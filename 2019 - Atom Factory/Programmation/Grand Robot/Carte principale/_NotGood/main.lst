CCS PCD C Compiler, Version 5.074, 38375               23-oct.-18 08:04

               Filename:   D:\Années\2019 - Atom Factory\Programmation\Grand Robot\Carte principale\main.lst

               ROM used:   41504 bytes (42%)
                           Largest free fragment is 32768
               RAM used:   6862 (85%) at main() level
                           7230 (89%) worst case
               Stack used: 176 locations (114 in main + 62 for interrupts)
               Stack size: 2048

*
00000:  GOTO    986C
*
0001A:  DATA    B2,0A,00
00020:  DATA    58,05,00
00022:  DATA    A6,0B,00
00026:  DATA    DA,08,00
*
00044:  DATA    7E,05,00
.................... /* 
.................... ==================================================================================================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*==================================================================================================== 
.................... =											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy				  												== 
.................... ===  Date				: 8.6.2017																	== 
.................... ===  Nom du programme 	: InterfaceRoboteQ.mcp (fichier main.c)										== 
.................... ===  Version 			: V2.0.0.0.0																== 
.................... =====================================================================================================*/ 
....................  
.................... #include <30F6014A.h> 
.................... //////////// Standard Header file for the DSPIC30F6014A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014A 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    52,45,00
0010E:  DATA    53,45,00
00110:  DATA    54,20,00
00112:  DATA    33,32,00
00114:  DATA    31,36,00
00116:  DATA    35,34,00
00118:  DATA    39,38,00
0011A:  DATA    37,20,00
0011C:  DATA    0D,00,00
0011E:  CLR     32
00120:  MOV     #12A,W3
00122:  ADD     W3,W0,W0
00124:  TBLRDL.B[W0],W0L
00126:  CLR.B   1
00128:  RETURN  
0012A:  DATA    7E,4B,00
0012C:  DATA    50,20,00
0012E:  DATA    31,20,00
00130:  DATA    0D,00,00
00132:  CLR     32
00134:  MOV     #13E,W3
00136:  ADD     W3,W0,W0
00138:  TBLRDL.B[W0],W0L
0013A:  CLR.B   1
0013C:  RETURN  
0013E:  DATA    7E,4B,00
00140:  DATA    49,20,00
00142:  DATA    31,20,00
00144:  DATA    0D,00,00
00146:  CLR     32
00148:  MOV     #152,W3
0014A:  ADD     W3,W0,W0
0014C:  TBLRDL.B[W0],W0L
0014E:  CLR.B   1
00150:  RETURN  
00152:  DATA    7E,4B,00
00154:  DATA    44,20,00
00156:  DATA    31,20,00
00158:  DATA    0D,00,00
0015A:  CLR     32
0015C:  MOV     #166,W3
0015E:  ADD     W3,W0,W0
00160:  TBLRDL.B[W0],W0L
00162:  CLR.B   1
00164:  RETURN  
00166:  DATA    7E,4B,00
00168:  DATA    50,20,00
0016A:  DATA    32,20,00
0016C:  DATA    0D,00,00
0016E:  CLR     32
00170:  MOV     #17A,W3
00172:  ADD     W3,W0,W0
00174:  TBLRDL.B[W0],W0L
00176:  CLR.B   1
00178:  RETURN  
0017A:  DATA    7E,4B,00
0017C:  DATA    49,20,00
0017E:  DATA    32,20,00
00180:  DATA    0D,00,00
00182:  CLR     32
00184:  MOV     #18E,W3
00186:  ADD     W3,W0,W0
00188:  TBLRDL.B[W0],W0L
0018A:  CLR.B   1
0018C:  RETURN  
0018E:  DATA    7E,4B,00
00190:  DATA    44,20,00
00192:  DATA    32,20,00
00194:  DATA    0D,00,00
00196:  CLR     32
00198:  MOV     #1A2,W3
0019A:  ADD     W3,W0,W0
0019C:  TBLRDL.B[W0],W0L
0019E:  CLR.B   1
001A0:  RETURN  
001A2:  DATA    7E,4D,00
001A4:  DATA    41,43,00
001A6:  DATA    20,31,00
001A8:  DATA    20,0D,00
001AA:  DATA    00,00,00
001AC:  CLR     32
001AE:  MOV     #1B8,W3
001B0:  ADD     W3,W0,W0
001B2:  TBLRDL.B[W0],W0L
001B4:  CLR.B   1
001B6:  RETURN  
001B8:  DATA    7E,4D,00
001BA:  DATA    44,45,00
001BC:  DATA    43,20,00
001BE:  DATA    31,20,00
001C0:  DATA    0D,00,00
001C2:  CLR     32
001C4:  MOV     #1CE,W3
001C6:  ADD     W3,W0,W0
001C8:  TBLRDL.B[W0],W0L
001CA:  CLR.B   1
001CC:  RETURN  
001CE:  DATA    7E,4D,00
001D0:  DATA    41,43,00
001D2:  DATA    20,32,00
001D4:  DATA    20,0D,00
001D6:  DATA    00,00,00
001D8:  CLR     32
001DA:  MOV     #1E4,W3
001DC:  ADD     W3,W0,W0
001DE:  TBLRDL.B[W0],W0L
001E0:  CLR.B   1
001E2:  RETURN  
001E4:  DATA    7E,4D,00
001E6:  DATA    44,45,00
001E8:  DATA    43,20,00
001EA:  DATA    32,20,00
001EC:  DATA    0D,00,00
001EE:  CLR     32
001F0:  MOV     #26,W3
001F2:  SUB     W0,W3,W3
001F4:  BRA     C,200
001F6:  MOV     #20A,W3
001F8:  ADD     W3,W0,W0
001FA:  TBLRDL.B[W0],W0L
001FC:  CLR.B   1
001FE:  RETURN  
00200:  MOV     #20A,W0
00202:  ADD     W3,W3,W3
00204:  ADD     W3,W0,W3
00206:  TBLRDH  [W3],W0
00208:  RETURN  
0020A:  DATA    5E,4B,49
0020C:  DATA    50,20,20
0020E:  DATA    31,20,32
00210:  DATA    25,75,20
00212:  DATA    5F,5E,25
00214:  DATA    4B,49,75
00216:  DATA    20,31,5F
00218:  DATA    20,25,5E
0021A:  DATA    75,5F,4B
0021C:  DATA    5E,4B,44
0021E:  DATA    44,20,20
00220:  DATA    31,20,32
00222:  DATA    25,75,20
00224:  DATA    5F,5E,25
00226:  DATA    4B,50,75
00228:  DATA    20,32,20
0022A:  DATA    20,25,0D
0022C:  DATA    75,5F,00
0022E:  DATA    5E,4B,00
00230:  CLR     32
00232:  MOV     #1E,W3
00234:  SUB     W0,W3,W3
00236:  BRA     C,242
00238:  MOV     #24C,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  MOV     #24C,W0
00244:  ADD     W3,W3,W3
00246:  ADD     W3,W0,W3
00248:  TBLRDH  [W3],W0
0024A:  RETURN  
0024C:  DATA    5E,4D,5F
0024E:  DATA    41,43,5E
00250:  DATA    20,31,4D
00252:  DATA    20,25,44
00254:  DATA    75,5F,45
00256:  DATA    5E,4D,43
00258:  DATA    44,45,20
0025A:  DATA    43,20,32
0025C:  DATA    31,20,20
0025E:  DATA    25,75,25
00260:  DATA    5F,5E,75
00262:  DATA    4D,41,20
00264:  DATA    43,20,0D
00266:  DATA    32,20,00
00268:  DATA    25,75,00
0026A:  CLR     32
0026C:  MOV     #276,W3
0026E:  ADD     W3,W0,W0
00270:  TBLRDL.B[W0],W0L
00272:  CLR.B   1
00274:  RETURN  
00276:  DATA    45,45,00
00278:  DATA    53,41,00
0027A:  DATA    56,20,00
0027C:  DATA    0D,00,00
0027E:  CLR     32
00280:  MOV     #28A,W3
00282:  ADD     W3,W0,W0
00284:  TBLRDL.B[W0],W0L
00286:  CLR.B   1
00288:  RETURN  
0028A:  DATA    3F,44,00
0028C:  DATA    52,0D,00
0028E:  DATA    00,00,00
00290:  CLR     32
00292:  MOV     #29C,W3
00294:  ADD     W3,W0,W0
00296:  TBLRDL.B[W0],W0L
00298:  CLR.B   1
0029A:  RETURN  
0029C:  DATA    3F,41,00
0029E:  DATA    20,31,00
002A0:  DATA    0D,00,00
002A2:  CLR     32
002A4:  MOV     #2AE,W3
002A6:  ADD     W3,W0,W0
002A8:  TBLRDL.B[W0],W0L
002AA:  CLR.B   1
002AC:  RETURN  
002AE:  DATA    3F,41,00
002B0:  DATA    20,32,00
002B2:  DATA    0D,00,00
002B4:  CLR     32
002B6:  MOV     #2C0,W3
002B8:  ADD     W3,W0,W0
002BA:  TBLRDL.B[W0],W0L
002BC:  CLR.B   1
002BE:  RETURN  
002C0:  DATA    21,53,00
002C2:  DATA    20,31,00
002C4:  DATA    20,25,00
002C6:  DATA    30,34,00
002C8:  DATA    75,5F,00
002CA:  DATA    21,53,00
002CC:  DATA    20,32,00
002CE:  DATA    20,25,00
002D0:  DATA    30,34,00
002D2:  DATA    75,20,00
002D4:  DATA    0D,00,00
002D6:  CLR     32
002D8:  MOV     #2E2,W3
002DA:  ADD     W3,W0,W0
002DC:  TBLRDL.B[W0],W0L
002DE:  CLR.B   1
002E0:  RETURN  
002E2:  DATA    21,50,00
002E4:  DATA    52,20,00
002E6:  DATA    31,20,00
002E8:  DATA    25,64,00
002EA:  DATA    5F,21,00
002EC:  DATA    50,52,00
002EE:  DATA    20,32,00
002F0:  DATA    20,25,00
002F2:  DATA    64,20,00
002F4:  DATA    0D,00,00
002F6:  CLR     32
002F8:  MOV     #302,W3
002FA:  ADD     W3,W0,W0
002FC:  TBLRDL.B[W0],W0L
002FE:  CLR.B   1
00300:  RETURN  
00302:  DATA    21,53,00
00304:  DATA    20,31,00
00306:  DATA    20,33,00
00308:  DATA    30,30,00
0030A:  DATA    5F,21,00
0030C:  DATA    53,20,00
0030E:  DATA    32,20,00
00310:  DATA    33,30,00
00312:  DATA    30,0D,00
00314:  DATA    00,00,00
00316:  CLR     32
00318:  MOV     #322,W3
0031A:  ADD     W3,W0,W0
0031C:  TBLRDL.B[W0],W0L
0031E:  CLR.B   1
00320:  RETURN  
00322:  DATA    21,50,00
00324:  DATA    52,20,00
00326:  DATA    31,20,00
00328:  DATA    31,5F,00
0032A:  DATA    21,50,00
0032C:  DATA    52,20,00
0032E:  DATA    32,20,00
00330:  DATA    31,0D,00
00332:  DATA    00,00,00
00334:  CLR     32
00336:  MOV     #340,W3
00338:  ADD     W3,W0,W0
0033A:  TBLRDL.B[W0],W0L
0033C:  CLR.B   1
0033E:  RETURN  
00340:  DATA    21,50,00
00342:  DATA    52,20,00
00344:  DATA    31,20,00
00346:  DATA    25,30,00
00348:  DATA    37,64,00
0034A:  DATA    5F,21,00
0034C:  DATA    50,52,00
0034E:  DATA    20,32,00
00350:  DATA    20,25,00
00352:  DATA    30,37,00
00354:  DATA    64,20,00
00356:  DATA    0D,00,00
00358:  CLR     32
0035A:  MOV     #364,W3
0035C:  ADD     W3,W0,W0
0035E:  TBLRDL.B[W0],W0L
00360:  CLR.B   1
00362:  RETURN  
00364:  DATA    21,4D,00
00366:  DATA    53,20,00
00368:  DATA    31,0D,00
0036A:  DATA    00,00,00
0036C:  CLR     32
0036E:  MOV     #378,W3
00370:  ADD     W3,W0,W0
00372:  TBLRDL.B[W0],W0L
00374:  CLR.B   1
00376:  RETURN  
00378:  DATA    21,4D,00
0037A:  DATA    53,20,00
0037C:  DATA    32,0D,00
0037E:  DATA    00,00,00
00380:  CLR     32
00382:  MOV     #38C,W3
00384:  ADD     W3,W0,W0
00386:  TBLRDL.B[W0],W0L
00388:  CLR.B   1
0038A:  RETURN  
0038C:  DATA    5E,4D,00
0038E:  DATA    4D,4F,00
00390:  DATA    44,20,00
00392:  DATA    31,20,00
00394:  DATA    30,5F,00
00396:  DATA    5E,4D,00
00398:  DATA    4D,4F,00
0039A:  DATA    44,20,00
0039C:  DATA    32,20,00
0039E:  DATA    30,0D,00
003A0:  DATA    00,00,00
003A2:  CLR     32
003A4:  MOV     #3AE,W3
003A6:  ADD     W3,W0,W0
003A8:  TBLRDL.B[W0],W0L
003AA:  CLR.B   1
003AC:  RETURN  
003AE:  DATA    5E,4D,00
003B0:  DATA    4D,4F,00
003B2:  DATA    44,20,00
003B4:  DATA    31,20,00
003B6:  DATA    33,5F,00
003B8:  DATA    5E,4D,00
003BA:  DATA    4D,4F,00
003BC:  DATA    44,20,00
003BE:  DATA    32,20,00
003C0:  DATA    33,0D,00
003C2:  DATA    00,00,00
003C4:  CLR     32
003C6:  MOV     #3D0,W3
003C8:  ADD     W3,W0,W0
003CA:  TBLRDL.B[W0],W0L
003CC:  CLR.B   1
003CE:  RETURN  
003D0:  DATA    43,61,00
003D2:  DATA    72,74,00
003D4:  DATA    65,20,00
003D6:  DATA    50,72,00
003D8:  DATA    69,6E,00
003DA:  DATA    63,69,00
003DC:  DATA    70,61,00
003DE:  DATA    6C,65,00
003E0:  DATA    20,3A,00
003E2:  DATA    20,43,00
003E4:  DATA    6F,6D,00
003E6:  DATA    6D,61,00
003E8:  DATA    6E,64,00
003EA:  DATA    65,20,00
003EC:  DATA    49,6E,00
003EE:  DATA    63,6F,00
003F0:  DATA    6E,6E,00
003F2:  DATA    75,65,00
003F4:  DATA    0D,00,00
003F6:  CLR     32
003F8:  MOV     #402,W3
003FA:  ADD     W3,W0,W0
003FC:  TBLRDL.B[W0],W0L
003FE:  CLR.B   1
00400:  RETURN  
00402:  DATA    21,4D,00
00404:  DATA    47,0D,00
00406:  DATA    00,00,00
00408:  CLR     32
0040A:  MOV     #414,W3
0040C:  ADD     W3,W0,W0
0040E:  TBLRDL.B[W0],W0L
00410:  CLR.B   1
00412:  RETURN  
00414:  DATA    5E,4D,00
00416:  DATA    44,45,00
00418:  DATA    43,20,00
0041A:  DATA    31,20,00
0041C:  DATA    39,30,00
0041E:  DATA    30,30,00
00420:  DATA    5F,5E,00
00422:  DATA    4D,44,00
00424:  DATA    45,43,00
00426:  DATA    20,32,00
00428:  DATA    20,39,00
0042A:  DATA    30,30,00
0042C:  DATA    30,0D,00
0042E:  DATA    00,00,00
00430:  CLR     32
00432:  MOV     #43C,W3
00434:  ADD     W3,W0,W0
00436:  TBLRDL.B[W0],W0L
00438:  CLR.B   1
0043A:  RETURN  
0043C:  DATA    21,53,00
0043E:  DATA    20,31,00
00440:  DATA    20,30,00
00442:  DATA    5F,21,00
00444:  DATA    53,20,00
00446:  DATA    32,20,00
00448:  DATA    30,0D,00
0044A:  DATA    00,00,00
0044C:  CLR     32
0044E:  MOV     #458,W3
00450:  ADD     W3,W0,W0
00452:  TBLRDL.B[W0],W0L
00454:  CLR.B   1
00456:  RETURN  
00458:  DATA    5E,4D,00
0045A:  DATA    44,45,00
0045C:  DATA    43,20,00
0045E:  DATA    31,20,00
00460:  DATA    36,30,00
00462:  DATA    30,30,00
00464:  DATA    5F,5E,00
00466:  DATA    4D,44,00
00468:  DATA    45,43,00
0046A:  DATA    20,32,00
0046C:  DATA    20,36,00
0046E:  DATA    30,30,00
00470:  DATA    30,0D,00
00472:  DATA    00,00,00
00474:  CLR     32
00476:  MOV     #480,W3
00478:  ADD     W3,W0,W0
0047A:  TBLRDL.B[W0],W0L
0047C:  CLR.B   1
0047E:  RETURN  
00480:  DATA    21,53,00
00482:  DATA    20,31,00
00484:  DATA    20,25,00
00486:  DATA    75,5F,00
00488:  DATA    21,53,00
0048A:  DATA    20,32,00
0048C:  DATA    20,25,00
0048E:  DATA    75,0D,00
00490:  DATA    00,00,00
00492:  CLR     32
00494:  MOV     #49E,W3
00496:  ADD     W3,W0,W0
00498:  TBLRDL.B[W0],W0L
0049A:  CLR.B   1
0049C:  RETURN  
0049E:  DATA    21,45,00
004A0:  DATA    58,20,00
004A2:  DATA    0D,00,00
*
00628:  MOV     W5,[W15++]
0062A:  MOV     #C,W5
0062C:  REPEAT  #3
0062E:  MOV     [W5++],[W15++]
00630:  MUL.UU  W0,W2,W4
00632:  BTSS    W3.F
00634:  BRA     63A
00636:  MUL.SS  W0,W3,W6
00638:  BRA     63C
0063A:  MUL.UU  W0,W3,W6
0063C:  BCLR.B  42.0
0063E:  ADD     W6,W5,W5
00640:  ADDC    W7,#0,W8
00642:  BTSS    W1.F
00644:  BRA     64A
00646:  MUL.SS  W1,W2,W6
00648:  BRA     64C
0064A:  MUL.UU  W1,W2,W6
0064C:  ADDC    W6,W5,W5
0064E:  ADDC    W7,W8,W8
00650:  ADDC    #0,W9
00652:  MUL.SS  W1,W3,W6
00654:  ADDC    W6,W8,W8
00656:  ADDC    W9,W7,W7
00658:  MOV     W7,W3
0065A:  MOV     W8,W2
0065C:  MOV     W5,W1
0065E:  MOV     W4,W0
00660:  MOV     #12,W5
00662:  REPEAT  #3
00664:  MOV     [--W15],[W5--]
00666:  MOV     [--W15],W5
00668:  RETURN  
*
00A5E:  MOV     W5,[W15++]
00A60:  MOV     #C,W5
00A62:  REPEAT  #3
00A64:  MOV     [W5++],[W15++]
00A66:  MOV     #0,W9
00A68:  BTSC.B  43.0
00A6A:  MOV     #1,W9
00A6C:  MOV     W9,[W15++]
00A6E:  CLR     W4
00A70:  CLR     W5
00A72:  CLR     W6
00A74:  CLR     W7
00A76:  XOR     W2,W3,W8
00A78:  BRA     Z,A9C
00A7A:  MOV     #20,W8
00A7C:  BCLR.B  42.0
00A7E:  RLC     W0,W0
00A80:  RLC     W1,W1
00A82:  RLC     W4,W4
00A84:  RLC     W5,W5
00A86:  CP      W5,W3
00A88:  BRA     NZ,A8C
00A8A:  CPB     W4,W2
00A8C:  BRA     NC,A94
00A8E:  SUB     W4,W2,W4
00A90:  SUBB    W5,W3,W5
00A92:  BSET.B  42.0
00A94:  RLC     W6,W6
00A96:  RLC     W7,W7
00A98:  DEC     W8,W8
00A9A:  BRA     NZ,A7C
00A9C:  MOV     W7,W1
00A9E:  MOV     W6,W0
00AA0:  MOV     [--W15],W9
00AA2:  CP0     W9
00AA4:  BRA     Z,AA8
00AA6:  MOV.D   W4,W0
00AA8:  MOV     #12,W5
00AAA:  REPEAT  #3
00AAC:  MOV     [--W15],[W5--]
00AAE:  MOV     [--W15],W5
00AB0:  RETURN  
*
00BCC:  MOV     W8,[W15++]
00BCE:  MOV     #12,W8
00BD0:  REPEAT  #4
00BD2:  MOV     [W8++],[W15++]
00BD4:  CLR     W11
00BD6:  MUL.UU  W12,#0,W12
00BD8:  MOV     W3,W8
00BDA:  MOV     W7,W9
00BDC:  MOV     #7FF,W10
00BDE:  BCLR.B  42.0
00BE0:  BCLR.B  42.1
00BE2:  ASR     W8,#4,W8
00BE4:  AND     W10,W8,W8
00BE6:  CP0     W8
00BE8:  BRA     Z,CCC
00BEA:  BCLR.B  42.0
00BEC:  BCLR.B  42.1
00BEE:  ASR     W9,#4,W9
00BF0:  AND     W10,W9,W9
00BF2:  CP0     W9
00BF4:  BRA     Z,CCC
00BF6:  ADD     W9,W8,W8
00BF8:  BTSC    W9.B
00BFA:  BRA     C04
00BFC:  SUB     #3FF,W8
00BFE:  BRA     Z,CCC
00C00:  BRA     NC,CCC
00C02:  BRA     C0A
00C04:  MOV     #401,W10
00C06:  ADD.B   W10L,W5L,W5L
00C08:  BRA     C,CCC
00C0A:  XOR     W3,W7,W13
00C0C:  BCLR.B  42.0
00C0E:  BCLR.B  42.1
00C10:  AND     #F,W3
00C12:  BSET    W3.4
00C14:  AND     #F,W7
00C16:  BSET    W7.4
00C18:  MOV     W8,[W15++]
00C1A:  MUL.UU  W4,W1,W8
00C1C:  MUL.UU  W5,W0,W10
00C1E:  ADD     W8,W10,W10
00C20:  ADDC    W9,W11,W11
00C22:  ADDC    #0,W12
00C24:  MUL.UU  W4,W2,W8
00C26:  ADD     W8,W11,W11
00C28:  ADDC    W9,W12,W12
00C2A:  MUL.UU  W5,W1,W8
00C2C:  CLR     W10
00C2E:  ADD     W8,W11,W11
00C30:  ADDC    W9,W12,W12
00C32:  ADDC    #0,W10
00C34:  MUL.UU  W6,W0,W8
00C36:  ADD     W8,W11,W11
00C38:  ADDC    W9,W12,W12
00C3A:  ADDC    #0,W10
00C3C:  CLR     W11
00C3E:  MUL.UU  W4,W3,W8
00C40:  ADD     W8,W12,W12
00C42:  ADDC    W9,W10,W10
00C44:  ADDC    #0,W11
00C46:  MUL.UU  W5,W2,W8
00C48:  ADD     W8,W12,W12
00C4A:  ADDC    W9,W10,W10
00C4C:  ADDC    #0,W11
00C4E:  MUL.UU  W6,W1,W8
00C50:  ADD     W8,W12,W12
00C52:  ADDC    W9,W10,W10
00C54:  ADDC    #0,W11
00C56:  MUL.UU  W7,W0,W8
00C58:  ADD     W8,W12,W12
00C5A:  ADDC    W9,W10,W10
00C5C:  ADDC    #0,W11
00C5E:  MOV     W12,W0
00C60:  CLR     W12
00C62:  MUL.UU  W5,W3,W8
00C64:  ADD     W8,W10,W10
00C66:  ADDC    W9,W11,W11
00C68:  ADDC    #0,W12
00C6A:  MUL.UU  W6,W2,W8
00C6C:  ADD     W8,W10,W10
00C6E:  ADDC    W9,W11,W11
00C70:  ADDC    #0,W12
00C72:  MUL.UU  W6,W3,W8
00C74:  ADD     W8,W11,W11
00C76:  ADDC    W9,W12,W12
00C78:  MUL.UU  W7,W1,W8
00C7A:  ADD     W8,W10,W10
00C7C:  ADDC    W9,W11,W11
00C7E:  ADDC    #0,W12
00C80:  MUL.UU  W7,W2,W8
00C82:  ADD     W8,W11,W11
00C84:  ADDC    W9,W12,W12
00C86:  MUL.UU  W7,W3,W8
00C88:  ADD     W8,W12,W12
00C8A:  MOV     W10,W1
00C8C:  MOV     W11,W2
00C8E:  MOV     W12,W3
00C90:  MOV     #5,W4
00C92:  BCLR.B  42.0
00C94:  RRC     W3,W3
00C96:  RRC     W2,W2
00C98:  RRC     W1,W1
00C9A:  RRC     W0,W0
00C9C:  DEC     W4,W4
00C9E:  BRA     NZ,C92
00CA0:  MOV     [--W15],W8
00CA2:  INC     W8,W8
00CA4:  IOR      W0,  W1,W6
00CA6:  BRA     Z,CAA
00CA8:  BRA     CAE
00CAA:  IOR      W2,  W3,W6
00CAC:  BRA     Z,CBE
00CAE:  BTSC    W3.4
00CB0:  BRA     CBE
00CB2:  BCLR.B  42.0
00CB4:  RLC     W0,W0
00CB6:  RLC     W1,W1
00CB8:  RLC     W2,W2
00CBA:  RLC     W3,W3
00CBC:  DEC     W8,W8
00CBE:  SL      W8,#4,W8
00CC0:  BCLR    W3.F
00CC2:  BTSC    W13.F
00CC4:  BSET    W3.F
00CC6:  BCLR    W3.4
00CC8:  XOR     W8,W3,W3
00CCA:  BRA     CD2
00CCC:  MUL.UU  W0,#0,W0
00CCE:  MUL.UU  W0,#0,W2
00CD0:  BRA     CD2
00CD2:  MOV     #1A,W8
00CD4:  REPEAT  #4
00CD6:  MOV     [--W15],[W8--]
00CD8:  MOV     [--W15],W8
00CDA:  RETURN  
00CDC:  MOV     W8,[W15++]
00CDE:  MOV     #12,W8
00CE0:  REPEAT  #4
00CE2:  MOV     [W8++],[W15++]
00CE4:  XOR     W3,W7,W13
00CE6:  MOV     W3,W8
00CE8:  MOV     W7,W9
00CEA:  MOV     #7FF,W10
00CEC:  BCLR.B  42.0
00CEE:  BCLR.B  42.1
00CF0:  ASR     W8,#4,W8
00CF2:  AND     W10,W8,W8
00CF4:  CP0     W8
00CF6:  BRA     Z,DD0
00CF8:  BCLR.B  42.0
00CFA:  BCLR.B  42.1
00CFC:  ASR     W9,#4,W9
00CFE:  AND     W10,W9,W9
00D00:  CP0     W9
00D02:  BRA     Z,DD0
00D04:  CLR     W10
00D06:  SUB     W8,W9,W12
00D08:  BRA     NC,D10
00D0A:  ADD     #3FF,W12
00D0C:  BRA     C,DD0
00D0E:  BRA     D18
00D10:  MOV     #401,W11
00D12:  SUB     W12,W11,W12
00D14:  BRA     NC,DD0
00D16:  BRA     Z,DD0
00D18:  CLR     W8
00D1A:  CLR     W9
00D1C:  CLR     W10
00D1E:  CLR     W11
00D20:  AND     #1F,W3
00D22:  BSET    W3.4
00D24:  AND     #1F,W7
00D26:  BSET    W7.4
00D28:  MOV     W12,[W15++]
00D2A:  MOV     #36,W12
00D2C:  SUB     W0,W4,W0
00D2E:  SUBB    W1,W5,W1
00D30:  SUBB    W2,W6,W2
00D32:  SUBB    W3,W7,W3
00D34:  BRA     N,D3A
00D36:  BRA     C,D44
00D38:  BRA     NZ,D46
00D3A:  ADD     W0,W4,W0
00D3C:  ADDC    W1,W5,W1
00D3E:  ADDC    W2,W6,W2
00D40:  ADDC    W3,W7,W3
00D42:  BRA     D46
00D44:  BSET    W8.0
00D46:  DEC     W12,W12
00D48:  BRA     Z,D60
00D4A:  BCLR.B  42.0
00D4C:  RLC     W0,W0
00D4E:  RLC     W1,W1
00D50:  RLC     W2,W2
00D52:  RLC     W3,W3
00D54:  BCLR.B  42.0
00D56:  RLC     W8,W8
00D58:  RLC     W9,W9
00D5A:  RLC     W10,W10
00D5C:  RLC     W11,W11
00D5E:  BRA     D2C
00D60:  MOV     [--W15],W12
00D62:  BTSC    W11.5
00D64:  BRA     D68
00D66:  BRA     D74
00D68:  BCLR.B  42.0
00D6A:  RRC     W11,W11
00D6C:  RRC     W10,W10
00D6E:  RRC     W9,W9
00D70:  RRC     W8,W8
00D72:  BRA     D7A
00D74:  DEC     W12,W12
00D76:  BCLR.B  42.0
00D78:  BRA     Z,DD0
00D7A:  BTSC.B  42.0
00D7C:  BRA     D90
00D7E:  RLC     W0,W0
00D80:  RLC     W1,W1
00D82:  RLC     W2,W2
00D84:  RLC     W3,W3
00D86:  SUB     W0,W4,W4
00D88:  SUBB    W1,W5,W5
00D8A:  SUBB    W2,W6,W6
00D8C:  SUBB    W3,W7,W7
00D8E:  BRA     NC,DBA
00D90:  INC     W8,W8
00D92:  BRA     NZ,DBA
00D94:  INC     W9,W9
00D96:  BRA     NZ,DBA
00D98:  INC     W10,W10
00D9A:  BRA     NZ,DBA
00D9C:  INC     W11,W11
00D9E:  BRA     NZ,DBA
00DA0:  INC     W12,W12
00DA2:  BRA     Z,DD0
00DA4:  BRA     DBA
00DA6:  DEC     W12,W12
00DA8:  BRA     Z,DD0
00DAA:  BTSC    W11.4
00DAC:  BRA     DBA
00DAE:  BCLR.B  42.0
00DB0:  RLC     W8,W8
00DB2:  RLC     W9,W9
00DB4:  RLC     W10,W10
00DB6:  RLC     W11,W11
00DB8:  BRA     DAA
00DBA:  SL      W12,#4,W12
00DBC:  BCLR.B  42.0
00DBE:  BCLR    W12.F
00DC0:  BTSC    W13.F
00DC2:  BSET    W12.F
00DC4:  BCLR    W11.4
00DC6:  XOR     W12,W11,W3
00DC8:  MOV     W10,W2
00DCA:  MOV     W9,W1
00DCC:  MOV     W8,W0
00DCE:  BRA     DDA
00DD0:  MOV     #0,W0
00DD2:  MOV     #0,W1
00DD4:  MOV     #0,W2
00DD6:  MOV     #0,W3
00DD8:  BRA     DDA
00DDA:  MOV     #1A,W8
00DDC:  REPEAT  #4
00DDE:  MOV     [--W15],[W8--]
00DE0:  MOV     [--W15],W8
00DE2:  RETURN  
*
01236:  MOV     #F000,W1
01238:  ADD     W1,W3,W3
0123A:  MOV     #7F,W1
0123C:  ADDC    W1,#0,W1
0123E:  MOV     W1,32
01240:  BCLR    W5.0
01242:  CP0     W5
01244:  BRA     Z,124C
01246:  TBLRDL  [W3++],[W4++]
01248:  DEC2    W5,W5
0124A:  BRA     NZ,1244
0124C:  RETURN  
*
012E8:  MOV     W5,[W15++]
012EA:  MOV     #C,W5
012EC:  REPEAT  #3
012EE:  MOV     [W5++],[W15++]
012F0:  MOV     W0,W4
012F2:  MOV     W1,W5
012F4:  MOV     W2,W6
012F6:  MOV     W3,W7
012F8:  CLR     W0
012FA:  CLR     W1
012FC:  CLR     W2
012FE:  CLR     W3
01300:  BCLR    W8.0
01302:  BTSS    W7.F
01304:  BRA     1316
01306:  BSET    W8.0
01308:  COM     W7,W7
0130A:  COM     W6,W6
0130C:  COM     W5,W5
0130E:  NEG     W4,W4
01310:  ADDC    W5,#0,W5
01312:  ADDC    W6,#0,W6
01314:  ADDC    W7,#0,W7
01316:  IOR      W4,  W5,W9
01318:  BRA     NZ,131E
0131A:  IOR      W6,  W7,W9
0131C:  BRA     Z,1348
0131E:  MOV     #473,W9
01320:  BTSC    W3.4
01322:  BRA     133A
01324:  BCLR.B  42.0
01326:  RLC     W4,W4
01328:  RLC     W5,W5
0132A:  RLC     W6,W6
0132C:  RLC     W7,W7
0132E:  RLC     W0,W0
01330:  RLC     W1,W1
01332:  RLC     W2,W2
01334:  RLC     W3,W3
01336:  DEC     W9,W9
01338:  BRA     NZ,1320
0133A:  SL      W9,#4,W9
0133C:  BCLR.B  42.0
0133E:  BCLR    W9.F
01340:  BCLR    W3.4
01342:  XOR     W9,W3,W3
01344:  BTSC    W8.0
01346:  BSET    W3.F
01348:  MOV     #12,W5
0134A:  REPEAT  #3
0134C:  MOV     [--W15],[W5--]
0134E:  MOV     [--W15],W5
01350:  RETURN  
*
013FC:  MOV     W8,[W15++]
013FE:  MOV     #12,W8
01400:  REPEAT  #4
01402:  MOV     [W8++],[W15++]
01404:  MOV     #8000,W8
01406:  BTSC.B  43.0
01408:  XOR     W8,W7,W7
0140A:  CP0     W0
0140C:  BRA     NZ,141C
0140E:  CP0     W1
01410:  BRA     NZ,141C
01412:  CP0     W2
01414:  BRA     NZ,141C
01416:  MOV     #7FFF,W10
01418:  AND     W3,W10,W10
0141A:  BTSS.B  42.1
0141C:  MOV     W3,W10
0141E:  XOR     W7,W10,W11
01420:  MOV     W3,W8
01422:  MOV     W7,W9
01424:  MOV     W7,W12
01426:  MOV     #7FF,W13
01428:  BCLR.B  42.1
0142A:  BCLR.B  42.0
0142C:  ASR     W8,#4,W8
0142E:  AND     W13,W8,W8
01430:  CP0     W8
01432:  BRA     Z,15AC
01434:  BCLR.B  42.1
01436:  BCLR.B  42.0
01438:  ASR     W9,#4,W9
0143A:  AND     W13,W9,W9
0143C:  CP0     W9
0143E:  BRA     Z,15BC
01440:  CLR     W13
01442:  BCLR.B  42.1
01444:  BCLR.B  42.0
01446:  CP      W9,W8
01448:  BRA     Z,15BE
0144A:  BRA     N,15CE
0144C:  BCLR    W13.0
0144E:  BSET    W13.1
01450:  SUB     W9,W8,W8
01452:  AND     #F,W3
01454:  BSET    W3.4
01456:  AND     #F,W7
01458:  BSET    W7.4
0145A:  SUB     #34,W8
0145C:  BRA     NN,148A
0145E:  ADD     #34,W8
01460:  BCLR.B  42.1
01462:  BCLR.B  42.0
01464:  RRC     W3,W3
01466:  RRC     W2,W2
01468:  RRC     W1,W1
0146A:  RRC     W0,W0
0146C:  DEC     W8,W8
0146E:  BRA     NZ,1460
01470:  BRA     149A
01472:  SUB     #34,W8
01474:  BRA     NN,1494
01476:  ADD     #34,W8
01478:  BCLR.B  42.1
0147A:  BCLR.B  42.0
0147C:  RRC     W7,W7
0147E:  RRC     W6,W6
01480:  RRC     W5,W5
01482:  RRC     W4,W4
01484:  DEC     W8,W8
01486:  BRA     NZ,1478
01488:  BRA     14C0
0148A:  MOV     W4,W0
0148C:  MOV     W5,W1
0148E:  MOV     W6,W2
01490:  MOV     W7,W3
01492:  XOR     W11,W12,W12
01494:  BTSC    W12.F
01496:  BTG     W11.F
01498:  BRA     158C
0149A:  BTSS    W11.F
0149C:  BRA     14DC
0149E:  BTSC    W13.4
014A0:  MOV     W12,W11
014A2:  COM     W0,W0
014A4:  COM     W1,W1
014A6:  COM     W2,W2
014A8:  COM.B   W3L,W3L
014AA:  AND.B   #1F,W3L
014AC:  INC     W0,W0
014AE:  BRA     NZ,14BA
014B0:  INC     W1,W1
014B2:  BRA     NZ,14BA
014B4:  INC     W2,W2
014B6:  BRA     NZ,14BA
014B8:  INC.B   W3L,W3L
014BA:  BTSC    W13.4
014BC:  BRA     1522
014BE:  BRA     14DC
014C0:  BTSS    W11.F
014C2:  BRA     14DC
014C4:  COM     W4,W4
014C6:  COM     W5,W5
014C8:  COM     W6,W6
014CA:  COM.B   W7L,W7L
014CC:  AND.B   #1F,W7L
014CE:  INC     W4,W4
014D0:  BRA     NZ,14DC
014D2:  INC     W5,W5
014D4:  BRA     NZ,14DC
014D6:  INC     W6,W6
014D8:  BRA     NZ,14DC
014DA:  INC.B   W7L,W7L
014DC:  BCLR.B  42.1
014DE:  BCLR.B  42.0
014E0:  ADD     W0,W4,W0
014E2:  ADDC    W1,W5,W1
014E4:  ADDC    W2,W6,W2
014E6:  ADDC.B  W3L,W7L,W3L
014E8:  BTSC    W3.5
014EA:  BSET    W13.3
014EC:  BTSC    W13.0
014EE:  BRA     1502
014F0:  BTSC    W13.1
014F2:  BRA     14F6
014F4:  BRA     150C
014F6:  BTSC    W11.F
014F8:  BRA     1522
014FA:  BTSC    W13.3
014FC:  BRA     1550
014FE:  BSET    W13.6
01500:  BRA     1544
01502:  BTSC    W11.F
01504:  BRA     1522
01506:  BTSC    W13.3
01508:  BRA     1550
0150A:  BRA     1544
0150C:  BTSC    W11.F
0150E:  BRA     1518
01510:  MOV     W10,W11
01512:  BTSC    W13.3
01514:  BRA     1550
01516:  BRA     158C
01518:  BSET    W13.4
0151A:  XOR.B   #10,W3L
0151C:  BTSC    W3.4
0151E:  BRA     149E
01520:  MOV     W10,W11
01522:  AND     #1F,W3
01524:  IOR      W3,  W2,W8
01526:  BRA     NZ,152C
01528:  IOR      W1,  W0,W8
0152A:  BRA     Z,1544
0152C:  BTSC    W3.4
0152E:  BRA     1544
01530:  BCLR.B  42.1
01532:  BCLR.B  42.0
01534:  RLC     W0,W0
01536:  RLC     W1,W1
01538:  RLC     W2,W2
0153A:  RLC     W3,W3
0153C:  DEC     W9,W9
0153E:  BTSC.B  42.1
01540:  BRA     15A6
01542:  BRA     152C
01544:  BTSC    W13.0
01546:  MOV     W10,W11
01548:  BTSC    W13.1
0154A:  MOV     W12,W11
0154C:  BTSS    W13.5
0154E:  BRA     158C
01550:  BCLR.B  42.0
01552:  RRC.B   W3L,W3L
01554:  RRC     W2,W2
01556:  RRC     W1,W1
01558:  RRC     W0,W0
0155A:  BTSC.B  42.0
0155C:  BSET    W13.5
0155E:  INC     W9,W9
01560:  BTSC.B  42.1
01562:  BRA     15A6
01564:  BTSS    W13.5
01566:  BRA     1584
01568:  INC     W0,W0
0156A:  BRA     NZ,1584
0156C:  INC     W1,W1
0156E:  BRA     NZ,1584
01570:  INC     W2,W2
01572:  BRA     NZ,1584
01574:  INC     W3,W3
01576:  BRA     NZ,1584
01578:  RRC.B   W3L,W3L
0157A:  RRC     W2,W2
0157C:  RRC     W1,W1
0157E:  RRC     W0,W0
01580:  INC     W9,W9
01582:  BRA     Z,15A6
01584:  BTSC    W13.0
01586:  MOV     W10,W11
01588:  BTSC    W13.1
0158A:  MOV     W12,W11
0158C:  IOR      W0,  W1,W4
0158E:  BRA     NZ,1594
01590:  IOR      W2,  W3,W4
01592:  BRA     Z,15E0
01594:  BCLR    W3.4
01596:  BCLR.B  42.1
01598:  BCLR.B  42.0
0159A:  SL      W9,#4,W9
0159C:  XOR     W9,W3,W3
0159E:  BSET    W3.F
015A0:  BTSS    W11.F
015A2:  BCLR    W3.F
015A4:  BRA     15E0
015A6:  MUL.UU  W0,#0,W0
015A8:  MUL.UU  W2,#0,W2
015AA:  BRA     15E0
015AC:  MOV     #8000,W8
015AE:  BTSC    W10.F
015B0:  XOR     W8,W7,W7
015B2:  MOV     W5,W1
015B4:  MOV     W4,W0
015B6:  MOV     W6,W2
015B8:  MOV     W7,W3
015BA:  BRA     15E0
015BC:  BRA     15E0
015BE:  AND     #F,W7
015C0:  BSET    W7.4
015C2:  AND     #F,W3
015C4:  BSET    W3.4
015C6:  BTSC    W11.F
015C8:  BCLR    W7.4
015CA:  BSET    W13.2
015CC:  BRA     14C0
015CE:  AND     #F,W3
015D0:  BSET    W3.4
015D2:  AND     #F,W7
015D4:  BSET    W7.4
015D6:  SUB     W8,W9,W8
015D8:  ADD     W8,W9,W9
015DA:  BCLR    W13.1
015DC:  BSET    W13.0
015DE:  BRA     1472
015E0:  MOV     #1A,W8
015E2:  REPEAT  #4
015E4:  MOV     [--W15],[W8--]
015E6:  MOV     [--W15],W8
015E8:  RETURN  
015EA:  MOV     W8,[W15++]
015EC:  MOV     W9,[W15++]
015EE:  MOV     W10,[W15++]
015F0:  XOR     W3,W7,W9
015F2:  BTSS    W9.F
015F4:  BRA     1602
015F6:  BCLR.B  42.0
015F8:  BCLR.B  42.1
015FA:  BTSS    W3.F
015FC:  BRA     1666
015FE:  BSET.B  42.0
01600:  BRA     1666
01602:  MOV     #7FF,W10
01604:  MOV     W3,W8
01606:  MOV     W7,W9
01608:  ASR     W8,#4,W8
0160A:  AND     W10,W8,W8
0160C:  ASR     W9,#4,W9
0160E:  AND     W10,W9,W9
01610:  SUB     W9,W8,W10
01612:  BRA     Z,161E
01614:  BTSS    W3.F
01616:  BRA     1666
01618:  MOV     #1,W0
0161A:  XOR.B   42
0161C:  BRA     1666
0161E:  MOV     W3,W8
01620:  MOV     W7,W9
01622:  AND     #1F,W3
01624:  AND     #1F,W7
01626:  BCLR    W3.4
01628:  BCLR    W7.4
0162A:  SUB.B   W7L,W3L,W10L
0162C:  BRA     Z,1638
0162E:  BTSS    W8.F
01630:  BRA     1666
01632:  MOV     #1,W0
01634:  XOR.B   42
01636:  BRA     1666
01638:  SUB     W6,W2,W10
0163A:  BRA     Z,1646
0163C:  BTSS    W8.F
0163E:  BRA     1666
01640:  MOV     #1,W0
01642:  XOR.B   42
01644:  BRA     1666
01646:  SUB     W5,W1,W10
01648:  BRA     Z,1654
0164A:  BTSS    W8.F
0164C:  BRA     1666
0164E:  MOV     #1,W0
01650:  XOR.B   42
01652:  BRA     1666
01654:  SUB     W4,W0,W10
01656:  BRA     Z,1662
01658:  BTSS    W8.F
0165A:  BRA     1666
0165C:  MOV     #1,W0
0165E:  XOR.B   42
01660:  BRA     1666
01662:  BCLR.B  42.0
01664:  BRA     1666
01666:  MOV     [--W15],W10
01668:  MOV     [--W15],W9
0166A:  MOV     [--W15],W8
0166C:  RETURN  
*
019EC:  MOV     W5,[W15++]
019EE:  MOV     #C,W5
019F0:  REPEAT  #5
019F2:  MOV     [W5++],[W15++]
019F4:  MOV     W3,W8
019F6:  MOV     W2,W7
019F8:  MOV     W1,W6
019FA:  MOV     W0,W5
019FC:  MOV     W3,W9
019FE:  MOV     #473,W11
01A00:  ASR     W3,#4,W3
01A02:  MOV     #7FF,W10
01A04:  AND     W10,W3,W3
01A06:  SUB     W11,W3,W11
01A08:  AND     #1F,W8
01A0A:  BSET    W8.4
01A0C:  CLR     W0
01A0E:  CLR     W1
01A10:  CLR     W2
01A12:  CLR     W3
01A14:  BCLR.B  42.0
01A16:  RRC     W8,W8
01A18:  RRC     W7,W7
01A1A:  RRC     W6,W6
01A1C:  RRC     W5,W5
01A1E:  RRC     W3,W3
01A20:  RRC     W2,W2
01A22:  RRC     W1,W1
01A24:  RRC     W0,W0
01A26:  DEC     W11,W11
01A28:  BRA     NZ,1A14
01A2A:  BTSS    W9.F
01A2C:  BRA     1A40
01A2E:  COM     W0,W0
01A30:  COM     W1,W1
01A32:  COM     W2,W2
01A34:  COM     W3,W3
01A36:  INC     W0,W0
01A38:  ADDC    #0,W1
01A3A:  ADDC    #0,W2
01A3C:  ADDC    #0,W3
01A3E:  BRA     1A40
01A40:  MOV     #16,W5
01A42:  REPEAT  #5
01A44:  MOV     [--W15],[W5--]
01A46:  MOV     [--W15],W5
01A48:  RETURN  
*
01AD2:  MOV     W5,[W15++]
01AD4:  MOV     #C,W5
01AD6:  REPEAT  #5
01AD8:  MOV     [W5++],[W15++]
01ADA:  MOV     W3,W8
01ADC:  MOV     W2,W7
01ADE:  MOV     W1,W6
01AE0:  MOV     W0,W5
01AE2:  MOV     W3,W9
01AE4:  MOV     #473,W11
01AE6:  ASR     W3,#4,W3
01AE8:  MOV     #7FF,W10
01AEA:  AND     W10,W3,W3
01AEC:  SUB     W11,W3,W11
01AEE:  AND     #1F,W8
01AF0:  BSET    W8.4
01AF2:  CLR     W0
01AF4:  CLR     W1
01AF6:  CLR     W2
01AF8:  CLR     W3
01AFA:  BCLR.B  42.0
01AFC:  RRC     W8,W8
01AFE:  RRC     W7,W7
01B00:  RRC     W6,W6
01B02:  RRC     W5,W5
01B04:  RRC     W3,W3
01B06:  RRC     W2,W2
01B08:  RRC     W1,W1
01B0A:  RRC     W0,W0
01B0C:  DEC     W11,W11
01B0E:  BRA     NZ,1AFA
01B10:  BTSS    W9.F
01B12:  BRA     1B26
01B14:  COM     W0,W0
01B16:  COM     W1,W1
01B18:  COM     W2,W2
01B1A:  COM     W3,W3
01B1C:  INC     W0,W0
01B1E:  ADDC    #0,W1
01B20:  ADDC    #0,W2
01B22:  ADDC    #0,W3
01B24:  BRA     1B26
01B26:  MOV     #16,W5
01B28:  REPEAT  #5
01B2A:  MOV     [--W15],[W5--]
01B2C:  MOV     [--W15],W5
01B2E:  RETURN  
01B30:  MOV     W5,[W15++]
01B32:  MOV     #C,W5
01B34:  REPEAT  #3
01B36:  MOV     [W5++],[W15++]
01B38:  MOV     W0,W4
01B3A:  MOV     W1,W5
01B3C:  MOV     W2,W6
01B3E:  MOV     W3,W7
01B40:  CLR     W0
01B42:  CLR     W1
01B44:  CLR     W2
01B46:  CLR     W3
01B48:  BCLR    W8.0
01B4A:  BTSS    W7.F
01B4C:  BRA     1B5E
01B4E:  BSET    W8.0
01B50:  COM     W7,W7
01B52:  COM     W6,W6
01B54:  COM     W5,W5
01B56:  NEG     W4,W4
01B58:  ADDC    W5,#0,W5
01B5A:  ADDC    W6,#0,W6
01B5C:  ADDC    W7,#0,W7
01B5E:  IOR      W4,  W5,W9
01B60:  BRA     NZ,1B66
01B62:  IOR      W6,  W7,W9
01B64:  BRA     Z,1B90
01B66:  MOV     #473,W9
01B68:  BTSC    W3.4
01B6A:  BRA     1B82
01B6C:  BCLR.B  42.0
01B6E:  RLC     W4,W4
01B70:  RLC     W5,W5
01B72:  RLC     W6,W6
01B74:  RLC     W7,W7
01B76:  RLC     W0,W0
01B78:  RLC     W1,W1
01B7A:  RLC     W2,W2
01B7C:  RLC     W3,W3
01B7E:  DEC     W9,W9
01B80:  BRA     NZ,1B68
01B82:  SL      W9,#4,W9
01B84:  BCLR.B  42.0
01B86:  BCLR    W9.F
01B88:  BCLR    W3.4
01B8A:  XOR     W9,W3,W3
01B8C:  BTSC    W8.0
01B8E:  BSET    W3.F
01B90:  MOV     #12,W5
01B92:  REPEAT  #3
01B94:  MOV     [--W15],[W5--]
01B96:  MOV     [--W15],W5
01B98:  RETURN  
*
06008:  MOV     W5,[W15++]
0600A:  MOV     W6,[W15++]
0600C:  MOV     W3,W4
0600E:  MOV     W3,W6
06010:  BCLR.B  42.0
06012:  ASR     W4,#4,W4
06014:  MOV     #7FF,W5
06016:  AND     W5,W4,W4
06018:  BRA     NZ,6020
0601A:  MUL.UU  W0,#0,W0
0601C:  CLR     W2
0601E:  BRA     6046
06020:  SUB     #380,W4
06022:  AND     #F,W3
06024:  MOV     #3,W7
06026:  BCLR.B  42.0
06028:  RLC     W0,W0
0602A:  RLC     W1,W1
0602C:  RLC     W2,W2
0602E:  RLC     W3,W3
06030:  DEC     W7,W7
06032:  BRA     NZ,6026
06034:  MOV     W1,W0
06036:  MOV     W2,W1
06038:  BCLR    W3.7
0603A:  SWAP    W4
0603C:  BCLR.B  42.0
0603E:  RRC     W4,W4
06040:  BTSC    W6.F
06042:  BSET    W4.F
06044:  XOR     W4,W3,W2
06046:  MOV     [--W15],W6
06048:  MOV     [--W15],W5
0604A:  RETURN  
0604C:  MOV     W5,[W15++]
0604E:  MOV     W6,[W15++]
06050:  MOV     W7,[W15++]
06052:  XOR     W1,W3,W4
06054:  BTSS    W4.F
06056:  BRA     6064
06058:  BCLR.B  42.0
0605A:  BCLR.B  42.1
0605C:  BTSS    W1.F
0605E:  BRA     60AC
06060:  BSET.B  42.0
06062:  BRA     60AC
06064:  MOV     W1,W4
06066:  MOV     W0,W5
06068:  MOV     W3,W6
0606A:  MOV     W2,W7
0606C:  RLC     W1,W1
0606E:  SWAP    W1
06070:  RLC     W3,W3
06072:  SWAP    W3
06074:  SUB.B   W3L,W1L,W1L
06076:  BRA     Z,6082
06078:  BTSS    W4.F
0607A:  BRA     60AC
0607C:  MOV     #1,W0
0607E:  XOR.B   42
06080:  BRA     60AC
06082:  MOV.B   W4L,W1L
06084:  MOV.B   W6L,W3L
06086:  BCLR    W1.7
06088:  BCLR    W3.7
0608A:  SUB.B   W3L,W1L,W1L
0608C:  BRA     Z,6098
0608E:  BTSS    W4.F
06090:  BRA     60AC
06092:  MOV     #1,W0
06094:  XOR.B   42
06096:  BRA     60AC
06098:  SUB     W7,W5,W1
0609A:  BRA     Z,60A6
0609C:  BTSS    W4.F
0609E:  BRA     60AC
060A0:  MOV     #1,W0
060A2:  XOR.B   42
060A4:  BRA     60AC
060A6:  BCLR.B  42.0
060A8:  BRA     60AC
060AA:  BRA     60AC
060AC:  MOV     [--W15],W7
060AE:  MOV     [--W15],W6
060B0:  MOV     [--W15],W5
060B2:  RETURN  
060B4:  MOV     W0,W2
060B6:  MOV     W1,W3
060B8:  MOV.B   W1L,W0L
060BA:  SWAP    W0
060BC:  BSET    W0.F
060BE:  RLC     W1,W1
060C0:  SWAP    W1
060C2:  ZE      W1,W1
060C4:  MOV     #8E,W4
060C6:  SUB.B   W4L,W1L,W1L
060C8:  BRA     Z,60D6
060CA:  CP0     W0
060CC:  BRA     Z,60D6
060CE:  BCLR.B  42.0
060D0:  RRC     W0,W0
060D2:  DEC     W1,W1
060D4:  BRA     NZ,60CA
060D6:  BTSS    W3.F
060D8:  BRA     60DE
060DA:  NEG     W0,W0
060DC:  BRA     60DE
060DE:  RETURN  
060E0:  MOV     W5,[W15++]
060E2:  MOV     W6,[W15++]
060E4:  MOV     #8E,W1
060E6:  CP0     W0
060E8:  BRA     Z,610E
060EA:  BTSC    W0.F
060EC:  BRA     60F6
060EE:  BCLR.B  42.0
060F0:  RLC     W0,W0
060F2:  DEC     W1,W1
060F4:  BRA     60EA
060F6:  SWAP    W1
060F8:  BCLR.B  42.0
060FA:  RRC     W1,W1
060FC:  BCLR    W0.F
060FE:  SWAP    W0
06100:  XOR.B   W0L,W1L,W1L
06102:  AND.B   #0,W0L
06104:  BRA     6114
06106:  MOV.B   W1L,W0L
06108:  BSET    W1.7
0610A:  AND.B   #0,W1L
0610C:  BRA     6114
0610E:  CLR     W0
06110:  CLR     W1
06112:  BRA     6114
06114:  MOV     [--W15],W6
06116:  MOV     [--W15],W5
06118:  RETURN  
0611A:  MOV     W5,[W15++]
0611C:  MOV     #C,W5
0611E:  REPEAT  #4
06120:  MOV     [W5++],[W15++]
06122:  MOV     W0,W4
06124:  MOV     W1,W5
06126:  MOV     W3,W7
06128:  MOV     W2,W6
0612A:  BCLR.B  42.0
0612C:  BCLR.B  42.1
0612E:  RLC     W1,W1
06130:  SWAP    W1
06132:  AND     #FF,W1
06134:  CP0     W1
06136:  BRA     Z,61CE
06138:  BCLR.B  42.0
0613A:  BCLR.B  42.1
0613C:  RLC     W3,W3
0613E:  SWAP    W3
06140:  AND     #FF,W3
06142:  CP0     W3
06144:  BRA     Z,61CE
06146:  ZE      W0,W0
06148:  ADD.B   W3L,W1L,W0L
0614A:  BRA     C,6154
0614C:  SUB     #7F,W0
0614E:  BRA     Z,61CE
06150:  BRA     NC,61CE
06152:  BRA     6158
06154:  ADD.B   #81,W0L
06156:  BRA     C,61CE
06158:  XOR     W5,W7,W10
0615A:  BCLR.B  42.0
0615C:  BCLR.B  42.1
0615E:  AND     #FF,W5
06160:  BSET    W5.7
06162:  BCLR.B  42.0
06164:  AND     #FF,W7
06166:  BSET    W7.7
06168:  MUL.UU  W4,W6,W2
0616A:  MUL.UU  W5,W6,W8
0616C:  ADDC    W8,W3,W3
0616E:  MOV     W9,W1
06170:  BTSC.B  42.0
06172:  INC     W1,W1
06174:  BCLR.B  42.0
06176:  MUL.UU  W7,W4,W8
06178:  ADDC    W8,W3,W3
0617A:  ADDC    W9,W1,W1
0617C:  MUL.UU  W5,W7,W8
0617E:  ADDC    W8,W1,W1
06180:  INC     W0,W0
06182:  CP0     W1
06184:  BTSC.B  42.1
06186:  BRA     618A
06188:  BRA     6190
0618A:  CP0     W3
0618C:  BTSC.B  42.1
0618E:  BRA     619A
06190:  BTSC    W1.F
06192:  BRA     619A
06194:  RLC     W3,W3
06196:  RLC     W1,W1
06198:  DEC     W0,W0
0619A:  MOV     W1,W2
0619C:  BCLR.B  42.0
0619E:  BTSS    W3.7
061A0:  BRA     61B4
061A2:  MOV     #FF00,W7
061A4:  AND     W3,W7,W3
061A6:  ADD     #100,W3
061A8:  ADDC    W2,#0,W2
061AA:  CP0     W2
061AC:  BRA     NZ,61B4
061AE:  CP0     W3
061B0:  BRA     NZ,61B4
061B2:  INC     W0,W0
061B4:  SWAP    W0
061B6:  BCLR.B  42.0
061B8:  BCLR.B  42.1
061BA:  RRC     W0,W1
061BC:  BTSC    W10.F
061BE:  BSET    W1.F
061C0:  BCLR    W2.F
061C2:  SWAP    W2
061C4:  XOR.B   W2L,W1L,W1L
061C6:  SWAP    W3
061C8:  MOV.B   W3L,W2L
061CA:  MOV     W2,W0
061CC:  BRA     61D4
061CE:  MOV     #0,W0
061D0:  MOV     #0,W1
061D2:  BRA     61D4
061D4:  MOV     #14,W5
061D6:  REPEAT  #4
061D8:  MOV     [--W15],[W5--]
061DA:  MOV     [--W15],W5
061DC:  RETURN  
061DE:  MOV     W5,[W15++]
061E0:  MOV     #C,W5
061E2:  REPEAT  #3
061E4:  MOV     [W5++],[W15++]
061E6:  CLR     W9
061E8:  MOV     #8000,W8
061EA:  BTSC.B  43.0
061EC:  XOR     W8,W3,W3
061EE:  CP0     W0
061F0:  BRA     NZ,61F8
061F2:  MOV     #7FFF,W10
061F4:  AND     W1,W10,W10
061F6:  BTSS.B  42.1
061F8:  MOV     W1,W10
061FA:  XOR     W3,W10,W11
061FC:  MOV     W1,W6
061FE:  MOV     W3,W7
06200:  MOV     W3,W12
06202:  BCLR.B  42.1
06204:  BCLR.B  42.0
06206:  RLC     W6,W6
06208:  SWAP    W6
0620A:  AND     #FF,W6
0620C:  CP0     W6
0620E:  BRA     Z,6352
06210:  BCLR.B  42.1
06212:  BCLR.B  42.0
06214:  RLC     W7,W7
06216:  SWAP    W7
06218:  AND     #FF,W7
0621A:  CP0     W7
0621C:  BRA     Z,635C
0621E:  BCLR.B  42.1
06220:  BCLR.B  42.0
06222:  CP      W7,W6
06224:  BRA     Z,635E
06226:  BRA     N,636E
06228:  BCLR    W9.0
0622A:  BSET    W9.1
0622C:  SUB     W7,W6,W8
0622E:  MOV     W7,W6
06230:  AND     #FF,W1
06232:  BSET    W1.7
06234:  AND     #FF,W3
06236:  BSET    W3.7
06238:  MOV     #28,W7
0623A:  CP      W7,W8
0623C:  BRA     N,6260
0623E:  BCLR.B  42.1
06240:  BCLR.B  42.0
06242:  RRC     W1,W1
06244:  RRC     W0,W0
06246:  DEC     W8,W8
06248:  BRA     NZ,623E
0624A:  BRA     6266
0624C:  MOV     #28,W7
0624E:  CP      W7,W8
06250:  BRA     N,6264
06252:  BCLR.B  42.1
06254:  BCLR.B  42.0
06256:  RRC     W3,W3
06258:  RRC     W2,W2
0625A:  DEC     W8,W8
0625C:  BRA     NZ,6252
0625E:  BRA     627E
06260:  MOV     W2,W0
06262:  MOV     W3,W1
06264:  BRA     62EC
06266:  BTSS    W11.F
06268:  BRA     628C
0626A:  BTSC    W9.4
0626C:  MOV     W12,W11
0626E:  NEG     W0,W0
06270:  BRA     Z,6276
06272:  COM.B   W1L,W1L
06274:  BRA     6278
06276:  NEG     W1,W1
06278:  BTSC    W9.4
0627A:  BRA     62D2
0627C:  BRA     628C
0627E:  BTSS    W11.F
06280:  BRA     628C
06282:  NEG     W2,W2
06284:  BRA     Z,628A
06286:  COM.B   W3L,W3L
06288:  BRA     628C
0628A:  NEG     W3,W3
0628C:  AND     #FF,W5
0628E:  BCLR.B  42.1
06290:  BCLR.B  42.0
06292:  ADD     W0,W2,W0
06294:  ADDC.B  W1L,W3L,W1L
06296:  BTSC.B  42.0
06298:  BSET    W9.3
0629A:  BTSC    W9.0
0629C:  BRA     62B0
0629E:  BTSC    W9.1
062A0:  BRA     62A4
062A2:  BRA     62BA
062A4:  BTSC    W11.F
062A6:  BRA     62D2
062A8:  BTSC    W9.3
062AA:  BRA     62FE
062AC:  BSET    W9.6
062AE:  BRA     62EC
062B0:  BTSC    W11.F
062B2:  BRA     62D2
062B4:  BTSC    W9.3
062B6:  BRA     62FE
062B8:  BRA     62EC
062BA:  BCLR    W9.2
062BC:  BTSC    W11.F
062BE:  BRA     62C8
062C0:  MOV     W10,W11
062C2:  BTSC    W9.3
062C4:  BRA     62FE
062C6:  BRA     6334
062C8:  BSET    W9.4
062CA:  XOR.B   #80,W1L
062CC:  BTSC    W1.7
062CE:  BRA     626A
062D0:  MOV     W10,W11
062D2:  AND     #FF,W1
062D4:  IOR      W0,  W1,W7
062D6:  BRA     Z,62EC
062D8:  BTSC    W1.7
062DA:  BRA     62EC
062DC:  BCLR.B  42.1
062DE:  BCLR.B  42.0
062E0:  RLC     W0,W0
062E2:  RLC     W1,W1
062E4:  DEC     W6,W6
062E6:  BTSC.B  42.1
062E8:  BRA     634C
062EA:  BRA     62D8
062EC:  BTSC    W9.0
062EE:  MOV     W10,W11
062F0:  BTSC    W9.1
062F2:  MOV     W12,W11
062F4:  BTSS    W9.5
062F6:  BRA     632C
062F8:  BTSC    W10.F
062FA:  BSET    W0.8
062FC:  BRA     6334
062FE:  BSET.B  42.0
06300:  RRC.B   W1L,W1L
06302:  RRC     W0,W0
06304:  BTSC.B  42.0
06306:  BSET    W9.5
06308:  INC     W6,W6
0630A:  BRA     Z,634C
0630C:  BTSS    W9.5
0630E:  BRA     6320
06310:  INC     W0,W0
06312:  BRA     NZ,6320
06314:  INC.B   W1L,W1L
06316:  BRA     NZ,6320
06318:  RRC.B   W1L,W1L
0631A:  RRC     W0,W0
0631C:  INC     W6,W6
0631E:  BRA     Z,634C
06320:  BTSC    W9.0
06322:  MOV     W10,W11
06324:  BTSC    W9.1
06326:  MOV     W12,W11
06328:  BTSC.B  42.1
0632A:  BRA     634C
0632C:  BTSC    W9.6
0632E:  MOV     W10,W11
06330:  BTSC    W9.7
06332:  MOV     W12,W11
06334:  IOR      W0,  W1,W2
06336:  BRA     Z,637E
06338:  BCLR    W1.7
0633A:  SWAP    W6
0633C:  BCLR.B  42.1
0633E:  BCLR.B  42.0
06340:  RRC     W6,W6
06342:  XOR     W6,W1,W1
06344:  BSET    W1.F
06346:  BTSS    W11.F
06348:  BCLR    W1.F
0634A:  BRA     637E
0634C:  MOV     #0,W0
0634E:  MOV     #0,W1
06350:  BRA     637E
06352:  BTSC    W10.F
06354:  XOR     W8,W3,W3
06356:  MOV     W2,W0
06358:  MOV     W3,W1
0635A:  BRA     637E
0635C:  BRA     637E
0635E:  AND     #FF,W3
06360:  BSET    W3.7
06362:  AND     #FF,W1
06364:  BSET    W1.7
06366:  BTSC    W11.F
06368:  BCLR    W3.7
0636A:  BSET    W9.2
0636C:  BRA     627E
0636E:  SUB     W6,W7,W8
06370:  AND     #FF,W1
06372:  BSET    W1.7
06374:  AND     #FF,W3
06376:  BSET    W3.7
06378:  BCLR    W9.1
0637A:  BSET    W9.0
0637C:  BRA     624C
0637E:  MOV     #12,W5
06380:  REPEAT  #3
06382:  MOV     [--W15],[W5--]
06384:  MOV     [--W15],W5
06386:  RETURN  
*
0651A:  MOV     W5,[W15++]
0651C:  MOV     W1,W5
0651E:  MOV     W0,W2
06520:  MOV     #B6,W4
06522:  RLC     W1,W1
06524:  SWAP    W1
06526:  AND     #FF,W1
06528:  SUB.B   W4L,W1L,W4L
0652A:  MOV.B   W5L,W3L
0652C:  BSET    W3.7
0652E:  AND     #FF,W3
06530:  CLR     W0
06532:  CLR     W1
06534:  CP      W4,#18
06536:  BRA     N,6556
06538:  BCLR.B  42.0
0653A:  RRC     W3,W3
0653C:  RRC     W2,W2
0653E:  RRC     W1,W1
06540:  RRC     W0,W0
06542:  DEC     W4,W4
06544:  BRA     NZ,6538
06546:  BTSS    W5.F
06548:  BRA     6556
0654A:  NEG     W0,W0
0654C:  BRA     Z,6552
0654E:  COM     W1,W1
06550:  BRA     6556
06552:  NEG     W1,W1
06554:  BRA     6556
06556:  MOV     [--W15],W5
06558:  RETURN  
*
065B6:  MOV     W5,[W15++]
065B8:  MOV     #C,W5
065BA:  REPEAT  #3
065BC:  MOV     [W5++],[W15++]
065BE:  MOV     W0,W7
065C0:  MOV     W4,W9
065C2:  BCLR    W4.F
065C4:  CP0     W4
065C6:  BRA     NZ,65D4
065C8:  BTSC    W9.F
065CA:  BRA     65D0
065CC:  MOV     #0,W5
065CE:  BRA     65F2
065D0:  MOV     #0,W5
065D2:  BRA     65F2
065D4:  SUB.B   W4L,#6,W5L
065D6:  BRA     NC,65F0
065D8:  MOV     #30,W0
065DA:  BTSS    W9.F
065DC:  MOV     #20,W0
065DE:  MOV     W0,[W15++]
065E0:  BTSC.B  219.1
065E2:  BRA     65E0
065E4:  MOV     W0,21A
065E6:  MOV     [--W15],W0
065E8:  DEC     W5,W5
065EA:  BRA     NN,65DE
065EC:  MOV     #5,W5
065EE:  BRA     65F2
065F0:  MOV     W4,W5
065F2:  MOV     #6,W4
065F4:  BSET    W5.E
065F6:  BTSC    W9.F
065F8:  BSET    W5.F
065FA:  MOV     #2710,W8
065FC:  REPEAT  #11
065FE:  DIV.U   W7,W8
06600:  CALL    6634
06604:  MOV     W1,W7
06606:  MOV     #3E8,W8
06608:  REPEAT  #11
0660A:  DIV.U   W7,W8
0660C:  CALL    6634
06610:  MOV     W1,W7
06612:  MOV     #64,W8
06614:  REPEAT  #11
06616:  DIV.U   W7,W8
06618:  CALL    6634
0661C:  MOV     W1,W7
0661E:  MOV     #A,W8
06620:  REPEAT  #11
06622:  DIV.U   W7,W8
06624:  CALL    6634
06628:  MOV     #30,W0
0662A:  ADD.B   W1L,W0L,W0L
0662C:  BTSC.B  219.1
0662E:  BRA     662C
06630:  MOV     W0,21A
06632:  BRA     6662
06634:  MOV     #30,W6
06636:  CP0     W0
06638:  BRA     NZ,6656
0663A:  BTSS    W5.E
0663C:  BRA     6658
0663E:  DEC     W4,W4
06640:  CP.B    W4L,W5L
06642:  BRA     Z,6648
06644:  BTSC.B  42.0
06646:  RETURN  
06648:  CP0     W0
0664A:  BRA     NZ,6656
0664C:  BTSS    W5.E
0664E:  BRA     6658
06650:  BTSS    W5.F
06652:  MOV     #20,W6
06654:  BRA     6658
06656:  BCLR    W5.E
06658:  ADD.B   W6L,W0L,W0L
0665A:  BTSC.B  219.1
0665C:  BRA     665A
0665E:  MOV     W0,21A
06660:  RETURN  
06662:  MOV     #12,W5
06664:  REPEAT  #3
06666:  MOV     [--W15],[W5--]
06668:  MOV     [--W15],W5
0666A:  RETURN  
0666C:  MOV     W6,[W15++]
0666E:  MOV     W7,[W15++]
06670:  MOV     W8,[W15++]
06672:  MOV     W9,[W15++]
06674:  CLR     W4
06676:  CLR     W5
06678:  CLR     W6
0667A:  CLR     W7
0667C:  XOR     W2,W3,W8
0667E:  BRA     Z,66A2
06680:  MOV     #20,W8
06682:  BCLR.B  42.0
06684:  RLC     W0,W0
06686:  RLC     W1,W1
06688:  RLC     W4,W4
0668A:  RLC     W5,W5
0668C:  CP      W5,W3
0668E:  BRA     NZ,6692
06690:  CPB     W4,W2
06692:  BRA     NC,669A
06694:  SUB     W4,W2,W4
06696:  SUBB    W5,W3,W5
06698:  BSET.B  42.0
0669A:  RLC     W6,W6
0669C:  RLC     W7,W7
0669E:  DEC     W8,W8
066A0:  BRA     NZ,6682
066A2:  MOV     W7,W1
066A4:  MOV     W6,W0
066A6:  MOV     [--W15],W9
066A8:  MOV     [--W15],W8
066AA:  MOV     [--W15],W7
066AC:  MOV     [--W15],W6
066AE:  RETURN  
066B0:  MOV     W5,[W15++]
066B2:  MOV     #C,W5
066B4:  REPEAT  #7
066B6:  MOV     [W5++],[W15++]
066B8:  BTSS    W1.F
066BA:  BRA     66CA
066BC:  NEG     W0,W0
066BE:  BRA     Z,66C2
066C0:  BRA     NZ,66C6
066C2:  NEG     W1,W1
066C4:  BRA     66C8
066C6:  COM     W1,W1
066C8:  BSET    W4.8
066CA:  CLR     W5
066CC:  MOV     W0,W6
066CE:  MOV     W1,W7
066D0:  MOV     W4,W12
066D2:  BCLR    W4.F
066D4:  CP0.B   W4L
066D6:  BRA     NZ,66DA
066D8:  BRA     670E
066DA:  SUB.B   W4L,#B,W5L
066DC:  BRA     NC,670E
066DE:  SUB.B   W4L,W5L,W4L
066E0:  BTSS    W12.F
066E2:  BRA     66FA
066E4:  BTSS    W4.8
066E6:  BRA     66F6
066E8:  MOV     #2D,W0
066EA:  BTSC.B  219.1
066EC:  BRA     66EA
066EE:  MOV     W0,21A
066F0:  BCLR    W4.8
066F2:  DEC     W5,W5
066F4:  BRA     N,670E
066F6:  MOV     #30,W0
066F8:  BRA     66FC
066FA:  MOV     #20,W0
066FC:  MOV     W0,[W15++]
066FE:  BTSC.B  219.1
06700:  BRA     66FE
06702:  MOV     W0,21A
06704:  MOV     [--W15],W0
06706:  DEC     W5,W5
06708:  BRA     NN,66FC
0670A:  BTSC    W4.8
0670C:  DEC.B   W4L,W4L
0670E:  MOV     #E,W8
06710:  MOV     #0,W9
06712:  LNK     #10
06714:  MOV     W12,[W14+W8]
06716:  DEC2    W8,W8
06718:  BRA     NN,6714
0671A:  MOV     W4,W5
0671C:  MOV     #A,W4
0671E:  BTSC    W5.8
06720:  INC     W4,W4
06722:  BSET    W5.E
06724:  BTSC    W12.F
06726:  BSET    W5.F
06728:  CP0.B   W5L
0672A:  BRA     Z,672E
0672C:  DEC.B   W5L,W5L
0672E:  MOV     W4,[W14]
06730:  MOV     W5,[W14+#2]
06732:  MOV     W6,W0
06734:  MOV     W7,W1
06736:  MOV     #CA00,W2
06738:  MOV     #3B9A,W3
0673A:  MOV     #2710,W8
0673C:  BCLR    W13.F
0673E:  BCLR.B  43.0
06740:  CALL    666C
06744:  BTG     W13.F
06746:  BTSC    W13.F
06748:  BRA     6758
0674A:  MOV     W0,[W14+#8]
0674C:  MOV     W1,[W14+#A]
0674E:  MOV     W0,W2
06750:  MOV     W1,W3
06752:  MOV     [W14+#4],W0
06754:  MOV     [W14+#6],W1
06756:  BRA     673E
06758:  MOV     W2,[W14+#8]
0675A:  MOV     W3,[W14+#A]
0675C:  MOV     W4,[W14+#4]
0675E:  MOV     W5,[W14+#6]
06760:  MOV     [W14],W4
06762:  MOV     [W14+#2],W5
06764:  MOV     #30,W6
06766:  CP0     W0
06768:  BRA     NZ,678C
0676A:  BTSS    W5.E
0676C:  BRA     6790
0676E:  DEC     W4,W4
06770:  MOV     W4,[W14]
06772:  CP0     W4
06774:  BRA     Z,6790
06776:  CP.B    W4L,W5L
06778:  BRA     Z,677E
0677A:  BTSC.B  42.0
0677C:  BRA     67AE
0677E:  BTSS    W5.F
06780:  BRA     6788
06782:  BTSS    W5.8
06784:  BRA     67A6
06786:  BRA     6796
06788:  MOV     #20,W6
0678A:  BRA     67A6
0678C:  BCLR    W5.E
0678E:  MOV     W5,[W14+#2]
06790:  MOV     [W14+#2],W5
06792:  BTSS    W5.8
06794:  BRA     67A6
06796:  BCLR    W5.8
06798:  MOV     W5,[W14+#2]
0679A:  MOV     W0,W10
0679C:  MOV     #2D,W0
0679E:  BTSC.B  219.1
067A0:  BRA     679E
067A2:  MOV     W0,21A
067A4:  MOV     W10,W0
067A6:  ADD.B   W6L,W0L,W0L
067A8:  BTSC.B  219.1
067AA:  BRA     67A8
067AC:  MOV     W0,21A
067AE:  MOV     [W14+#8],W0
067B0:  MOV     [W14+#A],W1
067B2:  MOV     #A,W2
067B4:  CLR     W3
067B6:  CP      W0,#1
067B8:  BRA     Z,67BC
067BA:  BRA     673E
067BC:  ULNK    
067BE:  MOV     #1A,W5
067C0:  REPEAT  #7
067C2:  MOV     [--W15],[W5--]
067C4:  MOV     [--W15],W5
067C6:  RETURN  
*
06FC8:  MOV     W5,[W15++]
06FCA:  MOV     #C,W5
06FCC:  REPEAT  #3
06FCE:  MOV     [W5++],[W15++]
06FD0:  MOV     #0,W9
06FD2:  BTSC.B  43.0
06FD4:  MOV     #1,W9
06FD6:  MOV     W9,[W15++]
06FD8:  XOR     W1,W3,W9
06FDA:  BTSS    W1.F
06FDC:  BRA     6FE4
06FDE:  COM     W1,W1
06FE0:  NEG     W0,W0
06FE2:  ADDC    W1,#0,W1
06FE4:  BTSS    W3.F
06FE6:  BRA     6FEE
06FE8:  COM     W3,W3
06FEA:  NEG     W2,W2
06FEC:  ADDC    W3,#0,W3
06FEE:  XOR     W2,W3,W4
06FF0:  BRA     Z,701C
06FF2:  CLR     W4
06FF4:  CLR     W5
06FF6:  CLR     W6
06FF8:  CLR     W7
06FFA:  MOV     #20,W8
06FFC:  BCLR.B  42.0
06FFE:  RLC     W0,W0
07000:  RLC     W1,W1
07002:  RLC     W4,W4
07004:  RLC     W5,W5
07006:  CP      W5,W3
07008:  BRA     NZ,700C
0700A:  CPB     W4,W2
0700C:  BRA     NC,7014
0700E:  SUB     W4,W2,W4
07010:  SUBB    W5,W3,W5
07012:  BSET.B  42.0
07014:  RLC     W6,W6
07016:  RLC     W7,W7
07018:  DEC     W8,W8
0701A:  BRA     NZ,6FFC
0701C:  BTSS    W9.F
0701E:  BRA     702E
07020:  NEG     W6,W0
07022:  BRA     Z,7026
07024:  BRA     NZ,702A
07026:  NEG     W7,W1
07028:  BRA     7034
0702A:  COM     W7,W1
0702C:  BRA     7034
0702E:  MOV     W7,W1
07030:  MOV     W6,W0
07032:  BRA     7034
07034:  MOV     [--W15],W9
07036:  CP0     W9
07038:  BRA     Z,703C
0703A:  MOV.D   W4,W0
0703C:  MOV     #12,W5
0703E:  REPEAT  #3
07040:  MOV     [--W15],[W5--]
07042:  MOV     [--W15],W5
07044:  RETURN  
*
07A56:  MOV     W5,[W15++]
07A58:  MOV     W6,[W15++]
07A5A:  MOV     #8E,W1
07A5C:  BCLR    W6.0
07A5E:  BTSS    W0.F
07A60:  BRA     7A68
07A62:  BSET    W6.0
07A64:  NEG     W0,W0
07A66:  BRA     7A68
07A68:  CP0     W0
07A6A:  BRA     Z,7A94
07A6C:  BTSC    W0.F
07A6E:  BRA     7A78
07A70:  BCLR.B  42.0
07A72:  RLC     W0,W0
07A74:  DEC     W1,W1
07A76:  BRA     7A6C
07A78:  SWAP    W1
07A7A:  BCLR.B  42.0
07A7C:  RRC     W1,W1
07A7E:  BCLR    W0.F
07A80:  SWAP    W0
07A82:  XOR.B   W0L,W1L,W1L
07A84:  AND.B   #0,W0L
07A86:  BTSC    W6.0
07A88:  BSET    W1.F
07A8A:  BRA     7A9A
07A8C:  MOV.B   W1L,W0L
07A8E:  BSET    W1.7
07A90:  AND.B   #0,W1L
07A92:  BRA     7A9A
07A94:  CLR     W0
07A96:  CLR     W1
07A98:  BRA     7A9A
07A9A:  MOV     [--W15],W6
07A9C:  MOV     [--W15],W5
07A9E:  RETURN  
07AA0:  MOV     W5,[W15++]
07AA2:  MOV     #C,W5
07AA4:  REPEAT  #4
07AA6:  MOV     [W5++],[W15++]
07AA8:  CLR     W9
07AAA:  XOR     W1,W3,W9
07AAC:  MOV     W1,W6
07AAE:  MOV     W0,W5
07AB0:  MOV     W3,W8
07AB2:  MOV     W2,W7
07AB4:  RLC     W1,W1
07AB6:  SWAP    W1
07AB8:  ZE      W1,W1
07ABA:  CP0     W1
07ABC:  BRA     Z,7B5A
07ABE:  RLC     W3,W3
07AC0:  SWAP    W3
07AC2:  ZE      W3,W3
07AC4:  CP0     W3
07AC6:  BRA     Z,7B5A
07AC8:  CLR     W0
07ACA:  SUB.B   W1L,W3L,W0L
07ACC:  BRA     NC,7AD4
07ACE:  ADD.B   #7F,W0L
07AD0:  BRA     C,7B5A
07AD2:  BRA     7ADA
07AD4:  SUB.B   #81,W0L
07AD6:  BRA     NC,7B5A
07AD8:  BRA     Z,7B5A
07ADA:  MOV     W5,W1
07ADC:  MOV     W6,W2
07ADE:  BSET    W2.7
07AE0:  AND     #FF,W2
07AE2:  AND     #FF,W8
07AE4:  BSET    W8.7
07AE6:  MOV     #19,W10
07AE8:  CLR     W3
07AEA:  CLR     W4
07AEC:  SUB     W1,W7,W1
07AEE:  SUBB    W2,W8,W2
07AF0:  BRA     N,7AF6
07AF2:  BRA     C,7AFC
07AF4:  BRA     NZ,7AFE
07AF6:  ADD     W1,W7,W1
07AF8:  ADDC    W2,W8,W2
07AFA:  BRA     7AFE
07AFC:  BSET    W4.0
07AFE:  DEC     W10,W10
07B00:  BRA     Z,7B10
07B02:  BCLR.B  42.0
07B04:  RLC     W1,W1
07B06:  RLC     W2,W2
07B08:  BCLR.B  42.0
07B0A:  RLC     W4,W4
07B0C:  RLC     W3,W3
07B0E:  BRA     7AEC
07B10:  CLR     W10
07B12:  BTSC    W3.8
07B14:  BRA     7B18
07B16:  BRA     7B24
07B18:  BCLR.B  42.0
07B1A:  RRC     W3,W3
07B1C:  BCLR    W3.7
07B1E:  RRC     W4,W4
07B20:  RLC     W10,W10
07B22:  BRA     7B28
07B24:  DEC     W0,W0
07B26:  BRA     Z,7B5A
07B28:  BTSC    W10.F
07B2A:  BRA     NC,7B36
07B2C:  RLC     W1,W1
07B2E:  RLC     W2,W2
07B30:  SUB     W1,W7,W1
07B32:  SUBB    W2,W8,W2
07B34:  BRA     NC,7B48
07B36:  INC     W4,W4
07B38:  BRA     NZ,7B48
07B3A:  INC     W3,W3
07B3C:  BRA     NZ,7B48
07B3E:  INC     W0,W0
07B40:  BRA     Z,7B5A
07B42:  BRA     7B48
07B44:  DEC     W0,W0
07B46:  BRA     Z,7B5A
07B48:  SWAP    W0
07B4A:  RRC     W0,W1
07B4C:  BSET    W1.F
07B4E:  BTSS    W9.F
07B50:  BCLR    W1.F
07B52:  BCLR    W3.7
07B54:  XOR.B   W3L,W1L,W1L
07B56:  MOV     W4,W0
07B58:  BRA     7B60
07B5A:  MOV     #0,W0
07B5C:  MOV     #0,W1
07B5E:  BRA     7B60
07B60:  MOV     #14,W5
07B62:  REPEAT  #4
07B64:  MOV     [--W15],[W5--]
07B66:  MOV     [--W15],W5
07B68:  RETURN  
*
07C4A:  MOV     W5,[W15++]
07C4C:  MOV     W6,[W15++]
07C4E:  MOV     W2,W3
07C50:  MOV     W2,W5
07C52:  BCLR.B  42.0
07C54:  RLC     W3,W3
07C56:  SWAP    W3
07C58:  AND     #FF,W3
07C5A:  BRA     NZ,7C62
07C5C:  MUL.UU  W0,#0,W0
07C5E:  MUL.UU  W2,#0,W2
07C60:  BRA     7C8E
07C62:  ADD     #380,W3
07C64:  AND     #7F,W2
07C66:  MOV     #3,W6
07C68:  CLR     W4
07C6A:  BCLR.B  42.0
07C6C:  RRC     W2,W2
07C6E:  RRC     W1,W1
07C70:  RRC     W0,W0
07C72:  BTSC.B  42.0
07C74:  INC     W4,W4
07C76:  DEC     W6,W6
07C78:  BRA     NZ,7C6A
07C7A:  BCLR    W2.7
07C7C:  SL      W3,#4,W3
07C7E:  BCLR    W3.F
07C80:  BTSC    W5.F
07C82:  BSET    W3.F
07C84:  XOR     W2,W3,W3
07C86:  MOV     W1,W2
07C88:  MOV     W0,W1
07C8A:  ADD     W4,W1,W1
07C8C:  CLR     W0
07C8E:  MOV     [--W15],W6
07C90:  MOV     [--W15],W5
07C92:  RETURN  
07C94:  MOV     W12,[W15++]
07C96:  MOV     W13,[W15++]
07C98:  CLR     W8
07C9A:  CLR     W9
07C9C:  CLR     W10
07C9E:  CLR     W11
07CA0:  CLR     W12
07CA2:  CLR     W13
07CA4:  MOV     #E,W8
07CA6:  MOV     #0,W9
07CA8:  LNK     #10
07CAA:  MOV     W12,[W14+W8]
07CAC:  DEC2    W8,W8
07CAE:  BRA     NN,7CAA
07CB0:  XOR     W4,W5,W8
07CB2:  BRA     NZ,7CB8
07CB4:  XOR     W6,W7,W8
07CB6:  BRA     Z,7D16
07CB8:  CLR     W8
07CBA:  MOV     #40,W13
07CBC:  MOV     #40,W13
07CBE:  BCLR.B  42.0
07CC0:  RLC     W0,W0
07CC2:  RLC     W1,W1
07CC4:  RLC     W2,W2
07CC6:  RLC     W3,W3
07CC8:  RLC     W8,W8
07CCA:  RLC     W9,W9
07CCC:  RLC     W10,W10
07CCE:  RLC     W11,W11
07CD0:  CP      W11,W7
07CD2:  BRA     NZ,7CDE
07CD4:  CPB     W10,W6
07CD6:  BRA     NZ,7CDE
07CD8:  CPB     W9,W5
07CDA:  BRA     NZ,7CDE
07CDC:  CPB     W8,W4
07CDE:  BRA     NC,7CEA
07CE0:  SUB     W8,W4,W8
07CE2:  SUBB    W9,W5,W9
07CE4:  SUBB    W10,W6,W10
07CE6:  SUBB    W11,W7,W11
07CE8:  BSET.B  42.0
07CEA:  MOV     W8,[W14]
07CEC:  MOV     W9,[W14+#2]
07CEE:  MOV     W10,[W14+#4]
07CF0:  MOV     W11,[W14+#6]
07CF2:  MOV     [W14+#8],W8
07CF4:  MOV     [W14+#A],W9
07CF6:  MOV     [W14+#C],W10
07CF8:  MOV     [W14+#E],W11
07CFA:  RLC     W8,W8
07CFC:  RLC     W9,W9
07CFE:  RLC     W10,W10
07D00:  RLC     W11,W11
07D02:  MOV     W8,[W14+#8]
07D04:  MOV     W9,[W14+#A]
07D06:  MOV     W10,[W14+#C]
07D08:  MOV     W11,[W14+#E]
07D0A:  MOV     [W14],W8
07D0C:  MOV     [W14+#2],W9
07D0E:  MOV     [W14+#4],W10
07D10:  MOV     [W14+#6],W11
07D12:  DEC     W13,W13
07D14:  BRA     NZ,7CBE
07D16:  MOV     [W14+#8],W0
07D18:  MOV     [W14+#A],W1
07D1A:  MOV     [W14+#C],W2
07D1C:  MOV     [W14+#E],W3
07D1E:  ULNK    
07D20:  BRA     7D22
07D22:  MOV     [--W15],W13
07D24:  MOV     [--W15],W12
07D26:  RETURN  
07D28:  MOV     W5,[W15++]
07D2A:  MOV     #C,W5
07D2C:  REPEAT  #5
07D2E:  MOV     [W5++],[W15++]
07D30:  BTSS    W3.F
07D32:  BRA     7D44
07D34:  COM     W1,W1
07D36:  COM     W2,W2
07D38:  COM     W3,W3
07D3A:  NEG     W0,W0
07D3C:  ADDC    W1,#0,W1
07D3E:  ADDC    W2,#0,W2
07D40:  ADDC    W3,#0,W3
07D42:  BSET    W4.8
07D44:  MOV     W0,W6
07D46:  MOV     W4,W12
07D48:  BCLR    W4.F
07D4A:  CP0     W4
07D4C:  BRA     NZ,7D50
07D4E:  BRA     7D84
07D50:  SUB.B   W4L,#14,W5L
07D52:  BRA     NC,7D84
07D54:  SUB.B   W4L,W5L,W4L
07D56:  BTSS    W12.F
07D58:  BRA     7D70
07D5A:  BTSS    W4.8
07D5C:  BRA     7D6C
07D5E:  MOV     #2D,W0
07D60:  BTSC.B  219.1
07D62:  BRA     7D60
07D64:  MOV     W0,21A
07D66:  BCLR    W4.8
07D68:  DEC     W5,W5
07D6A:  BRA     N,7D84
07D6C:  MOV     #30,W0
07D6E:  BRA     7D72
07D70:  MOV     #20,W0
07D72:  MOV     W0,[W15++]
07D74:  BTSC.B  219.1
07D76:  BRA     7D74
07D78:  MOV     W0,21A
07D7A:  MOV     [--W15],W0
07D7C:  DEC     W5,W5
07D7E:  BRA     NN,7D72
07D80:  BTSC    W4.8
07D82:  DEC.B   W4L,W4L
07D84:  MOV     #E,W8
07D86:  MOV     #0,W9
07D88:  LNK     #16
07D8A:  MOV     W12,[W14+W8]
07D8C:  DEC2    W8,W8
07D8E:  BRA     NN,7D8A
07D90:  MOV     W4,W5
07D92:  MOV     #13,W4
07D94:  BTSC    W5.8
07D96:  INC     W4,W4
07D98:  BSET    W5.E
07D9A:  BTSC    W12.F
07D9C:  BSET    W5.F
07D9E:  CP0.B   W5L
07DA0:  BRA     Z,7DA4
07DA2:  DEC.B   W5L,W5L
07DA4:  MOV     W4,[W14]
07DA6:  MOV     W5,[W14+#2]
07DA8:  MOV     W6,W0
07DAA:  CLR     W4
07DAC:  MOV     #A764,W5
07DAE:  MOV     #B6B3,W6
07DB0:  MOV     #DE0,W7
07DB2:  BCLR    W13.F
07DB4:  MOV     W13,[W14+#14]
07DB6:  CALL    7C94
07DBA:  MOV     [W14+#14],W13
07DBC:  BTG     W13.F
07DBE:  MOV     W13,[W14+#14]
07DC0:  BTSC    W13.F
07DC2:  BRA     7DDE
07DC4:  MOV     W0,[W14+#C]
07DC6:  MOV     W1,[W14+#E]
07DC8:  MOV     W2,[W14+#10]
07DCA:  MOV     W3,[W14+#12]
07DCC:  MOV     W0,W4
07DCE:  MOV     W1,W5
07DD0:  MOV     W2,W6
07DD2:  MOV     W3,W7
07DD4:  MOV     [W14+#4],W0
07DD6:  MOV     [W14+#6],W1
07DD8:  MOV     [W14+#8],W2
07DDA:  MOV     [W14+#A],W3
07DDC:  BRA     7DB6
07DDE:  MOV     W4,[W14+#C]
07DE0:  MOV     W5,[W14+#E]
07DE2:  MOV     W6,[W14+#10]
07DE4:  MOV     W7,[W14+#12]
07DE6:  MOV     W8,[W14+#4]
07DE8:  MOV     W9,[W14+#6]
07DEA:  MOV     W10,[W14+#8]
07DEC:  MOV     W11,[W14+#A]
07DEE:  MOV     [W14],W4
07DF0:  MOV     [W14+#2],W5
07DF2:  MOV     #30,W6
07DF4:  CP0     W0
07DF6:  BRA     NZ,7E1A
07DF8:  BTSS    W5.E
07DFA:  BRA     7E1E
07DFC:  DEC     W4,W4
07DFE:  MOV     W4,[W14]
07E00:  CP0     W4
07E02:  BRA     Z,7E1E
07E04:  CP.B    W4L,W5L
07E06:  BRA     Z,7E0C
07E08:  BTSC.B  42.0
07E0A:  BRA     7E3A
07E0C:  BTSS    W5.F
07E0E:  BRA     7E16
07E10:  BTSS    W5.8
07E12:  BRA     7E32
07E14:  BRA     7E22
07E16:  MOV     #20,W6
07E18:  BRA     7E32
07E1A:  BCLR    W5.E
07E1C:  MOV     W5,[W14+#2]
07E1E:  BTSS    W5.8
07E20:  BRA     7E32
07E22:  BCLR    W5.8
07E24:  MOV     W5,[W14+#2]
07E26:  MOV     W0,W10
07E28:  MOV     #2D,W0
07E2A:  BTSC.B  219.1
07E2C:  BRA     7E2A
07E2E:  MOV     W0,21A
07E30:  MOV     W10,W0
07E32:  ADD.B   W6L,W0L,W0L
07E34:  BTSC.B  219.1
07E36:  BRA     7E34
07E38:  MOV     W0,21A
07E3A:  MOV     [W14+#C],W0
07E3C:  MOV     [W14+#E],W1
07E3E:  MOV     [W14+#10],W2
07E40:  MOV     [W14+#12],W3
07E42:  MOV     #A,W4
07E44:  CLR     W5
07E46:  MUL.UU  W6,#0,W6
07E48:  CP      W0,#1
07E4A:  BRA     Z,7E4E
07E4C:  BRA     7DB6
07E4E:  ULNK    
07E50:  MOV     #16,W5
07E52:  REPEAT  #5
07E54:  MOV     [--W15],[W5--]
07E56:  MOV     [--W15],W5
07E58:  RETURN  
*
0907A:  PUSH    42
0907C:  MOV     W0,[W15++]
0907E:  BCLR.B  81.7
09080:  MOV     42,W4
09082:  IOR     #E0,W4
09084:  MOV     W4,42
09086:  BSET.B  81.7
09088:  MOV     W1,760
0908A:  MOV     #55,W4
0908C:  MOV     W4,766
0908E:  MOV     #AA,W4
09090:  MOV     W4,766
09092:  BSET.B  761.7
09094:  NOP     
09096:  NOP     
09098:  BTSC.B  761.7
0909A:  BRA     9098
0909C:  MOV     [--W15],W0
0909E:  BCLR.B  81.7
090A0:  POP     42
090A2:  BSET.B  81.7
090A4:  RETURN  
090A6:  MOV     W1,[W15++]
090A8:  MOV     #F000,W1
090AA:  ADD     W1,W0,W0
090AC:  CLR     W1
090AE:  MOV     #7F,W1
090B0:  ADDC    W1,#0,W1
090B2:  MOV     W1,32
090B4:  MOV     [--W15],W1
090B6:  BCLR    W2.0
090B8:  CP0     W2
090BA:  BRA     Z,90DE
090BC:  TBLWTL  [W1],[W0]
090BE:  MOV     W1,[W15++]
090C0:  MOV     #4044,W1
090C2:  CALL    907A
090C6:  MOV     [--W15],W1
090C8:  TBLWTL  [W1++],[W0]
090CA:  INC2    W0,W0
090CC:  BRA     NZ,90D0
090CE:  INC     0032
090D0:  MOV     W1,[W15++]
090D2:  MOV     #4004,W1
090D4:  CALL    907A
090D8:  MOV     [--W15],W1
090DA:  DEC2    W2,W2
090DC:  BRA     NZ,90BC
090DE:  RETURN  
....................  
.................... #list 
....................  
.................... #include "DSPIC30F_registers.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... #word WREG0 = 0x000 
.................... #word WREG1 = 0x002 
.................... #word WREG2 = 0x004 
.................... #word WREG3 = 0x006 
.................... #word WREG4 = 0x008 
.................... #word WREG5 = 0x00A 
.................... #word WREG6 = 0x00C 
.................... #word WREG7 = 0x00E 
.................... #word WREG8 = 0x010 
.................... #word WREG9 = 0x012 
.................... #word WREG10 = 0x014 
.................... #word WREG11 = 0x016 
.................... #word WREG12 = 0x018 
.................... #word WREG13 = 0x01A 
.................... #word WREG14 = 0x01C 
.................... #word WREG15 = 0x01E 
.................... #word SPLIM = 0x020 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x022 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x024 
.................... #word ACCAU = 0x026 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x028 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x02A 
.................... #word ACCBU = 0x02C 
.................... #word PC = 0x02E 
.................... #word PCH = 0x02E 
.................... #word PC = 0x02E 
.................... #word PCH = 0x030 
.................... #word TBLPAG = 0x032 
.................... #word PSVPAG = 0x034 
.................... #word RCOUNT = 0x036 
.................... #word DCOUNT = 0x038 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03A 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03C 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x03E 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x040 
.................... #word SR = 0x042 
.................... #word CORCON = 0x044 
.................... #word MODCON = 0x046 
.................... #word XMODSRT = 0x048 
.................... #word XMODEND = 0x04A 
.................... #word YMODSRT = 0x04C 
.................... #word YMODEND = 0x04E 
.................... #word XBREV = 0x050 
.................... #word DISICNT = 0x052 
.................... #word INTCON1 = 0x080 
.................... #word INTCON2 = 0x082 
.................... #word IFS0 = 0x084 
.................... #word IFS1 = 0x086 
.................... #word IFS2 = 0x088 
.................... #word IEC0 = 0x08C 
.................... #word IEC1 = 0x08E 
.................... #word IEC2 = 0x090 
.................... #word IPC0 = 0x094 
.................... #word IPC1 = 0x096 
.................... #word IPC2 = 0x098 
.................... #word IPC3 = 0x09A 
.................... #word IPC4 = 0x09C 
.................... #word IPC5 = 0x09E 
.................... #word IPC6 = 0x0A0 
.................... #word IPC7 = 0x0A2 
.................... #word IPC8 = 0x0A4 
.................... #word IPC9 = 0x0A6 
.................... #word IPC10 = 0x0A8 
.................... #word INTREG = 0x0B0 
.................... #word CNEN1 = 0x0C0 
.................... #word CNEN2 = 0x0C2 
.................... #word CNPU1 = 0x0C4 
.................... #word CNPU2 = 0x0C6 
.................... #word TMR1 = 0x100 
.................... #word PR1 = 0x102 
.................... #word T1CON = 0x104 
.................... #word TMR2 = 0x106 
.................... #word TMR3HLD = 0x108 
.................... #word TMR3 = 0x10A 
.................... #word PR2 = 0x10C 
.................... #word PR3 = 0x10E 
.................... #word T2CON = 0x110 
.................... #word T3CON = 0x112 
.................... #word TMR4 = 0x114 
.................... #word TMR5HLD = 0x116 
.................... #word TMR5 = 0x118 
.................... #word PR4 = 0x11A 
.................... #word PR5 = 0x11C 
.................... #word T4CON = 0x11E 
.................... #word T5CON = 0x120 
.................... #word IC1BUF = 0x140 
.................... #word IC1CON = 0x142 
.................... #word IC2BUF = 0x144 
.................... #word IC2CON = 0x146 
.................... #word IC3BUF = 0x148 
.................... #word IC3CON = 0x14A 
.................... #word IC4BUF = 0x14C 
.................... #word IC4CON = 0x14E 
.................... #word IC5BUF = 0x150 
.................... #word IC5CON = 0x152 
.................... #word IC6BUF = 0x154 
.................... #word IC6CON = 0x156 
.................... #word IC7BUF = 0x158 
.................... #word IC7CON = 0x15A 
.................... #word IC8BUF = 0x15C 
.................... #word IC8CON = 0x15E 
.................... #word OC1RS = 0x180 
.................... #word OC1R = 0x182 
.................... #word OC1CON = 0x184 
.................... #word OC2RS = 0x186 
.................... #word OC2R = 0x188 
.................... #word OC2CON = 0x18A 
.................... #word OC3RS = 0x18C 
.................... #word OC3R = 0x18E 
.................... #word OC3CON = 0x190 
.................... #word OC4RS = 0x192 
.................... #word OC4R = 0x194 
.................... #word OC4CON = 0x196 
.................... #word OC5RS = 0x198 
.................... #word OC5R = 0x19A 
.................... #word OC5CON = 0x19C 
.................... #word OC6RS = 0x19E 
.................... #word OC6R = 0x1A0 
.................... #word OC6CON = 0x1A2 
.................... #word OC7RS = 0x1A4 
.................... #word OC7R = 0x1A6 
.................... #word OC7CON = 0x1A8 
.................... #word OC8RS = 0x1AA 
.................... #word OC8R = 0x1AC 
.................... #word OC8CON = 0x1AE 
.................... #word I2CRCV = 0x200 
.................... #word I2CTRN = 0x202 
.................... #word I2CBRG = 0x204 
.................... #word I2CCON = 0x206 
.................... #word I2CSTAT = 0x208 
.................... #word I2CADD = 0x20A 
.................... #word U1MODE = 0x20C 
.................... #word U1STA = 0x20E 
.................... #word U1TXREG = 0x210 
.................... #word U1RXREG = 0x212 
.................... #word U1BRG = 0x214 
.................... #word U2MODE = 0x216 
.................... #word U2STA = 0x218 
.................... #word U2TXREG = 0x21A 
.................... #word U2RXREG = 0x21C 
.................... #word U2BRG = 0x21E 
.................... #word SPI1STAT = 0x220 
.................... #word SPI1CON = 0x222 
.................... #word SPI1BUF = 0x224 
.................... #word SPI2STAT = 0x226 
.................... #word SPI2CON = 0x228 
.................... #word SPI2BUF = 0x22A 
.................... #word DCICON1 = 0x240 
.................... #word DCICON2 = 0x242 
.................... #word DCICON3 = 0x244 
.................... #word DCISTAT = 0x246 
.................... #word TSCON = 0x248 
.................... #word RSCON = 0x24C 
.................... #word RXBUF0 = 0x250 
.................... #word RXBUF1 = 0x252 
.................... #word RXBUF2 = 0x254 
.................... #word RXBUF3 = 0x256 
.................... #word TXBUF0 = 0x258 
.................... #word TXBUF1 = 0x25A 
.................... #word TXBUF2 = 0x25C 
.................... #word TXBUF3 = 0x25E 
.................... #word ADCBUF0 = 0x280 
.................... #word ADCBUF1 = 0x282 
.................... #word ADCBUF2 = 0x284 
.................... #word ADCBUF3 = 0x286 
.................... #word ADCBUF4 = 0x288 
.................... #word ADCBUF5 = 0x28A 
.................... #word ADCBUF6 = 0x28C 
.................... #word ADCBUF7 = 0x28E 
.................... #word ADCBUF8 = 0x290 
.................... #word ADCBUF9 = 0x292 
.................... #word ADCBUFA = 0x294 
.................... #word ADCBUFB = 0x296 
.................... #word ADCBUFC = 0x298 
.................... #word ADCBUFD = 0x29A 
.................... #word ADCBUFE = 0x29C 
.................... #word ADCBUFF = 0x29E 
.................... #word ADCON1 = 0x2A0 
.................... #word ADCON2 = 0x2A2 
.................... #word ADCON3 = 0x2A4 
.................... #word ADCHS = 0x2A6 
.................... #word ADPCFG = 0x2A8 
.................... #word ADCSSL = 0x2AA 
.................... #word TRISA = 0x2C0 
.................... #word PORTA = 0x2C2 
.................... #word LATA = 0x2C4 
.................... #word TRISB = 0x2C6 
.................... #word PORTB = 0x2C8 
.................... #word LATB = 0x2CA 
.................... #word TRISC = 0x2CC 
.................... #word PORTC = 0x2CE 
.................... #word LATC = 0x2D0 
.................... #word TRISD = 0x2D2 
.................... #word PORTD = 0x2D4 
.................... #word LATD = 0x2D6 
.................... #word TRISF = 0x2DE 
.................... #word PORTF = 0x2E0 
.................... #word LATF = 0x2E2 
.................... #word TRISG = 0x2E4 
.................... #word PORTG = 0x2E6 
.................... #word LATG = 0x2E8 
.................... #word C1RXF0SID = 0x300 
.................... #word C1RXF0EIDH = 0x302 
.................... #word C1RXF0EIDL = 0x304 
.................... #word C1RXF1SID = 0x308 
.................... #word C1RXF1EIDH = 0x30A 
.................... #word C1RXF1EIDL = 0x30C 
.................... #word C1RXF2SID = 0x310 
.................... #word C1RXF2EIDH = 0x312 
.................... #word C1RXF2EIDL = 0x314 
.................... #word C1RXF3SID = 0x318 
.................... #word C1RXF3EIDH = 0x31A 
.................... #word C1RXF3EIDL = 0x31C 
.................... #word C1RXF4SID = 0x320 
.................... #word C1RXF4EIDH = 0x322 
.................... #word C1RXF4EIDL = 0x324 
.................... #word C1RXF5SID = 0x328 
.................... #word C1RXF5EIDH = 0x32A 
.................... #word C1RXF5EIDL = 0x32C 
.................... #word C1RXM0SID = 0x330 
.................... #word C1RXM0EIDH = 0x332 
.................... #word C1RXM0EIDL = 0x334 
.................... #word C1RXM1SID = 0x338 
.................... #word C1RXM1EIDH = 0x33A 
.................... #word C1RXM1EIDL = 0x33C 
.................... #word C1TX2SID = 0x340 
.................... #word C1TX2EID = 0x342 
.................... #word C1TX2DLC = 0x344 
.................... #word C1TX2B1 = 0x346 
.................... #word C1TX2B2 = 0x348 
.................... #word C1TX2B3 = 0x34A 
.................... #word C1TX2B4 = 0x34C 
.................... #word C1TX2CON = 0x34E 
.................... #word C1TX1SID = 0x350 
.................... #word C1TX1EID = 0x352 
.................... #word C1TX1DLC = 0x354 
.................... #word C1TX1B1 = 0x356 
.................... #word C1TX1B2 = 0x358 
.................... #word C1TX1B3 = 0x35A 
.................... #word C1TX1B4 = 0x35C 
.................... #word C1TX1CON = 0x35E 
.................... #word C1TX0SID = 0x360 
.................... #word C1TX0EID = 0x362 
.................... #word C1TX0DLC = 0x364 
.................... #word C1TX0B1 = 0x366 
.................... #word C1TX0B2 = 0x368 
.................... #word C1TX0B3 = 0x36A 
.................... #word C1TX0B4 = 0x36C 
.................... #word C1TX0CON = 0x36E 
.................... #word C1RX1SID = 0x370 
.................... #word C1RX1EID = 0x372 
.................... #word C1RX1DLC = 0x374 
.................... #word C1RX1B1 = 0x376 
.................... #word C1RX1B2 = 0x378 
.................... #word C1RX1B3 = 0x37A 
.................... #word C1RX1B4 = 0x37C 
.................... #word C1RX1CON = 0x37E 
.................... #word C1RX0SID = 0x380 
.................... #word C1RX0EID = 0x382 
.................... #word C1RX0DLC = 0x384 
.................... #word C1RX0B1 = 0x386 
.................... #word C1RX0B2 = 0x388 
.................... #word C1RX0B3 = 0x38A 
.................... #word C1RX0B4 = 0x38C 
.................... #word C1RX0CON = 0x38E 
.................... #word C1CTRL = 0x390 
.................... #word C1CFG1 = 0x392 
.................... #word C1CFG2 = 0x394 
.................... #word C1INTF = 0x396 
.................... #word C1INTE = 0x398 
.................... #word C1EC = 0x39A 
.................... #word C2RXF0SID = 0x3C0 
.................... #word C2RXF0EIDH = 0x3C2 
.................... #word C2RXF0EIDL = 0x3C4 
.................... #word C2RXF1SID = 0x3C8 
.................... #word C2RXF1EIDH = 0x3CA 
.................... #word C2RXF1EIDL = 0x3CC 
.................... #word C2RXF2SID = 0x3D0 
.................... #word C2RXF2EIDH = 0x3D2 
.................... #word C2RXF2EIDL = 0x3D4 
.................... #word C2RXF3SID = 0x3D8 
.................... #word C2RXF3EIDH = 0x3DA 
.................... #word C2RXF3EIDL = 0x3DC 
.................... #word C2RXF4SID = 0x3E0 
.................... #word C2RXF4EIDH = 0x3E2 
.................... #word C2RXF4EIDL = 0x3E4 
.................... #word C2RXF5SID = 0x3E8 
.................... #word C2RXF5EIDH = 0x3EA 
.................... #word C2RXF5EIDL = 0x3EC 
.................... #word C2RXM0SID = 0x3F0 
.................... #word C2RXM0EIDH = 0x3F2 
.................... #word C2RXM0EIDL = 0x3F4 
.................... #word C2RXM1SID = 0x3F8 
.................... #word C2RXM1EIDH = 0x3FA 
.................... #word C2RXM1EIDL = 0x3FC 
.................... #word C2TX2SID = 0x400 
.................... #word C2TX2EID = 0x402 
.................... #word C2TX2DLC = 0x404 
.................... #word C2TX2B1 = 0x406 
.................... #word C2TX2B2 = 0x408 
.................... #word C2TX2B3 = 0x40A 
.................... #word C2TX2B4 = 0x40C 
.................... #word C2TX2CON = 0x40E 
.................... #word C2TX1SID = 0x410 
.................... #word C2TX1EID = 0x412 
.................... #word C2TX1DLC = 0x414 
.................... #word C2TX1B1 = 0x416 
.................... #word C2TX1B2 = 0x418 
.................... #word C2TX1B3 = 0x41A 
.................... #word C2TX1B4 = 0x41C 
.................... #word C2TX1CON = 0x41E 
.................... #word C2TX0SID = 0x420 
.................... #word C2TX0EID = 0x422 
.................... #word C2TX0DLC = 0x424 
.................... #word C2TX0B1 = 0x426 
.................... #word C2TX0B2 = 0x428 
.................... #word C2TX0B3 = 0x42A 
.................... #word C2TX0B4 = 0x42C 
.................... #word C2TX0CON = 0x42E 
.................... #word C2RX1SID = 0x430 
.................... #word C2RX1EID = 0x432 
.................... #word C2RX1DLC = 0x434 
.................... #word C2RX1B1 = 0x436 
.................... #word C2RX1B2 = 0x438 
.................... #word C2RX1B3 = 0x43A 
.................... #word C2RX1B4 = 0x43C 
.................... #word C2RX1CON = 0x43E 
.................... #word C2RX0SID = 0x440 
.................... #word C2RX0EID = 0x442 
.................... #word C2RX0DLC = 0x444 
.................... #word C2RX0B1 = 0x446 
.................... #word C2RX0B2 = 0x448 
.................... #word C2RX0B3 = 0x44A 
.................... #word C2RX0B4 = 0x44C 
.................... #word C2RX0CON = 0x44E 
.................... #word C2CTRL = 0x450 
.................... #word C2CFG1 = 0x452 
.................... #word C2CFG2 = 0x454 
.................... #word C2INTF = 0x456 
.................... #word C2INTE = 0x458 
.................... #word C2EC = 0x45A 
.................... #word RCON = 0x740 
.................... #word OSCCON = 0x742 
.................... #word OSCTUN = 0x744 
.................... #word NVMCON = 0x760 
.................... #word NVMADR = 0x762 
.................... #word NVMADRU = 0x764 
.................... #word NVMKEY = 0x766 
.................... #word PMD1 = 0x770 
.................... #word PMD2 = 0x772 
....................  
....................  
.................... // Fuses 
.................... #fuses NOWDT, HS2_PLL8, NOPUT, NOPROTECT, DEBUG, NOBROWNOUT, NOWRTÂ  
.................... #device ICD=TRUE 
.................... // DÃ©finit la vitesse du quartz (prendre en compte si PLL employÃ©e) 
.................... #use delay(clock=80000000) 
*
00E90:  CP0     W0
00E92:  BTSC.B  42.1
00E94:  BRA     EA2
00E96:  REPEAT  #E1B
00E98:  NOP     
00E9A:  REPEAT  #3FFE
00E9C:  NOP     
00E9E:  DEC     W0,W0
00EA0:  BRA     NZ,E96
00EA2:  RETURN  
.................... // Config IIC 
.................... #use i2c(master,force_hw,slow,I2C1) 
*
00DE4:  MOV     #FFFF,W0
00DE6:  BTSS.B  208.3
00DE8:  BRA     DF4
00DEA:  BTSC.B  209.6
00DEC:  BRA     DEA
00DEE:  MOV     W1,202
00DF0:  BTSC.B  209.6
00DF2:  BRA     DF0
00DF4:  MOV     #0,W0
00DF6:  BTSC.B  209.7
00DF8:  INC     W0,W0
00DFA:  RETURN  
*
085E0:  MOV     #FFFF,W0
085E2:  BTSS.B  208.3
085E4:  BRA     8608
085E6:  MOV     206,W2
085E8:  AND     W2,#1F,W2
085EA:  BRA     NZ,85E6
085EC:  BSET.B  206.3
085EE:  BTSC    W1.0
085F0:  BCLR.B  206.5
085F2:  BTSS    W1.0
085F4:  BSET.B  206.5
085F6:  MOV     206,W2
085F8:  AND     W2,#1F,W2
085FA:  BRA     NZ,85F6
085FC:  BSET.B  206.4
085FE:  BTSS.B  208.1
08600:  BRA     85FE
08602:  MOV     200,W0
08604:  BTSC.B  208.6
08606:  BCLR.B  208.6
08608:  RETURN  
.................... #build(stack=2048) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,STREAM=ROBOTEQ) // Pour pouvoir utiliser le RS232/2 
....................  
....................  
.................... // Variables utiles (globales) 
.................... int1 flagGameEnd=0,flagTimeOut=0;	// DÃ©finit si le temps est dÃ©passÃ© 
.................... int1 flagBaliseCheck=0;				// DÃ©finit si adversaire dÃ©tectÃ© 
.................... int1 flagError=0; 					// Si une erreur doit Ãªtre affichÃ©e 
.................... int1 ToDisplay=0; 
.................... int1 IsPassedTimeOut=0; 
.................... int1 flag_depl_ok = 0; 
.................... int1 flag_end = 0; 
.................... int1 _Detected = 0;  
.................... int1 balise_on = 0; 
.................... int1 flag_error = 0;  
.................... int1 Team=0; 
.................... signed int32 ActualPosition = 0; 
.................... unsigned int8 value_balise=0;	// Valeur de la balise en dÃ©tection 
.................... unsigned int32 RealTimeMS=0,BeginTimeMS=0,GameTimeMS=0; 
.................... unsigned int8 GameTimeS=0;	// Temps de jeu 
.................... unsigned int8 Time_detected = 0; 
.................... unsigned int8 TIME_tempo_dectected = 6; 
.................... unsigned int8 No_erreur = 0;  
.................... unsigned int8 Value_bal = 0;  
.................... unsigned int8 Tempo_bal = 0 ;  
....................  
....................  
.................... unsigned int8 NoObj = 1; 
.................... unsigned int8 NoPts = 1; 
.................... unsigned int32 last_obj = 0; 
....................  
.................... #define TimeLimit 100 
.................... unsigned int16 TabZonesInterdites [5] [2] = {0}; 
....................  
....................  
.................... // DÃ©finit les constantes ASCII, comme il n'a pas l'air de les prendre ... 
.................... enum{NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL,BS,TAB,LF,VT,FF,CR,SO,SI,DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB,CAN,EM,SUB,ESC,FS,GS,RS,US,SPACE}; 
.................... enum{Init, Choose_objectif, Check_ZI, Send_depl_action, Send_depl_action_ZI, Depl_action_process, Depl_action_process_ZI,Switch_end_obj,Wait_end} Etat_rob = Init; 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	#define BalSensitivity 4 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Inclusion des fichiers sources 
.................... #include "driver_moteur.c" 
.................... //========================================================================================== 
.................... //																							 
.................... //						EMVs - Fonctions pour DRIVER MOTEUR MAXON 											 
.................... //						--------------------------												 
.................... //																							 
.................... //========================================================================================= 
.................... //	Développé par:		: Carrupt Aurélien    												 
.................... //						: Duay Daniel    												 
.................... //  Date				: 15.03.2013															 
.................... //  Date de modif.		: 14.02.2017															 
.................... //  Nom de la lib	 	: driver_moteur.c													 
.................... //  Version 			: V2.1																 
.................... //========================================================================================= 
.................... // Description :																			 
.................... //=============																			 
.................... //	Ce code contient les fonctions qui permettent au master de communiquer avec le driver  	 
.................... //	de moteur V3.0																			 
.................... //   
.................... //======================================================================================== 
.................... //DIRECTIVES DE PRECOMPILATIONS 
.................... //======================================================================================== 
....................  
.................... #DEFINE DRV_MODE_COURANT 0		// !!!!!!  NON IMPLEMENTE !!!!!   régulation en mode courant  
.................... #DEFINE DRV_MODE_VITESSE 1		// régulation en mode vitesse  
.................... #DEFINE DRV_MODE_NON_REGUL 2	// mode régulation désactivée  
.................... #DEFINE DRV_STOP 0				// Arrêt du moteur et arrêt d'urgence 
.................... #DEFINE DRV_RESET 1				// Reset du driver 
....................  
.................... #DEFINE DRV_ARRET_COURANT 0					// Arret en courant  
.................... #DEFINE DRV_ARRET_POSITION_ABSOLUE 1		// Arret en position absoulue 
.................... #DEFINE DRV_ARRET_POSITION_RELATIVE 2		// Arret en position relative 
.................... #DEFINE DRV_ARRET_TEMPS 3					// Arret en position temps  
.................... 			 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: go_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer un ordre de déplacement au moteur		 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					direction :			sens de rotation du moteur (int8) -> 0 ou 1																			 
.................... //					mode_regulation : 	!!!!!!  NON IMPLEMENTE !!!!!  DRV_MODE_COURANT (int8) -> régulation en courant ->paramètre_1 = valeur du courant qu'on souhaite maintenir [mA] (int16) 
.................... //										DRV_MODE_VITESSE (int8) -> régulation en vitesse  ->paramètre_1 = valeur de vitesse qu'on souhaite maintenir [impulse/s] (int16) 
.................... //										DRV_MODE_NON_REGUL (int8) -> régulation désactivée ->paramètre_1 = valeur de la PWM 0-100 en %  (int16) 
.................... //					mode_d'arret 	: 	DRV_ARRET_POSITION_ABSOLUE (int8)	-> 	parametre_2 = position a atteindre [impulse] (int32)																			   
.................... //										DRV_ARRET_POSITION_RELATIVE (int8)	->	parametre_2 = nombre d'impulsion d'encodeur a effectuer [impulse] (int32) 
.................... //										DRV_ARRET_TEMPS (int8)				->	parametre_2 = temps du parcours [ms] (int32) 
.................... //										DRV_ARRET_COURANT (int8)			->	parametre_2 = valeur du courant d'arrêt souhaité [mA] (int32)								 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 go_driver_moteur(int8 adresse_driver, int8 direction, int8 mode_regulation, int16 parametre_1, int8 mode_arret, signed int32 parametre_2) 
*
0874A:  MOV     W5,[W15++]
0874C:  MOV     W6,[W15++]
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
.................... 	int8 config; 
.................... 	 
.................... 	 
.................... 	config = ((mode_regulation & 0b00000111)<<5) + ((direction & 0b00000001)<<4) + (mode_arret & 0b00000111); 
0874E:  MOV.B   1B32,W0L
08750:  SE      W0,W0
08752:  AND     W0,#7,W5
08754:  SL      W5,#5,W5
08756:  MOV.B   1B31,W0L
08758:  SE      W0,W0
0875A:  AND     W0,#1,W6
0875C:  SL      W6,#4,W0
0875E:  ADD     W0,W5,W5
08760:  MOV.B   1B33,W0L
08762:  SE      W0,W0
08764:  AND     W0,#7,W0
08766:  ADD     W0,W5,W0
08768:  MOV.B   W0L,1B40
.................... 	val1 = make8(parametre_1, 0); 
0876A:  MOV.B   1B34,W0L
0876C:  MOV.B   W0L,1B3A
.................... 	val2 = make8(parametre_1, 1); 
0876E:  MOV.B   1B35,W0L
08770:  MOV.B   W0L,1B3B
.................... 	val3 = make8(parametre_2, 0); 
08772:  MOV.B   1B36,W0L
08774:  MOV.B   W0L,1B3C
.................... 	val4 = make8(parametre_2, 1); 
08776:  MOV.B   1B37,W0L
08778:  MOV.B   W0L,1B3D
.................... 	val5 = make8(parametre_2, 2); 
0877A:  MOV.B   1B38,W0L
0877C:  MOV.B   W0L,1B3E
.................... 	val6 = make8(parametre_2, 3); 
0877E:  MOV.B   1B39,W0L
08780:  MOV.B   W0L,1B3F
.................... 	 
.................... 	i2c_start(); 
08782:  BTSS.B  208.3
08784:  BRA     878E
08786:  BSET.B  206.1
08788:  BTSC.B  206.1
0878A:  BRA     8788
0878C:  BRA     8794
0878E:  BSET.B  206.0
08790:  BTSC.B  206.0
08792:  BRA     8790
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
08794:  MOV.B   1B30,W0L
08796:  MOV.B   W0L,2
08798:  CALL    DE4
0879C:  CP0.B   W0L
0879E:  BRA     NZ,87E2
.................... 	{ 
.................... 		i2c_write(0x48);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
087A0:  MOV.B   #48,W1L
087A2:  CALL    DE4
.................... 		i2c_write(config);					//configuration 
087A6:  MOV.B   1B40,W0L
087A8:  MOV.B   W0L,2
087AA:  CALL    DE4
.................... 		i2c_write(val1);					// parametre_1 
087AE:  MOV.B   1B3A,W0L
087B0:  MOV.B   W0L,2
087B2:  CALL    DE4
.................... 		i2c_write(val2); 
087B6:  MOV.B   1B3B,W0L
087B8:  MOV.B   W0L,W1L
087BA:  CALL    DE4
.................... 		i2c_write(val3);					// parametre_2 
087BE:  MOV.B   1B3C,W0L
087C0:  MOV.B   W0L,2
087C2:  CALL    DE4
.................... 		i2c_write(val4); 
087C6:  MOV.B   1B3D,W0L
087C8:  MOV.B   W0L,W1L
087CA:  CALL    DE4
.................... 		i2c_write(val5);					 
087CE:  MOV.B   1B3E,W0L
087D0:  MOV.B   W0L,2
087D2:  CALL    DE4
.................... 		i2c_write(val6); 
087D6:  MOV.B   1B3F,W0L
087D8:  MOV.B   W0L,W1L
087DA:  CALL    DE4
.................... 	} 
087DE:  GOTO    87F4
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
087E2:  MOV     #1F,W0
087E4:  AND     206,W0
087E6:  BRA     NZ,87E2
087E8:  BSET.B  206.2
087EA:  BTSC.B  206.2
087EC:  BRA     87EA
.................... 		return 2; 
087EE:  MOV.B   #2,W0L
087F0:  MOV.B   W0L,0
087F2:  BRA     8804
.................... 	} 
.................... 	i2c_stop();	 
087F4:  MOV     #1F,W0
087F6:  AND     206,W0
087F8:  BRA     NZ,87F4
087FA:  BSET.B  206.2
087FC:  BTSC.B  206.2
087FE:  BRA     87FC
.................... 	return 1; 
08800:  MOV.B   #1,W0L
08802:  MOV.B   W0L,0
08804:  MOV     [--W15],W6
08806:  MOV     [--W15],W5
08808:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur_pid																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les valeurs du PID du régulateur driver moteur	 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					reg_P 			= Valeur P du régulateur (int16)  valeur en millième  ex: 1250 = 1.25 
.................... //					reg_I 			= Valeur I du régulateur (int16)			idem 
.................... //					reg_D 			= Valeur D du régulateur (int16)			idem 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur_pid(int8 adresse_driver, int16 reg_P, int16 reg_I, int16 reg_D) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
....................  
.................... 	val1 = make8(reg_P, 0); 
*
00DFC:  MOV.B   1B2C,W0L
00DFE:  MOV.B   W0L,1B2B
.................... 	val2 = make8(reg_P, 1); 
00E00:  MOV.B   1B2D,W0L
00E02:  MOV.B   W0L,1B32
.................... 	val3 = make8(reg_I, 0); 
00E04:  MOV.B   1B2E,W0L
00E06:  MOV.B   W0L,1B33
.................... 	val4 = make8(reg_I, 1); 
00E08:  MOV.B   1B2F,W0L
00E0A:  MOV.B   W0L,1B34
.................... 	val5 = make8(reg_D, 0); 
00E0C:  MOV.B   1B30,W0L
00E0E:  MOV.B   W0L,1B35
.................... 	val6 = make8(reg_D, 1); 
00E10:  MOV.B   1B31,W0L
00E12:  MOV.B   W0L,1B36
....................  
.................... 	i2c_start(); 
00E14:  BTSS.B  208.3
00E16:  BRA     E20
00E18:  BSET.B  206.1
00E1A:  BTSC.B  206.1
00E1C:  BRA     E1A
00E1E:  BRA     E26
00E20:  BSET.B  206.0
00E22:  BTSC.B  206.0
00E24:  BRA     E22
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00E26:  MOV.B   1B2A,W0L
00E28:  MOV.B   W0L,2
00E2A:  CALL    DE4
00E2E:  CP0.B   W0L
00E30:  BRA     NZ,E6C
.................... 	{ 
.................... 		i2c_write(0x37);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00E32:  MOV.B   #37,W1L
00E34:  CALL    DE4
.................... 		i2c_write(val1);					// parametre P 
00E38:  MOV.B   1B2B,W0L
00E3A:  MOV.B   W0L,W1L
00E3C:  CALL    DE4
.................... 		i2c_write(val2); 
00E40:  MOV.B   1B32,W0L
00E42:  MOV.B   W0L,2
00E44:  CALL    DE4
.................... 		i2c_write(val3);					// parametre I 
00E48:  MOV.B   1B33,W0L
00E4A:  MOV.B   W0L,W1L
00E4C:  CALL    DE4
.................... 		i2c_write(val4); 
00E50:  MOV.B   1B34,W0L
00E52:  MOV.B   W0L,2
00E54:  CALL    DE4
.................... 		i2c_write(val5);					// parametre D					 
00E58:  MOV.B   1B35,W0L
00E5A:  MOV.B   W0L,W1L
00E5C:  CALL    DE4
.................... 		i2c_write(val6); 
00E60:  MOV.B   1B36,W0L
00E62:  MOV.B   W0L,2
00E64:  CALL    DE4
.................... 	} 
00E68:  GOTO    E7E
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00E6C:  MOV     #1F,W0
00E6E:  AND     206,W0
00E70:  BRA     NZ,E6C
00E72:  BSET.B  206.2
00E74:  BTSC.B  206.2
00E76:  BRA     E74
.................... 		return 2; 
00E78:  MOV.B   #2,W0L
00E7A:  MOV.B   W0L,0
00E7C:  BRA     E8E
.................... 	} 
.................... 	i2c_stop();	 
00E7E:  MOV     #1F,W0
00E80:  AND     206,W0
00E82:  BRA     NZ,E7E
00E84:  BSET.B  206.2
00E86:  BTSC.B  206.2
00E88:  BRA     E86
.................... 	return 1; 
00E8A:  MOV.B   #1,W0L
00E8C:  MOV.B   W0L,0
00E8E:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 18.03.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les rampes d'accélération et de décélération ainsi que le courant max du moteur 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					acceleration 	= valeur d'accélération en imp./sec (int16) 
.................... //					deceleration 	= valeur de décélération en imp./sec (int16)  
.................... //					courant_max 	= Valeur du courant max en mA (int16) 
.................... //					impuls_tour		= Impulsion par tour de moteur après le réducteur -> encodeur * réducteur 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur(int8 adresse_driver, int16 acceleration, int16 deceleration, int16 courant_max, int16 impuls_tour) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6, val7, val8; 
....................  
.................... 	val1 = make8(acceleration, 0); 
*
00EA4:  MOV.B   1B2C,W0L
00EA6:  MOV.B   W0L,1B2B
.................... 	val2 = make8(acceleration, 1); 
00EA8:  MOV.B   1B2D,W0L
00EAA:  MOV.B   W0L,1B34
.................... 	val3 = make8(deceleration, 0); 
00EAC:  MOV.B   1B2E,W0L
00EAE:  MOV.B   W0L,1B35
.................... 	val4 = make8(deceleration, 1); 
00EB0:  MOV.B   1B2F,W0L
00EB2:  MOV.B   W0L,1B36
.................... 	val5 = make8(courant_max, 0); 
00EB4:  MOV.B   1B30,W0L
00EB6:  MOV.B   W0L,1B37
.................... 	val6 = make8(courant_max, 1); 
00EB8:  MOV.B   1B31,W0L
00EBA:  MOV.B   W0L,1B38
.................... 	val7 = make8(impuls_tour, 0); 
00EBC:  MOV.B   1B32,W0L
00EBE:  MOV.B   W0L,1B39
.................... 	val8 = make8(impuls_tour, 1); 
00EC0:  MOV.B   1B33,W0L
00EC2:  MOV.B   W0L,1B3A
....................  
.................... 	i2c_start(); 
00EC4:  BTSS.B  208.3
00EC6:  BRA     ED0
00EC8:  BSET.B  206.1
00ECA:  BTSC.B  206.1
00ECC:  BRA     ECA
00ECE:  BRA     ED6
00ED0:  BSET.B  206.0
00ED2:  BTSC.B  206.0
00ED4:  BRA     ED2
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00ED6:  MOV.B   1B2A,W0L
00ED8:  MOV.B   W0L,2
00EDA:  CALL    DE4
00EDE:  CP0.B   W0L
00EE0:  BRA     NZ,F2C
.................... 	{ 
.................... 		i2c_write(0x29);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00EE2:  MOV.B   #29,W1L
00EE4:  CALL    DE4
.................... 		i2c_write(val1);					// accélération 
00EE8:  MOV.B   1B2B,W0L
00EEA:  MOV.B   W0L,W1L
00EEC:  CALL    DE4
.................... 		i2c_write(val2); 
00EF0:  MOV.B   1B34,W0L
00EF2:  MOV.B   W0L,2
00EF4:  CALL    DE4
.................... 		i2c_write(val3);					// décélération 
00EF8:  MOV.B   1B35,W0L
00EFA:  MOV.B   W0L,W1L
00EFC:  CALL    DE4
.................... 		i2c_write(val4); 
00F00:  MOV.B   1B36,W0L
00F02:  MOV.B   W0L,2
00F04:  CALL    DE4
.................... 		i2c_write(val5);					// courant max					 
00F08:  MOV.B   1B37,W0L
00F0A:  MOV.B   W0L,W1L
00F0C:  CALL    DE4
.................... 		i2c_write(val6); 
00F10:  MOV.B   1B38,W0L
00F12:  MOV.B   W0L,2
00F14:  CALL    DE4
.................... 		i2c_write(val7);					// impulsion par tour					 
00F18:  MOV.B   1B39,W0L
00F1A:  MOV.B   W0L,W1L
00F1C:  CALL    DE4
.................... 		i2c_write(val8); 
00F20:  MOV.B   1B3A,W0L
00F22:  MOV.B   W0L,2
00F24:  CALL    DE4
.................... 	} 
00F28:  GOTO    F3E
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00F2C:  MOV     #1F,W0
00F2E:  AND     206,W0
00F30:  BRA     NZ,F2C
00F32:  BSET.B  206.2
00F34:  BTSC.B  206.2
00F36:  BRA     F34
.................... 		return 2; 
00F38:  MOV.B   #2,W0L
00F3A:  MOV.B   W0L,0
00F3C:  BRA     F4E
.................... 	} 
.................... 	i2c_stop();	 
00F3E:  MOV     #1F,W0
00F40:  AND     206,W0
00F42:  BRA     NZ,F3E
00F44:  BSET.B  206.2
00F46:  BTSC.B  206.2
00F48:  BRA     F46
.................... 	return 1; 
00F4A:  MOV.B   #1,W0L
00F4C:  MOV.B   W0L,0
00F4E:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer des ordres courts direct comme d'arrêter le moteur même s'il n'a pas fini l'ordre précédent ou reset le driver 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver	(int8) 
.................... //					ordre		 	= ordre à effectuer (stop = 0, reset = 1) (int8) 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 driver_moteur(int8 adresse_driver, int8 ordre) 
*
0865A:  MOV     W5,[W15++]
.................... { 
.................... 	i2c_start(); 
0865C:  BTSS.B  208.3
0865E:  BRA     8668
08660:  BSET.B  206.1
08662:  BTSC.B  206.1
08664:  BRA     8662
08666:  BRA     866E
08668:  BSET.B  206.0
0866A:  BTSC.B  206.0
0866C:  BRA     866A
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
0866E:  MOV.B   1B2E,W0L
08670:  MOV.B   W0L,2
08672:  CALL    DE4
08676:  CP0.B   W0L
08678:  BRA     NZ,868E
.................... 	{ 
.................... 		i2c_write(((ordre << 4) & 0b00010000) + 0x01);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
0867A:  MOV     1B2E,W5
0867C:  LSR     W5,#8,W5
0867E:  SL      W5,#4,W5
08680:  AND     W5,#10,W5
08682:  ADD     W5,#1,W5
08684:  MOV.B   W5L,W1L
08686:  CALL    DE4
.................... 	} 
0868A:  GOTO    86A0
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
0868E:  MOV     #1F,W0
08690:  AND     206,W0
08692:  BRA     NZ,868E
08694:  BSET.B  206.2
08696:  BTSC.B  206.2
08698:  BRA     8696
.................... 		return 2; 
0869A:  MOV.B   #2,W0L
0869C:  MOV.B   W0L,0
0869E:  BRA     86B0
.................... 	} 
.................... 	i2c_stop();	 
086A0:  MOV     #1F,W0
086A2:  AND     206,W0
086A4:  BRA     NZ,86A0
086A6:  BSET.B  206.2
086A8:  BTSC.B  206.2
086AA:  BRA     86A8
.................... 	return 1; 
086AC:  MOV.B   #1,W0L
086AE:  MOV.B   W0L,0
086B0:  MOV     [--W15],W5
086B2:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_driver_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  Permet de lire l'état du driver								      	 
.................... == paramètre 	:  Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  retourne le status du driver											 
.................... ==				   0-> Arret  (le driver a fini tout traitement et attend le prochain ordre)	 
.................... ==				   1-> Marche (le driver est entrain d'exécuter l'ordre)													 
.................... ==				   2-> Surcharge (le driver a dépassé la limite de courant max. défini par l'utilisateur)															 
.................... ==				   3-> Erreur PONT-H (Température IC trop élevée, courant trop élevé) 
.................... ==				   4-> BUSY (le slave est entrain de traiter la prochaine commande) 
.................... ==				   5-> not ready  (le slave ne répond pas)															 
.................... /*===================================================================================================================================================================================================*/ 
.................... unsigned int8 read_driver_moteur(int8 adresse_driver) 
*
0860A:  MOV     W5,[W15++]
0860C:  CLR.B   1B39
0860E:  CLR.B   1B3A
.................... { 
.................... 	int8 driver_etat=0; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
08610:  BTSS.B  208.3
08612:  BRA     861C
08614:  BSET.B  206.1
08616:  BTSC.B  206.1
08618:  BRA     8616
0861A:  BRA     8622
0861C:  BSET.B  206.0
0861E:  BTSC.B  206.0
08620:  BRA     861E
.................... 	ack = i2c_write(adresse_driver+1); 
08622:  MOV.B   1B38,W0L
08624:  SE      W0,W0
08626:  ADD     W0,#1,W5
08628:  MOV.B   W5L,W1L
0862A:  CALL    DE4
0862E:  MOV.B   W0L,1B3A
.................... 	if(ack == 0) 
08630:  MOV.B   1B3A,W0L
08632:  SE      W0,W0
08634:  CP0     W0
08636:  BRA     NZ,8644
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
08638:  CLR.B   W1
0863A:  CALL    85E0
0863E:  MOV.B   W0L,1B39
.................... 	} 
08640:  GOTO    8648
.................... 	else driver_etat = 5; 
08644:  MOV.B   #5,W0L
08646:  MOV.B   W0L,1B39
....................  
.................... 	i2c_stop(); 
08648:  MOV     #1F,W0
0864A:  AND     206,W0
0864C:  BRA     NZ,8648
0864E:  BSET.B  206.2
08650:  BTSC.B  206.2
08652:  BRA     8650
.................... 	return driver_etat; 
08654:  MOV.B   1B39,W0L
08656:  MOV     [--W15],W5
08658:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_pos_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  	Permet de lire la valeur du capteur incrémental du moteur 
.................... ==					Attention n'utiliser cette fonction seulement quand le moteur est à l'arrêt, sinon il y a un risque de faire planter la communication I2C						      	 
.................... == paramètre 	:  	Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  	signed 32bits -> la valeur actuel du capteur incrémental du moteur 
.................... ==					2147483647 -> interdiction de lire la position pendant un mouvement 
.................... ==					2147483648 -> not ready  (le slave ne répond pas)  
.................... ==				    
.................... /*===================================================================================================================================================================================================*/ 
.................... signed int32 read_pos_moteur(int8 adresse_driver) 
*
086B4:  MOV     W5,[W15++]
086B6:  CLR.B   1B2F
.................... { 
.................... 	int8 ack=0; 
.................... 	unsigned int8 buffer[4]; 
.................... 	signed int32 pos_value; 
....................  
.................... 	if (read_driver_moteur(adresse_driver) != 1) 
086B8:  MOV.B   1B2E,W0L
086BA:  MOV.B   W0L,1B38
086BC:  CALL    860A
086C0:  CP.B    W0L,#1
086C2:  BRA     Z,873C
.................... 		{ 
.................... 			i2c_start(); 
086C4:  BTSS.B  208.3
086C6:  BRA     86D0
086C8:  BSET.B  206.1
086CA:  BTSC.B  206.1
086CC:  BRA     86CA
086CE:  BRA     86D6
086D0:  BSET.B  206.0
086D2:  BTSC.B  206.0
086D4:  BRA     86D2
.................... 			ack = i2c_write(adresse_driver+1); 
086D6:  MOV.B   1B2E,W0L
086D8:  SE      W0,W0
086DA:  ADD     W0,#1,W5
086DC:  MOV.B   W5L,W1L
086DE:  CALL    DE4
086E2:  MOV.B   W0L,1B2F
.................... 			if(ack == 0) 
086E4:  MOV.B   1B2F,W0L
086E6:  SE      W0,W0
086E8:  CP0     W0
086EA:  BRA     NZ,8726
.................... 			{ 
.................... 				i2c_read(1); 
086EC:  MOV.B   #1,W1L
086EE:  CALL    85E0
.................... 				buffer[0]=i2c_read(1); 
086F2:  MOV.B   #1,W1L
086F4:  CALL    85E0
086F8:  MOV.B   W0L,1B30
.................... 				buffer[1]=i2c_read(1); 
086FA:  MOV.B   #1,W1L
086FC:  CALL    85E0
08700:  MOV.B   W0L,1B31
.................... 				buffer[2]=i2c_read(1); 
08702:  MOV.B   #1,W1L
08704:  CALL    85E0
08708:  MOV.B   W0L,1B32
.................... 				buffer[3]=i2c_read(0); 
0870A:  CLR.B   W1
0870C:  CALL    85E0
08710:  MOV.B   W0L,1B33
.................... 				pos_value = make32(buffer[3],buffer[2],buffer[1],buffer[0]); 
08712:  MOV.B   1B33,W0L
08714:  MOV.B   W0L,1B37
08716:  MOV.B   1B32,W0L
08718:  MOV.B   W0L,1B36
0871A:  MOV.B   1B31,W0L
0871C:  MOV.B   W0L,1B35
0871E:  MOV.B   1B30,W0L
08720:  MOV.B   W0L,1B34
.................... 			} 
08722:  GOTO    872C
.................... 			else pos_value = 2147483648; 
08726:  CLR     1B34
08728:  MOV     #8000,W4
0872A:  MOV     W4,1B36
.................... 		 
.................... 			i2c_stop(); 
0872C:  MOV     #1F,W0
0872E:  AND     206,W0
08730:  BRA     NZ,872C
08732:  BSET.B  206.2
08734:  BTSC.B  206.2
08736:  BRA     8734
.................... 		} 
08738:  GOTO    8742
.................... 	else pos_value = 2147483647; 
0873C:  SETM    1B34
0873E:  MOV     #7FFF,W4
08740:  MOV     W4,1B36
....................  
.................... 	return pos_value; 
08742:  MOV     1B34,W0
08744:  MOV     1B36,W1
08746:  MOV     [--W15],W5
08748:  RETURN  
.................... }	 
.................... 	 
.................... //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... #include "Com_balises.c" 
.................... #ifndef Com_balises 
.................... #define Com_balises 
.................... 	 
.................... void Balise_config_plage(int8 no_plage, int8 deb_plage, int8 fin_plage) 
.................... {	 
.................... 	i2c_start(); 
*
01016:  BTSS.B  208.3
01018:  BRA     1022
0101A:  BSET.B  206.1
0101C:  BTSC.B  206.1
0101E:  BRA     101C
01020:  BRA     1028
01022:  BSET.B  206.0
01024:  BTSC.B  206.0
01026:  BRA     1024
.................... 	i2c_write(0x20);			// adresse de la balise 
01028:  MOV.B   #20,W1L
0102A:  CALL    DE4
.................... 	i2c_write(0x10);			// instruction de config 
0102E:  MOV.B   #10,W1L
01030:  CALL    DE4
.................... 	i2c_write(no_plage); 
01034:  MOV.B   1B2A,W0L
01036:  MOV.B   W0L,2
01038:  CALL    DE4
.................... 	i2c_write(deb_plage); 
0103C:  MOV.B   1B2B,W0L
0103E:  MOV.B   W0L,W1L
01040:  CALL    DE4
.................... 	i2c_write(fin_plage); 
01044:  MOV.B   1B2C,W0L
01046:  MOV.B   W0L,2
01048:  CALL    DE4
.................... 	i2c_write('@');				// fin de la communication 
0104C:  MOV.B   #40,W1L
0104E:  CALL    DE4
.................... 	i2c_stop(); 
01052:  MOV     #1F,W0
01054:  AND     206,W0
01056:  BRA     NZ,1052
01058:  BSET.B  206.2
0105A:  BTSC.B  206.2
0105C:  BRA     105A
0105E:  RETURN  
.................... } 
....................  
.................... void Balise_set_plage(int8 select_plage) 
.................... { 
.................... 	i2c_start(); 
*
07272:  BTSS.B  208.3
07274:  BRA     727E
07276:  BSET.B  206.1
07278:  BTSC.B  206.1
0727A:  BRA     7278
0727C:  BRA     7284
0727E:  BSET.B  206.0
07280:  BTSC.B  206.0
07282:  BRA     7280
.................... 	i2c_write(0x20);			// adresse de la balise 
07284:  MOV.B   #20,W1L
07286:  CALL    DE4
.................... 	i2c_write(0x80);			// instruction de set 
0728A:  MOV.B   #80,W1L
0728C:  CALL    DE4
.................... 	i2c_write(select_plage); 
07290:  MOV.B   1B6C,W0L
07292:  MOV.B   W0L,2
07294:  CALL    DE4
.................... 	i2c_write('@');				// fin de la communication 
07298:  MOV.B   #40,W1L
0729A:  CALL    DE4
.................... 	i2c_stop();	 
0729E:  MOV     #1F,W0
072A0:  AND     206,W0
072A2:  BRA     NZ,729E
072A4:  BSET.B  206.2
072A6:  BTSC.B  206.2
072A8:  BRA     72A6
072AA:  RETURN  
.................... } 
....................  
.................... unsigned int8 Check_balise(void) 
.................... { 
.................... 	static unsigned int8 ack_balise=0; 
....................  
.................... 	i2c_start(); 
*
08C2A:  BTSS.B  208.3
08C2C:  BRA     8C36
08C2E:  BSET.B  206.1
08C30:  BTSC.B  206.1
08C32:  BRA     8C30
08C34:  BRA     8C3C
08C36:  BSET.B  206.0
08C38:  BTSC.B  206.0
08C3A:  BRA     8C38
.................... 	ack_balise=i2c_write(0x21);			// adresse de balise en lecture 
08C3C:  MOV.B   #21,W1L
08C3E:  CALL    DE4
08C42:  MOV.B   W0L,88E
.................... 	if(ack_balise==0) 
08C44:  CP0.B   88E
08C46:  BRA     NZ,8C54
.................... 	{					// si elle est dÃ©tectÃ©e - demander sa lecture 
.................... 		delay_us(30); 
08C48:  REPEAT  #256
08C4A:  NOP     
.................... 		value_balise=i2c_read(0); 
08C4C:  CLR.B   W1
08C4E:  CALL    85E0
08C52:  MOV.B   W0L,860
.................... 	} 
.................... 	i2c_stop(); 
08C54:  MOV     #1F,W0
08C56:  AND     206,W0
08C58:  BRA     NZ,8C54
08C5A:  BSET.B  206.2
08C5C:  BTSC.B  206.2
08C5E:  BRA     8C5C
....................  
.................... 	return value_balise; 
08C60:  MOV.B   860,W0L
08C62:  MOV.B   W0L,0
08C64:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Init.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 05.03.2015																== 
.................... ===  Nom du programme 	: InterfaceRoboteQuC.mcp													== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Fonctions d'initialisation du dsPIC30F6014A.				    								== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Init 
.................... #define ___Init 
....................  
.................... //**************************************************************************************************** 
.................... //*  Défintion des bits 
.................... //*  ! Utiliser LATx pour des sorties et PORTx pour des entrées lorsque commandes succintes rapides. ! 
.................... //**************************************************************************************************** 
.................... #bit _LED1 = LATC.1			//--| 
.................... #bit _LED2 = LATC.2			//	| 
.................... #bit _LED3 = LATC.3			//	|- LEDs 
.................... #bit _LED4 = LATC.4			//	| 
....................  
.................... #bit _DEMA = PORTA.10		//--| 
.................... #bit _TEAM = PORTA.12		//	| 
.................... #bit _Dig3 = PORTA.13		//	|- Digital Inputs 
.................... #bit _Dig4 = PORTA.6		//	| 
.................... #bit _ZeroPoint = PORTA.7		//  | 
.................... #bit _Dig6 = PORTA.9		//	| 
....................  
.................... #bit _Out1 = LATD.0 		//--| 
.................... #bit _Out2 = LATD.1	    //	| 
.................... #bit _Out3 = LATD.2 	 	//	| 
.................... #bit _Out4 = LATD.3 		//	|- Outputs 
.................... #bit _SERV = LATD.4		//	| 
.................... #bit _LDT1 = LATD.5 		//	| 
.................... #bit _LDT2 = LATD.6		//  | 
.................... #bit _Out8 = LATD.7		//	| 
....................  
.................... #bit _Tim1On = T1CON.15 
.................... #bit _Tim2On = T2CON.15 
.................... #bit _Tim3On = T3CON.15 
....................  
.................... #bit _I2CEN = I2CCON.15 
.................... #bit _GCEN = I2CCON.7 
....................  
.................... #bit _En_Diz = PORTB.10 
.................... #bit _EN_Uni = PORTB.11 
....................  
....................  
.................... enum{STOP,CHARGE_OBJ,DRIVER_GO,OBJ_PERSO,DRIVER_DONE,OBJ_DONE,WAIT}State=STOP; 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    __Init_dsPIC 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    30.01.2015 
.................... //  Statut :    Fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Config. et initialisation du dsPIC30F6014A. 
.................... //	Paramètre(s): / 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Init_dsPIC(void) 
.................... { 
.................... 	//------------------------------------------------------------------------------ 
.................... 	// Configuration des I/O 
.................... 	TRISA = 0b0011011011000000;		// RA6,7,9,10,12,13 : Digital Input 
*
00F50:  MOV     #36C0,W4
00F52:  MOV     W4,2C0
.................... 	PORTA=0; 
00F54:  CLR     2C2
.................... 	TRISB = 0b0000000000111100;		// RB2-5: Analog Input 
00F56:  MOV     #3C,W4
00F58:  MOV     W4,2C6
.................... 	PORTB=0; 
00F5A:  CLR     2C8
.................... 	TRISC = 0b0000000000000000;		// RC1-4: LEDs 
00F5C:  CLR     2CC
.................... 	PORTC=0; 
00F5E:  CLR     2CE
.................... 	TRISD = 0b0000000000000000;		// RD0-7: Outputs 
00F60:  CLR     2D2
.................... 	PORTD=0; 
00F62:  CLR     2D4
.................... 	TRISF = 0b0000000000010100;		// RF2-5: Rx1, Tx1, Rx2, Tx2 
00F64:  MOV     #14,W4
00F66:  MOV     W4,2DE
.................... 	PORTF=0; 
00F68:  CLR     2E0
.................... 	TRISG = 0b0000000000001100;		// RG2-3: SCL-SDA 
00F6A:  MOV     #C,W4
00F6C:  MOV     W4,2E4
.................... 	PORTG=0;  
00F6E:  CLR     2E6
....................  
....................  
.................... // configuration de l'I2C 
.................... 	I2CCON = 0x800f;//LAISSER, SINON L'I2C PLANTE 
00F70:  MOV     #800F,W4
00F72:  MOV     W4,206
.................... //	_GCEN=0; 
.................... //	_I2CEN=1; 
.................... 	 
.................... 	// Temps de jeu 
.................... 	// Set le timer1 à 1 [ms] 
.................... 	setup_timer1(TMR_INTERNAL,0x4E20);	 
00F74:  CLR     104
00F76:  MOV     #4E20,W4
00F78:  MOV     W4,102
00F7A:  MOV     #8000,W4
00F7C:  MOV     W4,104
....................  
.................... 	// Capture balise 
.................... 	// Set le timer3 avec la fréquence interne, incrément chaque 64 instructions, jusque 31250 => 100 [ms] 
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, 31250); 
00F7E:  CLR     112
00F80:  MOV     #7A12,W4
00F82:  MOV     W4,10E
00F84:  MOV     #8020,W4
00F86:  MOV     W4,112
.................... 	 
.................... 	// Autorise le timer1 
.................... 	enable_interrupts(INT_TIMER1); 
00F88:  BSET.B  8C.3
.................... 	// Autorise le timer3 
.................... 	enable_interrupts(INT_TIMER3); 
00F8A:  BSET.B  8C.7
.................... 	// Interruptions RS232 
.................... 	enable_interrupts(INT_RDA2);	// Réception RS232/1 
00F8C:  BSET.B  8F.0
.................... 	// Autorise les interruptions globalement 
.................... 	enable_interrupts(INTR_GLOBAL); 
00F8E:  BCLR.B  81.7
00F90:  CLR     42
00F92:  BSET.B  81.7
.................... 	 
.................... 	config_driver_moteur_pid(0xC0, 200, 1, 0); 
00F94:  MOV.B   #C0,W0L
00F96:  MOV.B   W0L,1B2A
00F98:  MOV     #C8,W4
00F9A:  MOV     W4,1B2C
00F9C:  MOV     #1,W4
00F9E:  MOV     W4,1B2E
00FA0:  CLR     1B30
00FA2:  CALL    DFC
.................... 	config_driver_moteur_pid(0xC2, 200, 1, 0); 
00FA6:  MOV.B   #C2,W0L
00FA8:  MOV.B   W0L,1B2A
00FAA:  MOV     #C8,W4
00FAC:  MOV     W4,1B2C
00FAE:  MOV     #1,W4
00FB0:  MOV     W4,1B2E
00FB2:  CLR     1B30
00FB4:  CALL    DFC
.................... 	delay_ms(10); 
00FB8:  MOV     #A,W0
00FBA:  CALL    E90
.................... 	 
.................... 	config_driver_moteur(0xC0, 5000, 5000, 1000,4556);//moteur barillet 
00FBE:  MOV.B   #C0,W0L
00FC0:  MOV.B   W0L,1B2A
00FC2:  MOV     #1388,W4
00FC4:  MOV     W4,1B2C
00FC6:  MOV     #1388,W4
00FC8:  MOV     W4,1B2E
00FCA:  MOV     #3E8,W4
00FCC:  MOV     W4,1B30
00FCE:  MOV     #11CC,W4
00FD0:  MOV     W4,1B32
00FD2:  CALL    EA4
.................... 	config_driver_moteur(0xC2, 5000, 5000, 2000,0);//moteur éjection 
00FD6:  MOV.B   #C2,W0L
00FD8:  MOV.B   W0L,1B2A
00FDA:  MOV     #1388,W4
00FDC:  MOV     W4,1B2C
00FDE:  MOV     #1388,W4
00FE0:  MOV     W4,1B2E
00FE2:  MOV     #7D0,W4
00FE4:  MOV     W4,1B30
00FE6:  CLR     1B32
00FE8:  CALL    EA4
.................... 	config_driver_moteur(0xC4, 5000, 5000, 1000,0);//moteur poussage 
00FEC:  MOV.B   #C4,W0L
00FEE:  MOV.B   W0L,1B2A
00FF0:  MOV     #1388,W4
00FF2:  MOV     W4,1B2C
00FF4:  MOV     #1388,W4
00FF6:  MOV     W4,1B2E
00FF8:  MOV     #3E8,W4
00FFA:  MOV     W4,1B30
00FFC:  CLR     1B32
00FFE:  CALL    EA4
.................... 	delay_ms(10); 
01002:  MOV     #A,W0
01004:  CALL    E90
.................... 	 
.................... 	return; 
01008:  RETURN  
.................... 	 
.................... } 
.................... 	 
.................... #endif 
....................  
.................... #include "data/___data.h" 
.................... /* 
.................... * \file ___data.h 
.................... * \brief Data pour le robot. 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.03.2016 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___data_H 
.................... #define ___data_H 
....................  
.................... 	 
.................... 	int1 Depl_send = 0; 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	////////// Gestion erreurs 
.................... 	int1 Base = 0; 
.................... 	int16 TableWidth =3000; 
.................... 	unsigned int8 NbreZone_check = 0; 
.................... 	char RoboteQ_receiveBuffer[256]={};			// Buffer des donnÃÂ©es reÃÂ§ues 
.................... 	unsigned int8 TabSentRS232[256]={0}; 
....................  
....................  
.................... 	//Zones interdites 
.................... 	struct Coord 
.................... 	{ 
.................... 		double X; 
.................... 		double Y; 
.................... 	}; 
....................  
.................... 	 
.................... 	int intersection_found = 0; 
.................... 	 
.................... 	int path_found = 0; 
.................... 	int relay_point_number = 0; 
.................... 	int i_rel = 0; 
.................... 	int i_depl = 0; 
.................... 	int TabIntersection[10]; 
.................... 	struct Coord PtsRelai[10], start, end; 
....................  
.................... 	//Tableau contenant les zone interdites. Chaque zone contient {x1, y1, x4, y4} 
.................... 	//zones interdites Ã©crites directement dans le code. !! Mettre en commentaire si on les lit depuis le PC !! 
.................... 	long TabZones[10][4] = {{200,150,270,180}, {20,150,70,180}, {0,0,0,0}, {0,0,0,0},{80,70,180,100},{0,0,0,0},{0,0,0,0},{30,30,50,50},{0,0,0,0},{150,15,250,50}}; 
.................... 	//long TabZones[10][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; 
.................... 	 
.................... 	unsigned int16 TIME_SURCHAUFFE_MS = 1000; 
.................... 	unsigned int8 Erreur_max_surchauffe = 10; 
.................... 	unsigned int32 Time_ejection = 0; 
.................... 	unsigned int32 Time_ejection_toDo = 0; 
.................... 	int1 Action_send = 0;	 
....................  
.................... 	signed int16 TabObjectifs[7][13][12] = {0}; 
....................  
.................... 	// Objectif en cours 
.................... 	signed int16 oXp=0,oYp=0,oType=0,oAvAr=0,oCoteTourn=0,oVitMax=0,Obj_Action = 0,Pt_commun = 0,Ponderation = 0,Obj_end = 0,Next_obj = 0,keep_obj = 0;	 
.................... 	 
.................... 	 
.................... 	////////// UART 
.................... 	unsigned int8 UART_WD_DELAY = 20;	// DÃ©lai du watchdog UART, en [ms]; par pas de 1 [ms] 
.................... 	unsigned int8 UART_NBR_REP_NAK = 5;	// Combien de fois maximum il faut rÃ©pÃ©ter une commande si le rÃ©cepteur n'a pas compris  
.................... 	// Adresse UART du driver 
.................... 	unsigned int32 UART_ADDR = 2; 
.................... 	 
.................... 	////////// IIC 
.................... 	// Combien de fois maximum il faut rÃ©pÃ©ter une commande si le rÃ©cepteur n'a pas compris 
.................... //	unsigned int8 IIC_NBR_REP_NAK = 5;	 
.................... 	// Combien de fois on rÃ©Ã©ssaie un envoie 
.................... //	unsigned int8 IIC_NBR_REP_ENV = 5; 
....................  	//Adresse IIC du driver 
.................... //	unsigned int8 DRIVER_IIC_ADR = 0x50; 
.................... //	unsigned int8 TabToSendIIC[60]={0}; 
....................  
.................... 	 
.................... 	////////// Balise ///////// 
.................... 	unsigned int8 MAX_VALUE_DETECT_BALISE = 3; // Valeur maximum pour la dÃ©tection de l'adversaire (action trig si <=) 
.................... 	unsigned int16 TIME_TO_CHECK_BAL=200;	// Temps avant chaque check balise 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Mise en marche/arrÃªt 
.................... int1 flagMarche = 0; 
....................  
.................... // Pour le nombre d'objectifs dÃ©jÃ  enregistrÃ©s 
.................... unsigned int16 NbreObjectifs = 0; 
.................... 	// Pour connaÃ®tre le prochain objectif Ã  atteindre 
.................... unsigned int16 NextObj = 0; 
....................  
.................... ////PC 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
06388:  MOV     W5,[W15++]
0638A:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
0638C:  BCLR.B  1B89.0
....................    y = x; 
0638E:  PUSH    1B84
06390:  POP     1B8A
06392:  PUSH    1B86
06394:  POP     1B8C
....................  
....................    if (x < 0) 
06396:  MOV     1B84,W0
06398:  MOV     1B86,W1
0639A:  MOV     #0,W2
0639C:  MOV     #0,W3
0639E:  CALL    604C
063A2:  BRA     NC,63B0
....................    { 
....................       s = 1; 
063A4:  BSET.B  1B89.0
....................       y = -y; 
063A6:  MOV     #1B8A,W0
063A8:  MOV     #1B8A,W1
063AA:  REPEAT  #3
063AC:  MOV     [W0++],[W1++]
063AE:  BTG.B   1B8D.7
....................    } 
....................  
....................    if (y <= 32768.0) 
063B0:  MOV     1B8A,W0
063B2:  MOV     1B8C,W1
063B4:  MOV     #0,W2
063B6:  MOV     #4700,W3
063B8:  CALL    604C
063BC:  BRA     C,63C0
063BE:  BRA     NZ,63D4
....................       res = (float32)(unsigned int16)y; 
063C0:  MOV     1B8A,W0
063C2:  MOV     1B8C,W1
063C4:  CALL    60B4
063C8:  CALL    60E0
063CC:  MOV     W0,1B8E
063CE:  MOV     W1,1B90
063D0:  GOTO    6468
....................  
....................  else if (y < 10000000.0) 
063D4:  MOV     1B8A,W0
063D6:  MOV     1B8C,W1
063D8:  MOV     #9680,W2
063DA:  MOV     #4B18,W3
063DC:  CALL    604C
063E0:  BRA     NC,6460
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
063E2:  MOV     1B8A,W0
063E4:  MOV     1B8C,W1
063E6:  MOV     #0,W2
063E8:  MOV     #3800,W3
063EA:  CALL    611A
063EE:  CALL    60B4
063F2:  MOV     W0,1B92
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
063F4:  MOV     1B8A,W0
063F6:  MOV     1B8C,W1
063F8:  MOV     #0,W2
063FA:  MOV     #3800,W3
063FC:  CALL    611A
06400:  MOV     W0,W5
06402:  MOV     W1,W6
06404:  MOV     1B92,W0
06406:  CALL    60E0
0640A:  BSET.B  43.0
0640C:  MOV     W0,W2
0640E:  MOV     W1,W3
06410:  MOV     W5,W0
06412:  MOV     W6,W1
06414:  CALL    61DE
06418:  MOV     W0,W2
0641A:  MOV     W1,W3
0641C:  MOV     #0,W0
0641E:  MOV     #4700,W1
06420:  CALL    611A
06424:  MOV     W0,1B8A
06426:  MOV     W1,1B8C
....................       res = 32768.0*(float32)l; 
06428:  MOV     1B92,W0
0642A:  CALL    60E0
0642E:  MOV     W0,W2
06430:  MOV     W1,W3
06432:  MOV     #0,W0
06434:  MOV     #4700,W1
06436:  CALL    611A
0643A:  MOV     W0,1B8E
0643C:  MOV     W1,1B90
....................       res += (float32)(unsigned int16)y; 
0643E:  MOV     1B8A,W0
06440:  MOV     1B8C,W1
06442:  CALL    60B4
06446:  CALL    60E0
0644A:  BCLR.B  43.0
0644C:  MOV     W0,W2
0644E:  MOV     W1,W3
06450:  MOV     1B8E,W0
06452:  MOV     1B90,W1
06454:  CALL    61DE
06458:  MOV     W0,1B8E
0645A:  MOV     W1,1B90
....................    } 
0645C:  GOTO    6468
....................  
....................  else 
....................   res = y; 
06460:  PUSH    1B8A
06462:  POP     1B8E
06464:  PUSH    1B8C
06466:  POP     1B90
....................  
....................  y = y - (float32)(unsigned int16)y; 
06468:  MOV     1B8A,W0
0646A:  MOV     1B8C,W1
0646C:  CALL    60B4
06470:  CALL    60E0
06474:  BSET.B  43.0
06476:  MOV     W0,W2
06478:  MOV     W1,W3
0647A:  MOV     1B8A,W0
0647C:  MOV     1B8C,W1
0647E:  CALL    61DE
06482:  MOV     W0,1B8A
06484:  MOV     W1,1B8C
....................  
....................  if (s) 
06486:  BTSS.B  1B89.0
06488:  BRA     6494
....................   res = -res; 
0648A:  MOV     #1B8E,W0
0648C:  MOV     #1B8E,W1
0648E:  REPEAT  #3
06490:  MOV     [W0++],[W1++]
06492:  BTG.B   1B91.7
....................  
....................  if (y != 0) 
06494:  MOV     1B8A,W0
06496:  MOV     1B8C,W1
06498:  MOV     #0,W2
0649A:  MOV     #0,W3
0649C:  CALL    604C
064A0:  BRA     Z,64D8
....................  { 
....................   if (s == 1 && n == 0) 
064A2:  BTSS.B  1B89.0
064A4:  BRA     64BC
064A6:  CP0.B   1B88
064A8:  BRA     NZ,64BC
....................    res -= 1.0; 
064AA:  BSET.B  43.0
064AC:  MOV     1B8E,W0
064AE:  MOV     1B90,W1
064B0:  MOV     #0,W2
064B2:  MOV     #3F80,W3
064B4:  CALL    61DE
064B8:  MOV     W0,1B8E
064BA:  MOV     W1,1B90
....................  
....................   if (s == 0 && n == 1) 
064BC:  BTSC.B  1B89.0
064BE:  BRA     64D8
064C0:  MOV     1B88,W4
064C2:  CP.B    W4L,#1
064C4:  BRA     NZ,64D8
....................    res += 1.0; 
064C6:  BCLR.B  43.0
064C8:  MOV     1B8E,W0
064CA:  MOV     1B90,W1
064CC:  MOV     #0,W2
064CE:  MOV     #3F80,W3
064D0:  CALL    61DE
064D4:  MOV     W0,1B8E
064D6:  MOV     W1,1B90
....................  } 
....................  if (x == 0) 
064D8:  MOV     1B84,W0
064DA:  MOV     1B86,W1
064DC:  MOV     #0,W2
064DE:  MOV     #0,W3
064E0:  CALL    604C
064E4:  BRA     NZ,64EA
....................     res = 0; 
064E6:  CLR     1B8E
064E8:  CLR     1B90
....................  
....................  return (res); 
064EA:  MOV     1B8E,W0
064EC:  MOV     1B90,W1
064EE:  MOV     [--W15],W6
064F0:  MOV     [--W15],W5
064F2:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
*
01B9A:  MOV     W5,[W15++]
01B9C:  MOV     W6,[W15++]
01B9E:  MOV     W7,[W15++]
01BA0:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
01BA2:  BCLR.B  1BFF.0
....................    y = x; 
01BA4:  PUSH    1BF6
01BA6:  POP     1C00
01BA8:  PUSH    1BF8
01BAA:  POP     1C02
01BAC:  PUSH    1BFA
01BAE:  POP     1C04
01BB0:  PUSH    1BFC
01BB2:  POP     1C06
....................  
....................    if (x < 0) 
01BB4:  MOV     1BF6,W0
01BB6:  MOV     1BF8,W1
01BB8:  MOV     1BFA,W2
01BBA:  MOV     1BFC,W3
01BBC:  MOV     #0,W4
01BBE:  MOV     #0,W5
01BC0:  MOV     #0,W6
01BC2:  MOV     #0,W7
01BC4:  CALL    15EA
01BC8:  BRA     NC,1BD6
....................    { 
....................       s = 1; 
01BCA:  BSET.B  1BFF.0
....................       y = -y; 
01BCC:  MOV     #1C00,W0
01BCE:  MOV     #1C00,W1
01BD0:  REPEAT  #7
01BD2:  MOV     [W0++],[W1++]
01BD4:  BTG.B   1C07.7
....................    } 
....................  
....................    if (y <= 32768.0) 
01BD6:  MOV     1C00,W0
01BD8:  MOV     1C02,W1
01BDA:  MOV     1C04,W2
01BDC:  MOV     1C06,W3
01BDE:  MOV     #0,W4
01BE0:  MOV     #0,W5
01BE2:  MOV     #0,W6
01BE4:  MOV     #40E0,W7
01BE6:  CALL    15EA
01BEA:  BRA     C,1BEE
01BEC:  BRA     NZ,1C10
....................       res = (float64)(unsigned int16)y; 
01BEE:  MOV     1C00,W0
01BF0:  MOV     1C02,W1
01BF2:  MOV     1C04,W2
01BF4:  MOV     1C06,W3
01BF6:  CALL    1AD2
01BFA:  MOV     #0,W1
01BFC:  MOV     #0,W2
01BFE:  MOV     #0,W3
01C00:  CALL    1B30
01C04:  MOV     W0,1C08
01C06:  MOV     W1,1C0A
01C08:  MOV     W2,1C0C
01C0A:  MOV     W3,1C0E
01C0C:  GOTO    1D24
....................    else if (y < 4503599627370496.0) 
01C10:  MOV     1C00,W0
01C12:  MOV     1C02,W1
01C14:  MOV     1C04,W2
01C16:  MOV     1C06,W3
01C18:  MOV     #0,W4
01C1A:  MOV     #0,W5
01C1C:  MOV     #0,W6
01C1E:  MOV     #4330,W7
01C20:  CALL    15EA
01C24:  BRA     NC,1D0C
....................    { 
....................       l = (int64)(y*0.000030517578125); 
01C26:  MOV     1C00,W0
01C28:  MOV     1C02,W1
01C2A:  MOV     1C04,W2
01C2C:  MOV     1C06,W3
01C2E:  MOV     #0,W4
01C30:  MOV     #0,W5
01C32:  MOV     #0,W6
01C34:  MOV     #3F00,W7
01C36:  CALL    BCC
01C3A:  CALL    19EC
01C3E:  MOV     W0,1C10
01C40:  MOV     W1,1C12
01C42:  MOV     W2,1C14
01C44:  MOV     W3,1C16
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
01C46:  MOV     1C00,W0
01C48:  MOV     1C02,W1
01C4A:  MOV     1C04,W2
01C4C:  MOV     1C06,W3
01C4E:  MOV     #0,W4
01C50:  MOV     #0,W5
01C52:  MOV     #0,W6
01C54:  MOV     #3F00,W7
01C56:  CALL    BCC
01C5A:  MOV     W0,W5
01C5C:  MOV     W1,W6
01C5E:  MOV     W2,W7
01C60:  MOV     W3,W8
01C62:  MOV     1C10,W0
01C64:  MOV     1C12,W1
01C66:  MOV     1C14,W2
01C68:  MOV     1C16,W3
01C6A:  CALL    12E8
01C6E:  BSET.B  43.0
01C70:  MOV     W5,[W15++]
01C72:  MOV     W6,[W15++]
01C74:  MOV     W7,[W15++]
01C76:  MOV     W0,W4
01C78:  MOV     W5,W0
01C7A:  MOV     W1,W5
01C7C:  MOV     W6,W1
01C7E:  MOV     W2,W6
01C80:  MOV     W7,W2
01C82:  MOV     W3,W7
01C84:  MOV     W8,W3
01C86:  CALL    13FC
01C8A:  MOV     [--W15],W7
01C8C:  MOV     [--W15],W6
01C8E:  MOV     [--W15],W5
01C90:  MOV     W0,W4
01C92:  MOV     W1,W5
01C94:  MOV     W2,W6
01C96:  MOV     W3,W7
01C98:  MOV     #0,W0
01C9A:  MOV     #0,W1
01C9C:  MOV     #0,W2
01C9E:  MOV     #40E0,W3
01CA0:  CALL    BCC
01CA4:  MOV     W0,1C00
01CA6:  MOV     W1,1C02
01CA8:  MOV     W2,1C04
01CAA:  MOV     W3,1C06
....................       res = 32768.0*(float64)l; 
01CAC:  MOV     1C10,W0
01CAE:  MOV     1C12,W1
01CB0:  MOV     1C14,W2
01CB2:  MOV     1C16,W3
01CB4:  CALL    12E8
01CB8:  MOV     W0,W4
01CBA:  MOV     W1,W5
01CBC:  MOV     W2,W6
01CBE:  MOV     W3,W7
01CC0:  MOV     #0,W0
01CC2:  MOV     #0,W1
01CC4:  MOV     #0,W2
01CC6:  MOV     #40E0,W3
01CC8:  CALL    BCC
01CCC:  MOV     W0,1C08
01CCE:  MOV     W1,1C0A
01CD0:  MOV     W2,1C0C
01CD2:  MOV     W3,1C0E
....................       res += (float64)(unsigned int16)y; 
01CD4:  MOV     1C00,W0
01CD6:  MOV     1C02,W1
01CD8:  MOV     1C04,W2
01CDA:  MOV     1C06,W3
01CDC:  CALL    1AD2
01CE0:  MOV     #0,W1
01CE2:  MOV     #0,W2
01CE4:  MOV     #0,W3
01CE6:  CALL    1B30
01CEA:  BCLR.B  43.0
01CEC:  MOV     W0,W4
01CEE:  MOV     W1,W5
01CF0:  MOV     W2,W6
01CF2:  MOV     W3,W7
01CF4:  MOV     1C08,W0
01CF6:  MOV     1C0A,W1
01CF8:  MOV     1C0C,W2
01CFA:  MOV     1C0E,W3
01CFC:  CALL    13FC
01D00:  MOV     W0,1C08
01D02:  MOV     W1,1C0A
01D04:  MOV     W2,1C0C
01D06:  MOV     W3,1C0E
....................    } 
01D08:  GOTO    1D24
....................    else 
....................    { 
....................       res = y; 
01D0C:  PUSH    1C00
01D0E:  POP     1C08
01D10:  PUSH    1C02
01D12:  POP     1C0A
01D14:  PUSH    1C04
01D16:  POP     1C0C
01D18:  PUSH    1C06
01D1A:  POP     1C0E
....................       y = 0.0; 
01D1C:  CLR     1C00
01D1E:  CLR     1C02
01D20:  CLR     1C04
01D22:  CLR     1C06
....................    } 
....................     
....................    if(y != 0) 
01D24:  MOV     1C00,W0
01D26:  MOV     1C02,W1
01D28:  MOV     1C04,W2
01D2A:  MOV     1C06,W3
01D2C:  MOV     #0,W4
01D2E:  MOV     #0,W5
01D30:  MOV     #0,W6
01D32:  MOV     #0,W7
01D34:  CALL    15EA
01D38:  BRA     Z,1D6E
....................       y = y - (float64)(unsigned int16)y; 
01D3A:  MOV     1C00,W0
01D3C:  MOV     1C02,W1
01D3E:  MOV     1C04,W2
01D40:  MOV     1C06,W3
01D42:  CALL    1AD2
01D46:  MOV     #0,W1
01D48:  MOV     #0,W2
01D4A:  MOV     #0,W3
01D4C:  CALL    1B30
01D50:  BSET.B  43.0
01D52:  MOV     W0,W4
01D54:  MOV     W1,W5
01D56:  MOV     W2,W6
01D58:  MOV     W3,W7
01D5A:  MOV     1C00,W0
01D5C:  MOV     1C02,W1
01D5E:  MOV     1C04,W2
01D60:  MOV     1C06,W3
01D62:  CALL    13FC
01D66:  MOV     W0,1C00
01D68:  MOV     W1,1C02
01D6A:  MOV     W2,1C04
01D6C:  MOV     W3,1C06
....................  
....................    if (s) 
01D6E:  BTSS.B  1BFF.0
01D70:  BRA     1D7C
....................       res = -res; 
01D72:  MOV     #1C08,W0
01D74:  MOV     #1C08,W1
01D76:  REPEAT  #7
01D78:  MOV     [W0++],[W1++]
01D7A:  BTG.B   1C0F.7
....................  
....................    if (y != 0) 
01D7C:  MOV     1C00,W0
01D7E:  MOV     1C02,W1
01D80:  MOV     1C04,W2
01D82:  MOV     1C06,W3
01D84:  MOV     #0,W4
01D86:  MOV     #0,W5
01D88:  MOV     #0,W6
01D8A:  MOV     #0,W7
01D8C:  CALL    15EA
01D90:  BRA     Z,1DE0
....................    { 
....................       if (s == 1 && n == 0) 
01D92:  BTSS.B  1BFF.0
01D94:  BRA     1DB8
01D96:  CP0.B   1BFE
01D98:  BRA     NZ,1DB8
....................          res -= 1.0; 
01D9A:  BSET.B  43.0
01D9C:  MOV     1C08,W0
01D9E:  MOV     1C0A,W1
01DA0:  MOV     1C0C,W2
01DA2:  MOV     1C0E,W3
01DA4:  MOV     #0,W4
01DA6:  MOV     #0,W5
01DA8:  MOV     #0,W6
01DAA:  MOV     #3FF0,W7
01DAC:  CALL    13FC
01DB0:  MOV     W0,1C08
01DB2:  MOV     W1,1C0A
01DB4:  MOV     W2,1C0C
01DB6:  MOV     W3,1C0E
....................  
....................       if (s == 0 && n == 1) 
01DB8:  BTSC.B  1BFF.0
01DBA:  BRA     1DE0
01DBC:  MOV     1BFE,W4
01DBE:  CP.B    W4L,#1
01DC0:  BRA     NZ,1DE0
....................          res += 1.0; 
01DC2:  BCLR.B  43.0
01DC4:  MOV     1C08,W0
01DC6:  MOV     1C0A,W1
01DC8:  MOV     1C0C,W2
01DCA:  MOV     1C0E,W3
01DCC:  MOV     #0,W4
01DCE:  MOV     #0,W5
01DD0:  MOV     #0,W6
01DD2:  MOV     #3FF0,W7
01DD4:  CALL    13FC
01DD8:  MOV     W0,1C08
01DDA:  MOV     W1,1C0A
01DDC:  MOV     W2,1C0C
01DDE:  MOV     W3,1C0E
....................    } 
....................     
....................    if (x == 0) 
01DE0:  MOV     1BF6,W0
01DE2:  MOV     1BF8,W1
01DE4:  MOV     1BFA,W2
01DE6:  MOV     1BFC,W3
01DE8:  MOV     #0,W4
01DEA:  MOV     #0,W5
01DEC:  MOV     #0,W6
01DEE:  MOV     #0,W7
01DF0:  CALL    15EA
01DF4:  BRA     NZ,1DFE
....................       res = 0; 
01DF6:  CLR     1C08
01DF8:  CLR     1C0A
01DFA:  CLR     1C0C
01DFC:  CLR     1C0E
....................  
....................    return (res); 
01DFE:  MOV     1C08,W0
01E00:  MOV     1C0A,W1
01E02:  MOV     1C0C,W2
01E04:  MOV     1C0E,W3
01E06:  MOV     [--W15],W8
01E08:  MOV     [--W15],W7
01E0A:  MOV     [--W15],W6
01E0C:  MOV     [--W15],W5
01E0E:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
064F4:  CLR.B   1B88
064F6:  PUSH    1B7A
064F8:  POP     1B84
064FA:  PUSH    1B7C
064FC:  POP     1B86
064FE:  CALL    6388
06502:  MOV.D   W0,W0
06504:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
01E2A:  CLR.B   1BFE
01E2C:  PUSH    1BE4
01E2E:  POP     1BF6
01E30:  PUSH    1BE6
01E32:  POP     1BF8
01E34:  PUSH    1BE8
01E36:  POP     1BFA
01E38:  PUSH    1BEA
01E3A:  POP     1BFC
01E3C:  CALL    1B9A
01E40:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
06506:  MOV.B   #1,W0L
06508:  MOV.B   W0L,1B88
0650A:  PUSH    1B7A
0650C:  POP     1B84
0650E:  PUSH    1B7C
06510:  POP     1B86
06512:  CALL    6388
06516:  MOV.D   W0,W0
06518:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
01E10:  MOV.B   #1,W0L
01E12:  MOV.B   W0L,1BFE
01E14:  PUSH    1BE4
01E16:  POP     1BF6
01E18:  PUSH    1BE6
01E1A:  POP     1BF8
01E1C:  PUSH    1BE8
01E1E:  POP     1BFA
01E20:  PUSH    1BEA
01E22:  POP     1BFC
01E24:  CALL    1B9A
01E28:  RETURN  
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
*
01E42:  MOV     W5,[W15++]
01E44:  MOV     W6,[W15++]
01E46:  MOV     W7,[W15++]
01E48:  MOV     W8,[W15++]
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
01E4A:  MOV     1BCC,W0
01E4C:  MOV     1BCE,W1
01E4E:  MOV     1BD0,W2
01E50:  MOV     1BD2,W3
01E52:  MOV     #0,W4
01E54:  MOV     #0,W5
01E56:  MOV     #0,W6
01E58:  MOV     #0,W7
01E5A:  CALL    15EA
01E5E:  BRA     Z,1F2A
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
01E60:  MOV     1BC4,W0
01E62:  MOV     1BC6,W1
01E64:  MOV     1BC8,W2
01E66:  MOV     1BCA,W3
01E68:  MOV     1BCC,W4
01E6A:  MOV     1BCE,W5
01E6C:  MOV     1BD0,W6
01E6E:  MOV     1BD2,W7
01E70:  CALL    CDC
01E74:  MOV     W0,W5
01E76:  MOV     W1,W6
01E78:  MOV     W2,W7
01E7A:  MOV     W3,W8
01E7C:  MOV     W5,[W15++]
01E7E:  MOV     W6,[W15++]
01E80:  MOV     W7,[W15++]
01E82:  MOV     W5,W0
01E84:  MOV     W6,W1
01E86:  MOV     W7,W2
01E88:  MOV     W8,W3
01E8A:  MOV     #0,W4
01E8C:  MOV     #0,W5
01E8E:  MOV     #0,W6
01E90:  MOV     #0,W7
01E92:  CALL    15EA
01E96:  MOV     [--W15],W7
01E98:  MOV     [--W15],W6
01E9A:  MOV     [--W15],W5
01E9C:  BRA     NC,1ECA
01E9E:  MOV     1BC4,W0
01EA0:  MOV     1BC6,W1
01EA2:  MOV     1BC8,W2
01EA4:  MOV     1BCA,W3
01EA6:  MOV     1BCC,W4
01EA8:  MOV     1BCE,W5
01EAA:  MOV     1BD0,W6
01EAC:  MOV     1BD2,W7
01EAE:  CALL    CDC
01EB2:  MOV     W0,W5
01EB4:  MOV     W1,W6
01EB6:  MOV     W2,W7
01EB8:  MOV     W3,W8
01EBA:  MOV     W5,1BE4
01EBC:  MOV     W6,1BE6
01EBE:  MOV     W7,1BE8
01EC0:  MOV     W8,1BEA
01EC2:  CALL    1E10
01EC6:  GOTO    1EF2
01ECA:  MOV     1BC4,W0
01ECC:  MOV     1BC6,W1
01ECE:  MOV     1BC8,W2
01ED0:  MOV     1BCA,W3
01ED2:  MOV     1BCC,W4
01ED4:  MOV     1BCE,W5
01ED6:  MOV     1BD0,W6
01ED8:  MOV     1BD2,W7
01EDA:  CALL    CDC
01EDE:  MOV     W0,W5
01EE0:  MOV     W1,W6
01EE2:  MOV     W2,W7
01EE4:  MOV     W3,W8
01EE6:  MOV     W5,1BE4
01EE8:  MOV     W6,1BE6
01EEA:  MOV     W7,1BE8
01EEC:  MOV     W8,1BEA
01EEE:  CALL    1E2A
01EF2:  MOV     W0,1BD4
01EF4:  MOV     W1,1BD6
01EF6:  MOV     W2,1BD8
01EF8:  MOV     W3,1BDA
....................       return(x-(i*y)); 
01EFA:  MOV     1BD4,W0
01EFC:  MOV     1BD6,W1
01EFE:  MOV     1BD8,W2
01F00:  MOV     1BDA,W3
01F02:  MOV     1BCC,W4
01F04:  MOV     1BCE,W5
01F06:  MOV     1BD0,W6
01F08:  MOV     1BD2,W7
01F0A:  CALL    BCC
01F0E:  BSET.B  43.0
01F10:  MOV     W0,W4
01F12:  MOV     W1,W5
01F14:  MOV     W2,W6
01F16:  MOV     W3,W7
01F18:  MOV     1BC4,W0
01F1A:  MOV     1BC6,W1
01F1C:  MOV     1BC8,W2
01F1E:  MOV     1BCA,W3
01F20:  CALL    13FC
01F24:  BRA     1F2A
....................    } 
01F26:  GOTO    1F2A
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
01F2A:  MOV     [--W15],W8
01F2C:  MOV     [--W15],W7
01F2E:  MOV     [--W15],W6
01F30:  MOV     [--W15],W5
01F32:  RETURN  
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
*
022EC:  MOV     W5,[W15++]
022EE:  MOV     W6,[W15++]
022F0:  MOV     W7,[W15++]
022F2:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
022F4:  MOV     1BC4,W0
022F6:  MOV     1BC6,W1
022F8:  MOV     1BC8,W2
022FA:  MOV     1BCA,W3
022FC:  MOV     #82FE,W4
022FE:  MOV     #652B,W5
02300:  MOV     #1547,W6
02302:  MOV     #3FF7,W7
02304:  CALL    BCC
02308:  MOV     W0,1BCE
0230A:  MOV     W1,1BD0
0230C:  MOV     W2,1BD2
0230E:  MOV     W3,1BD4
....................    n = (signed int16)y; 
02310:  MOV     1BCE,W0
02312:  MOV     1BD0,W1
02314:  MOV     1BD2,W2
02316:  MOV     1BD4,W3
02318:  CALL    19EC
0231C:  MOV     W0,1BEC
....................    s = 0; 
0231E:  BCLR.B  1BCC.0
....................    y = x; 
02320:  PUSH    1BC4
02322:  POP     1BCE
02324:  PUSH    1BC6
02326:  POP     1BD0
02328:  PUSH    1BC8
0232A:  POP     1BD2
0232C:  PUSH    1BCA
0232E:  POP     1BD4
....................  
....................    if (x < 0) 
02330:  MOV     1BC4,W0
02332:  MOV     1BC6,W1
02334:  MOV     1BC8,W2
02336:  MOV     1BCA,W3
02338:  MOV     #0,W4
0233A:  MOV     #0,W5
0233C:  MOV     #0,W6
0233E:  MOV     #0,W7
02340:  CALL    15EA
02344:  BRA     NC,235A
....................    { 
....................       s = 1; 
02346:  BSET.B  1BCC.0
....................       n = -n; 
02348:  MOV     #0,W4
0234A:  MOV     1BEC,W3
0234C:  SUB     W4,W3,W0
0234E:  MOV     W0,1BEC
....................       y = -y; 
02350:  MOV     #1BCE,W0
02352:  MOV     #1BCE,W1
02354:  REPEAT  #7
02356:  MOV     [W0++],[W1++]
02358:  BTG.B   1BD5.7
....................    } 
....................  
....................    res = 0.0; 
0235A:  CLR     1BD6
0235C:  CLR     1BD8
0235E:  CLR     1BDA
02360:  CLR     1BDC
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
02362:  MOV     #1BDC,W4
02364:  MOV     W4,1BEA
....................    data1 = *p; 
02366:  MOV     1BEA,W0
02368:  MOV     [W0],[W15++]
0236A:  POP     1BE6
....................    data2 = *p;    
0236C:  MOV     1BEA,W0
0236E:  MOV     [W0],[W15++]
02370:  POP     1BE8
....................    data1 = n + 0x3FF; 
02372:  MOV     #3FF,W4
02374:  MOV     1BEC,W3
02376:  ADD     W3,W4,W0
02378:  MOV     W0,1BE6
....................    data1 = data1 <<4; 
0237A:  MOV     1BE6,W0
0237C:  SL      W0,#4,W0
0237E:  MOV     W0,1BE6
....................    if(bit_test(data2,15)) 
02380:  BTSS.B  1BE9.7
02382:  BRA     2388
....................    bit_set(data1,15); 
02384:  MOV     #1BE6,W4
02386:  BSET    [W4].F
....................    data2 = data2 & 0x000F; 
02388:  MOV     1BE8,W0
0238A:  AND     W0,#F,W0
0238C:  MOV     W0,1BE8
....................    data1 ^= data2; 
0238E:  MOV     1BE8,W0
02390:  XOR     1BE6
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
02392:  MOV     #1BDC,W5
02394:  MOV     1BE6,W4
02396:  MOV     W4,[W5+#0]
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
02398:  MOV     1BCE,W0
0239A:  MOV     1BD0,W1
0239C:  MOV     1BD2,W2
0239E:  MOV     1BD4,W3
023A0:  MOV     #82FE,W4
023A2:  MOV     #652B,W5
023A4:  MOV     #1547,W6
023A6:  MOV     #3FF7,W7
023A8:  CALL    BCC
023AC:  MOV     W0,W5
023AE:  MOV     W1,W6
023B0:  MOV     W2,W7
023B2:  MOV     W3,W8
023B4:  MOV     1BEC,W0
023B6:  CLR     W3
023B8:  BTSC    W0.F
023BA:  SETM    W3
023BC:  MOV     W3,W1
023BE:  MOV     W3,W2
023C0:  CALL    12E8
023C4:  BSET.B  43.0
023C6:  MOV     W5,[W15++]
023C8:  MOV     W6,[W15++]
023CA:  MOV     W7,[W15++]
023CC:  MOV     W0,W4
023CE:  MOV     W5,W0
023D0:  MOV     W1,W5
023D2:  MOV     W6,W1
023D4:  MOV     W2,W6
023D6:  MOV     W7,W2
023D8:  MOV     W3,W7
023DA:  MOV     W8,W3
023DC:  CALL    13FC
023E0:  MOV     [--W15],W7
023E2:  MOV     [--W15],W6
023E4:  MOV     [--W15],W5
023E6:  MOV     W0,1BCE
023E8:  MOV     W1,1BD0
023EA:  MOV     W2,1BD2
023EC:  MOV     W3,1BD4
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
023EE:  MOV     #8C0F,W0
023F0:  MOV     #A655,W1
023F2:  MOV     #9582,W2
023F4:  MOV     #3DD9,W3
023F6:  MOV     1BCE,W4
023F8:  MOV     1BD0,W5
023FA:  MOV     1BD2,W6
023FC:  MOV     1BD4,W7
023FE:  CALL    BCC
02402:  MOV     W0,W5
02404:  MOV     W1,W6
02406:  MOV     W2,W7
02408:  MOV     W3,W8
0240A:  BCLR.B  43.0
0240C:  MOV     W5,[W15++]
0240E:  MOV     W6,[W15++]
02410:  MOV     W7,[W15++]
02412:  MOV     W5,W0
02414:  MOV     W6,W1
02416:  MOV     W7,W2
02418:  MOV     W8,W3
0241A:  MOV     #D7E6,W4
0241C:  MOV     #E5FF,W5
0241E:  MOV     #90C9,W6
02420:  MOV     #BDC7,W7
02422:  CALL    13FC
02426:  MOV     [--W15],W7
02428:  MOV     [--W15],W6
0242A:  MOV     [--W15],W5
0242C:  MOV     W0,1BDE
0242E:  MOV     W1,1BE0
02430:  MOV     W2,1BE2
02432:  MOV     W3,1BE4
....................    r = r*y + pe_64[2]; 
02434:  MOV     1BDE,W0
02436:  MOV     1BE0,W1
02438:  MOV     1BE2,W2
0243A:  MOV     1BE4,W3
0243C:  MOV     1BCE,W4
0243E:  MOV     1BD0,W5
02440:  MOV     1BD2,W6
02442:  MOV     1BD4,W7
02444:  CALL    BCC
02448:  MOV     W0,W5
0244A:  MOV     W1,W6
0244C:  MOV     W2,W7
0244E:  MOV     W3,W8
02450:  BCLR.B  43.0
02452:  MOV     W5,[W15++]
02454:  MOV     W6,[W15++]
02456:  MOV     W7,[W15++]
02458:  MOV     W5,W0
0245A:  MOV     W6,W1
0245C:  MOV     W7,W2
0245E:  MOV     W8,W3
02460:  MOV     #40CE,W4
02462:  MOV     #4712,W5
02464:  MOV     #B70C,W6
02466:  MOV     #3E42,W7
02468:  CALL    13FC
0246C:  MOV     [--W15],W7
0246E:  MOV     [--W15],W6
02470:  MOV     [--W15],W5
02472:  MOV     W0,1BDE
02474:  MOV     W1,1BE0
02476:  MOV     W2,1BE2
02478:  MOV     W3,1BE4
....................    r = r*y + pe_64[3]; 
0247A:  MOV     1BDE,W0
0247C:  MOV     1BE0,W1
0247E:  MOV     1BE2,W2
02480:  MOV     1BE4,W3
02482:  MOV     1BCE,W4
02484:  MOV     1BD0,W5
02486:  MOV     1BD2,W6
02488:  MOV     1BD4,W7
0248A:  CALL    BCC
0248E:  MOV     W0,W5
02490:  MOV     W1,W6
02492:  MOV     W2,W7
02494:  MOV     W3,W8
02496:  BCLR.B  43.0
02498:  MOV     W5,[W15++]
0249A:  MOV     W6,[W15++]
0249C:  MOV     W7,[W15++]
0249E:  MOV     W5,W0
024A0:  MOV     W6,W1
024A2:  MOV     W7,W2
024A4:  MOV     W8,W3
024A6:  MOV     #6D9F,W4
024A8:  MOV     #C394,W5
024AA:  MOV     #6D25,W6
024AC:  MOV     #3E7A,W7
024AE:  CALL    13FC
024B2:  MOV     [--W15],W7
024B4:  MOV     [--W15],W6
024B6:  MOV     [--W15],W5
024B8:  MOV     W0,1BDE
024BA:  MOV     W1,1BE0
024BC:  MOV     W2,1BE2
024BE:  MOV     W3,1BE4
....................    r = r*y + pe_64[4]; 
024C0:  MOV     1BDE,W0
024C2:  MOV     1BE0,W1
024C4:  MOV     1BE2,W2
024C6:  MOV     1BE4,W3
024C8:  MOV     1BCE,W4
024CA:  MOV     1BD0,W5
024CC:  MOV     1BD2,W6
024CE:  MOV     1BD4,W7
024D0:  CALL    BCC
024D4:  MOV     W0,W5
024D6:  MOV     W1,W6
024D8:  MOV     W2,W7
024DA:  MOV     W3,W8
024DC:  BCLR.B  43.0
024DE:  MOV     W5,[W15++]
024E0:  MOV     W6,[W15++]
024E2:  MOV     W7,[W15++]
024E4:  MOV     W5,W0
024E6:  MOV     W6,W1
024E8:  MOV     W7,W2
024EA:  MOV     W8,W3
024EC:  MOV     #32DA,W4
024EE:  MOV     #BE0E,W5
024F0:  MOV     #3E9F,W6
024F2:  MOV     #3EB6,W7
024F4:  CALL    13FC
024F8:  MOV     [--W15],W7
024FA:  MOV     [--W15],W6
024FC:  MOV     [--W15],W5
024FE:  MOV     W0,1BDE
02500:  MOV     W1,1BE0
02502:  MOV     W2,1BE2
02504:  MOV     W3,1BE4
....................    r = r*y + pe_64[5]; 
02506:  MOV     1BDE,W0
02508:  MOV     1BE0,W1
0250A:  MOV     1BE2,W2
0250C:  MOV     1BE4,W3
0250E:  MOV     1BCE,W4
02510:  MOV     1BD0,W5
02512:  MOV     1BD2,W6
02514:  MOV     1BD4,W7
02516:  CALL    BCC
0251A:  MOV     W0,W5
0251C:  MOV     W1,W6
0251E:  MOV     W2,W7
02520:  MOV     W3,W8
02522:  BCLR.B  43.0
02524:  MOV     W5,[W15++]
02526:  MOV     W6,[W15++]
02528:  MOV     W7,[W15++]
0252A:  MOV     W5,W0
0252C:  MOV     W6,W1
0252E:  MOV     W7,W2
02530:  MOV     W8,W3
02532:  MOV     #AA6D,W4
02534:  MOV     #C228,W5
02536:  MOV     #FAB4,W6
02538:  MOV     #3EEF,W7
0253A:  CALL    13FC
0253E:  MOV     [--W15],W7
02540:  MOV     [--W15],W6
02542:  MOV     [--W15],W5
02544:  MOV     W0,1BDE
02546:  MOV     W1,1BE0
02548:  MOV     W2,1BE2
0254A:  MOV     W3,1BE4
....................    r = r*y + pe_64[6]; 
0254C:  MOV     1BDE,W0
0254E:  MOV     1BE0,W1
02550:  MOV     1BE2,W2
02552:  MOV     1BE4,W3
02554:  MOV     1BCE,W4
02556:  MOV     1BD0,W5
02558:  MOV     1BD2,W6
0255A:  MOV     1BD4,W7
0255C:  CALL    BCC
02560:  MOV     W0,W5
02562:  MOV     W1,W6
02564:  MOV     W2,W7
02566:  MOV     W3,W8
02568:  BCLR.B  43.0
0256A:  MOV     W5,[W15++]
0256C:  MOV     W6,[W15++]
0256E:  MOV     W7,[W15++]
02570:  MOV     W5,W0
02572:  MOV     W6,W1
02574:  MOV     W7,W2
02576:  MOV     W8,W3
02578:  MOV     #E089,W4
0257A:  MOV     #E529,W5
0257C:  MOV     #30A4,W6
0257E:  MOV     #3F24,W7
02580:  CALL    13FC
02584:  MOV     [--W15],W7
02586:  MOV     [--W15],W6
02588:  MOV     [--W15],W5
0258A:  MOV     W0,1BDE
0258C:  MOV     W1,1BE0
0258E:  MOV     W2,1BE2
02590:  MOV     W3,1BE4
....................    r = r*y + pe_64[7]; 
02592:  MOV     1BDE,W0
02594:  MOV     1BE0,W1
02596:  MOV     1BE2,W2
02598:  MOV     1BE4,W3
0259A:  MOV     1BCE,W4
0259C:  MOV     1BD0,W5
0259E:  MOV     1BD2,W6
025A0:  MOV     1BD4,W7
025A2:  CALL    BCC
025A6:  MOV     W0,W5
025A8:  MOV     W1,W6
025AA:  MOV     W2,W7
025AC:  MOV     W3,W8
025AE:  BCLR.B  43.0
025B0:  MOV     W5,[W15++]
025B2:  MOV     W6,[W15++]
025B4:  MOV     W7,[W15++]
025B6:  MOV     W5,W0
025B8:  MOV     W6,W1
025BA:  MOV     W7,W2
025BC:  MOV     W8,W3
025BE:  MOV     #8EA3,W4
025C0:  MOV     #E3FA,W5
025C2:  MOV     #D87E,W6
025C4:  MOV     #3F55,W7
025C6:  CALL    13FC
025CA:  MOV     [--W15],W7
025CC:  MOV     [--W15],W6
025CE:  MOV     [--W15],W5
025D0:  MOV     W0,1BDE
025D2:  MOV     W1,1BE0
025D4:  MOV     W2,1BE2
025D6:  MOV     W3,1BE4
....................    r = r*y + pe_64[8]; 
025D8:  MOV     1BDE,W0
025DA:  MOV     1BE0,W1
025DC:  MOV     1BE2,W2
025DE:  MOV     1BE4,W3
025E0:  MOV     1BCE,W4
025E2:  MOV     1BD0,W5
025E4:  MOV     1BD2,W6
025E6:  MOV     1BD4,W7
025E8:  CALL    BCC
025EC:  MOV     W0,W5
025EE:  MOV     W1,W6
025F0:  MOV     W2,W7
025F2:  MOV     W3,W8
025F4:  BCLR.B  43.0
025F6:  MOV     W5,[W15++]
025F8:  MOV     W6,[W15++]
025FA:  MOV     W7,[W15++]
025FC:  MOV     W5,W0
025FE:  MOV     W6,W1
02600:  MOV     W7,W2
02602:  MOV     W8,W3
02604:  MOV     #4C6,W4
02606:  MOV     #788A,W5
02608:  MOV     #B2AB,W6
0260A:  MOV     #3F83,W7
0260C:  CALL    13FC
02610:  MOV     [--W15],W7
02612:  MOV     [--W15],W6
02614:  MOV     [--W15],W5
02616:  MOV     W0,1BDE
02618:  MOV     W1,1BE0
0261A:  MOV     W2,1BE2
0261C:  MOV     W3,1BE4
....................    r = r*y + pe_64[9]; 
0261E:  MOV     1BDE,W0
02620:  MOV     1BE0,W1
02622:  MOV     1BE2,W2
02624:  MOV     1BE4,W3
02626:  MOV     1BCE,W4
02628:  MOV     1BD0,W5
0262A:  MOV     1BD2,W6
0262C:  MOV     1BD4,W7
0262E:  CALL    BCC
02632:  MOV     W0,W5
02634:  MOV     W1,W6
02636:  MOV     W2,W7
02638:  MOV     W3,W8
0263A:  BCLR.B  43.0
0263C:  MOV     W5,[W15++]
0263E:  MOV     W6,[W15++]
02640:  MOV     W7,[W15++]
02642:  MOV     W5,W0
02644:  MOV     W6,W1
02646:  MOV     W7,W2
02648:  MOV     W8,W3
0264A:  MOV     #EDCD,W4
0264C:  MOV     #D6A6,W5
0264E:  MOV     #6B08,W6
02650:  MOV     #3FAC,W7
02652:  CALL    13FC
02656:  MOV     [--W15],W7
02658:  MOV     [--W15],W6
0265A:  MOV     [--W15],W5
0265C:  MOV     W0,1BDE
0265E:  MOV     W1,1BE0
02660:  MOV     W2,1BE2
02662:  MOV     W3,1BE4
....................    r = r*y + pe_64[10]; 
02664:  MOV     1BDE,W0
02666:  MOV     1BE0,W1
02668:  MOV     1BE2,W2
0266A:  MOV     1BE4,W3
0266C:  MOV     1BCE,W4
0266E:  MOV     1BD0,W5
02670:  MOV     1BD2,W6
02672:  MOV     1BD4,W7
02674:  CALL    BCC
02678:  MOV     W0,W5
0267A:  MOV     W1,W6
0267C:  MOV     W2,W7
0267E:  MOV     W3,W8
02680:  BCLR.B  43.0
02682:  MOV     W5,[W15++]
02684:  MOV     W6,[W15++]
02686:  MOV     W7,[W15++]
02688:  MOV     W5,W0
0268A:  MOV     W6,W1
0268C:  MOV     W7,W2
0268E:  MOV     W8,W3
02690:  MOV     #D1FD,W4
02692:  MOV     #FF84,W5
02694:  MOV     #BFBD,W6
02696:  MOV     #3FCE,W7
02698:  CALL    13FC
0269C:  MOV     [--W15],W7
0269E:  MOV     [--W15],W6
026A0:  MOV     [--W15],W5
026A2:  MOV     W0,1BDE
026A4:  MOV     W1,1BE0
026A6:  MOV     W2,1BE2
026A8:  MOV     W3,1BE4
....................    r = r*y + pe_64[11]; 
026AA:  MOV     1BDE,W0
026AC:  MOV     1BE0,W1
026AE:  MOV     1BE2,W2
026B0:  MOV     1BE4,W3
026B2:  MOV     1BCE,W4
026B4:  MOV     1BD0,W5
026B6:  MOV     1BD2,W6
026B8:  MOV     1BD4,W7
026BA:  CALL    BCC
026BE:  MOV     W0,W5
026C0:  MOV     W1,W6
026C2:  MOV     W2,W7
026C4:  MOV     W3,W8
026C6:  BCLR.B  43.0
026C8:  MOV     W5,[W15++]
026CA:  MOV     W6,[W15++]
026CC:  MOV     W7,[W15++]
026CE:  MOV     W5,W0
026D0:  MOV     W6,W1
026D2:  MOV     W7,W2
026D4:  MOV     W8,W3
026D6:  MOV     #35A1,W4
026D8:  MOV     #FEFA,W5
026DA:  MOV     #2E42,W6
026DC:  MOV     #3FE6,W7
026DE:  CALL    13FC
026E2:  MOV     [--W15],W7
026E4:  MOV     [--W15],W6
026E6:  MOV     [--W15],W5
026E8:  MOV     W0,1BDE
026EA:  MOV     W1,1BE0
026EC:  MOV     W2,1BE2
026EE:  MOV     W3,1BE4
....................     
....................    res = res*(1.0 + y*r); 
026F0:  MOV     1BCE,W0
026F2:  MOV     1BD0,W1
026F4:  MOV     1BD2,W2
026F6:  MOV     1BD4,W3
026F8:  MOV     1BDE,W4
026FA:  MOV     1BE0,W5
026FC:  MOV     1BE2,W6
026FE:  MOV     1BE4,W7
02700:  CALL    BCC
02704:  BCLR.B  43.0
02706:  MOV     W0,W4
02708:  MOV     W1,W5
0270A:  MOV     W2,W6
0270C:  MOV     W3,W7
0270E:  MOV     #0,W0
02710:  MOV     #0,W1
02712:  MOV     #0,W2
02714:  MOV     #3FF0,W3
02716:  CALL    13FC
0271A:  MOV     W0,W4
0271C:  MOV     W1,W5
0271E:  MOV     W2,W6
02720:  MOV     W3,W7
02722:  MOV     1BD6,W0
02724:  MOV     1BD8,W1
02726:  MOV     1BDA,W2
02728:  MOV     1BDC,W3
0272A:  CALL    BCC
0272E:  MOV     W0,1BD6
02730:  MOV     W1,1BD8
02732:  MOV     W2,1BDA
02734:  MOV     W3,1BDC
....................  
....................    if (s) 
02736:  BTSS.B  1BCC.0
02738:  BRA     2756
....................       res = 1.0/res; 
0273A:  MOV     #0,W0
0273C:  MOV     #0,W1
0273E:  MOV     #0,W2
02740:  MOV     #3FF0,W3
02742:  MOV     1BD6,W4
02744:  MOV     1BD8,W5
02746:  MOV     1BDA,W6
02748:  MOV     1BDC,W7
0274A:  CALL    CDC
0274E:  MOV     W0,1BD6
02750:  MOV     W1,1BD8
02752:  MOV     W2,1BDA
02754:  MOV     W3,1BDC
....................    return(res); 
02756:  MOV     1BD6,W0
02758:  MOV     1BD8,W1
0275A:  MOV     1BDA,W2
0275C:  MOV     1BDC,W3
0275E:  MOV     [--W15],W8
02760:  MOV     [--W15],W7
02762:  MOV     [--W15],W6
02764:  MOV     [--W15],W5
02766:  RETURN  
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
*
01F34:  MOV     W5,[W15++]
01F36:  MOV     W6,[W15++]
01F38:  MOV     W7,[W15++]
01F3A:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
01F3C:  PUSH    1BC4
01F3E:  POP     1BCC
01F40:  PUSH    1BC6
01F42:  POP     1BCE
01F44:  PUSH    1BC8
01F46:  POP     1BD0
01F48:  PUSH    1BCA
01F4A:  POP     1BD2
....................  
....................    if (y != 1.0) 
01F4C:  MOV     1BCC,W0
01F4E:  MOV     1BCE,W1
01F50:  MOV     1BD0,W2
01F52:  MOV     1BD2,W3
01F54:  MOV     #0,W4
01F56:  MOV     #0,W5
01F58:  MOV     #0,W6
01F5A:  MOV     #3FF0,W7
01F5C:  CALL    15EA
01F60:  BRA     Z,22D2
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
01F62:  MOV     #1BD2,W4
01F64:  MOV     W4,1BF0
....................       data1 = *p; 
01F66:  MOV     1BF0,W0
01F68:  MOV     [W0],[W15++]
01F6A:  POP     1BEC
....................       data2 = *p; 
01F6C:  MOV     1BF0,W0
01F6E:  MOV     [W0],[W15++]
01F70:  POP     1BEE
....................       data1 = 0x3FE; 
01F72:  MOV     #3FE,W4
01F74:  MOV     W4,1BEC
....................       data1 = data1 <<4; 
01F76:  MOV     1BEC,W0
01F78:  SL      W0,#4,W0
01F7A:  MOV     W0,1BEC
....................       if(bit_test (data2,15)) 
01F7C:  BTSS.B  1BEF.7
01F7E:  BRA     1F84
....................          bit_set(data1,15); 
01F80:  MOV     #1BEC,W4
01F82:  BSET    [W4].F
....................       data2 = data2 & 0x000F; 
01F84:  MOV     1BEE,W0
01F86:  AND     W0,#F,W0
01F88:  MOV     W0,1BEE
....................       data1 ^=data2; 
01F8A:  MOV     1BEE,W0
01F8C:  XOR     1BEC
....................  
....................       *p = data1; 
01F8E:  MOV     1BF0,W5
01F90:  MOV     1BEC,W4
01F92:  MOV     W4,[W5+#0]
....................  
....................       y = (y - 1.0)/(y + 1.0); 
01F94:  BSET.B  43.0
01F96:  MOV     1BCC,W0
01F98:  MOV     1BCE,W1
01F9A:  MOV     1BD0,W2
01F9C:  MOV     1BD2,W3
01F9E:  MOV     #0,W4
01FA0:  MOV     #0,W5
01FA2:  MOV     #0,W6
01FA4:  MOV     #3FF0,W7
01FA6:  CALL    13FC
01FAA:  MOV     W0,W5
01FAC:  MOV     W1,W6
01FAE:  MOV     W2,W7
01FB0:  MOV     W3,W8
01FB2:  BCLR.B  43.0
01FB4:  MOV     W5,[W15++]
01FB6:  MOV     W6,[W15++]
01FB8:  MOV     W7,[W15++]
01FBA:  MOV     1BCC,W0
01FBC:  MOV     1BCE,W1
01FBE:  MOV     1BD0,W2
01FC0:  MOV     1BD2,W3
01FC2:  MOV     #0,W4
01FC4:  MOV     #0,W5
01FC6:  MOV     #0,W6
01FC8:  MOV     #3FF0,W7
01FCA:  CALL    13FC
01FCE:  MOV     [--W15],W7
01FD0:  MOV     [--W15],W6
01FD2:  MOV     [--W15],W5
01FD4:  MOV     W5,[W15++]
01FD6:  MOV     W6,[W15++]
01FD8:  MOV     W7,[W15++]
01FDA:  MOV     W0,W4
01FDC:  MOV     W5,W0
01FDE:  MOV     W1,W5
01FE0:  MOV     W6,W1
01FE2:  MOV     W2,W6
01FE4:  MOV     W7,W2
01FE6:  MOV     W3,W7
01FE8:  MOV     W8,W3
01FEA:  CALL    CDC
01FEE:  MOV     [--W15],W7
01FF0:  MOV     [--W15],W6
01FF2:  MOV     [--W15],W5
01FF4:  MOV     W0,1BCC
01FF6:  MOV     W1,1BCE
01FF8:  MOV     W2,1BD0
01FFA:  MOV     W3,1BD2
....................  
....................       y2=y*y; 
01FFC:  MOV     1BCC,W0
01FFE:  MOV     1BCE,W1
02000:  MOV     1BD0,W2
02002:  MOV     1BD2,W3
02004:  MOV     1BCC,W4
02006:  MOV     1BCE,W5
02008:  MOV     1BD0,W6
0200A:  MOV     1BD2,W7
0200C:  CALL    BCC
02010:  MOV     W0,1BE4
02012:  MOV     W1,1BE6
02014:  MOV     W2,1BE8
02016:  MOV     W3,1BEA
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
02018:  MOV     #BD05,W0
0201A:  MOV     #4A9A,W1
0201C:  MOV     #A61A,W2
0201E:  MOV     #BFC2,W3
02020:  MOV     1BE4,W4
02022:  MOV     1BE6,W5
02024:  MOV     1BE8,W6
02026:  MOV     1BEA,W7
02028:  CALL    BCC
0202C:  MOV     W0,W5
0202E:  MOV     W1,W6
02030:  MOV     W2,W7
02032:  MOV     W3,W8
02034:  BCLR.B  43.0
02036:  MOV     W5,[W15++]
02038:  MOV     W6,[W15++]
0203A:  MOV     W7,[W15++]
0203C:  MOV     W5,W0
0203E:  MOV     W6,W1
02040:  MOV     W7,W2
02042:  MOV     W8,W3
02044:  MOV     #B9B4,W4
02046:  MOV     #1D2A,W5
02048:  MOV     #D907,W6
0204A:  MOV     #3FF5,W7
0204C:  CALL    13FC
02050:  MOV     [--W15],W7
02052:  MOV     [--W15],W6
02054:  MOV     [--W15],W5
02056:  MOV     W0,1BD4
02058:  MOV     W1,1BD6
0205A:  MOV     W2,1BD8
0205C:  MOV     W3,1BDA
....................       res = res*y2 + pl_64[2]; 
0205E:  MOV     1BD4,W0
02060:  MOV     1BD6,W1
02062:  MOV     1BD8,W2
02064:  MOV     1BDA,W3
02066:  MOV     1BE4,W4
02068:  MOV     1BE6,W5
0206A:  MOV     1BE8,W6
0206C:  MOV     1BEA,W7
0206E:  CALL    BCC
02072:  MOV     W0,W5
02074:  MOV     W1,W6
02076:  MOV     W2,W7
02078:  MOV     W3,W8
0207A:  BCLR.B  43.0
0207C:  MOV     W5,[W15++]
0207E:  MOV     W6,[W15++]
02080:  MOV     W7,[W15++]
02082:  MOV     W5,W0
02084:  MOV     W6,W1
02086:  MOV     W7,W2
02088:  MOV     W8,W3
0208A:  MOV     #EB02,W4
0208C:  MOV     #6789,W5
0208E:  MOV     #F6DB,W6
02090:  MOV     #C008,W7
02092:  CALL    13FC
02096:  MOV     [--W15],W7
02098:  MOV     [--W15],W6
0209A:  MOV     [--W15],W5
0209C:  MOV     W0,1BD4
0209E:  MOV     W1,1BD6
020A0:  MOV     W2,1BD8
020A2:  MOV     W3,1BDA
....................       res = res*y2 + pl_64[3]; 
020A4:  MOV     1BD4,W0
020A6:  MOV     1BD6,W1
020A8:  MOV     1BD8,W2
020AA:  MOV     1BDA,W3
020AC:  MOV     1BE4,W4
020AE:  MOV     1BE6,W5
020B0:  MOV     1BE8,W6
020B2:  MOV     1BEA,W7
020B4:  CALL    BCC
020B8:  MOV     W0,W5
020BA:  MOV     W1,W6
020BC:  MOV     W2,W7
020BE:  MOV     W3,W8
020C0:  BCLR.B  43.0
020C2:  MOV     W5,[W15++]
020C4:  MOV     W6,[W15++]
020C6:  MOV     W7,[W15++]
020C8:  MOV     W5,W0
020CA:  MOV     W6,W1
020CC:  MOV     W7,W2
020CE:  MOV     W8,W3
020D0:  MOV     #0,W4
020D2:  MOV     #0,W5
020D4:  MOV     #0,W6
020D6:  MOV     #4000,W7
020D8:  CALL    13FC
020DC:  MOV     [--W15],W7
020DE:  MOV     [--W15],W6
020E0:  MOV     [--W15],W5
020E2:  MOV     W0,1BD4
020E4:  MOV     W1,1BD6
020E6:  MOV     W2,1BD8
020E8:  MOV     W3,1BDA
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
020EA:  MOV     #F22B,W0
020EC:  MOV     #8B93,W1
020EE:  MOV     #C543,W2
020F0:  MOV     #3F78,W3
020F2:  MOV     1BE4,W4
020F4:  MOV     1BE6,W5
020F6:  MOV     1BE8,W6
020F8:  MOV     1BEA,W7
020FA:  CALL    BCC
020FE:  MOV     W0,W5
02100:  MOV     W1,W6
02102:  MOV     W2,W7
02104:  MOV     W3,W8
02106:  BCLR.B  43.0
02108:  MOV     W5,[W15++]
0210A:  MOV     W6,[W15++]
0210C:  MOV     W7,[W15++]
0210E:  MOV     W5,W0
02110:  MOV     W6,W1
02112:  MOV     W7,W2
02114:  MOV     W8,W3
02116:  MOV     #E04F,W4
02118:  MOV     #A25D,W5
0211A:  MOV     #A984,W6
0211C:  MOV     #BFCA,W7
0211E:  CALL    13FC
02122:  MOV     [--W15],W7
02124:  MOV     [--W15],W6
02126:  MOV     [--W15],W5
02128:  MOV     W0,1BDC
0212A:  MOV     W1,1BDE
0212C:  MOV     W2,1BE0
0212E:  MOV     W3,1BE2
....................       r = r*y2 + ql_64[2]; 
02130:  MOV     1BDC,W0
02132:  MOV     1BDE,W1
02134:  MOV     1BE0,W2
02136:  MOV     1BE2,W3
02138:  MOV     1BE4,W4
0213A:  MOV     1BE6,W5
0213C:  MOV     1BE8,W6
0213E:  MOV     1BEA,W7
02140:  CALL    BCC
02144:  MOV     W0,W5
02146:  MOV     W1,W6
02148:  MOV     W2,W7
0214A:  MOV     W3,W8
0214C:  BCLR.B  43.0
0214E:  MOV     W5,[W15++]
02150:  MOV     W6,[W15++]
02152:  MOV     W7,[W15++]
02154:  MOV     W5,W0
02156:  MOV     W6,W1
02158:  MOV     W7,W2
0215A:  MOV     W8,W3
0215C:  MOV     #8F38,W4
0215E:  MOV     #EFAC,W5
02160:  MOV     #D2B5,W6
02162:  MOV     #3FF1,W7
02164:  CALL    13FC
02168:  MOV     [--W15],W7
0216A:  MOV     [--W15],W6
0216C:  MOV     [--W15],W5
0216E:  MOV     W0,1BDC
02170:  MOV     W1,1BDE
02172:  MOV     W2,1BE0
02174:  MOV     W3,1BE2
....................       r = r*y2 + ql_64[3]; 
02176:  MOV     1BDC,W0
02178:  MOV     1BDE,W1
0217A:  MOV     1BE0,W2
0217C:  MOV     1BE2,W3
0217E:  MOV     1BE4,W4
02180:  MOV     1BE6,W5
02182:  MOV     1BE8,W6
02184:  MOV     1BEA,W7
02186:  CALL    BCC
0218A:  MOV     W0,W5
0218C:  MOV     W1,W6
0218E:  MOV     W2,W7
02190:  MOV     W3,W8
02192:  BCLR.B  43.0
02194:  MOV     W5,[W15++]
02196:  MOV     W6,[W15++]
02198:  MOV     W7,[W15++]
0219A:  MOV     W5,W0
0219C:  MOV     W6,W1
0219E:  MOV     W7,W2
021A0:  MOV     W8,W3
021A2:  MOV     #3FD8,W4
021A4:  MOV     #BCDF,W5
021A6:  MOV     #4C30,W6
021A8:  MOV     #BFFE,W7
021AA:  CALL    13FC
021AE:  MOV     [--W15],W7
021B0:  MOV     [--W15],W6
021B2:  MOV     [--W15],W5
021B4:  MOV     W0,1BDC
021B6:  MOV     W1,1BDE
021B8:  MOV     W2,1BE0
021BA:  MOV     W3,1BE2
....................       r = r*y2 + 1.0; 
021BC:  MOV     1BDC,W0
021BE:  MOV     1BDE,W1
021C0:  MOV     1BE0,W2
021C2:  MOV     1BE2,W3
021C4:  MOV     1BE4,W4
021C6:  MOV     1BE6,W5
021C8:  MOV     1BE8,W6
021CA:  MOV     1BEA,W7
021CC:  CALL    BCC
021D0:  MOV     W0,W5
021D2:  MOV     W1,W6
021D4:  MOV     W2,W7
021D6:  MOV     W3,W8
021D8:  BCLR.B  43.0
021DA:  MOV     W5,[W15++]
021DC:  MOV     W6,[W15++]
021DE:  MOV     W7,[W15++]
021E0:  MOV     W5,W0
021E2:  MOV     W6,W1
021E4:  MOV     W7,W2
021E6:  MOV     W8,W3
021E8:  MOV     #0,W4
021EA:  MOV     #0,W5
021EC:  MOV     #0,W6
021EE:  MOV     #3FF0,W7
021F0:  CALL    13FC
021F4:  MOV     [--W15],W7
021F6:  MOV     [--W15],W6
021F8:  MOV     [--W15],W5
021FA:  MOV     W0,1BDC
021FC:  MOV     W1,1BDE
021FE:  MOV     W2,1BE0
02200:  MOV     W3,1BE2
....................  
....................       res = y*res/r; 
02202:  MOV     1BCC,W0
02204:  MOV     1BCE,W1
02206:  MOV     1BD0,W2
02208:  MOV     1BD2,W3
0220A:  MOV     1BD4,W4
0220C:  MOV     1BD6,W5
0220E:  MOV     1BD8,W6
02210:  MOV     1BDA,W7
02212:  CALL    BCC
02216:  MOV     W0,W5
02218:  MOV     W1,W6
0221A:  MOV     W2,W7
0221C:  MOV     W3,W8
0221E:  MOV     W5,[W15++]
02220:  MOV     W6,[W15++]
02222:  MOV     W7,[W15++]
02224:  MOV     W5,W0
02226:  MOV     W6,W1
02228:  MOV     W7,W2
0222A:  MOV     W8,W3
0222C:  MOV     1BDC,W4
0222E:  MOV     1BDE,W5
02230:  MOV     1BE0,W6
02232:  MOV     1BE2,W7
02234:  CALL    CDC
02238:  MOV     [--W15],W7
0223A:  MOV     [--W15],W6
0223C:  MOV     [--W15],W5
0223E:  MOV     W0,1BD4
02240:  MOV     W1,1BD6
02242:  MOV     W2,1BD8
02244:  MOV     W3,1BDA
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
02246:  MOV     #1BCA,W4
02248:  MOV     W4,1BF0
....................       data1 = *p; 
0224A:  MOV     1BF0,W0
0224C:  MOV     [W0],[W15++]
0224E:  POP     1BEC
....................       bit_clear(data1,15); 
02250:  MOV     #1BEC,W4
02252:  BCLR    [W4].F
....................       data1 = data1 >>4;     
02254:  MOV     1BEC,W0
02256:  LSR     W0,#4,W0
02258:  MOV     W0,1BEC
....................       n = data1 - 0x3FE; 
0225A:  MOV     1BEC,W4
0225C:  SUB     #3FE,W4
0225E:  MOV     W4,1BF2
....................  
....................  
....................       if (n<0) 
02260:  MOV     1BF2,W4
02262:  CP      W4,#0
02264:  BRA     GE,2284
....................          r = -(float64)-n; 
02266:  MOV     #0,W4
02268:  MOV     1BF2,W3
0226A:  SUB     W4,W3,W0
0226C:  MOV     #0,W1
0226E:  MOV     #0,W2
02270:  MOV     #0,W3
02272:  CALL    12E8
02276:  MOV     W0,1BDC
02278:  MOV     W1,1BDE
0227A:  MOV     W2,1BE0
0227C:  MOV     W3,1BE2
0227E:  BTG.B   1BE3.7
02280:  GOTO    229C
....................       else 
....................          r = (float64)n; 
02284:  MOV     1BF2,W0
02286:  CLR     W3
02288:  BTSC    W0.F
0228A:  SETM    W3
0228C:  MOV     W3,W1
0228E:  MOV     W3,W2
02290:  CALL    12E8
02294:  MOV     W0,1BDC
02296:  MOV     W1,1BDE
02298:  MOV     W2,1BE0
0229A:  MOV     W3,1BE2
....................  
....................       res += r*LN2; 
0229C:  MOV     1BDC,W0
0229E:  MOV     1BDE,W1
022A0:  MOV     1BE0,W2
022A2:  MOV     1BE2,W3
022A4:  MOV     #39EE,W4
022A6:  MOV     #FEFA,W5
022A8:  MOV     #2E42,W6
022AA:  MOV     #3FE6,W7
022AC:  CALL    BCC
022B0:  BCLR.B  43.0
022B2:  MOV     W0,W4
022B4:  MOV     W1,W5
022B6:  MOV     W2,W6
022B8:  MOV     W3,W7
022BA:  MOV     1BD4,W0
022BC:  MOV     1BD6,W1
022BE:  MOV     1BD8,W2
022C0:  MOV     1BDA,W3
022C2:  CALL    13FC
022C6:  MOV     W0,1BD4
022C8:  MOV     W1,1BD6
022CA:  MOV     W2,1BD8
022CC:  MOV     W3,1BDA
....................    } 
022CE:  GOTO    22DA
....................  
....................    else 
....................       res = 0.0; 
022D2:  CLR     1BD4
022D4:  CLR     1BD6
022D6:  CLR     1BD8
022D8:  CLR     1BDA
....................  
....................    return(res); 
022DA:  MOV     1BD4,W0
022DC:  MOV     1BD6,W1
022DE:  MOV     1BD8,W2
022E0:  MOV     1BDA,W3
022E2:  MOV     [--W15],W8
022E4:  MOV     [--W15],W7
022E6:  MOV     [--W15],W6
022E8:  MOV     [--W15],W5
022EA:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
*
02768:  MOV     W5,[W15++]
0276A:  MOV     #C,W5
0276C:  REPEAT  #6
0276E:  MOV     [W5++],[W15++]
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
02770:  MOV     1BAA,W0
02772:  MOV     1BAC,W1
02774:  MOV     1BAE,W2
02776:  MOV     1BB0,W3
02778:  MOV     #0,W4
0277A:  MOV     #0,W5
0277C:  MOV     #0,W6
0277E:  MOV     #0,W7
02780:  CALL    15EA
02784:  BRA     NC,28C8
02786:  PUSH    1BB2
02788:  POP     1BC4
0278A:  PUSH    1BB4
0278C:  POP     1BC6
0278E:  PUSH    1BB6
02790:  POP     1BC8
02792:  PUSH    1BB8
02794:  POP     1BCA
02796:  CLR     1BCC
02798:  CLR     1BCE
0279A:  CLR     1BD0
0279C:  MOV     #3FF0,W4
0279E:  MOV     W4,1BD2
027A0:  CALL    1E42
027A4:  MOV     W0,W9
027A6:  MOV     W1,W10
027A8:  MOV     W2,W11
027AA:  MOV     W3,W12
027AC:  MOV     W5,[W15++]
027AE:  MOV     W6,[W15++]
027B0:  MOV     W7,[W15++]
027B2:  MOV     W9,W0
027B4:  MOV     W10,W1
027B6:  MOV     W11,W2
027B8:  MOV     W12,W3
027BA:  MOV     #0,W4
027BC:  MOV     #0,W5
027BE:  MOV     #0,W6
027C0:  MOV     #0,W7
027C2:  CALL    15EA
027C6:  MOV     [--W15],W7
027C8:  MOV     [--W15],W6
027CA:  MOV     [--W15],W5
027CC:  BRA     NZ,28C8
....................       if(fmod(y, 2) == 0) { 
027CE:  PUSH    1BB2
027D0:  POP     1BC4
027D2:  PUSH    1BB4
027D4:  POP     1BC6
027D6:  PUSH    1BB6
027D8:  POP     1BC8
027DA:  PUSH    1BB8
027DC:  POP     1BCA
027DE:  CLR     1BCC
027E0:  CLR     1BCE
027E2:  CLR     1BD0
027E4:  MOV     #4000,W4
027E6:  MOV     W4,1BD2
027E8:  CALL    1E42
027EC:  MOV     W0,W9
027EE:  MOV     W1,W10
027F0:  MOV     W2,W11
027F2:  MOV     W3,W12
027F4:  MOV     W5,[W15++]
027F6:  MOV     W6,[W15++]
027F8:  MOV     W7,[W15++]
027FA:  MOV     W9,W0
027FC:  MOV     W10,W1
027FE:  MOV     W11,W2
02800:  MOV     W12,W3
02802:  MOV     #0,W4
02804:  MOV     #0,W5
02806:  MOV     #0,W6
02808:  MOV     #0,W7
0280A:  CALL    15EA
0280E:  MOV     [--W15],W7
02810:  MOV     [--W15],W6
02812:  MOV     [--W15],W5
02814:  BRA     NZ,286E
....................          return (exp(log(-x) * y)); 
02816:  MOV     1BAA,W5
02818:  MOV     1BAC,W6
0281A:  MOV     1BAE,W7
0281C:  MOV     1BB0,W8
0281E:  BTG     W8.F
02820:  MOV     W5,1BC4
02822:  MOV     W6,1BC6
02824:  MOV     W7,1BC8
02826:  MOV     W8,1BCA
02828:  CALL    1F34
0282C:  MOV     W0,W5
0282E:  MOV     W1,W6
02830:  MOV     W2,W7
02832:  MOV     W3,W8
02834:  MOV     W5,[W15++]
02836:  MOV     W6,[W15++]
02838:  MOV     W7,[W15++]
0283A:  MOV     W5,W0
0283C:  MOV     W6,W1
0283E:  MOV     W7,W2
02840:  MOV     W8,W3
02842:  MOV     1BB2,W4
02844:  MOV     1BB4,W5
02846:  MOV     1BB6,W6
02848:  MOV     1BB8,W7
0284A:  CALL    BCC
0284E:  MOV     [--W15],W7
02850:  MOV     [--W15],W6
02852:  MOV     [--W15],W5
02854:  MOV     W0,W5
02856:  MOV     W1,W6
02858:  MOV     W2,W7
0285A:  MOV     W3,W8
0285C:  MOV     W5,1BC4
0285E:  MOV     W6,1BC6
02860:  MOV     W7,1BC8
02862:  MOV     W8,1BCA
02864:  CALL    22EC
02868:  BRA     29C2
....................       } else { 
0286A:  GOTO    28C4
....................          return (-exp(log(-x) * y)); 
0286E:  MOV     1BAA,W5
02870:  MOV     1BAC,W6
02872:  MOV     1BAE,W7
02874:  MOV     1BB0,W8
02876:  BTG     W8.F
02878:  MOV     W5,1BC4
0287A:  MOV     W6,1BC6
0287C:  MOV     W7,1BC8
0287E:  MOV     W8,1BCA
02880:  CALL    1F34
02884:  MOV     W0,W5
02886:  MOV     W1,W6
02888:  MOV     W2,W7
0288A:  MOV     W3,W8
0288C:  MOV     W5,[W15++]
0288E:  MOV     W6,[W15++]
02890:  MOV     W7,[W15++]
02892:  MOV     W5,W0
02894:  MOV     W6,W1
02896:  MOV     W7,W2
02898:  MOV     W8,W3
0289A:  MOV     1BB2,W4
0289C:  MOV     1BB4,W5
0289E:  MOV     1BB6,W6
028A0:  MOV     1BB8,W7
028A2:  CALL    BCC
028A6:  MOV     [--W15],W7
028A8:  MOV     [--W15],W6
028AA:  MOV     [--W15],W5
028AC:  MOV     W0,W5
028AE:  MOV     W1,W6
028B0:  MOV     W2,W7
028B2:  MOV     W3,W8
028B4:  MOV     W5,1BC4
028B6:  MOV     W6,1BC6
028B8:  MOV     W7,1BC8
028BA:  MOV     W8,1BCA
028BC:  CALL    22EC
028C0:  BTG     W3.F
028C2:  BRA     29C2
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
028C4:  GOTO    29C2
028C8:  MOV     1BAA,W0
028CA:  MOV     1BAC,W1
028CC:  MOV     1BAE,W2
028CE:  MOV     1BB0,W3
028D0:  MOV     #0,W4
028D2:  MOV     #0,W5
028D4:  MOV     #0,W6
028D6:  MOV     #0,W7
028D8:  CALL    15EA
028DC:  BRA     NC,2934
028DE:  PUSH    1BB2
028E0:  POP     1BC4
028E2:  PUSH    1BB4
028E4:  POP     1BC6
028E6:  PUSH    1BB6
028E8:  POP     1BC8
028EA:  PUSH    1BB8
028EC:  POP     1BCA
028EE:  CLR     1BCC
028F0:  CLR     1BCE
028F2:  CLR     1BD0
028F4:  MOV     #3FF0,W4
028F6:  MOV     W4,1BD2
028F8:  CALL    1E42
028FC:  MOV     W0,W9
028FE:  MOV     W1,W10
02900:  MOV     W2,W11
02902:  MOV     W3,W12
02904:  MOV     W5,[W15++]
02906:  MOV     W6,[W15++]
02908:  MOV     W7,[W15++]
0290A:  MOV     W9,W0
0290C:  MOV     W10,W1
0290E:  MOV     W11,W2
02910:  MOV     W12,W3
02912:  MOV     #0,W4
02914:  MOV     #0,W5
02916:  MOV     #0,W6
02918:  MOV     #0,W7
0291A:  CALL    15EA
0291E:  MOV     [--W15],W7
02920:  MOV     [--W15],W6
02922:  MOV     [--W15],W5
02924:  BRA     Z,2934
....................       return 0; 
02926:  MOV     #0,W0
02928:  MOV     #0,W1
0292A:  MOV     #0,W2
0292C:  MOV     #0,W3
0292E:  BRA     29C2
....................    } else { 
02930:  GOTO    29C2
....................       if(x != 0 || 0 >= y) { 
02934:  MOV     1BAA,W0
02936:  MOV     1BAC,W1
02938:  MOV     1BAE,W2
0293A:  MOV     1BB0,W3
0293C:  MOV     #0,W4
0293E:  MOV     #0,W5
02940:  MOV     #0,W6
02942:  MOV     #0,W7
02944:  CALL    15EA
02948:  BRA     NZ,2962
0294A:  MOV     1BB2,W0
0294C:  MOV     1BB4,W1
0294E:  MOV     1BB6,W2
02950:  MOV     1BB8,W3
02952:  MOV     #0,W4
02954:  MOV     #0,W5
02956:  MOV     #0,W6
02958:  MOV     #0,W7
0295A:  CALL    15EA
0295E:  BRA     C,2962
02960:  BRA     NZ,29B8
....................          return (exp(log(x) * y)); 
02962:  PUSH    1BAA
02964:  POP     1BC4
02966:  PUSH    1BAC
02968:  POP     1BC6
0296A:  PUSH    1BAE
0296C:  POP     1BC8
0296E:  PUSH    1BB0
02970:  POP     1BCA
02972:  CALL    1F34
02976:  MOV     W0,W5
02978:  MOV     W1,W6
0297A:  MOV     W2,W7
0297C:  MOV     W3,W8
0297E:  MOV     W5,[W15++]
02980:  MOV     W6,[W15++]
02982:  MOV     W7,[W15++]
02984:  MOV     W5,W0
02986:  MOV     W6,W1
02988:  MOV     W7,W2
0298A:  MOV     W8,W3
0298C:  MOV     1BB2,W4
0298E:  MOV     1BB4,W5
02990:  MOV     1BB6,W6
02992:  MOV     1BB8,W7
02994:  CALL    BCC
02998:  MOV     [--W15],W7
0299A:  MOV     [--W15],W6
0299C:  MOV     [--W15],W5
0299E:  MOV     W0,W5
029A0:  MOV     W1,W6
029A2:  MOV     W2,W7
029A4:  MOV     W3,W8
029A6:  MOV     W5,1BC4
029A8:  MOV     W6,1BC6
029AA:  MOV     W7,1BC8
029AC:  MOV     W8,1BCA
029AE:  CALL    22EC
029B2:  BRA     29C2
....................       } else return 0; 
029B4:  GOTO    29C2
029B8:  MOV     #0,W0
029BA:  MOV     #0,W1
029BC:  MOV     #0,W2
029BE:  MOV     #0,W3
029C0:  BRA     29C2
....................    } 
029C2:  MOV     #18,W5
029C4:  REPEAT  #6
029C6:  MOV     [--W15],[W5--]
029C8:  MOV     [--W15],W5
029CA:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
07B6A:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
07B6C:  MOV     1B4C,W0
07B6E:  MOV     1B4E,W1
07B70:  MOV     #0,W2
07B72:  MOV     #0,W3
07B74:  CALL    604C
07B78:  BRA     C,7B7C
07B7A:  BRA     NZ,7B82
....................       return(0.0); 
07B7C:  MOV     #0,W0
07B7E:  MOV     #0,W1
07B80:  BRA     7C46
....................  
....................    y=x; 
07B82:  PUSH    1B4C
07B84:  POP     1B50
07B86:  PUSH    1B4E
07B88:  POP     1B52
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
07B8A:  MOV     #1B53,W4
07B8C:  MOV     W4,1B5C
....................     data1 = *(((unsigned int8 *)(&y))+3); 
07B8E:  MOV     #1B53,W0
07B90:  MOV     1B58,W4
07B92:  MOV.B   [W0+#0],W4L
07B94:  MOV     W4,1B58
07B96:  CLR.B   1B59
....................     data2 = *(((unsigned int8 *)(&y))+2); 
07B98:  MOV     #1B52,W0
07B9A:  MOV     1B5A,W4
07B9C:  MOV.B   [W0+#0],W4L
07B9E:  MOV     W4,1B5A
07BA0:  CLR.B   1B5B
....................     rotate_left(&data1,1);     
07BA2:  MOV     #1B58,W1
07BA4:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
07BA6:  BTSS.B  1B5A.7
07BA8:  BRA     7BAE
....................        bit_set(data1,0);     
07BAA:  MOV     #1B58,W4
07BAC:  BSET    [W4].0
....................     data1 = ((data1+127) >>1); 
07BAE:  MOV     #7F,W4
07BB0:  MOV     1B58,W3
07BB2:  ADD     W3,W4,W5
07BB4:  MOV     W5,1B58
07BB6:  LSR     1B58
....................     bit_clear(data2,7); 
07BB8:  MOV     #1B5A,W4
07BBA:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
07BBC:  BTSS.B  1B58.0
07BBE:  BRA     7BC4
....................        bit_set(data2,7); 
07BC0:  MOV     #1B5A,W4
07BC2:  BSET    [W4].7
....................     data1 = data1 >>1; 
07BC4:  LSR     1B58
....................     *(((unsigned int8 *)(&y))+3) = data1; 
07BC6:  MOV     #1B53,W5
07BC8:  MOV     1B58,W0
07BCA:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
07BCC:  MOV     #1B52,W5
07BCE:  MOV     1B5A,W0
07BD0:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
07BD2:  PUSH    1B50
07BD4:  POP     1B54
07BD6:  PUSH    1B52
07BD8:  POP     1B56
....................       y+=(x/y); 
07BDA:  MOV     1B4C,W0
07BDC:  MOV     1B4E,W1
07BDE:  MOV     1B50,W2
07BE0:  MOV     1B52,W3
07BE2:  CALL    7AA0
07BE6:  BCLR.B  43.0
07BE8:  MOV     W0,W2
07BEA:  MOV     W1,W3
07BEC:  MOV     1B50,W0
07BEE:  MOV     1B52,W1
07BF0:  CALL    61DE
07BF4:  MOV     W0,1B50
07BF6:  MOV     W1,1B52
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
07BF8:  MOV     #1B53,W0
07BFA:  MOV     1B58,W4
07BFC:  MOV.B   [W0+#0],W4L
07BFE:  MOV     W4,1B58
07C00:  CLR.B   1B59
....................     data2 = *(((unsigned int8 *)(&y))+2); 
07C02:  MOV     #1B52,W0
07C04:  MOV     1B5A,W4
07C06:  MOV.B   [W0+#0],W4L
07C08:  MOV     W4,1B5A
07C0A:  CLR.B   1B5B
....................     rotate_left(&data1,1); 
07C0C:  MOV     #1B58,W1
07C0E:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
07C10:  BTSS.B  1B5A.7
07C12:  BRA     7C18
....................        bit_set(data1,0);     
07C14:  MOV     #1B58,W4
07C16:  BSET    [W4].0
....................     data1--; 
07C18:  DEC     1B58
....................     bit_clear(data2,7); 
07C1A:  MOV     #1B5A,W4
07C1C:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
07C1E:  BTSS.B  1B58.0
07C20:  BRA     7C26
....................        bit_set(data2,7); 
07C22:  MOV     #1B5A,W4
07C24:  BSET    [W4].7
....................     data1 = data1 >>1; 
07C26:  LSR     1B58
....................     *(((unsigned int8 *)(&y))+3) = data1; 
07C28:  MOV     #1B53,W5
07C2A:  MOV     1B58,W0
07C2C:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
07C2E:  MOV     #1B52,W5
07C30:  MOV     1B5A,W0
07C32:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
07C34:  MOV     1B54,W0
07C36:  MOV     1B56,W1
07C38:  MOV     1B50,W2
07C3A:  MOV     1B52,W3
07C3C:  CALL    604C
07C40:  BRA     NZ,7BD2
....................  
....................    return(res); 
07C42:  MOV     1B54,W0
07C44:  MOV     1B56,W1
07C46:  MOV     [--W15],W5
07C48:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
*
029CC:  MOV     W5,[W15++]
029CE:  MOV     W6,[W15++]
029D0:  MOV     W7,[W15++]
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
029D2:  MOV     1BC2,W0
029D4:  MOV     1BC4,W1
029D6:  MOV     1BC6,W2
029D8:  MOV     1BC8,W3
029DA:  MOV     #0,W4
029DC:  MOV     #0,W5
029DE:  MOV     #0,W6
029E0:  MOV     #0,W7
029E2:  CALL    15EA
029E6:  BRA     C,29EA
029E8:  BRA     NZ,29F4
....................       return(0.0); 
029EA:  MOV     #0,W0
029EC:  MOV     #0,W1
029EE:  MOV     #0,W2
029F0:  MOV     #0,W3
029F2:  BRA     2AE0
....................  
....................    y=x; 
029F4:  PUSH    1BC2
029F6:  POP     1BCA
029F8:  PUSH    1BC4
029FA:  POP     1BCC
029FC:  PUSH    1BC6
029FE:  POP     1BCE
02A00:  PUSH    1BC8
02A02:  POP     1BD0
....................    p= (((unsigned int16 *)(&y))+3); 
02A04:  MOV     #1BD0,W4
02A06:  MOV     W4,1BDA
....................    temp1 = *p; 
02A08:  MOV     1BDA,W0
02A0A:  MOV     [W0],[W15++]
02A0C:  POP     1BDC
....................    temp2 = *p; 
02A0E:  MOV     1BDA,W0
02A10:  MOV     [W0],[W15++]
02A12:  POP     1BDE
....................    bit_clear(temp1,15); 
02A14:  MOV     #1BDC,W4
02A16:  BCLR    [W4].F
....................    temp1 = (temp1>>4)+1023; 
02A18:  MOV     1BDC,W5
02A1A:  LSR     W5,#4,W5
02A1C:  MOV     #3FF,W4
02A1E:  ADD     W5,W4,W0
02A20:  MOV     W0,1BDC
....................    temp1 = temp1 >> 1; 
02A22:  LSR     1BDC
....................    temp1 = (temp1<<4) & 0xFFF0; 
02A24:  MOV     1BDC,W5
02A26:  SL      W5,#4,W5
02A28:  MOV     #FFF0,W0
02A2A:  AND     W0,W5,W0
02A2C:  MOV     W0,1BDC
....................    if(bit_test(temp2,15)) 
02A2E:  BTSS.B  1BDF.7
02A30:  BRA     2A36
....................       bit_set(temp1,15); 
02A32:  MOV     #1BDC,W4
02A34:  BSET    [W4].F
....................    temp2 = temp2 & 0x000F; 
02A36:  MOV     1BDE,W0
02A38:  AND     W0,#F,W0
02A3A:  MOV     W0,1BDE
....................    temp1 ^= temp2; 
02A3C:  MOV     1BDE,W0
02A3E:  XOR     1BDC
....................     
....................    (*p) = temp1; 
02A40:  MOV     1BDA,W5
02A42:  MOV     1BDC,W4
02A44:  MOV     W4,[W5+#0]
....................     
....................    do { 
....................       res=y; 
02A46:  PUSH    1BCA
02A48:  POP     1BD2
02A4A:  PUSH    1BCC
02A4C:  POP     1BD4
02A4E:  PUSH    1BCE
02A50:  POP     1BD6
02A52:  PUSH    1BD0
02A54:  POP     1BD8
....................       y+=(x/y); 
02A56:  MOV     1BC2,W0
02A58:  MOV     1BC4,W1
02A5A:  MOV     1BC6,W2
02A5C:  MOV     1BC8,W3
02A5E:  MOV     1BCA,W4
02A60:  MOV     1BCC,W5
02A62:  MOV     1BCE,W6
02A64:  MOV     1BD0,W7
02A66:  CALL    CDC
02A6A:  BCLR.B  43.0
02A6C:  MOV     W0,W4
02A6E:  MOV     W1,W5
02A70:  MOV     W2,W6
02A72:  MOV     W3,W7
02A74:  MOV     1BCA,W0
02A76:  MOV     1BCC,W1
02A78:  MOV     1BCE,W2
02A7A:  MOV     1BD0,W3
02A7C:  CALL    13FC
02A80:  MOV     W0,1BCA
02A82:  MOV     W1,1BCC
02A84:  MOV     W2,1BCE
02A86:  MOV     W3,1BD0
....................      temp1 = *p; 
02A88:  MOV     1BDA,W0
02A8A:  MOV     [W0],[W15++]
02A8C:  POP     1BDC
....................      temp2 = *p; 
02A8E:  MOV     1BDA,W0
02A90:  MOV     [W0],[W15++]
02A92:  POP     1BDE
....................      bit_clear(temp1,15); 
02A94:  MOV     #1BDC,W4
02A96:  BCLR    [W4].F
....................      temp1 = (temp1>>4); 
02A98:  MOV     1BDC,W0
02A9A:  LSR     W0,#4,W0
02A9C:  MOV     W0,1BDC
....................      temp1--; 
02A9E:  DEC     1BDC
....................      temp1 = (temp1<<4) & 0xFFF0; 
02AA0:  MOV     1BDC,W5
02AA2:  SL      W5,#4,W5
02AA4:  MOV     #FFF0,W0
02AA6:  AND     W0,W5,W0
02AA8:  MOV     W0,1BDC
....................      if(bit_test(temp2,15)) 
02AAA:  BTSS.B  1BDF.7
02AAC:  BRA     2AB2
....................         bit_set(temp1,15); 
02AAE:  MOV     #1BDC,W4
02AB0:  BSET    [W4].F
....................      temp2 = temp2 & 0x000F; 
02AB2:  MOV     1BDE,W0
02AB4:  AND     W0,#F,W0
02AB6:  MOV     W0,1BDE
....................      temp1 ^= temp2; 
02AB8:  MOV     1BDE,W0
02ABA:  XOR     1BDC
....................      (*p) = temp1; 
02ABC:  MOV     1BDA,W5
02ABE:  MOV     1BDC,W4
02AC0:  MOV     W4,[W5+#0]
....................  
....................    } while(res != y); 
02AC2:  MOV     1BD2,W0
02AC4:  MOV     1BD4,W1
02AC6:  MOV     1BD6,W2
02AC8:  MOV     1BD8,W3
02ACA:  MOV     1BCA,W4
02ACC:  MOV     1BCC,W5
02ACE:  MOV     1BCE,W6
02AD0:  MOV     1BD0,W7
02AD2:  CALL    15EA
02AD6:  BRA     NZ,2A46
....................  
....................    return(res); 
02AD8:  MOV     1BD2,W0
02ADA:  MOV     1BD4,W1
02ADC:  MOV     1BD6,W2
02ADE:  MOV     1BD8,W3
02AE0:  MOV     [--W15],W7
02AE2:  MOV     [--W15],W6
02AE4:  MOV     [--W15],W5
02AE6:  RETURN  
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
*
07F0A:  MOV     W5,[W15++]
07F0C:  MOV     W6,[W15++]
07F0E:  MOV     W7,[W15++]
07F10:  MOV     W8,[W15++]
07F12:  CLR     1B74
07F14:  CLR     1B76
07F16:  CLR     1B78
07F18:  MOV     #3FF0,W4
07F1A:  MOV     W4,1B7A
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
07F1C:  MOV     #FF1F,W4
07F1E:  MOV     W4,1B84
07F20:  SETM    1B86
07F22:  SETM    1B88
07F24:  MOV     #BFDF,W4
07F26:  MOV     W4,1B8A
07F28:  MOV     #1C35,W4
07F2A:  MOV     W4,1B8C
07F2C:  MOV     #5555,W4
07F2E:  MOV     W4,1B8E
07F30:  MOV     #5555,W4
07F32:  MOV     W4,1B90
07F34:  MOV     #3FA5,W4
07F36:  MOV     W4,1B92
07F38:  MOV     #3F1C,W4
07F3A:  MOV     W4,1B94
07F3C:  MOV     #16A7,W4
07F3E:  MOV     W4,1B96
07F40:  MOV     #C16C,W4
07F42:  MOV     W4,1B98
07F44:  MOV     #BF56,W4
07F46:  MOV     W4,1B9A
07F48:  MOV     #F3E6,W4
07F4A:  MOV     W4,1B9C
07F4C:  MOV     #D65,W4
07F4E:  MOV     W4,1B9E
07F50:  MOV     #1A0,W4
07F52:  MOV     W4,1BA0
07F54:  MOV     #3EFA,W4
07F56:  MOV     W4,1BA2
07F58:  MOV     #A3E,W4
07F5A:  MOV     W4,1BA4
07F5C:  MOV     #3931,W4
07F5E:  MOV     W4,1BA6
07F60:  MOV     #7E4C,W4
07F62:  MOV     W4,1BA8
07F64:  MOV     #BE92,W4
07F66:  MOV     W4,1BAA
07F68:  MOV     #DDFB,W4
07F6A:  MOV     W4,1BAC
07F6C:  MOV     #2B77,W4
07F6E:  MOV     W4,1BAE
07F70:  MOV     #EDB1,W4
07F72:  MOV     W4,1BB0
07F74:  MOV     #3E21,W4
07F76:  MOV     W4,1BB2
07F78:  MOV     #6FCC,W4
07F7A:  MOV     W4,1BB4
07F7C:  MOV     #8FF7,W4
07F7E:  MOV     W4,1BB6
07F80:  MOV     #C610,W4
07F82:  MOV     W4,1BB8
07F84:  MOV     #BDA8,W4
07F86:  MOV     W4,1BBA
07F88:  MOV     #124C,W4
07F8A:  MOV     W4,1BBC
07F8C:  MOV     #8E1C,W4
07F8E:  MOV     W4,1BBE
07F90:  MOV     #3AF9,W4
07F92:  MOV     W4,1BC0
07F94:  MOV     #3CF3,W4
07F96:  MOV     W4,1BC2
07F98:  MOV     #7676,W4
07F9A:  MOV     W4,1BC4
07F9C:  MOV     #350F,W4
07F9E:  MOV     W4,1BC6
07FA0:  MOV     #C0DE,W4
07FA2:  MOV     W4,1BC8
07FA4:  MOV     #3CF0,W4
07FA6:  MOV     W4,1BCA
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
07FA8:  MOV     1B5A,W0
07FAA:  MOV     1B5C,W1
07FAC:  MOV     1B5E,W2
07FAE:  MOV     1B60,W3
07FB0:  MOV     #0,W4
07FB2:  MOV     #0,W5
07FB4:  MOV     #0,W6
07FB6:  MOV     #0,W7
07FB8:  CALL    15EA
07FBC:  BRA     NC,7FC8
07FBE:  MOV     #1B5A,W0
07FC0:  MOV     #1B5A,W1
07FC2:  REPEAT  #7
07FC4:  MOV     [W0++],[W1++]
07FC6:  BTG.B   1B61.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
07FC8:  MOV     1B5A,W0
07FCA:  MOV     1B5C,W1
07FCC:  MOV     1B5E,W2
07FCE:  MOV     1B60,W3
07FD0:  MOV     #C884,W4
07FD2:  MOV     #6DC9,W5
07FD4:  MOV     #5F30,W6
07FD6:  MOV     #3FE4,W7
07FD8:  CALL    BCC
07FDC:  CALL    1AD2
07FE0:  MOV.B   W0L,1B62
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
07FE2:  MOV     1B5A,W0
07FE4:  MOV     1B5C,W1
07FE6:  MOV     1B5E,W2
07FE8:  MOV     1B60,W3
07FEA:  MOV     #C884,W4
07FEC:  MOV     #6DC9,W5
07FEE:  MOV     #5F30,W6
07FF0:  MOV     #3FE4,W7
07FF2:  CALL    BCC
07FF6:  MOV     W0,W5
07FF8:  MOV     W1,W6
07FFA:  MOV     W2,W7
07FFC:  MOV     W3,W8
07FFE:  MOV     #0,W1
08000:  MOV     #0,W2
08002:  MOV     #0,W3
08004:  MOV.B   1B62,W0L
08006:  CLR.B   1
08008:  CALL    1B30
0800C:  BSET.B  43.0
0800E:  MOV     W5,[W15++]
08010:  MOV     W6,[W15++]
08012:  MOV     W7,[W15++]
08014:  MOV     W0,W4
08016:  MOV     W5,W0
08018:  MOV     W1,W5
0801A:  MOV     W6,W1
0801C:  MOV     W2,W6
0801E:  MOV     W7,W2
08020:  MOV     W3,W7
08022:  MOV     W8,W3
08024:  CALL    13FC
08028:  MOV     [--W15],W7
0802A:  MOV     [--W15],W6
0802C:  MOV     [--W15],W5
0802E:  MOV     W0,1B7C
08030:  MOV     W1,1B7E
08032:  MOV     W2,1B80
08034:  MOV     W3,1B82
....................    quad = quad % 4;                    // quadrant (0 to 3) 
08036:  MOV.B   1B62,W0L
08038:  AND.B   W0L,#3,W0L
0803A:  MOV.B   W0L,1B62
....................  
....................    if (quad == 0 || quad == 2) 
0803C:  CP0.B   1B62
0803E:  BRA     Z,8046
08040:  MOV     1B62,W4
08042:  CP.B    W4L,#2
08044:  BRA     NZ,8066
....................       t = frac * PI_DIV_BY_TWO; 
08046:  MOV     1B7C,W0
08048:  MOV     1B7E,W1
0804A:  MOV     1B80,W2
0804C:  MOV     1B82,W3
0804E:  MOV     #2D18,W4
08050:  MOV     #5444,W5
08052:  MOV     #21FB,W6
08054:  MOV     #3FF9,W7
08056:  CALL    BCC
0805A:  MOV     W0,1B6C
0805C:  MOV     W1,1B6E
0805E:  MOV     W2,1B70
08060:  MOV     W3,1B72
08062:  GOTO    80FC
....................    else if (quad == 1) 
08066:  MOV     1B62,W4
08068:  CP.B    W4L,#1
0806A:  BRA     NZ,80B6
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0806C:  BSET.B  43.0
0806E:  MOV     #0,W0
08070:  MOV     #0,W1
08072:  MOV     #0,W2
08074:  MOV     #3FF0,W3
08076:  MOV     1B7C,W4
08078:  MOV     1B7E,W5
0807A:  MOV     1B80,W6
0807C:  MOV     1B82,W7
0807E:  CALL    13FC
08082:  MOV     W0,W5
08084:  MOV     W1,W6
08086:  MOV     W2,W7
08088:  MOV     W3,W8
0808A:  MOV     W5,[W15++]
0808C:  MOV     W6,[W15++]
0808E:  MOV     W7,[W15++]
08090:  MOV     W5,W0
08092:  MOV     W6,W1
08094:  MOV     W7,W2
08096:  MOV     W8,W3
08098:  MOV     #2D18,W4
0809A:  MOV     #5444,W5
0809C:  MOV     #21FB,W6
0809E:  MOV     #3FF9,W7
080A0:  CALL    BCC
080A4:  MOV     [--W15],W7
080A6:  MOV     [--W15],W6
080A8:  MOV     [--W15],W5
080AA:  MOV     W0,1B6C
080AC:  MOV     W1,1B6E
080AE:  MOV     W2,1B70
080B0:  MOV     W3,1B72
080B2:  GOTO    80FC
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
080B6:  BSET.B  43.0
080B8:  MOV     1B7C,W0
080BA:  MOV     1B7E,W1
080BC:  MOV     1B80,W2
080BE:  MOV     1B82,W3
080C0:  MOV     #0,W4
080C2:  MOV     #0,W5
080C4:  MOV     #0,W6
080C6:  MOV     #3FF0,W7
080C8:  CALL    13FC
080CC:  MOV     W0,W5
080CE:  MOV     W1,W6
080D0:  MOV     W2,W7
080D2:  MOV     W3,W8
080D4:  MOV     W5,[W15++]
080D6:  MOV     W6,[W15++]
080D8:  MOV     W7,[W15++]
080DA:  MOV     W5,W0
080DC:  MOV     W6,W1
080DE:  MOV     W7,W2
080E0:  MOV     W8,W3
080E2:  MOV     #2D18,W4
080E4:  MOV     #5444,W5
080E6:  MOV     #21FB,W6
080E8:  MOV     #3FF9,W7
080EA:  CALL    BCC
080EE:  MOV     [--W15],W7
080F0:  MOV     [--W15],W6
080F2:  MOV     [--W15],W5
080F4:  MOV     W0,1B6C
080F6:  MOV     W1,1B6E
080F8:  MOV     W2,1B70
080FA:  MOV     W3,1B72
....................  
....................    y = 1.0; 
080FC:  CLR     1B64
080FE:  CLR     1B66
08100:  CLR     1B68
08102:  MOV     #3FF0,W4
08104:  MOV     W4,1B6A
....................    t = t * t; 
08106:  MOV     1B6C,W0
08108:  MOV     1B6E,W1
0810A:  MOV     1B70,W2
0810C:  MOV     1B72,W3
0810E:  MOV     1B6C,W4
08110:  MOV     1B6E,W5
08112:  MOV     1B70,W6
08114:  MOV     1B72,W7
08116:  CALL    BCC
0811A:  MOV     W0,1B6C
0811C:  MOV     W1,1B6E
0811E:  MOV     W2,1B70
08120:  MOV     W3,1B72
....................    for (i = 0; i <= 8; i++) 
08122:  CLR.B   1B63
08124:  MOV     1B62,W4
08126:  LSR     W4,#8,W4
08128:  CP.B    W4L,#8
0812A:  BRA     GTU,819C
....................    { 
....................       t2 = t2 * t; 
0812C:  MOV     1B74,W0
0812E:  MOV     1B76,W1
08130:  MOV     1B78,W2
08132:  MOV     1B7A,W3
08134:  MOV     1B6C,W4
08136:  MOV     1B6E,W5
08138:  MOV     1B70,W6
0813A:  MOV     1B72,W7
0813C:  CALL    BCC
08140:  MOV     W0,1B74
08142:  MOV     W1,1B76
08144:  MOV     W2,1B78
08146:  MOV     W3,1B7A
....................       y = y + p_64[i] * t2; 
08148:  MOV.B   1B63,W0L
0814A:  CLR.B   1
0814C:  SL      W0,#3,W0
0814E:  MOV     #1B84,W4
08150:  ADD     W0,W4,W0
08152:  MOV     #A,W4
08154:  REPEAT  #3
08156:  MOV     [W0++],[W4++]
08158:  MOV     W5,[W15++]
0815A:  MOV     W6,[W15++]
0815C:  MOV     W7,[W15++]
0815E:  MOV     W5,W0
08160:  MOV     W6,W1
08162:  MOV     W7,W2
08164:  MOV     W8,W3
08166:  MOV     1B74,W4
08168:  MOV     1B76,W5
0816A:  MOV     1B78,W6
0816C:  MOV     1B7A,W7
0816E:  CALL    BCC
08172:  MOV     [--W15],W7
08174:  MOV     [--W15],W6
08176:  MOV     [--W15],W5
08178:  BCLR.B  43.0
0817A:  MOV     W0,W4
0817C:  MOV     W1,W5
0817E:  MOV     W2,W6
08180:  MOV     W3,W7
08182:  MOV     1B64,W0
08184:  MOV     1B66,W1
08186:  MOV     1B68,W2
08188:  MOV     1B6A,W3
0818A:  CALL    13FC
0818E:  MOV     W0,1B64
08190:  MOV     W1,1B66
08192:  MOV     W2,1B68
08194:  MOV     W3,1B6A
08196:  INC.B   1B63
08198:  GOTO    8124
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
0819C:  MOV     1B62,W4
0819E:  CP.B    W4L,#2
081A0:  BRA     Z,81A8
081A2:  MOV     1B62,W4
081A4:  CP.B    W4L,#1
081A6:  BRA     NZ,81B2
....................       y = -y;  // correct sign 
081A8:  MOV     #1B64,W0
081AA:  MOV     #1B64,W1
081AC:  REPEAT  #7
081AE:  MOV     [W0++],[W1++]
081B0:  BTG.B   1B6B.7
....................  
....................    return (y); 
081B2:  MOV     1B64,W0
081B4:  MOV     1B66,W1
081B6:  MOV     1B68,W2
081B8:  MOV     1B6A,W3
081BA:  MOV     [--W15],W8
081BC:  MOV     [--W15],W7
081BE:  MOV     [--W15],W6
081C0:  MOV     [--W15],W5
081C2:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
081C4:  MOV     W5,[W15++]
081C6:  MOV     W6,[W15++]
081C8:  MOV     W7,[W15++]
081CA:  MOV     W8,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
081CC:  BSET.B  43.0
081CE:  MOV     1B48,W0
081D0:  MOV     1B4A,W1
081D2:  MOV     1B4C,W2
081D4:  MOV     1B4E,W3
081D6:  MOV     #2D18,W4
081D8:  MOV     #5444,W5
081DA:  MOV     #21FB,W6
081DC:  MOV     #3FF9,W7
081DE:  CALL    13FC
081E2:  MOV     W0,W5
081E4:  MOV     W1,W6
081E6:  MOV     W2,W7
081E8:  MOV     W3,W8
081EA:  MOV     W5,1B5A
081EC:  MOV     W6,1B5C
081EE:  MOV     W7,1B5E
081F0:  MOV     W8,1B60
081F2:  CALL    7F0A
081F6:  MOV     [--W15],W8
081F8:  MOV     [--W15],W7
081FA:  MOV     [--W15],W6
081FC:  MOV     [--W15],W5
081FE:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
*
06B0C:  MOV     W5,[W15++]
06B0E:  MOV     W6,[W15++]
06B10:  MOV     W7,[W15++]
06B12:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
06B14:  BCLR.B  1B97.0
....................    y = x; 
06B16:  PUSH    1B8E
06B18:  POP     1B98
06B1A:  PUSH    1B90
06B1C:  POP     1B9A
06B1E:  PUSH    1B92
06B20:  POP     1B9C
06B22:  PUSH    1B94
06B24:  POP     1B9E
....................  
....................    if (x < 0) 
06B26:  MOV     1B8E,W0
06B28:  MOV     1B90,W1
06B2A:  MOV     1B92,W2
06B2C:  MOV     1B94,W3
06B2E:  MOV     #0,W4
06B30:  MOV     #0,W5
06B32:  MOV     #0,W6
06B34:  MOV     #0,W7
06B36:  CALL    15EA
06B3A:  BRA     NC,6B48
....................    { 
....................       s = 1; 
06B3C:  BSET.B  1B97.0
....................       y = -y; 
06B3E:  MOV     #1B98,W0
06B40:  MOV     #1B98,W1
06B42:  REPEAT  #7
06B44:  MOV     [W0++],[W1++]
06B46:  BTG.B   1B9F.7
....................    } 
....................  
....................    if (y > 0.5) 
06B48:  MOV     #0,W0
06B4A:  MOV     #0,W1
06B4C:  MOV     #0,W2
06B4E:  MOV     #3FE0,W3
06B50:  MOV     1B98,W4
06B52:  MOV     1B9A,W5
06B54:  MOV     1B9C,W6
06B56:  MOV     1B9E,W7
06B58:  CALL    15EA
06B5C:  BRA     NC,6BBE
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
06B5E:  BSET.B  43.0
06B60:  MOV     #0,W0
06B62:  MOV     #0,W1
06B64:  MOV     #0,W2
06B66:  MOV     #3FF0,W3
06B68:  MOV     1B98,W4
06B6A:  MOV     1B9A,W5
06B6C:  MOV     1B9C,W6
06B6E:  MOV     1B9E,W7
06B70:  CALL    13FC
06B74:  MOV     W0,W5
06B76:  MOV     W1,W6
06B78:  MOV     W2,W7
06B7A:  MOV     W3,W8
06B7C:  MOV     W5,[W15++]
06B7E:  MOV     W6,[W15++]
06B80:  MOV     W7,[W15++]
06B82:  MOV     W5,W0
06B84:  MOV     W6,W1
06B86:  MOV     W7,W2
06B88:  MOV     W8,W3
06B8A:  MOV     #0,W4
06B8C:  MOV     #0,W5
06B8E:  MOV     #0,W6
06B90:  MOV     #3FE0,W7
06B92:  CALL    BCC
06B96:  MOV     [--W15],W7
06B98:  MOV     [--W15],W6
06B9A:  MOV     [--W15],W5
06B9C:  MOV     W0,W5
06B9E:  MOV     W1,W6
06BA0:  MOV     W2,W7
06BA2:  MOV     W3,W8
06BA4:  MOV     W5,1BC2
06BA6:  MOV     W6,1BC4
06BA8:  MOV     W7,1BC6
06BAA:  MOV     W8,1BC8
06BAC:  CALL    29CC
06BB0:  MOV     W0,1B98
06BB2:  MOV     W1,1B9A
06BB4:  MOV     W2,1B9C
06BB6:  MOV     W3,1B9E
....................       n += 2; 
06BB8:  MOV     1B96,W4
06BBA:  ADD.B   W4L,#2,W0L
06BBC:  MOV.B   W0L,1B96
....................    } 
....................  
....................    y2=y*y; 
06BBE:  MOV     1B98,W0
06BC0:  MOV     1B9A,W1
06BC2:  MOV     1B9C,W2
06BC4:  MOV     1B9E,W3
06BC6:  MOV     1B98,W4
06BC8:  MOV     1B9A,W5
06BCA:  MOV     1B9C,W6
06BCC:  MOV     1B9E,W7
06BCE:  CALL    BCC
06BD2:  MOV     W0,1BB0
06BD4:  MOV     W1,1BB2
06BD6:  MOV     W2,1BB4
06BD8:  MOV     W3,1BB6
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
06BDA:  MOV     14EA,W0
06BDC:  MOV     14EC,W1
06BDE:  MOV     14EE,W2
06BE0:  MOV     14F0,W3
06BE2:  MOV     1BB0,W4
06BE4:  MOV     1BB2,W5
06BE6:  MOV     1BB4,W6
06BE8:  MOV     1BB6,W7
06BEA:  CALL    BCC
06BEE:  MOV     W0,W5
06BF0:  MOV     W1,W6
06BF2:  MOV     W2,W7
06BF4:  MOV     W3,W8
06BF6:  BCLR.B  43.0
06BF8:  MOV     W5,[W15++]
06BFA:  MOV     W6,[W15++]
06BFC:  MOV     W7,[W15++]
06BFE:  MOV     W5,W0
06C00:  MOV     W6,W1
06C02:  MOV     W7,W2
06C04:  MOV     W8,W3
06C06:  MOV     14E2,W4
06C08:  MOV     14E4,W5
06C0A:  MOV     14E6,W6
06C0C:  MOV     14E8,W7
06C0E:  CALL    13FC
06C12:  MOV     [--W15],W7
06C14:  MOV     [--W15],W6
06C16:  MOV     [--W15],W5
06C18:  MOV     W0,1BA0
06C1A:  MOV     W1,1BA2
06C1C:  MOV     W2,1BA4
06C1E:  MOV     W3,1BA6
....................    res = res*y2 + pas_64[2]; 
06C20:  MOV     1BA0,W0
06C22:  MOV     1BA2,W1
06C24:  MOV     1BA4,W2
06C26:  MOV     1BA6,W3
06C28:  MOV     1BB0,W4
06C2A:  MOV     1BB2,W5
06C2C:  MOV     1BB4,W6
06C2E:  MOV     1BB6,W7
06C30:  CALL    BCC
06C34:  MOV     W0,W5
06C36:  MOV     W1,W6
06C38:  MOV     W2,W7
06C3A:  MOV     W3,W8
06C3C:  BCLR.B  43.0
06C3E:  MOV     W5,[W15++]
06C40:  MOV     W6,[W15++]
06C42:  MOV     W7,[W15++]
06C44:  MOV     W5,W0
06C46:  MOV     W6,W1
06C48:  MOV     W7,W2
06C4A:  MOV     W8,W3
06C4C:  MOV     14DA,W4
06C4E:  MOV     14DC,W5
06C50:  MOV     14DE,W6
06C52:  MOV     14E0,W7
06C54:  CALL    13FC
06C58:  MOV     [--W15],W7
06C5A:  MOV     [--W15],W6
06C5C:  MOV     [--W15],W5
06C5E:  MOV     W0,1BA0
06C60:  MOV     W1,1BA2
06C62:  MOV     W2,1BA4
06C64:  MOV     W3,1BA6
....................    res = res*y2 + pas_64[1]; 
06C66:  MOV     1BA0,W0
06C68:  MOV     1BA2,W1
06C6A:  MOV     1BA4,W2
06C6C:  MOV     1BA6,W3
06C6E:  MOV     1BB0,W4
06C70:  MOV     1BB2,W5
06C72:  MOV     1BB4,W6
06C74:  MOV     1BB6,W7
06C76:  CALL    BCC
06C7A:  MOV     W0,W5
06C7C:  MOV     W1,W6
06C7E:  MOV     W2,W7
06C80:  MOV     W3,W8
06C82:  BCLR.B  43.0
06C84:  MOV     W5,[W15++]
06C86:  MOV     W6,[W15++]
06C88:  MOV     W7,[W15++]
06C8A:  MOV     W5,W0
06C8C:  MOV     W6,W1
06C8E:  MOV     W7,W2
06C90:  MOV     W8,W3
06C92:  MOV     14D2,W4
06C94:  MOV     14D4,W5
06C96:  MOV     14D6,W6
06C98:  MOV     14D8,W7
06C9A:  CALL    13FC
06C9E:  MOV     [--W15],W7
06CA0:  MOV     [--W15],W6
06CA2:  MOV     [--W15],W5
06CA4:  MOV     W0,1BA0
06CA6:  MOV     W1,1BA2
06CA8:  MOV     W2,1BA4
06CAA:  MOV     W3,1BA6
....................    res = res*y2 + pas_64[0]; 
06CAC:  MOV     1BA0,W0
06CAE:  MOV     1BA2,W1
06CB0:  MOV     1BA4,W2
06CB2:  MOV     1BA6,W3
06CB4:  MOV     1BB0,W4
06CB6:  MOV     1BB2,W5
06CB8:  MOV     1BB4,W6
06CBA:  MOV     1BB6,W7
06CBC:  CALL    BCC
06CC0:  MOV     W0,W5
06CC2:  MOV     W1,W6
06CC4:  MOV     W2,W7
06CC6:  MOV     W3,W8
06CC8:  BCLR.B  43.0
06CCA:  MOV     W5,[W15++]
06CCC:  MOV     W6,[W15++]
06CCE:  MOV     W7,[W15++]
06CD0:  MOV     W5,W0
06CD2:  MOV     W6,W1
06CD4:  MOV     W7,W2
06CD6:  MOV     W8,W3
06CD8:  MOV     14CA,W4
06CDA:  MOV     14CC,W5
06CDC:  MOV     14CE,W6
06CDE:  MOV     14D0,W7
06CE0:  CALL    13FC
06CE4:  MOV     [--W15],W7
06CE6:  MOV     [--W15],W6
06CE8:  MOV     [--W15],W5
06CEA:  MOV     W0,1BA0
06CEC:  MOV     W1,1BA2
06CEE:  MOV     W2,1BA4
06CF0:  MOV     W3,1BA6
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
06CF2:  MOV     1512,W0
06CF4:  MOV     1514,W1
06CF6:  MOV     1516,W2
06CF8:  MOV     1518,W3
06CFA:  MOV     1BB0,W4
06CFC:  MOV     1BB2,W5
06CFE:  MOV     1BB4,W6
06D00:  MOV     1BB6,W7
06D02:  CALL    BCC
06D06:  MOV     W0,W5
06D08:  MOV     W1,W6
06D0A:  MOV     W2,W7
06D0C:  MOV     W3,W8
06D0E:  BCLR.B  43.0
06D10:  MOV     W5,[W15++]
06D12:  MOV     W6,[W15++]
06D14:  MOV     W7,[W15++]
06D16:  MOV     W5,W0
06D18:  MOV     W6,W1
06D1A:  MOV     W7,W2
06D1C:  MOV     W8,W3
06D1E:  MOV     150A,W4
06D20:  MOV     150C,W5
06D22:  MOV     150E,W6
06D24:  MOV     1510,W7
06D26:  CALL    13FC
06D2A:  MOV     [--W15],W7
06D2C:  MOV     [--W15],W6
06D2E:  MOV     [--W15],W5
06D30:  MOV     W0,1BA8
06D32:  MOV     W1,1BAA
06D34:  MOV     W2,1BAC
06D36:  MOV     W3,1BAE
....................    r = r*y2 + qas_64[2]; 
06D38:  MOV     1BA8,W0
06D3A:  MOV     1BAA,W1
06D3C:  MOV     1BAC,W2
06D3E:  MOV     1BAE,W3
06D40:  MOV     1BB0,W4
06D42:  MOV     1BB2,W5
06D44:  MOV     1BB4,W6
06D46:  MOV     1BB6,W7
06D48:  CALL    BCC
06D4C:  MOV     W0,W5
06D4E:  MOV     W1,W6
06D50:  MOV     W2,W7
06D52:  MOV     W3,W8
06D54:  BCLR.B  43.0
06D56:  MOV     W5,[W15++]
06D58:  MOV     W6,[W15++]
06D5A:  MOV     W7,[W15++]
06D5C:  MOV     W5,W0
06D5E:  MOV     W6,W1
06D60:  MOV     W7,W2
06D62:  MOV     W8,W3
06D64:  MOV     1502,W4
06D66:  MOV     1504,W5
06D68:  MOV     1506,W6
06D6A:  MOV     1508,W7
06D6C:  CALL    13FC
06D70:  MOV     [--W15],W7
06D72:  MOV     [--W15],W6
06D74:  MOV     [--W15],W5
06D76:  MOV     W0,1BA8
06D78:  MOV     W1,1BAA
06D7A:  MOV     W2,1BAC
06D7C:  MOV     W3,1BAE
....................    r = r*y2 + qas_64[1]; 
06D7E:  MOV     1BA8,W0
06D80:  MOV     1BAA,W1
06D82:  MOV     1BAC,W2
06D84:  MOV     1BAE,W3
06D86:  MOV     1BB0,W4
06D88:  MOV     1BB2,W5
06D8A:  MOV     1BB4,W6
06D8C:  MOV     1BB6,W7
06D8E:  CALL    BCC
06D92:  MOV     W0,W5
06D94:  MOV     W1,W6
06D96:  MOV     W2,W7
06D98:  MOV     W3,W8
06D9A:  BCLR.B  43.0
06D9C:  MOV     W5,[W15++]
06D9E:  MOV     W6,[W15++]
06DA0:  MOV     W7,[W15++]
06DA2:  MOV     W5,W0
06DA4:  MOV     W6,W1
06DA6:  MOV     W7,W2
06DA8:  MOV     W8,W3
06DAA:  MOV     14FA,W4
06DAC:  MOV     14FC,W5
06DAE:  MOV     14FE,W6
06DB0:  MOV     1500,W7
06DB2:  CALL    13FC
06DB6:  MOV     [--W15],W7
06DB8:  MOV     [--W15],W6
06DBA:  MOV     [--W15],W5
06DBC:  MOV     W0,1BA8
06DBE:  MOV     W1,1BAA
06DC0:  MOV     W2,1BAC
06DC2:  MOV     W3,1BAE
....................    r = r*y2 + qas_64[0]; 
06DC4:  MOV     1BA8,W0
06DC6:  MOV     1BAA,W1
06DC8:  MOV     1BAC,W2
06DCA:  MOV     1BAE,W3
06DCC:  MOV     1BB0,W4
06DCE:  MOV     1BB2,W5
06DD0:  MOV     1BB4,W6
06DD2:  MOV     1BB6,W7
06DD4:  CALL    BCC
06DD8:  MOV     W0,W5
06DDA:  MOV     W1,W6
06DDC:  MOV     W2,W7
06DDE:  MOV     W3,W8
06DE0:  BCLR.B  43.0
06DE2:  MOV     W5,[W15++]
06DE4:  MOV     W6,[W15++]
06DE6:  MOV     W7,[W15++]
06DE8:  MOV     W5,W0
06DEA:  MOV     W6,W1
06DEC:  MOV     W7,W2
06DEE:  MOV     W8,W3
06DF0:  MOV     14F2,W4
06DF2:  MOV     14F4,W5
06DF4:  MOV     14F6,W6
06DF6:  MOV     14F8,W7
06DF8:  CALL    13FC
06DFC:  MOV     [--W15],W7
06DFE:  MOV     [--W15],W6
06E00:  MOV     [--W15],W5
06E02:  MOV     W0,1BA8
06E04:  MOV     W1,1BAA
06E06:  MOV     W2,1BAC
06E08:  MOV     W3,1BAE
....................    r = r*y2 + 1.0; 
06E0A:  MOV     1BA8,W0
06E0C:  MOV     1BAA,W1
06E0E:  MOV     1BAC,W2
06E10:  MOV     1BAE,W3
06E12:  MOV     1BB0,W4
06E14:  MOV     1BB2,W5
06E16:  MOV     1BB4,W6
06E18:  MOV     1BB6,W7
06E1A:  CALL    BCC
06E1E:  MOV     W0,W5
06E20:  MOV     W1,W6
06E22:  MOV     W2,W7
06E24:  MOV     W3,W8
06E26:  BCLR.B  43.0
06E28:  MOV     W5,[W15++]
06E2A:  MOV     W6,[W15++]
06E2C:  MOV     W7,[W15++]
06E2E:  MOV     W5,W0
06E30:  MOV     W6,W1
06E32:  MOV     W7,W2
06E34:  MOV     W8,W3
06E36:  MOV     #0,W4
06E38:  MOV     #0,W5
06E3A:  MOV     #0,W6
06E3C:  MOV     #3FF0,W7
06E3E:  CALL    13FC
06E42:  MOV     [--W15],W7
06E44:  MOV     [--W15],W6
06E46:  MOV     [--W15],W5
06E48:  MOV     W0,1BA8
06E4A:  MOV     W1,1BAA
06E4C:  MOV     W2,1BAC
06E4E:  MOV     W3,1BAE
....................  
....................    res = y*res/r; 
06E50:  MOV     1B98,W0
06E52:  MOV     1B9A,W1
06E54:  MOV     1B9C,W2
06E56:  MOV     1B9E,W3
06E58:  MOV     1BA0,W4
06E5A:  MOV     1BA2,W5
06E5C:  MOV     1BA4,W6
06E5E:  MOV     1BA6,W7
06E60:  CALL    BCC
06E64:  MOV     W0,W5
06E66:  MOV     W1,W6
06E68:  MOV     W2,W7
06E6A:  MOV     W3,W8
06E6C:  MOV     W5,[W15++]
06E6E:  MOV     W6,[W15++]
06E70:  MOV     W7,[W15++]
06E72:  MOV     W5,W0
06E74:  MOV     W6,W1
06E76:  MOV     W7,W2
06E78:  MOV     W8,W3
06E7A:  MOV     1BA8,W4
06E7C:  MOV     1BAA,W5
06E7E:  MOV     1BAC,W6
06E80:  MOV     1BAE,W7
06E82:  CALL    CDC
06E86:  MOV     [--W15],W7
06E88:  MOV     [--W15],W6
06E8A:  MOV     [--W15],W5
06E8C:  MOV     W0,1BA0
06E8E:  MOV     W1,1BA2
06E90:  MOV     W2,1BA4
06E92:  MOV     W3,1BA6
....................  
....................    if (n & 2)     // |x| > 0.5 
06E94:  MOV.B   1B96,W0L
06E96:  CLR.B   1
06E98:  AND     W0,#2,W0
06E9A:  CP0     W0
06E9C:  BRA     Z,6ED0
....................       res = PI_DIV_BY_TWO - 2.0*res; 
06E9E:  MOV     #0,W0
06EA0:  MOV     #0,W1
06EA2:  MOV     #0,W2
06EA4:  MOV     #4000,W3
06EA6:  MOV     1BA0,W4
06EA8:  MOV     1BA2,W5
06EAA:  MOV     1BA4,W6
06EAC:  MOV     1BA6,W7
06EAE:  CALL    BCC
06EB2:  BSET.B  43.0
06EB4:  MOV     W0,W4
06EB6:  MOV     W1,W5
06EB8:  MOV     W2,W6
06EBA:  MOV     W3,W7
06EBC:  MOV     #2D18,W0
06EBE:  MOV     #5444,W1
06EC0:  MOV     #21FB,W2
06EC2:  MOV     #3FF9,W3
06EC4:  CALL    13FC
06EC8:  MOV     W0,1BA0
06ECA:  MOV     W1,1BA2
06ECC:  MOV     W2,1BA4
06ECE:  MOV     W3,1BA6
....................    if (s) 
06ED0:  BTSS.B  1B97.0
06ED2:  BRA     6EDE
....................       res = -res; 
06ED4:  MOV     #1BA0,W0
06ED6:  MOV     #1BA0,W1
06ED8:  REPEAT  #7
06EDA:  MOV     [W0++],[W1++]
06EDC:  BTG.B   1BA7.7
....................    if (n & 1)           // take arccos 
06EDE:  MOV.B   1B96,W0L
06EE0:  CLR.B   1
06EE2:  AND     W0,#1,W0
06EE4:  CP0     W0
06EE6:  BRA     Z,6F06
....................       res = PI_DIV_BY_TWO - res; 
06EE8:  BSET.B  43.0
06EEA:  MOV     #2D18,W0
06EEC:  MOV     #5444,W1
06EEE:  MOV     #21FB,W2
06EF0:  MOV     #3FF9,W3
06EF2:  MOV     1BA0,W4
06EF4:  MOV     1BA2,W5
06EF6:  MOV     1BA4,W6
06EF8:  MOV     1BA6,W7
06EFA:  CALL    13FC
06EFE:  MOV     W0,1BA0
06F00:  MOV     W1,1BA2
06F02:  MOV     W2,1BA4
06F04:  MOV     W3,1BA6
....................  
....................    return(res); 
06F06:  MOV     1BA0,W0
06F08:  MOV     1BA2,W1
06F0A:  MOV     1BA4,W2
06F0C:  MOV     1BA6,W3
06F0E:  MOV     [--W15],W8
06F10:  MOV     [--W15],W7
06F12:  MOV     [--W15],W6
06F14:  MOV     [--W15],W5
06F16:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
06F18:  CLR.B   1B96
06F1A:  PUSH    1B76
06F1C:  POP     1B8E
06F1E:  PUSH    1B78
06F20:  POP     1B90
06F22:  PUSH    1B7A
06F24:  POP     1B92
06F26:  PUSH    1B7C
06F28:  POP     1B94
06F2A:  CALL    6B0C
06F2E:  MOV     W0,1B7E
06F30:  MOV     W1,1B80
06F32:  MOV     W2,1B82
06F34:  MOV     W3,1B84
....................    return(r); 
06F36:  MOV     1B7E,W0
06F38:  MOV     1B80,W1
06F3A:  MOV     1B82,W2
06F3C:  MOV     1B84,W3
06F3E:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
06F40:  MOV.B   #1,W0L
06F42:  MOV.B   W0L,1B96
06F44:  PUSH    1B76
06F46:  POP     1B8E
06F48:  PUSH    1B78
06F4A:  POP     1B90
06F4C:  PUSH    1B7A
06F4E:  POP     1B92
06F50:  PUSH    1B7C
06F52:  POP     1B94
06F54:  CALL    6B0C
06F58:  MOV     W0,1B7E
06F5A:  MOV     W1,1B80
06F5C:  MOV     W2,1B82
06F5E:  MOV     W3,1B84
....................    return(r); 
06F60:  MOV     1B7E,W0
06F62:  MOV     1B80,W1
06F64:  MOV     1B82,W2
06F66:  MOV     1B84,W3
06F68:  RETURN  
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
0066A:  MOV     W5,[W15++]
0066C:  MOV     W6,[W15++]
0066E:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
00670:  CLR     1C8E
....................    sign = 0; 
00672:  CLR     1C8A
....................    base = 10; 
00674:  MOV     #A,W4
00676:  MOV     W4,1C8C
....................    result = 0; 
00678:  CLR     1C86
0067A:  CLR     1C88
....................  
....................    if (!s) 
0067C:  CP0     1C82
0067E:  BRA     NZ,686
....................       return 0; 
00680:  MOV     #0,W0
00682:  MOV     #0,W1
00684:  BRA     856
....................    c = s[index++]; 
00686:  MOV     1C8E,W0
00688:  INC     1C8E
0068A:  MOV     W0,W5
0068C:  MOV     W5,W0
0068E:  ADD     1C82,W0
00690:  MOV     1C84,W4
00692:  MOV.B   [W0+#0],W4L
00694:  MOV     W4,1C84
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00696:  MOV     1C84,W4
00698:  XOR.B   #2D,W4L
0069A:  BRA     NZ,6B4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0069C:  MOV     #1,W4
0069E:  MOV     W4,1C8A
....................       c = s[index++]; 
006A0:  MOV     1C8E,W0
006A2:  INC     1C8E
006A4:  MOV     W0,W5
006A6:  MOV     W5,W0
006A8:  ADD     1C82,W0
006AA:  MOV     1C84,W4
006AC:  MOV.B   [W0+#0],W4L
006AE:  MOV     W4,1C84
....................    } 
006B0:  GOTO    6CA
....................    else if (c == '+') 
006B4:  MOV     1C84,W4
006B6:  XOR.B   #2B,W4L
006B8:  BRA     NZ,6CA
....................    { 
....................       c = s[index++]; 
006BA:  MOV     1C8E,W0
006BC:  INC     1C8E
006BE:  MOV     W0,W5
006C0:  MOV     W5,W0
006C2:  ADD     1C82,W0
006C4:  MOV     1C84,W4
006C6:  MOV.B   [W0+#0],W4L
006C8:  MOV     W4,1C84
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
006CA:  MOV     1C84,W4
006CC:  MOV     #30,W3
006CE:  CP.B    W3L,W4L
006D0:  BRA     GT,836
006D2:  MOV     1C84,W4
006D4:  MOV     #39,W3
006D6:  CP.B    W3L,W4L
006D8:  BRA     LT,836
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
006DA:  MOV     1C84,W4
006DC:  XOR.B   #30,W4L
006DE:  BRA     NZ,70A
006E0:  MOV     1C8E,W0
006E2:  ADD     1C82,W0
006E4:  MOV.B   [W0],W4L
006E6:  XOR.B   #78,W4L
006E8:  BRA     Z,6F4
006EA:  MOV     1C8E,W0
006EC:  ADD     1C82,W0
006EE:  MOV.B   [W0],W4L
006F0:  XOR.B   #58,W4L
006F2:  BRA     NZ,70A
....................       { 
....................          base = 16; 
006F4:  MOV     #10,W4
006F6:  MOV     W4,1C8C
....................          index++; 
006F8:  INC     1C8E
....................          c = s[index++]; 
006FA:  MOV     1C8E,W0
006FC:  INC     1C8E
006FE:  MOV     W0,W5
00700:  MOV     W5,W0
00702:  ADD     1C82,W0
00704:  MOV     1C84,W4
00706:  MOV.B   [W0+#0],W4L
00708:  MOV     W4,1C84
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0070A:  MOV     1C8C,W4
0070C:  CP      W4,#A
0070E:  BRA     NZ,760
....................       { 
....................          while (c >= '0' && c <= '9') 
00710:  MOV     1C84,W4
00712:  MOV     #30,W3
00714:  CP.B    W3L,W4L
00716:  BRA     GT,75C
00718:  MOV     1C84,W4
0071A:  MOV     #39,W3
0071C:  CP.B    W3L,W4L
0071E:  BRA     LT,75C
....................          { 
....................             result = 10*result + (c - '0'); 
00720:  MOV     #A,W0
00722:  MOV     #0,W1
00724:  MOV     1C86,W2
00726:  MOV     1C88,W3
00728:  CALL    628
0072C:  MOV     W0,W5
0072E:  MOV     W1,W6
00730:  MOV     1C84,W4
00732:  SUB.B   #30,W4L
00734:  MOV.B   W4L,W0L
00736:  MOV.B   W0L,0
00738:  SE      W0,W0
0073A:  CLR     W1
0073C:  BTSC    W0.F
0073E:  SETM    W1
00740:  ADD     W0,W5,W0
00742:  MOV     W0,1C86
00744:  ADDC    W1,W6,W0
00746:  MOV     W0,1C88
....................             c = s[index++]; 
00748:  MOV     1C8E,W0
0074A:  INC     1C8E
0074C:  MOV     W0,W5
0074E:  MOV     W5,W0
00750:  ADD     1C82,W0
00752:  MOV     1C84,W4
00754:  MOV.B   [W0+#0],W4L
00756:  MOV     W4,1C84
00758:  GOTO    710
....................          } 
....................       } 
0075C:  GOTO    836
....................       else if (base == 16)    // The number is a hexa number 
00760:  MOV     1C8C,W4
00762:  CP      W4,#10
00764:  BRA     NZ,836
....................       { 
....................          c = toupper(c); 
00766:  MOV     1C84,W4
00768:  MOV     #61,W3
0076A:  CP.B    W3L,W4L
0076C:  BRA     GTU,77C
0076E:  MOV     1C84,W4
00770:  MOV     #7A,W3
00772:  CP.B    W3L,W4L
00774:  BRA     NC,77C
00776:  MOV.B   1C84,W0L
00778:  AND.B   #DF,W0L
0077A:  BRA     77E
0077C:  MOV.B   1C84,W0L
0077E:  MOV.B   W0L,1C84
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
00780:  MOV     1C84,W4
00782:  MOV     #30,W3
00784:  CP.B    W3L,W4L
00786:  BRA     GT,792
00788:  MOV     1C84,W4
0078A:  MOV     #39,W3
0078C:  CP.B    W3L,W4L
0078E:  BRA     LT,792
00790:  BRA     7A2
00792:  MOV     1C84,W4
00794:  MOV     #41,W3
00796:  CP.B    W3L,W4L
00798:  BRA     GT,836
0079A:  MOV     1C84,W4
0079C:  MOV     #46,W3
0079E:  CP.B    W3L,W4L
007A0:  BRA     LT,836
....................          { 
....................             if (c >= '0' && c <= '9') 
007A2:  MOV     1C84,W4
007A4:  MOV     #30,W3
007A6:  CP.B    W3L,W4L
007A8:  BRA     GT,7E0
007AA:  MOV     1C84,W4
007AC:  MOV     #39,W3
007AE:  CP.B    W3L,W4L
007B0:  BRA     LT,7E0
....................                result = (result << 4) + (c - '0'); 
007B2:  MOV     #4,W4
007B4:  MOV     1C86,W5
007B6:  MOV     1C88,W6
007B8:  INC     W4,W4
007BA:  DEC     W4,W4
007BC:  BRA     Z,7C4
007BE:  SL      W5,W5
007C0:  RLC     W6,W6
007C2:  BRA     7BA
007C4:  MOV     1C84,W4
007C6:  SUB.B   #30,W4L
007C8:  MOV.B   W4L,W0L
007CA:  MOV.B   W0L,0
007CC:  SE      W0,W0
007CE:  CLR     W1
007D0:  BTSC    W0.F
007D2:  SETM    W1
007D4:  ADD     W0,W5,W0
007D6:  MOV     W0,1C86
007D8:  ADDC    W1,W6,W0
007DA:  MOV     W0,1C88
007DC:  GOTO    808
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
007E0:  MOV     #4,W4
007E2:  MOV     1C86,W5
007E4:  MOV     1C88,W6
007E6:  INC     W4,W4
007E8:  DEC     W4,W4
007EA:  BRA     Z,7F2
007EC:  SL      W5,W5
007EE:  RLC     W6,W6
007F0:  BRA     7E8
007F2:  MOV     1C84,W4
007F4:  SUB.B   #41,W4L
007F6:  MOV.B   W4L,W0L
007F8:  MOV.B   W0L,0
007FA:  ZE      W0,W0
007FC:  ADD     W0,#A,W0
007FE:  ADD     W0,W5,W0
00800:  MOV     W0,1C86
00802:  MOV     #0,W4
00804:  ADDC    W4,W6,W0
00806:  MOV     W0,1C88
....................  
....................             c = s[index++];c = toupper(c); 
00808:  MOV     1C8E,W0
0080A:  INC     1C8E
0080C:  MOV     W0,W5
0080E:  MOV     W5,W0
00810:  ADD     1C82,W0
00812:  MOV     1C84,W4
00814:  MOV.B   [W0+#0],W4L
00816:  MOV     W4,1C84
00818:  MOV     1C84,W4
0081A:  MOV     #61,W3
0081C:  CP.B    W3L,W4L
0081E:  BRA     GTU,82E
00820:  MOV     1C84,W4
00822:  MOV     #7A,W3
00824:  CP.B    W3L,W4L
00826:  BRA     NC,82E
00828:  MOV.B   1C84,W0L
0082A:  AND.B   #DF,W0L
0082C:  BRA     830
0082E:  MOV.B   1C84,W0L
00830:  MOV.B   W0L,1C84
00832:  GOTO    780
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
00836:  MOV     1C8C,W4
00838:  CP      W4,#A
0083A:  BRA     NZ,852
0083C:  MOV     1C8A,W4
0083E:  CP      W4,#1
00840:  BRA     NZ,852
....................       result = -result; 
00842:  MOV     #0,W4
00844:  MOV     1C86,W3
00846:  SUB     W4,W3,W0
00848:  MOV     W0,1C86
0084A:  MOV     #0,W4
0084C:  MOV     1C88,W3
0084E:  SUBB    W4,W3,W0
00850:  MOV     W0,1C88
....................  
....................    return(result); 
00852:  MOV     1C86,W0
00854:  MOV     1C88,W1
00856:  MOV     [--W15],W7
00858:  MOV     [--W15],W6
0085A:  MOV     [--W15],W5
0085C:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "servomoteur/servomoteur.h" 
.................... #ifndef _SERVOMOTEUR_H 
.................... #define _SERVOMOTEUR_H 
....................  
.................... // Nombre de servomoteurs (0 Ã  MAXSERVO-1) 
.................... #DEFINE MAXSERVO 1 
.................... // Valeurs min et max de l'impulsion en [100us] pour la protection des servomoteurs 
.................... #DEFINE MINSERVOPOSITION 9 
.................... #DEFINE MAXSERVOPOSITION 20 
.................... // Normalement 9 et 21 pour 900us et 2.1ms 
....................  
.................... // Structure pour la gestion des servomoteurs 
.................... struct T_Servo{ 
.................... 	int Position; 
.................... 	int Count; 
.................... 	int OpenValue; 
.................... 	int CloseValue; 
.................... }; 
....................  
.................... struct T_Servo ServoTab[MAXSERVO]; 
....................  
.................... void MoveServo(int number, int position); 
.................... void SetServo(int number, int state); 
.................... void OpenServo(int number); 
.................... void CloseServo(int number); 
.................... void CheckServo(); 
.................... void __Init_Servos(); 
....................  
.................... #include "servomoteur/servomoteur.c" 
.................... ///============================================================================================ 
.................... ///	void MoveServo(int number, int position) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de modifier la valeur de consigne (l'angle) d'un servomoteur 
.................... ///	Position défini la longueur de l'impulsion en [100us] 
.................... ///============================================================================================ 
.................... void MoveServo(int number, int position) 
*
08BF4:  MOV     W5,[W15++]
08BF6:  MOV     W6,[W15++]
.................... { 
.................... 	// Protection pour ne pas bloquer le servo en butée 
.................... 	if(position < MINSERVOPOSITION) 
08BF8:  MOV     1B2C,W4
08BFA:  CP      W4,#9
08BFC:  BRA     GE,8C02
.................... 		position = MINSERVOPOSITION; 
08BFE:  MOV     #9,W4
08C00:  MOV     W4,1B2C
.................... 	 
.................... 	if (position > MAXSERVOPOSITION) 
08C02:  MOV     1B2C,W4
08C04:  CP      W4,#14
08C06:  BRA     LE,8C0C
.................... 		position = MAXSERVOPOSITION; 
08C08:  MOV     #14,W4
08C0A:  MOV     W4,1B2C
.................... 	// Définition de position du servomoteur 
.................... 	ServoTab[number].Position = position; 
08C0C:  MOV     1B2A,W4
08C0E:  MUL.UU  W4,#8,W0
08C10:  MOV     W0,W5
08C12:  MOV     #1580,W4
08C14:  ADD     W5,W4,W6
08C16:  MOV     1B2C,W4
08C18:  MOV     W4,[W6+#0]
.................... 	 
.................... 	enable_interrupts(INT_TIMER2); 
08C1A:  BSET.B  8C.6
.................... 	delay_ms(500); 
08C1C:  MOV     #1F4,W0
08C1E:  CALL    E90
.................... 	disable_interrupts(INT_TIMER2); 
08C22:  BCLR.B  8C.6
08C24:  MOV     [--W15],W6
08C26:  MOV     [--W15],W5
08C28:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void SetServo(int number, int state) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de définir la sortie propre à chaque servomoteur 
.................... ///	output_bit() demande l'adresse du bit utilisé (par exemple avec un "#define PIN_A3 5651") 
.................... ///============================================================================================ 
.................... void SetServo(int number, int state) 
.................... { 
.................... 	switch (number) 
*
004A4:  MOV     1C96,W0
004A6:  XOR     #0,W0
004A8:  BRA     Z,4AC
004AA:  BRA     4BC
.................... 	{ 
.................... 		case 0:		// Pour le servomoteur droit 
.................... 			output_bit(PIN_D4,state);	 
004AC:  CP0     1C98
004AE:  BRA     NZ,4B4
004B0:  BCLR.B  2D6.4
004B2:  BRA     4B6
004B4:  BSET.B  2D6.4
004B6:  BCLR.B  2D2.4
.................... 			break; 
004B8:  GOTO    4C0
.................... 		default : 
.................... 			break; 
004BC:  GOTO    4C0
.................... 	} 
004C0:  RETURN  
.................... 	 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void CheckServo() 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Gère la commande des servomoteurs 
.................... ///	Doit être appelé toutes les 100us 
.................... ///============================================================================================ 
.................... void CheckServo() 
004C2:  MOV     W5,[W15++]
004C4:  MOV     W6,[W15++]
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
004C6:  CLR     1C92
004C8:  MOV     1C92,W4
004CA:  CP      W4,#1
004CC:  BRA     GE,552
.................... 	{ 
.................... 		if(ServoTab[i].Count<ServoTab[i].Position) 
004CE:  MOV     1C92,W4
004D0:  MUL.UU  W4,#8,W0
004D2:  MOV     W0,W5
004D4:  ADD     W5,#2,W0
004D6:  MOV     #1580,W4
004D8:  ADD     W0,W4,W0
004DA:  MOV     [W0],W5
004DC:  MOV     1C92,W4
004DE:  MUL.UU  W4,#8,W6
004E0:  MOV     #1580,W4
004E2:  ADD     W6,W4,W0
004E4:  MOV     W0,W4
004E6:  MOV     [W4],W0
004E8:  CP      W5,W0
004EA:  BRA     GE,50A
.................... 		{ 
.................... 			// Ton 
.................... 			SetServo(i,1); 
004EC:  PUSH    1C92
004EE:  POP     1C96
004F0:  MOV     #1,W4
004F2:  MOV     W4,1C98
004F4:  CALL    4A4
.................... 			ServoTab[i].Count++; 
004F8:  MOV     1C92,W4
004FA:  MUL.UU  W4,#8,W0
004FC:  MOV     W0,W5
004FE:  ADD     W5,#2,W0
00500:  MOV     #1580,W4
00502:  ADD     W0,W4,W5
00504:  INC     [W5],[W5]
.................... 		}  
00506:  GOTO    54C
.................... 		else  
.................... 		{ 
.................... 			if(ServoTab[i].Count<197)  
0050A:  MOV     1C92,W4
0050C:  MUL.UU  W4,#8,W0
0050E:  MOV     W0,W5
00510:  ADD     W5,#2,W0
00512:  MOV     #1580,W4
00514:  ADD     W0,W4,W0
00516:  MOV     [W0],W5
00518:  MOV     #C5,W4
0051A:  CP      W4,W5
0051C:  BRA     LE,53A
.................... 			{ 
.................... 				// Toff 
.................... 				SetServo(i,0); 
0051E:  PUSH    1C92
00520:  POP     1C96
00522:  CLR     1C98
00524:  CALL    4A4
.................... 				ServoTab[i].Count++; 
00528:  MOV     1C92,W4
0052A:  MUL.UU  W4,#8,W0
0052C:  MOV     W0,W5
0052E:  ADD     W5,#2,W0
00530:  MOV     #1580,W4
00532:  ADD     W0,W4,W5
00534:  INC     [W5],[W5]
.................... 			}  
00536:  GOTO    54C
.................... 			else  
.................... 			{ 
.................... 				// Fin de la période 
.................... 				ServoTab[i].Count = 0; 
0053A:  MOV     1C92,W4
0053C:  MUL.UU  W4,#8,W0
0053E:  MOV     W0,W5
00540:  ADD     W5,#2,W0
00542:  MOV     #1580,W4
00544:  ADD     W0,W4,W5
00546:  CLR.B   [W5]
00548:  MOV.B   #0,W0L
0054A:  MOV.B   W0L,[W5+#1]
.................... 			} 
.................... 		} 
0054C:  INC     1C92
0054E:  GOTO    4C8
.................... 	} 
00552:  MOV     [--W15],W6
00554:  MOV     [--W15],W5
00556:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void OpenServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position ouverte définie avec ServoTab[x].OpenValue 
.................... ///============================================================================================ 
.................... void OpenServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].OpenValue); 
.................... } 
.................... ///============================================================================================ 
.................... /// void CloseServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position fermée définie avec ServoTab[x].CloseValue 
.................... ///============================================================================================ 
.................... void CloseServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].CloseValue); 
.................... } 
....................  
.................... ///	Initialisation de la structure des servomoteurs: 
.................... void __Init_Servos(void) 
.................... { 
.................... 	unsigned int8 i=0; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
.................... 	{ 
.................... 		ServoTab[i].Position = 0; 
.................... 		ServoTab[i].Count = 0; 
.................... 	} 
....................  
.................... 	///	Configuration du TIMER2 pour 100us: 
.................... ///-------------------------------------------------------------------- 
.................... 	setup_timer2(TMR_INTERNAL, 1973); 
.................... 	// 1/((80MHz)/4)*1*2000 = 100us 
.................... 	enable_interrupts(INT_TIMER2); 
.................... } 
....................  
.................... ///	Interruption TIMER2 
.................... ///-------------------------------------------------------------------- 
.................... 	#INT_TIMER2 HIGH 
.................... 	void timer2_isr() 
00558:  PUSH    42
0055A:  PUSH    36
0055C:  PUSH    32
0055E:  MOV     W0,[W15++]
00560:  MOV     #2,W0
00562:  REPEAT  #C
00564:  MOV     [W0++],[W15++]
.................... 	{ 
.................... 		set_timer2(0); 
00566:  CLR     106
.................... 		CheckServo(); 
00568:  CALL    4C2
.................... 	} 
....................  
....................  
.................... #endif 
....................  
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS - PRINCIPE 
.................... ///==================================================================== 
.................... /// 
.................... ///	Le but est de gÃ©nÃ©rer des sorties pour la commandes de servomoteurs. 
.................... ///	Les sorties sont mises Ã  jour chaque 100us grÃ¢ce au TIMER2. 
.................... ///	Les impulsions de commande sont envoyÃ©es en continu. 
.................... /// 
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS  - UTILISATION 
.................... ///==================================================================== 
.................... /// 
.................... ///	MAXSERVO permet de dÃ©finir le nombre de servomoteurs utilisÃ©s 
.................... ///	MINSERVOPOSITION et MAXSERVOPOSITION fixent les valeurs min et max 
.................... ///	des impulsions Ã  gÃ©nÃ©rer pour la commande des servomoteurs, en 
.................... ///	gÃ©nÃ©ral on se limite Ã  900us (9) et 2.1ms (21) 
.................... /// 
.................... ///	CheckServo(): gÃ¨re la commande des servomoteurs, Ã  appeler toutes 
.................... ///	toutes les 100us 
.................... /// 
.................... ///	MoveServo(number, position): permet de modifier la valeur de consigne 
.................... ///	d'un servomoteur 
.................... /// 
.................... ///	SetServo(numer, state): utilisÃ© par CheckServo(), le switch case 
.................... ///	permet de dÃ©finir les sorties propres Ã  chaque servomoteurs. 
....................  
.................... #include "LCD/___LCD.h" 
.................... /* 
.................... * \file ___LCD.h 
.................... * \brief Gère l'afficheur LCD I2C (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_H 
0056C:  BCLR.B  84.6
0056E:  MOV     #1A,W0
00570:  REPEAT  #C
00572:  MOV     [--W15],[W0--]
00574:  MOV     [--W15],W0
00576:  POP     32
00578:  POP     36
0057A:  POP     42
0057C:  RETFIE  
.................... #define ___LCD_H 
....................  
.................... void __Init_LCD(void); // Init LCD 
.................... void __ClearLCD(void);	// Efface l'écran 
.................... void __WriteLCD(unsigned int8 _Command);	// Ecrit la commande  
.................... void __WriteCount(float64 _Value, int1 _Mode);	// Ecrit une valeur, int32 si mode = 0, float si mode = 1 
.................... void __SautLig(unsigned int8 _Lig);	// Saute d'une ligne sur l'écran 
....................  
.................... #include "LCD/___LCD.c" 
.................... /* 
.................... * \file ___LCD.c 
.................... * \brief Gère l'afficheur LCD I2C (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_C 
.................... #define ___LCD_C 
....................  
.................... void __Init_LCD(void) 
.................... { 
.................... 	// Config LCD IIC 
.................... 	i2c_start(); 
.................... 	i2c_write(0x50);	// Adresse du LCD 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x52);	// Contraste 
.................... 	i2c_write(0x24);	// 36 sur 50 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x53);	// Brightness backlight 
.................... 	i2c_write(6);		// 6 sur 8 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x51);	// Efface l'écran 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __ClearLCD 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __ClearLCD(void) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Clear le LCD 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x51); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteLCD 
.................... // Ecrit ou envoi une commande au LCD. 
.................... // Prend quoi écrire. 
.................... // Ne retourne rien. 
.................... void __WriteLCD(unsigned int8 _Command) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
.................... unsigned int8 ack=i2c_write(0x50); 
.................... 	// Se connecte au LCD 
.................... 	if(ack==0) 
.................... 	// Ecrit ou envoi la comande au LCD 
.................... 	i2c_write(_Command); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteCount 
.................... // Permet d'écrire la valeur de la roue folle. 
.................... // Prend la valeur à écrire et le mode (0 = écrit. int, 1 = écrit. float tronqué) 
.................... // Ne retourne rien. 
.................... void __WriteCount(float64 _Value, int1 _Mode) 
.................... { 
.................... 	// Index d'affichage 
.................... 	unsigned int8 IAff=0, TabValue[16]; 
.................... 	 
.................... 	// Selon mode d'affichage choisi 
.................... 	// Transforme le nombre en chaîne de caractère 
.................... 	if(_Mode == 0) 
.................... 	sprintf(TabValue,"%7Ld ",(int32)_Value); 
.................... 	else	 
.................... 	sprintf(TabValue,"%6.3f ",(float64)_Value); 
.................... 		 
.................... 	// Affiche les caractères à la suite 
.................... 	while(TabValue[IAff]!=0x00) 
.................... 	{ 
.................... 		__WriteLCD(TabValue[IAff]); 
.................... 		Iaff++; 
.................... 	}	 
....................  
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... }	 
....................  
.................... // __SautLig 
.................... // Saute à la seconde ligne 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __SautLig(unsigned int8 _Lig) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Saute à la seconde ligne 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x45); 
.................... 	i2c_write(_Lig); 
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: TestCartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contrôle du robor secondaire.																	== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_h 
.................... #define ___Functions_h 
....................  
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0); 
.................... int1 Eject(void); 
....................  
.................... unsigned int16 soll_vit_rot  = 1450; 
.................... unsigned int16 soll_vit_rot_zero = 2000;  
.................... unsigned int16 soll_vit_mov = 1200; 
....................  
.................... signed int32 Endposition = 0; //position qui doit etre atteinte a la fin du depl 
.................... unsigned int8 Etat_ejection = 0; 
.................... int1 bras_out = 0; 
.................... int1 bras_in  = 0; 
.................... int1 flag_module_fond = 0; 
.................... void __ReadObjectifs(void); 
.................... int1 Ejecte(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
.................... void __resetEEPROM(void); 
.................... void __reset_roboteq(void); 
.................... void __GetRoboteqPID(unsigned int8 valeur); 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2); 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr); 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend); 
.................... void Ramassage(void); 
.................... void __Gestion_surcharge(unsigned int8 Adresse_driver); 
.................... void EjectionModule(unsigned int8 nbre_repet_ToDo); 
.................... void __Action_Writting(unsigned int8 ActionToDo); 
.................... void __ReadZones_Interdites(void); 
.................... int1 __Poussage(void); 
.................... int1 __Rentrage(void); 
.................... int1 __GoToZero(void); 
.................... void Deposage(void); 
.................... void Pos_barillet_module_du_fond(void); 
.................... void Ramassage_1module(void); 
.................... #include "Functions.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel 
.................... 						: Borgeat RÃ©my     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Function.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient des fonctions pour le robot																== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_c 
.................... #define ___Functions_c 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // arrondi_float 
.................... // 
.................... // Cette fonction permet d'arrondir un nombre decimal en entier relatif 
.................... // 12.7863 => 13 
.................... // 14.45621 => 14  
.................... // 
.................... // Developpe par : Louis Mayencourt 
.................... // Date :          01.12.2010  
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : nombre a convertir  
.................... // return      : nombre converti 
.................... // 
.................... //********************************************************************************************************************* 
.................... signed int32 arrondi_float_signed(float nombre) 
.................... { 
.................... 	float chiffres_apres_virgule;		// contient les chiffres apres la virgule du float a convertir  
....................  
.................... // prend les chiffres apres la virgule 
.................... 	chiffres_apres_virgule = nombre-floor(nombre); 
*
0655A:  PUSH    1B72
0655C:  POP     1B7A
0655E:  PUSH    1B74
06560:  POP     1B7C
06562:  CALL    64F4
06566:  BSET.B  43.0
06568:  MOV     W0,W2
0656A:  MOV     W1,W3
0656C:  MOV     1B72,W0
0656E:  MOV     1B74,W1
06570:  CALL    61DE
06574:  MOV     W0,1B76
06576:  MOV     W1,1B78
....................  
.................... // test si il faut arrondir vers le bas ou le haut 
.................... 	if(chiffres_apres_virgule>=0.5) return( (signed int32)(ceil(nombre))); 
06578:  MOV     #0,W0
0657A:  MOV     #3F00,W1
0657C:  MOV     1B76,W2
0657E:  MOV     1B78,W3
06580:  CALL    604C
06584:  BRA     C,6588
06586:  BRA     NZ,65A0
06588:  PUSH    1B72
0658A:  POP     1B7A
0658C:  PUSH    1B74
0658E:  POP     1B7C
06590:  CALL    6506
06594:  CALL    651A
06598:  MOV.D   W0,W0
0659A:  BRA     65B4
0659C:  GOTO    65B4
.................... 	else return( (signed int32)(floor(nombre))); 
065A0:  PUSH    1B72
065A2:  POP     1B7A
065A4:  PUSH    1B74
065A6:  POP     1B7C
065A8:  CALL    64F4
065AC:  CALL    651A
065B0:  MOV.D   W0,W0
065B2:  BRA     65B4
065B4:  RETURN  
.................... } 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Afficheur 7 segments 
.................... //	Auteur :	BORR 
.................... //	Date:	    6.1.16 
.................... //  Statut :    Fonctionnel 
.................... //  Futur :     n.a. 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : GÃ¨re 2 afficheur 7 segments 
.................... //	ParamÃ¨tre(s): int8 nombre -> nombre<=99 
.................... //  RÃ©sultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0) 
.................... { 
.................... 	_EN_Uni = _En_Diz = 1; 
*
01060:  BSET.B  2C9.2
01062:  BSET.B  2C9.3
.................... 	 
.................... 	if(ToBlank) 
01064:  CP0.B   1B2F
01066:  BRA     Z,1078
.................... 	{ 
.................... 		PORTB |= 0b1111<<12; 
01068:  MOV     #F000,W0
0106A:  IOR     2C8
.................... 		// charge sur les latchs 
.................... 		_EN_Uni = _En_Diz = 0; 
0106C:  BCLR.B  2C9.2
0106E:  BCLR.B  2C9.3
.................... 		_EN_Uni = _En_Diz = 1; 
01070:  BSET.B  2C9.2
01072:  BSET.B  2C9.3
.................... 	} 
01074:  GOTO    10B2
.................... 	else 
.................... 	{		 
.................... 		static unsigned int16 dizaine = 0; // variable qui va rÃ©cupÃ©rer le chiffre des dizaine  
.................... 		static unsigned int16 unite = 0; // variable qui va rÃ©cupÃ©rer le chiffre des unitÃ© 
.................... 	 
.................... 		dizaine = nombre/10; //rÃ©cupÃ©ration du nombre des dizaine 
01078:  MOV.B   1B2E,W0L
0107A:  SE      W0,W0
0107C:  MOV     W0,W4
0107E:  MOV     #A,W3
01080:  REPEAT  #11
01082:  DIV.S   W4,W3
01084:  MOV     W0,1596
.................... 		unite   = nombre%10; //rÃ©cupÃ©ration du nombre des unitÃ©s 
01086:  MOV.B   1B2E,W0L
01088:  SE      W0,W0
0108A:  MOV     W0,W4
0108C:  MOV     #A,W3
0108E:  REPEAT  #11
01090:  DIV.S   W4,W3
01092:  MOV     W1,W0
01094:  MOV     W0,1598
.................... 	 
.................... 		dizaine = dizaine * 4096; //dÃ©calage vers la droite car sortie sur RB12 Ã  RB15 
01096:  MOV     1596,W0
01098:  SL      W0,#C,W0
0109A:  MOV     W0,1596
.................... 		unite = unite * 4096; //dÃ©calage vers la droite car sortie sur RB12 Ã  RB15 
0109C:  MOV     1598,W0
0109E:  SL      W0,#C,W0
010A0:  MOV     W0,1598
.................... 		 
.................... 		_En_Diz = 0; // possibilitÃ© d'afficher sur l'afficheur des dizaine	 
010A2:  BCLR.B  2C9.2
.................... 		PORTB = dizaine; //affichage de la valeur sur l'afficheur 
010A4:  PUSH    1596
010A6:  POP     2C8
.................... 		_En_Diz = 1; // Afficheur dizaine allumÃ©, mais on ne peux plus changer la valeur 
010A8:  BSET.B  2C9.2
.................... 	 
.................... 		_EN_Uni = 0; // possibilitÃ© d'afficher sur afficheur unitÃ©  
010AA:  BCLR.B  2C9.3
.................... 		PORTB = unite; // affichage des unitÃ© sur l'afficheur des unitÃ©  
010AC:  PUSH    1598
010AE:  POP     2C8
.................... 		_EN_Uni = 1; // Afficheur unitÃ© allumÃ©, mais on ne peux plus changer la valeur 
010B0:  BSET.B  2C9.3
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
010B2:  RETURN  
.................... } 
.................... void __Affichage_Erreur(int8 nombre) 
.................... { 
.................... 	No_erreur = nombre;  
*
0100E:  MOV.B   1B2E,W0L
01010:  MOV.B   W0L,870
.................... 	flag_error = 1;  
01012:  BSET.B  85B.2
.................... 		// Quitte la fonction 
.................... 	return; 
01014:  RETURN  
.................... } 
....................  
.................... /* 
.................... 	Fct qui reset une partie de l'eeprom en 
.................... 	remettant les valeurs Ã  0xffff 
.................... 	 
.................... 	Auteur : Borgeat RÃ©my 
.................... 	Date   : 9.2.2017 
.................... */ 
.................... void __resetEEPROM(void) 
*
094CC:  MOV     W5,[W15++]
094CE:  CLR     1B36
.................... { 
.................... 	unsigned int16 adresse = 0; 
.................... 	for(adresse = 0; adresse <= 820; adresse +=  2) 
094D0:  CLR     1B36
094D2:  MOV     1B36,W4
094D4:  MOV     #334,W3
094D6:  CP      W3,W4
094D8:  BRA     NC,94F0
.................... 	{ 
.................... 		write_eeprom(adresse, 0xFFFF);//on Ã©crase l'eeprom 
094DA:  MOV     #FFFF,W5
094DC:  MOV     1B36,W0
094DE:  MOV     #A,W1
094E0:  MOV     #2,W2
094E2:  CALL    90A6
094E6:  MOV     1B36,W4
094E8:  ADD     W4,#2,W0
094EA:  MOV     W0,1B36
094EC:  GOTO    94D2
.................... 	} 
094F0:  MOV     [--W15],W5
094F2:  RETURN  
.................... } 
.................... void __reset_roboteq(void) 
.................... { 
.................... 	fputc('%',ROBOTEQ); 
*
094A8:  MOV.B   #25,W0L
094AA:  BTSC.B  219.1
094AC:  BRA     94AA
094AE:  MOV.B   W0L,21A
094B0:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"RESET 321654987 \r"); 
094B2:  MOV     #0,W1
094B4:  MOV     W1,W0
094B6:  CLR.B   1
094B8:  CALL    100
094BC:  INC     W1,W1
094BE:  BTSC.B  219.1
094C0:  BRA     94BE
094C2:  MOV     W0,21A
094C4:  MOV     #10,W0
094C6:  CPSGT   W1,W0
094C8:  BRA     94B4
094CA:  RETURN  
.................... } 
.................... /*======================================================================================= 
.................... 	Fct qui va recuperer les pid du roboteq et les mettre dans un tableau 
.................... =========================================================================================	 
.................... 	Auteur : Borgeat RÃ©my 
.................... 	Date : 16.2.2017 
.................... =========================================================================================	 
.................... 	! on doit faire passer 6x dans la fct. 
.................... 	On doit mettre une boucle exeterieur, car avec dans la fct, 
.................... 	on resete la dedans, et donc on ne peut pas recuperer des caractere 
.................... 	 
.................... 	Trame envoyer : Tab{2,0,:,10,...\r) 
.................... 					Tab{kp1 : ki1 : ...) 
.................... 	Les : separe les donnes, le \r annonce la fin du tableau 
.................... 	 
.................... 	!on peut pas chainer les commande, car il ecrase a chaque fois la reponse de l'ordre precdent 
.................... ==========================================================================================*/ 
.................... void __GetRoboteqPID(unsigned int8 valeur) 
*
090E0:  MOV     W5,[W15++]
090E2:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 i = 3; // car on recoit KP=110 -> on veut que la valeur --> on saute les 3 premiers caractere 
.................... 	static int8 y = 0; 
.................... 	 
.................... 	switch(valeur) // on demande au roboteq es valeur 
090E4:  MOV.B   1B36,W0L
090E6:  CLR.B   1
090E8:  XOR     #0,W0
090EA:  BRA     Z,9112
090EC:  XOR     #1,W0
090EE:  BRA     Z,9134
090F0:  XOR     #3,W0
090F2:  BRA     Z,9156
090F4:  XOR     #1,W0
090F6:  BRA     Z,9178
090F8:  XOR     #7,W0
090FA:  BRA     Z,919A
090FC:  XOR     #1,W0
090FE:  BRA     Z,91BC
09100:  XOR     #3,W0
09102:  BRA     Z,91DE
09104:  XOR     #1,W0
09106:  BRA     Z,9204
09108:  XOR     #F,W0
0910A:  BRA     Z,922A
0910C:  XOR     #1,W0
0910E:  BRA     Z,9250
09110:  BRA     9276
.................... 	{ 
.................... 		case 0: 
.................... 			fprintf(ROBOTEQ,"~KP 1 \r");			 
09112:  MOV     #0,W1
09114:  MOV     W1,W0
09116:  CLR.B   1
09118:  CALL    11E
0911C:  INC     W1,W1
0911E:  BTSC.B  219.1
09120:  BRA     911E
09122:  MOV     W0,21A
09124:  MOV     #6,W0
09126:  CPSGT   W1,W0
09128:  BRA     9114
.................... 			delay_ms(10);			 
0912A:  MOV     #A,W0
0912C:  CALL    E90
.................... 			break; 
09130:  GOTO    9276
.................... 		case 1: 
.................... 			fprintf(ROBOTEQ,"~KI 1 \r"); 
09134:  MOV     #0,W1
09136:  MOV     W1,W0
09138:  CLR.B   1
0913A:  CALL    132
0913E:  INC     W1,W1
09140:  BTSC.B  219.1
09142:  BRA     9140
09144:  MOV     W0,21A
09146:  MOV     #6,W0
09148:  CPSGT   W1,W0
0914A:  BRA     9136
.................... 			delay_ms(10); 
0914C:  MOV     #A,W0
0914E:  CALL    E90
.................... 			break; 
09152:  GOTO    9276
.................... 		case 2: 
.................... 			fprintf(ROBOTEQ,"~KD 1 \r"); 
09156:  MOV     #0,W1
09158:  MOV     W1,W0
0915A:  CLR.B   1
0915C:  CALL    146
09160:  INC     W1,W1
09162:  BTSC.B  219.1
09164:  BRA     9162
09166:  MOV     W0,21A
09168:  MOV     #6,W0
0916A:  CPSGT   W1,W0
0916C:  BRA     9158
.................... 			delay_ms(10); 
0916E:  MOV     #A,W0
09170:  CALL    E90
.................... 			break; 
09174:  GOTO    9276
.................... 		case 3: 
.................... 			fprintf(ROBOTEQ,"~KP 2 \r"); 
09178:  MOV     #0,W1
0917A:  MOV     W1,W0
0917C:  CLR.B   1
0917E:  CALL    15A
09182:  INC     W1,W1
09184:  BTSC.B  219.1
09186:  BRA     9184
09188:  MOV     W0,21A
0918A:  MOV     #6,W0
0918C:  CPSGT   W1,W0
0918E:  BRA     917A
.................... 			delay_ms(10); 
09190:  MOV     #A,W0
09192:  CALL    E90
.................... 			break; 
09196:  GOTO    9276
.................... 		case 4: 
.................... 			fprintf(ROBOTEQ,"~KI 2 \r"); 
0919A:  MOV     #0,W1
0919C:  MOV     W1,W0
0919E:  CLR.B   1
091A0:  CALL    16E
091A4:  INC     W1,W1
091A6:  BTSC.B  219.1
091A8:  BRA     91A6
091AA:  MOV     W0,21A
091AC:  MOV     #6,W0
091AE:  CPSGT   W1,W0
091B0:  BRA     919C
.................... 			delay_ms(10); 
091B2:  MOV     #A,W0
091B4:  CALL    E90
.................... 			break; 
091B8:  GOTO    9276
.................... 		case 5: 
.................... 			fprintf(ROBOTEQ,"~KD 2 \r"); 
091BC:  MOV     #0,W1
091BE:  MOV     W1,W0
091C0:  CLR.B   1
091C2:  CALL    182
091C6:  INC     W1,W1
091C8:  BTSC.B  219.1
091CA:  BRA     91C8
091CC:  MOV     W0,21A
091CE:  MOV     #6,W0
091D0:  CPSGT   W1,W0
091D2:  BRA     91BE
.................... 			delay_ms(10); 
091D4:  MOV     #A,W0
091D6:  CALL    E90
.................... 			break;	 
091DA:  GOTO    9276
.................... 		case 6: 
.................... 			fprintf(ROBOTEQ,"~MAC 1 \r"); 
091DE:  MOV     #0,W1
091E0:  MOV     W1,W0
091E2:  CLR.B   1
091E4:  CALL    196
091E8:  INC     W1,W1
091EA:  BTSC.B  219.1
091EC:  BRA     91EA
091EE:  MOV     W0,21A
091F0:  MOV     #7,W0
091F2:  CPSGT   W1,W0
091F4:  BRA     91E0
.................... 			delay_ms(10); 
091F6:  MOV     #A,W0
091F8:  CALL    E90
.................... 			i = 4; 
091FC:  MOV.B   #4,W0L
091FE:  MOV.B   W0L,1595
.................... 			break;	 
09200:  GOTO    9276
.................... 		case 7: 
.................... 			fprintf(ROBOTEQ,"~MDEC 1 \r"); 
09204:  MOV     #0,W1
09206:  MOV     W1,W0
09208:  CLR.B   1
0920A:  CALL    1AC
0920E:  INC     W1,W1
09210:  BTSC.B  219.1
09212:  BRA     9210
09214:  MOV     W0,21A
09216:  MOV     #8,W0
09218:  CPSGT   W1,W0
0921A:  BRA     9206
.................... 			delay_ms(10); 
0921C:  MOV     #A,W0
0921E:  CALL    E90
.................... 			i = 5; 
09222:  MOV.B   #5,W0L
09224:  MOV.B   W0L,1595
.................... 			break;	 
09226:  GOTO    9276
.................... 		case 8: 
.................... 			fprintf(ROBOTEQ,"~MAC 2 \r"); 
0922A:  MOV     #0,W1
0922C:  MOV     W1,W0
0922E:  CLR.B   1
09230:  CALL    1C2
09234:  INC     W1,W1
09236:  BTSC.B  219.1
09238:  BRA     9236
0923A:  MOV     W0,21A
0923C:  MOV     #7,W0
0923E:  CPSGT   W1,W0
09240:  BRA     922C
.................... 			delay_ms(10); 
09242:  MOV     #A,W0
09244:  CALL    E90
.................... 			i = 4; 
09248:  MOV.B   #4,W0L
0924A:  MOV.B   W0L,1595
.................... 			break;	 
0924C:  GOTO    9276
.................... 		case 9: 
.................... 			fprintf(ROBOTEQ,"~MDEC 2 \r"); 
09250:  MOV     #0,W1
09252:  MOV     W1,W0
09254:  CLR.B   1
09256:  CALL    1D8
0925A:  INC     W1,W1
0925C:  BTSC.B  219.1
0925E:  BRA     925C
09260:  MOV     W0,21A
09262:  MOV     #8,W0
09264:  CPSGT   W1,W0
09266:  BRA     9252
.................... 			delay_ms(10); 
09268:  MOV     #A,W0
0926A:  CALL    E90
.................... 			i = 5; 
0926E:  MOV.B   #5,W0L
09270:  MOV.B   W0L,1595
.................... 			break;	 
09272:  GOTO    9276
.................... 	}	 
....................  
.................... 	if(RoboteQ_receiveBuffer[0] == 'K' || RoboteQ_receiveBuffer[0] == 'M') 
09276:  MOV     894,W4
09278:  XOR.B   #4B,W4L
0927A:  BRA     Z,9282
0927C:  MOV     894,W4
0927E:  XOR.B   #4D,W4L
09280:  BRA     NZ,92D6
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i] != 0x0D) // On commence du [2] pour sauter le 'C='. Le +3 est pour le C,= et : (C=xxx:xxx). 
09282:  MOV.B   1595,W0L
09284:  SE      W0,W0
09286:  MOV     #894,W4
09288:  ADD     W0,W4,W0
0928A:  MOV.B   [W0],W5L
0928C:  SE      W5,W5
0928E:  CP      W5,#D
09290:  BRA     Z,92AC
.................... 		{  
.................... 			TabSentRS232[y] = RoboteQ_receiveBuffer[i];				 
09292:  MOV.B   159A,W0L
09294:  SE      W0,W0
09296:  MOV     #994,W4
09298:  ADD     W0,W4,W5
0929A:  MOV.B   1595,W0L
0929C:  SE      W0,W0
0929E:  MOV     #894,W4
092A0:  ADD     W0,W4,W0
092A2:  MOV.B   [W0],[W5]
.................... 			i++; 
092A4:  INC.B   1595
.................... 			y++; 
092A6:  INC.B   159A
092A8:  GOTO    9282
.................... 		} 
.................... 		if(valeur<9) 
092AC:  MOV     1B36,W4
092AE:  CP.B    W4L,#9
092B0:  BRA     C,92C4
.................... 		{	 
.................... 			TabSentRS232[y] = ':';//seperation des valeur	 
092B2:  MOV.B   159A,W0L
092B4:  SE      W0,W0
092B6:  MOV     #994,W4
092B8:  ADD     W0,W4,W5
092BA:  MOV.B   #3A,W0L
092BC:  MOV.B   W0L,[W5]
.................... 			y++; 
092BE:  INC.B   159A
.................... 		} 
092C0:  GOTO    92D2
.................... 		else 
.................... 		{ 
.................... 			TabSentRS232[y] = '\r'; // fin de transmssion 
092C4:  MOV.B   159A,W0L
092C6:  SE      W0,W0
092C8:  MOV     #994,W4
092CA:  ADD     W0,W4,W5
092CC:  MOV.B   #D,W0L
092CE:  MOV.B   W0L,[W5]
.................... 			y = 0 ;	 
092D0:  CLR.B   159A
.................... 		} 
.................... 		i = 3; 
092D2:  MOV.B   #3,W0L
092D4:  MOV.B   W0L,1595
.................... 	}	 
092D6:  MOV     [--W15],W6
092D8:  MOV     [--W15],W5
092DA:  RETURN  
....................  
.................... } 
.................... /* 
.................... 	Fct qui va changer les paramÃ¨tre PID du roboteq. 
.................... 	Les parametre ont ete recu du pc et ont les save en 
.................... 	dans l'eeprom du roboteq 
.................... 	 
.................... 	Auteur : Borgeat RÃ©my 
.................... 	Date   : 16.2.2017 
.................... */ 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2) 
092DC:  MOV     W5,[W15++]
.................... { 
.................... 	//envoi des paramÃ¨tres PID au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"^KP 1 %u_^KI 1 %u_^KD 1 %u_^KP 2 %u_^KI 2 %u_^KD 2 %u \r",P1,I1,D1,P2,I2,D2); 
092DE:  MOV     #0,W1
092E0:  MOV     W1,W0
092E2:  CLR.B   1
092E4:  CALL    1EE
092E8:  INC     W1,W1
092EA:  BTSC.B  219.1
092EC:  BRA     92EA
092EE:  MOV     W0,21A
092F0:  MOV     #5,W0
092F2:  CPSGT   W1,W0
092F4:  BRA     92E0
092F6:  MOV.B   1B4C,W0L
092F8:  CLR.B   1
092FA:  MOV     #0,W4
092FC:  CALL    65B6
09300:  MOV     #8,W1
09302:  MOV     W1,W0
09304:  CLR.B   1
09306:  CALL    1EE
0930A:  INC     W1,W1
0930C:  BTSC.B  219.1
0930E:  BRA     930C
09310:  MOV     W0,21A
09312:  MOV     #E,W0
09314:  CPSGT   W1,W0
09316:  BRA     9302
09318:  MOV     1B4E,W0
0931A:  MOV     #0,W4
0931C:  CALL    65B6
09320:  MOV     #11,W1
09322:  MOV     W1,W0
09324:  CLR.B   1
09326:  CALL    1EE
0932A:  INC     W1,W1
0932C:  BTSC.B  219.1
0932E:  BRA     932C
09330:  MOV     W0,21A
09332:  MOV     #17,W0
09334:  CPSGT   W1,W0
09336:  BRA     9322
09338:  MOV     1B50,W0
0933A:  MOV     #0,W4
0933C:  CALL    65B6
09340:  MOV     #1A,W1
09342:  MOV     W1,W0
09344:  CLR.B   1
09346:  CALL    1EE
0934A:  INC     W1,W1
0934C:  BTSC.B  219.1
0934E:  BRA     934C
09350:  MOV     W0,21A
09352:  MOV     #20,W0
09354:  CPSGT   W1,W0
09356:  BRA     9342
09358:  MOV     1B52,W0
0935A:  MOV     #0,W4
0935C:  CALL    65B6
09360:  MOV     #23,W1
09362:  MOV     W1,W0
09364:  CLR.B   1
09366:  CALL    1EE
0936A:  INC     W1,W1
0936C:  BTSC.B  219.1
0936E:  BRA     936C
09370:  MOV     W0,21A
09372:  MOV     #29,W0
09374:  CPSGT   W1,W0
09376:  BRA     9362
09378:  MOV     1B54,W0
0937A:  MOV     #0,W4
0937C:  CALL    65B6
09380:  MOV     #2C,W1
09382:  MOV     W1,W0
09384:  CLR.B   1
09386:  CALL    1EE
0938A:  INC     W1,W1
0938C:  BTSC.B  219.1
0938E:  BRA     938C
09390:  MOV     W0,21A
09392:  MOV     #32,W0
09394:  CPSGT   W1,W0
09396:  BRA     9382
09398:  MOV     1B56,W0
0939A:  MOV     #0,W4
0939C:  CALL    65B6
093A0:  BTSC.B  219.1
093A2:  BRA     93A0
093A4:  MOV     #20,W4
093A6:  MOV     W4,21A
093A8:  BTSC.B  219.1
093AA:  BRA     93A8
093AC:  MOV     #D,W4
093AE:  MOV     W4,21A
.................... 	fprintf(ROBOTEQ,"^MAC 1 %u_^MDEC 1 %u_^MAC 2 %u_^MDEC 2 %u \r",ac1,dc1,ac2,dc2);// envoie au Roboteq 
093B0:  MOV     #0,W1
093B2:  MOV     W1,W0
093B4:  CLR.B   1
093B6:  CALL    230
093BA:  INC     W1,W1
093BC:  BTSC.B  219.1
093BE:  BRA     93BC
093C0:  MOV     W0,21A
093C2:  MOV     #6,W0
093C4:  CPSGT   W1,W0
093C6:  BRA     93B2
093C8:  MOV     1B58,W0
093CA:  MOV     #0,W4
093CC:  CALL    65B6
093D0:  MOV     #9,W1
093D2:  MOV     W1,W0
093D4:  CLR.B   1
093D6:  CALL    230
093DA:  INC     W1,W1
093DC:  BTSC.B  219.1
093DE:  BRA     93DC
093E0:  MOV     W0,21A
093E2:  MOV     #11,W0
093E4:  CPSGT   W1,W0
093E6:  BRA     93D2
093E8:  MOV     1B5A,W0
093EA:  MOV     #0,W4
093EC:  CALL    65B6
093F0:  MOV     #14,W1
093F2:  MOV     W1,W0
093F4:  CLR.B   1
093F6:  CALL    230
093FA:  INC     W1,W1
093FC:  BTSC.B  219.1
093FE:  BRA     93FC
09400:  MOV     W0,21A
09402:  MOV     #1B,W0
09404:  CPSGT   W1,W0
09406:  BRA     93F2
09408:  MOV     1B5C,W0
0940A:  MOV     #0,W4
0940C:  CALL    65B6
09410:  MOV     #1E,W1
09412:  MOV     W1,W0
09414:  CLR.B   1
09416:  CALL    230
0941A:  INC     W1,W1
0941C:  BTSC.B  219.1
0941E:  BRA     941C
09420:  MOV     W0,21A
09422:  MOV     #26,W0
09424:  CPSGT   W1,W0
09426:  BRA     9412
09428:  MOV     1B5E,W0
0942A:  MOV     #0,W4
0942C:  CALL    65B6
09430:  BTSC.B  219.1
09432:  BRA     9430
09434:  MOV     #20,W4
09436:  MOV     W4,21A
09438:  BTSC.B  219.1
0943A:  BRA     9438
0943C:  MOV     #D,W4
0943E:  MOV     W4,21A
....................  
.................... 	write_eeprom(300,P1); 
09440:  MOV.B   1B4C,W0L
09442:  MOV.B   W0L,A
09444:  CLR.B   B
09446:  MOV     #12C,W0
09448:  MOV     #A,W1
0944A:  MOV     #2,W2
0944C:  CALL    90A6
.................... 	write_eeprom(302,I1); 
09450:  MOV     #12E,W0
09452:  MOV     #1B4E,W1
09454:  MOV     #2,W2
09456:  CALL    90A6
.................... 	write_eeprom(304,D1); 
0945A:  MOV     #130,W0
0945C:  MOV     #1B50,W1
0945E:  MOV     #2,W2
09460:  CALL    90A6
.................... 	write_eeprom(306,P2); 
09464:  MOV     #132,W0
09466:  MOV     #1B52,W1
09468:  MOV     #2,W2
0946A:  CALL    90A6
.................... 	write_eeprom(308,I2); 
0946E:  MOV     #134,W0
09470:  MOV     #1B54,W1
09472:  MOV     #2,W2
09474:  CALL    90A6
.................... 	write_eeprom(310,D2); 
09478:  MOV     #136,W0
0947A:  MOV     #1B56,W1
0947C:  MOV     #2,W2
0947E:  CALL    90A6
.................... 	 
.................... 	//Sauvegarde en eeprom 
.................... 	fputc('%',ROBOTEQ);//pas le choix de faire un putc, car le % est un caractÃ¨re rÃ©servÃ© pour le pritnf 
09482:  MOV.B   #25,W0L
09484:  BTSC.B  219.1
09486:  BRA     9484
09488:  MOV.B   W0L,21A
0948A:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"EESAV \r");//envoie du reste de la commande 
0948C:  MOV     #0,W1
0948E:  MOV     W1,W0
09490:  CLR.B   1
09492:  CALL    26A
09496:  INC     W1,W1
09498:  BTSC.B  219.1
0949A:  BRA     9498
0949C:  MOV     W0,21A
0949E:  MOV     #6,W0
094A0:  CPSGT   W1,W0
094A2:  BRA     948E
094A4:  MOV     [--W15],W5
094A6:  RETURN  
....................  
.................... } 
....................  
.................... // RÃ©cupÃ¨re tous les objectifs et les stock en eeprom 
.................... void __ReadObjectifs(void) 
*
0124E:  MOV     W5,[W15++]
01250:  MOV     W6,[W15++]
01252:  CLR     1B36
01254:  CLR     1B38
01256:  CLR     1B3A
01258:  CLR     1B3C
.................... { 
.................... 	// Lit les objectifs stockÃ©s en EEPROM 
.................... 	// Les Ã©lÃ©ments d'objectifs sont stockÃ©s chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset; 
.................... 	unsigned int16 NumObj = 0; 
.................... 	unsigned int16 Obj = 0; 
....................  
.................... 	while(y==0) 
0125A:  CP0     1B38
0125C:  BRA     NZ,12E2
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
0125E:  MOV     159C,W3
01260:  MOV     #0,W4
01262:  MOV     #2,W5
01264:  CALL    1236
01268:  MOV     W0,1B3C
.................... 		NumObj = read_eeprom(offset+2); 
0126A:  MOV     159C,W4
0126C:  ADD     W4,#2,W5
0126E:  MOV     W5,[W15++]
01270:  MOV     W5,W3
01272:  MOV     #0,W4
01274:  MOV     #2,W5
01276:  CALL    1236
0127A:  MOV     [--W15],W5
0127C:  MOV     W0,1B3A
.................... 		if(Obj!=0xFFFF)//Si il en reste 
0127E:  MOV     1B3C,W4
01280:  MOV     #FFFF,W3
01282:  CP      W3,W4
01284:  BRA     Z,12DA
.................... 		{ 
.................... 			for( i = 0 ; i < 24; i += 2) 
01286:  CLR     1B36
01288:  MOV     1B36,W4
0128A:  CP      W4,#18
0128C:  BRA     C,12CC
.................... 			{			 
.................... 				TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
0128E:  MOV     1B3C,W4
01290:  MOV     #138,W3
01292:  MUL.UU  W4,W3,W0
01294:  MOV     W0,W5
01296:  MOV     1B3A,W4
01298:  MUL.UU  W4,#18,W0
0129A:  ADD     W0,W5,W5
0129C:  MOV     1B36,W6
0129E:  LSR     W6,#1,W6
012A0:  SL      W6,#1,W0
012A2:  ADD     W0,W5,W0
012A4:  MOV     #C1C,W4
012A6:  ADD     W0,W4,W5
012A8:  MOV     1B36,W4
012AA:  ADD     W4,#4,W6
012AC:  MOV     W6,W0
012AE:  ADD     159C,W0
012B0:  MOV     W0,W6
012B2:  MOV     W5,[W15++]
012B4:  MOV     W6,W3
012B6:  MOV     #0,W4
012B8:  MOV     #2,W5
012BA:  CALL    1236
012BE:  MOV     [--W15],W5
012C0:  MOV     W0,[W5]
012C2:  MOV     1B36,W4
012C4:  ADD     W4,#2,W0
012C6:  MOV     W0,1B36
012C8:  GOTO    1288
.................... 			}	 
.................... 			offset += 28;// offset de +24,afin de lire les objectifs suivant	 
012CC:  MOV     159C,W4
012CE:  ADD     W4,#1C,W0
012D0:  MOV     W0,159C
.................... 			NbreObjectifs=Obj;	 
012D2:  PUSH    1B3C
012D4:  POP     14C6
.................... 		} 
012D6:  GOTO    12DE
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
012DA:  MOV     #1,W4
012DC:  MOV     W4,1B38
.................... 		} 
012DE:  GOTO    125A
.................... 	} 
012E2:  MOV     [--W15],W6
012E4:  MOV     [--W15],W5
012E6:  RETURN  
....................  
.................... } 
.................... // RÃ©cupÃ¨re tous les objectifs et les stock en eeprom 
.................... void __ReadZones_Interdites(void) 
*
094F4:  MOV     W5,[W15++]
094F6:  MOV     W6,[W15++]
094F8:  CLR     1B36
094FA:  CLR     1B38
094FC:  CLR     1B3A
.................... { 
.................... 	// Lit les objectifs stockÃ©s en EEPROM 
.................... 	// Les Ã©lÃ©ments d'objectifs sont stockÃ©s chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset = 200; 
.................... 	unsigned int16 NumZone = 0; 
....................  
.................... 	while(y==0) 
094FE:  CP0     1B38
09500:  BRA     NZ,956E
.................... 	{ 
.................... 		NumZone = read_eeprom(offset);//on check si il reste des objectifs 
09502:  MOV     159E,W3
09504:  MOV     #0,W4
09506:  MOV     #2,W5
09508:  CALL    1236
0950C:  MOV     W0,1B3A
.................... 		if(NumZone!=0xFFFF)//Si il en reste 
0950E:  MOV     1B3A,W4
09510:  MOV     #FFFF,W3
09512:  CP      W3,W4
09514:  BRA     Z,9566
.................... 		{ 
.................... 			for( i = 0 ; i < 16; i += 2) 
09516:  CLR     1B36
09518:  MOV     1B36,W4
0951A:  CP      W4,#10
0951C:  BRA     C,955A
.................... 			{ 
.................... 				TabZones[NumZone][(i/2)] = read_eeprom(i+2+offset);//remplir le tableau avec les objectifs 
0951E:  MOV     1B3A,W5
09520:  SL      W5,#4,W5
09522:  MOV     1B36,W6
09524:  LSR     W6,#1,W6
09526:  SL      W6,#2,W0
09528:  ADD     W0,W5,W0
0952A:  MOV     #B72,W4
0952C:  ADD     W0,W4,W5
0952E:  MOV     1B36,W4
09530:  ADD     W4,#2,W6
09532:  MOV     W6,W0
09534:  ADD     159E,W0
09536:  MOV     W0,W6
09538:  MOV     W5,[W15++]
0953A:  MOV     W6,W3
0953C:  MOV     #0,W4
0953E:  MOV     #2,W5
09540:  CALL    1236
09544:  MOV     [--W15],W5
09546:  MOV     W0,[W5]
09548:  MOV.B   #0,W4L
0954A:  MOV.B   W4L,[W5+#2]
0954C:  MOV.B   #0,W3L
0954E:  MOV.B   W3L,[W5+#3]
09550:  MOV     1B36,W4
09552:  ADD     W4,#2,W0
09554:  MOV     W0,1B36
09556:  GOTO    9518
.................... 			}	 
.................... 			offset += 18;// offset de +24,afin de lire les objectifs suivant	 
0955A:  MOV     159E,W4
0955C:  ADD     W4,#12,W0
0955E:  MOV     W0,159E
.................... 			NbreZone_check++; 
09560:  INC.B   0892
.................... 		} 
09562:  GOTO    956A
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
09566:  MOV     #1,W4
09568:  MOV     W4,1B38
.................... 		} 
0956A:  GOTO    94FE
.................... 			 
.................... 	} 
0956E:  MOV     [--W15],W6
09570:  MOV     [--W15],W5
09572:  RETURN  
.................... //	NbreZone = read_eeprom(512);	 
.................... } 
....................  
.................... // Actions Ã  effectuer 
.................... void __Action_Writting(unsigned int8 ActionToDo) 
.................... { 
.................... //	unsigned int8 StateDriver = 0; 
.................... 	switch(ActionToDo) 
*
085D8:  MOV.B   1B2A,W0L
085DA:  CLR.B   1
085DC:  BRA     85DE
.................... 	{ 
.................... 		/* 
.................... 		// Ne fait rien 
.................... 		case 0 : 
.................... 			Action_send=1; 
.................... 			break;		 
.................... 		case 1 : 
.................... 			Ramassage(); 
.................... 			break;	 
.................... 		case 2 :  
.................... 			EjectionModule(3); 
.................... 			break; 
.................... 		case 3 :  
.................... 			__Rentrage(); 
.................... 			break; 
.................... 		case 4 :  
.................... 			EjectionModule(0); 
.................... 			break; 
.................... 		case 5 :  
.................... 			__GoToZero(); 
.................... 			break; 
.................... 		case 7 : 
.................... 			Ramassage_1module(); 
.................... 			break; 
.................... 		case 8 :  
.................... 			Pos_barillet_module_du_fond(); 
.................... 			break; 
.................... 		case 9 :  
.................... 			Deposage(); 
.................... 			break; 
.................... 		default : 
.................... 			__Affichage_erreur(5); 
.................... 			break; 
.................... 			 
.................... 			*/ 
.................... 	} 
085DE:  RETURN  
.................... } 
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: GoToZero																														 
.................... //================================================================================================================================================================================================= 
.................... //	DÃ©veloppÃ© par:		: Favre Lenny 
.................... //						: Borgeat RÃ©my     												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 17.3.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui place le barillet Ã  son point zÃ©ro 
.................... // paramÃ¨tres 	:	Aucun paramÃ¨tre 
.................... // retourne 	:	retourne le status du driver											 
.................... //					0-> non utilisÃ©																 
.................... //					1-> OK : ordre transmis et terminÃ©													 
.................... //					2-> not ready  (le slave ne rÃ©pond pas)															 
.................... //					3-> Le barillet n'a pas trouvÃ© le point zÃ©ro															 
.................... //=================================================================================================================================================================================================== 
.................... int1 __GoToZero(void) 
.................... { 
.................... 	static signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
....................  
.................... 	if(_ZeroPoint == 0 && Etat == 0) return(1); 
.................... 	else 
.................... 	{	 
.................... 		if(Etat!=1) 
.................... 		{ 
.................... 			if(!read) 
.................... 			{ 
.................... 				ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
.................... 				delay_ms(20); 
.................... 				read = 1; 
.................... 			}		 
.................... 			Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot_zero,DRV_ARRET_POSITION_ABSOLUE,(5400 + ActualPosition));	 
.................... 			delay_ms(20); 
.................... 			return(0); 
.................... 		} 
.................... 		else 
.................... 		{ 
.................... 			if(!_ZeroPoint) 
.................... 			{ 
.................... 				Etat = 0; 
.................... 				read = 0; 
.................... 				driver_moteur(0xC0,0); //arrÃªt du driver 
.................... 				if(obj_Action==8)Action_send = 0; 
.................... 				else Action_send=1; 
.................... 				return(1); 
.................... 			} 
.................... 			else return(0); 
.................... 		} 
.................... 	} 
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: __Check_action_end																														 
.................... //================================================================================================================================================================================================= 
.................... //	DÃ©veloppÃ© par:		: Borgeat Remy   
.................... //						:   												 
.................... //  Date				: 28.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui check l'etat du driver moteur 
.................... // 				: 	En cas de surcharge ou driver pas connecte --> on affiche l'erreur 
.................... //				: 	En cas de surchauffe --> on attend 1s pour renvoyer l'ordre 
.................... // paramÃ¨tres 	:	Addresse du driver 
.................... // retourne 	:	1 -> ordre fini, 0 -> ordre en cours ou erreur	 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Check_action_end(unsigned int8 driver_address) 
*
0880A:  MOV     W5,[W15++]
0880C:  MOV     W6,[W15++]
0880E:  CLR     1B2C
.................... { 
.................... 	static unsigned int32 Time_ms = 0; 
.................... 	static signed int16 impulses_toDo = 0; 
.................... 	signed int16 ActualPosition = 0; 
.................... 	static unsigned int8 passage_erreur = 0; 
.................... 	static unsigned int8 Etat_d = 1; 
.................... 	static unsigned int1 ok = 0; 
.................... 	static unsigned int8 Etat = 0; 
.................... 	static unsigned int1 read = 0; 
.................... 	static unsigned int8 Etat_driver = 0; 
.................... 	Etat_d = read_driver_moteur(driver_address); 
08810:  MOV.B   1B2A,W0L
08812:  MOV.B   W0L,1B38
08814:  CALL    860A
08818:  MOV.B   W0L,15AB
.................... 	delay_ms(20); 
0881A:  MOV     #14,W0
0881C:  CALL    E90
....................  
.................... 	switch(Etat_d) 
08820:  MOV.B   15AB,W0L
08822:  CLR.B   1
08824:  XOR     #0,W0
08826:  BRA     Z,883E
08828:  XOR     #1,W0
0882A:  BRA     Z,884E
0882C:  XOR     #3,W0
0882E:  BRA     Z,888E
08830:  XOR     #1,W0
08832:  BRA     Z,8998
08834:  XOR     #7,W0
08836:  BRA     Z,8B70
08838:  XOR     #1,W0
0883A:  BRA     Z,8BB0
0883C:  BRA     8BEE
.................... 	{ 
.................... 		case 0:  
.................... 			Erreur_max_surchauffe = 0; 
0883E:  CLR.B   893
.................... 			Time_ms = 0; 
08840:  CLR     15A4
08842:  CLR     15A6
.................... 			return(1); //driver arreter --> ordre fini  
08844:  MOV.B   #1,W0L
08846:  MOV.B   W0L,0
08848:  BRA     8BEE
.................... 			break;	 
0884A:  GOTO    8BEE
.................... 			 
.................... 		case 1:	//en cours 
.................... 			 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(10); 
0884E:  MOV     1B2A,W4
08850:  XOR.B   #C0,W4L
08852:  BRA     NZ,8862
08854:  MOV.B   #A,W0L
08856:  MOV.B   W0L,1B2E
08858:  CLR.B   1B2F
0885A:  CALL    1060
0885E:  GOTO    8886
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(11); 
08862:  MOV     1B2A,W4
08864:  XOR.B   #C2,W4L
08866:  BRA     NZ,8876
08868:  MOV.B   #B,W0L
0886A:  MOV.B   W0L,1B2E
0886C:  CLR.B   1B2F
0886E:  CALL    1060
08872:  GOTO    8886
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(12); 
08876:  MOV     1B2A,W4
08878:  XOR.B   #C4,W4L
0887A:  BRA     NZ,8886
0887C:  MOV.B   #C,W0L
0887E:  MOV.B   W0L,1B2E
08880:  CLR.B   1B2F
08882:  CALL    1060
....................  
.................... 			return(0);//driver en mouvement, ou en erreur --> on renvoie 0	 
08886:  CLR.B   0
08888:  BRA     8BEE
.................... 			break; 
0888A:  GOTO    8BEE
.................... 					 
.................... 		case 2: // surcharge on tire plus de courant que le maximum configure 
.................... 	 
.................... 			if(driver_address==0xC0) 
0888E:  MOV     1B2A,W4
08890:  XOR.B   #C0,W4L
08892:  BRA     NZ,896E
.................... 			{ 
.................... 				while(!ok) 
08894:  BTSC.B  1594.4
08896:  BRA     896A
.................... 				{ 
.................... 					switch(Etat) 
08898:  MOV.B   15AC,W0L
0889A:  CLR.B   1
0889C:  XOR     #0,W0
0889E:  BRA     Z,88A6
088A0:  XOR     #1,W0
088A2:  BRA     Z,8900
088A4:  BRA     8966
.................... 					{ 
.................... 						case 0: 
.................... 							if(!read) 
088A6:  BTSC.B  1594.5
088A8:  BRA     88C0
.................... 							{ 
.................... 								driver_moteur(0xC0,0); 
088AA:  MOV.B   #C0,W0L
088AC:  MOV.B   W0L,1B2E
088AE:  CLR.B   1B2F
088B0:  CALL    865A
.................... 								ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
088B4:  MOV.B   #C0,W0L
088B6:  MOV.B   W0L,1B2E
088B8:  CALL    86B4
088BC:  MOV     W0,1B2C
.................... 								read = 1; 
088BE:  BSET.B  1594.5
.................... 							} 
.................... 							if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
088C0:  MOV     15AC,W4
088C2:  LSR     W4,#8,W4
088C4:  CP.B    W4L,#1
088C6:  BRA     Z,88F6
.................... 							{ 
.................... 								Etat_driver = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition-250)); 
088C8:  MOV     1B2C,W4
088CA:  SUB     #FA,W4
088CC:  MOV     W4,W5
088CE:  MOV.B   #C0,W0L
088D0:  MOV.B   W0L,1B30
088D2:  MOV.B   #1,W0L
088D4:  MOV.B   W0L,1B31
088D6:  MOV.B   #1,W0L
088D8:  MOV.B   W0L,1B32
088DA:  MOV.B   #1,W0L
088DC:  MOV.B   W0L,1B33
088DE:  PUSH    158E
088E0:  POP     1B34
088E2:  MOV     W5,1B36
088E4:  CLR     W4
088E6:  BTSC.B  1B37.7
088E8:  SETM    W4
088EA:  MOV     W4,1B38
088EC:  CALL    874A
088F0:  MOV.B   W0L,15AD
.................... 							} 
088F2:  GOTO    88FC
.................... 							else 
.................... 							{ 
.................... 								Etat_driver = 0; 
088F6:  CLR.B   15AD
.................... 								Etat++; // passe au depl suivant 
088F8:  INC.B   15AC
.................... 								read = 0; 
088FA:  BCLR.B  1594.5
.................... 							} 
.................... 							break; 
088FC:  GOTO    8966
.................... 						case 1://retourne a la postion  
.................... 							Etat_d = read_driver_moteur(0xC0); 
08900:  MOV.B   #C0,W0L
08902:  MOV.B   W0L,1B38
08904:  CALL    860A
08908:  MOV.B   W0L,15AB
.................... 							if(Etat_d == 0) 
0890A:  CP0.B   15AB
0890C:  BRA     NZ,8962
.................... 							{ 
.................... 								if(!read) 
0890E:  BTSC.B  1594.5
08910:  BRA     892C
.................... 								{ 
.................... 									ActualPosition = ActualPosition - 250; 
08912:  MOV     1B2C,W4
08914:  SUB     #FA,W4
08916:  MOV     W4,1B2C
.................... 									impulses_toDo = EndPosition - ActualPosition ; 
08918:  MOV     1B2C,W0
0891A:  CLR     W1
0891C:  BTSC    W0.F
0891E:  SETM    W1
08920:  MOV     1590,W4
08922:  SUB     W4,W0,W0
08924:  MOV     1592,W4
08926:  SUBB    W4,W1,W1
08928:  MOV     W0,15A8
.................... 									read = 1;   
0892A:  BSET.B  1594.5
.................... 								} 
.................... 								if(Etat_driver!=1) 
0892C:  MOV     15AC,W4
0892E:  LSR     W4,#8,W4
08930:  CP.B    W4L,#1
08932:  BRA     Z,8960
.................... 								{ 
.................... 									Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition + impulses_toDo)); 
08934:  MOV     1B2C,W0
08936:  ADD     15A8,W0
08938:  MOV     W0,W5
0893A:  MOV.B   #C0,W0L
0893C:  MOV.B   W0L,1B30
0893E:  CLR.B   1B31
08940:  MOV.B   #1,W0L
08942:  MOV.B   W0L,1B32
08944:  MOV.B   #1,W0L
08946:  MOV.B   W0L,1B33
08948:  PUSH    158E
0894A:  POP     1B34
0894C:  MOV     W5,1B36
0894E:  CLR     W4
08950:  BTSC.B  1B37.7
08952:  SETM    W4
08954:  MOV     W4,1B38
08956:  CALL    874A
0895A:  MOV.B   W0L,15AD
.................... 									 
.................... 								} 
0895C:  GOTO    8962
.................... 								else 
.................... 								{ 
.................... 									ok = 1;  
08960:  BSET.B  1594.4
.................... 								} 
.................... 							}								 
.................... 							break; 
08962:  GOTO    8966
.................... 					} 
08966:  GOTO    8894
.................... 					} 
.................... 			} 
0896A:  GOTO    898E
.................... 			else if(driver_address==0xC2) __Affichage_erreur(11); // surcharge ejection 
0896E:  MOV     1B2A,W4
08970:  XOR.B   #C2,W4L
08972:  BRA     NZ,8980
08974:  MOV.B   #B,W0L
08976:  MOV.B   W0L,1B2E
08978:  CALL    100E
0897C:  GOTO    898E
.................... 			else if(driver_address==0xC4) __Affichage_erreur(12); // surcharge cremaillere		 
08980:  MOV     1B2A,W4
08982:  XOR.B   #C4,W4L
08984:  BRA     NZ,898E
08986:  MOV.B   #C,W0L
08988:  MOV.B   W0L,1B2E
0898A:  CALL    100E
.................... 			ok = 0; 
0898E:  BCLR.B  1594.4
.................... 			return(0); 
08990:  CLR.B   0
08992:  BRA     8BEE
.................... 			break; 
08994:  GOTO    8BEE
.................... 			 
.................... 		case 3: // surchauffe pont-h 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(16); 
08998:  MOV     1B2A,W4
0899A:  XOR.B   #C0,W4L
0899C:  BRA     NZ,89AC
0899E:  MOV.B   #10,W0L
089A0:  MOV.B   W0L,1B2E
089A2:  CLR.B   1B2F
089A4:  CALL    1060
089A8:  GOTO    89D0
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(17); 
089AC:  MOV     1B2A,W4
089AE:  XOR.B   #C2,W4L
089B0:  BRA     NZ,89C0
089B2:  MOV.B   #11,W0L
089B4:  MOV.B   W0L,1B2E
089B6:  CLR.B   1B2F
089B8:  CALL    1060
089BC:  GOTO    89D0
.................... 			else if(driver_address==0xC4) __Afficheur_7segments(18); 
089C0:  MOV     1B2A,W4
089C2:  XOR.B   #C4,W4L
089C4:  BRA     NZ,89D0
089C6:  MOV.B   #12,W0L
089C8:  MOV.B   W0L,1B2E
089CA:  CLR.B   1B2F
089CC:  CALL    1060
.................... 			 
.................... 			if(Time_ms==0)Time_ms = GameTimeMS; 
089D0:  CP0     15A4
089D2:  BRA     NZ,89E4
089D4:  CP0     15A6
089D6:  BRA     NZ,89E4
089D8:  PUSH    86A
089DA:  POP     15A4
089DC:  PUSH    86C
089DE:  POP     15A6
089E0:  GOTO    8B68
.................... 			else if(GameTimeMS - Time_ms >= TIME_SURCHAUFFE_MS)//on attend 1s 
089E4:  MOV     86A,W4
089E6:  MOV     15A4,W3
089E8:  SUB     W4,W3,W5
089EA:  MOV     86C,W4
089EC:  MOV     15A6,W3
089EE:  SUBB    W4,W3,W6
089F0:  CP      W6,#0
089F2:  BRA     NC,8B68
089F4:  BRA     GTU,89FC
089F6:  MOV     C12,W4
089F8:  CP      W4,W5
089FA:  BRA     GTU,8B68
.................... 			{ 
.................... 				Time_ms = 0; 
089FC:  CLR     15A4
089FE:  CLR     15A6
.................... 				 
.................... 				if(driver_address == 0xC0)//moteur barillet 
08A00:  MOV     1B2A,W4
08A02:  XOR.B   #C0,W4L
08A04:  BRA     NZ,8A60
.................... 				{ 
.................... 					ActualPosition = read_pos_moteur(0xC0); //on reprend l'ordre 
08A06:  MOV.B   #C0,W0L
08A08:  MOV.B   W0L,1B2E
08A0A:  CALL    86B4
08A0E:  MOV     W0,1B2C
.................... 					if((ActualPosition-EndPosition)!= 0) 
08A10:  MOV     1B2C,W0
08A12:  CLR     W1
08A14:  BTSC    W0.F
08A16:  SETM    W1
08A18:  MOV     1590,W4
08A1A:  SUB     W0,W4,W5
08A1C:  MOV     1592,W4
08A1E:  SUBB    W1,W4,W6
08A20:  CP0     W5
08A22:  BRA     NZ,8A28
08A24:  CP0     W6
08A26:  BRA     Z,8A5C
.................... 					{ 
.................... 						impulses_toDo = EndPosition - ActualPosition ;  
08A28:  MOV     1B2C,W0
08A2A:  CLR     W1
08A2C:  BTSC    W0.F
08A2E:  SETM    W1
08A30:  MOV     1590,W4
08A32:  SUB     W4,W0,W0
08A34:  MOV     1592,W4
08A36:  SUBB    W4,W1,W1
08A38:  MOV     W0,15A8
.................... 						go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,impulses_toDo); 
08A3A:  MOV.B   #C0,W0L
08A3C:  MOV.B   W0L,1B30
08A3E:  CLR.B   1B31
08A40:  MOV.B   #1,W0L
08A42:  MOV.B   W0L,1B32
08A44:  MOV.B   #1,W0L
08A46:  MOV.B   W0L,1B33
08A48:  PUSH    158E
08A4A:  POP     1B34
08A4C:  PUSH    15A8
08A4E:  POP     1B36
08A50:  CLR     W4
08A52:  BTSC.B  1B37.7
08A54:  SETM    W4
08A56:  MOV     W4,1B38
08A58:  CALL    874A
.................... 					} 
.................... 				} 
08A5C:  GOTO    8B2C
.................... 				else if(driver_address == 0xC2)//moteur qui couche les modules 
08A60:  MOV     1B2A,W4
08A62:  XOR.B   #C2,W4L
08A64:  BRA     NZ,8AE8
.................... 				{ 
.................... 					if((GameTimeMS-Time_ejection)<Time_ejection_toDo) 
08A66:  MOV     86A,W4
08A68:  MOV     C14,W3
08A6A:  SUB     W4,W3,W5
08A6C:  MOV     86C,W4
08A6E:  MOV     C16,W3
08A70:  SUBB    W4,W3,W6
08A72:  MOV     C1A,W4
08A74:  CP      W4,W6
08A76:  BRA     NC,8AE4
08A78:  BRA     GTU,8A80
08A7A:  MOV     C18,W4
08A7C:  CP      W4,W5
08A7E:  BRA     LEU,8AE4
.................... 					{ 
.................... 						Time_ejection_toDo = Time_ejection_toDo - (GameTimeMS-Time_ejection); //calcul du temps qu'il reste a faire 
08A80:  MOV     86A,W4
08A82:  MOV     C14,W3
08A84:  SUB     W4,W3,W0
08A86:  MOV     86C,W4
08A88:  MOV     C16,W3
08A8A:  SUBB    W4,W3,W1
08A8C:  MOV     C18,W4
08A8E:  SUB     W4,W0,W0
08A90:  MOV     W0,C18
08A92:  MOV     C1A,W4
08A94:  SUBB    W4,W1,W0
08A96:  MOV     W0,C1A
.................... 						//renvoi de la suite de l'ordre 
.................... 						if(Etat_ejection == 1) go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,100,DRV_ARRET_TEMPS, Time_ejection_toDo);						 
08A98:  MOV     14C2,W4
08A9A:  LSR     W4,#8,W4
08A9C:  CP.B    W4L,#1
08A9E:  BRA     NZ,8AC4
08AA0:  MOV.B   #C2,W0L
08AA2:  MOV.B   W0L,1B30
08AA4:  MOV.B   #1,W0L
08AA6:  MOV.B   W0L,1B31
08AA8:  MOV.B   #2,W0L
08AAA:  MOV.B   W0L,1B32
08AAC:  MOV.B   #3,W0L
08AAE:  MOV.B   W0L,1B33
08AB0:  MOV     #64,W4
08AB2:  MOV     W4,1B34
08AB4:  PUSH    C18
08AB6:  POP     1B36
08AB8:  PUSH    C1A
08ABA:  POP     1B38
08ABC:  CALL    874A
08AC0:  GOTO    8AE4
.................... 						else go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,25,DRV_ARRET_TEMPS,Time_ejection_toDo); 
08AC4:  MOV.B   #C2,W0L
08AC6:  MOV.B   W0L,1B30
08AC8:  MOV.B   #1,W0L
08ACA:  MOV.B   W0L,1B31
08ACC:  MOV.B   #2,W0L
08ACE:  MOV.B   W0L,1B32
08AD0:  MOV.B   #3,W0L
08AD2:  MOV.B   W0L,1B33
08AD4:  MOV     #19,W4
08AD6:  MOV     W4,1B34
08AD8:  PUSH    C18
08ADA:  POP     1B36
08ADC:  PUSH    C1A
08ADE:  POP     1B38
08AE0:  CALL    874A
.................... 					}	 
.................... 				} 
08AE4:  GOTO    8B2C
.................... 				else if(driver_address == 0xC4) 
08AE8:  MOV     1B2A,W4
08AEA:  XOR.B   #C4,W4L
08AEC:  BRA     NZ,8B2C
.................... 				{ 
.................... 					if(bras_out)go_driver_moteur(0xC4,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200); // rentre le bras 
08AEE:  BTSS.B  1594.0
08AF0:  BRA     8B10
08AF2:  MOV.B   #C4,W0L
08AF4:  MOV.B   W0L,1B30
08AF6:  CLR.B   1B31
08AF8:  MOV.B   #2,W0L
08AFA:  MOV.B   W0L,1B32
08AFC:  CLR.B   1B33
08AFE:  MOV     #64,W4
08B00:  MOV     W4,1B34
08B02:  MOV     #C8,W4
08B04:  MOV     W4,1B36
08B06:  CLR     1B38
08B08:  CALL    874A
08B0C:  GOTO    8B2C
.................... 					else go_driver_moteur(0xC4,1,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200);	   // sort le bras		 
08B10:  MOV.B   #C4,W0L
08B12:  MOV.B   W0L,1B30
08B14:  MOV.B   #1,W0L
08B16:  MOV.B   W0L,1B31
08B18:  MOV.B   #2,W0L
08B1A:  MOV.B   W0L,1B32
08B1C:  CLR.B   1B33
08B1E:  MOV     #64,W4
08B20:  MOV     W4,1B34
08B22:  MOV     #C8,W4
08B24:  MOV     W4,1B36
08B26:  CLR     1B38
08B28:  CALL    874A
.................... 				} 
.................... 				passage_erreur++; 
08B2C:  INC.B   15AA
.................... 				if(passage_erreur > Erreur_max_surchauffe)// si on a 10 erreurs a la suite de surchauffe 
08B2E:  MOV.B   893,W0L
08B30:  MOV     15AA,W4
08B32:  CP.B    W4L,W0L
08B34:  BRA     LEU,8B68
.................... 				{ 
.................... 					if(driver_address == 0xC0)    __Affichage_erreur(13); //surcahuffe driver barrilet 
08B36:  MOV     1B2A,W4
08B38:  XOR.B   #C0,W4L
08B3A:  BRA     NZ,8B48
08B3C:  MOV.B   #D,W0L
08B3E:  MOV.B   W0L,1B2E
08B40:  CALL    100E
08B44:  GOTO    8B68
.................... 					else if(driver_address==0xC2) __Affichage_erreur(14); //surchauffe driver ejection 
08B48:  MOV     1B2A,W4
08B4A:  XOR.B   #C2,W4L
08B4C:  BRA     NZ,8B5A
08B4E:  MOV.B   #E,W0L
08B50:  MOV.B   W0L,1B2E
08B52:  CALL    100E
08B56:  GOTO    8B68
.................... 					else if(driver_address==0xC4) __Affichage_erreur(15); //surchauffe driver cremaillere	 
08B5A:  MOV     1B2A,W4
08B5C:  XOR.B   #C4,W4L
08B5E:  BRA     NZ,8B68
08B60:  MOV.B   #F,W0L
08B62:  MOV.B   W0L,1B2E
08B64:  CALL    100E
.................... 				} 
.................... 				 
.................... 			} 	 
.................... 			return(0);						 
08B68:  CLR.B   0
08B6A:  BRA     8BEE
.................... 			break; 
08B6C:  GOTO    8BEE
.................... 		case 4://processing 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(13); 
08B70:  MOV     1B2A,W4
08B72:  XOR.B   #C0,W4L
08B74:  BRA     NZ,8B84
08B76:  MOV.B   #D,W0L
08B78:  MOV.B   W0L,1B2E
08B7A:  CLR.B   1B2F
08B7C:  CALL    1060
08B80:  GOTO    8BA8
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(14); 
08B84:  MOV     1B2A,W4
08B86:  XOR.B   #C2,W4L
08B88:  BRA     NZ,8B98
08B8A:  MOV.B   #E,W0L
08B8C:  MOV.B   W0L,1B2E
08B8E:  CLR.B   1B2F
08B90:  CALL    1060
08B94:  GOTO    8BA8
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(15); 
08B98:  MOV     1B2A,W4
08B9A:  XOR.B   #C4,W4L
08B9C:  BRA     NZ,8BA8
08B9E:  MOV.B   #F,W0L
08BA0:  MOV.B   W0L,1B2E
08BA2:  CLR.B   1B2F
08BA4:  CALL    1060
.................... 			return(0);  
08BA8:  CLR.B   0
08BAA:  BRA     8BEE
.................... 			break;  
08BAC:  GOTO    8BEE
.................... 		case 5://slave ne repond pas 
.................... 			if(driver_address == 0xC0)    __Affichage_erreur(16); //driver barillet ne repond pas 
08BB0:  MOV     1B2A,W4
08BB2:  XOR.B   #C0,W4L
08BB4:  BRA     NZ,8BC2
08BB6:  MOV.B   #10,W0L
08BB8:  MOV.B   W0L,1B2E
08BBA:  CALL    100E
08BBE:  GOTO    8BE6
.................... 			else if(driver_address==0xC2) __Affichage_erreur(17); //driver ejection ne repond pas 
08BC2:  MOV     1B2A,W4
08BC4:  XOR.B   #C2,W4L
08BC6:  BRA     NZ,8BD4
08BC8:  MOV.B   #11,W0L
08BCA:  MOV.B   W0L,1B2E
08BCC:  CALL    100E
08BD0:  GOTO    8BE6
.................... 			else if(driver_address==0xC4) __Affichage_erreur(18); //driver cremaillere ne repond pas			 
08BD4:  MOV     1B2A,W4
08BD6:  XOR.B   #C4,W4L
08BD8:  BRA     NZ,8BE6
08BDA:  MOV.B   #12,W0L
08BDC:  MOV.B   W0L,1B2E
08BDE:  CALL    100E
08BE2:  GOTO    8BE6
.................... 			else ;//__Affichage_erreur();	 
.................... 			return(0);			 
08BE6:  CLR.B   0
08BE8:  BRA     8BEE
.................... 			break; 
08BEA:  GOTO    8BEE
.................... 	} 
08BEE:  MOV     [--W15],W6
08BF0:  MOV     [--W15],W5
08BF2:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Deplacement/___Depl.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl 
.................... #define ___Depl 
....................  
....................  
.................... /////////////////  Deplacement Progress  //////////////////////////////// 
.................... float64 amp_limit = 1.6;				 // limite de courant depl progress 
.................... unsigned int16 DIST_SECU_PROGRESS = 100; // distance de secu sur le deplacement progress en mm 
.................... 	 
.................... /////////////////  Localisation  //////////////////////////////// 
.................... signed int16 Dist_x,Dist_y=0; 
.................... signed int16 Pos_x = 0; //en mm 
.................... signed int16 Pos_y = 0;//en mm 
.................... signed int16 Orient_deg = 0; 
.................... float64 Dorient = 0;  
.................... float64 Orient = 0; 
.................... float64 DIAM_ENCO = 3.48139;	// Diamètre des encodeurs, en [cm] 
.................... float64 IMPULSES_ENCO = 5000;	// Nombre d'impulsions de l'encodeur (sans compter le x4 du QEI) 
.................... float64 ENTRAXE_ROUESFOLLES = 29.51922;//31.6006	// Entraxe entre les deux centres des roues folles, en [cm] 
....................  
.................... ///////////////// Calcul //////////////////////////////////////// 
.................... float64 COEFF_D	= (float64) (IMPULSES_ENCO*4)/(DIAM_ENCO*PI);	// Nbre de pas pour 1 [cm] 
.................... float64 CONV_DEG_RAD = (float64) (PI / 180); 
....................  
.................... ////////////////////// Gestion de la reception //////////////////////////////////// 
.................... unsigned int8 RoboteQ_receiveToProceed = 0;	// Position maximale pour la rÃ©ception 
.................... unsigned int8 RoboteQ_receiveLenght = 0;	// Longeur totale de la donnÃ©e 
.................... signed int32 Dist_Do = 0; 
....................  
.................... ///////////////////// Impulsions ////////////////////////////////////////////////// 
.................... signed int32 value_enco_g_start = 0;		//valeur enco debut deplacment 
.................... signed int32 value_enco_d_start = 0;		//valeur enco debut deplacement 
.................... signed int32 value_enco_g_end = 0;			//valeur enco fin deplacment 
.................... signed int32 value_enco_d_end = 0;			//valeur enco fin deplacement	 
....................  
....................  
.................... /////////////////  Prototype fct  //////////////////////////////// 
.................... void __DeplToDo(unsigned int8 _Command);	// 0--> turn, 1--> PaP, 2--> progress, 4-->nothing 
.................... void __Turn(signed int16 _Ang);				 
.................... void __PaP(int16 _X, int16 _Y); 
.................... void __Progress(int16 _X, int16 _Y); 
.................... void __Nothing(void); 
.................... float64 __Get_amp(int channel); 
.................... void __Init_pos(void); 
.................... void __LoadObj(unsigned int16 _Obj); // Charge les différents paramètres des objectifs selon lequel est sélectionné 
.................... float64 __Conv_Ang_4Quadr(float64 _Ang); // Convertit un angle selon le cadran de l'objectif. 
.................... void __Get_enco_value(int1 start_end); 
....................  
.................... #include "Deplacement/___Depl.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl_c 
.................... #define ___Depl_c 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Check_commande_atteint 
.................... //	Auteur :	BORREM 
.................... //	Date:	    18.2.15 
.................... //  Statut :    fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Check si la commande donnÃ© aux moteurs a Ã©tÃ© finie 
.................... void __Check_commande_atteint(void) 
*
06F6A:  MOV     W5,[W15++]
06F6C:  MOV     W6,[W15++]
06F6E:  BCLR.B  1B6C.1
.................... { 
.................... 	int1 comm_atteinte_m1,comm_atteinte_m2 = 0; 
.................... 	fprintf(ROBOTEQ,"?DR\r"); 
06F70:  MOV     #0,W1
06F72:  MOV     W1,W0
06F74:  CLR.B   1
06F76:  CALL    27E
06F7A:  INC     W1,W1
06F7C:  BTSC.B  219.1
06F7E:  BRA     6F7C
06F80:  MOV     W0,21A
06F82:  MOV     #3,W0
06F84:  CPSGT   W1,W0
06F86:  BRA     6F72
.................... //il renvoie DR=x:x 
.................... 	delay_ms(20); 
06F88:  MOV     #14,W0
06F8A:  CALL    E90
.................... //on vÃ©rifie que le premier caractÃ¨re n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] != '!' && RoboteQ_receiveBuffer[0] != '?' && RoboteQ_receiveBuffer[0] != '~' && RoboteQ_receiveBuffer[0] != '^' && RoboteQ_receiveBuffer[0] != '#') 
06F8E:  MOV     894,W4
06F90:  XOR.B   #21,W4L
06F92:  BRA     Z,6FB8
06F94:  MOV     894,W4
06F96:  XOR.B   #3F,W4L
06F98:  BRA     Z,6FB8
06F9A:  MOV     894,W4
06F9C:  XOR.B   #7E,W4L
06F9E:  BRA     Z,6FB8
06FA0:  MOV     894,W4
06FA2:  XOR.B   #5E,W4L
06FA4:  BRA     Z,6FB8
06FA6:  MOV     894,W4
06FA8:  XOR.B   #23,W4L
06FAA:  BRA     Z,6FB8
.................... 	{ 
.................... 		comm_atteinte_m1 = RoboteQ_receiveBuffer[3]; // affectation du premier x dans la variable 
06FAC:  BCLR.B  1B6C.0
06FAE:  BTSC.B  897.0
06FB0:  BSET.B  1B6C.0
.................... 		comm_atteinte_m2 = RoboteQ_receiveBuffer[5]; // affectation du deuxiÃ¨me x dans la variable 
06FB2:  BCLR.B  1B6C.1
06FB4:  BTSC.B  899.0
06FB6:  BSET.B  1B6C.1
.................... 	} 
.................... 	if(comm_atteinte_m1 == 1 && comm_atteinte_m2== 1) // si commande des deux moteurs dini  
06FB8:  BTSS.B  1B6C.0
06FBA:  BRA     6FC2
06FBC:  BTSS.B  1B6C.1
06FBE:  BRA     6FC2
.................... 	{ 
.................... 		flag_depl_ok =1 ; // on peut passer au dÃ©placement suivant 
06FC0:  BSET.B  85A.6
.................... 	} 
06FC2:  MOV     [--W15],W6
06FC4:  MOV     [--W15],W5
06FC6:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_amp(int channel) 
.................... * \brief Recupere la valeur du courant dans les moteurs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] channel--> 1 moteur 1, 2  moteur 2  
.................... * \return Ne retourne rien 
.................... */ 
.................... float64 __Get_amp(int channel) 
*
07E5A:  MOV     W5,[W15++]
07E5C:  MOV     W6,[W15++]
07E5E:  CLR     1B4C
07E60:  MOV.B   #2,W0L
07E62:  MOV.B   W0L,1B4A
.................... { 
.................... 	unsigned int16 ampere = 0; 
.................... 	unsigned int8 i = 2; 
.................... 	if(channel == 1) 
07E64:  MOV     1B48,W4
07E66:  CP      W4,#1
07E68:  BRA     NZ,7E86
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 1\r"); 
07E6A:  MOV     #0,W1
07E6C:  MOV     W1,W0
07E6E:  CLR.B   1
07E70:  CALL    290
07E74:  INC     W1,W1
07E76:  BTSC.B  219.1
07E78:  BRA     7E76
07E7A:  MOV     W0,21A
07E7C:  MOV     #4,W0
07E7E:  CPSGT   W1,W0
07E80:  BRA     7E6C
.................... 	} 
07E82:  GOTO    7E9E
.................... 	else 
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 2\r"); 
07E86:  MOV     #0,W1
07E88:  MOV     W1,W0
07E8A:  CLR.B   1
07E8C:  CALL    2A2
07E90:  INC     W1,W1
07E92:  BTSC.B  219.1
07E94:  BRA     7E92
07E96:  MOV     W0,21A
07E98:  MOV     #4,W0
07E9A:  CPSGT   W1,W0
07E9C:  BRA     7E88
.................... 	}  
.................... 	//il renvoie DR=x:x 
.................... 	delay_ms(10); 
07E9E:  MOV     #A,W0
07EA0:  CALL    E90
.................... 	//on verifie que le premier caractere n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] == 'A') 
07EA4:  MOV     894,W4
07EA6:  XOR.B   #41,W4L
07EA8:  BRA     NZ,7EFA
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= '\r') 
07EAA:  MOV     1B4A,W4
07EAC:  CLR.B   9
07EAE:  MOV     #894,W3
07EB0:  ADD     W4,W3,W0
07EB2:  MOV.B   [W0],W4L
07EB4:  CP.B    W4L,#D
07EB6:  BRA     Z,7EE8
.................... 		{ 
.................... 			if(RoboteQ_receiveBuffer[i]!=0x2D) // 0x2D -> signe '-' en ascii, courant neg -> on prend en abs 
07EB8:  MOV     1B4A,W4
07EBA:  CLR.B   9
07EBC:  MOV     #894,W3
07EBE:  ADD     W4,W3,W0
07EC0:  MOV.B   [W0],W5L
07EC2:  SE      W5,W5
07EC4:  MOV     #2D,W4
07EC6:  CP      W4,W5
07EC8:  BRA     Z,7EE2
.................... 			{ 
.................... 				ampere  *= 10; 
07ECA:  MOV     1B4C,W4
07ECC:  MUL.UU  W4,#A,W0
07ECE:  MOV     W0,1B4C
.................... 				ampere  += RoboteQ_receiveBuffer[i]-0x30; 
07ED0:  MOV     1B4A,W4
07ED2:  CLR.B   9
07ED4:  MOV     #894,W3
07ED6:  ADD     W4,W3,W0
07ED8:  MOV.B   [W0],W5L
07EDA:  SE      W5,W5
07EDC:  MOV     #30,W4
07EDE:  SUB     W5,W4,W0
07EE0:  ADD     1B4C
.................... 			} 
.................... 			i++;  
07EE2:  INC.B   1B4A
07EE4:  GOTO    7EAA
.................... 		} 
.................... 		return(ampere); 
07EE8:  MOV     1B4C,W0
07EEA:  MOV     #0,W1
07EEC:  MOV     #0,W2
07EEE:  MOV     #0,W3
07EF0:  CALL    1B30
07EF4:  BRA     7F04
.................... 	} 
07EF6:  GOTO    7F04
.................... 	else 
.................... 	{ 
.................... 		return(0); 
07EFA:  MOV     #0,W0
07EFC:  MOV     #0,W1
07EFE:  MOV     #0,W2
07F00:  MOV     #0,W3
07F02:  BRA     7F04
.................... 	} 
07F04:  MOV     [--W15],W6
07F06:  MOV     [--W15],W5
07F08:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_enco_value(int1 start_end) 
.................... * \brief Recupere la valeur des encodeurs du robot 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] 1 -> enco au depart, 0 -> enco a la fin 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Get_enco_value(int1 start_end) 
*
07046:  MOV     W5,[W15++]
07048:  MOV     W6,[W15++]
0704A:  MOV.B   #2,W0L
0704C:  MOV.B   W0L,1B6D
0704E:  BCLR.B  1B6E.0
.................... { 
.................... 	unsigned int8 i = 2; 
.................... 	int1 flag_inverted = 0; 
.................... 	if(start_end) // si recuperation enco au depart --> on clear tout 
07050:  CP0.B   1B6C
07052:  BRA     Z,7064
.................... 	{ 
.................... 		value_enco_g_start = 0; 
07054:  CLR     1600
07056:  CLR     1602
.................... 		value_enco_d_start = 0; 
07058:  CLR     1604
0705A:  CLR     1606
.................... 		value_enco_g_end   = 0; 
0705C:  CLR     1608
0705E:  CLR     160A
.................... 		value_enco_d_end   = 0; 
07060:  CLR     160C
07062:  CLR     160E
.................... 	} 
....................  
.................... 	fprintf(ROBOTEQ,"?C\r"); // on demande la valeur des encodeurs 
07064:  BTSC.B  219.1
07066:  BRA     7064
07068:  MOV     #3F,W4
0706A:  MOV     W4,21A
0706C:  BTSC.B  219.1
0706E:  BRA     706C
07070:  MOV     #43,W4
07072:  MOV     W4,21A
07074:  BTSC.B  219.1
07076:  BRA     7074
07078:  MOV     #D,W4
0707A:  MOV     W4,21A
.................... 	delay_ms(20); 
0707C:  MOV     #14,W0
0707E:  CALL    E90
.................... 	 
.................... 	if(RoboteQ_receiveBuffer[0] == 'C') // si on reçoit C=xxxx:xxxx 
07082:  MOV     894,W4
07084:  XOR.B   #43,W4L
07086:  BRA     NZ,723A
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= ':') 
07088:  MOV     1B6C,W4
0708A:  LSR     W4,#8,W4
0708C:  MOV     #894,W3
0708E:  ADD     W4,W3,W0
07090:  MOV.B   [W0],W4L
07092:  XOR.B   #3A,W4L
07094:  BRA     Z,7130
.................... 		{ 
.................... 			if(start_end) 
07096:  CP0.B   1B6C
07098:  BRA     Z,70E4
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
0709A:  MOV     1B6C,W4
0709C:  LSR     W4,#8,W4
0709E:  MOV     #894,W3
070A0:  ADD     W4,W3,W0
070A2:  MOV.B   [W0],W5L
070A4:  SE      W5,W5
070A6:  MOV     #2D,W4
070A8:  CP      W4,W5
070AA:  BRA     NZ,70B2
.................... 				{ 
.................... 					flag_inverted = 1; 
070AC:  BSET.B  1B6E.0
.................... 				} 
070AE:  GOTO    70E0
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_start *= 10; 
070B2:  MOV     1600,W0
070B4:  MOV     1602,W1
070B6:  MOV     #A,W2
070B8:  MOV     #0,W3
070BA:  CALL    628
070BE:  MOV     W0,1600
070C0:  MOV     W1,1602
.................... 					value_enco_g_start += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
070C2:  MOV     1B6C,W4
070C4:  LSR     W4,#8,W4
070C6:  MOV     #894,W3
070C8:  ADD     W4,W3,W0
070CA:  MOV.B   [W0],W5L
070CC:  SE      W5,W5
070CE:  MOV     #30,W4
070D0:  SUB     W5,W4,W0
070D2:  CLR     W1
070D4:  BTSC    W0.F
070D6:  SETM    W1
070D8:  ADD     1600
070DA:  MOV     1602,W4
070DC:  ADDC    W1,W4,W0
070DE:  MOV     W0,1602
.................... 				}				 
.................... 			} 
070E0:  GOTO    712A
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
070E4:  MOV     1B6C,W4
070E6:  LSR     W4,#8,W4
070E8:  MOV     #894,W3
070EA:  ADD     W4,W3,W0
070EC:  MOV.B   [W0],W5L
070EE:  SE      W5,W5
070F0:  MOV     #2D,W4
070F2:  CP      W4,W5
070F4:  BRA     NZ,70FC
.................... 				{ 
.................... 					flag_inverted = 1; 
070F6:  BSET.B  1B6E.0
.................... 				} 
070F8:  GOTO    712A
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_end *= 10; 
070FC:  MOV     1608,W0
070FE:  MOV     160A,W1
07100:  MOV     #A,W2
07102:  MOV     #0,W3
07104:  CALL    628
07108:  MOV     W0,1608
0710A:  MOV     W1,160A
.................... 					value_enco_g_end += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
0710C:  MOV     1B6C,W4
0710E:  LSR     W4,#8,W4
07110:  MOV     #894,W3
07112:  ADD     W4,W3,W0
07114:  MOV.B   [W0],W5L
07116:  SE      W5,W5
07118:  MOV     #30,W4
0711A:  SUB     W5,W4,W0
0711C:  CLR     W1
0711E:  BTSC    W0.F
07120:  SETM    W1
07122:  ADD     1608
07124:  MOV     160A,W4
07126:  ADDC    W1,W4,W0
07128:  MOV     W0,160A
.................... 				} 
.................... 			} 
.................... 			i++; 
0712A:  INC.B   1B6D
0712C:  GOTO    7088
.................... 		} 
.................... 		if(flag_inverted) //si l'on a recu un nbre d'impulses negatifs 
07130:  BTSS.B  1B6E.0
07132:  BRA     7160
.................... 		{ 
.................... 			if(start_end)  
07134:  CP0.B   1B6C
07136:  BRA     Z,714E
.................... 			{ 
.................... 				value_enco_g_start = 0-value_enco_g_start; // on inverse tout 
07138:  MOV     #0,W4
0713A:  MOV     1600,W3
0713C:  SUB     W4,W3,W0
0713E:  MOV     W0,1600
07140:  MOV     #0,W4
07142:  MOV     1602,W3
07144:  SUBB    W4,W3,W0
07146:  MOV     W0,1602
.................... 				flag_inverted = 0; 
07148:  BCLR.B  1B6E.0
.................... 			} 
0714A:  GOTO    7160
.................... 			else 
.................... 			{ 
.................... 				value_enco_g_end = 0-value_enco_g_end;	// on inverse tout 
0714E:  MOV     #0,W4
07150:  MOV     1608,W3
07152:  SUB     W4,W3,W0
07154:  MOV     W0,1608
07156:  MOV     #0,W4
07158:  MOV     160A,W3
0715A:  SUBB    W4,W3,W0
0715C:  MOV     W0,160A
.................... 				flag_inverted = 0; 
0715E:  BCLR.B  1B6E.0
.................... 			} 
.................... 		} 
.................... 		i++; 
07160:  INC.B   1B6D
.................... 		while(RoboteQ_receiveBuffer[i]!='\r')//tant que la transmission n'est pas fini 
07162:  MOV     1B6C,W4
07164:  LSR     W4,#8,W4
07166:  MOV     #894,W3
07168:  ADD     W4,W3,W0
0716A:  MOV.B   [W0],W4L
0716C:  CP.B    W4L,#D
0716E:  BRA     Z,720A
.................... 		{ 
.................... 			if(start_end) 
07170:  CP0.B   1B6C
07172:  BRA     Z,71BE
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
07174:  MOV     1B6C,W4
07176:  LSR     W4,#8,W4
07178:  MOV     #894,W3
0717A:  ADD     W4,W3,W0
0717C:  MOV.B   [W0],W5L
0717E:  SE      W5,W5
07180:  MOV     #2D,W4
07182:  CP      W4,W5
07184:  BRA     NZ,718C
.................... 				{ 
.................... 					flag_inverted = 1; 
07186:  BSET.B  1B6E.0
.................... 				} 
07188:  GOTO    71BA
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_start *= 10; 
0718C:  MOV     1604,W0
0718E:  MOV     1606,W1
07190:  MOV     #A,W2
07192:  MOV     #0,W3
07194:  CALL    628
07198:  MOV     W0,1604
0719A:  MOV     W1,1606
.................... 					value_enco_d_start += RoboteQ_receiveBuffer[i]-0x30; 
0719C:  MOV     1B6C,W4
0719E:  LSR     W4,#8,W4
071A0:  MOV     #894,W3
071A2:  ADD     W4,W3,W0
071A4:  MOV.B   [W0],W5L
071A6:  SE      W5,W5
071A8:  MOV     #30,W4
071AA:  SUB     W5,W4,W0
071AC:  CLR     W1
071AE:  BTSC    W0.F
071B0:  SETM    W1
071B2:  ADD     1604
071B4:  MOV     1606,W4
071B6:  ADDC    W1,W4,W0
071B8:  MOV     W0,1606
.................... 				} 
.................... 			} 
071BA:  GOTO    7204
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
071BE:  MOV     1B6C,W4
071C0:  LSR     W4,#8,W4
071C2:  MOV     #894,W3
071C4:  ADD     W4,W3,W0
071C6:  MOV.B   [W0],W5L
071C8:  SE      W5,W5
071CA:  MOV     #2D,W4
071CC:  CP      W4,W5
071CE:  BRA     NZ,71D6
.................... 				{ 
.................... 					flag_inverted = 1; 
071D0:  BSET.B  1B6E.0
.................... 				} 
071D2:  GOTO    7204
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_end *= 10; 
071D6:  MOV     160C,W0
071D8:  MOV     160E,W1
071DA:  MOV     #A,W2
071DC:  MOV     #0,W3
071DE:  CALL    628
071E2:  MOV     W0,160C
071E4:  MOV     W1,160E
.................... 					value_enco_d_end += RoboteQ_receiveBuffer[i]-0x30;			 
071E6:  MOV     1B6C,W4
071E8:  LSR     W4,#8,W4
071EA:  MOV     #894,W3
071EC:  ADD     W4,W3,W0
071EE:  MOV.B   [W0],W5L
071F0:  SE      W5,W5
071F2:  MOV     #30,W4
071F4:  SUB     W5,W4,W0
071F6:  CLR     W1
071F8:  BTSC    W0.F
071FA:  SETM    W1
071FC:  ADD     160C
071FE:  MOV     160E,W4
07200:  ADDC    W1,W4,W0
07202:  MOV     W0,160E
.................... 				} 
.................... 			} 
.................... 			i++;		 
07204:  INC.B   1B6D
07206:  GOTO    7162
.................... 		} 
.................... 		if(flag_inverted)//si l'on a recu un nbre d'impulses negatifs 
0720A:  BTSS.B  1B6E.0
0720C:  BRA     723A
.................... 		{ 
.................... 			if(start_end) 
0720E:  CP0.B   1B6C
07210:  BRA     Z,7228
.................... 			{ 
.................... 				value_enco_d_start = 0-value_enco_d_start;// on inverse tout 
07212:  MOV     #0,W4
07214:  MOV     1604,W3
07216:  SUB     W4,W3,W0
07218:  MOV     W0,1604
0721A:  MOV     #0,W4
0721C:  MOV     1606,W3
0721E:  SUBB    W4,W3,W0
07220:  MOV     W0,1606
.................... 				flag_inverted = 0; 
07222:  BCLR.B  1B6E.0
.................... 			} 
07224:  GOTO    723A
.................... 			else 
.................... 			{ 
.................... 				value_enco_d_end = 0-value_enco_d_end;// on inverse tout 
07228:  MOV     #0,W4
0722A:  MOV     160C,W3
0722C:  SUB     W4,W3,W0
0722E:  MOV     W0,160C
07230:  MOV     #0,W4
07232:  MOV     160E,W3
07234:  SUBB    W4,W3,W0
07236:  MOV     W0,160E
.................... 				flag_inverted = 0; 
07238:  BCLR.B  1B6E.0
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	if(!start_end) 
0723A:  CP0.B   1B6C
0723C:  BRA     NZ,726C
.................... 	{ 
.................... 		Dist_Do = ((value_enco_g_end-value_enco_g_start)+(value_enco_d_end-value_enco_d_start))/2; // calcul distance parcourue 
0723E:  MOV     1608,W4
07240:  MOV     1600,W3
07242:  SUB     W4,W3,W5
07244:  MOV     160A,W4
07246:  MOV     1602,W3
07248:  SUBB    W4,W3,W6
0724A:  MOV     160C,W4
0724C:  MOV     1604,W3
0724E:  SUB     W4,W3,W0
07250:  MOV     160E,W4
07252:  MOV     1606,W3
07254:  SUBB    W4,W3,W1
07256:  ADD     W0,W5,W5
07258:  ADDC    W1,W6,W6
0725A:  BCLR.B  43.0
0725C:  MOV     W5,W0
0725E:  MOV     W6,W1
07260:  MOV     #2,W2
07262:  MOV     #0,W3
07264:  CALL    6FC8
07268:  MOV     W0,15FC
0726A:  MOV     W1,15FE
.................... 	} 
0726C:  MOV     [--W15],W6
0726E:  MOV     [--W15],W5
07270:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Actual_pos(void) 
.................... * \brief Actualise la position xy du robot s'il doit switcher d'objectifs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] - 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __actual_pos(void) 
*
08C66:  MOV     W5,[W15++]
08C68:  MOV     W6,[W15++]
08C6A:  MOV     W7,[W15++]
08C6C:  MOV     W8,[W15++]
08C6E:  CLR     1B2A
08C70:  CLR     1B2C
08C72:  CLR     1B2E
08C74:  CLR     1B30
08C76:  CLR     1B32
08C78:  CLR     1B34
.................... { 
.................... 	signed int32 Dist_Do_mm = 0; 
.................... 	signed int32 dx = 0; 
.................... 	signed int32 dy = 0; 
.................... 	__Get_enco_value(0); // recuperation delta x,y 
08C7A:  CLR.B   1B6C
08C7C:  CALL    7046
.................... 							 
.................... 	Dist_Do_mm = (signed int32)(Dist_Do/(COEFF_D/10)); 
08C80:  MOV     15EA,W0
08C82:  MOV     15EC,W1
08C84:  MOV     15EE,W2
08C86:  MOV     15F0,W3
08C88:  MOV     #0,W4
08C8A:  MOV     #0,W5
08C8C:  MOV     #0,W6
08C8E:  MOV     #4024,W7
08C90:  CALL    CDC
08C94:  MOV     W0,W5
08C96:  MOV     W1,W6
08C98:  MOV     W2,W7
08C9A:  MOV     W3,W8
08C9C:  MOV     15FC,W0
08C9E:  MOV     15FE,W1
08CA0:  CLR     W3
08CA2:  BTSC    W1.F
08CA4:  SETM    W3
08CA6:  MOV     W3,W2
08CA8:  CALL    12E8
08CAC:  MOV     W5,[W15++]
08CAE:  MOV     W6,[W15++]
08CB0:  MOV     W7,[W15++]
08CB2:  MOV     W5,W4
08CB4:  MOV     W6,W5
08CB6:  MOV     W7,W6
08CB8:  MOV     W8,W7
08CBA:  CALL    CDC
08CBE:  MOV     [--W15],W7
08CC0:  MOV     [--W15],W6
08CC2:  MOV     [--W15],W5
08CC4:  CALL    19EC
08CC8:  MOV     W0,1B2A
08CCA:  MOV     W1,1B2C
.................... 	///////////////////////// Calcul dx,dy //////////////////////////// 
.................... 	if(0 <= Orient && Orient <= PI)//entre 0 et 180deg 
08CCC:  MOV     #0,W0
08CCE:  MOV     #0,W1
08CD0:  MOV     #0,W2
08CD2:  MOV     #0,W3
08CD4:  MOV     15CA,W4
08CD6:  MOV     15CC,W5
08CD8:  MOV     15CE,W6
08CDA:  MOV     15D0,W7
08CDC:  CALL    15EA
08CE0:  BRA     C,8CE4
08CE2:  BRA     NZ,8DB4
08CE4:  MOV     15CA,W0
08CE6:  MOV     15CC,W1
08CE8:  MOV     15CE,W2
08CEA:  MOV     15D0,W3
08CEC:  MOV     #2D18,W4
08CEE:  MOV     #5444,W5
08CF0:  MOV     #21FB,W6
08CF2:  MOV     #4009,W7
08CF4:  CALL    15EA
08CF8:  BRA     C,8CFC
08CFA:  BRA     NZ,8DB4
.................... 	{ 
.................... 		dx =  (signed int16)(cos(Orient) * Dist_Do_mm); 
08CFC:  PUSH    15CA
08CFE:  POP     1B5A
08D00:  PUSH    15CC
08D02:  POP     1B5C
08D04:  PUSH    15CE
08D06:  POP     1B5E
08D08:  PUSH    15D0
08D0A:  POP     1B60
08D0C:  CALL    7F0A
08D10:  MOV     W0,W5
08D12:  MOV     W1,W6
08D14:  MOV     W2,W7
08D16:  MOV     W3,W8
08D18:  MOV     1B2A,W0
08D1A:  MOV     1B2C,W1
08D1C:  CLR     W3
08D1E:  BTSC    W1.F
08D20:  SETM    W3
08D22:  MOV     W3,W2
08D24:  CALL    12E8
08D28:  MOV     W5,[W15++]
08D2A:  MOV     W6,[W15++]
08D2C:  MOV     W7,[W15++]
08D2E:  MOV     W0,W4
08D30:  MOV     W5,W0
08D32:  MOV     W1,W5
08D34:  MOV     W6,W1
08D36:  MOV     W2,W6
08D38:  MOV     W7,W2
08D3A:  MOV     W3,W7
08D3C:  MOV     W8,W3
08D3E:  CALL    BCC
08D42:  MOV     [--W15],W7
08D44:  MOV     [--W15],W6
08D46:  MOV     [--W15],W5
08D48:  CALL    19EC
08D4C:  CLR     W1
08D4E:  BTSC    W0.F
08D50:  SETM    W1
08D52:  MOV     W0,1B2E
08D54:  MOV     W1,1B30
.................... 		dy =  (signed int16)(sin(Orient) * Dist_Do_mm);	 
08D56:  PUSH    15CA
08D58:  POP     1B48
08D5A:  PUSH    15CC
08D5C:  POP     1B4A
08D5E:  PUSH    15CE
08D60:  POP     1B4C
08D62:  PUSH    15D0
08D64:  POP     1B4E
08D66:  CALL    81C4
08D6A:  MOV     W0,W5
08D6C:  MOV     W1,W6
08D6E:  MOV     W2,W7
08D70:  MOV     W3,W8
08D72:  MOV     1B2A,W0
08D74:  MOV     1B2C,W1
08D76:  CLR     W3
08D78:  BTSC    W1.F
08D7A:  SETM    W3
08D7C:  MOV     W3,W2
08D7E:  CALL    12E8
08D82:  MOV     W5,[W15++]
08D84:  MOV     W6,[W15++]
08D86:  MOV     W7,[W15++]
08D88:  MOV     W0,W4
08D8A:  MOV     W5,W0
08D8C:  MOV     W1,W5
08D8E:  MOV     W6,W1
08D90:  MOV     W2,W6
08D92:  MOV     W7,W2
08D94:  MOV     W3,W7
08D96:  MOV     W8,W3
08D98:  CALL    BCC
08D9C:  MOV     [--W15],W7
08D9E:  MOV     [--W15],W6
08DA0:  MOV     [--W15],W5
08DA2:  CALL    19EC
08DA6:  CLR     W1
08DA8:  BTSC    W0.F
08DAA:  SETM    W1
08DAC:  MOV     W0,1B32
08DAE:  MOV     W1,1B34
.................... 	} 
08DB0:  GOTO    904C
.................... 	else if(( (Orient>PI) && ((3*PI)/2 >= Orient)) || (Orient <= (-PI/2) && Orient > -PI))//180 et 270deg 
08DB4:  MOV     #2D18,W0
08DB6:  MOV     #5444,W1
08DB8:  MOV     #21FB,W2
08DBA:  MOV     #4009,W3
08DBC:  MOV     15CA,W4
08DBE:  MOV     15CC,W5
08DC0:  MOV     15CE,W6
08DC2:  MOV     15D0,W7
08DC4:  CALL    15EA
08DC8:  BRA     NC,8DE2
08DCA:  MOV     15CA,W0
08DCC:  MOV     15CC,W1
08DCE:  MOV     15CE,W2
08DD0:  MOV     15D0,W3
08DD2:  MOV     #21D2,W4
08DD4:  MOV     #7F33,W5
08DD6:  MOV     #D97C,W6
08DD8:  MOV     #4012,W7
08DDA:  CALL    15EA
08DDE:  BRA     C,8E10
08DE0:  BRA     Z,8E10
08DE2:  MOV     15CA,W0
08DE4:  MOV     15CC,W1
08DE6:  MOV     15CE,W2
08DE8:  MOV     15D0,W3
08DEA:  MOV     #2D18,W4
08DEC:  MOV     #5444,W5
08DEE:  MOV     #21FB,W6
08DF0:  MOV     #BFF9,W7
08DF2:  CALL    15EA
08DF6:  BRA     C,8DFA
08DF8:  BRA     NZ,8F04
08DFA:  MOV     #2D18,W0
08DFC:  MOV     #5444,W1
08DFE:  MOV     #21FB,W2
08E00:  MOV     #C009,W3
08E02:  MOV     15CA,W4
08E04:  MOV     15CC,W5
08E06:  MOV     15CE,W6
08E08:  MOV     15D0,W7
08E0A:  CALL    15EA
08E0E:  BRA     NC,8F04
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm; 
08E10:  MOV     #0,W4
08E12:  MOV     1B2A,W3
08E14:  SUB     W4,W3,W0
08E16:  MOV     W0,1B2A
08E18:  MOV     #0,W4
08E1A:  MOV     1B2C,W3
08E1C:  SUBB    W4,W3,W0
08E1E:  MOV     W0,1B2C
.................... 		dx = (signed int16)(sin(3*(PI/2)-Orient) * Dist_Do_mm); 
08E20:  BSET.B  43.0
08E22:  MOV     #21D2,W0
08E24:  MOV     #7F33,W1
08E26:  MOV     #D97C,W2
08E28:  MOV     #4012,W3
08E2A:  MOV     15CA,W4
08E2C:  MOV     15CC,W5
08E2E:  MOV     15CE,W6
08E30:  MOV     15D0,W7
08E32:  CALL    13FC
08E36:  MOV     W0,W5
08E38:  MOV     W1,W6
08E3A:  MOV     W2,W7
08E3C:  MOV     W3,W8
08E3E:  MOV     W5,1B48
08E40:  MOV     W6,1B4A
08E42:  MOV     W7,1B4C
08E44:  MOV     W8,1B4E
08E46:  CALL    81C4
08E4A:  MOV     W0,W5
08E4C:  MOV     W1,W6
08E4E:  MOV     W2,W7
08E50:  MOV     W3,W8
08E52:  MOV     1B2A,W0
08E54:  MOV     1B2C,W1
08E56:  CLR     W3
08E58:  BTSC    W1.F
08E5A:  SETM    W3
08E5C:  MOV     W3,W2
08E5E:  CALL    12E8
08E62:  MOV     W5,[W15++]
08E64:  MOV     W6,[W15++]
08E66:  MOV     W7,[W15++]
08E68:  MOV     W0,W4
08E6A:  MOV     W5,W0
08E6C:  MOV     W1,W5
08E6E:  MOV     W6,W1
08E70:  MOV     W2,W6
08E72:  MOV     W7,W2
08E74:  MOV     W3,W7
08E76:  MOV     W8,W3
08E78:  CALL    BCC
08E7C:  MOV     [--W15],W7
08E7E:  MOV     [--W15],W6
08E80:  MOV     [--W15],W5
08E82:  CALL    19EC
08E86:  CLR     W1
08E88:  BTSC    W0.F
08E8A:  SETM    W1
08E8C:  MOV     W0,1B2E
08E8E:  MOV     W1,1B30
.................... 		dy = (signed int16)(cos(3*(PI/2)-Orient) * Dist_Do_mm); 
08E90:  BSET.B  43.0
08E92:  MOV     #21D2,W0
08E94:  MOV     #7F33,W1
08E96:  MOV     #D97C,W2
08E98:  MOV     #4012,W3
08E9A:  MOV     15CA,W4
08E9C:  MOV     15CC,W5
08E9E:  MOV     15CE,W6
08EA0:  MOV     15D0,W7
08EA2:  CALL    13FC
08EA6:  MOV     W0,W5
08EA8:  MOV     W1,W6
08EAA:  MOV     W2,W7
08EAC:  MOV     W3,W8
08EAE:  MOV     W5,1B5A
08EB0:  MOV     W6,1B5C
08EB2:  MOV     W7,1B5E
08EB4:  MOV     W8,1B60
08EB6:  CALL    7F0A
08EBA:  MOV     W0,W5
08EBC:  MOV     W1,W6
08EBE:  MOV     W2,W7
08EC0:  MOV     W3,W8
08EC2:  MOV     1B2A,W0
08EC4:  MOV     1B2C,W1
08EC6:  CLR     W3
08EC8:  BTSC    W1.F
08ECA:  SETM    W3
08ECC:  MOV     W3,W2
08ECE:  CALL    12E8
08ED2:  MOV     W5,[W15++]
08ED4:  MOV     W6,[W15++]
08ED6:  MOV     W7,[W15++]
08ED8:  MOV     W0,W4
08EDA:  MOV     W5,W0
08EDC:  MOV     W1,W5
08EDE:  MOV     W6,W1
08EE0:  MOV     W2,W6
08EE2:  MOV     W7,W2
08EE4:  MOV     W3,W7
08EE6:  MOV     W8,W3
08EE8:  CALL    BCC
08EEC:  MOV     [--W15],W7
08EEE:  MOV     [--W15],W6
08EF0:  MOV     [--W15],W5
08EF2:  CALL    19EC
08EF6:  CLR     W1
08EF8:  BTSC    W0.F
08EFA:  SETM    W1
08EFC:  MOV     W0,1B32
08EFE:  MOV     W1,1B34
.................... 	} 
08F00:  GOTO    904C
.................... 	else if(((Orient>(3*PI/2)) && (Orient < (2*PI))) || (Orient < 0 && Orient > (-PI/2)))//270deg et 360deg 
08F04:  MOV     #21D2,W0
08F06:  MOV     #7F33,W1
08F08:  MOV     #D97C,W2
08F0A:  MOV     #4012,W3
08F0C:  MOV     15CA,W4
08F0E:  MOV     15CC,W5
08F10:  MOV     15CE,W6
08F12:  MOV     15D0,W7
08F14:  CALL    15EA
08F18:  BRA     NC,8F30
08F1A:  MOV     15CA,W0
08F1C:  MOV     15CC,W1
08F1E:  MOV     15CE,W2
08F20:  MOV     15D0,W3
08F22:  MOV     #2D18,W4
08F24:  MOV     #5444,W5
08F26:  MOV     #21FB,W6
08F28:  MOV     #4019,W7
08F2A:  CALL    15EA
08F2E:  BRA     C,8F5C
08F30:  MOV     15CA,W0
08F32:  MOV     15CC,W1
08F34:  MOV     15CE,W2
08F36:  MOV     15D0,W3
08F38:  MOV     #0,W4
08F3A:  MOV     #0,W5
08F3C:  MOV     #0,W6
08F3E:  MOV     #0,W7
08F40:  CALL    15EA
08F44:  BRA     NC,904C
08F46:  MOV     #2D18,W0
08F48:  MOV     #5444,W1
08F4A:  MOV     #21FB,W2
08F4C:  MOV     #BFF9,W3
08F4E:  MOV     15CA,W4
08F50:  MOV     15CC,W5
08F52:  MOV     15CE,W6
08F54:  MOV     15D0,W7
08F56:  CALL    15EA
08F5A:  BRA     NC,904C
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm;  
08F5C:  MOV     #0,W4
08F5E:  MOV     1B2A,W3
08F60:  SUB     W4,W3,W0
08F62:  MOV     W0,1B2A
08F64:  MOV     #0,W4
08F66:  MOV     1B2C,W3
08F68:  SUBB    W4,W3,W0
08F6A:  MOV     W0,1B2C
.................... 		dx = (signed int16)(sin(-(PI/2)-Orient) * Dist_Do_mm); 
08F6C:  BSET.B  43.0
08F6E:  MOV     #2D18,W0
08F70:  MOV     #5444,W1
08F72:  MOV     #21FB,W2
08F74:  MOV     #BFF9,W3
08F76:  MOV     15CA,W4
08F78:  MOV     15CC,W5
08F7A:  MOV     15CE,W6
08F7C:  MOV     15D0,W7
08F7E:  CALL    13FC
08F82:  MOV     W0,W5
08F84:  MOV     W1,W6
08F86:  MOV     W2,W7
08F88:  MOV     W3,W8
08F8A:  MOV     W5,1B48
08F8C:  MOV     W6,1B4A
08F8E:  MOV     W7,1B4C
08F90:  MOV     W8,1B4E
08F92:  CALL    81C4
08F96:  MOV     W0,W5
08F98:  MOV     W1,W6
08F9A:  MOV     W2,W7
08F9C:  MOV     W3,W8
08F9E:  MOV     1B2A,W0
08FA0:  MOV     1B2C,W1
08FA2:  CLR     W3
08FA4:  BTSC    W1.F
08FA6:  SETM    W3
08FA8:  MOV     W3,W2
08FAA:  CALL    12E8
08FAE:  MOV     W5,[W15++]
08FB0:  MOV     W6,[W15++]
08FB2:  MOV     W7,[W15++]
08FB4:  MOV     W0,W4
08FB6:  MOV     W5,W0
08FB8:  MOV     W1,W5
08FBA:  MOV     W6,W1
08FBC:  MOV     W2,W6
08FBE:  MOV     W7,W2
08FC0:  MOV     W3,W7
08FC2:  MOV     W8,W3
08FC4:  CALL    BCC
08FC8:  MOV     [--W15],W7
08FCA:  MOV     [--W15],W6
08FCC:  MOV     [--W15],W5
08FCE:  CALL    19EC
08FD2:  CLR     W1
08FD4:  BTSC    W0.F
08FD6:  SETM    W1
08FD8:  MOV     W0,1B2E
08FDA:  MOV     W1,1B30
.................... 		dy = (signed int16)(cos(-(PI/2)-Orient) * Dist_Do_mm); 
08FDC:  BSET.B  43.0
08FDE:  MOV     #2D18,W0
08FE0:  MOV     #5444,W1
08FE2:  MOV     #21FB,W2
08FE4:  MOV     #BFF9,W3
08FE6:  MOV     15CA,W4
08FE8:  MOV     15CC,W5
08FEA:  MOV     15CE,W6
08FEC:  MOV     15D0,W7
08FEE:  CALL    13FC
08FF2:  MOV     W0,W5
08FF4:  MOV     W1,W6
08FF6:  MOV     W2,W7
08FF8:  MOV     W3,W8
08FFA:  MOV     W5,1B5A
08FFC:  MOV     W6,1B5C
08FFE:  MOV     W7,1B5E
09000:  MOV     W8,1B60
09002:  CALL    7F0A
09006:  MOV     W0,W5
09008:  MOV     W1,W6
0900A:  MOV     W2,W7
0900C:  MOV     W3,W8
0900E:  MOV     1B2A,W0
09010:  MOV     1B2C,W1
09012:  CLR     W3
09014:  BTSC    W1.F
09016:  SETM    W3
09018:  MOV     W3,W2
0901A:  CALL    12E8
0901E:  MOV     W5,[W15++]
09020:  MOV     W6,[W15++]
09022:  MOV     W7,[W15++]
09024:  MOV     W0,W4
09026:  MOV     W5,W0
09028:  MOV     W1,W5
0902A:  MOV     W6,W1
0902C:  MOV     W2,W6
0902E:  MOV     W7,W2
09030:  MOV     W3,W7
09032:  MOV     W8,W3
09034:  CALL    BCC
09038:  MOV     [--W15],W7
0903A:  MOV     [--W15],W6
0903C:  MOV     [--W15],W5
0903E:  CALL    19EC
09042:  CLR     W1
09044:  BTSC    W0.F
09046:  SETM    W1
09048:  MOV     W0,1B32
0904A:  MOV     W1,1B34
.................... 	} 
.................... 	Pos_x = (signed int16)(Pos_x + dx); //mise a jour pos x 
0904C:  MOV     15BC,W0
0904E:  CLR     W1
09050:  BTSC    W0.F
09052:  SETM    W1
09054:  MOV     1B2E,W4
09056:  ADD     W0,W4,W0
09058:  MOV     1B30,W4
0905A:  ADDC    W1,W4,W1
0905C:  MOV     W0,15BC
.................... 	Pos_y = (signed int16)(Pos_y + dy);	//mise a jour pos y 
0905E:  MOV     15BE,W0
09060:  CLR     W1
09062:  BTSC    W0.F
09064:  SETM    W1
09066:  MOV     1B32,W4
09068:  ADD     W0,W4,W0
0906A:  MOV     1B34,W4
0906C:  ADDC    W1,W4,W1
0906E:  MOV     W0,15BE
09070:  MOV     [--W15],W8
09072:  MOV     [--W15],W7
09074:  MOV     [--W15],W6
09076:  MOV     [--W15],W5
09078:  RETURN  
.................... } 
.................... /* 
.................... 	Borgeat Rémy 
....................  
.................... 	20.2.2017 
....................  
.................... 	Initialise la postion de départ du robot. 
.................... 	Gere le cote duquel se trouve le robot 
.................... */ 
.................... void __Init_pos(void) 
*
01352:  MOV     W5,[W15++]
01354:  MOV     W6,[W15++]
01356:  MOV     W7,[W15++]
01358:  MOV     W8,[W15++]
.................... { 
.................... 	Pos_x = read_eeprom(800); 
0135A:  MOV     #320,W3
0135C:  MOV     #0,W4
0135E:  MOV     #2,W5
01360:  CALL    1236
01364:  MOV     W0,15BC
.................... 	Pos_y = read_eeprom(802); 
01366:  MOV     #322,W3
01368:  MOV     #0,W4
0136A:  MOV     #2,W5
0136C:  CALL    1236
01370:  MOV     W0,15BE
.................... 	Orient_deg = read_eeprom(804); 
01372:  MOV     #324,W3
01374:  MOV     #0,W4
01376:  MOV     #2,W5
01378:  CALL    1236
0137C:  MOV     W0,15C0
....................  
.................... 	//si on est de l'autre cote du terrain 
.................... 	if(_TEAM) 
0137E:  BTSS.B  2C3.4
01380:  BRA     13A6
.................... 	{ 
.................... 		Pos_x = TableWidth-Pos_x; 
01382:  MOV     890,W4
01384:  MOV     15BC,W3
01386:  SUB     W4,W3,W0
01388:  MOV     W0,15BC
.................... 		if(Orient_deg<=180)Orient_deg=180-Orient_deg ; 
0138A:  MOV     15C0,W4
0138C:  MOV     #B4,W3
0138E:  CP      W3,W4
01390:  BRA     LT,139E
01392:  MOV     #B4,W4
01394:  MOV     15C0,W3
01396:  SUB     W4,W3,W0
01398:  MOV     W0,15C0
0139A:  GOTO    13A6
.................... 		else Orient_deg = 540 - Orient_deg ; 
0139E:  MOV     #21C,W4
013A0:  MOV     15C0,W3
013A2:  SUB     W4,W3,W0
013A4:  MOV     W0,15C0
.................... 	}		 
.................... 	Orient = (float64)(Orient_deg*PI/180); 
013A6:  MOV     15C0,W0
013A8:  CLR     W3
013AA:  BTSC    W0.F
013AC:  SETM    W3
013AE:  MOV     W3,W1
013B0:  MOV     W3,W2
013B2:  CALL    12E8
013B6:  MOV     #2D18,W4
013B8:  MOV     #5444,W5
013BA:  MOV     #21FB,W6
013BC:  MOV     #4009,W7
013BE:  CALL    BCC
013C2:  MOV     W0,W5
013C4:  MOV     W1,W6
013C6:  MOV     W2,W7
013C8:  MOV     W3,W8
013CA:  MOV     W5,[W15++]
013CC:  MOV     W6,[W15++]
013CE:  MOV     W7,[W15++]
013D0:  MOV     W5,W0
013D2:  MOV     W6,W1
013D4:  MOV     W7,W2
013D6:  MOV     W8,W3
013D8:  MOV     #0,W4
013DA:  MOV     #0,W5
013DC:  MOV     #8000,W6
013DE:  MOV     #4066,W7
013E0:  CALL    CDC
013E4:  MOV     [--W15],W7
013E6:  MOV     [--W15],W6
013E8:  MOV     [--W15],W5
013EA:  MOV     W0,15CA
013EC:  MOV     W1,15CC
013EE:  MOV     W2,15CE
013F0:  MOV     W3,15D0
013F2:  MOV     [--W15],W8
013F4:  MOV     [--W15],W7
013F6:  MOV     [--W15],W6
013F8:  MOV     [--W15],W5
013FA:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __Action_Writting(unsigned int8 _Command) 
.................... * \brief Demande d'Ã©criture, entre 0x00 et 0x79. 
.................... * 
.................... * \author Barman Corentin / rev. Amand Axel 
.................... * \version 2.0 
.................... * \date 19.11.2015 
.................... * 
.................... * \param[in] _Command Choisit la commande Ã  effectuer 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __DeplToDo(unsigned int8 _Command) 
.................... { 
.................... 	switch(_Command) 
*
08580:  MOV.B   1B2A,W0L
08582:  CLR.B   1
08584:  XOR     #0,W0
08586:  BRA     Z,8596
08588:  XOR     #1,W0
0858A:  BRA     Z,85A2
0858C:  XOR     #3,W0
0858E:  BRA     Z,85B2
08590:  XOR     #1,W0
08592:  BRA     Z,85C2
08594:  BRA     85CA
.................... 	{ 
.................... 		// !!! En ajoutant des types de dÃ©placement, 
.................... 		//		pensez Ã  les gÃ©rer dans __LoadObj() tout en bas du fichier. 
.................... 		//		Comme le X est par exemple utiliser pour donner un angle, 
.................... 		//		si comme un dÃ©pl. PÃ P vous faÃ®tes TailleTable - X .... 
.................... 		//		Autant dire que le robot va faire n'importe quoi ^^ 
.................... 		case 0 : 
.................... 			__Turn((signed int16) oXp);			 
08596:  PUSH    14A4
08598:  POP     1B2C
0859A:  CALL    67C8
.................... 			break; 
0859E:  GOTO    85D6
.................... 		case 1 : 
.................... 			__PaP(oXp, oYp); 
085A2:  PUSH    14A4
085A4:  POP     1B30
085A6:  PUSH    14A6
085A8:  POP     1B32
085AA:  CALL    72AC
.................... 			break; 
085AE:  GOTO    85D6
.................... 		case 2 : 
.................... 			__Progress(oXp, oYp); //se déplace d'une certaine distance, jusqu'a ce qu'on tape dans un bord, ou que l'ordre soit fini 
085B2:  PUSH    14A4
085B4:  POP     1B2C
085B6:  PUSH    14A6
085B8:  POP     1B2E
085BA:  CALL    8200
.................... 			break; 
085BE:  GOTO    85D6
.................... 		case 3 : 
.................... 			__Nothing(); 
085C2:  CALL    8578
.................... 			break; 
085C6:  GOTO    85D6
.................... 		default: 
.................... 			__Affichage_erreur(4); 
085CA:  MOV.B   #4,W0L
085CC:  MOV.B   W0L,1B2E
085CE:  CALL    100E
.................... 			break; 
085D2:  GOTO    85D6
.................... 	} 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
085D6:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Turn(signed int16 _Ang) 
.................... * \brief Tourne sur place jusqu'a l'angle donne. 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] Angle d'arrive  
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Turn(signed int16 _Ang) 
*
067C8:  MOV     W5,[W15++]
067CA:  MOV     W6,[W15++]
067CC:  MOV     W7,[W15++]
067CE:  MOV     W8,[W15++]
067D0:  CLR     1B2E
067D2:  CLR     1B30
067D4:  CLR     1B32
067D6:  CLR     1B34
067D8:  CLR     1B36
067DA:  CLR     1B38
067DC:  CLR     1B3A
067DE:  CLR     1B3C
067E0:  CLR     1B3E
067E2:  CLR     1B40
067E4:  CLR     1B42
067E6:  CLR     1B44
067E8:  CLR     1B46
067EA:  CLR     1B48
.................... { 
.................... 	float64 AngToDo = 0;			 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer en nombre d'impulses 
.................... 	signed int32 impulse_g = 0; 	//impulse mot g 
.................... 	signed int32 impulse_d = 0;		//impulse mot d 
.................... 	float64 temporaire = 0; 
....................  
.................... 	// Convertit la valeur de l'angle en radian 
.................... 	AngToDo = (_Ang * CONV_DEG_RAD) - Orient ; 
067EC:  MOV     1B2C,W0
067EE:  CLR     W3
067F0:  BTSC    W0.F
067F2:  SETM    W3
067F4:  MOV     W3,W1
067F6:  MOV     W3,W2
067F8:  CALL    12E8
067FC:  MOV     15F2,W4
067FE:  MOV     15F4,W5
06800:  MOV     15F6,W6
06802:  MOV     15F8,W7
06804:  CALL    BCC
06808:  MOV     W0,W5
0680A:  MOV     W1,W6
0680C:  MOV     W2,W7
0680E:  MOV     W3,W8
06810:  BSET.B  43.0
06812:  MOV     W5,[W15++]
06814:  MOV     W6,[W15++]
06816:  MOV     W7,[W15++]
06818:  MOV     W5,W0
0681A:  MOV     W6,W1
0681C:  MOV     W7,W2
0681E:  MOV     W8,W3
06820:  MOV     15CA,W4
06822:  MOV     15CC,W5
06824:  MOV     15CE,W6
06826:  MOV     15D0,W7
06828:  CALL    13FC
0682C:  MOV     [--W15],W7
0682E:  MOV     [--W15],W6
06830:  MOV     [--W15],W5
06832:  MOV     W0,1B2E
06834:  MOV     W1,1B30
06836:  MOV     W2,1B32
06838:  MOV     W3,1B34
....................  
.................... 	if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
0683A:  MOV     14AC,W4
0683C:  CP      W4,#2
0683E:  BRA     NZ,6878
06840:  MOV     #0,W0
06842:  MOV     #0,W1
06844:  MOV     #0,W2
06846:  MOV     #0,W3
06848:  MOV     1B2E,W4
0684A:  MOV     1B30,W5
0684C:  MOV     1B32,W6
0684E:  MOV     1B34,W7
06850:  CALL    15EA
06854:  BRA     NC,6878
.................... 	{ 
.................... 		AngToDo += -2 * PI; //on tourne sur la gauche 
06856:  BCLR.B  43.0
06858:  MOV     1B2E,W0
0685A:  MOV     1B30,W1
0685C:  MOV     1B32,W2
0685E:  MOV     1B34,W3
06860:  MOV     #2D18,W4
06862:  MOV     #5444,W5
06864:  MOV     #21FB,W6
06866:  MOV     #C019,W7
06868:  CALL    13FC
0686C:  MOV     W0,1B2E
0686E:  MOV     W1,1B30
06870:  MOV     W2,1B32
06872:  MOV     W3,1B34
.................... 	}	 
06874:  GOTO    68B2
.................... 	else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
06878:  MOV     14AC,W4
0687A:  CP      W4,#1
0687C:  BRA     NZ,68B2
0687E:  MOV     1B2E,W0
06880:  MOV     1B30,W1
06882:  MOV     1B32,W2
06884:  MOV     1B34,W3
06886:  MOV     #0,W4
06888:  MOV     #0,W5
0688A:  MOV     #0,W6
0688C:  MOV     #0,W7
0688E:  CALL    15EA
06892:  BRA     NC,68B2
.................... 	{ 
.................... 		AngToDo += 2 * PI;//On tourne sur la droite	 
06894:  BCLR.B  43.0
06896:  MOV     1B2E,W0
06898:  MOV     1B30,W1
0689A:  MOV     1B32,W2
0689C:  MOV     1B34,W3
0689E:  MOV     #2D18,W4
068A0:  MOV     #5444,W5
068A2:  MOV     #21FB,W6
068A4:  MOV     #4019,W7
068A6:  CALL    13FC
068AA:  MOV     W0,1B2E
068AC:  MOV     W1,1B30
068AE:  MOV     W2,1B32
068B0:  MOV     W3,1B34
.................... 	} 
.................... 	 
.................... 	if(AngToDo > PI && oCoteTourn==0) // on a plus de 180Â° 
068B2:  MOV     #2D18,W0
068B4:  MOV     #5444,W1
068B6:  MOV     #21FB,W2
068B8:  MOV     #4009,W3
068BA:  MOV     1B2E,W4
068BC:  MOV     1B30,W5
068BE:  MOV     1B32,W6
068C0:  MOV     1B34,W7
068C2:  CALL    15EA
068C6:  BRA     NC,68EE
068C8:  CP0     14AC
068CA:  BRA     NZ,68EE
.................... 	{ 
.................... 		AngToDo -= 2*PI; // on tourne ds l'autre sens 
068CC:  BSET.B  43.0
068CE:  MOV     1B2E,W0
068D0:  MOV     1B30,W1
068D2:  MOV     1B32,W2
068D4:  MOV     1B34,W3
068D6:  MOV     #2D18,W4
068D8:  MOV     #5444,W5
068DA:  MOV     #21FB,W6
068DC:  MOV     #4019,W7
068DE:  CALL    13FC
068E2:  MOV     W0,1B2E
068E4:  MOV     W1,1B30
068E6:  MOV     W2,1B32
068E8:  MOV     W3,1B34
.................... 	} 
068EA:  GOTO    6926
.................... 	else if(AngToDo < -PI  && oCoteTourn==0) // si on moins que -180Â°   
068EE:  MOV     1B2E,W0
068F0:  MOV     1B30,W1
068F2:  MOV     1B32,W2
068F4:  MOV     1B34,W3
068F6:  MOV     #2D18,W4
068F8:  MOV     #5444,W5
068FA:  MOV     #21FB,W6
068FC:  MOV     #C009,W7
068FE:  CALL    15EA
06902:  BRA     NC,6926
06904:  CP0     14AC
06906:  BRA     NZ,6926
.................... 	{ 
.................... 		AngToDo += 2 * PI; // on tourne ds l'autre sens 
06908:  BCLR.B  43.0
0690A:  MOV     1B2E,W0
0690C:  MOV     1B30,W1
0690E:  MOV     1B32,W2
06910:  MOV     1B34,W3
06912:  MOV     #2D18,W4
06914:  MOV     #5444,W5
06916:  MOV     #21FB,W6
06918:  MOV     #4019,W7
0691A:  CALL    13FC
0691E:  MOV     W0,1B2E
06920:  MOV     W1,1B30
06922:  MOV     W2,1B32
06924:  MOV     W3,1B34
.................... 	}	 
....................  
.................... 	if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
06926:  MOV     #432D,W0
06928:  MOV     #EB1C,W1
0692A:  MOV     #36E2,W2
0692C:  MOV     #BF1A,W3
0692E:  MOV     1B2E,W4
06930:  MOV     1B30,W5
06932:  MOV     1B32,W6
06934:  MOV     1B34,W7
06936:  CALL    15EA
0693A:  BRA     NC,695A
0693C:  MOV     1B2E,W0
0693E:  MOV     1B30,W1
06940:  MOV     1B32,W2
06942:  MOV     1B34,W3
06944:  MOV     #432D,W4
06946:  MOV     #EB1C,W5
06948:  MOV     #36E2,W6
0694A:  MOV     #3F1A,W7
0694C:  CALL    15EA
06950:  BRA     NC,695A
06952:  CLR     1B2E
06954:  CLR     1B30
06956:  CLR     1B32
06958:  CLR     1B34
.................... 	temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
0695A:  MOV     15E2,W0
0695C:  MOV     15E4,W1
0695E:  MOV     15E6,W2
06960:  MOV     15E8,W3
06962:  MOV     15D2,W4
06964:  MOV     15D4,W5
06966:  MOV     15D6,W6
06968:  MOV     15D8,W7
0696A:  CALL    CDC
0696E:  MOV     W0,W4
06970:  MOV     W1,W5
06972:  MOV     W2,W6
06974:  MOV     W3,W7
06976:  MOV     1B2E,W0
06978:  MOV     1B30,W1
0697A:  MOV     1B32,W2
0697C:  MOV     1B34,W3
0697E:  CALL    BCC
06982:  MOV     W0,W5
06984:  MOV     W1,W6
06986:  MOV     W2,W7
06988:  MOV     W3,W8
0698A:  MOV     W5,[W15++]
0698C:  MOV     W6,[W15++]
0698E:  MOV     W7,[W15++]
06990:  MOV     W5,W0
06992:  MOV     W6,W1
06994:  MOV     W7,W2
06996:  MOV     W8,W3
06998:  MOV     15DA,W4
0699A:  MOV     15DC,W5
0699C:  MOV     15DE,W6
0699E:  MOV     15E0,W7
069A0:  CALL    BCC
069A4:  MOV     [--W15],W7
069A6:  MOV     [--W15],W6
069A8:  MOV     [--W15],W5
069AA:  MOV     W0,W5
069AC:  MOV     W1,W6
069AE:  MOV     W2,W7
069B0:  MOV     W3,W8
069B2:  MOV     W5,[W15++]
069B4:  MOV     W6,[W15++]
069B6:  MOV     W7,[W15++]
069B8:  MOV     W5,W0
069BA:  MOV     W6,W1
069BC:  MOV     W7,W2
069BE:  MOV     W8,W3
069C0:  MOV     #0,W4
069C2:  MOV     #0,W5
069C4:  MOV     #0,W6
069C6:  MOV     #4000,W7
069C8:  CALL    BCC
069CC:  MOV     [--W15],W7
069CE:  MOV     [--W15],W6
069D0:  MOV     [--W15],W5
069D2:  MOV     W0,W5
069D4:  MOV     W1,W6
069D6:  MOV     W2,W7
069D8:  MOV     W3,W8
069DA:  MOV     W5,[W15++]
069DC:  MOV     W6,[W15++]
069DE:  MOV     W7,[W15++]
069E0:  MOV     W5,W0
069E2:  MOV     W6,W1
069E4:  MOV     W7,W2
069E6:  MOV     W8,W3
069E8:  MOV     #2D18,W4
069EA:  MOV     #5444,W5
069EC:  MOV     #21FB,W6
069EE:  MOV     #4009,W7
069F0:  CALL    CDC
069F4:  MOV     [--W15],W7
069F6:  MOV     [--W15],W6
069F8:  MOV     [--W15],W5
069FA:  MOV     W0,1B42
069FC:  MOV     W1,1B44
069FE:  MOV     W2,1B46
06A00:  MOV     W3,1B48
.................... 	AngToDo_int = (signed int32)(arrondi_float_signed(temporaire));	 
06A02:  MOV     1B42,W0
06A04:  MOV     1B44,W1
06A06:  MOV     1B46,W2
06A08:  MOV     1B48,W3
06A0A:  CALL    6008
06A0E:  MOV     W1,W5
06A10:  MOV     W2,W6
06A12:  MOV     W5,1B72
06A14:  MOV     W6,1B74
06A16:  CALL    655A
06A1A:  MOV     W0,1B36
06A1C:  MOV     W1,1B38
.................... 	// on envoie les donnee au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
06A1E:  MOV     #0,W1
06A20:  MOV     W1,W0
06A22:  CLR.B   1
06A24:  CALL    2B4
06A28:  INC     W1,W1
06A2A:  BTSC.B  219.1
06A2C:  BRA     6A2A
06A2E:  MOV     W0,21A
06A30:  MOV     #4,W0
06A32:  CPSGT   W1,W0
06A34:  BRA     6A20
06A36:  MOV     14AE,W0
06A38:  MOV     #8004,W4
06A3A:  CALL    65B6
06A3E:  MOV     #9,W1
06A40:  MOV     W1,W0
06A42:  CLR.B   1
06A44:  CALL    2B4
06A48:  INC     W1,W1
06A4A:  BTSC.B  219.1
06A4C:  BRA     6A4A
06A4E:  MOV     W0,21A
06A50:  MOV     #E,W0
06A52:  CPSGT   W1,W0
06A54:  BRA     6A40
06A56:  MOV     14AE,W0
06A58:  MOV     #8004,W4
06A5A:  CALL    65B6
06A5E:  BTSC.B  219.1
06A60:  BRA     6A5E
06A62:  MOV     #20,W4
06A64:  MOV     W4,21A
06A66:  BTSC.B  219.1
06A68:  BRA     6A66
06A6A:  MOV     #D,W4
06A6C:  MOV     W4,21A
.................... 	 
.................... 	//balise  
.................... 	balise_on = 0; 
06A6E:  BCLR.B  85B.1
.................... 	 
.................... 	impulse_g = AngToDo_int; 
06A70:  PUSH    1B36
06A72:  POP     1B3A
06A74:  PUSH    1B38
06A76:  POP     1B3C
.................... 	impulse_d = 0-AngToDo_int; 
06A78:  MOV     #0,W4
06A7A:  MOV     1B36,W3
06A7C:  SUB     W4,W3,W0
06A7E:  MOV     W0,1B3E
06A80:  MOV     #0,W4
06A82:  MOV     1B38,W3
06A84:  SUBB    W4,W3,W0
06A86:  MOV     W0,1B40
.................... 	fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
06A88:  MOV     #0,W1
06A8A:  MOV     W1,W0
06A8C:  CLR.B   1
06A8E:  CALL    2D6
06A92:  INC     W1,W1
06A94:  BTSC.B  219.1
06A96:  BRA     6A94
06A98:  MOV     W0,21A
06A9A:  MOV     #5,W0
06A9C:  CPSGT   W1,W0
06A9E:  BRA     6A8A
06AA0:  MOV     1B3A,W0
06AA2:  MOV     1B3C,W1
06AA4:  MOV     #0,W4
06AA6:  CALL    66B0
06AAA:  MOV     #8,W1
06AAC:  MOV     W1,W0
06AAE:  CLR.B   1
06AB0:  CALL    2D6
06AB4:  INC     W1,W1
06AB6:  BTSC.B  219.1
06AB8:  BRA     6AB6
06ABA:  MOV     W0,21A
06ABC:  MOV     #E,W0
06ABE:  CPSGT   W1,W0
06AC0:  BRA     6AAC
06AC2:  MOV     1B3E,W0
06AC4:  MOV     1B40,W1
06AC6:  MOV     #0,W4
06AC8:  CALL    66B0
06ACC:  BTSC.B  219.1
06ACE:  BRA     6ACC
06AD0:  MOV     #20,W4
06AD2:  MOV     W4,21A
06AD4:  BTSC.B  219.1
06AD6:  BRA     6AD4
06AD8:  MOV     #D,W4
06ADA:  MOV     W4,21A
.................... 	 
.................... 	Depl_send = 1; 
06ADC:  BSET.B  85B.4
.................... 	Orient = (float64)(_Ang * CONV_DEG_RAD); // mise à jour de l'angle 
06ADE:  MOV     1B2C,W0
06AE0:  CLR     W3
06AE2:  BTSC    W0.F
06AE4:  SETM    W3
06AE6:  MOV     W3,W1
06AE8:  MOV     W3,W2
06AEA:  CALL    12E8
06AEE:  MOV     15F2,W4
06AF0:  MOV     15F4,W5
06AF2:  MOV     15F6,W6
06AF4:  MOV     15F8,W7
06AF6:  CALL    BCC
06AFA:  MOV     W0,15CA
06AFC:  MOV     W1,15CC
06AFE:  MOV     W2,15CE
06B00:  MOV     W3,15D0
06B02:  MOV     [--W15],W8
06B04:  MOV     [--W15],W7
06B06:  MOV     [--W15],W6
06B08:  MOV     [--W15],W5
06B0A:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __PaP(signed int16 _X, signed int16 _Y) 
.................... * \brief Depl Pap du robot. 
.................... *		Le deplacement se fait tel que : 
.................... *			- Rotation vers le point a  atteindre 
.................... *			- Deplacement ligne droite 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] coordonee x,y de la pos d'arrivee 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __PaP(signed int16 _X, signed int16 _Y) 
*
072AC:  MOV     W5,[W15++]
072AE:  MOV     #C,W5
072B0:  REPEAT  #3
072B2:  MOV     [W5++],[W15++]
072B4:  CLR     1B44
072B6:  CLR     1B46
072B8:  CLR     1B48
072BA:  CLR     1B4A
072BC:  CLR     1B4C
072BE:  CLR     1B4E
072C0:  CLR     1B50
072C2:  CLR     1B52
072C4:  CLR     1B54
072C6:  CLR     1B56
072C8:  CLR     1B58
072CA:  CLR     1B5A
072CC:  CLR     1B5C
072CE:  CLR     1B5E
072D0:  CLR     1B60
072D2:  CLR     1B62
072D4:  CLR     1B64
072D6:  CLR     1B66
072D8:  CLR     1B68
072DA:  CLR     1B6A
.................... { 
....................  
.................... 	float64	dx,dy,distToDo = 0;	 
.................... 	signed int32 distToDo_int = 0;	//dist a effectuer 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer 
.................... 	signed int32 impulse_g = 0;	 	//impulse mot gauche 
.................... 	signed int32 impulse_d = 0;		//impulse mot droite 
.................... 	static int1 etat_deplacement = 0; 
.................... 	float64 AngToDo = 0; 
.................... 	float64 temporaire = 0; 
.................... 	 
.................... 	 
.................... 	dx = (_X - Pos_x) * (COEFF_D/10); //calcul deplacment en x et transformation en pas 
072DC:  MOV     1B30,W4
072DE:  MOV     15BC,W3
072E0:  SUB     W4,W3,W5
072E2:  MOV     W5,[W15++]
072E4:  MOV     15EA,W0
072E6:  MOV     15EC,W1
072E8:  MOV     15EE,W2
072EA:  MOV     15F0,W3
072EC:  MOV     #0,W4
072EE:  MOV     #0,W5
072F0:  MOV     #0,W6
072F2:  MOV     #4024,W7
072F4:  CALL    CDC
072F8:  MOV     [--W15],W5
072FA:  MOV     W0,W6
072FC:  MOV     W1,W7
072FE:  MOV     W2,W8
07300:  MOV     W3,W9
07302:  MOV     W5,W0
07304:  CLR     W3
07306:  BTSC    W0.F
07308:  SETM    W3
0730A:  MOV     W3,W1
0730C:  MOV     W3,W2
0730E:  CALL    12E8
07312:  MOV     W5,[W15++]
07314:  MOV     W6,[W15++]
07316:  MOV     W7,[W15++]
07318:  MOV     W6,W4
0731A:  MOV     W7,W5
0731C:  MOV     W8,W6
0731E:  MOV     W9,W7
07320:  CALL    BCC
07324:  MOV     [--W15],W7
07326:  MOV     [--W15],W6
07328:  MOV     [--W15],W5
0732A:  MOV     W0,1B34
0732C:  MOV     W1,1B36
0732E:  MOV     W2,1B38
07330:  MOV     W3,1B3A
.................... 	dy = (_Y - Pos_Y) * (COEFF_D/10); //calcul deplacment en y et transformation en pas 
07332:  MOV     1B32,W4
07334:  MOV     15BE,W3
07336:  SUB     W4,W3,W5
07338:  MOV     W5,[W15++]
0733A:  MOV     15EA,W0
0733C:  MOV     15EC,W1
0733E:  MOV     15EE,W2
07340:  MOV     15F0,W3
07342:  MOV     #0,W4
07344:  MOV     #0,W5
07346:  MOV     #0,W6
07348:  MOV     #4024,W7
0734A:  CALL    CDC
0734E:  MOV     [--W15],W5
07350:  MOV     W0,W6
07352:  MOV     W1,W7
07354:  MOV     W2,W8
07356:  MOV     W3,W9
07358:  MOV     W5,W0
0735A:  CLR     W3
0735C:  BTSC    W0.F
0735E:  SETM    W3
07360:  MOV     W3,W1
07362:  MOV     W3,W2
07364:  CALL    12E8
07368:  MOV     W5,[W15++]
0736A:  MOV     W6,[W15++]
0736C:  MOV     W7,[W15++]
0736E:  MOV     W6,W4
07370:  MOV     W7,W5
07372:  MOV     W8,W6
07374:  MOV     W9,W7
07376:  CALL    BCC
0737A:  MOV     [--W15],W7
0737C:  MOV     [--W15],W6
0737E:  MOV     [--W15],W5
07380:  MOV     W0,1B3C
07382:  MOV     W1,1B3E
07384:  MOV     W2,1B40
07386:  MOV     W3,1B42
.................... 	distToDo = sqrt((dx*dx)+(dy*dy)); //calcul de la distance 
07388:  MOV     1B34,W0
0738A:  MOV     1B36,W1
0738C:  MOV     1B38,W2
0738E:  MOV     1B3A,W3
07390:  MOV     1B34,W4
07392:  MOV     1B36,W5
07394:  MOV     1B38,W6
07396:  MOV     1B3A,W7
07398:  CALL    BCC
0739C:  MOV     W0,W5
0739E:  MOV     W1,W6
073A0:  MOV     W2,W7
073A2:  MOV     W3,W8
073A4:  MOV     W5,[W15++]
073A6:  MOV     W6,[W15++]
073A8:  MOV     W7,[W15++]
073AA:  MOV     1B3C,W0
073AC:  MOV     1B3E,W1
073AE:  MOV     1B40,W2
073B0:  MOV     1B42,W3
073B2:  MOV     1B3C,W4
073B4:  MOV     1B3E,W5
073B6:  MOV     1B40,W6
073B8:  MOV     1B42,W7
073BA:  CALL    BCC
073BE:  MOV     [--W15],W7
073C0:  MOV     [--W15],W6
073C2:  MOV     [--W15],W5
073C4:  BCLR.B  43.0
073C6:  MOV     W5,[W15++]
073C8:  MOV     W6,[W15++]
073CA:  MOV     W7,[W15++]
073CC:  MOV     W0,W4
073CE:  MOV     W5,W0
073D0:  MOV     W1,W5
073D2:  MOV     W6,W1
073D4:  MOV     W2,W6
073D6:  MOV     W7,W2
073D8:  MOV     W3,W7
073DA:  MOV     W8,W3
073DC:  CALL    13FC
073E0:  MOV     [--W15],W7
073E2:  MOV     [--W15],W6
073E4:  MOV     [--W15],W5
073E6:  MOV     W0,W5
073E8:  MOV     W1,W6
073EA:  MOV     W2,W7
073EC:  MOV     W3,W8
073EE:  MOV     W5,1BC2
073F0:  MOV     W6,1BC4
073F2:  MOV     W7,1BC6
073F4:  MOV     W8,1BC8
073F6:  CALL    29CC
073FA:  MOV     W0,1B44
073FC:  MOV     W1,1B46
073FE:  MOV     W2,1B48
07400:  MOV     W3,1B4A
.................... 	distToDo_int = distToDo ; 
07402:  MOV     1B44,W0
07404:  MOV     1B46,W1
07406:  MOV     1B48,W2
07408:  MOV     1B4A,W3
0740A:  CALL    19EC
0740E:  MOV     W0,1B4C
07410:  MOV     W1,1B4E
....................  
.................... 	switch(etat_deplacement) 
07412:  CLR     W0
07414:  BTSC.B  1594.6
07416:  INC     W0,W0
07418:  CLR.B   1
0741A:  XOR     #0,W0
0741C:  BRA     Z,7424
0741E:  XOR     #1,W0
07420:  BRA     Z,7938
07422:  BRA     7A4C
.................... 	{ 
.................... 		case 0: // gestion de l'angle 
.................... 		 
.................... 			/////////////////////////////////////////////// 
.................... 			//////////Calcul de l'angle//////////////////// 
.................... 			/////////////////////////////////////////////// 
.................... 				if(dx >= 0) // 1er et 4eme quadrant 
07424:  MOV     #0,W0
07426:  MOV     #0,W1
07428:  MOV     #0,W2
0742A:  MOV     #0,W3
0742C:  MOV     1B34,W4
0742E:  MOV     1B36,W5
07430:  MOV     1B38,W6
07432:  MOV     1B3A,W7
07434:  CALL    15EA
07438:  BRA     C,743C
0743A:  BRA     NZ,749A
.................... 				{ 
.................... 					AngToDo = asin(dy/distToDo) - Orient;	 
0743C:  MOV     1B3C,W0
0743E:  MOV     1B3E,W1
07440:  MOV     1B40,W2
07442:  MOV     1B42,W3
07444:  MOV     1B44,W4
07446:  MOV     1B46,W5
07448:  MOV     1B48,W6
0744A:  MOV     1B4A,W7
0744C:  CALL    CDC
07450:  MOV     W0,W5
07452:  MOV     W1,W6
07454:  MOV     W2,W7
07456:  MOV     W3,W8
07458:  MOV     W5,1B76
0745A:  MOV     W6,1B78
0745C:  MOV     W7,1B7A
0745E:  MOV     W8,1B7C
07460:  CALL    6F18
07464:  MOV     W0,W5
07466:  MOV     W1,W6
07468:  MOV     W2,W7
0746A:  MOV     W3,W8
0746C:  BSET.B  43.0
0746E:  MOV     W5,[W15++]
07470:  MOV     W6,[W15++]
07472:  MOV     W7,[W15++]
07474:  MOV     W5,W0
07476:  MOV     W6,W1
07478:  MOV     W7,W2
0747A:  MOV     W8,W3
0747C:  MOV     15CA,W4
0747E:  MOV     15CC,W5
07480:  MOV     15CE,W6
07482:  MOV     15D0,W7
07484:  CALL    13FC
07488:  MOV     [--W15],W7
0748A:  MOV     [--W15],W6
0748C:  MOV     [--W15],W5
0748E:  MOV     W0,1B5C
07490:  MOV     W1,1B5E
07492:  MOV     W2,1B60
07494:  MOV     W3,1B62
.................... 				} 
07496:  GOTO    75F6
.................... 				 
.................... 				else if(dx <= 0 && dy > 0)//2eme quandrant 
0749A:  MOV     1B34,W0
0749C:  MOV     1B36,W1
0749E:  MOV     1B38,W2
074A0:  MOV     1B3A,W3
074A2:  MOV     #0,W4
074A4:  MOV     #0,W5
074A6:  MOV     #0,W6
074A8:  MOV     #0,W7
074AA:  CALL    15EA
074AE:  BRA     C,74B2
074B0:  BRA     NZ,7526
074B2:  MOV     #0,W0
074B4:  MOV     #0,W1
074B6:  MOV     #0,W2
074B8:  MOV     #0,W3
074BA:  MOV     1B3C,W4
074BC:  MOV     1B3E,W5
074BE:  MOV     1B40,W6
074C0:  MOV     1B42,W7
074C2:  CALL    15EA
074C6:  BRA     NC,7526
.................... 				{ 
.................... 					AngToDo = acos(dx/distToDo) - Orient; 
074C8:  MOV     1B34,W0
074CA:  MOV     1B36,W1
074CC:  MOV     1B38,W2
074CE:  MOV     1B3A,W3
074D0:  MOV     1B44,W4
074D2:  MOV     1B46,W5
074D4:  MOV     1B48,W6
074D6:  MOV     1B4A,W7
074D8:  CALL    CDC
074DC:  MOV     W0,W5
074DE:  MOV     W1,W6
074E0:  MOV     W2,W7
074E2:  MOV     W3,W8
074E4:  MOV     W5,1B76
074E6:  MOV     W6,1B78
074E8:  MOV     W7,1B7A
074EA:  MOV     W8,1B7C
074EC:  CALL    6F40
074F0:  MOV     W0,W5
074F2:  MOV     W1,W6
074F4:  MOV     W2,W7
074F6:  MOV     W3,W8
074F8:  BSET.B  43.0
074FA:  MOV     W5,[W15++]
074FC:  MOV     W6,[W15++]
074FE:  MOV     W7,[W15++]
07500:  MOV     W5,W0
07502:  MOV     W6,W1
07504:  MOV     W7,W2
07506:  MOV     W8,W3
07508:  MOV     15CA,W4
0750A:  MOV     15CC,W5
0750C:  MOV     15CE,W6
0750E:  MOV     15D0,W7
07510:  CALL    13FC
07514:  MOV     [--W15],W7
07516:  MOV     [--W15],W6
07518:  MOV     [--W15],W5
0751A:  MOV     W0,1B5C
0751C:  MOV     W1,1B5E
0751E:  MOV     W2,1B60
07520:  MOV     W3,1B62
.................... 				} 
07522:  GOTO    75F6
.................... 				 
.................... 				else if(dx < 0 && dy <= 0)//3eme quadrant 
07526:  MOV     1B34,W0
07528:  MOV     1B36,W1
0752A:  MOV     1B38,W2
0752C:  MOV     1B3A,W3
0752E:  MOV     #0,W4
07530:  MOV     #0,W5
07532:  MOV     #0,W6
07534:  MOV     #0,W7
07536:  CALL    15EA
0753A:  BRA     NC,75F6
0753C:  MOV     1B3C,W0
0753E:  MOV     1B3E,W1
07540:  MOV     1B40,W2
07542:  MOV     1B42,W3
07544:  MOV     #0,W4
07546:  MOV     #0,W5
07548:  MOV     #0,W6
0754A:  MOV     #0,W7
0754C:  CALL    15EA
07550:  BRA     C,7554
07552:  BRA     NZ,75F6
.................... 				{ 
.................... 					AngToDo = asin(abs(dy)/distToDo) + PI - Orient;	 
07554:  MOV     1B3C,W0
07556:  MOV     1B3E,W1
07558:  MOV     1B40,W2
0755A:  MOV     1B42,W3
0755C:  BCLR    W3.F
0755E:  MOV     W0,W5
07560:  MOV     W1,W6
07562:  MOV     W2,W7
07564:  MOV     W3,W8
07566:  MOV     W5,[W15++]
07568:  MOV     W6,[W15++]
0756A:  MOV     W7,[W15++]
0756C:  MOV     W5,W0
0756E:  MOV     W6,W1
07570:  MOV     W7,W2
07572:  MOV     W8,W3
07574:  MOV     1B44,W4
07576:  MOV     1B46,W5
07578:  MOV     1B48,W6
0757A:  MOV     1B4A,W7
0757C:  CALL    CDC
07580:  MOV     [--W15],W7
07582:  MOV     [--W15],W6
07584:  MOV     [--W15],W5
07586:  MOV     W0,W5
07588:  MOV     W1,W6
0758A:  MOV     W2,W7
0758C:  MOV     W3,W8
0758E:  MOV     W5,1B76
07590:  MOV     W6,1B78
07592:  MOV     W7,1B7A
07594:  MOV     W8,1B7C
07596:  CALL    6F18
0759A:  MOV     W0,W5
0759C:  MOV     W1,W6
0759E:  MOV     W2,W7
075A0:  MOV     W3,W8
075A2:  BCLR.B  43.0
075A4:  MOV     W5,[W15++]
075A6:  MOV     W6,[W15++]
075A8:  MOV     W7,[W15++]
075AA:  MOV     W5,W0
075AC:  MOV     W6,W1
075AE:  MOV     W7,W2
075B0:  MOV     W8,W3
075B2:  MOV     #2D18,W4
075B4:  MOV     #5444,W5
075B6:  MOV     #21FB,W6
075B8:  MOV     #4009,W7
075BA:  CALL    13FC
075BE:  MOV     [--W15],W7
075C0:  MOV     [--W15],W6
075C2:  MOV     [--W15],W5
075C4:  MOV     W0,W5
075C6:  MOV     W1,W6
075C8:  MOV     W2,W7
075CA:  MOV     W3,W8
075CC:  BSET.B  43.0
075CE:  MOV     W5,[W15++]
075D0:  MOV     W6,[W15++]
075D2:  MOV     W7,[W15++]
075D4:  MOV     W5,W0
075D6:  MOV     W6,W1
075D8:  MOV     W7,W2
075DA:  MOV     W8,W3
075DC:  MOV     15CA,W4
075DE:  MOV     15CC,W5
075E0:  MOV     15CE,W6
075E2:  MOV     15D0,W7
075E4:  CALL    13FC
075E8:  MOV     [--W15],W7
075EA:  MOV     [--W15],W6
075EC:  MOV     [--W15],W5
075EE:  MOV     W0,1B5C
075F0:  MOV     W1,1B5E
075F2:  MOV     W2,1B60
075F4:  MOV     W3,1B62
.................... 				} 
.................... 				 
.................... 			//////////////////////////////////////////////// 
.................... 			////////////Gestion de l'angle////////////////// 
.................... 			//////////////////////////////////////////////// 
.................... 				if(oAvAr) 
075F6:  CP0     14AA
075F8:  BRA     Z,7684
.................... 				{ 
.................... 					AngToDo += PI;	 
075FA:  BCLR.B  43.0
075FC:  MOV     1B5C,W0
075FE:  MOV     1B5E,W1
07600:  MOV     1B60,W2
07602:  MOV     1B62,W3
07604:  MOV     #2D18,W4
07606:  MOV     #5444,W5
07608:  MOV     #21FB,W6
0760A:  MOV     #4009,W7
0760C:  CALL    13FC
07610:  MOV     W0,1B5C
07612:  MOV     W1,1B5E
07614:  MOV     W2,1B60
07616:  MOV     W3,1B62
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
07618:  MOV     #2D18,W0
0761A:  MOV     #5444,W1
0761C:  MOV     #21FB,W2
0761E:  MOV     #4009,W3
07620:  MOV     1B5C,W4
07622:  MOV     1B5E,W5
07624:  MOV     1B60,W6
07626:  MOV     1B62,W7
07628:  CALL    15EA
0762C:  BRA     NC,7650
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
0762E:  BSET.B  43.0
07630:  MOV     1B5C,W0
07632:  MOV     1B5E,W1
07634:  MOV     1B60,W2
07636:  MOV     1B62,W3
07638:  MOV     #2D18,W4
0763A:  MOV     #5444,W5
0763C:  MOV     #21FB,W6
0763E:  MOV     #4019,W7
07640:  CALL    13FC
07644:  MOV     W0,1B5C
07646:  MOV     W1,1B5E
07648:  MOV     W2,1B60
0764A:  MOV     W3,1B62
.................... 					} 
0764C:  GOTO    7684
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
07650:  MOV     1B5C,W0
07652:  MOV     1B5E,W1
07654:  MOV     1B60,W2
07656:  MOV     1B62,W3
07658:  MOV     #2D18,W4
0765A:  MOV     #5444,W5
0765C:  MOV     #21FB,W6
0765E:  MOV     #C009,W7
07660:  CALL    15EA
07664:  BRA     NC,7684
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07666:  BCLR.B  43.0
07668:  MOV     1B5C,W0
0766A:  MOV     1B5E,W1
0766C:  MOV     1B60,W2
0766E:  MOV     1B62,W3
07670:  MOV     #2D18,W4
07672:  MOV     #5444,W5
07674:  MOV     #21FB,W6
07676:  MOV     #4019,W7
07678:  CALL    13FC
0767C:  MOV     W0,1B5C
0767E:  MOV     W1,1B5E
07680:  MOV     W2,1B60
07682:  MOV     W3,1B62
.................... 					} 
.................... 				}					 
.................... 				if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
07684:  MOV     14AC,W4
07686:  CP      W4,#2
07688:  BRA     NZ,76C2
0768A:  MOV     #0,W0
0768C:  MOV     #0,W1
0768E:  MOV     #0,W2
07690:  MOV     #0,W3
07692:  MOV     1B5C,W4
07694:  MOV     1B5E,W5
07696:  MOV     1B60,W6
07698:  MOV     1B62,W7
0769A:  CALL    15EA
0769E:  BRA     NC,76C2
.................... 				{ 
.................... 					AngToDo += -2 * PI; //on tourne sur la gauche 
076A0:  BCLR.B  43.0
076A2:  MOV     1B5C,W0
076A4:  MOV     1B5E,W1
076A6:  MOV     1B60,W2
076A8:  MOV     1B62,W3
076AA:  MOV     #2D18,W4
076AC:  MOV     #5444,W5
076AE:  MOV     #21FB,W6
076B0:  MOV     #C019,W7
076B2:  CALL    13FC
076B6:  MOV     W0,1B5C
076B8:  MOV     W1,1B5E
076BA:  MOV     W2,1B60
076BC:  MOV     W3,1B62
.................... 				}	 
076BE:  GOTO    7770
.................... 				 
.................... 				else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
076C2:  MOV     14AC,W4
076C4:  CP      W4,#1
076C6:  BRA     NZ,7700
076C8:  MOV     1B5C,W0
076CA:  MOV     1B5E,W1
076CC:  MOV     1B60,W2
076CE:  MOV     1B62,W3
076D0:  MOV     #0,W4
076D2:  MOV     #0,W5
076D4:  MOV     #0,W6
076D6:  MOV     #0,W7
076D8:  CALL    15EA
076DC:  BRA     NC,7700
.................... 				{ 
.................... 					AngToDo += 2 * PI;//On tourne sur la droite	 
076DE:  BCLR.B  43.0
076E0:  MOV     1B5C,W0
076E2:  MOV     1B5E,W1
076E4:  MOV     1B60,W2
076E6:  MOV     1B62,W3
076E8:  MOV     #2D18,W4
076EA:  MOV     #5444,W5
076EC:  MOV     #21FB,W6
076EE:  MOV     #4019,W7
076F0:  CALL    13FC
076F4:  MOV     W0,1B5C
076F6:  MOV     W1,1B5E
076F8:  MOV     W2,1B60
076FA:  MOV     W3,1B62
.................... 				}				 
076FC:  GOTO    7770
.................... 				 
.................... 				else if(oCoteTourn==0) 
07700:  CP0     14AC
07702:  BRA     NZ,7770
.................... 				{ 
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
07704:  MOV     #2D18,W0
07706:  MOV     #5444,W1
07708:  MOV     #21FB,W2
0770A:  MOV     #4009,W3
0770C:  MOV     1B5C,W4
0770E:  MOV     1B5E,W5
07710:  MOV     1B60,W6
07712:  MOV     1B62,W7
07714:  CALL    15EA
07718:  BRA     NC,773C
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
0771A:  BSET.B  43.0
0771C:  MOV     1B5C,W0
0771E:  MOV     1B5E,W1
07720:  MOV     1B60,W2
07722:  MOV     1B62,W3
07724:  MOV     #2D18,W4
07726:  MOV     #5444,W5
07728:  MOV     #21FB,W6
0772A:  MOV     #4019,W7
0772C:  CALL    13FC
07730:  MOV     W0,1B5C
07732:  MOV     W1,1B5E
07734:  MOV     W2,1B60
07736:  MOV     W3,1B62
.................... 					} 
07738:  GOTO    7770
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
0773C:  MOV     1B5C,W0
0773E:  MOV     1B5E,W1
07740:  MOV     1B60,W2
07742:  MOV     1B62,W3
07744:  MOV     #2D18,W4
07746:  MOV     #5444,W5
07748:  MOV     #21FB,W6
0774A:  MOV     #C009,W7
0774C:  CALL    15EA
07750:  BRA     NC,7770
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07752:  BCLR.B  43.0
07754:  MOV     1B5C,W0
07756:  MOV     1B5E,W1
07758:  MOV     1B60,W2
0775A:  MOV     1B62,W3
0775C:  MOV     #2D18,W4
0775E:  MOV     #5444,W5
07760:  MOV     #21FB,W6
07762:  MOV     #4019,W7
07764:  CALL    13FC
07768:  MOV     W0,1B5C
0776A:  MOV     W1,1B5E
0776C:  MOV     W2,1B60
0776E:  MOV     W3,1B62
.................... 					}	 
.................... 				} 
.................... 			if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
07770:  MOV     #432D,W0
07772:  MOV     #EB1C,W1
07774:  MOV     #36E2,W2
07776:  MOV     #BF1A,W3
07778:  MOV     1B5C,W4
0777A:  MOV     1B5E,W5
0777C:  MOV     1B60,W6
0777E:  MOV     1B62,W7
07780:  CALL    15EA
07784:  BRA     NC,77A4
07786:  MOV     1B5C,W0
07788:  MOV     1B5E,W1
0778A:  MOV     1B60,W2
0778C:  MOV     1B62,W3
0778E:  MOV     #432D,W4
07790:  MOV     #EB1C,W5
07792:  MOV     #36E2,W6
07794:  MOV     #3F1A,W7
07796:  CALL    15EA
0779A:  BRA     NC,77A4
0779C:  CLR     1B5C
0779E:  CLR     1B5E
077A0:  CLR     1B60
077A2:  CLR     1B62
.................... 			temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
077A4:  MOV     15E2,W0
077A6:  MOV     15E4,W1
077A8:  MOV     15E6,W2
077AA:  MOV     15E8,W3
077AC:  MOV     15D2,W4
077AE:  MOV     15D4,W5
077B0:  MOV     15D6,W6
077B2:  MOV     15D8,W7
077B4:  CALL    CDC
077B8:  MOV     W0,W4
077BA:  MOV     W1,W5
077BC:  MOV     W2,W6
077BE:  MOV     W3,W7
077C0:  MOV     1B5C,W0
077C2:  MOV     1B5E,W1
077C4:  MOV     1B60,W2
077C6:  MOV     1B62,W3
077C8:  CALL    BCC
077CC:  MOV     W0,W5
077CE:  MOV     W1,W6
077D0:  MOV     W2,W7
077D2:  MOV     W3,W8
077D4:  MOV     W5,[W15++]
077D6:  MOV     W6,[W15++]
077D8:  MOV     W7,[W15++]
077DA:  MOV     W5,W0
077DC:  MOV     W6,W1
077DE:  MOV     W7,W2
077E0:  MOV     W8,W3
077E2:  MOV     15DA,W4
077E4:  MOV     15DC,W5
077E6:  MOV     15DE,W6
077E8:  MOV     15E0,W7
077EA:  CALL    BCC
077EE:  MOV     [--W15],W7
077F0:  MOV     [--W15],W6
077F2:  MOV     [--W15],W5
077F4:  MOV     W0,W5
077F6:  MOV     W1,W6
077F8:  MOV     W2,W7
077FA:  MOV     W3,W8
077FC:  MOV     W5,[W15++]
077FE:  MOV     W6,[W15++]
07800:  MOV     W7,[W15++]
07802:  MOV     W5,W0
07804:  MOV     W6,W1
07806:  MOV     W7,W2
07808:  MOV     W8,W3
0780A:  MOV     #0,W4
0780C:  MOV     #0,W5
0780E:  MOV     #0,W6
07810:  MOV     #4000,W7
07812:  CALL    BCC
07816:  MOV     [--W15],W7
07818:  MOV     [--W15],W6
0781A:  MOV     [--W15],W5
0781C:  MOV     W0,W5
0781E:  MOV     W1,W6
07820:  MOV     W2,W7
07822:  MOV     W3,W8
07824:  MOV     W5,[W15++]
07826:  MOV     W6,[W15++]
07828:  MOV     W7,[W15++]
0782A:  MOV     W5,W0
0782C:  MOV     W6,W1
0782E:  MOV     W7,W2
07830:  MOV     W8,W3
07832:  MOV     #2D18,W4
07834:  MOV     #5444,W5
07836:  MOV     #21FB,W6
07838:  MOV     #4009,W7
0783A:  CALL    CDC
0783E:  MOV     [--W15],W7
07840:  MOV     [--W15],W6
07842:  MOV     [--W15],W5
07844:  MOV     W0,1B64
07846:  MOV     W1,1B66
07848:  MOV     W2,1B68
0784A:  MOV     W3,1B6A
.................... 			AngToDo_int = (signed int32)(arrondi_float_signed(temporaire)); 
0784C:  MOV     1B64,W0
0784E:  MOV     1B66,W1
07850:  MOV     1B68,W2
07852:  MOV     1B6A,W3
07854:  CALL    6008
07858:  MOV     W1,W5
0785A:  MOV     W2,W6
0785C:  MOV     W5,1B72
0785E:  MOV     W6,1B74
07860:  CALL    655A
07864:  MOV     W0,1B50
07866:  MOV     W1,1B52
.................... 			/////////////////////////////////////////////////// 
.................... 			/////////////////Envoi de l'angle au Roboteq/////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			if(AngToDo_int != 0) 
07868:  CP0     1B50
0786A:  BRA     NZ,7870
0786C:  CP0     1B52
0786E:  BRA     Z,78FC
.................... 			{ 
.................... 				//balise 
.................... 				balise_on = 0; //desactive la balise sur une rotation 
07870:  BCLR.B  85B.1
.................... 				 
.................... 				fprintf(ROBOTEQ,"!S 1 300_!S 2 300\r"); 
07872:  MOV     #0,W1
07874:  MOV     W1,W0
07876:  CLR.B   1
07878:  CALL    2F6
0787C:  INC     W1,W1
0787E:  BTSC.B  219.1
07880:  BRA     787E
07882:  MOV     W0,21A
07884:  MOV     #11,W0
07886:  CPSGT   W1,W0
07888:  BRA     7874
.................... 				// on envoie les donnee au ROBOTEQ 
.................... 							 
.................... 				impulse_g = AngToDo_int; 
0788A:  PUSH    1B50
0788C:  POP     1B54
0788E:  PUSH    1B52
07890:  POP     1B56
.................... 				impulse_d = 0-AngToDo_int; 
07892:  MOV     #0,W4
07894:  MOV     1B50,W3
07896:  SUB     W4,W3,W0
07898:  MOV     W0,1B58
0789A:  MOV     #0,W4
0789C:  MOV     1B52,W3
0789E:  SUBB    W4,W3,W0
078A0:  MOV     W0,1B5A
.................... 				fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
078A2:  MOV     #0,W1
078A4:  MOV     W1,W0
078A6:  CLR.B   1
078A8:  CALL    2D6
078AC:  INC     W1,W1
078AE:  BTSC.B  219.1
078B0:  BRA     78AE
078B2:  MOV     W0,21A
078B4:  MOV     #5,W0
078B6:  CPSGT   W1,W0
078B8:  BRA     78A4
078BA:  MOV     1B54,W0
078BC:  MOV     1B56,W1
078BE:  MOV     #0,W4
078C0:  CALL    66B0
078C4:  MOV     #8,W1
078C6:  MOV     W1,W0
078C8:  CLR.B   1
078CA:  CALL    2D6
078CE:  INC     W1,W1
078D0:  BTSC.B  219.1
078D2:  BRA     78D0
078D4:  MOV     W0,21A
078D6:  MOV     #E,W0
078D8:  CPSGT   W1,W0
078DA:  BRA     78C6
078DC:  MOV     1B58,W0
078DE:  MOV     1B5A,W1
078E0:  MOV     #0,W4
078E2:  CALL    66B0
078E6:  BTSC.B  219.1
078E8:  BRA     78E6
078EA:  MOV     #20,W4
078EC:  MOV     W4,21A
078EE:  BTSC.B  219.1
078F0:  BRA     78EE
078F2:  MOV     #D,W4
078F4:  MOV     W4,21A
.................... 				 
.................... 				etat_deplacement  = 1;	 
078F6:  BSET.B  1594.6
.................... 			}					 
078F8:  GOTO    7916
.................... 			else 
.................... 			{			 
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r"); 
078FC:  MOV     #0,W1
078FE:  MOV     W1,W0
07900:  CLR.B   1
07902:  CALL    316
07906:  INC     W1,W1
07908:  BTSC.B  219.1
0790A:  BRA     7908
0790C:  MOV     W0,21A
0790E:  MOV     #F,W0
07910:  CPSGT   W1,W0
07912:  BRA     78FE
.................... 				etat_deplacement = 1; 
07914:  BSET.B  1594.6
.................... 			}	 
.................... 			Orient = (float64)(Orient + AngToDo);	 
07916:  BCLR.B  43.0
07918:  MOV     15CA,W0
0791A:  MOV     15CC,W1
0791C:  MOV     15CE,W2
0791E:  MOV     15D0,W3
07920:  MOV     1B5C,W4
07922:  MOV     1B5E,W5
07924:  MOV     1B60,W6
07926:  MOV     1B62,W7
07928:  CALL    13FC
0792C:  MOV     W0,15CA
0792E:  MOV     W1,15CC
07930:  MOV     W2,15CE
07932:  MOV     W3,15D0
.................... 			break; 
07934:  GOTO    7A4C
.................... 		case 1 : // gestion de la distance 
.................... 		 
.................... 			if(distToDo!=0)//si on doit faire avancer le robot 
07938:  MOV     1B44,W0
0793A:  MOV     1B46,W1
0793C:  MOV     1B48,W2
0793E:  MOV     1B4A,W3
07940:  MOV     #0,W4
07942:  MOV     #0,W5
07944:  MOV     #0,W6
07946:  MOV     #0,W7
07948:  CALL    15EA
0794C:  BRA     Z,7A44
.................... 			{		 
.................... 				__Check_commande_atteint();  
0794E:  CALL    6F6A
.................... 				__Get_enco_value(1);	//recupere la valeur des encos du pt de depart 
07952:  MOV.B   #1,W0L
07954:  MOV.B   W0L,1B6C
07956:  CALL    7046
.................... 				 
.................... 				if(flag_depl_ok == 1)//On attend que le deplacment precedent soit fini(angle) 
0795A:  BTSS.B  85A.6
0795C:  BRA     7A40
.................... 				{ 
.................... 					fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
0795E:  MOV     #0,W1
07960:  MOV     W1,W0
07962:  CLR.B   1
07964:  CALL    2B4
07968:  INC     W1,W1
0796A:  BTSC.B  219.1
0796C:  BRA     796A
0796E:  MOV     W0,21A
07970:  MOV     #4,W0
07972:  CPSGT   W1,W0
07974:  BRA     7960
07976:  MOV     14AE,W0
07978:  MOV     #8004,W4
0797A:  CALL    65B6
0797E:  MOV     #9,W1
07980:  MOV     W1,W0
07982:  CLR.B   1
07984:  CALL    2B4
07988:  INC     W1,W1
0798A:  BTSC.B  219.1
0798C:  BRA     798A
0798E:  MOV     W0,21A
07990:  MOV     #E,W0
07992:  CPSGT   W1,W0
07994:  BRA     7980
07996:  MOV     14AE,W0
07998:  MOV     #8004,W4
0799A:  CALL    65B6
0799E:  BTSC.B  219.1
079A0:  BRA     799E
079A2:  MOV     #20,W4
079A4:  MOV     W4,21A
079A6:  BTSC.B  219.1
079A8:  BRA     79A6
079AA:  MOV     #D,W4
079AC:  MOV     W4,21A
.................... 					 
.................... 					flag_depl_ok = 0; 
079AE:  BCLR.B  85A.6
.................... 					 
.................... 					if(oAvAr)//si on recule 
079B0:  CP0     14AA
079B2:  BRA     Z,79D0
.................... 					{		 
.................... 						Balise_set_plage(1);//plage à l'arriere du robot						 
079B4:  MOV.B   #1,W0L
079B6:  MOV.B   W0L,1B6C
079B8:  CALL    7272
.................... 						distToDo_int = 0 - distToDo_int; //impulse negative --> recule 
079BC:  MOV     #0,W4
079BE:  MOV     1B4C,W3
079C0:  SUB     W4,W3,W0
079C2:  MOV     W0,1B4C
079C4:  MOV     #0,W4
079C6:  MOV     1B4E,W3
079C8:  SUBB    W4,W3,W0
079CA:  MOV     W0,1B4E
.................... 					} 
079CC:  GOTO    79D6
.................... 					else  
.................... 					{ 
.................... 						Balise_set_plage(0);//plage à l'avant du robot 
079D0:  CLR.B   1B6C
079D2:  CALL    7272
.................... 					} 
.................... 					//balise	 
.................... 					balise_on = 1; // active la balise sur un depl 
079D6:  BSET.B  85B.1
.................... 					//////////////////////////////////////////////////// 
.................... 					////////////envoie au Roobreq/////////////////////// 
.................... 					/////////////////////////////////////////////////// 
.................... 	 
.................... 					fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",distToDo_int,distToDo_int);						 
079D8:  MOV     #0,W1
079DA:  MOV     W1,W0
079DC:  CLR.B   1
079DE:  CALL    334
079E2:  INC     W1,W1
079E4:  BTSC.B  219.1
079E6:  BRA     79E4
079E8:  MOV     W0,21A
079EA:  MOV     #5,W0
079EC:  CPSGT   W1,W0
079EE:  BRA     79DA
079F0:  MOV     1B4C,W0
079F2:  MOV     1B4E,W1
079F4:  MOV     #8007,W4
079F6:  CALL    66B0
079FA:  MOV     #A,W1
079FC:  MOV     W1,W0
079FE:  CLR.B   1
07A00:  CALL    334
07A04:  INC     W1,W1
07A06:  BTSC.B  219.1
07A08:  BRA     7A06
07A0A:  MOV     W0,21A
07A0C:  MOV     #10,W0
07A0E:  CPSGT   W1,W0
07A10:  BRA     79FC
07A12:  MOV     1B4C,W0
07A14:  MOV     1B4E,W1
07A16:  MOV     #8007,W4
07A18:  CALL    66B0
07A1C:  BTSC.B  219.1
07A1E:  BRA     7A1C
07A20:  MOV     #20,W4
07A22:  MOV     W4,21A
07A24:  BTSC.B  219.1
07A26:  BRA     7A24
07A28:  MOV     #D,W4
07A2A:  MOV     W4,21A
.................... 					Depl_send = 1;							//indique que l'on a fini d'envoyer les ordres du dÃ©placment 
07A2C:  BSET.B  85B.4
.................... 					etat_deplacement = 0; 
07A2E:  BCLR.B  1594.6
.................... 					Dist_x = (signed int16)(_X - Pos_x);	//mise a jour pos x 
07A30:  MOV     1B30,W4
07A32:  MOV     15BC,W3
07A34:  SUB     W4,W3,W0
07A36:  MOV     W0,15B8
.................... 					Dist_y = (signed int16)(_Y - Pos_y); 	//mise a jour pos y 
07A38:  MOV     1B32,W4
07A3A:  MOV     15BE,W3
07A3C:  SUB     W4,W3,W0
07A3E:  MOV     W0,15BA
.................... 				}	 
.................... 			} 
07A40:  GOTO    7A48
.................... 			else 
.................... 			{				 
.................... 				Depl_send = 1; 
07A44:  BSET.B  85B.4
.................... 				etat_deplacement = 0; 
07A46:  BCLR.B  1594.6
.................... 			} 
.................... 		break; 
07A48:  GOTO    7A4C
.................... 	} 
.................... 	// Quitte la fonction 
.................... 	return; 
07A4C:  MOV     #12,W5
07A4E:  REPEAT  #3
07A50:  MOV     [--W15],[W5--]
07A52:  MOV     [--W15],W5
07A54:  RETURN  
.................... } 
.................... /* 
.................... 	/** 
.................... * \fn void __Progress(int16 _X, int16 _Y) 
.................... * \brief Fonction utile pour s'etalonner dans un bord  
.................... * \		 s'arrete en detectant une limite de courant  
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 23.2.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Progress(int16 _X, int16 _Y) 
*
08200:  MOV     W5,[W15++]
08202:  MOV     W6,[W15++]
08204:  MOV     W7,[W15++]
08206:  MOV     W8,[W15++]
08208:  CLR     1B30
0820A:  CLR     1B32
0820C:  CLR     1B34
0820E:  CLR     1B36
08210:  CLR     1B38
08212:  CLR     1B3A
08214:  CLR     1B3C
08216:  CLR     1B3E
08218:  CLR     1B40
0821A:  CLR     1B42
0821C:  CLR     1B44
0821E:  CLR     1B46
.................... { 
.................... 	static unsigned int8 etat_depl; 
.................... 	float64 amp = 0;				//courant dans le moteur 1 
.................... 	float64 amp2 = 0;				//courant dans le moteur 2  
.................... 	static int1 m1_stop,m2_stop;	//arret moteur 1 et arret moteur 2 
....................  
.................... 	float64 Dist = 0;  
....................  
.................... 	switch(etat_depl) 
08220:  MOV.B   1610,W0L
08222:  CLR.B   1
08224:  XOR     #0,W0
08226:  BRA     Z,822E
08228:  XOR     #1,W0
0822A:  BRA     Z,83AA
0822C:  BRA     856E
.................... 	{ 
.................... 		case 0: 
.................... 		 	Dist = sqrt(((_X - Pos_x) * (_X - Pos_x)) + ((_Y - Pos_y) * (_Y - Pos_y))) + DIST_SECU_PROGRESS; // calcul distance de depl  
0822E:  MOV     1B2C,W4
08230:  MOV     15BC,W3
08232:  SUB     W4,W3,W5
08234:  MOV     1B2C,W4
08236:  MOV     15BC,W3
08238:  SUB     W4,W3,W0
0823A:  MUL.SS  W5,W0,W0
0823C:  MOV     W0,W5
0823E:  MOV     1B2E,W4
08240:  MOV     15BE,W3
08242:  SUB     W4,W3,W6
08244:  MOV     1B2E,W4
08246:  MOV     15BE,W3
08248:  SUB     W4,W3,W0
0824A:  MUL.SS  W6,W0,W0
0824C:  ADD     W0,W5,W0
0824E:  CALL    7A56
08252:  MOV     W0,W5
08254:  MOV     W1,W6
08256:  MOV     W5,1B4C
08258:  MOV     W6,1B4E
0825A:  CALL    7B6A
0825E:  MOV     W0,W5
08260:  MOV     W1,W6
08262:  MOV     15B6,W0
08264:  CALL    60E0
08268:  BCLR.B  43.0
0826A:  MOV     W0,W2
0826C:  MOV     W1,W3
0826E:  MOV     W5,W0
08270:  MOV     W6,W1
08272:  CALL    61DE
08276:  MOV     W1,W2
08278:  MOV     W0,W1
0827A:  MOV     #0,W0
0827C:  CALL    7C4A
08280:  MOV     W0,1B40
08282:  MOV     W1,1B42
08284:  MOV     W2,1B44
08286:  MOV     W3,1B46
.................... 		 	Dist *= (COEFF_D/10);	//conversion mm en pas 
08288:  MOV     15EA,W0
0828A:  MOV     15EC,W1
0828C:  MOV     15EE,W2
0828E:  MOV     15F0,W3
08290:  MOV     #0,W4
08292:  MOV     #0,W5
08294:  MOV     #0,W6
08296:  MOV     #4024,W7
08298:  CALL    CDC
0829C:  MOV     W0,W4
0829E:  MOV     W1,W5
082A0:  MOV     W2,W6
082A2:  MOV     W3,W7
082A4:  MOV     1B40,W0
082A6:  MOV     1B42,W1
082A8:  MOV     1B44,W2
082AA:  MOV     1B46,W3
082AC:  CALL    BCC
082B0:  MOV     W0,1B40
082B2:  MOV     W1,1B42
082B4:  MOV     W2,1B44
082B6:  MOV     W3,1B46
.................... 			flag_depl_ok = 0; 
082B8:  BCLR.B  85A.6
.................... 			 
.................... 			//balise	 
.................... 			balise_on = 1; // active la balise sur un depl				 
082BA:  BSET.B  85B.1
.................... 			 
.................... 			if(oAvAr)//si on recule 
082BC:  CP0     14AA
082BE:  BRA     Z,82EA
.................... 			{	 
.................... 				Balise_set_plage(1);//plage à l'arriere du robot					 
082C0:  MOV.B   #1,W0L
082C2:  MOV.B   W0L,1B6C
082C4:  CALL    7272
.................... 				Dist = 0 - Dist; 	// on inverse la distance 
082C8:  BSET.B  43.0
082CA:  MOV     #0,W0
082CC:  MOV     #0,W1
082CE:  MOV     #0,W2
082D0:  MOV     #0,W3
082D2:  MOV     1B40,W4
082D4:  MOV     1B42,W5
082D6:  MOV     1B44,W6
082D8:  MOV     1B46,W7
082DA:  CALL    13FC
082DE:  MOV     W0,1B40
082E0:  MOV     W1,1B42
082E2:  MOV     W2,1B44
082E4:  MOV     W3,1B46
.................... 			} 
082E6:  GOTO    82F0
.................... 			else  
.................... 			{ 
.................... 				Balise_set_plage(0);//plage à l'avant du robot 
082EA:  CLR.B   1B6C
082EC:  CALL    7272
.................... 			} 
.................... 			//////////////////////////////////////////////////// 
.................... 			////////////envoie au Roobreq/////////////////////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			//__Get_enco_value(1); 
.................... 			 
.................... 			fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax);	 
082F0:  MOV     #0,W1
082F2:  MOV     W1,W0
082F4:  CLR.B   1
082F6:  CALL    2B4
082FA:  INC     W1,W1
082FC:  BTSC.B  219.1
082FE:  BRA     82FC
08300:  MOV     W0,21A
08302:  MOV     #4,W0
08304:  CPSGT   W1,W0
08306:  BRA     82F2
08308:  MOV     14AE,W0
0830A:  MOV     #8004,W4
0830C:  CALL    65B6
08310:  MOV     #9,W1
08312:  MOV     W1,W0
08314:  CLR.B   1
08316:  CALL    2B4
0831A:  INC     W1,W1
0831C:  BTSC.B  219.1
0831E:  BRA     831C
08320:  MOV     W0,21A
08322:  MOV     #E,W0
08324:  CPSGT   W1,W0
08326:  BRA     8312
08328:  MOV     14AE,W0
0832A:  MOV     #8004,W4
0832C:  CALL    65B6
08330:  BTSC.B  219.1
08332:  BRA     8330
08334:  MOV     #20,W4
08336:  MOV     W4,21A
08338:  BTSC.B  219.1
0833A:  BRA     8338
0833C:  MOV     #D,W4
0833E:  MOV     W4,21A
.................... 			fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",Dist,Dist);		 
08340:  MOV     #0,W1
08342:  MOV     W1,W0
08344:  CLR.B   1
08346:  CALL    2D6
0834A:  INC     W1,W1
0834C:  BTSC.B  219.1
0834E:  BRA     834C
08350:  MOV     W0,21A
08352:  MOV     #5,W0
08354:  CPSGT   W1,W0
08356:  BRA     8342
08358:  MOV     1B40,W0
0835A:  MOV     1B42,W1
0835C:  MOV     1B44,W2
0835E:  MOV     1B46,W3
08360:  MOV     #0,W4
08362:  CALL    7D28
08366:  MOV     #8,W1
08368:  MOV     W1,W0
0836A:  CLR.B   1
0836C:  CALL    2D6
08370:  INC     W1,W1
08372:  BTSC.B  219.1
08374:  BRA     8372
08376:  MOV     W0,21A
08378:  MOV     #E,W0
0837A:  CPSGT   W1,W0
0837C:  BRA     8368
0837E:  MOV     1B40,W0
08380:  MOV     1B42,W1
08382:  MOV     1B44,W2
08384:  MOV     1B46,W3
08386:  MOV     #0,W4
08388:  CALL    7D28
0838C:  BTSC.B  219.1
0838E:  BRA     838C
08390:  MOV     #20,W4
08392:  MOV     W4,21A
08394:  BTSC.B  219.1
08396:  BRA     8394
08398:  MOV     #D,W4
0839A:  MOV     W4,21A
.................... 			 
.................... 			etat_depl = 1; 
0839C:  MOV.B   #1,W0L
0839E:  MOV.B   W0L,1610
.................... 			delay_ms(20); 
083A0:  MOV     #14,W0
083A2:  CALL    E90
.................... 			 
.................... 			break; 
083A6:  GOTO    856E
.................... 		case 1:  
.................... 			amp = (float64)(__Get_amp(1));	//recup du courant du mot 1 
083AA:  MOV     #1,W4
083AC:  MOV     W4,1B48
083AE:  CALL    7E5A
083B2:  MOV     W0,1B30
083B4:  MOV     W1,1B32
083B6:  MOV     W2,1B34
083B8:  MOV     W3,1B36
.................... 			amp2 =(float64)(__Get_amp(2));	//recup du courant du mot 2 
083BA:  MOV     #2,W4
083BC:  MOV     W4,1B48
083BE:  CALL    7E5A
083C2:  MOV     W0,1B38
083C4:  MOV     W1,1B3A
083C6:  MOV     W2,1B3C
083C8:  MOV     W3,1B3E
.................... 			amp /= 10;					  	// roboteq envoie 15A pour 1,5A --> /10 
083CA:  MOV     1B30,W0
083CC:  MOV     1B32,W1
083CE:  MOV     1B34,W2
083D0:  MOV     1B36,W3
083D2:  MOV     #0,W4
083D4:  MOV     #0,W5
083D6:  MOV     #0,W6
083D8:  MOV     #4024,W7
083DA:  CALL    CDC
083DE:  MOV     W0,1B30
083E0:  MOV     W1,1B32
083E2:  MOV     W2,1B34
083E4:  MOV     W3,1B36
.................... 			amp2 /= 10;					 	// roboteq envoie 15A pour 1,5A --> /10 
083E6:  MOV     1B38,W0
083E8:  MOV     1B3A,W1
083EA:  MOV     1B3C,W2
083EC:  MOV     1B3E,W3
083EE:  MOV     #0,W4
083F0:  MOV     #0,W5
083F2:  MOV     #0,W6
083F4:  MOV     #4024,W7
083F6:  CALL    CDC
083FA:  MOV     W0,1B38
083FC:  MOV     W1,1B3A
083FE:  MOV     W2,1B3C
08400:  MOV     W3,1B3E
.................... 			if(amp >= amp_limit)		 	//Seuil courant ds mot 1 detecte  
08402:  MOV     15AE,W0
08404:  MOV     15B0,W1
08406:  MOV     15B2,W2
08408:  MOV     15B4,W3
0840A:  MOV     1B30,W4
0840C:  MOV     1B32,W5
0840E:  MOV     1B34,W6
08410:  MOV     1B36,W7
08412:  CALL    15EA
08416:  BRA     C,841A
08418:  BRA     NZ,8434
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 1\r");	//Stop le mot 1  
0841A:  MOV     #0,W1
0841C:  MOV     W1,W0
0841E:  CLR.B   1
08420:  CALL    358
08424:  INC     W1,W1
08426:  BTSC.B  219.1
08428:  BRA     8426
0842A:  MOV     W0,21A
0842C:  MOV     #5,W0
0842E:  CPSGT   W1,W0
08430:  BRA     841C
.................... 				m1_stop = 1; 
08432:  BSET.B  1594.7
.................... 			} 
.................... 			if(amp2 >= amp_limit)			//Seuil courant ds mot 2 detecte 
08434:  MOV     15AE,W0
08436:  MOV     15B0,W1
08438:  MOV     15B2,W2
0843A:  MOV     15B4,W3
0843C:  MOV     1B38,W4
0843E:  MOV     1B3A,W5
08440:  MOV     1B3C,W6
08442:  MOV     1B3E,W7
08444:  CALL    15EA
08448:  BRA     C,844C
0844A:  BRA     NZ,8466
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 2\r");	//Stop le mot 2 
0844C:  MOV     #0,W1
0844E:  MOV     W1,W0
08450:  CLR.B   1
08452:  CALL    36C
08456:  INC     W1,W1
08458:  BTSC.B  219.1
0845A:  BRA     8458
0845C:  MOV     W0,21A
0845E:  MOV     #5,W0
08460:  CPSGT   W1,W0
08462:  BRA     844E
.................... 				m2_stop = 1; 
08464:  BSET.B  1611.0
.................... 			}	 
.................... 			if(m1_stop==1 && m2_stop==1)	//les 2 moteurs stopes 
08466:  BTSS.B  1594.7
08468:  BRA     84D4
0846A:  BTSS.B  1611.0
0846C:  BRA     84D4
.................... 			{ 
....................  
.................... 				fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); 	//passage en open loop speed 
0846E:  MOV     #0,W1
08470:  MOV     W1,W0
08472:  CLR.B   1
08474:  CALL    380
08478:  INC     W1,W1
0847A:  BTSC.B  219.1
0847C:  BRA     847A
0847E:  MOV     W0,21A
08480:  MOV     #13,W0
08482:  CPSGT   W1,W0
08484:  BRA     8470
.................... 				delay_ms(10); 
08486:  MOV     #A,W0
08488:  CALL    E90
.................... 				fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); 	//passage en closed loop count postion 
0848C:  MOV     #0,W1
0848E:  MOV     W1,W0
08490:  CLR.B   1
08492:  CALL    3A2
08496:  INC     W1,W1
08498:  BTSC.B  219.1
0849A:  BRA     8498
0849C:  MOV     W0,21A
0849E:  MOV     #13,W0
084A0:  CPSGT   W1,W0
084A2:  BRA     848E
.................... 								 
.................... 				Depl_send = 1; 							  	//fin du déplacment 
084A4:  BSET.B  85B.4
.................... 				etat_depl = 0; 
084A6:  CLR.B   1610
....................  
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r");	   
084A8:  MOV     #0,W1
084AA:  MOV     W1,W0
084AC:  CLR.B   1
084AE:  CALL    316
084B2:  INC     W1,W1
084B4:  BTSC.B  219.1
084B6:  BRA     84B4
084B8:  MOV     W0,21A
084BA:  MOV     #F,W0
084BC:  CPSGT   W1,W0
084BE:  BRA     84AA
.................... 				 
.................... 				Dist_x = (signed int16)(_X-Pos_x);			//mise a jour pos x 
084C0:  MOV     1B2C,W4
084C2:  MOV     15BC,W3
084C4:  SUB     W4,W3,W0
084C6:  MOV     W0,15B8
.................... 				Dist_y = (signed int16)(_Y-Pos_y);			//mise a jour pos y 
084C8:  MOV     1B2E,W4
084CA:  MOV     15BE,W3
084CC:  SUB     W4,W3,W0
084CE:  MOV     W0,15BA
.................... 			} 
084D0:  GOTO    856A
.................... 			else // si pos atteinte 
.................... 			{					 
.................... 				__Check_commande_atteint();  
084D4:  CALL    6F6A
.................... 				if(flag_depl_ok == 1) //On attend que le deplacment precedent soit fini(angle) 
084D8:  BTSS.B  85A.6
084DA:  BRA     856A
.................... 				{ 
.................... 					Dist_x =  cos(Orient) * Dist;			//mise a jour pos x 
084DC:  PUSH    15CA
084DE:  POP     1B5A
084E0:  PUSH    15CC
084E2:  POP     1B5C
084E4:  PUSH    15CE
084E6:  POP     1B5E
084E8:  PUSH    15D0
084EA:  POP     1B60
084EC:  CALL    7F0A
084F0:  MOV     W0,W5
084F2:  MOV     W1,W6
084F4:  MOV     W2,W7
084F6:  MOV     W3,W8
084F8:  MOV     W5,[W15++]
084FA:  MOV     W6,[W15++]
084FC:  MOV     W7,[W15++]
084FE:  MOV     W5,W0
08500:  MOV     W6,W1
08502:  MOV     W7,W2
08504:  MOV     W8,W3
08506:  MOV     1B40,W4
08508:  MOV     1B42,W5
0850A:  MOV     1B44,W6
0850C:  MOV     1B46,W7
0850E:  CALL    BCC
08512:  MOV     [--W15],W7
08514:  MOV     [--W15],W6
08516:  MOV     [--W15],W5
08518:  CALL    19EC
0851C:  MOV     W0,15B8
.................... 					Dist_y =  sin(Orient) * Dist;			//mise a jour pos y 
0851E:  PUSH    15CA
08520:  POP     1B48
08522:  PUSH    15CC
08524:  POP     1B4A
08526:  PUSH    15CE
08528:  POP     1B4C
0852A:  PUSH    15D0
0852C:  POP     1B4E
0852E:  CALL    81C4
08532:  MOV     W0,W5
08534:  MOV     W1,W6
08536:  MOV     W2,W7
08538:  MOV     W3,W8
0853A:  MOV     W5,[W15++]
0853C:  MOV     W6,[W15++]
0853E:  MOV     W7,[W15++]
08540:  MOV     W5,W0
08542:  MOV     W6,W1
08544:  MOV     W7,W2
08546:  MOV     W8,W3
08548:  MOV     1B40,W4
0854A:  MOV     1B42,W5
0854C:  MOV     1B44,W6
0854E:  MOV     1B46,W7
08550:  CALL    BCC
08554:  MOV     [--W15],W7
08556:  MOV     [--W15],W6
08558:  MOV     [--W15],W5
0855A:  CALL    19EC
0855E:  MOV     W0,15BA
....................  
.................... 					//remise a zero des varaibles 
.................... 					flag_depl_ok = 0; 
08560:  BCLR.B  85A.6
.................... 					Depl_send = 1; 
08562:  BSET.B  85B.4
.................... 					m1_stop = 0; 
08564:  BCLR.B  1594.7
.................... 					m2_stop = 0;								 
08566:  BCLR.B  1611.0
.................... 					etat_depl = 0;			 
08568:  CLR.B   1610
.................... 				} 
.................... 			} 
.................... 			break; 
0856A:  GOTO    856E
.................... 	} 
0856E:  MOV     [--W15],W8
08570:  MOV     [--W15],W7
08572:  MOV     [--W15],W6
08574:  MOV     [--W15],W5
08576:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Nothing(void) 
.................... * \brief Passe l'objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
....................  
.................... void __Nothing(void) 
.................... { 
.................... 	flag_depl_ok = 1;  
08578:  BSET.B  85A.6
.................... 	Depl_send=1; 
0857A:  BSET.B  85B.4
.................... 	balise_on = 0; 
0857C:  BCLR.B  85B.1
.................... 	// Quitte la fonction 
.................... 	return; 
0857E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __LoadObj(unsigned int8 _Obj) 
.................... * \brief Charge le prochain objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 2.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param [in] _Obj Numero de l'objectif desire 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __LoadObj(unsigned int16 _Obj,unsigned int16 pts) 
*
010B4:  MOV     W5,[W15++]
.................... {	 
.................... 	// Enregistre Xp, en [mm] 
.................... 	oXp=TabObjectifs[_Obj][pts][0]; 
010B6:  MOV     1B2C,W4
010B8:  MOV     #138,W3
010BA:  MUL.UU  W4,W3,W0
010BC:  MOV     W0,W5
010BE:  MOV     1B2E,W4
010C0:  MUL.UU  W4,#18,W0
010C2:  ADD     W0,W5,W5
010C4:  MOV     #C1C,W4
010C6:  ADD     W5,W4,W0
010C8:  MOV     [W0],[W15++]
010CA:  POP     14A4
....................  
.................... 	// Enregistre Yp, en [mm] 
.................... 	oYp=TabObjectifs[_Obj][pts][1]; 
010CC:  MOV     1B2C,W4
010CE:  MOV     #138,W3
010D0:  MUL.UU  W4,W3,W0
010D2:  MOV     W0,W5
010D4:  MOV     1B2E,W4
010D6:  MUL.UU  W4,#18,W0
010D8:  ADD     W0,W5,W5
010DA:  ADD     W5,#2,W0
010DC:  MOV     #C1C,W4
010DE:  ADD     W0,W4,W0
010E0:  MOV     [W0],[W15++]
010E2:  POP     14A6
....................  
.................... 	// Enregistre le type de deplacement, en [nbre] 
.................... 	oType=TabObjectifs[_Obj][pts][2]; 
010E4:  MOV     1B2C,W4
010E6:  MOV     #138,W3
010E8:  MUL.UU  W4,W3,W0
010EA:  MOV     W0,W5
010EC:  MOV     1B2E,W4
010EE:  MUL.UU  W4,#18,W0
010F0:  ADD     W0,W5,W5
010F2:  ADD     W5,#4,W0
010F4:  MOV     #C1C,W4
010F6:  ADD     W0,W4,W0
010F8:  MOV     [W0],[W15++]
010FA:  POP     14A8
....................  
.................... 	// Enregistre si avance ou recule 
.................... 	oAvAr=TabObjectifs[_Obj][pts][3]; 
010FC:  MOV     1B2C,W4
010FE:  MOV     #138,W3
01100:  MUL.UU  W4,W3,W0
01102:  MOV     W0,W5
01104:  MOV     1B2E,W4
01106:  MUL.UU  W4,#18,W0
01108:  ADD     W0,W5,W5
0110A:  ADD     W5,#6,W0
0110C:  MOV     #C1C,W4
0110E:  ADD     W0,W4,W0
01110:  MOV     [W0],[W15++]
01112:  POP     14AA
....................  
.................... 	// Enregistre le cote duquel tourner 
.................... 	oCoteTourn=TabObjectifs[_Obj][pts][4]; 
01114:  MOV     1B2C,W4
01116:  MOV     #138,W3
01118:  MUL.UU  W4,W3,W0
0111A:  MOV     W0,W5
0111C:  MOV     1B2E,W4
0111E:  MUL.UU  W4,#18,W0
01120:  ADD     W0,W5,W5
01122:  ADD     W5,#8,W0
01124:  MOV     #C1C,W4
01126:  ADD     W0,W4,W0
01128:  MOV     [W0],[W15++]
0112A:  POP     14AC
....................  
.................... 	// Enregistre la vitesse maximum, en [mm/s] (en [0/000] pour RoboteQ) 
.................... 	oVitMax=TabObjectifs[_Obj][pts][5]; 
0112C:  MOV     1B2C,W4
0112E:  MOV     #138,W3
01130:  MUL.UU  W4,W3,W0
01132:  MOV     W0,W5
01134:  MOV     1B2E,W4
01136:  MUL.UU  W4,#18,W0
01138:  ADD     W0,W5,W5
0113A:  ADD     W5,#A,W0
0113C:  MOV     #C1C,W4
0113E:  ADD     W0,W4,W0
01140:  MOV     [W0],[W15++]
01142:  POP     14AE
....................  
.................... 	//Enregistre l'action a faire 
.................... 	Obj_Action = TabObjectifs[_Obj][pts][6]; 
01144:  MOV     1B2C,W4
01146:  MOV     #138,W3
01148:  MUL.UU  W4,W3,W0
0114A:  MOV     W0,W5
0114C:  MOV     1B2E,W4
0114E:  MUL.UU  W4,#18,W0
01150:  ADD     W0,W5,W5
01152:  ADD     W5,#C,W0
01154:  MOV     #C1C,W4
01156:  ADD     W0,W4,W0
01158:  MOV     [W0],[W15++]
0115A:  POP     14B0
.................... 	 
.................... 	//Enregistre si le pt est symetrique ou non 
.................... 	Pt_commun = TabObjectifs[_Obj][pts][7]; 
0115C:  MOV     1B2C,W4
0115E:  MOV     #138,W3
01160:  MUL.UU  W4,W3,W0
01162:  MOV     W0,W5
01164:  MOV     1B2E,W4
01166:  MUL.UU  W4,#18,W0
01168:  ADD     W0,W5,W5
0116A:  ADD     W5,#E,W0
0116C:  MOV     #C1C,W4
0116E:  ADD     W0,W4,W0
01170:  MOV     [W0],[W15++]
01172:  POP     14B2
.................... 	 
.................... 	//ponderation objectifs 
.................... 	Ponderation = TabObjectifs[_Obj][pts][8];	 
01174:  MOV     1B2C,W4
01176:  MOV     #138,W3
01178:  MUL.UU  W4,W3,W0
0117A:  MOV     W0,W5
0117C:  MOV     1B2E,W4
0117E:  MUL.UU  W4,#18,W0
01180:  ADD     W0,W5,W5
01182:  ADD     W5,#10,W0
01184:  MOV     #C1C,W4
01186:  ADD     W0,W4,W0
01188:  MOV     [W0],[W15++]
0118A:  POP     14B4
.................... 	 
.................... 	//Objectifs fini ou non 
.................... 	Obj_end	= TabObjectifs[_Obj][pts][9];  
0118C:  MOV     1B2C,W4
0118E:  MOV     #138,W3
01190:  MUL.UU  W4,W3,W0
01192:  MOV     W0,W5
01194:  MOV     1B2E,W4
01196:  MUL.UU  W4,#18,W0
01198:  ADD     W0,W5,W5
0119A:  ADD     W5,#12,W0
0119C:  MOV     #C1C,W4
0119E:  ADD     W0,W4,W0
011A0:  MOV     [W0],[W15++]
011A2:  POP     14B6
.................... 	 
.................... 	//prochain objectifs 
.................... 	Next_obj = TabObjectifs[_Obj][pts][10]; 
011A4:  MOV     1B2C,W4
011A6:  MOV     #138,W3
011A8:  MUL.UU  W4,W3,W0
011AA:  MOV     W0,W5
011AC:  MOV     1B2E,W4
011AE:  MUL.UU  W4,#18,W0
011B0:  ADD     W0,W5,W5
011B2:  ADD     W5,#14,W0
011B4:  MOV     #C1C,W4
011B6:  ADD     W0,W4,W0
011B8:  MOV     [W0],[W15++]
011BA:  POP     14B8
.................... 	 
.................... 	keep_obj = TabObjectifs[_Obj][pts][11]; 
011BC:  MOV     1B2C,W4
011BE:  MOV     #138,W3
011C0:  MUL.UU  W4,W3,W0
011C2:  MOV     W0,W5
011C4:  MOV     1B2E,W4
011C6:  MUL.UU  W4,#18,W0
011C8:  ADD     W0,W5,W5
011CA:  ADD     W5,#16,W0
011CC:  MOV     #C1C,W4
011CE:  ADD     W0,W4,W0
011D0:  MOV     [W0],[W15++]
011D2:  POP     14BA
....................  
.................... 	// Switch les donnees selon la base choisie et le mode 
.................... 	if(TEAM) 
011D4:  BTSS.B  85B.3
011D6:  BRA     1232
.................... 	{ 
.................... 		switch(oType) 
011D8:  MOV     14A8,W0
011DA:  XOR     #0,W0
011DC:  BRA     Z,11E4
011DE:  XOR     #1,W0
011E0:  BRA     Z,1204
011E2:  BRA     122E
.................... 		{ 
.................... 			case 0 : 
.................... 				if(oXp<=180)oXp=180-oXp; //gestion angle 
011E4:  MOV     14A4,W4
011E6:  MOV     #B4,W3
011E8:  CP      W3,W4
011EA:  BRA     LT,11F8
011EC:  MOV     #B4,W4
011EE:  MOV     14A4,W3
011F0:  SUB     W4,W3,W0
011F2:  MOV     W0,14A4
011F4:  GOTO    1200
.................... 				else oXp = 540 - oXp; 
011F8:  MOV     #21C,W4
011FA:  MOV     14A4,W3
011FC:  SUB     W4,W3,W0
011FE:  MOV     W0,14A4
.................... 				break; 
01200:  GOTO    1232
.................... 			case 1 : 
.................... 				// PaP ou retient sur place, calcul automatique de l'angle, inversion oX et oCoteTourn 
.................... 				// Enregistre Xp, en [mm] 
.................... 				oXp = TableWidth - oXp; 
01204:  MOV     890,W4
01206:  MOV     14A4,W3
01208:  SUB     W4,W3,W0
0120A:  MOV     W0,14A4
.................... 				// Enregistre le cote duquel tourner 
.................... 				if(oCoteTourn==1)oCoteTourn=2; 
0120C:  MOV     14AC,W4
0120E:  CP      W4,#1
01210:  BRA     NZ,121A
01212:  MOV     #2,W4
01214:  MOV     W4,14AC
01216:  GOTO    122A
.................... 				else if(oCoteTourn==2)oCoteTourn=1; 
0121A:  MOV     14AC,W4
0121C:  CP      W4,#2
0121E:  BRA     NZ,1228
01220:  MOV     #1,W4
01222:  MOV     W4,14AC
01224:  GOTO    122A
.................... 				else oCoteTourn=0; 
01228:  CLR     14AC
.................... 	 
.................... 				break; 
0122A:  GOTO    1232
.................... 			default : 
.................... 				break; 
0122E:  GOTO    1232
.................... 		}		 
.................... 	}						 
01232:  MOV     [--W15],W5
01234:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    RDA_isr 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    27.03.2015 
.................... //  Statut :    OK 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Interruption pour la rÃÂ©ception RS232.  
.................... #INT_RDA2 
.................... void RDA2_isr(void) 
*
0057E:  PUSH    42
00580:  PUSH    36
00582:  PUSH    32
00584:  MOV     W0,[W15++]
00586:  MOV     #2,W0
00588:  REPEAT  #C
0058A:  MOV     [W0++],[W15++]
.................... { 
.................... 	// Pour la lecture du caractÃÂ¨re reÃÂ§u 
.................... 	char myChar; 
.................... 	// RÃÂ©ception 
.................... 	myChar = fgetc(ROBOTEQ); 
0058C:  BTSS.B  218.0
0058E:  BRA     58C
00590:  MOV     21C,W0
00592:  MOV.B   W0L,1C6C
.................... 	// Ajout au buffer et incrÃÂ©mentation de la longeur du buffer 
.................... 	RoboteQ_receiveBuffer[RoboteQ_receiveLenght] = myChar; 
00594:  MOV     15FA,W4
00596:  LSR     W4,#8,W4
00598:  MOV     #894,W3
0059A:  ADD     W4,W3,W5
0059C:  MOV     1C6C,W0
0059E:  MOV.B   W0L,[W5+#0]
.................... 	RoboteQ_receiveLenght++; 
005A0:  INC.B   15FB
.................... 	 
.................... 	// Si on trouve la fin de la commande 
.................... 	if(myChar == '\r') 
005A2:  MOV     1C6C,W4
005A4:  CP.B    W4L,#D
005A6:  BRA     NZ,5AE
.................... 	{ 
.................... 		// On dit qu'on peut lire le buffer de rÃÂ©ception 
.................... 		RoboteQ_receiveToProceed = RoboteQ_receiveLenght; 
005A8:  MOV.B   15FB,W0L
005AA:  MOV.B   W0L,15FA
.................... 		RoboteQ_receiveLenght=0; 
005AC:  CLR.B   15FB
.................... 	} 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "PC/___PC.h" 
.................... /* 
.................... * \file ___PC.h 
.................... * \brief Gère la communication PC (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_H 
.................... #define ___PC_H 
....................  
....................  
....................  
.................... // Config RS232 
005AE:  BCLR.B  87.0
005B0:  MOV     #1A,W0
005B2:  REPEAT  #C
005B4:  MOV     [--W15],[W0--]
005B6:  MOV     [--W15],W0
005B8:  POP     32
005BA:  POP     36
005BC:  POP     42
005BE:  RETFIE  
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=RS232) 
.................... // Config UART 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,stream=UARTi) 
....................  
.................... // Définit quand un tableau est à décoder 
.................... int1 PCh_flagUARTReadyToDecode = 0; 
.................... // Watchdog pour éviter un blocage UART 
.................... int1 PCh_flagUARTWatchdog = 0; 
....................  
....................  
.................... void __Init_UART(void);	// Initialise 
.................... void __UART_Decode(unsigned int32* _Tab);	// Décode une trame 
.................... void __SendBackUART(void); // Renvoi la dernière commande envoyée 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec); // Décode un tableau 
.................... #include "PC/___PC.c" 
.................... /* 
.................... * \file ___PC.c 
.................... * \brief Gère la communication PC (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_C 
.................... #define ___PC_C 
....................  
.................... // Bits & define 
.................... 	// Contient la trame à décoder 
.................... unsigned int8 TabToDecode[256]={0}; 
.................... unsigned int8 PosTabToDecode = 0; 
.................... unsigned int8 ToDoUART = 0; 
.................... 	// Contient les valeurs décodées 
.................... unsigned int32 TabDecoded[256]={0}; 
.................... 	// Attend une réponse 
.................... int1 UARTWaitResp=0; 
.................... 	// Nombre de fois à renvoyer 
.................... unsigned int8 UARTToSendBack=0; 
.................... 	 
....................  
.................... /** 
.................... * \fn void __Init_UART(void) 
.................... * \brief Initie l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Init_UART(void) 
.................... { 
.................... 	// Réception 
.................... 	enable_interrupts(INT_RDA); 
*
0100A:  BSET.B  8D.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
0100C:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void RDA_isr(void) 
.................... * \brief Interruption RDA, récupère les caractères du RS232. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... */ 
.................... #INT_RDA 
.................... void RDA_isr(void) 
*
008DA:  PUSH    42
008DC:  PUSH    36
008DE:  PUSH    32
008E0:  MOV     W0,[W15++]
008E2:  MOV     #2,W0
008E4:  REPEAT  #C
008E6:  MOV     [W0++],[W15++]
.................... {	 
.................... 	// Checksum UART 
.................... 	static unsigned int8 HashR1, HashR2, HashC1, HashC2; 
.................... 	if(PCh_flagUARTReadyToDecode==0) 
008E8:  BTSC.B  1611.1
008EA:  BRA     A4C
.................... 	{ 
.................... 		// Active le watchdog UART 
.................... 		PCh_flagUARTWatchdog = 1; 
008EC:  BSET.B  1611.2
.................... 		// Traite la réception 
.................... 		while(kbhit(RS232)) 
008EE:  BTSS.B  20E.0
008F0:  BRA     A4C
.................... 		{ 
.................... 			// Récupération donnée 
.................... 			unsigned int8 Dataa = fgetc(RS232); 
008F2:  BTSS.B  20E.0
008F4:  BRA     8F2
008F6:  MOV     212,W0
008F8:  MOV.B   W0L,1C6C
.................... 			 
.................... 			// Si c'est une réponse à un envoi, on remet à 0 l'attente de réponse et la fausse erreur 
.................... 			if(UARTWaitResp && Dataa==ACK)  
008FA:  BTSS.B  1611.3
008FC:  BRA     90C
008FE:  MOV     1C6C,W4
00900:  CP.B    W4L,#6
00902:  BRA     NZ,90C
.................... 			{ 
.................... 				UARTWaitResp=0; 
00904:  BCLR.B  1611.3
.................... 				UARTToSendBack=0; 
00906:  CLR.B   1B14
.................... 				 
.................... 			}	 
00908:  GOTO    A48
.................... 			// Si ce n'est pas OK, renvoie un certain nombre de fois 
.................... 			else if(UARTWaitResp && Dataa==NAK) 
0090C:  BTSS.B  1611.3
0090E:  BRA     932
00910:  MOV     1C6C,W4
00912:  CP.B    W4L,#15
00914:  BRA     NZ,932
.................... 			{ 
.................... 				if(UARTToSendBack<UART_NBR_REP_NAK) {__SendBackUART();UARTToSendBack++;} 
00916:  MOV.B   1B14,W0L
00918:  MOV     14BC,W4
0091A:  LSR     W4,#8,W4
0091C:  CP.B    W4L,W0L
0091E:  BRA     LEU,92A
00920:  CALL    5C0
00924:  INC.B   1B14
00926:  GOTO    92E
.................... 				else {UARTWaitResp=0;UARTToSendBack=0;} 
0092A:  BCLR.B  1611.3
0092C:  CLR.B   1B14
.................... 			} 
0092E:  GOTO    A48
.................... 			// Réception 
.................... 			else 
.................... 			{	 
.................... 				// Début de transmission 
.................... 				if(Dataa == STX&&ToDoUART==0) 
00932:  MOV     1C6C,W4
00934:  CP.B    W4L,#2
00936:  BRA     NZ,94C
00938:  CP0.B   1713
0093A:  BRA     NZ,94C
.................... 				{ 
.................... 					HashC1 = HashC2 = 0; 
0093C:  CLR.B   1B18
0093E:  MOV.B   1B18,W0L
00940:  MOV.B   W0L,1B17
.................... 					ToDoUART=1;  
00942:  MOV.B   #1,W0L
00944:  MOV.B   W0L,1713
.................... 					PosTabToDecode=0; 
00946:  CLR.B   1712
.................... 				} 
00948:  GOTO    A48
.................... 				// Fin de transmission 
.................... 				else if(Dataa == ETX&&ToDoUART==5)		 
0094C:  MOV     1C6C,W4
0094E:  CP.B    W4L,#3
00950:  BRA     NZ,9D2
00952:  MOV     1712,W4
00954:  LSR     W4,#8,W4
00956:  CP.B    W4L,#5
00958:  BRA     NZ,9D2
.................... 				{		 
.................... 					if(HashC1==ETX||HashC1==CR)HashC1++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
0095A:  MOV     1B16,W4
0095C:  LSR     W4,#8,W4
0095E:  CP.B    W4L,#3
00960:  BRA     Z,96A
00962:  MOV     1B16,W4
00964:  LSR     W4,#8,W4
00966:  CP.B    W4L,#D
00968:  BRA     NZ,96C
0096A:  INC.B   1B17
.................... 					if(HashC2==ETX||HashC2==CR)HashC2++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
0096C:  MOV     1B18,W4
0096E:  CP.B    W4L,#3
00970:  BRA     Z,978
00972:  MOV     1B18,W4
00974:  CP.B    W4L,#D
00976:  BRA     NZ,97A
00978:  INC.B   1B18
.................... 					// Si trame OK 
.................... 					if(HashC1==HashR1 && HashC2==HashR2) 
0097A:  MOV.B   1B17,W0L
0097C:  CP.B    1B15
0097E:  BRA     NZ,9BC
00980:  MOV.B   1B18,W0L
00982:  CP.B    1B16
00984:  BRA     NZ,9BC
.................... 					{ 
.................... 						TabToDecode[PosTabToDecode] = ETX; 
00986:  MOV     1712,W4
00988:  CLR.B   9
0098A:  MOV     #1612,W3
0098C:  ADD     W4,W3,W5
0098E:  MOV.B   #3,W0L
00990:  MOV.B   W0L,[W5]
.................... 						// Décode le tableau 
.................... 						__CommDecode(TabToDecode,TabDecoded); 
00992:  MOV     #1612,W4
00994:  MOV     W4,1C6E
00996:  MOV     #1714,W4
00998:  MOV     W4,1C70
0099A:  CALL    85E
.................... 						if(TabDecoded[0]==UART_ADDR) 
0099E:  MOV     1714,W0
009A0:  CP      14BE
009A2:  BRA     NZ,9B8
009A4:  MOV     1716,W0
009A6:  CP      14C0
009A8:  BRA     NZ,9B8
.................... 						{	 
.................... 							// Dit qu'on est prêts à recevoir 
.................... 							PCh_flagUARTReadyToDecode=1; 
009AA:  BSET.B  1611.1
.................... 							// Renvoie un simple OK 
.................... 							fputc(ACK,RS232); 
009AC:  MOV.B   #6,W0L
009AE:  BTSC.B  20F.1
009B0:  BRA     9AE
009B2:  MOV.B   W0L,210
009B4:  CLR.B   211
.................... 							// Dit qu'on attend une réponse 
.................... 							UARTWaitResp=1; 
009B6:  BSET.B  1611.3
.................... 						}	 
.................... 					} 
009B8:  GOTO    9C6
.................... 					else fputc(NAK,RS232); // Erreur de réception, envoi un pas ok 
009BC:  MOV.B   #15,W0L
009BE:  BTSC.B  20F.1
009C0:  BRA     9BE
009C2:  MOV.B   W0L,210
009C4:  CLR.B   211
.................... 					ToDoUART = 0; 
009C6:  CLR.B   1713
.................... 					PosTabToDecode=0; 
009C8:  CLR.B   1712
.................... 					UARTToSendBack=0; 
009CA:  CLR.B   1B14
.................... 					// Désactive le watchdog UART 
.................... 					PCh_flagUARTWatchdog = 0; 
009CC:  BCLR.B  1611.2
.................... 				} 
009CE:  GOTO    A48
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==1)ToDoUART=2; 
009D2:  MOV     1712,W4
009D4:  LSR     W4,#8,W4
009D6:  CP.B    W4L,#1
009D8:  BRA     NZ,9E2
009DA:  MOV.B   #2,W0L
009DC:  MOV.B   W0L,1713
009DE:  GOTO    A48
.................... 				// Enregistre le premier Hash 
.................... 				else if(ToDoUART==2) 
009E2:  MOV     1712,W4
009E4:  LSR     W4,#8,W4
009E6:  CP.B    W4L,#2
009E8:  BRA     NZ,9F6
.................... 				{ 
.................... 					HashR1 = Dataa; 
009EA:  MOV.B   1C6C,W0L
009EC:  MOV.B   W0L,1B15
.................... 					ToDoUART=3;	 
009EE:  MOV.B   #3,W0L
009F0:  MOV.B   W0L,1713
.................... 				}	 
009F2:  GOTO    A48
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==3)ToDoUART=4; 
009F6:  MOV     1712,W4
009F8:  LSR     W4,#8,W4
009FA:  CP.B    W4L,#3
009FC:  BRA     NZ,A06
009FE:  MOV.B   #4,W0L
00A00:  MOV.B   W0L,1713
00A02:  GOTO    A48
.................... 				// Enregistre le second Hash 
.................... 				else if(ToDoUART==4) 
00A06:  MOV     1712,W4
00A08:  LSR     W4,#8,W4
00A0A:  CP.B    W4L,#4
00A0C:  BRA     NZ,A1A
.................... 				{ 
.................... 					HashR2 = Dataa; 
00A0E:  MOV.B   1C6C,W0L
00A10:  MOV.B   W0L,1B16
.................... 					ToDoUART=5; 
00A12:  MOV.B   #5,W0L
00A14:  MOV.B   W0L,1713
.................... 				} 
00A16:  GOTO    A48
.................... 				// Capture la trame 
.................... 				else if(ToDoUART == 5)  
00A1A:  MOV     1712,W4
00A1C:  LSR     W4,#8,W4
00A1E:  CP.B    W4L,#5
00A20:  BRA     NZ,A48
.................... 				{ 
.................... 					// Hash les valeurs reçues 
.................... 					HashC1 += Dataa; 
00A22:  MOV.B   1B17,W0L
00A24:  ADD.B   1C6C,W0L
00A26:  MOV.B   W0L,1B17
.................... 					HashC2 = (HashC2+Dataa)*(PosTabToDecode+1);	 
00A28:  MOV.B   1B18,W0L
00A2A:  ADD.B   1C6C,W0L
00A2C:  MOV.B   W0L,A
00A2E:  MOV     1712,W4
00A30:  CLR.B   9
00A32:  ADD     W4,#1,W0
00A34:  CLR.B   B
00A36:  MUL.UU  W5,W0,W0
00A38:  MOV.B   W0L,1B18
.................... 					// Retire l'incrément ASCII et enregistre 
.................... 					TabToDecode[PosTabToDecode] = Dataa; 
00A3A:  MOV     1712,W4
00A3C:  CLR.B   9
00A3E:  MOV     #1612,W3
00A40:  ADD     W4,W3,W5
00A42:  MOV     1C6C,W0
00A44:  MOV.B   W0L,[W5+#0]
.................... 					 
.................... 					PosTabToDecode++; 
00A46:  INC.B   1712
.................... 				} 
.................... 			}			 
00A48:  GOTO    8EE
.................... 		}	 
.................... 	}		 
.................... 	// Quitte l'interruption 
.................... 	return; 
00A4C:  BCLR.B  85.1
00A4E:  MOV     #1A,W0
00A50:  REPEAT  #C
00A52:  MOV     [--W15],[W0--]
00A54:  MOV     [--W15],W0
00A56:  POP     32
00A58:  POP     36
00A5A:  POP     42
00A5C:  RETFIE  
.................... } 
....................  
.................... /** 
.................... * \fn void __UART_Decode(char* Tab) 
.................... * \brief Décode la trame de l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \param[in] (*)_Tab Tableau avec lequel travailler 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __UART_Decode(unsigned int32* _Tab) 
*
09574:  MOV     W5,[W15++]
09576:  MOV     #C,W5
09578:  REPEAT  #7
0957A:  MOV     [W5++],[W15++]
0957C:  CLR     1B2C
0957E:  CLR     1B30
09580:  CLR     1B32
09582:  CLR     1B34
.................... { 
.................... 	unsigned int16 index = 0; 
.................... 	unsigned int16 Xo,Yo = 0; 
.................... 	signed int16 phi = 0;	 
.................... 	static int16 memo; 
.................... 	static int16 Memorise; 
.................... 	unsigned int16 Adresse = 0; 
.................... 	// Regarde quoi faire 
.................... 	switch(*(_Tab+1)) // On saute la première adresse mémoire qui contient l'adresse du driver 
09584:  MOV     1B2A,W4
09586:  ADD     W4,#4,W0
09588:  MOV     W0,W5
0958A:  MOV     #0,W3
0958C:  MOV     [W5++],[W3++]
0958E:  MOV     [W5++],[W3++]
09590:  CP0     W0
09592:  BRA     NZ,9598
09594:  CP0     W1
09596:  BRA     Z,9624
09598:  CP      W0,#1
0959A:  BRA     NZ,95A0
0959C:  CP0     W1
0959E:  BRA     Z,9630
095A0:  CP      W0,#2
095A2:  BRA     NZ,95A8
095A4:  CP0     W1
095A6:  BRA     Z,963E
095A8:  CP      W0,#3
095AA:  BRA     NZ,95B0
095AC:  CP0     W1
095AE:  BRA     Z,9644
095B0:  CP      W0,#4
095B2:  BRA     NZ,95B8
095B4:  CP0     W1
095B6:  BRA     Z,9648
095B8:  CP      W0,#A
095BA:  BRA     NZ,95C0
095BC:  CP0     W1
095BE:  BRA     Z,964C
095C0:  CP      W0,#B
095C2:  BRA     NZ,95C8
095C4:  CP0     W1
095C6:  BRA     Z,9668
095C8:  CP      W0,#C
095CA:  BRA     NZ,95D0
095CC:  CP0     W1
095CE:  BRA     Z,966C
095D0:  CP      W0,#14
095D2:  BRA     NZ,95D8
095D4:  CP0     W1
095D6:  BRA     Z,96B0
095D8:  CP      W0,#15
095DA:  BRA     NZ,95E0
095DC:  CP0     W1
095DE:  BRA     Z,96B4
095E0:  CP      W0,#16
095E2:  BRA     NZ,95E8
095E4:  CP0     W1
095E6:  BRA     Z,9702
095E8:  CP      W0,#17
095EA:  BRA     NZ,95F0
095EC:  CP0     W1
095EE:  BRA     Z,9714
095F0:  CP      W0,#18
095F2:  BRA     NZ,95F8
095F4:  CP0     W1
095F6:  BRA     Z,975C
095F8:  CP      W0,#19
095FA:  BRA     NZ,9600
095FC:  CP0     W1
095FE:  BRA     Z,97D0
09600:  CP      W0,#1E
09602:  BRA     NZ,9608
09604:  CP0     W1
09606:  BRA     Z,97DE
09608:  CP      W0,#1F
0960A:  BRA     NZ,9610
0960C:  CP0     W1
0960E:  BRA     Z,97E2
09610:  CP      W0,#13
09612:  BRA     NZ,9618
09614:  CP0     W1
09616:  BRA     Z,97E6
09618:  MOV     #32,W4
0961A:  CP      W0,W4
0961C:  BRA     NZ,9622
0961E:  CP0     W1
09620:  BRA     Z,9840
09622:  BRA     9844
.................... 	{ 
.................... 		// Test Comm - LED Blink 
.................... 		case 0 : 
.................... 			_LED1=_LED2=_LED3=_LED4=1; 
09624:  BSET.B  2D0.4
09626:  BSET.B  2D0.3
09628:  BSET.B  2D0.2
0962A:  BSET.B  2D0.1
.................... 			break; 
0962C:  GOTO    9860
.................... 		// Demande si est connecté	 
.................... 		case 1 : 
.................... 			fputc(0x31,RS232); 
09630:  MOV.B   #31,W0L
09632:  BTSC.B  20F.1
09634:  BRA     9632
09636:  MOV.B   W0L,210
09638:  CLR.B   211
.................... 			break; 
0963A:  GOTO    9860
.................... 		// Reset la plaque 
.................... 		case 2 : 
.................... 			reset_cpu(); 
0963E:  RESET   
.................... 			break; 
09640:  GOTO    9860
.................... 		// Demande si RoboteQ connecté 
.................... 		case 3 : 
.................... 			// ? 
.................... 			break; 
09644:  GOTO    9860
.................... 		// Configuration du robot 
.................... 		case 4 :			 
.................... 			break; 
09648:  GOTO    9860
.................... 		// Change d'objectif 
.................... 		case 10 : 
.................... 			flagMarche = (int1)(*(_Tab+2)); 
0964C:  MOV     1B2A,W4
0964E:  ADD     W4,#8,W0
09650:  MOV     W0,[W15++]
09652:  MOV.B   [W0],W0L
09654:  MOV.B   W0L,FEF
09656:  MOV     [--W15],W0
09658:  CLR     W0
0965A:  BTSC.B  FEF.0
0965C:  INC     W0,W0
0965E:  BCLR.B  85B.7
09660:  BTSC.B  0.0
09662:  BSET.B  85B.7
.................... 			break; 
09664:  GOTO    9860
.................... 		//	Arrêt d'urgence 
.................... 		case 11 : 
.................... 			 
.................... 			break; 
09668:  GOTO    9860
.................... 		// Set la position de départ 
.................... 		case 12 : 
.................... 			Xo = *(_Tab+2); 
0966C:  MOV     1B2A,W4
0966E:  ADD     W4,#8,W0
09670:  MOV     [W0],[W15++]
09672:  POP     1B2E
.................... 			Yo = *(_Tab+3); 
09674:  MOV     1B2A,W4
09676:  ADD     W4,#C,W0
09678:  MOV     [W0],[W15++]
0967A:  POP     1B30
.................... 			phi = *(_Tab+4); 
0967C:  MOV     1B2A,W4
0967E:  ADD     W4,#10,W0
09680:  MOV     W0,W4
09682:  MOV     #0,W3
09684:  MOV     [W4++],[W3++]
09686:  MOV     [W4++],[W3++]
09688:  MOV     W0,1B32
.................... 			 
.................... 			write_eeprom(800,Xo); 
0968A:  MOV     #320,W0
0968C:  MOV     #1B2E,W1
0968E:  MOV     #2,W2
09690:  CALL    90A6
.................... 			write_eeprom(802,Yo); 
09694:  MOV     #322,W0
09696:  MOV     #1B30,W1
09698:  MOV     #2,W2
0969A:  CALL    90A6
.................... 			write_eeprom(804,phi); 
0969E:  MOV     #324,W0
096A0:  MOV     #1B32,W1
096A2:  MOV     #2,W2
096A4:  CALL    90A6
.................... 			 
.................... 			__Init_pos();	 
096A8:  CALL    1352
.................... 			break; 
096AC:  GOTO    9860
.................... 		 
.................... 		// Enregistre le nombre d'objectifs 
.................... 		case 20 : 
.................... 			break; 
096B0:  GOTO    9860
.................... 		// Sauvegarde un objectif en EEPROM 
.................... 		case 21 : 
.................... 			for(index = memo; index <  (memo + 28); index += 2) 
096B4:  PUSH    1B1A
096B6:  POP     1B2C
096B8:  MOV     1B1A,W4
096BA:  ADD     W4,#1C,W0
096BC:  MOV     1B2C,W4
096BE:  CP      W4,W0
096C0:  BRA     GE,96F6
.................... 			{ 
.................... 				write_eeprom(index, *( _Tab +((index - memo)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
096C2:  MOV     1B2C,W4
096C4:  MOV     1B1A,W3
096C6:  SUB     W4,W3,W5
096C8:  MOV     W5,W4
096CA:  MOV     #2,W3
096CC:  REPEAT  #11
096CE:  DIV.S   W4,W3
096D0:  MOV     W0,W5
096D2:  MOV     W5,W4
096D4:  MUL.UU  W4,#4,W0
096D6:  MOV     1B2A,W4
096D8:  ADD     W0,W4,W5
096DA:  ADD     W5,#C,W0
096DC:  MOV     #A,W4
096DE:  MOV     [W0++],[W4++]
096E0:  MOV     [W0++],[W4++]
096E2:  MOV     1B2C,W0
096E4:  MOV     #A,W1
096E6:  MOV     #2,W2
096E8:  CALL    90A6
096EC:  MOV     1B2C,W4
096EE:  ADD     W4,#2,W0
096F0:  MOV     W0,1B2C
096F2:  GOTO    96B8
.................... 			} 
.................... 			memo = index; //offset afin d'aler écrie plus loin dans l'eeprom 
096F6:  PUSH    1B2C
096F8:  POP     1B1A
.................... 			__ReadObjectifs(); 
096FA:  CALL    124E
.................... 		break; 
096FE:  GOTO    9860
.................... 		// Définit le prochain objectif à charger 
.................... 		case 22 : 
.................... 			NextObj=(unsigned int16)*(_Tab+2); 
09702:  MOV     1B2A,W4
09704:  ADD     W4,#8,W0
09706:  MOV     W0,W4
09708:  MOV     #0,W3
0970A:  MOV     [W4++],[W3++]
0970C:  MOV     [W4++],[W3++]
0970E:  MOV     W0,14C8
.................... 			break; 
09710:  GOTO    9860
.................... 		// Set les PIDs de roboteQ 
.................... 		case 23 : 
.................... 			while(index<250)//reset le tableau 
09714:  MOV     1B2C,W4
09716:  MOV     #FA,W3
09718:  CP      W3,W4
0971A:  BRA     LEU,972C
.................... 			{ 
.................... 				 TabSentRS232[index] = '\r'; 
0971C:  MOV     #994,W4
0971E:  MOV     1B2C,W3
09720:  ADD     W3,W4,W5
09722:  MOV.B   #D,W0L
09724:  MOV.B   W0L,[W5]
.................... 				 index++; 
09726:  INC     1B2C
09728:  GOTO    9714
.................... 			} 
.................... 			index = 0; 
0972C:  CLR     1B2C
.................... 			index = 0; 
0972E:  CLR     1B2C
.................... 			while(index<10) // on recupere les donnees 
09730:  MOV     1B2C,W4
09732:  CP      W4,#A
09734:  BRA     C,9744
.................... 			{ 
.................... 				 __GetRoboteqPID(index); 
09736:  MOV.B   1B2C,W0L
09738:  MOV.B   W0L,1B36
0973A:  CALL    90E0
.................... 				 index++; 
0973E:  INC     1B2C
09740:  GOTO    9730
09744:  PUSH    42
09746:  BCLR.B  81.7
09748:  SETM.B  42
0974A:  BSET.B  81.7
.................... 			} 
.................... 			__SendBackUART(); // on envoie a la plaque 
0974C:  CALL    5C0
09750:  BCLR.B  81.7
09752:  POP     42
09754:  BSET.B  81.7
.................... 			index = 0; 
09756:  CLR     1B2C
.................... 			break; 
09758:  GOTO    9860
.................... 		case 24 : 
.................... 			__SetRoboteqPID(*(_Tab+2),*(_Tab+3),*(_Tab+4),*(_Tab+5),*(_Tab+6),*(_Tab+7),*(_Tab+8),*(_Tab+9),*(_Tab+10),*(_Tab+11)); 
0975C:  MOV     1B2A,W4
0975E:  ADD     W4,#8,W0
09760:  MOV     #A,W4
09762:  MOV     [W0++],[W4++]
09764:  MOV     [W0++],[W4++]
09766:  MOV     1B2A,W4
09768:  ADD     W4,#C,W0
0976A:  MOV     [W0],W7
0976C:  MOV     1B2A,W4
0976E:  ADD     W4,#10,W0
09770:  MOV     [W0],W8
09772:  MOV     1B2A,W4
09774:  ADD     W4,#14,W0
09776:  MOV     [W0],W9
09778:  MOV     1B2A,W4
0977A:  ADD     W4,#18,W0
0977C:  MOV     [W0],W10
0977E:  MOV     1B2A,W4
09780:  ADD     W4,#1C,W0
09782:  MOV     [W0],W11
09784:  MOV     #20,W4
09786:  MOV     1B2A,W3
09788:  ADD     W3,W4,W0
0978A:  MOV     [W0],W12
0978C:  MOV     #24,W4
0978E:  MOV     1B2A,W3
09790:  ADD     W3,W4,W0
09792:  MOV     [W0],W13
09794:  MOV     #28,W4
09796:  MOV     1B2A,W3
09798:  ADD     W3,W4,W0
0979A:  MOV     [W0],[W15++]
0979C:  POP     1B36
0979E:  MOV     #2C,W4
097A0:  MOV     1B2A,W3
097A2:  ADD     W3,W4,W0
097A4:  MOV     [W0],[W15++]
097A6:  POP     1B38
097A8:  PUSH    1B4C
097AA:  MOV.B   W5L,[W15-#2]
097AC:  POP     1B4C
097AE:  MOV     W7,1B4E
097B0:  MOV     W8,1B50
097B2:  MOV     W9,1B52
097B4:  MOV     W10,1B54
097B6:  MOV     W11,1B56
097B8:  MOV     W12,1B58
097BA:  MOV     W13,1B5A
097BC:  PUSH    1B36
097BE:  POP     1B5C
097C0:  PUSH    1B38
097C2:  POP     1B5E
097C4:  CALL    92DC
.................... 			__reset_Roboteq(); 
097C8:  CALL    94A8
.................... 			break; 
097CC:  GOTO    9860
.................... 		 
.................... 		//erase eeprom 
.................... 		case 25 : 
.................... 			__resetEEPROM(); 
097D0:  CALL    94CC
.................... 			reset_cpu();     
097D4:  RESET   
.................... 			break;		 
097D6:  GOTO    9860
.................... 		 
.................... 			break; 
097DA:  GOTO    9860
.................... 		// Ouvre ou ferme l'étau 
.................... 		case 30 : 
.................... 			break; 
097DE:  GOTO    9860
.................... 		// Position hold ou release du servo 
.................... 		case 31 : 
.................... 			break;			 
097E2:  GOTO    9860
.................... 		case 19 : 
.................... 			for(Adresse = Memorise ; Adresse <= 16 + Memorise ; Adresse += 2) 
097E6:  PUSH    1B1C
097E8:  POP     1B34
097EA:  MOV     #10,W0
097EC:  ADD     1B1C,W0
097EE:  MOV     1B34,W4
097F0:  CP      W4,W0
097F2:  BRA     GT,9834
.................... 			{ 
.................... 				write_eeprom(Adresse + 200 , *( _Tab +((Adresse - Memorise)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
097F4:  MOV     #C8,W4
097F6:  MOV     1B34,W3
097F8:  ADD     W3,W4,W5
097FA:  MOV     1B34,W4
097FC:  MOV     1B1C,W3
097FE:  SUB     W4,W3,W6
09800:  MOV     W6,W4
09802:  MOV     #2,W3
09804:  REPEAT  #11
09806:  DIV.S   W4,W3
09808:  MOV     W0,W6
0980A:  MOV     W6,W4
0980C:  MUL.UU  W4,#4,W0
0980E:  MOV     1B2A,W4
09810:  ADD     W0,W4,W6
09812:  ADD     W6,#C,W0
09814:  MOV     #C,W4
09816:  MOV     [W0++],[W4++]
09818:  MOV     [W0++],[W4++]
0981A:  MOV     W5,W0
0981C:  MOV     #C,W1
0981E:  MOV     #2,W2
09820:  CALL    90A6
.................... 				delay_ms(5); 
09824:  MOV     #5,W0
09826:  CALL    E90
0982A:  MOV     1B34,W4
0982C:  ADD     W4,#2,W0
0982E:  MOV     W0,1B34
09830:  GOTO    97EA
.................... 			} 
.................... 			Memorise = Adresse; //offset afin d'aler écrie plus loin dans l'eeprom 
09834:  PUSH    1B34
09836:  POP     1B1C
.................... 			__ReadZones_Interdites();		 
09838:  CALL    94F4
.................... 			break; 
0983C:  GOTO    9860
.................... 		// Ne lit plus les objectifs en ROM avant une nouvelle écriture	 
.................... 		case 50 :			 
.................... 			break;	 
09840:  GOTO    9860
.................... 			 
.................... 			// Avertit le PC d'une action inconnue 
.................... 		default : 
.................... 			fprintf(RS232,"Carte Principale : Commande Inconnue\r"); 
09844:  MOV     #0,W1
09846:  MOV     W1,W0
09848:  CLR.B   1
0984A:  CALL    3C4
0984E:  INC     W1,W1
09850:  BTSC.B  20F.1
09852:  BRA     9850
09854:  MOV     W0,210
09856:  MOV     #24,W0
09858:  CPSGT   W1,W0
0985A:  BRA     9846
.................... 			break; 
0985C:  GOTO    9860
.................... 	} 
.................... 	 
.................... 	// Permet de recevoir à nouveau 
.................... 	PCh_flagUARTReadyToDecode = 0; 
09860:  BCLR.B  1611.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
09862:  MOV     #1A,W5
09864:  REPEAT  #7
09866:  MOV     [--W15],[W5--]
09868:  MOV     [--W15],W5
0986A:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __SendBackUART(void) 
.................... * \brief Envoi des commandes en UART 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.01.2016 
.................... * 
.................... * \return Ne retourne rien 
....................  
.................... */ 
.................... void __SendBackUART(void) 
*
005C0:  MOV     W5,[W15++]
005C2:  MOV     #994,W4
005C4:  MOV     W4,1C70
005C6:  CLR.B   1C6E
.................... { 
.................... 	char* ptrBuffy = TabSentRS232; 
.................... 	// Envoi commande 
.................... 	unsigned int8 ToEndSend=0; 
.................... 	while(*(ptrBuffy+ToEndSend)!='\r' && *(ptrBuffy+ToEndSend)!=ETX) // Attend de voir la fin de tableau 
005C8:  MOV     1C6E,W4
005CA:  CLR.B   9
005CC:  MOV     1C70,W3
005CE:  ADD     W3,W4,W0
005D0:  MOV.B   [W0],W4L
005D2:  CP.B    W4L,#D
005D4:  BRA     Z,5FE
005D6:  MOV     1C6E,W4
005D8:  CLR.B   9
005DA:  MOV     1C70,W3
005DC:  ADD     W3,W4,W0
005DE:  MOV.B   [W0],W4L
005E0:  CP.B    W4L,#3
005E2:  BRA     Z,5FE
.................... 	{ 
.................... 		fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi la commande 
005E4:  MOV     1C6E,W4
005E6:  CLR.B   9
005E8:  MOV     1C70,W3
005EA:  ADD     W3,W4,W0
005EC:  MOV.B   [W0],W5L
005EE:  MOV.B   W5L,W0L
005F0:  BTSC.B  20F.1
005F2:  BRA     5F0
005F4:  MOV.B   W0L,210
005F6:  CLR.B   211
.................... 		ToEndSend++; 
005F8:  INC.B   1C6E
005FA:  GOTO    5C8
.................... 	}	 
.................... 	fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi le caractère de fin de commande 
005FE:  MOV     1C6E,W4
00600:  CLR.B   9
00602:  MOV     1C70,W3
00604:  ADD     W3,W4,W0
00606:  MOV.B   [W0],W5L
00608:  MOV.B   W5L,W0L
0060A:  BTSC.B  20F.1
0060C:  BRA     60A
0060E:  MOV.B   W0L,210
00610:  CLR.B   211
.................... 	TabSentRS232[ToEndSend]=*(ptrBuffy+ToEndSend); 
00612:  MOV     1C6E,W4
00614:  CLR.B   9
00616:  MOV     #994,W3
00618:  ADD     W4,W3,W5
0061A:  MOV     1C6E,W4
0061C:  CLR.B   9
0061E:  MOV     1C70,W3
00620:  ADD     W3,W4,W0
00622:  MOV.B   [W0],[W5]
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
00624:  MOV     [--W15],W5
00626:  RETURN  
.................... }	 
....................  
.................... // Décode un tableau 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec) 
*
0085E:  MOV     W5,[W15++]
00860:  MOV.B   #1,W0L
00862:  MOV.B   W0L,1C72
00864:  CLR.B   1C73
00866:  CLR.B   1C74
.................... { 
.................... 	// Permet de se balader dans le tableau 
.................... 	unsigned int8 i=1,j=0,ki=0; 
.................... 	char TempTab[11]={0}; // Taille max d'un int32 + NULL 
00868:  CLR     1C76
0086A:  CLR     1C78
0086C:  CLR     1C7A
0086E:  CLR     1C7C
00870:  CLR     1C7E
00872:  CLR.B   1C80
.................... 	// On décode tout 
.................... 	while(_TabToDec[i]!=ETX) 
00874:  MOV     1C72,W4
00876:  CLR.B   9
00878:  MOV     W4,W0
0087A:  ADD     1C6E,W0
0087C:  MOV.B   [W0],W4L
0087E:  CP.B    W4L,#3
00880:  BRA     Z,8D6
.................... 	{ 
.................... 		// On cherche la fin d'un nombre 
.................... 		while(_TabToDec[i]!=SPACE) 
00882:  MOV     1C72,W4
00884:  CLR.B   9
00886:  MOV     W4,W0
00888:  ADD     1C6E,W0
0088A:  MOV.B   [W0],W4L
0088C:  XOR.B   #20,W4L
0088E:  BRA     Z,8AA
.................... 		{ 
.................... 			TempTab[j]=(char)(_TabToDec[i]); 
00890:  MOV     1C72,W4
00892:  LSR     W4,#8,W4
00894:  MOV     #1C76,W3
00896:  ADD     W4,W3,W5
00898:  MOV     1C72,W4
0089A:  CLR.B   9
0089C:  MOV     W4,W0
0089E:  ADD     1C6E,W0
008A0:  MOV.B   [W0],[W5]
.................... 			i++;j++; 
008A2:  INC.B   1C72
008A4:  INC.B   1C73
008A6:  GOTO    882
.................... 		}	 
.................... 		TempTab[j]=NUL; 
008AA:  MOV     1C72,W4
008AC:  LSR     W4,#8,W4
008AE:  MOV     #1C76,W3
008B0:  ADD     W4,W3,W5
008B2:  CLR.B   [W5]
.................... 		i++;j=0; 
008B4:  INC.B   1C72
008B6:  CLR.B   1C73
.................... 		// On enregistre le nombres 
.................... 		_TabDec[ki]=(unsigned int32)atoi32(TempTab); 
008B8:  MOV.B   1C74,W0L
008BA:  CLR.B   1
008BC:  SL      W0,#2,W0
008BE:  MOV     1C70,W4
008C0:  ADD     W0,W4,W5
008C2:  MOV     #1C76,W4
008C4:  MOV     W4,1C82
008C6:  CALL    66A
008CA:  MOV     #0,W4
008CC:  MOV     [W4++],[W5++]
008CE:  MOV     [W4++],[W5++]
.................... 		ki++; 
008D0:  INC.B   1C74
008D2:  GOTO    874
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
008D6:  MOV     [--W15],W5
008D8:  RETURN  
.................... }	 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_h 
.................... #define ___Zones_interdites_h 
....................  
....................  
....................  
.................... enum{x1, y1, x4, y4}; 
....................  
.................... int x3 = 0; 
.................... int y3 = 3; 
.................... int x2 = 2; 
.................... int y2 = 1; 
....................  
.................... int checkPath(); 
....................  
.................... void findPath(); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... double getDist(double x1, double y1, double x2, double y2); 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y); 
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int xStart, int yStart, int xEnd, int yEnd, int i_zone); 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.c" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_c 
.................... #define ___Zones_interdites_c 
....................  
....................  
.................... int checkPath() 
.................... { 
.................... 	path_found = 0; 
*
01930:  CLR     A96
....................  
....................     start.X = Pos_x; 
01932:  MOV     15BC,W0
01934:  CLR     W3
01936:  BTSC    W0.F
01938:  SETM    W3
0193A:  MOV     W3,W1
0193C:  MOV     W3,W2
0193E:  CALL    12E8
01942:  MOV     W0,B52
01944:  MOV     W1,B54
01946:  MOV     W2,B56
01948:  MOV     W3,B58
....................     start.Y = Pos_y; 
0194A:  MOV     15BE,W0
0194C:  CLR     W3
0194E:  BTSC    W0.F
01950:  SETM    W3
01952:  MOV     W3,W1
01954:  MOV     W3,W2
01956:  CALL    12E8
0195A:  MOV     W0,B5A
0195C:  MOV     W1,B5C
0195E:  MOV     W2,B5E
01960:  MOV     W3,B60
....................  
....................     end.X = oXp; 
01962:  MOV     14A4,W0
01964:  CLR     W3
01966:  BTSC    W0.F
01968:  SETM    W3
0196A:  MOV     W3,W1
0196C:  MOV     W3,W2
0196E:  CALL    12E8
01972:  MOV     W0,B62
01974:  MOV     W1,B64
01976:  MOV     W2,B66
01978:  MOV     W3,B68
....................     end.Y = oYp; 
0197A:  MOV     14A6,W0
0197C:  CLR     W3
0197E:  BTSC    W0.F
01980:  SETM    W3
01982:  MOV     W3,W1
01984:  MOV     W3,W2
01986:  CALL    12E8
0198A:  MOV     W0,B6A
0198C:  MOV     W1,B6C
0198E:  MOV     W2,B6E
01990:  MOV     W3,B70
....................  
....................     checkIntersection(start.X, start.Y, end.X, end.Y); 
01992:  PUSH    B52
01994:  POP     1B3E
01996:  PUSH    B54
01998:  POP     1B40
0199A:  PUSH    B56
0199C:  POP     1B42
0199E:  PUSH    B58
019A0:  POP     1B44
019A2:  PUSH    B5A
019A4:  POP     1B46
019A6:  PUSH    B5C
019A8:  POP     1B48
019AA:  PUSH    B5E
019AC:  POP     1B4A
019AE:  PUSH    B60
019B0:  POP     1B4C
019B2:  PUSH    B62
019B4:  POP     1B4E
019B6:  PUSH    B64
019B8:  POP     1B50
019BA:  PUSH    B66
019BC:  POP     1B52
019BE:  PUSH    B68
019C0:  POP     1B54
019C2:  PUSH    B6A
019C4:  POP     1B56
019C6:  PUSH    B6C
019C8:  POP     1B58
019CA:  PUSH    B6E
019CC:  POP     1B5A
019CE:  PUSH    B70
019D0:  POP     1B5C
019D2:  CALL    166E
.................... 		 
.................... 	if (intersection_found > 0) 
019D6:  MOV     A94,W4
019D8:  CP      W4,#0
019DA:  BRA     LE,19E2
.................... 	{ 
.................... 			path_found = 0; 
019DC:  CLR     A96
.................... 	} 
019DE:  GOTO    19E6
.................... 	else 
.................... 	{ 
.................... 			path_found = 1; 
019E2:  MOV     #1,W4
019E4:  MOV     W4,A96
.................... 	} 
....................  
.................... 	return path_found; 
019E6:  PUSH    A96
019E8:  POP     0
019EA:  RETURN  
....................    
.................... } 
....................  
.................... void findPath() 
*
05E7E:  MOV     W5,[W15++]
05E80:  MOV     #C,W5
05E82:  REPEAT  #7
05E84:  MOV     [W5++],[W15++]
.................... { 
....................     i_rel = 0; 
05E86:  CLR     A9A
....................  
....................     //On trouve le premier point relai 
....................     findRel(start.X, start.Y, end.X, end.Y, 0); 
05E88:  MOV     B52,W0
05E8A:  MOV     B54,W1
05E8C:  MOV     B56,W2
05E8E:  MOV     B58,W3
05E90:  CALL    19EC
05E94:  MOV     W0,W5
05E96:  MOV     B5A,W0
05E98:  MOV     B5C,W1
05E9A:  MOV     B5E,W2
05E9C:  MOV     B60,W3
05E9E:  CALL    19EC
05EA2:  MOV     W0,W6
05EA4:  MOV     B62,W0
05EA6:  MOV     B64,W1
05EA8:  MOV     B66,W2
05EAA:  MOV     B68,W3
05EAC:  CALL    19EC
05EB0:  MOV     W0,W7
05EB2:  MOV     B6A,W0
05EB4:  MOV     B6C,W1
05EB6:  MOV     B6E,W2
05EB8:  MOV     B70,W3
05EBA:  CALL    19EC
05EBE:  MOV     W0,W8
05EC0:  MOV     W5,1B36
05EC2:  MOV     W6,1B38
05EC4:  MOV     W7,1B3A
05EC6:  MOV     W8,1B3C
05EC8:  CLR     1B3E
05ECA:  CALL    2BAC
....................  
....................     //On vÃ©rifie si depuis le premier point relai on intercepte encore une zone 
....................     checkIntersection(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end.X, end.Y); 
05ECE:  MOV     A9A,W4
05ED0:  SUB     W4,#1,W5
05ED2:  MOV     W5,W4
05ED4:  MUL.UU  W4,#10,W0
05ED6:  MOV     W0,W5
05ED8:  MOV     #AB2,W4
05EDA:  ADD     W5,W4,W0
05EDC:  MOV     #C,W4
05EDE:  REPEAT  #3
05EE0:  MOV     [W0++],[W4++]
05EE2:  MOV     A9A,W4
05EE4:  SUB     W4,#1,W10
05EE6:  MOV     W10,W4
05EE8:  MUL.UU  W4,#10,W10
05EEA:  ADD     W10,#8,W0
05EEC:  MOV     #AB2,W4
05EEE:  ADD     W0,W4,W0
05EF0:  MOV     #14,W4
05EF2:  REPEAT  #3
05EF4:  MOV     [W0++],[W4++]
05EF6:  MOV     W6,1B3E
05EF8:  MOV     W7,1B40
05EFA:  MOV     W8,1B42
05EFC:  MOV     W9,1B44
05EFE:  MOV     W10,1B46
05F00:  MOV     W11,1B48
05F02:  MOV     W12,1B4A
05F04:  MOV     W13,1B4C
05F06:  PUSH    B62
05F08:  POP     1B4E
05F0A:  PUSH    B64
05F0C:  POP     1B50
05F0E:  PUSH    B66
05F10:  POP     1B52
05F12:  PUSH    B68
05F14:  POP     1B54
05F16:  PUSH    B6A
05F18:  POP     1B56
05F1A:  PUSH    B6C
05F1C:  POP     1B58
05F1E:  PUSH    B6E
05F20:  POP     1B5A
05F22:  PUSH    B70
05F24:  POP     1B5C
05F26:  CALL    166E
....................  
....................     if(path_found < 1) 
05F2A:  MOV     A96,W4
05F2C:  CP      W4,#1
05F2E:  BRA     GE,5FFE
....................     { 
....................     	int i = 0; 
05F30:  CLR     1B2A
.................... 	    //Si on intecepte encore une zone alors intersection_found sera >1 
.................... 	    while(intersection_found > 0) 
05F32:  MOV     A94,W4
05F34:  CP      W4,#0
05F36:  BRA     LE,5FFE
.................... 	    { 
.................... 	        //Tant qu'on intercepte une zone depuis le point relai on continue Ã  en chercher un autre 
.................... 	        i++; 
05F38:  INC     1B2A
.................... 	        findRel(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end.X, end.Y, 0); 
05F3A:  MOV     A9A,W4
05F3C:  SUB     W4,#1,W5
05F3E:  MOV     W5,W4
05F40:  MUL.UU  W4,#10,W0
05F42:  MOV     W0,W5
05F44:  MOV     #AB2,W4
05F46:  ADD     W5,W4,W0
05F48:  MOV     W0,W4
05F4A:  MOV     #0,W3
05F4C:  REPEAT  #3
05F4E:  MOV     [W4++],[W3++]
05F50:  CALL    19EC
05F54:  MOV     W0,W6
05F56:  MOV     A9A,W4
05F58:  SUB     W4,#1,W7
05F5A:  MOV     W7,W4
05F5C:  MUL.UU  W4,#10,W0
05F5E:  MOV     W0,W7
05F60:  ADD     W7,#8,W0
05F62:  MOV     #AB2,W4
05F64:  ADD     W0,W4,W0
05F66:  MOV     W0,W4
05F68:  MOV     #0,W3
05F6A:  REPEAT  #3
05F6C:  MOV     [W4++],[W3++]
05F6E:  CALL    19EC
05F72:  MOV     W0,W7
05F74:  MOV     B62,W0
05F76:  MOV     B64,W1
05F78:  MOV     B66,W2
05F7A:  MOV     B68,W3
05F7C:  CALL    19EC
05F80:  MOV     W0,W8
05F82:  MOV     B6A,W0
05F84:  MOV     B6C,W1
05F86:  MOV     B6E,W2
05F88:  MOV     B70,W3
05F8A:  CALL    19EC
05F8E:  MOV     W0,W9
05F90:  MOV     W6,1B36
05F92:  MOV     W7,1B38
05F94:  MOV     W8,1B3A
05F96:  MOV     W9,1B3C
05F98:  CLR     1B3E
05F9A:  CALL    2BAC
.................... 	        checkIntersection(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end.X, end.Y); 
05F9E:  MOV     A9A,W4
05FA0:  SUB     W4,#1,W5
05FA2:  MOV     W5,W4
05FA4:  MUL.UU  W4,#10,W0
05FA6:  MOV     W0,W5
05FA8:  MOV     #AB2,W4
05FAA:  ADD     W5,W4,W0
05FAC:  MOV     #C,W4
05FAE:  REPEAT  #3
05FB0:  MOV     [W0++],[W4++]
05FB2:  MOV     A9A,W4
05FB4:  SUB     W4,#1,W10
05FB6:  MOV     W10,W4
05FB8:  MUL.UU  W4,#10,W10
05FBA:  ADD     W10,#8,W0
05FBC:  MOV     #AB2,W4
05FBE:  ADD     W0,W4,W0
05FC0:  MOV     #14,W4
05FC2:  REPEAT  #3
05FC4:  MOV     [W0++],[W4++]
05FC6:  MOV     W6,1B3E
05FC8:  MOV     W7,1B40
05FCA:  MOV     W8,1B42
05FCC:  MOV     W9,1B44
05FCE:  MOV     W10,1B46
05FD0:  MOV     W11,1B48
05FD2:  MOV     W12,1B4A
05FD4:  MOV     W13,1B4C
05FD6:  PUSH    B62
05FD8:  POP     1B4E
05FDA:  PUSH    B64
05FDC:  POP     1B50
05FDE:  PUSH    B66
05FE0:  POP     1B52
05FE2:  PUSH    B68
05FE4:  POP     1B54
05FE6:  PUSH    B6A
05FE8:  POP     1B56
05FEA:  PUSH    B6C
05FEC:  POP     1B58
05FEE:  PUSH    B6E
05FF0:  POP     1B5A
05FF2:  PUSH    B70
05FF4:  POP     1B5C
05FF6:  CALL    166E
05FFA:  GOTO    5F32
.................... 	    } 
....................     } 
05FFE:  MOV     #1A,W5
06000:  REPEAT  #7
06002:  MOV     [--W15],[W5--]
06004:  MOV     [--W15],W5
06006:  RETURN  
....................      
....................  
....................  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getDist 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... double getDist(double x1, double y1, double x2, double y2) 
*
02AE8:  MOV     W5,[W15++]
02AEA:  MOV     #C,W5
02AEC:  REPEAT  #6
02AEE:  MOV     [W5++],[W15++]
.................... { 
....................     return (sqrt(pow((x2-x1),2)) + (pow((y2-y1),2))); 
02AF0:  BSET.B  43.0
02AF2:  MOV     1B8A,W0
02AF4:  MOV     1B8C,W1
02AF6:  MOV     1B8E,W2
02AF8:  MOV     1B90,W3
02AFA:  MOV     1B7A,W4
02AFC:  MOV     1B7C,W5
02AFE:  MOV     1B7E,W6
02B00:  MOV     1B80,W7
02B02:  CALL    13FC
02B06:  MOV     W0,W5
02B08:  MOV     W1,W6
02B0A:  MOV     W2,W7
02B0C:  MOV     W3,W8
02B0E:  MOV     W5,1BAA
02B10:  MOV     W6,1BAC
02B12:  MOV     W7,1BAE
02B14:  MOV     W8,1BB0
02B16:  CLR     1BB2
02B18:  CLR     1BB4
02B1A:  CLR     1BB6
02B1C:  MOV     #4000,W4
02B1E:  MOV     W4,1BB8
02B20:  CALL    2768
02B24:  MOV     W0,W5
02B26:  MOV     W1,W6
02B28:  MOV     W2,W7
02B2A:  MOV     W3,W8
02B2C:  MOV     W5,1BC2
02B2E:  MOV     W6,1BC4
02B30:  MOV     W7,1BC6
02B32:  MOV     W8,1BC8
02B34:  CALL    29CC
02B38:  MOV     W0,W5
02B3A:  MOV     W1,W6
02B3C:  MOV     W2,W7
02B3E:  MOV     W3,W8
02B40:  BSET.B  43.0
02B42:  MOV     W5,[W15++]
02B44:  MOV     W6,[W15++]
02B46:  MOV     W7,[W15++]
02B48:  MOV     1B92,W0
02B4A:  MOV     1B94,W1
02B4C:  MOV     1B96,W2
02B4E:  MOV     1B98,W3
02B50:  MOV     1B82,W4
02B52:  MOV     1B84,W5
02B54:  MOV     1B86,W6
02B56:  MOV     1B88,W7
02B58:  CALL    13FC
02B5C:  MOV     [--W15],W7
02B5E:  MOV     [--W15],W6
02B60:  MOV     [--W15],W5
02B62:  MOV     W0,W9
02B64:  MOV     W1,W10
02B66:  MOV     W2,W11
02B68:  MOV     W3,W12
02B6A:  MOV     W9,1BAA
02B6C:  MOV     W10,1BAC
02B6E:  MOV     W11,1BAE
02B70:  MOV     W12,1BB0
02B72:  CLR     1BB2
02B74:  CLR     1BB4
02B76:  CLR     1BB6
02B78:  MOV     #4000,W4
02B7A:  MOV     W4,1BB8
02B7C:  CALL    2768
02B80:  BCLR.B  43.0
02B82:  MOV     W5,[W15++]
02B84:  MOV     W6,[W15++]
02B86:  MOV     W7,[W15++]
02B88:  MOV     W0,W4
02B8A:  MOV     W5,W0
02B8C:  MOV     W1,W5
02B8E:  MOV     W6,W1
02B90:  MOV     W2,W6
02B92:  MOV     W7,W2
02B94:  MOV     W3,W7
02B96:  MOV     W8,W3
02B98:  CALL    13FC
02B9C:  MOV     [--W15],W7
02B9E:  MOV     [--W15],W6
02BA0:  MOV     [--W15],W5
02BA2:  MOV     #18,W5
02BA4:  REPEAT  #6
02BA6:  MOV     [--W15],[W5--]
02BA8:  MOV     [--W15],W5
02BAA:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y) 
*
0166E:  MOV     W5,[W15++]
01670:  MOV     #C,W5
01672:  REPEAT  #4
01674:  MOV     [W5++],[W15++]
01676:  CLR     1B6E
.................... { 
.................... 	struct Coord spot; 
....................  
....................     int zoneToCheck = 0; 
....................  
....................     intersection_found = 0; 
01678:  CLR     A94
....................  
....................     int j; 
....................     for ( j= 0; j < 10; j++) 
0167A:  CLR     1B70
0167C:  MOV     1B70,W4
0167E:  CP      W4,#A
01680:  BRA     GE,1696
....................     { 
....................         TabIntersection[j] = 0; 
01682:  MOV     1B70,W4
01684:  MUL.UU  W4,#2,W0
01686:  MOV     #A9E,W4
01688:  ADD     W0,W4,W5
0168A:  CLR.B   [W5]
0168C:  MOV.B   #0,W0L
0168E:  MOV.B   W0L,[W5+#1]
01690:  INC     1B70
01692:  GOTO    167C
....................     } 
....................      
....................  
....................     double dX = pt2X-pt1X; 
....................     double dY = pt2Y-pt1Y; 
....................  
....................     int i = 0; 
01696:  BSET.B  43.0
01698:  MOV     1B4E,W0
0169A:  MOV     1B50,W1
0169C:  MOV     1B52,W2
0169E:  MOV     1B54,W3
016A0:  MOV     1B3E,W4
016A2:  MOV     1B40,W5
016A4:  MOV     1B42,W6
016A6:  MOV     1B44,W7
016A8:  CALL    13FC
016AC:  MOV     W0,1B72
016AE:  MOV     W1,1B74
016B0:  MOV     W2,1B76
016B2:  MOV     W3,1B78
016B4:  BSET.B  43.0
016B6:  MOV     1B56,W0
016B8:  MOV     1B58,W1
016BA:  MOV     1B5A,W2
016BC:  MOV     1B5C,W3
016BE:  MOV     1B46,W4
016C0:  MOV     1B48,W5
016C2:  MOV     1B4A,W6
016C4:  MOV     1B4C,W7
016C6:  CALL    13FC
016CA:  MOV     W0,1B7A
016CC:  MOV     W1,1B7C
016CE:  MOV     W2,1B7E
016D0:  MOV     W3,1B80
016D2:  CLR     1B82
....................  
....................     do 
....................     { 
....................         i++; 
016D4:  INC     1B82
....................  
....................         //On calcule des points le long du trajet 
....................         spot.X = (dX*i)/100; 
016D6:  MOV     1B82,W0
016D8:  CLR     W3
016DA:  BTSC    W0.F
016DC:  SETM    W3
016DE:  MOV     W3,W1
016E0:  MOV     W3,W2
016E2:  CALL    12E8
016E6:  MOV     W0,W4
016E8:  MOV     W1,W5
016EA:  MOV     W2,W6
016EC:  MOV     W3,W7
016EE:  MOV     1B72,W0
016F0:  MOV     1B74,W1
016F2:  MOV     1B76,W2
016F4:  MOV     1B78,W3
016F6:  CALL    BCC
016FA:  MOV     W0,W5
016FC:  MOV     W1,W6
016FE:  MOV     W2,W7
01700:  MOV     W3,W8
01702:  MOV     W5,[W15++]
01704:  MOV     W6,[W15++]
01706:  MOV     W7,[W15++]
01708:  MOV     W5,W0
0170A:  MOV     W6,W1
0170C:  MOV     W7,W2
0170E:  MOV     W8,W3
01710:  MOV     #0,W4
01712:  MOV     #0,W5
01714:  MOV     #0,W6
01716:  MOV     #4059,W7
01718:  CALL    CDC
0171C:  MOV     [--W15],W7
0171E:  MOV     [--W15],W6
01720:  MOV     [--W15],W5
01722:  MOV     W0,1B5E
01724:  MOV     W1,1B60
01726:  MOV     W2,1B62
01728:  MOV     W3,1B64
....................         spot.Y = (dY*i)/100; 
0172A:  MOV     1B82,W0
0172C:  CLR     W3
0172E:  BTSC    W0.F
01730:  SETM    W3
01732:  MOV     W3,W1
01734:  MOV     W3,W2
01736:  CALL    12E8
0173A:  MOV     W0,W4
0173C:  MOV     W1,W5
0173E:  MOV     W2,W6
01740:  MOV     W3,W7
01742:  MOV     1B7A,W0
01744:  MOV     1B7C,W1
01746:  MOV     1B7E,W2
01748:  MOV     1B80,W3
0174A:  CALL    BCC
0174E:  MOV     W0,W5
01750:  MOV     W1,W6
01752:  MOV     W2,W7
01754:  MOV     W3,W8
01756:  MOV     W5,[W15++]
01758:  MOV     W6,[W15++]
0175A:  MOV     W7,[W15++]
0175C:  MOV     W5,W0
0175E:  MOV     W6,W1
01760:  MOV     W7,W2
01762:  MOV     W8,W3
01764:  MOV     #0,W4
01766:  MOV     #0,W5
01768:  MOV     #0,W6
0176A:  MOV     #4059,W7
0176C:  CALL    CDC
01770:  MOV     [--W15],W7
01772:  MOV     [--W15],W6
01774:  MOV     [--W15],W5
01776:  MOV     W0,1B66
01778:  MOV     W1,1B68
0177A:  MOV     W2,1B6A
0177C:  MOV     W3,1B6C
....................  
....................  
....................         //Pour chaque point du trajet on vÃ©rifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < 10; zoneToCheck++) 
0177E:  CLR     1B6E
01780:  MOV     1B6E,W4
01782:  CP      W4,#A
01784:  BRA     GE,190A
....................         { 
....................             //On vÃ©rifie si le point se trouve dans la zone interdite 
.................... 	        if ((spot.X+pt1X) >= TabZones[zoneToCheck][0] && (spot.X+pt1X) <= TabZones[zoneToCheck][2]) 
01786:  BCLR.B  43.0
01788:  MOV     1B5E,W0
0178A:  MOV     1B60,W1
0178C:  MOV     1B62,W2
0178E:  MOV     1B64,W3
01790:  MOV     1B3E,W4
01792:  MOV     1B40,W5
01794:  MOV     1B42,W6
01796:  MOV     1B44,W7
01798:  CALL    13FC
0179C:  MOV     W0,W5
0179E:  MOV     W1,W6
017A0:  MOV     W2,W7
017A2:  MOV     W3,W8
017A4:  MOV     1B6E,W4
017A6:  MUL.UU  W4,#10,W0
017A8:  MOV     W0,W9
017AA:  MOV     #B72,W4
017AC:  ADD     W9,W4,W0
017AE:  MOV     W0,W4
017B0:  MOV     #0,W3
017B2:  MOV     [W4++],[W3++]
017B4:  MOV     [W4++],[W3++]
017B6:  MOV     #0,W2
017B8:  MOV     #0,W3
017BA:  CALL    12E8
017BE:  MOV     W5,[W15++]
017C0:  MOV     W6,[W15++]
017C2:  MOV     W7,[W15++]
017C4:  MOV     W5,W4
017C6:  MOV     W6,W5
017C8:  MOV     W7,W6
017CA:  MOV     W8,W7
017CC:  CALL    15EA
017D0:  MOV     [--W15],W7
017D2:  MOV     [--W15],W6
017D4:  MOV     [--W15],W5
017D6:  BRA     C,17DA
017D8:  BRA     NZ,1904
017DA:  BCLR.B  43.0
017DC:  MOV     W5,[W15++]
017DE:  MOV     W6,[W15++]
017E0:  MOV     W7,[W15++]
017E2:  MOV     1B5E,W0
017E4:  MOV     1B60,W1
017E6:  MOV     1B62,W2
017E8:  MOV     1B64,W3
017EA:  MOV     1B3E,W4
017EC:  MOV     1B40,W5
017EE:  MOV     1B42,W6
017F0:  MOV     1B44,W7
017F2:  CALL    13FC
017F6:  MOV     [--W15],W7
017F8:  MOV     [--W15],W6
017FA:  MOV     [--W15],W5
017FC:  MOV     W0,W5
017FE:  MOV     W1,W6
01800:  MOV     W2,W7
01802:  MOV     W3,W8
01804:  MOV     1B6E,W4
01806:  MUL.UU  W4,#10,W10
01808:  ADD     W10,#8,W0
0180A:  MOV     #B72,W4
0180C:  ADD     W0,W4,W0
0180E:  MOV     W0,W4
01810:  MOV     #0,W3
01812:  MOV     [W4++],[W3++]
01814:  MOV     [W4++],[W3++]
01816:  MOV     #0,W2
01818:  MOV     #0,W3
0181A:  CALL    12E8
0181E:  MOV     W5,[W15++]
01820:  MOV     W6,[W15++]
01822:  MOV     W7,[W15++]
01824:  MOV     W0,W4
01826:  MOV     W5,W0
01828:  MOV     W1,W5
0182A:  MOV     W6,W1
0182C:  MOV     W2,W6
0182E:  MOV     W7,W2
01830:  MOV     W3,W7
01832:  MOV     W8,W3
01834:  CALL    15EA
01838:  MOV     [--W15],W7
0183A:  MOV     [--W15],W6
0183C:  MOV     [--W15],W5
0183E:  BRA     C,1842
01840:  BRA     NZ,1904
.................... 	        { 
.................... 		        if ((spot.Y+pt1Y) >= TabZones[zoneToCheck][1] && (spot.Y+pt1Y) <= TabZones[zoneToCheck][3]) 
01842:  BCLR.B  43.0
01844:  MOV     1B66,W0
01846:  MOV     1B68,W1
01848:  MOV     1B6A,W2
0184A:  MOV     1B6C,W3
0184C:  MOV     1B46,W4
0184E:  MOV     1B48,W5
01850:  MOV     1B4A,W6
01852:  MOV     1B4C,W7
01854:  CALL    13FC
01858:  MOV     W0,W5
0185A:  MOV     W1,W6
0185C:  MOV     W2,W7
0185E:  MOV     W3,W8
01860:  MOV     1B6E,W4
01862:  MUL.UU  W4,#10,W0
01864:  MOV     W0,W9
01866:  ADD     W9,#4,W0
01868:  MOV     #B72,W4
0186A:  ADD     W0,W4,W0
0186C:  MOV     W0,W4
0186E:  MOV     #0,W3
01870:  MOV     [W4++],[W3++]
01872:  MOV     [W4++],[W3++]
01874:  MOV     #0,W2
01876:  MOV     #0,W3
01878:  CALL    12E8
0187C:  MOV     W5,[W15++]
0187E:  MOV     W6,[W15++]
01880:  MOV     W7,[W15++]
01882:  MOV     W5,W4
01884:  MOV     W6,W5
01886:  MOV     W7,W6
01888:  MOV     W8,W7
0188A:  CALL    15EA
0188E:  MOV     [--W15],W7
01890:  MOV     [--W15],W6
01892:  MOV     [--W15],W5
01894:  BRA     C,1898
01896:  BRA     NZ,1904
01898:  BCLR.B  43.0
0189A:  MOV     1B66,W0
0189C:  MOV     1B68,W1
0189E:  MOV     1B6A,W2
018A0:  MOV     1B6C,W3
018A2:  MOV     1B46,W4
018A4:  MOV     1B48,W5
018A6:  MOV     1B4A,W6
018A8:  MOV     1B4C,W7
018AA:  CALL    13FC
018AE:  MOV     W0,W5
018B0:  MOV     W1,W6
018B2:  MOV     W2,W7
018B4:  MOV     W3,W8
018B6:  MOV     1B6E,W4
018B8:  MUL.UU  W4,#10,W0
018BA:  MOV     W0,W9
018BC:  ADD     W9,#C,W0
018BE:  MOV     #B72,W4
018C0:  ADD     W0,W4,W0
018C2:  MOV     W0,W4
018C4:  MOV     #0,W3
018C6:  MOV     [W4++],[W3++]
018C8:  MOV     [W4++],[W3++]
018CA:  MOV     #0,W2
018CC:  MOV     #0,W3
018CE:  CALL    12E8
018D2:  MOV     W5,[W15++]
018D4:  MOV     W6,[W15++]
018D6:  MOV     W7,[W15++]
018D8:  MOV     W0,W4
018DA:  MOV     W5,W0
018DC:  MOV     W1,W5
018DE:  MOV     W6,W1
018E0:  MOV     W2,W6
018E2:  MOV     W7,W2
018E4:  MOV     W3,W7
018E6:  MOV     W8,W3
018E8:  CALL    15EA
018EC:  MOV     [--W15],W7
018EE:  MOV     [--W15],W6
018F0:  MOV     [--W15],W5
018F2:  BRA     C,18F6
018F4:  BRA     NZ,1904
.................... 		        { 
.................... 			        
....................                     TabIntersection[intersection_found] = zoneToCheck; 
018F6:  MOV     A94,W4
018F8:  MUL.UU  W4,#2,W0
018FA:  MOV     #A9E,W4
018FC:  ADD     W0,W4,W5
018FE:  MOV     1B6E,W4
01900:  MOV     W4,[W5+#0]
....................                     intersection_found++; 
01902:  INC     0A94
.................... 			 
.................... 		        } 
.................... 			 
.................... 			 
.................... 	        } 
01904:  INC     1B6E
01906:  GOTO    1780
....................         } 
.................... 	 
....................     }while (i < 100 && intersection_found == 0); 
0190A:  MOV     1B82,W4
0190C:  MOV     #64,W3
0190E:  CP      W3,W4
01910:  BRA     LE,1916
01912:  CP0     A94
01914:  BRA     Z,16D4
....................  
....................     if(intersection_found > 0) 
01916:  MOV     A94,W4
01918:  CP      W4,#0
0191A:  BRA     LE,1922
....................     { 
....................     	path_found = 0; 
0191C:  CLR     A96
....................     } 
0191E:  GOTO    1926
....................     else 
....................     { 
....................     	path_found = 1; 
01922:  MOV     #1,W4
01924:  MOV     W4,A96
....................     } 
01926:  MOV     #14,W5
01928:  REPEAT  #4
0192A:  MOV     [--W15],[W5--]
0192C:  MOV     [--W15],W5
0192E:  RETURN  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
*
01A4A:  MOV     1B5C,W0
01A4C:  MOV     1B54,W4
01A4E:  CP      W4,W0
01A50:  BRA     LE,1A7A
....................     { 
....................         if (py > ry4) 
01A52:  MOV     1B5E,W0
01A54:  MOV     1B56,W4
01A56:  CP      W4,W0
01A58:  BRA     LE,1A62
....................         { 
....................             pos = 4; //Le point se trouve en bas Ã  droite de la zone 
01A5A:  MOV     #4,W4
01A5C:  MOV     W4,1B60
....................         } 
01A5E:  GOTO    1A76
....................         else if (py > ry1) 
01A62:  MOV     1B5A,W0
01A64:  MOV     1B56,W4
01A66:  CP      W4,W0
01A68:  BRA     LE,1A72
....................         { 
....................             pos = 3; //Le point se trouve Ã  droite de la zone 
01A6A:  MOV     #3,W4
01A6C:  MOV     W4,1B60
....................         } 
01A6E:  GOTO    1A76
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut Ã  droite de la zone 
01A72:  MOV     #2,W4
01A74:  MOV     W4,1B60
....................         } 
....................     } 
01A76:  GOTO    1ACC
....................     else if (px > rx1) 
01A7A:  MOV     1B58,W0
01A7C:  MOV     1B54,W4
01A7E:  CP      W4,W0
01A80:  BRA     LE,1AAA
....................     { 
....................         if (py > ry4) 
01A82:  MOV     1B5E,W0
01A84:  MOV     1B56,W4
01A86:  CP      W4,W0
01A88:  BRA     LE,1A92
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
01A8A:  MOV     #5,W4
01A8C:  MOV     W4,1B60
....................         } 
01A8E:  GOTO    1AA6
....................         else if (py > ry1) 
01A92:  MOV     1B5A,W0
01A94:  MOV     1B56,W4
01A96:  CP      W4,W0
01A98:  BRA     LE,1AA2
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
01A9A:  MOV     #8,W4
01A9C:  MOV     W4,1B60
....................         } 
01A9E:  GOTO    1AA6
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
01AA2:  MOV     #1,W4
01AA4:  MOV     W4,1B60
....................         } 
....................     } 
01AA6:  GOTO    1ACC
....................     else 
....................     { 
....................         if (py > ry4) 
01AAA:  MOV     1B5E,W0
01AAC:  MOV     1B56,W4
01AAE:  CP      W4,W0
01AB0:  BRA     LE,1ABA
....................         { 
....................             pos = 6; //Le point se trouve en bas Ã  gauche de la zone 
01AB2:  MOV     #6,W4
01AB4:  MOV     W4,1B60
....................         } 
01AB6:  GOTO    1ACC
....................         else if (py > ry1) 
01ABA:  MOV     1B5A,W0
01ABC:  MOV     1B56,W4
01ABE:  CP      W4,W0
01AC0:  BRA     LE,1ACA
....................         { 
....................             pos = 7; //Le point se trouve Ã  gauche de la zone 
01AC2:  MOV     #7,W4
01AC4:  MOV     W4,1B60
....................         } 
01AC6:  GOTO    1ACC
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut Ã  gauche de la zone 
01ACA:  CLR     1B60
....................         } 
....................     } 
....................  
....................     return pos; 
01ACC:  PUSH    1B60
01ACE:  POP     0
01AD0:  RETURN  
....................          
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int xStart, int yStart, int xEnd, int yEnd, int i_zone) 
*
02BAC:  MOV     W5,[W15++]
02BAE:  MOV     #C,W5
02BB0:  REPEAT  #7
02BB2:  MOV     [W5++],[W15++]
02BB4:  MOV     1B3E,W4
02BB6:  MUL.UU  W4,#2,W0
02BB8:  MOV     #A9E,W4
02BBA:  ADD     W0,W4,W0
02BBC:  MOV     [W0],W5
02BBE:  MOV     W5,W4
02BC0:  MUL.UU  W4,#10,W0
02BC2:  MOV     W0,W5
02BC4:  MOV     #B72,W4
02BC6:  ADD     W5,W4,W0
02BC8:  MOV     [W0],W6
02BCA:  MOV     1B3E,W4
02BCC:  MUL.UU  W4,#2,W0
02BCE:  MOV     #A9E,W4
02BD0:  ADD     W0,W4,W0
02BD2:  MOV     [W0],W7
02BD4:  MOV     W7,W4
02BD6:  MUL.UU  W4,#10,W0
02BD8:  MOV     W0,W7
02BDA:  ADD     W7,#4,W0
02BDC:  MOV     #B72,W4
02BDE:  ADD     W0,W4,W0
02BE0:  MOV     [W0],W7
02BE2:  MOV     1B3E,W4
02BE4:  MUL.UU  W4,#2,W0
02BE6:  MOV     #A9E,W4
02BE8:  ADD     W0,W4,W0
02BEA:  MOV     [W0],W8
02BEC:  MOV     W8,W4
02BEE:  MUL.UU  W4,#10,W8
02BF0:  ADD     W8,#8,W0
02BF2:  MOV     #B72,W4
02BF4:  ADD     W0,W4,W0
02BF6:  MOV     [W0],W8
02BF8:  MOV     1B3E,W4
02BFA:  MUL.UU  W4,#2,W0
02BFC:  MOV     #A9E,W4
02BFE:  ADD     W0,W4,W0
02C00:  MOV     [W0],W9
02C02:  MOV     W9,W4
02C04:  MUL.UU  W4,#10,W0
02C06:  MOV     W0,W9
02C08:  ADD     W9,#C,W0
02C0A:  MOV     #B72,W4
02C0C:  ADD     W0,W4,W0
02C0E:  MOV     [W0],W9
02C10:  PUSH    1B36
02C12:  POP     1B54
02C14:  PUSH    1B38
02C16:  POP     1B56
02C18:  MOV     W6,1B58
02C1A:  MOV     W7,1B5A
02C1C:  MOV     W8,1B5C
02C1E:  MOV     W9,1B5E
02C20:  CALL    1A4A
02C24:  MOV     W0,1B40
02C26:  MOV     1B3E,W4
02C28:  MUL.UU  W4,#2,W0
02C2A:  MOV     #A9E,W4
02C2C:  ADD     W0,W4,W0
02C2E:  MOV     [W0],W6
02C30:  MOV     W6,W4
02C32:  MUL.UU  W4,#10,W6
02C34:  MOV     #B72,W4
02C36:  ADD     W6,W4,W0
02C38:  MOV     [W0],W7
02C3A:  MOV     1B3E,W4
02C3C:  MUL.UU  W4,#2,W0
02C3E:  MOV     #A9E,W4
02C40:  ADD     W0,W4,W0
02C42:  MOV     [W0],W8
02C44:  MOV     W8,W4
02C46:  MUL.UU  W4,#10,W8
02C48:  ADD     W8,#4,W0
02C4A:  MOV     #B72,W4
02C4C:  ADD     W0,W4,W0
02C4E:  MOV     [W0],W8
02C50:  MOV     1B3E,W4
02C52:  MUL.UU  W4,#2,W0
02C54:  MOV     #A9E,W4
02C56:  ADD     W0,W4,W0
02C58:  MOV     [W0],W9
02C5A:  MOV     W9,W4
02C5C:  MUL.UU  W4,#10,W0
02C5E:  MOV     W0,W9
02C60:  ADD     W9,#8,W0
02C62:  MOV     #B72,W4
02C64:  ADD     W0,W4,W0
02C66:  MOV     [W0],W9
02C68:  MOV     1B3E,W4
02C6A:  MUL.UU  W4,#2,W0
02C6C:  MOV     #A9E,W4
02C6E:  ADD     W0,W4,W0
02C70:  MOV     [W0],W10
02C72:  MOV     W10,W4
02C74:  MUL.UU  W4,#10,W10
02C76:  ADD     W10,#C,W0
02C78:  MOV     #B72,W4
02C7A:  ADD     W0,W4,W0
02C7C:  MOV     [W0],W10
02C7E:  PUSH    1B3A
02C80:  POP     1B54
02C82:  PUSH    1B3C
02C84:  POP     1B56
02C86:  MOV     W7,1B58
02C88:  MOV     W8,1B5A
02C8A:  MOV     W9,1B5C
02C8C:  MOV     W10,1B5E
02C8E:  CALL    1A4A
02C92:  MOV     W0,1B42
02C94:  CLR     1B44
.................... { 
.................... 	//On rÃ©cupÃ¨re la position des deux points par rapport Ã  la zone 
....................     int posStart = getPos(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................     int posEnd = getPos(xEnd, yEnd, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................  
....................     int relay_point_number = 0; 
....................  
....................     if(posStart == 8 || posEnd == 8) 
02C96:  MOV     1B40,W4
02C98:  CP      W4,#8
02C9A:  BRA     Z,2CA2
02C9C:  MOV     1B42,W4
02C9E:  CP      W4,#8
02CA0:  BRA     NZ,2CA8
....................     { 
....................     	path_found = 0; 
02CA2:  CLR     A96
....................     }	 
02CA4:  GOTO    5E74
....................     else 
....................     { 
.................... 	    switch (posStart) 
02CA8:  MOV     1B40,W0
02CAA:  XOR     #0,W0
02CAC:  BRA     Z,2CD0
02CAE:  XOR     #1,W0
02CB0:  BRA     Z,328C
02CB2:  XOR     #3,W0
02CB4:  BRA     Z,3946
02CB6:  XOR     #1,W0
02CB8:  BRA     Z,3EE2
02CBA:  XOR     #7,W0
02CBC:  BRA     Z,4596
02CBE:  XOR     #1,W0
02CC0:  BRA     Z,4B58
02CC2:  XOR     #3,W0
02CC4:  BRA     Z,520C
02CC6:  XOR     #1,W0
02CC8:  BRA     Z,57A8
02CCA:  XOR     #F,W0
02CCC:  BRA     Z,5E62
02CCE:  BRA     5E68
.................... 	    { 
.................... 	        case 0: 
.................... 	            if (posEnd == 3) 
02CD0:  MOV     1B42,W4
02CD2:  CP      W4,#3
02CD4:  BRA     NZ,2D56
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
02CD6:  MOV     A9A,W4
02CD8:  MUL.UU  W4,#10,W0
02CDA:  MOV     W0,W5
02CDC:  MOV     #AB2,W4
02CDE:  ADD     W5,W4,W6
02CE0:  MOV     1B3E,W4
02CE2:  MUL.UU  W4,#2,W0
02CE4:  MOV     #A9E,W4
02CE6:  ADD     W0,W4,W0
02CE8:  MOV     [W0],W7
02CEA:  MOV     W7,W4
02CEC:  MUL.UU  W4,#10,W0
02CEE:  MOV     W0,W7
02CF0:  MOV     1B22,W4
02CF2:  MUL.UU  W4,#4,W0
02CF4:  ADD     W0,W7,W0
02CF6:  MOV     #B72,W4
02CF8:  ADD     W0,W4,W0
02CFA:  MOV     W0,W4
02CFC:  MOV     #0,W3
02CFE:  MOV     [W4++],[W3++]
02D00:  MOV     [W4++],[W3++]
02D02:  MOV     #0,W2
02D04:  MOV     #0,W3
02D06:  CALL    12E8
02D0A:  MOV     #0,W4
02D0C:  REPEAT  #3
02D0E:  MOV     [W4++],[W6++]
02D10:  MOV     A9A,W4
02D12:  MUL.UU  W4,#10,W0
02D14:  MOV     W0,W5
02D16:  ADD     W5,#8,W0
02D18:  MOV     #AB2,W4
02D1A:  ADD     W0,W4,W5
02D1C:  MOV     1B3E,W4
02D1E:  MUL.UU  W4,#2,W0
02D20:  MOV     #A9E,W4
02D22:  ADD     W0,W4,W0
02D24:  MOV     [W0],W6
02D26:  MOV     W6,W4
02D28:  MUL.UU  W4,#10,W6
02D2A:  MOV     1B24,W4
02D2C:  MUL.UU  W4,#4,W0
02D2E:  ADD     W0,W6,W0
02D30:  MOV     #B72,W4
02D32:  ADD     W0,W4,W0
02D34:  MOV     W0,W4
02D36:  MOV     #0,W3
02D38:  MOV     [W4++],[W3++]
02D3A:  MOV     [W4++],[W3++]
02D3C:  MOV     #0,W2
02D3E:  MOV     #0,W3
02D40:  CALL    12E8
02D44:  MOV     #0,W4
02D46:  REPEAT  #3
02D48:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
02D4A:  MOV     #1,W4
02D4C:  MOV     W4,1B44
.................... 	                path_found = true; 
02D4E:  MOV     #1,W4
02D50:  MOV     W4,A96
.................... 	            } 
02D52:  GOTO    3288
.................... 	            else if (posEnd == 4) 
02D56:  MOV     1B42,W4
02D58:  CP      W4,#4
02D5A:  BRA     NZ,3206
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
02D5C:  MOV     1B36,W0
02D5E:  CLR     W3
02D60:  BTSC    W0.F
02D62:  SETM    W3
02D64:  MOV     W3,W1
02D66:  MOV     W3,W2
02D68:  CALL    12E8
02D6C:  MOV     W0,W5
02D6E:  MOV     W1,W6
02D70:  MOV     W2,W7
02D72:  MOV     W3,W8
02D74:  MOV     1B38,W0
02D76:  CLR     W3
02D78:  BTSC    W0.F
02D7A:  SETM    W3
02D7C:  MOV     W3,W1
02D7E:  MOV     W3,W2
02D80:  CALL    12E8
02D84:  MOV     W0,W9
02D86:  MOV     W1,W10
02D88:  MOV     W2,W11
02D8A:  MOV     W3,W12
02D8C:  MOV     1B3E,W4
02D8E:  MUL.UU  W4,#2,W0
02D90:  MOV     #A9E,W4
02D92:  ADD     W0,W4,W0
02D94:  MOV     [W0],W13
02D96:  MOV     W13,W4
02D98:  MUL.UU  W4,#10,W0
02D9A:  MOV     W0,W13
02D9C:  MOV     1B1E,W4
02D9E:  MUL.UU  W4,#4,W0
02DA0:  ADD     W0,W13,W0
02DA2:  MOV     #B72,W4
02DA4:  ADD     W0,W4,W0
02DA6:  MOV     W0,W4
02DA8:  MOV     #0,W3
02DAA:  MOV     [W4++],[W3++]
02DAC:  MOV     [W4++],[W3++]
02DAE:  MOV     #0,W2
02DB0:  MOV     #0,W3
02DB2:  CALL    12E8
02DB6:  MOV     W0,W13
02DB8:  MOV     W1,W14
02DBA:  MOV     W2,W15
02DBC:  MOV     W3,[W0]
02DBE:  MOV     1B3E,W4
02DC0:  MUL.UU  W4,#2,W0
02DC2:  MOV     #A9E,W4
02DC4:  ADD     W0,W4,W0
02DC6:  MOV     [W0],[W15++]
02DC8:  POP     1B4C
02DCA:  MOV     1B4C,W4
02DCC:  MUL.UU  W4,#10,W0
02DCE:  MOV     W0,1B4C
02DD0:  MOV     1B20,W4
02DD2:  MUL.UU  W4,#4,W0
02DD4:  MOV     1B4C,W4
02DD6:  ADD     W0,W4,W0
02DD8:  MOV     #B72,W4
02DDA:  ADD     W0,W4,W0
02DDC:  MOV     W0,W4
02DDE:  MOV     #0,W3
02DE0:  MOV     [W4++],[W3++]
02DE2:  MOV     [W4++],[W3++]
02DE4:  MOV     #0,W2
02DE6:  MOV     #0,W3
02DE8:  CALL    12E8
02DEC:  MOV     W0,1B4C
02DEE:  MOV     W1,1B4E
02DF0:  MOV     W2,1B50
02DF2:  MOV     W3,1B52
02DF4:  MOV     W5,1B7A
02DF6:  MOV     W6,1B7C
02DF8:  MOV     W7,1B7E
02DFA:  MOV     W8,1B80
02DFC:  MOV     W9,1B82
02DFE:  MOV     W10,1B84
02E00:  MOV     W11,1B86
02E02:  MOV     W12,1B88
02E04:  MOV     W13,1B8A
02E06:  MOV     W14,1B8C
02E08:  MOV     W15,1B8E
02E0A:  MOV     [W0],[W15++]
02E0C:  POP     1B90
02E0E:  PUSH    1B4C
02E10:  POP     1B92
02E12:  PUSH    1B4E
02E14:  POP     1B94
02E16:  PUSH    1B50
02E18:  POP     1B96
02E1A:  PUSH    1B52
02E1C:  POP     1B98
02E1E:  CALL    2AE8
02E22:  MOV     W0,W5
02E24:  MOV     W1,W6
02E26:  MOV     W2,W7
02E28:  MOV     W3,W8
02E2A:  MOV     1B3E,W4
02E2C:  MUL.UU  W4,#2,W0
02E2E:  MOV     #A9E,W4
02E30:  ADD     W0,W4,W0
02E32:  MOV     [W0],W9
02E34:  MOV     W9,W4
02E36:  MUL.UU  W4,#10,W0
02E38:  MOV     W0,W9
02E3A:  MOV     1B1E,W4
02E3C:  MUL.UU  W4,#4,W0
02E3E:  ADD     W0,W9,W0
02E40:  MOV     #B72,W4
02E42:  ADD     W0,W4,W0
02E44:  MOV     W0,W4
02E46:  MOV     #0,W3
02E48:  MOV     [W4++],[W3++]
02E4A:  MOV     [W4++],[W3++]
02E4C:  MOV     #0,W2
02E4E:  MOV     #0,W3
02E50:  CALL    12E8
02E54:  MOV     W0,W9
02E56:  MOV     W1,W10
02E58:  MOV     W2,W11
02E5A:  MOV     W3,W12
02E5C:  MOV     1B3E,W4
02E5E:  MUL.UU  W4,#2,W0
02E60:  MOV     #A9E,W4
02E62:  ADD     W0,W4,W0
02E64:  MOV     [W0],W13
02E66:  MOV     W13,W4
02E68:  MUL.UU  W4,#10,W0
02E6A:  MOV     W0,W13
02E6C:  MOV     1B20,W4
02E6E:  MUL.UU  W4,#4,W0
02E70:  ADD     W0,W13,W0
02E72:  MOV     #B72,W4
02E74:  ADD     W0,W4,W0
02E76:  MOV     W0,W4
02E78:  MOV     #0,W3
02E7A:  MOV     [W4++],[W3++]
02E7C:  MOV     [W4++],[W3++]
02E7E:  MOV     #0,W2
02E80:  MOV     #0,W3
02E82:  CALL    12E8
02E86:  MOV     W0,W13
02E88:  MOV     W1,W14
02E8A:  MOV     W2,W15
02E8C:  MOV     W3,[W0]
02E8E:  MOV     1B3A,W0
02E90:  CLR     W3
02E92:  BTSC    W0.F
02E94:  SETM    W3
02E96:  MOV     W3,W1
02E98:  MOV     W3,W2
02E9A:  CALL    12E8
02E9E:  MOV     W0,1B4C
02EA0:  MOV     W1,1B4E
02EA2:  MOV     W2,1B50
02EA4:  MOV     W3,1B52
02EA6:  MOV     1B3C,W0
02EA8:  CLR     W3
02EAA:  BTSC    W0.F
02EAC:  SETM    W3
02EAE:  MOV     W3,W1
02EB0:  MOV     W3,W2
02EB2:  CALL    12E8
02EB6:  MOV     W0,1B54
02EB8:  MOV     W1,1B56
02EBA:  MOV     W2,1B58
02EBC:  MOV     W3,1B5A
02EBE:  MOV     W9,1B7A
02EC0:  MOV     W10,1B7C
02EC2:  MOV     W11,1B7E
02EC4:  MOV     W12,1B80
02EC6:  MOV     W13,1B82
02EC8:  MOV     W14,1B84
02ECA:  MOV     W15,1B86
02ECC:  MOV     [W0],[W15++]
02ECE:  POP     1B88
02ED0:  PUSH    1B4C
02ED2:  POP     1B8A
02ED4:  PUSH    1B4E
02ED6:  POP     1B8C
02ED8:  PUSH    1B50
02EDA:  POP     1B8E
02EDC:  PUSH    1B52
02EDE:  POP     1B90
02EE0:  PUSH    1B54
02EE2:  POP     1B92
02EE4:  PUSH    1B56
02EE6:  POP     1B94
02EE8:  PUSH    1B58
02EEA:  POP     1B96
02EEC:  PUSH    1B5A
02EEE:  POP     1B98
02EF0:  CALL    2AE8
02EF4:  BCLR.B  43.0
02EF6:  MOV     W5,[W15++]
02EF8:  MOV     W6,[W15++]
02EFA:  MOV     W7,[W15++]
02EFC:  MOV     W0,W4
02EFE:  MOV     W5,W0
02F00:  MOV     W1,W5
02F02:  MOV     W6,W1
02F04:  MOV     W2,W6
02F06:  MOV     W7,W2
02F08:  MOV     W3,W7
02F0A:  MOV     W8,W3
02F0C:  CALL    13FC
02F10:  MOV     [--W15],W7
02F12:  MOV     [--W15],W6
02F14:  MOV     [--W15],W5
02F16:  MOV     W0,W5
02F18:  MOV     W1,W6
02F1A:  MOV     W2,W7
02F1C:  MOV     W3,W8
02F1E:  MOV     1B36,W0
02F20:  CLR     W3
02F22:  BTSC    W0.F
02F24:  SETM    W3
02F26:  MOV     W3,W1
02F28:  MOV     W3,W2
02F2A:  CALL    12E8
02F2E:  MOV     W0,W9
02F30:  MOV     W1,W10
02F32:  MOV     W2,W11
02F34:  MOV     W3,W12
02F36:  MOV     1B38,W0
02F38:  CLR     W3
02F3A:  BTSC    W0.F
02F3C:  SETM    W3
02F3E:  MOV     W3,W1
02F40:  MOV     W3,W2
02F42:  CALL    12E8
02F46:  MOV     W0,W13
02F48:  MOV     W1,W14
02F4A:  MOV     W2,W15
02F4C:  MOV     W3,[W0]
02F4E:  MOV     1B3E,W4
02F50:  MUL.UU  W4,#2,W0
02F52:  MOV     #A9E,W4
02F54:  ADD     W0,W4,W0
02F56:  MOV     [W0],[W15++]
02F58:  POP     1B4C
02F5A:  MOV     1B4C,W4
02F5C:  MUL.UU  W4,#10,W0
02F5E:  MOV     W0,1B4C
02F60:  MOV     1B22,W4
02F62:  MUL.UU  W4,#4,W0
02F64:  MOV     1B4C,W4
02F66:  ADD     W0,W4,W0
02F68:  MOV     #B72,W4
02F6A:  ADD     W0,W4,W0
02F6C:  MOV     W0,W4
02F6E:  MOV     #0,W3
02F70:  MOV     [W4++],[W3++]
02F72:  MOV     [W4++],[W3++]
02F74:  MOV     #0,W2
02F76:  MOV     #0,W3
02F78:  CALL    12E8
02F7C:  MOV     W0,1B4C
02F7E:  MOV     W1,1B4E
02F80:  MOV     W2,1B50
02F82:  MOV     W3,1B52
02F84:  MOV     1B3E,W4
02F86:  MUL.UU  W4,#2,W0
02F88:  MOV     #A9E,W4
02F8A:  ADD     W0,W4,W0
02F8C:  MOV     [W0],[W15++]
02F8E:  POP     1B54
02F90:  MOV     1B54,W4
02F92:  MUL.UU  W4,#10,W0
02F94:  MOV     W0,1B54
02F96:  MOV     1B24,W4
02F98:  MUL.UU  W4,#4,W0
02F9A:  MOV     1B54,W4
02F9C:  ADD     W0,W4,W0
02F9E:  MOV     #B72,W4
02FA0:  ADD     W0,W4,W0
02FA2:  MOV     W0,W4
02FA4:  MOV     #0,W3
02FA6:  MOV     [W4++],[W3++]
02FA8:  MOV     [W4++],[W3++]
02FAA:  MOV     #0,W2
02FAC:  MOV     #0,W3
02FAE:  CALL    12E8
02FB2:  MOV     W0,1B54
02FB4:  MOV     W1,1B56
02FB6:  MOV     W2,1B58
02FB8:  MOV     W3,1B5A
02FBA:  MOV     W9,1B7A
02FBC:  MOV     W10,1B7C
02FBE:  MOV     W11,1B7E
02FC0:  MOV     W12,1B80
02FC2:  MOV     W13,1B82
02FC4:  MOV     W14,1B84
02FC6:  MOV     W15,1B86
02FC8:  MOV     [W0],[W15++]
02FCA:  POP     1B88
02FCC:  PUSH    1B4C
02FCE:  POP     1B8A
02FD0:  PUSH    1B4E
02FD2:  POP     1B8C
02FD4:  PUSH    1B50
02FD6:  POP     1B8E
02FD8:  PUSH    1B52
02FDA:  POP     1B90
02FDC:  PUSH    1B54
02FDE:  POP     1B92
02FE0:  PUSH    1B56
02FE2:  POP     1B94
02FE4:  PUSH    1B58
02FE6:  POP     1B96
02FE8:  PUSH    1B5A
02FEA:  POP     1B98
02FEC:  CALL    2AE8
02FF0:  MOV     W0,W9
02FF2:  MOV     W1,W10
02FF4:  MOV     W2,W11
02FF6:  MOV     W3,W12
02FF8:  MOV     1B3E,W4
02FFA:  MUL.UU  W4,#2,W0
02FFC:  MOV     #A9E,W4
02FFE:  ADD     W0,W4,W0
03000:  MOV     [W0],W13
03002:  MOV     W13,W4
03004:  MUL.UU  W4,#10,W0
03006:  MOV     W0,W13
03008:  MOV     1B22,W4
0300A:  MUL.UU  W4,#4,W0
0300C:  ADD     W0,W13,W0
0300E:  MOV     #B72,W4
03010:  ADD     W0,W4,W0
03012:  MOV     W0,W4
03014:  MOV     #0,W3
03016:  MOV     [W4++],[W3++]
03018:  MOV     [W4++],[W3++]
0301A:  MOV     #0,W2
0301C:  MOV     #0,W3
0301E:  CALL    12E8
03022:  MOV     W0,W13
03024:  MOV     W1,W14
03026:  MOV     W2,W15
03028:  MOV     W3,[W0]
0302A:  MOV     1B3E,W4
0302C:  MUL.UU  W4,#2,W0
0302E:  MOV     #A9E,W4
03030:  ADD     W0,W4,W0
03032:  MOV     [W0],[W15++]
03034:  POP     1B4C
03036:  MOV     1B4C,W4
03038:  MUL.UU  W4,#10,W0
0303A:  MOV     W0,1B4C
0303C:  MOV     1B24,W4
0303E:  MUL.UU  W4,#4,W0
03040:  MOV     1B4C,W4
03042:  ADD     W0,W4,W0
03044:  MOV     #B72,W4
03046:  ADD     W0,W4,W0
03048:  MOV     W0,W4
0304A:  MOV     #0,W3
0304C:  MOV     [W4++],[W3++]
0304E:  MOV     [W4++],[W3++]
03050:  MOV     #0,W2
03052:  MOV     #0,W3
03054:  CALL    12E8
03058:  MOV     W0,1B4C
0305A:  MOV     W1,1B4E
0305C:  MOV     W2,1B50
0305E:  MOV     W3,1B52
03060:  MOV     1B3A,W0
03062:  CLR     W3
03064:  BTSC    W0.F
03066:  SETM    W3
03068:  MOV     W3,W1
0306A:  MOV     W3,W2
0306C:  CALL    12E8
03070:  MOV     W0,1B54
03072:  MOV     W1,1B56
03074:  MOV     W2,1B58
03076:  MOV     W3,1B5A
03078:  MOV     1B3C,W0
0307A:  CLR     W3
0307C:  BTSC    W0.F
0307E:  SETM    W3
03080:  MOV     W3,W1
03082:  MOV     W3,W2
03084:  CALL    12E8
03088:  MOV     W0,1B5C
0308A:  MOV     W1,1B5E
0308C:  MOV     W2,1B60
0308E:  MOV     W3,1B62
03090:  MOV     W13,1B7A
03092:  MOV     W14,1B7C
03094:  MOV     W15,1B7E
03096:  MOV     [W0],[W15++]
03098:  POP     1B80
0309A:  PUSH    1B4C
0309C:  POP     1B82
0309E:  PUSH    1B4E
030A0:  POP     1B84
030A2:  PUSH    1B50
030A4:  POP     1B86
030A6:  PUSH    1B52
030A8:  POP     1B88
030AA:  PUSH    1B54
030AC:  POP     1B8A
030AE:  PUSH    1B56
030B0:  POP     1B8C
030B2:  PUSH    1B58
030B4:  POP     1B8E
030B6:  PUSH    1B5A
030B8:  POP     1B90
030BA:  PUSH    1B5C
030BC:  POP     1B92
030BE:  PUSH    1B5E
030C0:  POP     1B94
030C2:  PUSH    1B60
030C4:  POP     1B96
030C6:  PUSH    1B62
030C8:  POP     1B98
030CA:  CALL    2AE8
030CE:  BCLR.B  43.0
030D0:  MOV     W5,[W15++]
030D2:  MOV     W6,[W15++]
030D4:  MOV     W7,[W15++]
030D6:  MOV     W0,W4
030D8:  MOV     W1,W5
030DA:  MOV     W2,W6
030DC:  MOV     W3,W7
030DE:  MOV     W9,W0
030E0:  MOV     W10,W1
030E2:  MOV     W11,W2
030E4:  MOV     W12,W3
030E6:  CALL    13FC
030EA:  MOV     [--W15],W7
030EC:  MOV     [--W15],W6
030EE:  MOV     [--W15],W5
030F0:  MOV     W5,[W15++]
030F2:  MOV     W6,[W15++]
030F4:  MOV     W7,[W15++]
030F6:  MOV     W5,W4
030F8:  MOV     W6,W5
030FA:  MOV     W7,W6
030FC:  MOV     W8,W7
030FE:  CALL    15EA
03102:  MOV     [--W15],W7
03104:  MOV     [--W15],W6
03106:  MOV     [--W15],W5
03108:  BRA     NC,3186
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0310A:  MOV     A9A,W4
0310C:  MUL.UU  W4,#10,W0
0310E:  MOV     W0,W5
03110:  MOV     #AB2,W4
03112:  ADD     W5,W4,W6
03114:  MOV     1B3E,W4
03116:  MUL.UU  W4,#2,W0
03118:  MOV     #A9E,W4
0311A:  ADD     W0,W4,W0
0311C:  MOV     [W0],W7
0311E:  MOV     W7,W4
03120:  MUL.UU  W4,#10,W0
03122:  MOV     W0,W7
03124:  MOV     1B22,W4
03126:  MUL.UU  W4,#4,W0
03128:  ADD     W0,W7,W0
0312A:  MOV     #B72,W4
0312C:  ADD     W0,W4,W0
0312E:  MOV     W0,W4
03130:  MOV     #0,W3
03132:  MOV     [W4++],[W3++]
03134:  MOV     [W4++],[W3++]
03136:  MOV     #0,W2
03138:  MOV     #0,W3
0313A:  CALL    12E8
0313E:  MOV     #0,W4
03140:  REPEAT  #3
03142:  MOV     [W4++],[W6++]
03144:  MOV     A9A,W4
03146:  MUL.UU  W4,#10,W0
03148:  MOV     W0,W5
0314A:  ADD     W5,#8,W0
0314C:  MOV     #AB2,W4
0314E:  ADD     W0,W4,W5
03150:  MOV     1B3E,W4
03152:  MUL.UU  W4,#2,W0
03154:  MOV     #A9E,W4
03156:  ADD     W0,W4,W0
03158:  MOV     [W0],W6
0315A:  MOV     W6,W4
0315C:  MUL.UU  W4,#10,W6
0315E:  MOV     1B24,W4
03160:  MUL.UU  W4,#4,W0
03162:  ADD     W0,W6,W0
03164:  MOV     #B72,W4
03166:  ADD     W0,W4,W0
03168:  MOV     W0,W4
0316A:  MOV     #0,W3
0316C:  MOV     [W4++],[W3++]
0316E:  MOV     [W4++],[W3++]
03170:  MOV     #0,W2
03172:  MOV     #0,W3
03174:  CALL    12E8
03178:  MOV     #0,W4
0317A:  REPEAT  #3
0317C:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
0317E:  MOV     #1,W4
03180:  MOV     W4,1B44
.................... 	                } 
03182:  GOTO    31FE
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
03186:  MOV     A9A,W4
03188:  MUL.UU  W4,#10,W0
0318A:  MOV     W0,W5
0318C:  MOV     #AB2,W4
0318E:  ADD     W5,W4,W6
03190:  MOV     1B3E,W4
03192:  MUL.UU  W4,#2,W0
03194:  MOV     #A9E,W4
03196:  ADD     W0,W4,W0
03198:  MOV     [W0],W7
0319A:  MOV     W7,W4
0319C:  MUL.UU  W4,#10,W0
0319E:  MOV     W0,W7
031A0:  MOV     1B1E,W4
031A2:  MUL.UU  W4,#4,W0
031A4:  ADD     W0,W7,W0
031A6:  MOV     #B72,W4
031A8:  ADD     W0,W4,W0
031AA:  MOV     W0,W4
031AC:  MOV     #0,W3
031AE:  MOV     [W4++],[W3++]
031B0:  MOV     [W4++],[W3++]
031B2:  MOV     #0,W2
031B4:  MOV     #0,W3
031B6:  CALL    12E8
031BA:  MOV     #0,W4
031BC:  REPEAT  #3
031BE:  MOV     [W4++],[W6++]
031C0:  MOV     A9A,W4
031C2:  MUL.UU  W4,#10,W0
031C4:  MOV     W0,W5
031C6:  ADD     W5,#8,W0
031C8:  MOV     #AB2,W4
031CA:  ADD     W0,W4,W5
031CC:  MOV     1B3E,W4
031CE:  MUL.UU  W4,#2,W0
031D0:  MOV     #A9E,W4
031D2:  ADD     W0,W4,W0
031D4:  MOV     [W0],W6
031D6:  MOV     W6,W4
031D8:  MUL.UU  W4,#10,W6
031DA:  MOV     1B20,W4
031DC:  MUL.UU  W4,#4,W0
031DE:  ADD     W0,W6,W0
031E0:  MOV     #B72,W4
031E2:  ADD     W0,W4,W0
031E4:  MOV     W0,W4
031E6:  MOV     #0,W3
031E8:  MOV     [W4++],[W3++]
031EA:  MOV     [W4++],[W3++]
031EC:  MOV     #0,W2
031EE:  MOV     #0,W3
031F0:  CALL    12E8
031F4:  MOV     #0,W4
031F6:  REPEAT  #3
031F8:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
031FA:  MOV     #1,W4
031FC:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
031FE:  MOV     #1,W4
03200:  MOV     W4,A96
.................... 	            } 
03202:  GOTO    3288
.................... 	            else if (posEnd == 5) 
03206:  MOV     1B42,W4
03208:  CP      W4,#5
0320A:  BRA     NZ,3288
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
0320C:  MOV     A9A,W4
0320E:  MUL.UU  W4,#10,W0
03210:  MOV     W0,W5
03212:  MOV     #AB2,W4
03214:  ADD     W5,W4,W6
03216:  MOV     1B3E,W4
03218:  MUL.UU  W4,#2,W0
0321A:  MOV     #A9E,W4
0321C:  ADD     W0,W4,W0
0321E:  MOV     [W0],W7
03220:  MOV     W7,W4
03222:  MUL.UU  W4,#10,W0
03224:  MOV     W0,W7
03226:  MOV     1B1E,W4
03228:  MUL.UU  W4,#4,W0
0322A:  ADD     W0,W7,W0
0322C:  MOV     #B72,W4
0322E:  ADD     W0,W4,W0
03230:  MOV     W0,W4
03232:  MOV     #0,W3
03234:  MOV     [W4++],[W3++]
03236:  MOV     [W4++],[W3++]
03238:  MOV     #0,W2
0323A:  MOV     #0,W3
0323C:  CALL    12E8
03240:  MOV     #0,W4
03242:  REPEAT  #3
03244:  MOV     [W4++],[W6++]
03246:  MOV     A9A,W4
03248:  MUL.UU  W4,#10,W0
0324A:  MOV     W0,W5
0324C:  ADD     W5,#8,W0
0324E:  MOV     #AB2,W4
03250:  ADD     W0,W4,W5
03252:  MOV     1B3E,W4
03254:  MUL.UU  W4,#2,W0
03256:  MOV     #A9E,W4
03258:  ADD     W0,W4,W0
0325A:  MOV     [W0],W6
0325C:  MOV     W6,W4
0325E:  MUL.UU  W4,#10,W6
03260:  MOV     1B20,W4
03262:  MUL.UU  W4,#4,W0
03264:  ADD     W0,W6,W0
03266:  MOV     #B72,W4
03268:  ADD     W0,W4,W0
0326A:  MOV     W0,W4
0326C:  MOV     #0,W3
0326E:  MOV     [W4++],[W3++]
03270:  MOV     [W4++],[W3++]
03272:  MOV     #0,W2
03274:  MOV     #0,W3
03276:  CALL    12E8
0327A:  MOV     #0,W4
0327C:  REPEAT  #3
0327E:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
03280:  MOV     #1,W4
03282:  MOV     W4,1B44
.................... 	                path_found = true; 
03284:  MOV     #1,W4
03286:  MOV     W4,A96
.................... 	            } 
.................... 	            break; 
03288:  GOTO    5E6E
....................  
.................... 	        case 1: 
.................... 	            if (posEnd == 3 || posEnd == 4) 
0328C:  MOV     1B42,W4
0328E:  CP      W4,#3
03290:  BRA     Z,3298
03292:  MOV     1B42,W4
03294:  CP      W4,#4
03296:  BRA     NZ,3318
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
03298:  MOV     A9A,W4
0329A:  MUL.UU  W4,#10,W0
0329C:  MOV     W0,W5
0329E:  MOV     #AB2,W4
032A0:  ADD     W5,W4,W6
032A2:  MOV     1B3E,W4
032A4:  MUL.UU  W4,#2,W0
032A6:  MOV     #A9E,W4
032A8:  ADD     W0,W4,W0
032AA:  MOV     [W0],W7
032AC:  MOV     W7,W4
032AE:  MUL.UU  W4,#10,W0
032B0:  MOV     W0,W7
032B2:  MOV     1B22,W4
032B4:  MUL.UU  W4,#4,W0
032B6:  ADD     W0,W7,W0
032B8:  MOV     #B72,W4
032BA:  ADD     W0,W4,W0
032BC:  MOV     W0,W4
032BE:  MOV     #0,W3
032C0:  MOV     [W4++],[W3++]
032C2:  MOV     [W4++],[W3++]
032C4:  MOV     #0,W2
032C6:  MOV     #0,W3
032C8:  CALL    12E8
032CC:  MOV     #0,W4
032CE:  REPEAT  #3
032D0:  MOV     [W4++],[W6++]
032D2:  MOV     A9A,W4
032D4:  MUL.UU  W4,#10,W0
032D6:  MOV     W0,W5
032D8:  ADD     W5,#8,W0
032DA:  MOV     #AB2,W4
032DC:  ADD     W0,W4,W5
032DE:  MOV     1B3E,W4
032E0:  MUL.UU  W4,#2,W0
032E2:  MOV     #A9E,W4
032E4:  ADD     W0,W4,W0
032E6:  MOV     [W0],W6
032E8:  MOV     W6,W4
032EA:  MUL.UU  W4,#10,W6
032EC:  MOV     1B24,W4
032EE:  MUL.UU  W4,#4,W0
032F0:  ADD     W0,W6,W0
032F2:  MOV     #B72,W4
032F4:  ADD     W0,W4,W0
032F6:  MOV     W0,W4
032F8:  MOV     #0,W3
032FA:  MOV     [W4++],[W3++]
032FC:  MOV     [W4++],[W3++]
032FE:  MOV     #0,W2
03300:  MOV     #0,W3
03302:  CALL    12E8
03306:  MOV     #0,W4
03308:  REPEAT  #3
0330A:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0330C:  MOV     #1,W4
0330E:  MOV     W4,1B44
.................... 	                path_found = true; 
03310:  MOV     #1,W4
03312:  MOV     W4,A96
.................... 	            } 
03314:  GOTO    3942
.................... 	            else if (posEnd == 5) 
03318:  MOV     1B42,W4
0331A:  CP      W4,#5
0331C:  BRA     NZ,38C4
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
0331E:  MOV     1B36,W0
03320:  CLR     W3
03322:  BTSC    W0.F
03324:  SETM    W3
03326:  MOV     W3,W1
03328:  MOV     W3,W2
0332A:  CALL    12E8
0332E:  MOV     W0,W5
03330:  MOV     W1,W6
03332:  MOV     W2,W7
03334:  MOV     W3,W8
03336:  MOV     1B38,W0
03338:  CLR     W3
0333A:  BTSC    W0.F
0333C:  SETM    W3
0333E:  MOV     W3,W1
03340:  MOV     W3,W2
03342:  CALL    12E8
03346:  MOV     W0,W9
03348:  MOV     W1,W10
0334A:  MOV     W2,W11
0334C:  MOV     W3,W12
0334E:  MOV     1B3E,W4
03350:  MUL.UU  W4,#2,W0
03352:  MOV     #A9E,W4
03354:  ADD     W0,W4,W0
03356:  MOV     [W0],W13
03358:  MOV     W13,W4
0335A:  MUL.UU  W4,#10,W0
0335C:  MOV     W0,W13
0335E:  MOV     #B72,W4
03360:  ADD     W13,W4,W0
03362:  MOV     W0,W4
03364:  MOV     #0,W3
03366:  MOV     [W4++],[W3++]
03368:  MOV     [W4++],[W3++]
0336A:  MOV     #0,W2
0336C:  MOV     #0,W3
0336E:  CALL    12E8
03372:  MOV     W0,1B46
03374:  MOV     W1,1B48
03376:  MOV     W2,1B4A
03378:  MOV     W3,1B4C
0337A:  MOV     1B3E,W4
0337C:  MUL.UU  W4,#2,W0
0337E:  MOV     #A9E,W4
03380:  ADD     W0,W4,W0
03382:  MOV     [W0],[W15++]
03384:  POP     1B4E
03386:  MOV     1B4E,W4
03388:  MUL.UU  W4,#10,W0
0338A:  MOV     W0,1B4E
0338C:  MOV     1B4E,W4
0338E:  ADD     W4,#4,W0
03390:  MOV     #B72,W4
03392:  ADD     W0,W4,W0
03394:  MOV     W0,W4
03396:  MOV     #0,W3
03398:  MOV     [W4++],[W3++]
0339A:  MOV     [W4++],[W3++]
0339C:  MOV     #0,W2
0339E:  MOV     #0,W3
033A0:  CALL    12E8
033A4:  MOV     W0,1B4E
033A6:  MOV     W1,1B50
033A8:  MOV     W2,1B52
033AA:  MOV     W3,1B54
033AC:  MOV     W5,1B7A
033AE:  MOV     W6,1B7C
033B0:  MOV     W7,1B7E
033B2:  MOV     W8,1B80
033B4:  MOV     W9,1B82
033B6:  MOV     W10,1B84
033B8:  MOV     W11,1B86
033BA:  MOV     W12,1B88
033BC:  PUSH    1B46
033BE:  POP     1B8A
033C0:  PUSH    1B48
033C2:  POP     1B8C
033C4:  PUSH    1B4A
033C6:  POP     1B8E
033C8:  PUSH    1B4C
033CA:  POP     1B90
033CC:  PUSH    1B4E
033CE:  POP     1B92
033D0:  PUSH    1B50
033D2:  POP     1B94
033D4:  PUSH    1B52
033D6:  POP     1B96
033D8:  PUSH    1B54
033DA:  POP     1B98
033DC:  CALL    2AE8
033E0:  MOV     W0,W5
033E2:  MOV     W1,W6
033E4:  MOV     W2,W7
033E6:  MOV     W3,W8
033E8:  MOV     1B3E,W4
033EA:  MUL.UU  W4,#2,W0
033EC:  MOV     #A9E,W4
033EE:  ADD     W0,W4,W0
033F0:  MOV     [W0],W9
033F2:  MOV     W9,W4
033F4:  MUL.UU  W4,#10,W0
033F6:  MOV     W0,W9
033F8:  MOV     1B1E,W4
033FA:  MUL.UU  W4,#4,W0
033FC:  ADD     W0,W9,W0
033FE:  MOV     #B72,W4
03400:  ADD     W0,W4,W0
03402:  MOV     W0,W4
03404:  MOV     #0,W3
03406:  MOV     [W4++],[W3++]
03408:  MOV     [W4++],[W3++]
0340A:  MOV     #0,W2
0340C:  MOV     #0,W3
0340E:  CALL    12E8
03412:  MOV     W0,W9
03414:  MOV     W1,W10
03416:  MOV     W2,W11
03418:  MOV     W3,W12
0341A:  MOV     1B3E,W4
0341C:  MUL.UU  W4,#2,W0
0341E:  MOV     #A9E,W4
03420:  ADD     W0,W4,W0
03422:  MOV     [W0],[W15++]
03424:  POP     1B46
03426:  MOV     1B46,W4
03428:  MUL.UU  W4,#10,W0
0342A:  MOV     W0,1B46
0342C:  MOV     1B20,W4
0342E:  MUL.UU  W4,#4,W0
03430:  MOV     1B46,W4
03432:  ADD     W0,W4,W0
03434:  MOV     #B72,W4
03436:  ADD     W0,W4,W0
03438:  MOV     W0,W4
0343A:  MOV     #0,W3
0343C:  MOV     [W4++],[W3++]
0343E:  MOV     [W4++],[W3++]
03440:  MOV     #0,W2
03442:  MOV     #0,W3
03444:  CALL    12E8
03448:  MOV     W0,1B46
0344A:  MOV     W1,1B48
0344C:  MOV     W2,1B4A
0344E:  MOV     W3,1B4C
03450:  MOV     1B3A,W0
03452:  CLR     W3
03454:  BTSC    W0.F
03456:  SETM    W3
03458:  MOV     W3,W1
0345A:  MOV     W3,W2
0345C:  CALL    12E8
03460:  MOV     W0,1B4E
03462:  MOV     W1,1B50
03464:  MOV     W2,1B52
03466:  MOV     W3,1B54
03468:  MOV     1B3C,W0
0346A:  CLR     W3
0346C:  BTSC    W0.F
0346E:  SETM    W3
03470:  MOV     W3,W1
03472:  MOV     W3,W2
03474:  CALL    12E8
03478:  MOV     W0,1B56
0347A:  MOV     W1,1B58
0347C:  MOV     W2,1B5A
0347E:  MOV     W3,1B5C
03480:  MOV     W9,1B7A
03482:  MOV     W10,1B7C
03484:  MOV     W11,1B7E
03486:  MOV     W12,1B80
03488:  PUSH    1B46
0348A:  POP     1B82
0348C:  PUSH    1B48
0348E:  POP     1B84
03490:  PUSH    1B4A
03492:  POP     1B86
03494:  PUSH    1B4C
03496:  POP     1B88
03498:  PUSH    1B4E
0349A:  POP     1B8A
0349C:  PUSH    1B50
0349E:  POP     1B8C
034A0:  PUSH    1B52
034A2:  POP     1B8E
034A4:  PUSH    1B54
034A6:  POP     1B90
034A8:  PUSH    1B56
034AA:  POP     1B92
034AC:  PUSH    1B58
034AE:  POP     1B94
034B0:  PUSH    1B5A
034B2:  POP     1B96
034B4:  PUSH    1B5C
034B6:  POP     1B98
034B8:  CALL    2AE8
034BC:  BCLR.B  43.0
034BE:  MOV     W5,[W15++]
034C0:  MOV     W6,[W15++]
034C2:  MOV     W7,[W15++]
034C4:  MOV     W0,W4
034C6:  MOV     W5,W0
034C8:  MOV     W1,W5
034CA:  MOV     W6,W1
034CC:  MOV     W2,W6
034CE:  MOV     W7,W2
034D0:  MOV     W3,W7
034D2:  MOV     W8,W3
034D4:  CALL    13FC
034D8:  MOV     [--W15],W7
034DA:  MOV     [--W15],W6
034DC:  MOV     [--W15],W5
034DE:  MOV     W0,W5
034E0:  MOV     W1,W6
034E2:  MOV     W2,W7
034E4:  MOV     W3,W8
034E6:  MOV     1B36,W0
034E8:  CLR     W3
034EA:  BTSC    W0.F
034EC:  SETM    W3
034EE:  MOV     W3,W1
034F0:  MOV     W3,W2
034F2:  CALL    12E8
034F6:  MOV     W0,W9
034F8:  MOV     W1,W10
034FA:  MOV     W2,W11
034FC:  MOV     W3,W12
034FE:  MOV     1B38,W0
03500:  CLR     W3
03502:  BTSC    W0.F
03504:  SETM    W3
03506:  MOV     W3,W1
03508:  MOV     W3,W2
0350A:  CALL    12E8
0350E:  MOV     W0,1B46
03510:  MOV     W1,1B48
03512:  MOV     W2,1B4A
03514:  MOV     W3,1B4C
03516:  MOV     1B3E,W4
03518:  MUL.UU  W4,#2,W0
0351A:  MOV     #A9E,W4
0351C:  ADD     W0,W4,W0
0351E:  MOV     [W0],[W15++]
03520:  POP     1B4E
03522:  MOV     1B4E,W4
03524:  MUL.UU  W4,#10,W0
03526:  MOV     W0,1B4E
03528:  MOV     1B22,W4
0352A:  MUL.UU  W4,#4,W0
0352C:  MOV     1B4E,W4
0352E:  ADD     W0,W4,W0
03530:  MOV     #B72,W4
03532:  ADD     W0,W4,W0
03534:  MOV     W0,W4
03536:  MOV     #0,W3
03538:  MOV     [W4++],[W3++]
0353A:  MOV     [W4++],[W3++]
0353C:  MOV     #0,W2
0353E:  MOV     #0,W3
03540:  CALL    12E8
03544:  MOV     W0,1B4E
03546:  MOV     W1,1B50
03548:  MOV     W2,1B52
0354A:  MOV     W3,1B54
0354C:  MOV     1B3E,W4
0354E:  MUL.UU  W4,#2,W0
03550:  MOV     #A9E,W4
03552:  ADD     W0,W4,W0
03554:  MOV     [W0],[W15++]
03556:  POP     1B56
03558:  MOV     1B56,W4
0355A:  MUL.UU  W4,#10,W0
0355C:  MOV     W0,1B56
0355E:  MOV     1B24,W4
03560:  MUL.UU  W4,#4,W0
03562:  MOV     1B56,W4
03564:  ADD     W0,W4,W0
03566:  MOV     #B72,W4
03568:  ADD     W0,W4,W0
0356A:  MOV     W0,W4
0356C:  MOV     #0,W3
0356E:  MOV     [W4++],[W3++]
03570:  MOV     [W4++],[W3++]
03572:  MOV     #0,W2
03574:  MOV     #0,W3
03576:  CALL    12E8
0357A:  MOV     W0,1B56
0357C:  MOV     W1,1B58
0357E:  MOV     W2,1B5A
03580:  MOV     W3,1B5C
03582:  MOV     W9,1B7A
03584:  MOV     W10,1B7C
03586:  MOV     W11,1B7E
03588:  MOV     W12,1B80
0358A:  PUSH    1B46
0358C:  POP     1B82
0358E:  PUSH    1B48
03590:  POP     1B84
03592:  PUSH    1B4A
03594:  POP     1B86
03596:  PUSH    1B4C
03598:  POP     1B88
0359A:  PUSH    1B4E
0359C:  POP     1B8A
0359E:  PUSH    1B50
035A0:  POP     1B8C
035A2:  PUSH    1B52
035A4:  POP     1B8E
035A6:  PUSH    1B54
035A8:  POP     1B90
035AA:  PUSH    1B56
035AC:  POP     1B92
035AE:  PUSH    1B58
035B0:  POP     1B94
035B2:  PUSH    1B5A
035B4:  POP     1B96
035B6:  PUSH    1B5C
035B8:  POP     1B98
035BA:  CALL    2AE8
035BE:  MOV     W0,W9
035C0:  MOV     W1,W10
035C2:  MOV     W2,W11
035C4:  MOV     W3,W12
035C6:  MOV     1B3E,W4
035C8:  MUL.UU  W4,#2,W0
035CA:  MOV     #A9E,W4
035CC:  ADD     W0,W4,W0
035CE:  MOV     [W0],[W15++]
035D0:  POP     1B46
035D2:  MOV     1B46,W4
035D4:  MUL.UU  W4,#10,W0
035D6:  MOV     W0,1B46
035D8:  MOV     1B46,W4
035DA:  ADD     W4,#8,W0
035DC:  MOV     #B72,W4
035DE:  ADD     W0,W4,W0
035E0:  MOV     W0,W4
035E2:  MOV     #0,W3
035E4:  MOV     [W4++],[W3++]
035E6:  MOV     [W4++],[W3++]
035E8:  MOV     #0,W2
035EA:  MOV     #0,W3
035EC:  CALL    12E8
035F0:  MOV     W0,1B46
035F2:  MOV     W1,1B48
035F4:  MOV     W2,1B4A
035F6:  MOV     W3,1B4C
035F8:  MOV     1B3E,W4
035FA:  MUL.UU  W4,#2,W0
035FC:  MOV     #A9E,W4
035FE:  ADD     W0,W4,W0
03600:  MOV     [W0],[W15++]
03602:  POP     1B4E
03604:  MOV     1B4E,W4
03606:  MUL.UU  W4,#10,W0
03608:  MOV     W0,1B4E
0360A:  MOV     1B4E,W4
0360C:  ADD     W4,#C,W0
0360E:  MOV     #B72,W4
03610:  ADD     W0,W4,W0
03612:  MOV     W0,W4
03614:  MOV     #0,W3
03616:  MOV     [W4++],[W3++]
03618:  MOV     [W4++],[W3++]
0361A:  MOV     #0,W2
0361C:  MOV     #0,W3
0361E:  CALL    12E8
03622:  MOV     W0,1B4E
03624:  MOV     W1,1B50
03626:  MOV     W2,1B52
03628:  MOV     W3,1B54
0362A:  MOV     1B3A,W0
0362C:  CLR     W3
0362E:  BTSC    W0.F
03630:  SETM    W3
03632:  MOV     W3,W1
03634:  MOV     W3,W2
03636:  CALL    12E8
0363A:  MOV     W0,1B56
0363C:  MOV     W1,1B58
0363E:  MOV     W2,1B5A
03640:  MOV     W3,1B5C
03642:  MOV     1B3C,W0
03644:  CLR     W3
03646:  BTSC    W0.F
03648:  SETM    W3
0364A:  MOV     W3,W1
0364C:  MOV     W3,W2
0364E:  CALL    12E8
03652:  MOV     W0,1B5E
03654:  MOV     W1,1B60
03656:  MOV     W2,1B62
03658:  MOV     W3,1B64
0365A:  PUSH    1B46
0365C:  POP     1B7A
0365E:  PUSH    1B48
03660:  POP     1B7C
03662:  PUSH    1B4A
03664:  POP     1B7E
03666:  PUSH    1B4C
03668:  POP     1B80
0366A:  PUSH    1B4E
0366C:  POP     1B82
0366E:  PUSH    1B50
03670:  POP     1B84
03672:  PUSH    1B52
03674:  POP     1B86
03676:  PUSH    1B54
03678:  POP     1B88
0367A:  PUSH    1B56
0367C:  POP     1B8A
0367E:  PUSH    1B58
03680:  POP     1B8C
03682:  PUSH    1B5A
03684:  POP     1B8E
03686:  PUSH    1B5C
03688:  POP     1B90
0368A:  PUSH    1B5E
0368C:  POP     1B92
0368E:  PUSH    1B60
03690:  POP     1B94
03692:  PUSH    1B62
03694:  POP     1B96
03696:  PUSH    1B64
03698:  POP     1B98
0369A:  CALL    2AE8
0369E:  BCLR.B  43.0
036A0:  MOV     W5,[W15++]
036A2:  MOV     W6,[W15++]
036A4:  MOV     W7,[W15++]
036A6:  MOV     W0,W4
036A8:  MOV     W1,W5
036AA:  MOV     W2,W6
036AC:  MOV     W3,W7
036AE:  MOV     W9,W0
036B0:  MOV     W10,W1
036B2:  MOV     W11,W2
036B4:  MOV     W12,W3
036B6:  CALL    13FC
036BA:  MOV     [--W15],W7
036BC:  MOV     [--W15],W6
036BE:  MOV     [--W15],W5
036C0:  MOV     W5,[W15++]
036C2:  MOV     W6,[W15++]
036C4:  MOV     W7,[W15++]
036C6:  MOV     W0,W4
036C8:  MOV     W5,W0
036CA:  MOV     W1,W5
036CC:  MOV     W6,W1
036CE:  MOV     W2,W6
036D0:  MOV     W7,W2
036D2:  MOV     W3,W7
036D4:  MOV     W8,W3
036D6:  CALL    15EA
036DA:  MOV     [--W15],W7
036DC:  MOV     [--W15],W6
036DE:  MOV     [--W15],W5
036E0:  BRA     NC,37D0
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
036E2:  MOV     A9A,W4
036E4:  MUL.UU  W4,#10,W0
036E6:  MOV     W0,W5
036E8:  MOV     #AB2,W4
036EA:  ADD     W5,W4,W6
036EC:  MOV     1B3E,W4
036EE:  MUL.UU  W4,#2,W0
036F0:  MOV     #A9E,W4
036F2:  ADD     W0,W4,W0
036F4:  MOV     [W0],W7
036F6:  MOV     W7,W4
036F8:  MUL.UU  W4,#10,W0
036FA:  MOV     W0,W7
036FC:  MOV     #B72,W4
036FE:  ADD     W7,W4,W0
03700:  MOV     W0,W4
03702:  MOV     #0,W3
03704:  MOV     [W4++],[W3++]
03706:  MOV     [W4++],[W3++]
03708:  MOV     #0,W2
0370A:  MOV     #0,W3
0370C:  CALL    12E8
03710:  MOV     #0,W4
03712:  REPEAT  #3
03714:  MOV     [W4++],[W6++]
03716:  MOV     A9A,W4
03718:  MUL.UU  W4,#10,W0
0371A:  MOV     W0,W5
0371C:  ADD     W5,#8,W0
0371E:  MOV     #AB2,W4
03720:  ADD     W0,W4,W5
03722:  MOV     1B3E,W4
03724:  MUL.UU  W4,#2,W0
03726:  MOV     #A9E,W4
03728:  ADD     W0,W4,W0
0372A:  MOV     [W0],W6
0372C:  MOV     W6,W4
0372E:  MUL.UU  W4,#10,W6
03730:  ADD     W6,#4,W0
03732:  MOV     #B72,W4
03734:  ADD     W0,W4,W0
03736:  MOV     W0,W4
03738:  MOV     #0,W3
0373A:  MOV     [W4++],[W3++]
0373C:  MOV     [W4++],[W3++]
0373E:  MOV     #0,W2
03740:  MOV     #0,W3
03742:  CALL    12E8
03746:  MOV     #0,W4
03748:  REPEAT  #3
0374A:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel+1].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1].Y = TabZones[TabIntersection[i_zone]][y3]; 
0374C:  MOV     A9A,W4
0374E:  ADD     W4,#1,W5
03750:  MOV     W5,W4
03752:  MUL.UU  W4,#10,W0
03754:  MOV     W0,W5
03756:  MOV     #AB2,W4
03758:  ADD     W5,W4,W6
0375A:  MOV     1B3E,W4
0375C:  MUL.UU  W4,#2,W0
0375E:  MOV     #A9E,W4
03760:  ADD     W0,W4,W0
03762:  MOV     [W0],W7
03764:  MOV     W7,W4
03766:  MUL.UU  W4,#10,W0
03768:  MOV     W0,W7
0376A:  MOV     1B1E,W4
0376C:  MUL.UU  W4,#4,W0
0376E:  ADD     W0,W7,W0
03770:  MOV     #B72,W4
03772:  ADD     W0,W4,W0
03774:  MOV     W0,W4
03776:  MOV     #0,W3
03778:  MOV     [W4++],[W3++]
0377A:  MOV     [W4++],[W3++]
0377C:  MOV     #0,W2
0377E:  MOV     #0,W3
03780:  CALL    12E8
03784:  MOV     #0,W4
03786:  REPEAT  #3
03788:  MOV     [W4++],[W6++]
0378A:  MOV     A9A,W4
0378C:  ADD     W4,#1,W5
0378E:  MOV     W5,W4
03790:  MUL.UU  W4,#10,W0
03792:  MOV     W0,W5
03794:  ADD     W5,#8,W0
03796:  MOV     #AB2,W4
03798:  ADD     W0,W4,W5
0379A:  MOV     1B3E,W4
0379C:  MUL.UU  W4,#2,W0
0379E:  MOV     #A9E,W4
037A0:  ADD     W0,W4,W0
037A2:  MOV     [W0],W6
037A4:  MOV     W6,W4
037A6:  MUL.UU  W4,#10,W6
037A8:  MOV     1B20,W4
037AA:  MUL.UU  W4,#4,W0
037AC:  ADD     W0,W6,W0
037AE:  MOV     #B72,W4
037B0:  ADD     W0,W4,W0
037B2:  MOV     W0,W4
037B4:  MOV     #0,W3
037B6:  MOV     [W4++],[W3++]
037B8:  MOV     [W4++],[W3++]
037BA:  MOV     #0,W2
037BC:  MOV     #0,W3
037BE:  CALL    12E8
037C2:  MOV     #0,W4
037C4:  REPEAT  #3
037C6:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
037C8:  MOV     #2,W4
037CA:  MOV     W4,1B44
.................... 	                } 
037CC:  GOTO    38BC
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
037D0:  MOV     A9A,W4
037D2:  MUL.UU  W4,#10,W0
037D4:  MOV     W0,W5
037D6:  MOV     #AB2,W4
037D8:  ADD     W5,W4,W6
037DA:  MOV     1B3E,W4
037DC:  MUL.UU  W4,#2,W0
037DE:  MOV     #A9E,W4
037E0:  ADD     W0,W4,W0
037E2:  MOV     [W0],W7
037E4:  MOV     W7,W4
037E6:  MUL.UU  W4,#10,W0
037E8:  MOV     W0,W7
037EA:  MOV     1B22,W4
037EC:  MUL.UU  W4,#4,W0
037EE:  ADD     W0,W7,W0
037F0:  MOV     #B72,W4
037F2:  ADD     W0,W4,W0
037F4:  MOV     W0,W4
037F6:  MOV     #0,W3
037F8:  MOV     [W4++],[W3++]
037FA:  MOV     [W4++],[W3++]
037FC:  MOV     #0,W2
037FE:  MOV     #0,W3
03800:  CALL    12E8
03804:  MOV     #0,W4
03806:  REPEAT  #3
03808:  MOV     [W4++],[W6++]
0380A:  MOV     A9A,W4
0380C:  MUL.UU  W4,#10,W0
0380E:  MOV     W0,W5
03810:  ADD     W5,#8,W0
03812:  MOV     #AB2,W4
03814:  ADD     W0,W4,W5
03816:  MOV     1B3E,W4
03818:  MUL.UU  W4,#2,W0
0381A:  MOV     #A9E,W4
0381C:  ADD     W0,W4,W0
0381E:  MOV     [W0],W6
03820:  MOV     W6,W4
03822:  MUL.UU  W4,#10,W6
03824:  MOV     1B24,W4
03826:  MUL.UU  W4,#4,W0
03828:  ADD     W0,W6,W0
0382A:  MOV     #B72,W4
0382C:  ADD     W0,W4,W0
0382E:  MOV     W0,W4
03830:  MOV     #0,W3
03832:  MOV     [W4++],[W3++]
03834:  MOV     [W4++],[W3++]
03836:  MOV     #0,W2
03838:  MOV     #0,W3
0383A:  CALL    12E8
0383E:  MOV     #0,W4
03840:  REPEAT  #3
03842:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel+1].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1].Y = TabZones[TabIntersection[i_zone]][y4]; 
03844:  MOV     A9A,W4
03846:  ADD     W4,#1,W5
03848:  MOV     W5,W4
0384A:  MUL.UU  W4,#10,W0
0384C:  MOV     W0,W5
0384E:  MOV     #AB2,W4
03850:  ADD     W5,W4,W6
03852:  MOV     1B3E,W4
03854:  MUL.UU  W4,#2,W0
03856:  MOV     #A9E,W4
03858:  ADD     W0,W4,W0
0385A:  MOV     [W0],W7
0385C:  MOV     W7,W4
0385E:  MUL.UU  W4,#10,W0
03860:  MOV     W0,W7
03862:  ADD     W7,#8,W0
03864:  MOV     #B72,W4
03866:  ADD     W0,W4,W0
03868:  MOV     W0,W4
0386A:  MOV     #0,W3
0386C:  MOV     [W4++],[W3++]
0386E:  MOV     [W4++],[W3++]
03870:  MOV     #0,W2
03872:  MOV     #0,W3
03874:  CALL    12E8
03878:  MOV     #0,W4
0387A:  REPEAT  #3
0387C:  MOV     [W4++],[W6++]
0387E:  MOV     A9A,W4
03880:  ADD     W4,#1,W5
03882:  MOV     W5,W4
03884:  MUL.UU  W4,#10,W0
03886:  MOV     W0,W5
03888:  ADD     W5,#8,W0
0388A:  MOV     #AB2,W4
0388C:  ADD     W0,W4,W5
0388E:  MOV     1B3E,W4
03890:  MUL.UU  W4,#2,W0
03892:  MOV     #A9E,W4
03894:  ADD     W0,W4,W0
03896:  MOV     [W0],W6
03898:  MOV     W6,W4
0389A:  MUL.UU  W4,#10,W6
0389C:  ADD     W6,#C,W0
0389E:  MOV     #B72,W4
038A0:  ADD     W0,W4,W0
038A2:  MOV     W0,W4
038A4:  MOV     #0,W3
038A6:  MOV     [W4++],[W3++]
038A8:  MOV     [W4++],[W3++]
038AA:  MOV     #0,W2
038AC:  MOV     #0,W3
038AE:  CALL    12E8
038B2:  MOV     #0,W4
038B4:  REPEAT  #3
038B6:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
038B8:  MOV     #2,W4
038BA:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
038BC:  MOV     #1,W4
038BE:  MOV     W4,A96
.................... 	            } 
038C0:  GOTO    3942
.................... 	            else if (posEnd == 6 || posEnd == 7) 
038C4:  MOV     1B42,W4
038C6:  CP      W4,#6
038C8:  BRA     Z,38D0
038CA:  MOV     1B42,W4
038CC:  CP      W4,#7
038CE:  BRA     NZ,3942
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
038D0:  MOV     A9A,W4
038D2:  MUL.UU  W4,#10,W0
038D4:  MOV     W0,W5
038D6:  MOV     #AB2,W4
038D8:  ADD     W5,W4,W6
038DA:  MOV     1B3E,W4
038DC:  MUL.UU  W4,#2,W0
038DE:  MOV     #A9E,W4
038E0:  ADD     W0,W4,W0
038E2:  MOV     [W0],W7
038E4:  MOV     W7,W4
038E6:  MUL.UU  W4,#10,W0
038E8:  MOV     W0,W7
038EA:  MOV     #B72,W4
038EC:  ADD     W7,W4,W0
038EE:  MOV     W0,W4
038F0:  MOV     #0,W3
038F2:  MOV     [W4++],[W3++]
038F4:  MOV     [W4++],[W3++]
038F6:  MOV     #0,W2
038F8:  MOV     #0,W3
038FA:  CALL    12E8
038FE:  MOV     #0,W4
03900:  REPEAT  #3
03902:  MOV     [W4++],[W6++]
03904:  MOV     A9A,W4
03906:  MUL.UU  W4,#10,W0
03908:  MOV     W0,W5
0390A:  ADD     W5,#8,W0
0390C:  MOV     #AB2,W4
0390E:  ADD     W0,W4,W5
03910:  MOV     1B3E,W4
03912:  MUL.UU  W4,#2,W0
03914:  MOV     #A9E,W4
03916:  ADD     W0,W4,W0
03918:  MOV     [W0],W6
0391A:  MOV     W6,W4
0391C:  MUL.UU  W4,#10,W6
0391E:  ADD     W6,#4,W0
03920:  MOV     #B72,W4
03922:  ADD     W0,W4,W0
03924:  MOV     W0,W4
03926:  MOV     #0,W3
03928:  MOV     [W4++],[W3++]
0392A:  MOV     [W4++],[W3++]
0392C:  MOV     #0,W2
0392E:  MOV     #0,W3
03930:  CALL    12E8
03934:  MOV     #0,W4
03936:  REPEAT  #3
03938:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0393A:  MOV     #1,W4
0393C:  MOV     W4,1B44
.................... 	                path_found = true; 
0393E:  MOV     #1,W4
03940:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
03942:  GOTO    5E6E
....................  
.................... 	        case 2: 
.................... 	            if (posEnd == 5) 
03946:  MOV     1B42,W4
03948:  CP      W4,#5
0394A:  BRA     NZ,39C4
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
0394C:  MOV     A9A,W4
0394E:  MUL.UU  W4,#10,W0
03950:  MOV     W0,W5
03952:  MOV     #AB2,W4
03954:  ADD     W5,W4,W6
03956:  MOV     1B3E,W4
03958:  MUL.UU  W4,#2,W0
0395A:  MOV     #A9E,W4
0395C:  ADD     W0,W4,W0
0395E:  MOV     [W0],W7
03960:  MOV     W7,W4
03962:  MUL.UU  W4,#10,W0
03964:  MOV     W0,W7
03966:  ADD     W7,#8,W0
03968:  MOV     #B72,W4
0396A:  ADD     W0,W4,W0
0396C:  MOV     W0,W4
0396E:  MOV     #0,W3
03970:  MOV     [W4++],[W3++]
03972:  MOV     [W4++],[W3++]
03974:  MOV     #0,W2
03976:  MOV     #0,W3
03978:  CALL    12E8
0397C:  MOV     #0,W4
0397E:  REPEAT  #3
03980:  MOV     [W4++],[W6++]
03982:  MOV     A9A,W4
03984:  MUL.UU  W4,#10,W0
03986:  MOV     W0,W5
03988:  ADD     W5,#8,W0
0398A:  MOV     #AB2,W4
0398C:  ADD     W0,W4,W5
0398E:  MOV     1B3E,W4
03990:  MUL.UU  W4,#2,W0
03992:  MOV     #A9E,W4
03994:  ADD     W0,W4,W0
03996:  MOV     [W0],W6
03998:  MOV     W6,W4
0399A:  MUL.UU  W4,#10,W6
0399C:  ADD     W6,#C,W0
0399E:  MOV     #B72,W4
039A0:  ADD     W0,W4,W0
039A2:  MOV     W0,W4
039A4:  MOV     #0,W3
039A6:  MOV     [W4++],[W3++]
039A8:  MOV     [W4++],[W3++]
039AA:  MOV     #0,W2
039AC:  MOV     #0,W3
039AE:  CALL    12E8
039B2:  MOV     #0,W4
039B4:  REPEAT  #3
039B6:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
039B8:  MOV     #1,W4
039BA:  MOV     W4,1B44
.................... 	                path_found = true; 
039BC:  MOV     #1,W4
039BE:  MOV     W4,A96
.................... 	            } 
039C0:  GOTO    3EDE
.................... 	            else if (posEnd == 6) 
039C4:  MOV     1B42,W4
039C6:  CP      W4,#6
039C8:  BRA     NZ,3E66
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
039CA:  MOV     1B36,W0
039CC:  CLR     W3
039CE:  BTSC    W0.F
039D0:  SETM    W3
039D2:  MOV     W3,W1
039D4:  MOV     W3,W2
039D6:  CALL    12E8
039DA:  MOV     W0,W5
039DC:  MOV     W1,W6
039DE:  MOV     W2,W7
039E0:  MOV     W3,W8
039E2:  MOV     1B38,W0
039E4:  CLR     W3
039E6:  BTSC    W0.F
039E8:  SETM    W3
039EA:  MOV     W3,W1
039EC:  MOV     W3,W2
039EE:  CALL    12E8
039F2:  MOV     W0,W9
039F4:  MOV     W1,W10
039F6:  MOV     W2,W11
039F8:  MOV     W3,W12
039FA:  MOV     1B3E,W4
039FC:  MUL.UU  W4,#2,W0
039FE:  MOV     #A9E,W4
03A00:  ADD     W0,W4,W0
03A02:  MOV     [W0],W13
03A04:  MOV     W13,W4
03A06:  MUL.UU  W4,#10,W0
03A08:  MOV     W0,W13
03A0A:  MOV     #B72,W4
03A0C:  ADD     W13,W4,W0
03A0E:  MOV     W0,W4
03A10:  MOV     #0,W3
03A12:  MOV     [W4++],[W3++]
03A14:  MOV     [W4++],[W3++]
03A16:  MOV     #0,W2
03A18:  MOV     #0,W3
03A1A:  CALL    12E8
03A1E:  MOV     W0,1B46
03A20:  MOV     W1,1B48
03A22:  MOV     W2,1B4A
03A24:  MOV     W3,1B4C
03A26:  MOV     1B3E,W4
03A28:  MUL.UU  W4,#2,W0
03A2A:  MOV     #A9E,W4
03A2C:  ADD     W0,W4,W0
03A2E:  MOV     [W0],[W15++]
03A30:  POP     1B4E
03A32:  MOV     1B4E,W4
03A34:  MUL.UU  W4,#10,W0
03A36:  MOV     W0,1B4E
03A38:  MOV     1B4E,W4
03A3A:  ADD     W4,#4,W0
03A3C:  MOV     #B72,W4
03A3E:  ADD     W0,W4,W0
03A40:  MOV     W0,W4
03A42:  MOV     #0,W3
03A44:  MOV     [W4++],[W3++]
03A46:  MOV     [W4++],[W3++]
03A48:  MOV     #0,W2
03A4A:  MOV     #0,W3
03A4C:  CALL    12E8
03A50:  MOV     W0,1B4E
03A52:  MOV     W1,1B50
03A54:  MOV     W2,1B52
03A56:  MOV     W3,1B54
03A58:  MOV     W5,1B7A
03A5A:  MOV     W6,1B7C
03A5C:  MOV     W7,1B7E
03A5E:  MOV     W8,1B80
03A60:  MOV     W9,1B82
03A62:  MOV     W10,1B84
03A64:  MOV     W11,1B86
03A66:  MOV     W12,1B88
03A68:  PUSH    1B46
03A6A:  POP     1B8A
03A6C:  PUSH    1B48
03A6E:  POP     1B8C
03A70:  PUSH    1B4A
03A72:  POP     1B8E
03A74:  PUSH    1B4C
03A76:  POP     1B90
03A78:  PUSH    1B4E
03A7A:  POP     1B92
03A7C:  PUSH    1B50
03A7E:  POP     1B94
03A80:  PUSH    1B52
03A82:  POP     1B96
03A84:  PUSH    1B54
03A86:  POP     1B98
03A88:  CALL    2AE8
03A8C:  MOV     W0,W5
03A8E:  MOV     W1,W6
03A90:  MOV     W2,W7
03A92:  MOV     W3,W8
03A94:  MOV     1B3E,W4
03A96:  MUL.UU  W4,#2,W0
03A98:  MOV     #A9E,W4
03A9A:  ADD     W0,W4,W0
03A9C:  MOV     [W0],W9
03A9E:  MOV     W9,W4
03AA0:  MUL.UU  W4,#10,W0
03AA2:  MOV     W0,W9
03AA4:  MOV     #B72,W4
03AA6:  ADD     W9,W4,W0
03AA8:  MOV     W0,W4
03AAA:  MOV     #0,W3
03AAC:  MOV     [W4++],[W3++]
03AAE:  MOV     [W4++],[W3++]
03AB0:  MOV     #0,W2
03AB2:  MOV     #0,W3
03AB4:  CALL    12E8
03AB8:  MOV     W0,W10
03ABA:  MOV     W1,W11
03ABC:  MOV     W2,W12
03ABE:  MOV     W3,W13
03AC0:  MOV     1B3E,W4
03AC2:  MUL.UU  W4,#2,W0
03AC4:  MOV     #A9E,W4
03AC6:  ADD     W0,W4,W0
03AC8:  MOV     [W0],[W15++]
03ACA:  POP     1B46
03ACC:  MOV     1B46,W4
03ACE:  MUL.UU  W4,#10,W0
03AD0:  MOV     W0,1B46
03AD2:  MOV     1B46,W4
03AD4:  ADD     W4,#4,W0
03AD6:  MOV     #B72,W4
03AD8:  ADD     W0,W4,W0
03ADA:  MOV     W0,W4
03ADC:  MOV     #0,W3
03ADE:  MOV     [W4++],[W3++]
03AE0:  MOV     [W4++],[W3++]
03AE2:  MOV     #0,W2
03AE4:  MOV     #0,W3
03AE6:  CALL    12E8
03AEA:  MOV     W0,1B46
03AEC:  MOV     W1,1B48
03AEE:  MOV     W2,1B4A
03AF0:  MOV     W3,1B4C
03AF2:  MOV     1B3A,W0
03AF4:  CLR     W3
03AF6:  BTSC    W0.F
03AF8:  SETM    W3
03AFA:  MOV     W3,W1
03AFC:  MOV     W3,W2
03AFE:  CALL    12E8
03B02:  MOV     W0,1B4E
03B04:  MOV     W1,1B50
03B06:  MOV     W2,1B52
03B08:  MOV     W3,1B54
03B0A:  MOV     1B3C,W0
03B0C:  CLR     W3
03B0E:  BTSC    W0.F
03B10:  SETM    W3
03B12:  MOV     W3,W1
03B14:  MOV     W3,W2
03B16:  CALL    12E8
03B1A:  MOV     W0,1B56
03B1C:  MOV     W1,1B58
03B1E:  MOV     W2,1B5A
03B20:  MOV     W3,1B5C
03B22:  MOV     W10,1B7A
03B24:  MOV     W11,1B7C
03B26:  MOV     W12,1B7E
03B28:  MOV     W13,1B80
03B2A:  PUSH    1B46
03B2C:  POP     1B82
03B2E:  PUSH    1B48
03B30:  POP     1B84
03B32:  PUSH    1B4A
03B34:  POP     1B86
03B36:  PUSH    1B4C
03B38:  POP     1B88
03B3A:  PUSH    1B4E
03B3C:  POP     1B8A
03B3E:  PUSH    1B50
03B40:  POP     1B8C
03B42:  PUSH    1B52
03B44:  POP     1B8E
03B46:  PUSH    1B54
03B48:  POP     1B90
03B4A:  PUSH    1B56
03B4C:  POP     1B92
03B4E:  PUSH    1B58
03B50:  POP     1B94
03B52:  PUSH    1B5A
03B54:  POP     1B96
03B56:  PUSH    1B5C
03B58:  POP     1B98
03B5A:  CALL    2AE8
03B5E:  BCLR.B  43.0
03B60:  MOV     W5,[W15++]
03B62:  MOV     W6,[W15++]
03B64:  MOV     W7,[W15++]
03B66:  MOV     W0,W4
03B68:  MOV     W5,W0
03B6A:  MOV     W1,W5
03B6C:  MOV     W6,W1
03B6E:  MOV     W2,W6
03B70:  MOV     W7,W2
03B72:  MOV     W3,W7
03B74:  MOV     W8,W3
03B76:  CALL    13FC
03B7A:  MOV     [--W15],W7
03B7C:  MOV     [--W15],W6
03B7E:  MOV     [--W15],W5
03B80:  MOV     W0,W5
03B82:  MOV     W1,W6
03B84:  MOV     W2,W7
03B86:  MOV     W3,W8
03B88:  MOV     1B36,W0
03B8A:  CLR     W3
03B8C:  BTSC    W0.F
03B8E:  SETM    W3
03B90:  MOV     W3,W1
03B92:  MOV     W3,W2
03B94:  CALL    12E8
03B98:  MOV     W0,W10
03B9A:  MOV     W1,W11
03B9C:  MOV     W2,W12
03B9E:  MOV     W3,W13
03BA0:  MOV     1B38,W0
03BA2:  CLR     W3
03BA4:  BTSC    W0.F
03BA6:  SETM    W3
03BA8:  MOV     W3,W1
03BAA:  MOV     W3,W2
03BAC:  CALL    12E8
03BB0:  MOV     W0,1B46
03BB2:  MOV     W1,1B48
03BB4:  MOV     W2,1B4A
03BB6:  MOV     W3,1B4C
03BB8:  MOV     1B3E,W4
03BBA:  MUL.UU  W4,#2,W0
03BBC:  MOV     #A9E,W4
03BBE:  ADD     W0,W4,W0
03BC0:  MOV     [W0],[W15++]
03BC2:  POP     1B4E
03BC4:  MOV     1B4E,W4
03BC6:  MUL.UU  W4,#10,W0
03BC8:  MOV     W0,1B4E
03BCA:  MOV     1B4E,W4
03BCC:  ADD     W4,#8,W0
03BCE:  MOV     #B72,W4
03BD0:  ADD     W0,W4,W0
03BD2:  MOV     W0,W4
03BD4:  MOV     #0,W3
03BD6:  MOV     [W4++],[W3++]
03BD8:  MOV     [W4++],[W3++]
03BDA:  MOV     #0,W2
03BDC:  MOV     #0,W3
03BDE:  CALL    12E8
03BE2:  MOV     W0,1B4E
03BE4:  MOV     W1,1B50
03BE6:  MOV     W2,1B52
03BE8:  MOV     W3,1B54
03BEA:  MOV     1B3E,W4
03BEC:  MUL.UU  W4,#2,W0
03BEE:  MOV     #A9E,W4
03BF0:  ADD     W0,W4,W0
03BF2:  MOV     [W0],[W15++]
03BF4:  POP     1B56
03BF6:  MOV     1B56,W4
03BF8:  MUL.UU  W4,#10,W0
03BFA:  MOV     W0,1B56
03BFC:  MOV     1B56,W4
03BFE:  ADD     W4,#C,W0
03C00:  MOV     #B72,W4
03C02:  ADD     W0,W4,W0
03C04:  MOV     W0,W4
03C06:  MOV     #0,W3
03C08:  MOV     [W4++],[W3++]
03C0A:  MOV     [W4++],[W3++]
03C0C:  MOV     #0,W2
03C0E:  MOV     #0,W3
03C10:  CALL    12E8
03C14:  MOV     W0,1B56
03C16:  MOV     W1,1B58
03C18:  MOV     W2,1B5A
03C1A:  MOV     W3,1B5C
03C1C:  MOV     W10,1B7A
03C1E:  MOV     W11,1B7C
03C20:  MOV     W12,1B7E
03C22:  MOV     W13,1B80
03C24:  PUSH    1B46
03C26:  POP     1B82
03C28:  PUSH    1B48
03C2A:  POP     1B84
03C2C:  PUSH    1B4A
03C2E:  POP     1B86
03C30:  PUSH    1B4C
03C32:  POP     1B88
03C34:  PUSH    1B4E
03C36:  POP     1B8A
03C38:  PUSH    1B50
03C3A:  POP     1B8C
03C3C:  PUSH    1B52
03C3E:  POP     1B8E
03C40:  PUSH    1B54
03C42:  POP     1B90
03C44:  PUSH    1B56
03C46:  POP     1B92
03C48:  PUSH    1B58
03C4A:  POP     1B94
03C4C:  PUSH    1B5A
03C4E:  POP     1B96
03C50:  PUSH    1B5C
03C52:  POP     1B98
03C54:  CALL    2AE8
03C58:  MOV     W0,W10
03C5A:  MOV     W1,W11
03C5C:  MOV     W2,W12
03C5E:  MOV     W3,W13
03C60:  MOV     1B3E,W4
03C62:  MUL.UU  W4,#2,W0
03C64:  MOV     #A9E,W4
03C66:  ADD     W0,W4,W0
03C68:  MOV     [W0],[W15++]
03C6A:  POP     1B46
03C6C:  MOV     1B46,W4
03C6E:  MUL.UU  W4,#10,W0
03C70:  MOV     W0,1B46
03C72:  MOV     1B46,W4
03C74:  ADD     W4,#8,W0
03C76:  MOV     #B72,W4
03C78:  ADD     W0,W4,W0
03C7A:  MOV     W0,W4
03C7C:  MOV     #0,W3
03C7E:  MOV     [W4++],[W3++]
03C80:  MOV     [W4++],[W3++]
03C82:  MOV     #0,W2
03C84:  MOV     #0,W3
03C86:  CALL    12E8
03C8A:  MOV     W0,1B46
03C8C:  MOV     W1,1B48
03C8E:  MOV     W2,1B4A
03C90:  MOV     W3,1B4C
03C92:  MOV     1B3E,W4
03C94:  MUL.UU  W4,#2,W0
03C96:  MOV     #A9E,W4
03C98:  ADD     W0,W4,W0
03C9A:  MOV     [W0],[W15++]
03C9C:  POP     1B4E
03C9E:  MOV     1B4E,W4
03CA0:  MUL.UU  W4,#10,W0
03CA2:  MOV     W0,1B4E
03CA4:  MOV     1B4E,W4
03CA6:  ADD     W4,#C,W0
03CA8:  MOV     #B72,W4
03CAA:  ADD     W0,W4,W0
03CAC:  MOV     W0,W4
03CAE:  MOV     #0,W3
03CB0:  MOV     [W4++],[W3++]
03CB2:  MOV     [W4++],[W3++]
03CB4:  MOV     #0,W2
03CB6:  MOV     #0,W3
03CB8:  CALL    12E8
03CBC:  MOV     W0,1B4E
03CBE:  MOV     W1,1B50
03CC0:  MOV     W2,1B52
03CC2:  MOV     W3,1B54
03CC4:  MOV     1B3A,W0
03CC6:  CLR     W3
03CC8:  BTSC    W0.F
03CCA:  SETM    W3
03CCC:  MOV     W3,W1
03CCE:  MOV     W3,W2
03CD0:  CALL    12E8
03CD4:  MOV     W0,1B56
03CD6:  MOV     W1,1B58
03CD8:  MOV     W2,1B5A
03CDA:  MOV     W3,1B5C
03CDC:  MOV     1B3C,W0
03CDE:  CLR     W3
03CE0:  BTSC    W0.F
03CE2:  SETM    W3
03CE4:  MOV     W3,W1
03CE6:  MOV     W3,W2
03CE8:  CALL    12E8
03CEC:  MOV     W0,1B5E
03CEE:  MOV     W1,1B60
03CF0:  MOV     W2,1B62
03CF2:  MOV     W3,1B64
03CF4:  PUSH    1B46
03CF6:  POP     1B7A
03CF8:  PUSH    1B48
03CFA:  POP     1B7C
03CFC:  PUSH    1B4A
03CFE:  POP     1B7E
03D00:  PUSH    1B4C
03D02:  POP     1B80
03D04:  PUSH    1B4E
03D06:  POP     1B82
03D08:  PUSH    1B50
03D0A:  POP     1B84
03D0C:  PUSH    1B52
03D0E:  POP     1B86
03D10:  PUSH    1B54
03D12:  POP     1B88
03D14:  PUSH    1B56
03D16:  POP     1B8A
03D18:  PUSH    1B58
03D1A:  POP     1B8C
03D1C:  PUSH    1B5A
03D1E:  POP     1B8E
03D20:  PUSH    1B5C
03D22:  POP     1B90
03D24:  PUSH    1B5E
03D26:  POP     1B92
03D28:  PUSH    1B60
03D2A:  POP     1B94
03D2C:  PUSH    1B62
03D2E:  POP     1B96
03D30:  PUSH    1B64
03D32:  POP     1B98
03D34:  CALL    2AE8
03D38:  BCLR.B  43.0
03D3A:  MOV     W5,[W15++]
03D3C:  MOV     W6,[W15++]
03D3E:  MOV     W7,[W15++]
03D40:  MOV     W0,W4
03D42:  MOV     W1,W5
03D44:  MOV     W2,W6
03D46:  MOV     W3,W7
03D48:  MOV     W10,W0
03D4A:  MOV     W11,W1
03D4C:  MOV     W12,W2
03D4E:  MOV     W13,W3
03D50:  CALL    13FC
03D54:  MOV     [--W15],W7
03D56:  MOV     [--W15],W6
03D58:  MOV     [--W15],W5
03D5A:  MOV     W5,[W15++]
03D5C:  MOV     W6,[W15++]
03D5E:  MOV     W7,[W15++]
03D60:  MOV     W0,W4
03D62:  MOV     W5,W0
03D64:  MOV     W1,W5
03D66:  MOV     W6,W1
03D68:  MOV     W2,W6
03D6A:  MOV     W7,W2
03D6C:  MOV     W3,W7
03D6E:  MOV     W8,W3
03D70:  CALL    15EA
03D74:  MOV     [--W15],W7
03D76:  MOV     [--W15],W6
03D78:  MOV     [--W15],W5
03D7A:  BRA     NC,3DEE
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
03D7C:  MOV     A9A,W4
03D7E:  MUL.UU  W4,#10,W0
03D80:  MOV     W0,W5
03D82:  MOV     #AB2,W4
03D84:  ADD     W5,W4,W6
03D86:  MOV     1B3E,W4
03D88:  MUL.UU  W4,#2,W0
03D8A:  MOV     #A9E,W4
03D8C:  ADD     W0,W4,W0
03D8E:  MOV     [W0],W7
03D90:  MOV     W7,W4
03D92:  MUL.UU  W4,#10,W0
03D94:  MOV     W0,W7
03D96:  MOV     #B72,W4
03D98:  ADD     W7,W4,W0
03D9A:  MOV     W0,W4
03D9C:  MOV     #0,W3
03D9E:  MOV     [W4++],[W3++]
03DA0:  MOV     [W4++],[W3++]
03DA2:  MOV     #0,W2
03DA4:  MOV     #0,W3
03DA6:  CALL    12E8
03DAA:  MOV     #0,W4
03DAC:  REPEAT  #3
03DAE:  MOV     [W4++],[W6++]
03DB0:  MOV     A9A,W4
03DB2:  MUL.UU  W4,#10,W0
03DB4:  MOV     W0,W5
03DB6:  ADD     W5,#8,W0
03DB8:  MOV     #AB2,W4
03DBA:  ADD     W0,W4,W5
03DBC:  MOV     1B3E,W4
03DBE:  MUL.UU  W4,#2,W0
03DC0:  MOV     #A9E,W4
03DC2:  ADD     W0,W4,W0
03DC4:  MOV     [W0],W6
03DC6:  MOV     W6,W4
03DC8:  MUL.UU  W4,#10,W6
03DCA:  ADD     W6,#4,W0
03DCC:  MOV     #B72,W4
03DCE:  ADD     W0,W4,W0
03DD0:  MOV     W0,W4
03DD2:  MOV     #0,W3
03DD4:  MOV     [W4++],[W3++]
03DD6:  MOV     [W4++],[W3++]
03DD8:  MOV     #0,W2
03DDA:  MOV     #0,W3
03DDC:  CALL    12E8
03DE0:  MOV     #0,W4
03DE2:  REPEAT  #3
03DE4:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
03DE6:  MOV     #1,W4
03DE8:  MOV     W4,1B44
.................... 	                } 
03DEA:  GOTO    3E5E
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
03DEE:  MOV     A9A,W4
03DF0:  MUL.UU  W4,#10,W0
03DF2:  MOV     W0,W5
03DF4:  MOV     #AB2,W4
03DF6:  ADD     W5,W4,W6
03DF8:  MOV     1B3E,W4
03DFA:  MUL.UU  W4,#2,W0
03DFC:  MOV     #A9E,W4
03DFE:  ADD     W0,W4,W0
03E00:  MOV     [W0],W7
03E02:  MOV     W7,W4
03E04:  MUL.UU  W4,#10,W0
03E06:  MOV     W0,W7
03E08:  ADD     W7,#8,W0
03E0A:  MOV     #B72,W4
03E0C:  ADD     W0,W4,W0
03E0E:  MOV     W0,W4
03E10:  MOV     #0,W3
03E12:  MOV     [W4++],[W3++]
03E14:  MOV     [W4++],[W3++]
03E16:  MOV     #0,W2
03E18:  MOV     #0,W3
03E1A:  CALL    12E8
03E1E:  MOV     #0,W4
03E20:  REPEAT  #3
03E22:  MOV     [W4++],[W6++]
03E24:  MOV     A9A,W4
03E26:  MUL.UU  W4,#10,W0
03E28:  MOV     W0,W5
03E2A:  ADD     W5,#8,W0
03E2C:  MOV     #AB2,W4
03E2E:  ADD     W0,W4,W5
03E30:  MOV     1B3E,W4
03E32:  MUL.UU  W4,#2,W0
03E34:  MOV     #A9E,W4
03E36:  ADD     W0,W4,W0
03E38:  MOV     [W0],W6
03E3A:  MOV     W6,W4
03E3C:  MUL.UU  W4,#10,W6
03E3E:  ADD     W6,#C,W0
03E40:  MOV     #B72,W4
03E42:  ADD     W0,W4,W0
03E44:  MOV     W0,W4
03E46:  MOV     #0,W3
03E48:  MOV     [W4++],[W3++]
03E4A:  MOV     [W4++],[W3++]
03E4C:  MOV     #0,W2
03E4E:  MOV     #0,W3
03E50:  CALL    12E8
03E54:  MOV     #0,W4
03E56:  REPEAT  #3
03E58:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
03E5A:  MOV     #1,W4
03E5C:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
03E5E:  MOV     #1,W4
03E60:  MOV     W4,A96
.................... 	            } 
03E62:  GOTO    3EDE
.................... 	            else if (posEnd == 7) 
03E66:  MOV     1B42,W4
03E68:  CP      W4,#7
03E6A:  BRA     NZ,3EDE
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
03E6C:  MOV     A9A,W4
03E6E:  MUL.UU  W4,#10,W0
03E70:  MOV     W0,W5
03E72:  MOV     #AB2,W4
03E74:  ADD     W5,W4,W6
03E76:  MOV     1B3E,W4
03E78:  MUL.UU  W4,#2,W0
03E7A:  MOV     #A9E,W4
03E7C:  ADD     W0,W4,W0
03E7E:  MOV     [W0],W7
03E80:  MOV     W7,W4
03E82:  MUL.UU  W4,#10,W0
03E84:  MOV     W0,W7
03E86:  MOV     #B72,W4
03E88:  ADD     W7,W4,W0
03E8A:  MOV     W0,W4
03E8C:  MOV     #0,W3
03E8E:  MOV     [W4++],[W3++]
03E90:  MOV     [W4++],[W3++]
03E92:  MOV     #0,W2
03E94:  MOV     #0,W3
03E96:  CALL    12E8
03E9A:  MOV     #0,W4
03E9C:  REPEAT  #3
03E9E:  MOV     [W4++],[W6++]
03EA0:  MOV     A9A,W4
03EA2:  MUL.UU  W4,#10,W0
03EA4:  MOV     W0,W5
03EA6:  ADD     W5,#8,W0
03EA8:  MOV     #AB2,W4
03EAA:  ADD     W0,W4,W5
03EAC:  MOV     1B3E,W4
03EAE:  MUL.UU  W4,#2,W0
03EB0:  MOV     #A9E,W4
03EB2:  ADD     W0,W4,W0
03EB4:  MOV     [W0],W6
03EB6:  MOV     W6,W4
03EB8:  MUL.UU  W4,#10,W6
03EBA:  ADD     W6,#4,W0
03EBC:  MOV     #B72,W4
03EBE:  ADD     W0,W4,W0
03EC0:  MOV     W0,W4
03EC2:  MOV     #0,W3
03EC4:  MOV     [W4++],[W3++]
03EC6:  MOV     [W4++],[W3++]
03EC8:  MOV     #0,W2
03ECA:  MOV     #0,W3
03ECC:  CALL    12E8
03ED0:  MOV     #0,W4
03ED2:  REPEAT  #3
03ED4:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
03ED6:  MOV     #1,W4
03ED8:  MOV     W4,1B44
.................... 	                path_found = true; 
03EDA:  MOV     #1,W4
03EDC:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
03EDE:  GOTO    5E6E
....................  
.................... 	        case 3: 
.................... 	            if (posEnd == 5 || posEnd == 6) 
03EE2:  MOV     1B42,W4
03EE4:  CP      W4,#5
03EE6:  BRA     Z,3EEE
03EE8:  MOV     1B42,W4
03EEA:  CP      W4,#6
03EEC:  BRA     NZ,3F66
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
03EEE:  MOV     A9A,W4
03EF0:  MUL.UU  W4,#10,W0
03EF2:  MOV     W0,W5
03EF4:  MOV     #AB2,W4
03EF6:  ADD     W5,W4,W6
03EF8:  MOV     1B3E,W4
03EFA:  MUL.UU  W4,#2,W0
03EFC:  MOV     #A9E,W4
03EFE:  ADD     W0,W4,W0
03F00:  MOV     [W0],W7
03F02:  MOV     W7,W4
03F04:  MUL.UU  W4,#10,W0
03F06:  MOV     W0,W7
03F08:  ADD     W7,#8,W0
03F0A:  MOV     #B72,W4
03F0C:  ADD     W0,W4,W0
03F0E:  MOV     W0,W4
03F10:  MOV     #0,W3
03F12:  MOV     [W4++],[W3++]
03F14:  MOV     [W4++],[W3++]
03F16:  MOV     #0,W2
03F18:  MOV     #0,W3
03F1A:  CALL    12E8
03F1E:  MOV     #0,W4
03F20:  REPEAT  #3
03F22:  MOV     [W4++],[W6++]
03F24:  MOV     A9A,W4
03F26:  MUL.UU  W4,#10,W0
03F28:  MOV     W0,W5
03F2A:  ADD     W5,#8,W0
03F2C:  MOV     #AB2,W4
03F2E:  ADD     W0,W4,W5
03F30:  MOV     1B3E,W4
03F32:  MUL.UU  W4,#2,W0
03F34:  MOV     #A9E,W4
03F36:  ADD     W0,W4,W0
03F38:  MOV     [W0],W6
03F3A:  MOV     W6,W4
03F3C:  MUL.UU  W4,#10,W6
03F3E:  ADD     W6,#C,W0
03F40:  MOV     #B72,W4
03F42:  ADD     W0,W4,W0
03F44:  MOV     W0,W4
03F46:  MOV     #0,W3
03F48:  MOV     [W4++],[W3++]
03F4A:  MOV     [W4++],[W3++]
03F4C:  MOV     #0,W2
03F4E:  MOV     #0,W3
03F50:  CALL    12E8
03F54:  MOV     #0,W4
03F56:  REPEAT  #3
03F58:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
03F5A:  MOV     #1,W4
03F5C:  MOV     W4,1B44
.................... 	                path_found = true; 
03F5E:  MOV     #1,W4
03F60:  MOV     W4,A96
.................... 	            } 
03F62:  GOTO    4592
.................... 	            else if (posEnd == 7) 
03F66:  MOV     1B42,W4
03F68:  CP      W4,#7
03F6A:  BRA     NZ,450C
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
03F6C:  MOV     1B36,W0
03F6E:  CLR     W3
03F70:  BTSC    W0.F
03F72:  SETM    W3
03F74:  MOV     W3,W1
03F76:  MOV     W3,W2
03F78:  CALL    12E8
03F7C:  MOV     W0,W5
03F7E:  MOV     W1,W6
03F80:  MOV     W2,W7
03F82:  MOV     W3,W8
03F84:  MOV     1B38,W0
03F86:  CLR     W3
03F88:  BTSC    W0.F
03F8A:  SETM    W3
03F8C:  MOV     W3,W1
03F8E:  MOV     W3,W2
03F90:  CALL    12E8
03F94:  MOV     W0,W9
03F96:  MOV     W1,W10
03F98:  MOV     W2,W11
03F9A:  MOV     W3,W12
03F9C:  MOV     1B3E,W4
03F9E:  MUL.UU  W4,#2,W0
03FA0:  MOV     #A9E,W4
03FA2:  ADD     W0,W4,W0
03FA4:  MOV     [W0],W13
03FA6:  MOV     W13,W4
03FA8:  MUL.UU  W4,#10,W0
03FAA:  MOV     W0,W13
03FAC:  MOV     1B22,W4
03FAE:  MUL.UU  W4,#4,W0
03FB0:  ADD     W0,W13,W0
03FB2:  MOV     #B72,W4
03FB4:  ADD     W0,W4,W0
03FB6:  MOV     W0,W4
03FB8:  MOV     #0,W3
03FBA:  MOV     [W4++],[W3++]
03FBC:  MOV     [W4++],[W3++]
03FBE:  MOV     #0,W2
03FC0:  MOV     #0,W3
03FC2:  CALL    12E8
03FC6:  MOV     W0,W13
03FC8:  MOV     W1,W14
03FCA:  MOV     W2,W15
03FCC:  MOV     W3,[W0]
03FCE:  MOV     1B3E,W4
03FD0:  MUL.UU  W4,#2,W0
03FD2:  MOV     #A9E,W4
03FD4:  ADD     W0,W4,W0
03FD6:  MOV     [W0],[W15++]
03FD8:  POP     1B4C
03FDA:  MOV     1B4C,W4
03FDC:  MUL.UU  W4,#10,W0
03FDE:  MOV     W0,1B4C
03FE0:  MOV     1B24,W4
03FE2:  MUL.UU  W4,#4,W0
03FE4:  MOV     1B4C,W4
03FE6:  ADD     W0,W4,W0
03FE8:  MOV     #B72,W4
03FEA:  ADD     W0,W4,W0
03FEC:  MOV     W0,W4
03FEE:  MOV     #0,W3
03FF0:  MOV     [W4++],[W3++]
03FF2:  MOV     [W4++],[W3++]
03FF4:  MOV     #0,W2
03FF6:  MOV     #0,W3
03FF8:  CALL    12E8
03FFC:  MOV     W0,1B4C
03FFE:  MOV     W1,1B4E
04000:  MOV     W2,1B50
04002:  MOV     W3,1B52
04004:  MOV     W5,1B7A
04006:  MOV     W6,1B7C
04008:  MOV     W7,1B7E
0400A:  MOV     W8,1B80
0400C:  MOV     W9,1B82
0400E:  MOV     W10,1B84
04010:  MOV     W11,1B86
04012:  MOV     W12,1B88
04014:  MOV     W13,1B8A
04016:  MOV     W14,1B8C
04018:  MOV     W15,1B8E
0401A:  MOV     [W0],[W15++]
0401C:  POP     1B90
0401E:  PUSH    1B4C
04020:  POP     1B92
04022:  PUSH    1B4E
04024:  POP     1B94
04026:  PUSH    1B50
04028:  POP     1B96
0402A:  PUSH    1B52
0402C:  POP     1B98
0402E:  CALL    2AE8
04032:  MOV     W0,W5
04034:  MOV     W1,W6
04036:  MOV     W2,W7
04038:  MOV     W3,W8
0403A:  MOV     1B3E,W4
0403C:  MUL.UU  W4,#2,W0
0403E:  MOV     #A9E,W4
04040:  ADD     W0,W4,W0
04042:  MOV     [W0],W9
04044:  MOV     W9,W4
04046:  MUL.UU  W4,#10,W0
04048:  MOV     W0,W9
0404A:  MOV     #B72,W4
0404C:  ADD     W9,W4,W0
0404E:  MOV     W0,W4
04050:  MOV     #0,W3
04052:  MOV     [W4++],[W3++]
04054:  MOV     [W4++],[W3++]
04056:  MOV     #0,W2
04058:  MOV     #0,W3
0405A:  CALL    12E8
0405E:  MOV     W0,W10
04060:  MOV     W1,W11
04062:  MOV     W2,W12
04064:  MOV     W3,W13
04066:  MOV     1B3E,W4
04068:  MUL.UU  W4,#2,W0
0406A:  MOV     #A9E,W4
0406C:  ADD     W0,W4,W0
0406E:  MOV     [W0],[W15++]
04070:  POP     1B46
04072:  MOV     1B46,W4
04074:  MUL.UU  W4,#10,W0
04076:  MOV     W0,1B46
04078:  MOV     1B46,W4
0407A:  ADD     W4,#4,W0
0407C:  MOV     #B72,W4
0407E:  ADD     W0,W4,W0
04080:  MOV     W0,W4
04082:  MOV     #0,W3
04084:  MOV     [W4++],[W3++]
04086:  MOV     [W4++],[W3++]
04088:  MOV     #0,W2
0408A:  MOV     #0,W3
0408C:  CALL    12E8
04090:  MOV     W0,1B46
04092:  MOV     W1,1B48
04094:  MOV     W2,1B4A
04096:  MOV     W3,1B4C
04098:  MOV     1B3A,W0
0409A:  CLR     W3
0409C:  BTSC    W0.F
0409E:  SETM    W3
040A0:  MOV     W3,W1
040A2:  MOV     W3,W2
040A4:  CALL    12E8
040A8:  MOV     W0,1B4E
040AA:  MOV     W1,1B50
040AC:  MOV     W2,1B52
040AE:  MOV     W3,1B54
040B0:  MOV     1B3C,W0
040B2:  CLR     W3
040B4:  BTSC    W0.F
040B6:  SETM    W3
040B8:  MOV     W3,W1
040BA:  MOV     W3,W2
040BC:  CALL    12E8
040C0:  MOV     W0,1B56
040C2:  MOV     W1,1B58
040C4:  MOV     W2,1B5A
040C6:  MOV     W3,1B5C
040C8:  MOV     W10,1B7A
040CA:  MOV     W11,1B7C
040CC:  MOV     W12,1B7E
040CE:  MOV     W13,1B80
040D0:  PUSH    1B46
040D2:  POP     1B82
040D4:  PUSH    1B48
040D6:  POP     1B84
040D8:  PUSH    1B4A
040DA:  POP     1B86
040DC:  PUSH    1B4C
040DE:  POP     1B88
040E0:  PUSH    1B4E
040E2:  POP     1B8A
040E4:  PUSH    1B50
040E6:  POP     1B8C
040E8:  PUSH    1B52
040EA:  POP     1B8E
040EC:  PUSH    1B54
040EE:  POP     1B90
040F0:  PUSH    1B56
040F2:  POP     1B92
040F4:  PUSH    1B58
040F6:  POP     1B94
040F8:  PUSH    1B5A
040FA:  POP     1B96
040FC:  PUSH    1B5C
040FE:  POP     1B98
04100:  CALL    2AE8
04104:  BCLR.B  43.0
04106:  MOV     W5,[W15++]
04108:  MOV     W6,[W15++]
0410A:  MOV     W7,[W15++]
0410C:  MOV     W0,W4
0410E:  MOV     W5,W0
04110:  MOV     W1,W5
04112:  MOV     W6,W1
04114:  MOV     W2,W6
04116:  MOV     W7,W2
04118:  MOV     W3,W7
0411A:  MOV     W8,W3
0411C:  CALL    13FC
04120:  MOV     [--W15],W7
04122:  MOV     [--W15],W6
04124:  MOV     [--W15],W5
04126:  MOV     W0,W5
04128:  MOV     W1,W6
0412A:  MOV     W2,W7
0412C:  MOV     W3,W8
0412E:  MOV     1B36,W0
04130:  CLR     W3
04132:  BTSC    W0.F
04134:  SETM    W3
04136:  MOV     W3,W1
04138:  MOV     W3,W2
0413A:  CALL    12E8
0413E:  MOV     W0,W10
04140:  MOV     W1,W11
04142:  MOV     W2,W12
04144:  MOV     W3,W13
04146:  MOV     1B38,W0
04148:  CLR     W3
0414A:  BTSC    W0.F
0414C:  SETM    W3
0414E:  MOV     W3,W1
04150:  MOV     W3,W2
04152:  CALL    12E8
04156:  MOV     W0,1B46
04158:  MOV     W1,1B48
0415A:  MOV     W2,1B4A
0415C:  MOV     W3,1B4C
0415E:  MOV     1B3E,W4
04160:  MUL.UU  W4,#2,W0
04162:  MOV     #A9E,W4
04164:  ADD     W0,W4,W0
04166:  MOV     [W0],[W15++]
04168:  POP     1B4E
0416A:  MOV     1B4E,W4
0416C:  MUL.UU  W4,#10,W0
0416E:  MOV     W0,1B4E
04170:  MOV     1B4E,W4
04172:  ADD     W4,#8,W0
04174:  MOV     #B72,W4
04176:  ADD     W0,W4,W0
04178:  MOV     W0,W4
0417A:  MOV     #0,W3
0417C:  MOV     [W4++],[W3++]
0417E:  MOV     [W4++],[W3++]
04180:  MOV     #0,W2
04182:  MOV     #0,W3
04184:  CALL    12E8
04188:  MOV     W0,1B4E
0418A:  MOV     W1,1B50
0418C:  MOV     W2,1B52
0418E:  MOV     W3,1B54
04190:  MOV     1B3E,W4
04192:  MUL.UU  W4,#2,W0
04194:  MOV     #A9E,W4
04196:  ADD     W0,W4,W0
04198:  MOV     [W0],[W15++]
0419A:  POP     1B56
0419C:  MOV     1B56,W4
0419E:  MUL.UU  W4,#10,W0
041A0:  MOV     W0,1B56
041A2:  MOV     1B56,W4
041A4:  ADD     W4,#C,W0
041A6:  MOV     #B72,W4
041A8:  ADD     W0,W4,W0
041AA:  MOV     W0,W4
041AC:  MOV     #0,W3
041AE:  MOV     [W4++],[W3++]
041B0:  MOV     [W4++],[W3++]
041B2:  MOV     #0,W2
041B4:  MOV     #0,W3
041B6:  CALL    12E8
041BA:  MOV     W0,1B56
041BC:  MOV     W1,1B58
041BE:  MOV     W2,1B5A
041C0:  MOV     W3,1B5C
041C2:  MOV     W10,1B7A
041C4:  MOV     W11,1B7C
041C6:  MOV     W12,1B7E
041C8:  MOV     W13,1B80
041CA:  PUSH    1B46
041CC:  POP     1B82
041CE:  PUSH    1B48
041D0:  POP     1B84
041D2:  PUSH    1B4A
041D4:  POP     1B86
041D6:  PUSH    1B4C
041D8:  POP     1B88
041DA:  PUSH    1B4E
041DC:  POP     1B8A
041DE:  PUSH    1B50
041E0:  POP     1B8C
041E2:  PUSH    1B52
041E4:  POP     1B8E
041E6:  PUSH    1B54
041E8:  POP     1B90
041EA:  PUSH    1B56
041EC:  POP     1B92
041EE:  PUSH    1B58
041F0:  POP     1B94
041F2:  PUSH    1B5A
041F4:  POP     1B96
041F6:  PUSH    1B5C
041F8:  POP     1B98
041FA:  CALL    2AE8
041FE:  MOV     W0,W10
04200:  MOV     W1,W11
04202:  MOV     W2,W12
04204:  MOV     W3,W13
04206:  MOV     1B3E,W4
04208:  MUL.UU  W4,#2,W0
0420A:  MOV     #A9E,W4
0420C:  ADD     W0,W4,W0
0420E:  MOV     [W0],[W15++]
04210:  POP     1B46
04212:  MOV     1B46,W4
04214:  MUL.UU  W4,#10,W0
04216:  MOV     W0,1B46
04218:  MOV     1B1E,W4
0421A:  MUL.UU  W4,#4,W0
0421C:  MOV     1B46,W4
0421E:  ADD     W0,W4,W0
04220:  MOV     #B72,W4
04222:  ADD     W0,W4,W0
04224:  MOV     W0,W4
04226:  MOV     #0,W3
04228:  MOV     [W4++],[W3++]
0422A:  MOV     [W4++],[W3++]
0422C:  MOV     #0,W2
0422E:  MOV     #0,W3
04230:  CALL    12E8
04234:  MOV     W0,1B46
04236:  MOV     W1,1B48
04238:  MOV     W2,1B4A
0423A:  MOV     W3,1B4C
0423C:  MOV     1B3E,W4
0423E:  MUL.UU  W4,#2,W0
04240:  MOV     #A9E,W4
04242:  ADD     W0,W4,W0
04244:  MOV     [W0],[W15++]
04246:  POP     1B4E
04248:  MOV     1B4E,W4
0424A:  MUL.UU  W4,#10,W0
0424C:  MOV     W0,1B4E
0424E:  MOV     1B20,W4
04250:  MUL.UU  W4,#4,W0
04252:  MOV     1B4E,W4
04254:  ADD     W0,W4,W0
04256:  MOV     #B72,W4
04258:  ADD     W0,W4,W0
0425A:  MOV     W0,W4
0425C:  MOV     #0,W3
0425E:  MOV     [W4++],[W3++]
04260:  MOV     [W4++],[W3++]
04262:  MOV     #0,W2
04264:  MOV     #0,W3
04266:  CALL    12E8
0426A:  MOV     W0,1B4E
0426C:  MOV     W1,1B50
0426E:  MOV     W2,1B52
04270:  MOV     W3,1B54
04272:  MOV     1B3A,W0
04274:  CLR     W3
04276:  BTSC    W0.F
04278:  SETM    W3
0427A:  MOV     W3,W1
0427C:  MOV     W3,W2
0427E:  CALL    12E8
04282:  MOV     W0,1B56
04284:  MOV     W1,1B58
04286:  MOV     W2,1B5A
04288:  MOV     W3,1B5C
0428A:  MOV     1B3C,W0
0428C:  CLR     W3
0428E:  BTSC    W0.F
04290:  SETM    W3
04292:  MOV     W3,W1
04294:  MOV     W3,W2
04296:  CALL    12E8
0429A:  MOV     W0,1B5E
0429C:  MOV     W1,1B60
0429E:  MOV     W2,1B62
042A0:  MOV     W3,1B64
042A2:  PUSH    1B46
042A4:  POP     1B7A
042A6:  PUSH    1B48
042A8:  POP     1B7C
042AA:  PUSH    1B4A
042AC:  POP     1B7E
042AE:  PUSH    1B4C
042B0:  POP     1B80
042B2:  PUSH    1B4E
042B4:  POP     1B82
042B6:  PUSH    1B50
042B8:  POP     1B84
042BA:  PUSH    1B52
042BC:  POP     1B86
042BE:  PUSH    1B54
042C0:  POP     1B88
042C2:  PUSH    1B56
042C4:  POP     1B8A
042C6:  PUSH    1B58
042C8:  POP     1B8C
042CA:  PUSH    1B5A
042CC:  POP     1B8E
042CE:  PUSH    1B5C
042D0:  POP     1B90
042D2:  PUSH    1B5E
042D4:  POP     1B92
042D6:  PUSH    1B60
042D8:  POP     1B94
042DA:  PUSH    1B62
042DC:  POP     1B96
042DE:  PUSH    1B64
042E0:  POP     1B98
042E2:  CALL    2AE8
042E6:  BCLR.B  43.0
042E8:  MOV     W5,[W15++]
042EA:  MOV     W6,[W15++]
042EC:  MOV     W7,[W15++]
042EE:  MOV     W0,W4
042F0:  MOV     W1,W5
042F2:  MOV     W2,W6
042F4:  MOV     W3,W7
042F6:  MOV     W10,W0
042F8:  MOV     W11,W1
042FA:  MOV     W12,W2
042FC:  MOV     W13,W3
042FE:  CALL    13FC
04302:  MOV     [--W15],W7
04304:  MOV     [--W15],W6
04306:  MOV     [--W15],W5
04308:  MOV     W5,[W15++]
0430A:  MOV     W6,[W15++]
0430C:  MOV     W7,[W15++]
0430E:  MOV     W0,W4
04310:  MOV     W5,W0
04312:  MOV     W1,W5
04314:  MOV     W6,W1
04316:  MOV     W2,W6
04318:  MOV     W7,W2
0431A:  MOV     W3,W7
0431C:  MOV     W8,W3
0431E:  CALL    15EA
04322:  MOV     [--W15],W7
04324:  MOV     [--W15],W6
04326:  MOV     [--W15],W5
04328:  BRA     NC,4418
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0432A:  MOV     A9A,W4
0432C:  MUL.UU  W4,#10,W0
0432E:  MOV     W0,W5
04330:  MOV     #AB2,W4
04332:  ADD     W5,W4,W6
04334:  MOV     1B3E,W4
04336:  MUL.UU  W4,#2,W0
04338:  MOV     #A9E,W4
0433A:  ADD     W0,W4,W0
0433C:  MOV     [W0],W7
0433E:  MOV     W7,W4
04340:  MUL.UU  W4,#10,W0
04342:  MOV     W0,W7
04344:  MOV     1B22,W4
04346:  MUL.UU  W4,#4,W0
04348:  ADD     W0,W7,W0
0434A:  MOV     #B72,W4
0434C:  ADD     W0,W4,W0
0434E:  MOV     W0,W4
04350:  MOV     #0,W3
04352:  MOV     [W4++],[W3++]
04354:  MOV     [W4++],[W3++]
04356:  MOV     #0,W2
04358:  MOV     #0,W3
0435A:  CALL    12E8
0435E:  MOV     #0,W4
04360:  REPEAT  #3
04362:  MOV     [W4++],[W6++]
04364:  MOV     A9A,W4
04366:  MUL.UU  W4,#10,W0
04368:  MOV     W0,W5
0436A:  ADD     W5,#8,W0
0436C:  MOV     #AB2,W4
0436E:  ADD     W0,W4,W5
04370:  MOV     1B3E,W4
04372:  MUL.UU  W4,#2,W0
04374:  MOV     #A9E,W4
04376:  ADD     W0,W4,W0
04378:  MOV     [W0],W6
0437A:  MOV     W6,W4
0437C:  MUL.UU  W4,#10,W6
0437E:  MOV     1B24,W4
04380:  MUL.UU  W4,#4,W0
04382:  ADD     W0,W6,W0
04384:  MOV     #B72,W4
04386:  ADD     W0,W4,W0
04388:  MOV     W0,W4
0438A:  MOV     #0,W3
0438C:  MOV     [W4++],[W3++]
0438E:  MOV     [W4++],[W3++]
04390:  MOV     #0,W2
04392:  MOV     #0,W3
04394:  CALL    12E8
04398:  MOV     #0,W4
0439A:  REPEAT  #3
0439C:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y1]; 
0439E:  MOV     A9A,W4
043A0:  ADD     W4,#1,W5
043A2:  MOV     W5,W4
043A4:  MUL.UU  W4,#10,W0
043A6:  MOV     W0,W5
043A8:  MOV     #AB2,W4
043AA:  ADD     W5,W4,W6
043AC:  MOV     1B3E,W4
043AE:  MUL.UU  W4,#2,W0
043B0:  MOV     #A9E,W4
043B2:  ADD     W0,W4,W0
043B4:  MOV     [W0],W7
043B6:  MOV     W7,W4
043B8:  MUL.UU  W4,#10,W0
043BA:  MOV     W0,W7
043BC:  MOV     #B72,W4
043BE:  ADD     W7,W4,W0
043C0:  MOV     W0,W4
043C2:  MOV     #0,W3
043C4:  MOV     [W4++],[W3++]
043C6:  MOV     [W4++],[W3++]
043C8:  MOV     #0,W2
043CA:  MOV     #0,W3
043CC:  CALL    12E8
043D0:  MOV     #0,W4
043D2:  REPEAT  #3
043D4:  MOV     [W4++],[W6++]
043D6:  MOV     A9A,W4
043D8:  ADD     W4,#1,W5
043DA:  MOV     W5,W4
043DC:  MUL.UU  W4,#10,W0
043DE:  MOV     W0,W5
043E0:  ADD     W5,#8,W0
043E2:  MOV     #AB2,W4
043E4:  ADD     W0,W4,W5
043E6:  MOV     1B3E,W4
043E8:  MUL.UU  W4,#2,W0
043EA:  MOV     #A9E,W4
043EC:  ADD     W0,W4,W0
043EE:  MOV     [W0],W6
043F0:  MOV     W6,W4
043F2:  MUL.UU  W4,#10,W6
043F4:  ADD     W6,#4,W0
043F6:  MOV     #B72,W4
043F8:  ADD     W0,W4,W0
043FA:  MOV     W0,W4
043FC:  MOV     #0,W3
043FE:  MOV     [W4++],[W3++]
04400:  MOV     [W4++],[W3++]
04402:  MOV     #0,W2
04404:  MOV     #0,W3
04406:  CALL    12E8
0440A:  MOV     #0,W4
0440C:  REPEAT  #3
0440E:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
04410:  MOV     #2,W4
04412:  MOV     W4,1B44
.................... 	                } 
04414:  GOTO    4504
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04418:  MOV     A9A,W4
0441A:  MUL.UU  W4,#10,W0
0441C:  MOV     W0,W5
0441E:  MOV     #AB2,W4
04420:  ADD     W5,W4,W6
04422:  MOV     1B3E,W4
04424:  MUL.UU  W4,#2,W0
04426:  MOV     #A9E,W4
04428:  ADD     W0,W4,W0
0442A:  MOV     [W0],W7
0442C:  MOV     W7,W4
0442E:  MUL.UU  W4,#10,W0
04430:  MOV     W0,W7
04432:  ADD     W7,#8,W0
04434:  MOV     #B72,W4
04436:  ADD     W0,W4,W0
04438:  MOV     W0,W4
0443A:  MOV     #0,W3
0443C:  MOV     [W4++],[W3++]
0443E:  MOV     [W4++],[W3++]
04440:  MOV     #0,W2
04442:  MOV     #0,W3
04444:  CALL    12E8
04448:  MOV     #0,W4
0444A:  REPEAT  #3
0444C:  MOV     [W4++],[W6++]
0444E:  MOV     A9A,W4
04450:  MUL.UU  W4,#10,W0
04452:  MOV     W0,W5
04454:  ADD     W5,#8,W0
04456:  MOV     #AB2,W4
04458:  ADD     W0,W4,W5
0445A:  MOV     1B3E,W4
0445C:  MUL.UU  W4,#2,W0
0445E:  MOV     #A9E,W4
04460:  ADD     W0,W4,W0
04462:  MOV     [W0],W6
04464:  MOV     W6,W4
04466:  MUL.UU  W4,#10,W6
04468:  ADD     W6,#C,W0
0446A:  MOV     #B72,W4
0446C:  ADD     W0,W4,W0
0446E:  MOV     W0,W4
04470:  MOV     #0,W3
04472:  MOV     [W4++],[W3++]
04474:  MOV     [W4++],[W3++]
04476:  MOV     #0,W2
04478:  MOV     #0,W3
0447A:  CALL    12E8
0447E:  MOV     #0,W4
04480:  REPEAT  #3
04482:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3]; 
04484:  MOV     A9A,W4
04486:  ADD     W4,#1,W5
04488:  MOV     W5,W4
0448A:  MUL.UU  W4,#10,W0
0448C:  MOV     W0,W5
0448E:  MOV     #AB2,W4
04490:  ADD     W5,W4,W6
04492:  MOV     1B3E,W4
04494:  MUL.UU  W4,#2,W0
04496:  MOV     #A9E,W4
04498:  ADD     W0,W4,W0
0449A:  MOV     [W0],W7
0449C:  MOV     W7,W4
0449E:  MUL.UU  W4,#10,W0
044A0:  MOV     W0,W7
044A2:  MOV     1B1E,W4
044A4:  MUL.UU  W4,#4,W0
044A6:  ADD     W0,W7,W0
044A8:  MOV     #B72,W4
044AA:  ADD     W0,W4,W0
044AC:  MOV     W0,W4
044AE:  MOV     #0,W3
044B0:  MOV     [W4++],[W3++]
044B2:  MOV     [W4++],[W3++]
044B4:  MOV     #0,W2
044B6:  MOV     #0,W3
044B8:  CALL    12E8
044BC:  MOV     #0,W4
044BE:  REPEAT  #3
044C0:  MOV     [W4++],[W6++]
044C2:  MOV     A9A,W4
044C4:  ADD     W4,#1,W5
044C6:  MOV     W5,W4
044C8:  MUL.UU  W4,#10,W0
044CA:  MOV     W0,W5
044CC:  ADD     W5,#8,W0
044CE:  MOV     #AB2,W4
044D0:  ADD     W0,W4,W5
044D2:  MOV     1B3E,W4
044D4:  MUL.UU  W4,#2,W0
044D6:  MOV     #A9E,W4
044D8:  ADD     W0,W4,W0
044DA:  MOV     [W0],W6
044DC:  MOV     W6,W4
044DE:  MUL.UU  W4,#10,W6
044E0:  MOV     1B20,W4
044E2:  MUL.UU  W4,#4,W0
044E4:  ADD     W0,W6,W0
044E6:  MOV     #B72,W4
044E8:  ADD     W0,W4,W0
044EA:  MOV     W0,W4
044EC:  MOV     #0,W3
044EE:  MOV     [W4++],[W3++]
044F0:  MOV     [W4++],[W3++]
044F2:  MOV     #0,W2
044F4:  MOV     #0,W3
044F6:  CALL    12E8
044FA:  MOV     #0,W4
044FC:  REPEAT  #3
044FE:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
04500:  MOV     #2,W4
04502:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
04504:  MOV     #1,W4
04506:  MOV     W4,A96
.................... 	            } 
04508:  GOTO    4592
.................... 	            else if (posEnd == 0 || posEnd == 1) 
0450C:  CP0     1B42
0450E:  BRA     Z,4516
04510:  MOV     1B42,W4
04512:  CP      W4,#1
04514:  BRA     NZ,4592
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
04516:  MOV     A9A,W4
04518:  MUL.UU  W4,#10,W0
0451A:  MOV     W0,W5
0451C:  MOV     #AB2,W4
0451E:  ADD     W5,W4,W6
04520:  MOV     1B3E,W4
04522:  MUL.UU  W4,#2,W0
04524:  MOV     #A9E,W4
04526:  ADD     W0,W4,W0
04528:  MOV     [W0],W7
0452A:  MOV     W7,W4
0452C:  MUL.UU  W4,#10,W0
0452E:  MOV     W0,W7
04530:  MOV     1B22,W4
04532:  MUL.UU  W4,#4,W0
04534:  ADD     W0,W7,W0
04536:  MOV     #B72,W4
04538:  ADD     W0,W4,W0
0453A:  MOV     W0,W4
0453C:  MOV     #0,W3
0453E:  MOV     [W4++],[W3++]
04540:  MOV     [W4++],[W3++]
04542:  MOV     #0,W2
04544:  MOV     #0,W3
04546:  CALL    12E8
0454A:  MOV     #0,W4
0454C:  REPEAT  #3
0454E:  MOV     [W4++],[W6++]
04550:  MOV     A9A,W4
04552:  MUL.UU  W4,#10,W0
04554:  MOV     W0,W5
04556:  ADD     W5,#8,W0
04558:  MOV     #AB2,W4
0455A:  ADD     W0,W4,W5
0455C:  MOV     1B3E,W4
0455E:  MUL.UU  W4,#2,W0
04560:  MOV     #A9E,W4
04562:  ADD     W0,W4,W0
04564:  MOV     [W0],W6
04566:  MOV     W6,W4
04568:  MUL.UU  W4,#10,W6
0456A:  MOV     1B24,W4
0456C:  MUL.UU  W4,#4,W0
0456E:  ADD     W0,W6,W0
04570:  MOV     #B72,W4
04572:  ADD     W0,W4,W0
04574:  MOV     W0,W4
04576:  MOV     #0,W3
04578:  MOV     [W4++],[W3++]
0457A:  MOV     [W4++],[W3++]
0457C:  MOV     #0,W2
0457E:  MOV     #0,W3
04580:  CALL    12E8
04584:  MOV     #0,W4
04586:  REPEAT  #3
04588:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0458A:  MOV     #1,W4
0458C:  MOV     W4,1B44
.................... 	                path_found = true; 
0458E:  MOV     #1,W4
04590:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
04592:  GOTO    5E6E
....................  
.................... 	        case 4: 
.................... 	            if (posEnd == 7) 
04596:  MOV     1B42,W4
04598:  CP      W4,#7
0459A:  BRA     NZ,461C
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
0459C:  MOV     A9A,W4
0459E:  MUL.UU  W4,#10,W0
045A0:  MOV     W0,W5
045A2:  MOV     #AB2,W4
045A4:  ADD     W5,W4,W6
045A6:  MOV     1B3E,W4
045A8:  MUL.UU  W4,#2,W0
045AA:  MOV     #A9E,W4
045AC:  ADD     W0,W4,W0
045AE:  MOV     [W0],W7
045B0:  MOV     W7,W4
045B2:  MUL.UU  W4,#10,W0
045B4:  MOV     W0,W7
045B6:  MOV     1B1E,W4
045B8:  MUL.UU  W4,#4,W0
045BA:  ADD     W0,W7,W0
045BC:  MOV     #B72,W4
045BE:  ADD     W0,W4,W0
045C0:  MOV     W0,W4
045C2:  MOV     #0,W3
045C4:  MOV     [W4++],[W3++]
045C6:  MOV     [W4++],[W3++]
045C8:  MOV     #0,W2
045CA:  MOV     #0,W3
045CC:  CALL    12E8
045D0:  MOV     #0,W4
045D2:  REPEAT  #3
045D4:  MOV     [W4++],[W6++]
045D6:  MOV     A9A,W4
045D8:  MUL.UU  W4,#10,W0
045DA:  MOV     W0,W5
045DC:  ADD     W5,#8,W0
045DE:  MOV     #AB2,W4
045E0:  ADD     W0,W4,W5
045E2:  MOV     1B3E,W4
045E4:  MUL.UU  W4,#2,W0
045E6:  MOV     #A9E,W4
045E8:  ADD     W0,W4,W0
045EA:  MOV     [W0],W6
045EC:  MOV     W6,W4
045EE:  MUL.UU  W4,#10,W6
045F0:  MOV     1B20,W4
045F2:  MUL.UU  W4,#4,W0
045F4:  ADD     W0,W6,W0
045F6:  MOV     #B72,W4
045F8:  ADD     W0,W4,W0
045FA:  MOV     W0,W4
045FC:  MOV     #0,W3
045FE:  MOV     [W4++],[W3++]
04600:  MOV     [W4++],[W3++]
04602:  MOV     #0,W2
04604:  MOV     #0,W3
04606:  CALL    12E8
0460A:  MOV     #0,W4
0460C:  REPEAT  #3
0460E:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
04610:  MOV     #1,W4
04612:  MOV     W4,1B44
.................... 	                path_found = true; 
04614:  MOV     #1,W4
04616:  MOV     W4,A96
.................... 	            } 
04618:  GOTO    4B54
.................... 	            else if (posEnd == 0) 
0461C:  CP0     1B42
0461E:  BRA     NZ,4AD2
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
04620:  MOV     1B36,W0
04622:  CLR     W3
04624:  BTSC    W0.F
04626:  SETM    W3
04628:  MOV     W3,W1
0462A:  MOV     W3,W2
0462C:  CALL    12E8
04630:  MOV     W0,W5
04632:  MOV     W1,W6
04634:  MOV     W2,W7
04636:  MOV     W3,W8
04638:  MOV     1B38,W0
0463A:  CLR     W3
0463C:  BTSC    W0.F
0463E:  SETM    W3
04640:  MOV     W3,W1
04642:  MOV     W3,W2
04644:  CALL    12E8
04648:  MOV     W0,W9
0464A:  MOV     W1,W10
0464C:  MOV     W2,W11
0464E:  MOV     W3,W12
04650:  MOV     1B3E,W4
04652:  MUL.UU  W4,#2,W0
04654:  MOV     #A9E,W4
04656:  ADD     W0,W4,W0
04658:  MOV     [W0],W13
0465A:  MOV     W13,W4
0465C:  MUL.UU  W4,#10,W0
0465E:  MOV     W0,W13
04660:  MOV     1B22,W4
04662:  MUL.UU  W4,#4,W0
04664:  ADD     W0,W13,W0
04666:  MOV     #B72,W4
04668:  ADD     W0,W4,W0
0466A:  MOV     W0,W4
0466C:  MOV     #0,W3
0466E:  MOV     [W4++],[W3++]
04670:  MOV     [W4++],[W3++]
04672:  MOV     #0,W2
04674:  MOV     #0,W3
04676:  CALL    12E8
0467A:  MOV     W0,W13
0467C:  MOV     W1,W14
0467E:  MOV     W2,W15
04680:  MOV     W3,[W0]
04682:  MOV     1B3E,W4
04684:  MUL.UU  W4,#2,W0
04686:  MOV     #A9E,W4
04688:  ADD     W0,W4,W0
0468A:  MOV     [W0],[W15++]
0468C:  POP     1B4C
0468E:  MOV     1B4C,W4
04690:  MUL.UU  W4,#10,W0
04692:  MOV     W0,1B4C
04694:  MOV     1B24,W4
04696:  MUL.UU  W4,#4,W0
04698:  MOV     1B4C,W4
0469A:  ADD     W0,W4,W0
0469C:  MOV     #B72,W4
0469E:  ADD     W0,W4,W0
046A0:  MOV     W0,W4
046A2:  MOV     #0,W3
046A4:  MOV     [W4++],[W3++]
046A6:  MOV     [W4++],[W3++]
046A8:  MOV     #0,W2
046AA:  MOV     #0,W3
046AC:  CALL    12E8
046B0:  MOV     W0,1B4C
046B2:  MOV     W1,1B4E
046B4:  MOV     W2,1B50
046B6:  MOV     W3,1B52
046B8:  MOV     W5,1B7A
046BA:  MOV     W6,1B7C
046BC:  MOV     W7,1B7E
046BE:  MOV     W8,1B80
046C0:  MOV     W9,1B82
046C2:  MOV     W10,1B84
046C4:  MOV     W11,1B86
046C6:  MOV     W12,1B88
046C8:  MOV     W13,1B8A
046CA:  MOV     W14,1B8C
046CC:  MOV     W15,1B8E
046CE:  MOV     [W0],[W15++]
046D0:  POP     1B90
046D2:  PUSH    1B4C
046D4:  POP     1B92
046D6:  PUSH    1B4E
046D8:  POP     1B94
046DA:  PUSH    1B50
046DC:  POP     1B96
046DE:  PUSH    1B52
046E0:  POP     1B98
046E2:  CALL    2AE8
046E6:  MOV     W0,W5
046E8:  MOV     W1,W6
046EA:  MOV     W2,W7
046EC:  MOV     W3,W8
046EE:  MOV     1B3E,W4
046F0:  MUL.UU  W4,#2,W0
046F2:  MOV     #A9E,W4
046F4:  ADD     W0,W4,W0
046F6:  MOV     [W0],W9
046F8:  MOV     W9,W4
046FA:  MUL.UU  W4,#10,W0
046FC:  MOV     W0,W9
046FE:  MOV     1B22,W4
04700:  MUL.UU  W4,#4,W0
04702:  ADD     W0,W9,W0
04704:  MOV     #B72,W4
04706:  ADD     W0,W4,W0
04708:  MOV     W0,W4
0470A:  MOV     #0,W3
0470C:  MOV     [W4++],[W3++]
0470E:  MOV     [W4++],[W3++]
04710:  MOV     #0,W2
04712:  MOV     #0,W3
04714:  CALL    12E8
04718:  MOV     W0,W9
0471A:  MOV     W1,W10
0471C:  MOV     W2,W11
0471E:  MOV     W3,W12
04720:  MOV     1B3E,W4
04722:  MUL.UU  W4,#2,W0
04724:  MOV     #A9E,W4
04726:  ADD     W0,W4,W0
04728:  MOV     [W0],W13
0472A:  MOV     W13,W4
0472C:  MUL.UU  W4,#10,W0
0472E:  MOV     W0,W13
04730:  MOV     1B24,W4
04732:  MUL.UU  W4,#4,W0
04734:  ADD     W0,W13,W0
04736:  MOV     #B72,W4
04738:  ADD     W0,W4,W0
0473A:  MOV     W0,W4
0473C:  MOV     #0,W3
0473E:  MOV     [W4++],[W3++]
04740:  MOV     [W4++],[W3++]
04742:  MOV     #0,W2
04744:  MOV     #0,W3
04746:  CALL    12E8
0474A:  MOV     W0,W13
0474C:  MOV     W1,W14
0474E:  MOV     W2,W15
04750:  MOV     W3,[W0]
04752:  MOV     1B3A,W0
04754:  CLR     W3
04756:  BTSC    W0.F
04758:  SETM    W3
0475A:  MOV     W3,W1
0475C:  MOV     W3,W2
0475E:  CALL    12E8
04762:  MOV     W0,1B4C
04764:  MOV     W1,1B4E
04766:  MOV     W2,1B50
04768:  MOV     W3,1B52
0476A:  MOV     1B3C,W0
0476C:  CLR     W3
0476E:  BTSC    W0.F
04770:  SETM    W3
04772:  MOV     W3,W1
04774:  MOV     W3,W2
04776:  CALL    12E8
0477A:  MOV     W0,1B54
0477C:  MOV     W1,1B56
0477E:  MOV     W2,1B58
04780:  MOV     W3,1B5A
04782:  MOV     W9,1B7A
04784:  MOV     W10,1B7C
04786:  MOV     W11,1B7E
04788:  MOV     W12,1B80
0478A:  MOV     W13,1B82
0478C:  MOV     W14,1B84
0478E:  MOV     W15,1B86
04790:  MOV     [W0],[W15++]
04792:  POP     1B88
04794:  PUSH    1B4C
04796:  POP     1B8A
04798:  PUSH    1B4E
0479A:  POP     1B8C
0479C:  PUSH    1B50
0479E:  POP     1B8E
047A0:  PUSH    1B52
047A2:  POP     1B90
047A4:  PUSH    1B54
047A6:  POP     1B92
047A8:  PUSH    1B56
047AA:  POP     1B94
047AC:  PUSH    1B58
047AE:  POP     1B96
047B0:  PUSH    1B5A
047B2:  POP     1B98
047B4:  CALL    2AE8
047B8:  BCLR.B  43.0
047BA:  MOV     W5,[W15++]
047BC:  MOV     W6,[W15++]
047BE:  MOV     W7,[W15++]
047C0:  MOV     W0,W4
047C2:  MOV     W5,W0
047C4:  MOV     W1,W5
047C6:  MOV     W6,W1
047C8:  MOV     W2,W6
047CA:  MOV     W7,W2
047CC:  MOV     W3,W7
047CE:  MOV     W8,W3
047D0:  CALL    13FC
047D4:  MOV     [--W15],W7
047D6:  MOV     [--W15],W6
047D8:  MOV     [--W15],W5
047DA:  MOV     W0,W5
047DC:  MOV     W1,W6
047DE:  MOV     W2,W7
047E0:  MOV     W3,W8
047E2:  MOV     1B36,W0
047E4:  CLR     W3
047E6:  BTSC    W0.F
047E8:  SETM    W3
047EA:  MOV     W3,W1
047EC:  MOV     W3,W2
047EE:  CALL    12E8
047F2:  MOV     W0,W9
047F4:  MOV     W1,W10
047F6:  MOV     W2,W11
047F8:  MOV     W3,W12
047FA:  MOV     1B38,W0
047FC:  CLR     W3
047FE:  BTSC    W0.F
04800:  SETM    W3
04802:  MOV     W3,W1
04804:  MOV     W3,W2
04806:  CALL    12E8
0480A:  MOV     W0,W13
0480C:  MOV     W1,W14
0480E:  MOV     W2,W15
04810:  MOV     W3,[W0]
04812:  MOV     1B3E,W4
04814:  MUL.UU  W4,#2,W0
04816:  MOV     #A9E,W4
04818:  ADD     W0,W4,W0
0481A:  MOV     [W0],[W15++]
0481C:  POP     1B4C
0481E:  MOV     1B4C,W4
04820:  MUL.UU  W4,#10,W0
04822:  MOV     W0,1B4C
04824:  MOV     1B1E,W4
04826:  MUL.UU  W4,#4,W0
04828:  MOV     1B4C,W4
0482A:  ADD     W0,W4,W0
0482C:  MOV     #B72,W4
0482E:  ADD     W0,W4,W0
04830:  MOV     W0,W4
04832:  MOV     #0,W3
04834:  MOV     [W4++],[W3++]
04836:  MOV     [W4++],[W3++]
04838:  MOV     #0,W2
0483A:  MOV     #0,W3
0483C:  CALL    12E8
04840:  MOV     W0,1B4C
04842:  MOV     W1,1B4E
04844:  MOV     W2,1B50
04846:  MOV     W3,1B52
04848:  MOV     1B3E,W4
0484A:  MUL.UU  W4,#2,W0
0484C:  MOV     #A9E,W4
0484E:  ADD     W0,W4,W0
04850:  MOV     [W0],[W15++]
04852:  POP     1B54
04854:  MOV     1B54,W4
04856:  MUL.UU  W4,#10,W0
04858:  MOV     W0,1B54
0485A:  MOV     1B20,W4
0485C:  MUL.UU  W4,#4,W0
0485E:  MOV     1B54,W4
04860:  ADD     W0,W4,W0
04862:  MOV     #B72,W4
04864:  ADD     W0,W4,W0
04866:  MOV     W0,W4
04868:  MOV     #0,W3
0486A:  MOV     [W4++],[W3++]
0486C:  MOV     [W4++],[W3++]
0486E:  MOV     #0,W2
04870:  MOV     #0,W3
04872:  CALL    12E8
04876:  MOV     W0,1B54
04878:  MOV     W1,1B56
0487A:  MOV     W2,1B58
0487C:  MOV     W3,1B5A
0487E:  MOV     W9,1B7A
04880:  MOV     W10,1B7C
04882:  MOV     W11,1B7E
04884:  MOV     W12,1B80
04886:  MOV     W13,1B82
04888:  MOV     W14,1B84
0488A:  MOV     W15,1B86
0488C:  MOV     [W0],[W15++]
0488E:  POP     1B88
04890:  PUSH    1B4C
04892:  POP     1B8A
04894:  PUSH    1B4E
04896:  POP     1B8C
04898:  PUSH    1B50
0489A:  POP     1B8E
0489C:  PUSH    1B52
0489E:  POP     1B90
048A0:  PUSH    1B54
048A2:  POP     1B92
048A4:  PUSH    1B56
048A6:  POP     1B94
048A8:  PUSH    1B58
048AA:  POP     1B96
048AC:  PUSH    1B5A
048AE:  POP     1B98
048B0:  CALL    2AE8
048B4:  MOV     W0,W9
048B6:  MOV     W1,W10
048B8:  MOV     W2,W11
048BA:  MOV     W3,W12
048BC:  MOV     1B3E,W4
048BE:  MUL.UU  W4,#2,W0
048C0:  MOV     #A9E,W4
048C2:  ADD     W0,W4,W0
048C4:  MOV     [W0],W13
048C6:  MOV     W13,W4
048C8:  MUL.UU  W4,#10,W0
048CA:  MOV     W0,W13
048CC:  MOV     1B1E,W4
048CE:  MUL.UU  W4,#4,W0
048D0:  ADD     W0,W13,W0
048D2:  MOV     #B72,W4
048D4:  ADD     W0,W4,W0
048D6:  MOV     W0,W4
048D8:  MOV     #0,W3
048DA:  MOV     [W4++],[W3++]
048DC:  MOV     [W4++],[W3++]
048DE:  MOV     #0,W2
048E0:  MOV     #0,W3
048E2:  CALL    12E8
048E6:  MOV     W0,W13
048E8:  MOV     W1,W14
048EA:  MOV     W2,W15
048EC:  MOV     W3,[W0]
048EE:  MOV     1B3E,W4
048F0:  MUL.UU  W4,#2,W0
048F2:  MOV     #A9E,W4
048F4:  ADD     W0,W4,W0
048F6:  MOV     [W0],[W15++]
048F8:  POP     1B4C
048FA:  MOV     1B4C,W4
048FC:  MUL.UU  W4,#10,W0
048FE:  MOV     W0,1B4C
04900:  MOV     1B20,W4
04902:  MUL.UU  W4,#4,W0
04904:  MOV     1B4C,W4
04906:  ADD     W0,W4,W0
04908:  MOV     #B72,W4
0490A:  ADD     W0,W4,W0
0490C:  MOV     W0,W4
0490E:  MOV     #0,W3
04910:  MOV     [W4++],[W3++]
04912:  MOV     [W4++],[W3++]
04914:  MOV     #0,W2
04916:  MOV     #0,W3
04918:  CALL    12E8
0491C:  MOV     W0,1B4C
0491E:  MOV     W1,1B4E
04920:  MOV     W2,1B50
04922:  MOV     W3,1B52
04924:  MOV     1B3A,W0
04926:  CLR     W3
04928:  BTSC    W0.F
0492A:  SETM    W3
0492C:  MOV     W3,W1
0492E:  MOV     W3,W2
04930:  CALL    12E8
04934:  MOV     W0,1B54
04936:  MOV     W1,1B56
04938:  MOV     W2,1B58
0493A:  MOV     W3,1B5A
0493C:  MOV     1B3C,W0
0493E:  CLR     W3
04940:  BTSC    W0.F
04942:  SETM    W3
04944:  MOV     W3,W1
04946:  MOV     W3,W2
04948:  CALL    12E8
0494C:  MOV     W0,1B5C
0494E:  MOV     W1,1B5E
04950:  MOV     W2,1B60
04952:  MOV     W3,1B62
04954:  MOV     W13,1B7A
04956:  MOV     W14,1B7C
04958:  MOV     W15,1B7E
0495A:  MOV     [W0],[W15++]
0495C:  POP     1B80
0495E:  PUSH    1B4C
04960:  POP     1B82
04962:  PUSH    1B4E
04964:  POP     1B84
04966:  PUSH    1B50
04968:  POP     1B86
0496A:  PUSH    1B52
0496C:  POP     1B88
0496E:  PUSH    1B54
04970:  POP     1B8A
04972:  PUSH    1B56
04974:  POP     1B8C
04976:  PUSH    1B58
04978:  POP     1B8E
0497A:  PUSH    1B5A
0497C:  POP     1B90
0497E:  PUSH    1B5C
04980:  POP     1B92
04982:  PUSH    1B5E
04984:  POP     1B94
04986:  PUSH    1B60
04988:  POP     1B96
0498A:  PUSH    1B62
0498C:  POP     1B98
0498E:  CALL    2AE8
04992:  BCLR.B  43.0
04994:  MOV     W5,[W15++]
04996:  MOV     W6,[W15++]
04998:  MOV     W7,[W15++]
0499A:  MOV     W0,W4
0499C:  MOV     W1,W5
0499E:  MOV     W2,W6
049A0:  MOV     W3,W7
049A2:  MOV     W9,W0
049A4:  MOV     W10,W1
049A6:  MOV     W11,W2
049A8:  MOV     W12,W3
049AA:  CALL    13FC
049AE:  MOV     [--W15],W7
049B0:  MOV     [--W15],W6
049B2:  MOV     [--W15],W5
049B4:  MOV     W5,[W15++]
049B6:  MOV     W6,[W15++]
049B8:  MOV     W7,[W15++]
049BA:  MOV     W0,W4
049BC:  MOV     W5,W0
049BE:  MOV     W1,W5
049C0:  MOV     W6,W1
049C2:  MOV     W2,W6
049C4:  MOV     W7,W2
049C6:  MOV     W3,W7
049C8:  MOV     W8,W3
049CA:  CALL    15EA
049CE:  MOV     [--W15],W7
049D0:  MOV     [--W15],W6
049D2:  MOV     [--W15],W5
049D4:  BRA     NC,4A52
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
049D6:  MOV     A9A,W4
049D8:  MUL.UU  W4,#10,W0
049DA:  MOV     W0,W5
049DC:  MOV     #AB2,W4
049DE:  ADD     W5,W4,W6
049E0:  MOV     1B3E,W4
049E2:  MUL.UU  W4,#2,W0
049E4:  MOV     #A9E,W4
049E6:  ADD     W0,W4,W0
049E8:  MOV     [W0],W7
049EA:  MOV     W7,W4
049EC:  MUL.UU  W4,#10,W0
049EE:  MOV     W0,W7
049F0:  MOV     1B22,W4
049F2:  MUL.UU  W4,#4,W0
049F4:  ADD     W0,W7,W0
049F6:  MOV     #B72,W4
049F8:  ADD     W0,W4,W0
049FA:  MOV     W0,W4
049FC:  MOV     #0,W3
049FE:  MOV     [W4++],[W3++]
04A00:  MOV     [W4++],[W3++]
04A02:  MOV     #0,W2
04A04:  MOV     #0,W3
04A06:  CALL    12E8
04A0A:  MOV     #0,W4
04A0C:  REPEAT  #3
04A0E:  MOV     [W4++],[W6++]
04A10:  MOV     A9A,W4
04A12:  MUL.UU  W4,#10,W0
04A14:  MOV     W0,W5
04A16:  ADD     W5,#8,W0
04A18:  MOV     #AB2,W4
04A1A:  ADD     W0,W4,W5
04A1C:  MOV     1B3E,W4
04A1E:  MUL.UU  W4,#2,W0
04A20:  MOV     #A9E,W4
04A22:  ADD     W0,W4,W0
04A24:  MOV     [W0],W6
04A26:  MOV     W6,W4
04A28:  MUL.UU  W4,#10,W6
04A2A:  MOV     1B24,W4
04A2C:  MUL.UU  W4,#4,W0
04A2E:  ADD     W0,W6,W0
04A30:  MOV     #B72,W4
04A32:  ADD     W0,W4,W0
04A34:  MOV     W0,W4
04A36:  MOV     #0,W3
04A38:  MOV     [W4++],[W3++]
04A3A:  MOV     [W4++],[W3++]
04A3C:  MOV     #0,W2
04A3E:  MOV     #0,W3
04A40:  CALL    12E8
04A44:  MOV     #0,W4
04A46:  REPEAT  #3
04A48:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
04A4A:  MOV     #1,W4
04A4C:  MOV     W4,1B44
.................... 	                } 
04A4E:  GOTO    4ACA
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
04A52:  MOV     A9A,W4
04A54:  MUL.UU  W4,#10,W0
04A56:  MOV     W0,W5
04A58:  MOV     #AB2,W4
04A5A:  ADD     W5,W4,W6
04A5C:  MOV     1B3E,W4
04A5E:  MUL.UU  W4,#2,W0
04A60:  MOV     #A9E,W4
04A62:  ADD     W0,W4,W0
04A64:  MOV     [W0],W7
04A66:  MOV     W7,W4
04A68:  MUL.UU  W4,#10,W0
04A6A:  MOV     W0,W7
04A6C:  MOV     1B1E,W4
04A6E:  MUL.UU  W4,#4,W0
04A70:  ADD     W0,W7,W0
04A72:  MOV     #B72,W4
04A74:  ADD     W0,W4,W0
04A76:  MOV     W0,W4
04A78:  MOV     #0,W3
04A7A:  MOV     [W4++],[W3++]
04A7C:  MOV     [W4++],[W3++]
04A7E:  MOV     #0,W2
04A80:  MOV     #0,W3
04A82:  CALL    12E8
04A86:  MOV     #0,W4
04A88:  REPEAT  #3
04A8A:  MOV     [W4++],[W6++]
04A8C:  MOV     A9A,W4
04A8E:  MUL.UU  W4,#10,W0
04A90:  MOV     W0,W5
04A92:  ADD     W5,#8,W0
04A94:  MOV     #AB2,W4
04A96:  ADD     W0,W4,W5
04A98:  MOV     1B3E,W4
04A9A:  MUL.UU  W4,#2,W0
04A9C:  MOV     #A9E,W4
04A9E:  ADD     W0,W4,W0
04AA0:  MOV     [W0],W6
04AA2:  MOV     W6,W4
04AA4:  MUL.UU  W4,#10,W6
04AA6:  MOV     1B20,W4
04AA8:  MUL.UU  W4,#4,W0
04AAA:  ADD     W0,W6,W0
04AAC:  MOV     #B72,W4
04AAE:  ADD     W0,W4,W0
04AB0:  MOV     W0,W4
04AB2:  MOV     #0,W3
04AB4:  MOV     [W4++],[W3++]
04AB6:  MOV     [W4++],[W3++]
04AB8:  MOV     #0,W2
04ABA:  MOV     #0,W3
04ABC:  CALL    12E8
04AC0:  MOV     #0,W4
04AC2:  REPEAT  #3
04AC4:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
04AC6:  MOV     #1,W4
04AC8:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
04ACA:  MOV     #1,W4
04ACC:  MOV     W4,A96
.................... 	            } 
04ACE:  GOTO    4B54
.................... 	            else if (posEnd == 1) 
04AD2:  MOV     1B42,W4
04AD4:  CP      W4,#1
04AD6:  BRA     NZ,4B54
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
04AD8:  MOV     A9A,W4
04ADA:  MUL.UU  W4,#10,W0
04ADC:  MOV     W0,W5
04ADE:  MOV     #AB2,W4
04AE0:  ADD     W5,W4,W6
04AE2:  MOV     1B3E,W4
04AE4:  MUL.UU  W4,#2,W0
04AE6:  MOV     #A9E,W4
04AE8:  ADD     W0,W4,W0
04AEA:  MOV     [W0],W7
04AEC:  MOV     W7,W4
04AEE:  MUL.UU  W4,#10,W0
04AF0:  MOV     W0,W7
04AF2:  MOV     1B22,W4
04AF4:  MUL.UU  W4,#4,W0
04AF6:  ADD     W0,W7,W0
04AF8:  MOV     #B72,W4
04AFA:  ADD     W0,W4,W0
04AFC:  MOV     W0,W4
04AFE:  MOV     #0,W3
04B00:  MOV     [W4++],[W3++]
04B02:  MOV     [W4++],[W3++]
04B04:  MOV     #0,W2
04B06:  MOV     #0,W3
04B08:  CALL    12E8
04B0C:  MOV     #0,W4
04B0E:  REPEAT  #3
04B10:  MOV     [W4++],[W6++]
04B12:  MOV     A9A,W4
04B14:  MUL.UU  W4,#10,W0
04B16:  MOV     W0,W5
04B18:  ADD     W5,#8,W0
04B1A:  MOV     #AB2,W4
04B1C:  ADD     W0,W4,W5
04B1E:  MOV     1B3E,W4
04B20:  MUL.UU  W4,#2,W0
04B22:  MOV     #A9E,W4
04B24:  ADD     W0,W4,W0
04B26:  MOV     [W0],W6
04B28:  MOV     W6,W4
04B2A:  MUL.UU  W4,#10,W6
04B2C:  MOV     1B24,W4
04B2E:  MUL.UU  W4,#4,W0
04B30:  ADD     W0,W6,W0
04B32:  MOV     #B72,W4
04B34:  ADD     W0,W4,W0
04B36:  MOV     W0,W4
04B38:  MOV     #0,W3
04B3A:  MOV     [W4++],[W3++]
04B3C:  MOV     [W4++],[W3++]
04B3E:  MOV     #0,W2
04B40:  MOV     #0,W3
04B42:  CALL    12E8
04B46:  MOV     #0,W4
04B48:  REPEAT  #3
04B4A:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
04B4C:  MOV     #1,W4
04B4E:  MOV     W4,1B44
.................... 	                path_found = true; 
04B50:  MOV     #1,W4
04B52:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
04B54:  GOTO    5E6E
....................  
.................... 	        case 5: 
.................... 	            if (posEnd == 2 || posEnd == 3) 
04B58:  MOV     1B42,W4
04B5A:  CP      W4,#2
04B5C:  BRA     Z,4B64
04B5E:  MOV     1B42,W4
04B60:  CP      W4,#3
04B62:  BRA     NZ,4BDC
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04B64:  MOV     A9A,W4
04B66:  MUL.UU  W4,#10,W0
04B68:  MOV     W0,W5
04B6A:  MOV     #AB2,W4
04B6C:  ADD     W5,W4,W6
04B6E:  MOV     1B3E,W4
04B70:  MUL.UU  W4,#2,W0
04B72:  MOV     #A9E,W4
04B74:  ADD     W0,W4,W0
04B76:  MOV     [W0],W7
04B78:  MOV     W7,W4
04B7A:  MUL.UU  W4,#10,W0
04B7C:  MOV     W0,W7
04B7E:  ADD     W7,#8,W0
04B80:  MOV     #B72,W4
04B82:  ADD     W0,W4,W0
04B84:  MOV     W0,W4
04B86:  MOV     #0,W3
04B88:  MOV     [W4++],[W3++]
04B8A:  MOV     [W4++],[W3++]
04B8C:  MOV     #0,W2
04B8E:  MOV     #0,W3
04B90:  CALL    12E8
04B94:  MOV     #0,W4
04B96:  REPEAT  #3
04B98:  MOV     [W4++],[W6++]
04B9A:  MOV     A9A,W4
04B9C:  MUL.UU  W4,#10,W0
04B9E:  MOV     W0,W5
04BA0:  ADD     W5,#8,W0
04BA2:  MOV     #AB2,W4
04BA4:  ADD     W0,W4,W5
04BA6:  MOV     1B3E,W4
04BA8:  MUL.UU  W4,#2,W0
04BAA:  MOV     #A9E,W4
04BAC:  ADD     W0,W4,W0
04BAE:  MOV     [W0],W6
04BB0:  MOV     W6,W4
04BB2:  MUL.UU  W4,#10,W6
04BB4:  ADD     W6,#C,W0
04BB6:  MOV     #B72,W4
04BB8:  ADD     W0,W4,W0
04BBA:  MOV     W0,W4
04BBC:  MOV     #0,W3
04BBE:  MOV     [W4++],[W3++]
04BC0:  MOV     [W4++],[W3++]
04BC2:  MOV     #0,W2
04BC4:  MOV     #0,W3
04BC6:  CALL    12E8
04BCA:  MOV     #0,W4
04BCC:  REPEAT  #3
04BCE:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
04BD0:  MOV     #1,W4
04BD2:  MOV     W4,1B44
.................... 	                path_found = true; 
04BD4:  MOV     #1,W4
04BD6:  MOV     W4,A96
.................... 	            } 
04BD8:  GOTO    5208
.................... 	            else if (posEnd == 1) 
04BDC:  MOV     1B42,W4
04BDE:  CP      W4,#1
04BE0:  BRA     NZ,5182
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
04BE2:  MOV     1B36,W0
04BE4:  CLR     W3
04BE6:  BTSC    W0.F
04BE8:  SETM    W3
04BEA:  MOV     W3,W1
04BEC:  MOV     W3,W2
04BEE:  CALL    12E8
04BF2:  MOV     W0,W5
04BF4:  MOV     W1,W6
04BF6:  MOV     W2,W7
04BF8:  MOV     W3,W8
04BFA:  MOV     1B38,W0
04BFC:  CLR     W3
04BFE:  BTSC    W0.F
04C00:  SETM    W3
04C02:  MOV     W3,W1
04C04:  MOV     W3,W2
04C06:  CALL    12E8
04C0A:  MOV     W0,W9
04C0C:  MOV     W1,W10
04C0E:  MOV     W2,W11
04C10:  MOV     W3,W12
04C12:  MOV     1B3E,W4
04C14:  MUL.UU  W4,#2,W0
04C16:  MOV     #A9E,W4
04C18:  ADD     W0,W4,W0
04C1A:  MOV     [W0],W13
04C1C:  MOV     W13,W4
04C1E:  MUL.UU  W4,#10,W0
04C20:  MOV     W0,W13
04C22:  MOV     1B1E,W4
04C24:  MUL.UU  W4,#4,W0
04C26:  ADD     W0,W13,W0
04C28:  MOV     #B72,W4
04C2A:  ADD     W0,W4,W0
04C2C:  MOV     W0,W4
04C2E:  MOV     #0,W3
04C30:  MOV     [W4++],[W3++]
04C32:  MOV     [W4++],[W3++]
04C34:  MOV     #0,W2
04C36:  MOV     #0,W3
04C38:  CALL    12E8
04C3C:  MOV     W0,W13
04C3E:  MOV     W1,W14
04C40:  MOV     W2,W15
04C42:  MOV     W3,[W0]
04C44:  MOV     1B3E,W4
04C46:  MUL.UU  W4,#2,W0
04C48:  MOV     #A9E,W4
04C4A:  ADD     W0,W4,W0
04C4C:  MOV     [W0],[W15++]
04C4E:  POP     1B4C
04C50:  MOV     1B4C,W4
04C52:  MUL.UU  W4,#10,W0
04C54:  MOV     W0,1B4C
04C56:  MOV     1B20,W4
04C58:  MUL.UU  W4,#4,W0
04C5A:  MOV     1B4C,W4
04C5C:  ADD     W0,W4,W0
04C5E:  MOV     #B72,W4
04C60:  ADD     W0,W4,W0
04C62:  MOV     W0,W4
04C64:  MOV     #0,W3
04C66:  MOV     [W4++],[W3++]
04C68:  MOV     [W4++],[W3++]
04C6A:  MOV     #0,W2
04C6C:  MOV     #0,W3
04C6E:  CALL    12E8
04C72:  MOV     W0,1B4C
04C74:  MOV     W1,1B4E
04C76:  MOV     W2,1B50
04C78:  MOV     W3,1B52
04C7A:  MOV     W5,1B7A
04C7C:  MOV     W6,1B7C
04C7E:  MOV     W7,1B7E
04C80:  MOV     W8,1B80
04C82:  MOV     W9,1B82
04C84:  MOV     W10,1B84
04C86:  MOV     W11,1B86
04C88:  MOV     W12,1B88
04C8A:  MOV     W13,1B8A
04C8C:  MOV     W14,1B8C
04C8E:  MOV     W15,1B8E
04C90:  MOV     [W0],[W15++]
04C92:  POP     1B90
04C94:  PUSH    1B4C
04C96:  POP     1B92
04C98:  PUSH    1B4E
04C9A:  POP     1B94
04C9C:  PUSH    1B50
04C9E:  POP     1B96
04CA0:  PUSH    1B52
04CA2:  POP     1B98
04CA4:  CALL    2AE8
04CA8:  MOV     W0,W5
04CAA:  MOV     W1,W6
04CAC:  MOV     W2,W7
04CAE:  MOV     W3,W8
04CB0:  MOV     1B3E,W4
04CB2:  MUL.UU  W4,#2,W0
04CB4:  MOV     #A9E,W4
04CB6:  ADD     W0,W4,W0
04CB8:  MOV     [W0],W9
04CBA:  MOV     W9,W4
04CBC:  MUL.UU  W4,#10,W0
04CBE:  MOV     W0,W9
04CC0:  MOV     #B72,W4
04CC2:  ADD     W9,W4,W0
04CC4:  MOV     W0,W4
04CC6:  MOV     #0,W3
04CC8:  MOV     [W4++],[W3++]
04CCA:  MOV     [W4++],[W3++]
04CCC:  MOV     #0,W2
04CCE:  MOV     #0,W3
04CD0:  CALL    12E8
04CD4:  MOV     W0,W10
04CD6:  MOV     W1,W11
04CD8:  MOV     W2,W12
04CDA:  MOV     W3,W13
04CDC:  MOV     1B3E,W4
04CDE:  MUL.UU  W4,#2,W0
04CE0:  MOV     #A9E,W4
04CE2:  ADD     W0,W4,W0
04CE4:  MOV     [W0],[W15++]
04CE6:  POP     1B46
04CE8:  MOV     1B46,W4
04CEA:  MUL.UU  W4,#10,W0
04CEC:  MOV     W0,1B46
04CEE:  MOV     1B46,W4
04CF0:  ADD     W4,#4,W0
04CF2:  MOV     #B72,W4
04CF4:  ADD     W0,W4,W0
04CF6:  MOV     W0,W4
04CF8:  MOV     #0,W3
04CFA:  MOV     [W4++],[W3++]
04CFC:  MOV     [W4++],[W3++]
04CFE:  MOV     #0,W2
04D00:  MOV     #0,W3
04D02:  CALL    12E8
04D06:  MOV     W0,1B46
04D08:  MOV     W1,1B48
04D0A:  MOV     W2,1B4A
04D0C:  MOV     W3,1B4C
04D0E:  MOV     1B3A,W0
04D10:  CLR     W3
04D12:  BTSC    W0.F
04D14:  SETM    W3
04D16:  MOV     W3,W1
04D18:  MOV     W3,W2
04D1A:  CALL    12E8
04D1E:  MOV     W0,1B4E
04D20:  MOV     W1,1B50
04D22:  MOV     W2,1B52
04D24:  MOV     W3,1B54
04D26:  MOV     1B3C,W0
04D28:  CLR     W3
04D2A:  BTSC    W0.F
04D2C:  SETM    W3
04D2E:  MOV     W3,W1
04D30:  MOV     W3,W2
04D32:  CALL    12E8
04D36:  MOV     W0,1B56
04D38:  MOV     W1,1B58
04D3A:  MOV     W2,1B5A
04D3C:  MOV     W3,1B5C
04D3E:  MOV     W10,1B7A
04D40:  MOV     W11,1B7C
04D42:  MOV     W12,1B7E
04D44:  MOV     W13,1B80
04D46:  PUSH    1B46
04D48:  POP     1B82
04D4A:  PUSH    1B48
04D4C:  POP     1B84
04D4E:  PUSH    1B4A
04D50:  POP     1B86
04D52:  PUSH    1B4C
04D54:  POP     1B88
04D56:  PUSH    1B4E
04D58:  POP     1B8A
04D5A:  PUSH    1B50
04D5C:  POP     1B8C
04D5E:  PUSH    1B52
04D60:  POP     1B8E
04D62:  PUSH    1B54
04D64:  POP     1B90
04D66:  PUSH    1B56
04D68:  POP     1B92
04D6A:  PUSH    1B58
04D6C:  POP     1B94
04D6E:  PUSH    1B5A
04D70:  POP     1B96
04D72:  PUSH    1B5C
04D74:  POP     1B98
04D76:  CALL    2AE8
04D7A:  BCLR.B  43.0
04D7C:  MOV     W5,[W15++]
04D7E:  MOV     W6,[W15++]
04D80:  MOV     W7,[W15++]
04D82:  MOV     W0,W4
04D84:  MOV     W5,W0
04D86:  MOV     W1,W5
04D88:  MOV     W6,W1
04D8A:  MOV     W2,W6
04D8C:  MOV     W7,W2
04D8E:  MOV     W3,W7
04D90:  MOV     W8,W3
04D92:  CALL    13FC
04D96:  MOV     [--W15],W7
04D98:  MOV     [--W15],W6
04D9A:  MOV     [--W15],W5
04D9C:  MOV     W0,W5
04D9E:  MOV     W1,W6
04DA0:  MOV     W2,W7
04DA2:  MOV     W3,W8
04DA4:  MOV     1B36,W0
04DA6:  CLR     W3
04DA8:  BTSC    W0.F
04DAA:  SETM    W3
04DAC:  MOV     W3,W1
04DAE:  MOV     W3,W2
04DB0:  CALL    12E8
04DB4:  MOV     W0,W10
04DB6:  MOV     W1,W11
04DB8:  MOV     W2,W12
04DBA:  MOV     W3,W13
04DBC:  MOV     1B38,W0
04DBE:  CLR     W3
04DC0:  BTSC    W0.F
04DC2:  SETM    W3
04DC4:  MOV     W3,W1
04DC6:  MOV     W3,W2
04DC8:  CALL    12E8
04DCC:  MOV     W0,1B46
04DCE:  MOV     W1,1B48
04DD0:  MOV     W2,1B4A
04DD2:  MOV     W3,1B4C
04DD4:  MOV     1B3E,W4
04DD6:  MUL.UU  W4,#2,W0
04DD8:  MOV     #A9E,W4
04DDA:  ADD     W0,W4,W0
04DDC:  MOV     [W0],[W15++]
04DDE:  POP     1B4E
04DE0:  MOV     1B4E,W4
04DE2:  MUL.UU  W4,#10,W0
04DE4:  MOV     W0,1B4E
04DE6:  MOV     1B4E,W4
04DE8:  ADD     W4,#8,W0
04DEA:  MOV     #B72,W4
04DEC:  ADD     W0,W4,W0
04DEE:  MOV     W0,W4
04DF0:  MOV     #0,W3
04DF2:  MOV     [W4++],[W3++]
04DF4:  MOV     [W4++],[W3++]
04DF6:  MOV     #0,W2
04DF8:  MOV     #0,W3
04DFA:  CALL    12E8
04DFE:  MOV     W0,1B4E
04E00:  MOV     W1,1B50
04E02:  MOV     W2,1B52
04E04:  MOV     W3,1B54
04E06:  MOV     1B3E,W4
04E08:  MUL.UU  W4,#2,W0
04E0A:  MOV     #A9E,W4
04E0C:  ADD     W0,W4,W0
04E0E:  MOV     [W0],[W15++]
04E10:  POP     1B56
04E12:  MOV     1B56,W4
04E14:  MUL.UU  W4,#10,W0
04E16:  MOV     W0,1B56
04E18:  MOV     1B56,W4
04E1A:  ADD     W4,#C,W0
04E1C:  MOV     #B72,W4
04E1E:  ADD     W0,W4,W0
04E20:  MOV     W0,W4
04E22:  MOV     #0,W3
04E24:  MOV     [W4++],[W3++]
04E26:  MOV     [W4++],[W3++]
04E28:  MOV     #0,W2
04E2A:  MOV     #0,W3
04E2C:  CALL    12E8
04E30:  MOV     W0,1B56
04E32:  MOV     W1,1B58
04E34:  MOV     W2,1B5A
04E36:  MOV     W3,1B5C
04E38:  MOV     W10,1B7A
04E3A:  MOV     W11,1B7C
04E3C:  MOV     W12,1B7E
04E3E:  MOV     W13,1B80
04E40:  PUSH    1B46
04E42:  POP     1B82
04E44:  PUSH    1B48
04E46:  POP     1B84
04E48:  PUSH    1B4A
04E4A:  POP     1B86
04E4C:  PUSH    1B4C
04E4E:  POP     1B88
04E50:  PUSH    1B4E
04E52:  POP     1B8A
04E54:  PUSH    1B50
04E56:  POP     1B8C
04E58:  PUSH    1B52
04E5A:  POP     1B8E
04E5C:  PUSH    1B54
04E5E:  POP     1B90
04E60:  PUSH    1B56
04E62:  POP     1B92
04E64:  PUSH    1B58
04E66:  POP     1B94
04E68:  PUSH    1B5A
04E6A:  POP     1B96
04E6C:  PUSH    1B5C
04E6E:  POP     1B98
04E70:  CALL    2AE8
04E74:  MOV     W0,W10
04E76:  MOV     W1,W11
04E78:  MOV     W2,W12
04E7A:  MOV     W3,W13
04E7C:  MOV     1B3E,W4
04E7E:  MUL.UU  W4,#2,W0
04E80:  MOV     #A9E,W4
04E82:  ADD     W0,W4,W0
04E84:  MOV     [W0],[W15++]
04E86:  POP     1B46
04E88:  MOV     1B46,W4
04E8A:  MUL.UU  W4,#10,W0
04E8C:  MOV     W0,1B46
04E8E:  MOV     1B22,W4
04E90:  MUL.UU  W4,#4,W0
04E92:  MOV     1B46,W4
04E94:  ADD     W0,W4,W0
04E96:  MOV     #B72,W4
04E98:  ADD     W0,W4,W0
04E9A:  MOV     W0,W4
04E9C:  MOV     #0,W3
04E9E:  MOV     [W4++],[W3++]
04EA0:  MOV     [W4++],[W3++]
04EA2:  MOV     #0,W2
04EA4:  MOV     #0,W3
04EA6:  CALL    12E8
04EAA:  MOV     W0,1B46
04EAC:  MOV     W1,1B48
04EAE:  MOV     W2,1B4A
04EB0:  MOV     W3,1B4C
04EB2:  MOV     1B3E,W4
04EB4:  MUL.UU  W4,#2,W0
04EB6:  MOV     #A9E,W4
04EB8:  ADD     W0,W4,W0
04EBA:  MOV     [W0],[W15++]
04EBC:  POP     1B4E
04EBE:  MOV     1B4E,W4
04EC0:  MUL.UU  W4,#10,W0
04EC2:  MOV     W0,1B4E
04EC4:  MOV     1B24,W4
04EC6:  MUL.UU  W4,#4,W0
04EC8:  MOV     1B4E,W4
04ECA:  ADD     W0,W4,W0
04ECC:  MOV     #B72,W4
04ECE:  ADD     W0,W4,W0
04ED0:  MOV     W0,W4
04ED2:  MOV     #0,W3
04ED4:  MOV     [W4++],[W3++]
04ED6:  MOV     [W4++],[W3++]
04ED8:  MOV     #0,W2
04EDA:  MOV     #0,W3
04EDC:  CALL    12E8
04EE0:  MOV     W0,1B4E
04EE2:  MOV     W1,1B50
04EE4:  MOV     W2,1B52
04EE6:  MOV     W3,1B54
04EE8:  MOV     1B3A,W0
04EEA:  CLR     W3
04EEC:  BTSC    W0.F
04EEE:  SETM    W3
04EF0:  MOV     W3,W1
04EF2:  MOV     W3,W2
04EF4:  CALL    12E8
04EF8:  MOV     W0,1B56
04EFA:  MOV     W1,1B58
04EFC:  MOV     W2,1B5A
04EFE:  MOV     W3,1B5C
04F00:  MOV     1B3C,W0
04F02:  CLR     W3
04F04:  BTSC    W0.F
04F06:  SETM    W3
04F08:  MOV     W3,W1
04F0A:  MOV     W3,W2
04F0C:  CALL    12E8
04F10:  MOV     W0,1B5E
04F12:  MOV     W1,1B60
04F14:  MOV     W2,1B62
04F16:  MOV     W3,1B64
04F18:  PUSH    1B46
04F1A:  POP     1B7A
04F1C:  PUSH    1B48
04F1E:  POP     1B7C
04F20:  PUSH    1B4A
04F22:  POP     1B7E
04F24:  PUSH    1B4C
04F26:  POP     1B80
04F28:  PUSH    1B4E
04F2A:  POP     1B82
04F2C:  PUSH    1B50
04F2E:  POP     1B84
04F30:  PUSH    1B52
04F32:  POP     1B86
04F34:  PUSH    1B54
04F36:  POP     1B88
04F38:  PUSH    1B56
04F3A:  POP     1B8A
04F3C:  PUSH    1B58
04F3E:  POP     1B8C
04F40:  PUSH    1B5A
04F42:  POP     1B8E
04F44:  PUSH    1B5C
04F46:  POP     1B90
04F48:  PUSH    1B5E
04F4A:  POP     1B92
04F4C:  PUSH    1B60
04F4E:  POP     1B94
04F50:  PUSH    1B62
04F52:  POP     1B96
04F54:  PUSH    1B64
04F56:  POP     1B98
04F58:  CALL    2AE8
04F5C:  BCLR.B  43.0
04F5E:  MOV     W5,[W15++]
04F60:  MOV     W6,[W15++]
04F62:  MOV     W7,[W15++]
04F64:  MOV     W0,W4
04F66:  MOV     W1,W5
04F68:  MOV     W2,W6
04F6A:  MOV     W3,W7
04F6C:  MOV     W10,W0
04F6E:  MOV     W11,W1
04F70:  MOV     W12,W2
04F72:  MOV     W13,W3
04F74:  CALL    13FC
04F78:  MOV     [--W15],W7
04F7A:  MOV     [--W15],W6
04F7C:  MOV     [--W15],W5
04F7E:  MOV     W5,[W15++]
04F80:  MOV     W6,[W15++]
04F82:  MOV     W7,[W15++]
04F84:  MOV     W0,W4
04F86:  MOV     W5,W0
04F88:  MOV     W1,W5
04F8A:  MOV     W6,W1
04F8C:  MOV     W2,W6
04F8E:  MOV     W7,W2
04F90:  MOV     W3,W7
04F92:  MOV     W8,W3
04F94:  CALL    15EA
04F98:  MOV     [--W15],W7
04F9A:  MOV     [--W15],W6
04F9C:  MOV     [--W15],W5
04F9E:  BRA     NC,508E
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3];  
04FA0:  MOV     A9A,W4
04FA2:  MUL.UU  W4,#10,W0
04FA4:  MOV     W0,W5
04FA6:  MOV     #AB2,W4
04FA8:  ADD     W5,W4,W6
04FAA:  MOV     1B3E,W4
04FAC:  MUL.UU  W4,#2,W0
04FAE:  MOV     #A9E,W4
04FB0:  ADD     W0,W4,W0
04FB2:  MOV     [W0],W7
04FB4:  MOV     W7,W4
04FB6:  MUL.UU  W4,#10,W0
04FB8:  MOV     W0,W7
04FBA:  MOV     1B1E,W4
04FBC:  MUL.UU  W4,#4,W0
04FBE:  ADD     W0,W7,W0
04FC0:  MOV     #B72,W4
04FC2:  ADD     W0,W4,W0
04FC4:  MOV     W0,W4
04FC6:  MOV     #0,W3
04FC8:  MOV     [W4++],[W3++]
04FCA:  MOV     [W4++],[W3++]
04FCC:  MOV     #0,W2
04FCE:  MOV     #0,W3
04FD0:  CALL    12E8
04FD4:  MOV     #0,W4
04FD6:  REPEAT  #3
04FD8:  MOV     [W4++],[W6++]
04FDA:  MOV     A9A,W4
04FDC:  ADD     W4,#1,W5
04FDE:  MOV     W5,W4
04FE0:  MUL.UU  W4,#10,W0
04FE2:  MOV     W0,W5
04FE4:  ADD     W5,#8,W0
04FE6:  MOV     #AB2,W4
04FE8:  ADD     W0,W4,W5
04FEA:  MOV     1B3E,W4
04FEC:  MUL.UU  W4,#2,W0
04FEE:  MOV     #A9E,W4
04FF0:  ADD     W0,W4,W0
04FF2:  MOV     [W0],W6
04FF4:  MOV     W6,W4
04FF6:  MUL.UU  W4,#10,W6
04FF8:  MOV     1B20,W4
04FFA:  MUL.UU  W4,#4,W0
04FFC:  ADD     W0,W6,W0
04FFE:  MOV     #B72,W4
05000:  ADD     W0,W4,W0
05002:  MOV     W0,W4
05004:  MOV     #0,W3
05006:  MOV     [W4++],[W3++]
05008:  MOV     [W4++],[W3++]
0500A:  MOV     #0,W2
0500C:  MOV     #0,W3
0500E:  CALL    12E8
05012:  MOV     #0,W4
05014:  REPEAT  #3
05016:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05018:  MOV     A9A,W4
0501A:  ADD     W4,#1,W5
0501C:  MOV     W5,W4
0501E:  MUL.UU  W4,#10,W0
05020:  MOV     W0,W5
05022:  MOV     #AB2,W4
05024:  ADD     W5,W4,W6
05026:  MOV     1B3E,W4
05028:  MUL.UU  W4,#2,W0
0502A:  MOV     #A9E,W4
0502C:  ADD     W0,W4,W0
0502E:  MOV     [W0],W7
05030:  MOV     W7,W4
05032:  MUL.UU  W4,#10,W0
05034:  MOV     W0,W7
05036:  MOV     #B72,W4
05038:  ADD     W7,W4,W0
0503A:  MOV     W0,W4
0503C:  MOV     #0,W3
0503E:  MOV     [W4++],[W3++]
05040:  MOV     [W4++],[W3++]
05042:  MOV     #0,W2
05044:  MOV     #0,W3
05046:  CALL    12E8
0504A:  MOV     #0,W4
0504C:  REPEAT  #3
0504E:  MOV     [W4++],[W6++]
05050:  MOV     A9A,W4
05052:  MUL.UU  W4,#10,W0
05054:  MOV     W0,W5
05056:  ADD     W5,#8,W0
05058:  MOV     #AB2,W4
0505A:  ADD     W0,W4,W5
0505C:  MOV     1B3E,W4
0505E:  MUL.UU  W4,#2,W0
05060:  MOV     #A9E,W4
05062:  ADD     W0,W4,W0
05064:  MOV     [W0],W6
05066:  MOV     W6,W4
05068:  MUL.UU  W4,#10,W6
0506A:  ADD     W6,#4,W0
0506C:  MOV     #B72,W4
0506E:  ADD     W0,W4,W0
05070:  MOV     W0,W4
05072:  MOV     #0,W3
05074:  MOV     [W4++],[W3++]
05076:  MOV     [W4++],[W3++]
05078:  MOV     #0,W2
0507A:  MOV     #0,W3
0507C:  CALL    12E8
05080:  MOV     #0,W4
05082:  REPEAT  #3
05084:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
05086:  MOV     #2,W4
05088:  MOV     W4,1B44
.................... 	                } 
0508A:  GOTO    517A
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y4]; 
0508E:  MOV     A9A,W4
05090:  MUL.UU  W4,#10,W0
05092:  MOV     W0,W5
05094:  MOV     #AB2,W4
05096:  ADD     W5,W4,W6
05098:  MOV     1B3E,W4
0509A:  MUL.UU  W4,#2,W0
0509C:  MOV     #A9E,W4
0509E:  ADD     W0,W4,W0
050A0:  MOV     [W0],W7
050A2:  MOV     W7,W4
050A4:  MUL.UU  W4,#10,W0
050A6:  MOV     W0,W7
050A8:  ADD     W7,#8,W0
050AA:  MOV     #B72,W4
050AC:  ADD     W0,W4,W0
050AE:  MOV     W0,W4
050B0:  MOV     #0,W3
050B2:  MOV     [W4++],[W3++]
050B4:  MOV     [W4++],[W3++]
050B6:  MOV     #0,W2
050B8:  MOV     #0,W3
050BA:  CALL    12E8
050BE:  MOV     #0,W4
050C0:  REPEAT  #3
050C2:  MOV     [W4++],[W6++]
050C4:  MOV     A9A,W4
050C6:  ADD     W4,#1,W5
050C8:  MOV     W5,W4
050CA:  MUL.UU  W4,#10,W0
050CC:  MOV     W0,W5
050CE:  ADD     W5,#8,W0
050D0:  MOV     #AB2,W4
050D2:  ADD     W0,W4,W5
050D4:  MOV     1B3E,W4
050D6:  MUL.UU  W4,#2,W0
050D8:  MOV     #A9E,W4
050DA:  ADD     W0,W4,W0
050DC:  MOV     [W0],W6
050DE:  MOV     W6,W4
050E0:  MUL.UU  W4,#10,W6
050E2:  ADD     W6,#C,W0
050E4:  MOV     #B72,W4
050E6:  ADD     W0,W4,W0
050E8:  MOV     W0,W4
050EA:  MOV     #0,W3
050EC:  MOV     [W4++],[W3++]
050EE:  MOV     [W4++],[W3++]
050F0:  MOV     #0,W2
050F2:  MOV     #0,W3
050F4:  CALL    12E8
050F8:  MOV     #0,W4
050FA:  REPEAT  #3
050FC:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2];  
050FE:  MOV     A9A,W4
05100:  ADD     W4,#1,W5
05102:  MOV     W5,W4
05104:  MUL.UU  W4,#10,W0
05106:  MOV     W0,W5
05108:  MOV     #AB2,W4
0510A:  ADD     W5,W4,W6
0510C:  MOV     1B3E,W4
0510E:  MUL.UU  W4,#2,W0
05110:  MOV     #A9E,W4
05112:  ADD     W0,W4,W0
05114:  MOV     [W0],W7
05116:  MOV     W7,W4
05118:  MUL.UU  W4,#10,W0
0511A:  MOV     W0,W7
0511C:  MOV     1B22,W4
0511E:  MUL.UU  W4,#4,W0
05120:  ADD     W0,W7,W0
05122:  MOV     #B72,W4
05124:  ADD     W0,W4,W0
05126:  MOV     W0,W4
05128:  MOV     #0,W3
0512A:  MOV     [W4++],[W3++]
0512C:  MOV     [W4++],[W3++]
0512E:  MOV     #0,W2
05130:  MOV     #0,W3
05132:  CALL    12E8
05136:  MOV     #0,W4
05138:  REPEAT  #3
0513A:  MOV     [W4++],[W6++]
0513C:  MOV     A9A,W4
0513E:  MUL.UU  W4,#10,W0
05140:  MOV     W0,W5
05142:  ADD     W5,#8,W0
05144:  MOV     #AB2,W4
05146:  ADD     W0,W4,W5
05148:  MOV     1B3E,W4
0514A:  MUL.UU  W4,#2,W0
0514C:  MOV     #A9E,W4
0514E:  ADD     W0,W4,W0
05150:  MOV     [W0],W6
05152:  MOV     W6,W4
05154:  MUL.UU  W4,#10,W6
05156:  MOV     1B24,W4
05158:  MUL.UU  W4,#4,W0
0515A:  ADD     W0,W6,W0
0515C:  MOV     #B72,W4
0515E:  ADD     W0,W4,W0
05160:  MOV     W0,W4
05162:  MOV     #0,W3
05164:  MOV     [W4++],[W3++]
05166:  MOV     [W4++],[W3++]
05168:  MOV     #0,W2
0516A:  MOV     #0,W3
0516C:  CALL    12E8
05170:  MOV     #0,W4
05172:  REPEAT  #3
05174:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
05176:  MOV     #2,W4
05178:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
0517A:  MOV     #1,W4
0517C:  MOV     W4,A96
.................... 	            } 
0517E:  GOTO    5208
.................... 	            else if (posEnd == 7 || posEnd == 0) 
05182:  MOV     1B42,W4
05184:  CP      W4,#7
05186:  BRA     Z,518C
05188:  CP0     1B42
0518A:  BRA     NZ,5208
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
0518C:  MOV     A9A,W4
0518E:  MUL.UU  W4,#10,W0
05190:  MOV     W0,W5
05192:  MOV     #AB2,W4
05194:  ADD     W5,W4,W6
05196:  MOV     1B3E,W4
05198:  MUL.UU  W4,#2,W0
0519A:  MOV     #A9E,W4
0519C:  ADD     W0,W4,W0
0519E:  MOV     [W0],W7
051A0:  MOV     W7,W4
051A2:  MUL.UU  W4,#10,W0
051A4:  MOV     W0,W7
051A6:  MOV     1B1E,W4
051A8:  MUL.UU  W4,#4,W0
051AA:  ADD     W0,W7,W0
051AC:  MOV     #B72,W4
051AE:  ADD     W0,W4,W0
051B0:  MOV     W0,W4
051B2:  MOV     #0,W3
051B4:  MOV     [W4++],[W3++]
051B6:  MOV     [W4++],[W3++]
051B8:  MOV     #0,W2
051BA:  MOV     #0,W3
051BC:  CALL    12E8
051C0:  MOV     #0,W4
051C2:  REPEAT  #3
051C4:  MOV     [W4++],[W6++]
051C6:  MOV     A9A,W4
051C8:  MUL.UU  W4,#10,W0
051CA:  MOV     W0,W5
051CC:  ADD     W5,#8,W0
051CE:  MOV     #AB2,W4
051D0:  ADD     W0,W4,W5
051D2:  MOV     1B3E,W4
051D4:  MUL.UU  W4,#2,W0
051D6:  MOV     #A9E,W4
051D8:  ADD     W0,W4,W0
051DA:  MOV     [W0],W6
051DC:  MOV     W6,W4
051DE:  MUL.UU  W4,#10,W6
051E0:  MOV     1B20,W4
051E2:  MUL.UU  W4,#4,W0
051E4:  ADD     W0,W6,W0
051E6:  MOV     #B72,W4
051E8:  ADD     W0,W4,W0
051EA:  MOV     W0,W4
051EC:  MOV     #0,W3
051EE:  MOV     [W4++],[W3++]
051F0:  MOV     [W4++],[W3++]
051F2:  MOV     #0,W2
051F4:  MOV     #0,W3
051F6:  CALL    12E8
051FA:  MOV     #0,W4
051FC:  REPEAT  #3
051FE:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05200:  MOV     #1,W4
05202:  MOV     W4,1B44
.................... 	                path_found = true; 
05204:  MOV     #1,W4
05206:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
05208:  GOTO    5E6E
....................  
.................... 	        case 6: 
.................... 	            if (posEnd == 3) 
0520C:  MOV     1B42,W4
0520E:  CP      W4,#3
05210:  BRA     NZ,528A
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
05212:  MOV     A9A,W4
05214:  MUL.UU  W4,#10,W0
05216:  MOV     W0,W5
05218:  MOV     #AB2,W4
0521A:  ADD     W5,W4,W6
0521C:  MOV     1B3E,W4
0521E:  MUL.UU  W4,#2,W0
05220:  MOV     #A9E,W4
05222:  ADD     W0,W4,W0
05224:  MOV     [W0],W7
05226:  MOV     W7,W4
05228:  MUL.UU  W4,#10,W0
0522A:  MOV     W0,W7
0522C:  ADD     W7,#8,W0
0522E:  MOV     #B72,W4
05230:  ADD     W0,W4,W0
05232:  MOV     W0,W4
05234:  MOV     #0,W3
05236:  MOV     [W4++],[W3++]
05238:  MOV     [W4++],[W3++]
0523A:  MOV     #0,W2
0523C:  MOV     #0,W3
0523E:  CALL    12E8
05242:  MOV     #0,W4
05244:  REPEAT  #3
05246:  MOV     [W4++],[W6++]
05248:  MOV     A9A,W4
0524A:  MUL.UU  W4,#10,W0
0524C:  MOV     W0,W5
0524E:  ADD     W5,#8,W0
05250:  MOV     #AB2,W4
05252:  ADD     W0,W4,W5
05254:  MOV     1B3E,W4
05256:  MUL.UU  W4,#2,W0
05258:  MOV     #A9E,W4
0525A:  ADD     W0,W4,W0
0525C:  MOV     [W0],W6
0525E:  MOV     W6,W4
05260:  MUL.UU  W4,#10,W6
05262:  ADD     W6,#C,W0
05264:  MOV     #B72,W4
05266:  ADD     W0,W4,W0
05268:  MOV     W0,W4
0526A:  MOV     #0,W3
0526C:  MOV     [W4++],[W3++]
0526E:  MOV     [W4++],[W3++]
05270:  MOV     #0,W2
05272:  MOV     #0,W3
05274:  CALL    12E8
05278:  MOV     #0,W4
0527A:  REPEAT  #3
0527C:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0527E:  MOV     #1,W4
05280:  MOV     W4,1B44
.................... 	                path_found = true; 
05282:  MOV     #1,W4
05284:  MOV     W4,A96
.................... 	            } 
05286:  GOTO    57A4
.................... 	            else if (posEnd == 2) 
0528A:  MOV     1B42,W4
0528C:  CP      W4,#2
0528E:  BRA     NZ,572C
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
05290:  MOV     1B36,W0
05292:  CLR     W3
05294:  BTSC    W0.F
05296:  SETM    W3
05298:  MOV     W3,W1
0529A:  MOV     W3,W2
0529C:  CALL    12E8
052A0:  MOV     W0,W5
052A2:  MOV     W1,W6
052A4:  MOV     W2,W7
052A6:  MOV     W3,W8
052A8:  MOV     1B38,W0
052AA:  CLR     W3
052AC:  BTSC    W0.F
052AE:  SETM    W3
052B0:  MOV     W3,W1
052B2:  MOV     W3,W2
052B4:  CALL    12E8
052B8:  MOV     W0,W9
052BA:  MOV     W1,W10
052BC:  MOV     W2,W11
052BE:  MOV     W3,W12
052C0:  MOV     1B3E,W4
052C2:  MUL.UU  W4,#2,W0
052C4:  MOV     #A9E,W4
052C6:  ADD     W0,W4,W0
052C8:  MOV     [W0],W13
052CA:  MOV     W13,W4
052CC:  MUL.UU  W4,#10,W0
052CE:  MOV     W0,W13
052D0:  MOV     #B72,W4
052D2:  ADD     W13,W4,W0
052D4:  MOV     W0,W4
052D6:  MOV     #0,W3
052D8:  MOV     [W4++],[W3++]
052DA:  MOV     [W4++],[W3++]
052DC:  MOV     #0,W2
052DE:  MOV     #0,W3
052E0:  CALL    12E8
052E4:  MOV     W0,1B46
052E6:  MOV     W1,1B48
052E8:  MOV     W2,1B4A
052EA:  MOV     W3,1B4C
052EC:  MOV     1B3E,W4
052EE:  MUL.UU  W4,#2,W0
052F0:  MOV     #A9E,W4
052F2:  ADD     W0,W4,W0
052F4:  MOV     [W0],[W15++]
052F6:  POP     1B4E
052F8:  MOV     1B4E,W4
052FA:  MUL.UU  W4,#10,W0
052FC:  MOV     W0,1B4E
052FE:  MOV     1B4E,W4
05300:  ADD     W4,#4,W0
05302:  MOV     #B72,W4
05304:  ADD     W0,W4,W0
05306:  MOV     W0,W4
05308:  MOV     #0,W3
0530A:  MOV     [W4++],[W3++]
0530C:  MOV     [W4++],[W3++]
0530E:  MOV     #0,W2
05310:  MOV     #0,W3
05312:  CALL    12E8
05316:  MOV     W0,1B4E
05318:  MOV     W1,1B50
0531A:  MOV     W2,1B52
0531C:  MOV     W3,1B54
0531E:  MOV     W5,1B7A
05320:  MOV     W6,1B7C
05322:  MOV     W7,1B7E
05324:  MOV     W8,1B80
05326:  MOV     W9,1B82
05328:  MOV     W10,1B84
0532A:  MOV     W11,1B86
0532C:  MOV     W12,1B88
0532E:  PUSH    1B46
05330:  POP     1B8A
05332:  PUSH    1B48
05334:  POP     1B8C
05336:  PUSH    1B4A
05338:  POP     1B8E
0533A:  PUSH    1B4C
0533C:  POP     1B90
0533E:  PUSH    1B4E
05340:  POP     1B92
05342:  PUSH    1B50
05344:  POP     1B94
05346:  PUSH    1B52
05348:  POP     1B96
0534A:  PUSH    1B54
0534C:  POP     1B98
0534E:  CALL    2AE8
05352:  MOV     W0,W5
05354:  MOV     W1,W6
05356:  MOV     W2,W7
05358:  MOV     W3,W8
0535A:  MOV     1B3E,W4
0535C:  MUL.UU  W4,#2,W0
0535E:  MOV     #A9E,W4
05360:  ADD     W0,W4,W0
05362:  MOV     [W0],W9
05364:  MOV     W9,W4
05366:  MUL.UU  W4,#10,W0
05368:  MOV     W0,W9
0536A:  MOV     #B72,W4
0536C:  ADD     W9,W4,W0
0536E:  MOV     W0,W4
05370:  MOV     #0,W3
05372:  MOV     [W4++],[W3++]
05374:  MOV     [W4++],[W3++]
05376:  MOV     #0,W2
05378:  MOV     #0,W3
0537A:  CALL    12E8
0537E:  MOV     W0,W10
05380:  MOV     W1,W11
05382:  MOV     W2,W12
05384:  MOV     W3,W13
05386:  MOV     1B3E,W4
05388:  MUL.UU  W4,#2,W0
0538A:  MOV     #A9E,W4
0538C:  ADD     W0,W4,W0
0538E:  MOV     [W0],[W15++]
05390:  POP     1B46
05392:  MOV     1B46,W4
05394:  MUL.UU  W4,#10,W0
05396:  MOV     W0,1B46
05398:  MOV     1B46,W4
0539A:  ADD     W4,#4,W0
0539C:  MOV     #B72,W4
0539E:  ADD     W0,W4,W0
053A0:  MOV     W0,W4
053A2:  MOV     #0,W3
053A4:  MOV     [W4++],[W3++]
053A6:  MOV     [W4++],[W3++]
053A8:  MOV     #0,W2
053AA:  MOV     #0,W3
053AC:  CALL    12E8
053B0:  MOV     W0,1B46
053B2:  MOV     W1,1B48
053B4:  MOV     W2,1B4A
053B6:  MOV     W3,1B4C
053B8:  MOV     1B3A,W0
053BA:  CLR     W3
053BC:  BTSC    W0.F
053BE:  SETM    W3
053C0:  MOV     W3,W1
053C2:  MOV     W3,W2
053C4:  CALL    12E8
053C8:  MOV     W0,1B4E
053CA:  MOV     W1,1B50
053CC:  MOV     W2,1B52
053CE:  MOV     W3,1B54
053D0:  MOV     1B3C,W0
053D2:  CLR     W3
053D4:  BTSC    W0.F
053D6:  SETM    W3
053D8:  MOV     W3,W1
053DA:  MOV     W3,W2
053DC:  CALL    12E8
053E0:  MOV     W0,1B56
053E2:  MOV     W1,1B58
053E4:  MOV     W2,1B5A
053E6:  MOV     W3,1B5C
053E8:  MOV     W10,1B7A
053EA:  MOV     W11,1B7C
053EC:  MOV     W12,1B7E
053EE:  MOV     W13,1B80
053F0:  PUSH    1B46
053F2:  POP     1B82
053F4:  PUSH    1B48
053F6:  POP     1B84
053F8:  PUSH    1B4A
053FA:  POP     1B86
053FC:  PUSH    1B4C
053FE:  POP     1B88
05400:  PUSH    1B4E
05402:  POP     1B8A
05404:  PUSH    1B50
05406:  POP     1B8C
05408:  PUSH    1B52
0540A:  POP     1B8E
0540C:  PUSH    1B54
0540E:  POP     1B90
05410:  PUSH    1B56
05412:  POP     1B92
05414:  PUSH    1B58
05416:  POP     1B94
05418:  PUSH    1B5A
0541A:  POP     1B96
0541C:  PUSH    1B5C
0541E:  POP     1B98
05420:  CALL    2AE8
05424:  BCLR.B  43.0
05426:  MOV     W5,[W15++]
05428:  MOV     W6,[W15++]
0542A:  MOV     W7,[W15++]
0542C:  MOV     W0,W4
0542E:  MOV     W5,W0
05430:  MOV     W1,W5
05432:  MOV     W6,W1
05434:  MOV     W2,W6
05436:  MOV     W7,W2
05438:  MOV     W3,W7
0543A:  MOV     W8,W3
0543C:  CALL    13FC
05440:  MOV     [--W15],W7
05442:  MOV     [--W15],W6
05444:  MOV     [--W15],W5
05446:  MOV     W0,W5
05448:  MOV     W1,W6
0544A:  MOV     W2,W7
0544C:  MOV     W3,W8
0544E:  MOV     1B36,W0
05450:  CLR     W3
05452:  BTSC    W0.F
05454:  SETM    W3
05456:  MOV     W3,W1
05458:  MOV     W3,W2
0545A:  CALL    12E8
0545E:  MOV     W0,W10
05460:  MOV     W1,W11
05462:  MOV     W2,W12
05464:  MOV     W3,W13
05466:  MOV     1B38,W0
05468:  CLR     W3
0546A:  BTSC    W0.F
0546C:  SETM    W3
0546E:  MOV     W3,W1
05470:  MOV     W3,W2
05472:  CALL    12E8
05476:  MOV     W0,1B46
05478:  MOV     W1,1B48
0547A:  MOV     W2,1B4A
0547C:  MOV     W3,1B4C
0547E:  MOV     1B3E,W4
05480:  MUL.UU  W4,#2,W0
05482:  MOV     #A9E,W4
05484:  ADD     W0,W4,W0
05486:  MOV     [W0],[W15++]
05488:  POP     1B4E
0548A:  MOV     1B4E,W4
0548C:  MUL.UU  W4,#10,W0
0548E:  MOV     W0,1B4E
05490:  MOV     1B4E,W4
05492:  ADD     W4,#8,W0
05494:  MOV     #B72,W4
05496:  ADD     W0,W4,W0
05498:  MOV     W0,W4
0549A:  MOV     #0,W3
0549C:  MOV     [W4++],[W3++]
0549E:  MOV     [W4++],[W3++]
054A0:  MOV     #0,W2
054A2:  MOV     #0,W3
054A4:  CALL    12E8
054A8:  MOV     W0,1B4E
054AA:  MOV     W1,1B50
054AC:  MOV     W2,1B52
054AE:  MOV     W3,1B54
054B0:  MOV     1B3E,W4
054B2:  MUL.UU  W4,#2,W0
054B4:  MOV     #A9E,W4
054B6:  ADD     W0,W4,W0
054B8:  MOV     [W0],[W15++]
054BA:  POP     1B56
054BC:  MOV     1B56,W4
054BE:  MUL.UU  W4,#10,W0
054C0:  MOV     W0,1B56
054C2:  MOV     1B56,W4
054C4:  ADD     W4,#C,W0
054C6:  MOV     #B72,W4
054C8:  ADD     W0,W4,W0
054CA:  MOV     W0,W4
054CC:  MOV     #0,W3
054CE:  MOV     [W4++],[W3++]
054D0:  MOV     [W4++],[W3++]
054D2:  MOV     #0,W2
054D4:  MOV     #0,W3
054D6:  CALL    12E8
054DA:  MOV     W0,1B56
054DC:  MOV     W1,1B58
054DE:  MOV     W2,1B5A
054E0:  MOV     W3,1B5C
054E2:  MOV     W10,1B7A
054E4:  MOV     W11,1B7C
054E6:  MOV     W12,1B7E
054E8:  MOV     W13,1B80
054EA:  PUSH    1B46
054EC:  POP     1B82
054EE:  PUSH    1B48
054F0:  POP     1B84
054F2:  PUSH    1B4A
054F4:  POP     1B86
054F6:  PUSH    1B4C
054F8:  POP     1B88
054FA:  PUSH    1B4E
054FC:  POP     1B8A
054FE:  PUSH    1B50
05500:  POP     1B8C
05502:  PUSH    1B52
05504:  POP     1B8E
05506:  PUSH    1B54
05508:  POP     1B90
0550A:  PUSH    1B56
0550C:  POP     1B92
0550E:  PUSH    1B58
05510:  POP     1B94
05512:  PUSH    1B5A
05514:  POP     1B96
05516:  PUSH    1B5C
05518:  POP     1B98
0551A:  CALL    2AE8
0551E:  MOV     W0,W10
05520:  MOV     W1,W11
05522:  MOV     W2,W12
05524:  MOV     W3,W13
05526:  MOV     1B3E,W4
05528:  MUL.UU  W4,#2,W0
0552A:  MOV     #A9E,W4
0552C:  ADD     W0,W4,W0
0552E:  MOV     [W0],[W15++]
05530:  POP     1B46
05532:  MOV     1B46,W4
05534:  MUL.UU  W4,#10,W0
05536:  MOV     W0,1B46
05538:  MOV     1B46,W4
0553A:  ADD     W4,#8,W0
0553C:  MOV     #B72,W4
0553E:  ADD     W0,W4,W0
05540:  MOV     W0,W4
05542:  MOV     #0,W3
05544:  MOV     [W4++],[W3++]
05546:  MOV     [W4++],[W3++]
05548:  MOV     #0,W2
0554A:  MOV     #0,W3
0554C:  CALL    12E8
05550:  MOV     W0,1B46
05552:  MOV     W1,1B48
05554:  MOV     W2,1B4A
05556:  MOV     W3,1B4C
05558:  MOV     1B3E,W4
0555A:  MUL.UU  W4,#2,W0
0555C:  MOV     #A9E,W4
0555E:  ADD     W0,W4,W0
05560:  MOV     [W0],[W15++]
05562:  POP     1B4E
05564:  MOV     1B4E,W4
05566:  MUL.UU  W4,#10,W0
05568:  MOV     W0,1B4E
0556A:  MOV     1B4E,W4
0556C:  ADD     W4,#C,W0
0556E:  MOV     #B72,W4
05570:  ADD     W0,W4,W0
05572:  MOV     W0,W4
05574:  MOV     #0,W3
05576:  MOV     [W4++],[W3++]
05578:  MOV     [W4++],[W3++]
0557A:  MOV     #0,W2
0557C:  MOV     #0,W3
0557E:  CALL    12E8
05582:  MOV     W0,1B4E
05584:  MOV     W1,1B50
05586:  MOV     W2,1B52
05588:  MOV     W3,1B54
0558A:  MOV     1B3A,W0
0558C:  CLR     W3
0558E:  BTSC    W0.F
05590:  SETM    W3
05592:  MOV     W3,W1
05594:  MOV     W3,W2
05596:  CALL    12E8
0559A:  MOV     W0,1B56
0559C:  MOV     W1,1B58
0559E:  MOV     W2,1B5A
055A0:  MOV     W3,1B5C
055A2:  MOV     1B3C,W0
055A4:  CLR     W3
055A6:  BTSC    W0.F
055A8:  SETM    W3
055AA:  MOV     W3,W1
055AC:  MOV     W3,W2
055AE:  CALL    12E8
055B2:  MOV     W0,1B5E
055B4:  MOV     W1,1B60
055B6:  MOV     W2,1B62
055B8:  MOV     W3,1B64
055BA:  PUSH    1B46
055BC:  POP     1B7A
055BE:  PUSH    1B48
055C0:  POP     1B7C
055C2:  PUSH    1B4A
055C4:  POP     1B7E
055C6:  PUSH    1B4C
055C8:  POP     1B80
055CA:  PUSH    1B4E
055CC:  POP     1B82
055CE:  PUSH    1B50
055D0:  POP     1B84
055D2:  PUSH    1B52
055D4:  POP     1B86
055D6:  PUSH    1B54
055D8:  POP     1B88
055DA:  PUSH    1B56
055DC:  POP     1B8A
055DE:  PUSH    1B58
055E0:  POP     1B8C
055E2:  PUSH    1B5A
055E4:  POP     1B8E
055E6:  PUSH    1B5C
055E8:  POP     1B90
055EA:  PUSH    1B5E
055EC:  POP     1B92
055EE:  PUSH    1B60
055F0:  POP     1B94
055F2:  PUSH    1B62
055F4:  POP     1B96
055F6:  PUSH    1B64
055F8:  POP     1B98
055FA:  CALL    2AE8
055FE:  BCLR.B  43.0
05600:  MOV     W5,[W15++]
05602:  MOV     W6,[W15++]
05604:  MOV     W7,[W15++]
05606:  MOV     W0,W4
05608:  MOV     W1,W5
0560A:  MOV     W2,W6
0560C:  MOV     W3,W7
0560E:  MOV     W10,W0
05610:  MOV     W11,W1
05612:  MOV     W12,W2
05614:  MOV     W13,W3
05616:  CALL    13FC
0561A:  MOV     [--W15],W7
0561C:  MOV     [--W15],W6
0561E:  MOV     [--W15],W5
05620:  MOV     W5,[W15++]
05622:  MOV     W6,[W15++]
05624:  MOV     W7,[W15++]
05626:  MOV     W0,W4
05628:  MOV     W5,W0
0562A:  MOV     W1,W5
0562C:  MOV     W6,W1
0562E:  MOV     W2,W6
05630:  MOV     W7,W2
05632:  MOV     W3,W7
05634:  MOV     W8,W3
05636:  CALL    15EA
0563A:  MOV     [--W15],W7
0563C:  MOV     [--W15],W6
0563E:  MOV     [--W15],W5
05640:  BRA     NC,56B4
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05642:  MOV     A9A,W4
05644:  MUL.UU  W4,#10,W0
05646:  MOV     W0,W5
05648:  MOV     #AB2,W4
0564A:  ADD     W5,W4,W6
0564C:  MOV     1B3E,W4
0564E:  MUL.UU  W4,#2,W0
05650:  MOV     #A9E,W4
05652:  ADD     W0,W4,W0
05654:  MOV     [W0],W7
05656:  MOV     W7,W4
05658:  MUL.UU  W4,#10,W0
0565A:  MOV     W0,W7
0565C:  MOV     #B72,W4
0565E:  ADD     W7,W4,W0
05660:  MOV     W0,W4
05662:  MOV     #0,W3
05664:  MOV     [W4++],[W3++]
05666:  MOV     [W4++],[W3++]
05668:  MOV     #0,W2
0566A:  MOV     #0,W3
0566C:  CALL    12E8
05670:  MOV     #0,W4
05672:  REPEAT  #3
05674:  MOV     [W4++],[W6++]
05676:  MOV     A9A,W4
05678:  MUL.UU  W4,#10,W0
0567A:  MOV     W0,W5
0567C:  ADD     W5,#8,W0
0567E:  MOV     #AB2,W4
05680:  ADD     W0,W4,W5
05682:  MOV     1B3E,W4
05684:  MUL.UU  W4,#2,W0
05686:  MOV     #A9E,W4
05688:  ADD     W0,W4,W0
0568A:  MOV     [W0],W6
0568C:  MOV     W6,W4
0568E:  MUL.UU  W4,#10,W6
05690:  ADD     W6,#4,W0
05692:  MOV     #B72,W4
05694:  ADD     W0,W4,W0
05696:  MOV     W0,W4
05698:  MOV     #0,W3
0569A:  MOV     [W4++],[W3++]
0569C:  MOV     [W4++],[W3++]
0569E:  MOV     #0,W2
056A0:  MOV     #0,W3
056A2:  CALL    12E8
056A6:  MOV     #0,W4
056A8:  REPEAT  #3
056AA:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
056AC:  MOV     #1,W4
056AE:  MOV     W4,1B44
.................... 	                } 
056B0:  GOTO    5724
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
056B4:  MOV     A9A,W4
056B6:  MUL.UU  W4,#10,W0
056B8:  MOV     W0,W5
056BA:  MOV     #AB2,W4
056BC:  ADD     W5,W4,W6
056BE:  MOV     1B3E,W4
056C0:  MUL.UU  W4,#2,W0
056C2:  MOV     #A9E,W4
056C4:  ADD     W0,W4,W0
056C6:  MOV     [W0],W7
056C8:  MOV     W7,W4
056CA:  MUL.UU  W4,#10,W0
056CC:  MOV     W0,W7
056CE:  ADD     W7,#8,W0
056D0:  MOV     #B72,W4
056D2:  ADD     W0,W4,W0
056D4:  MOV     W0,W4
056D6:  MOV     #0,W3
056D8:  MOV     [W4++],[W3++]
056DA:  MOV     [W4++],[W3++]
056DC:  MOV     #0,W2
056DE:  MOV     #0,W3
056E0:  CALL    12E8
056E4:  MOV     #0,W4
056E6:  REPEAT  #3
056E8:  MOV     [W4++],[W6++]
056EA:  MOV     A9A,W4
056EC:  MUL.UU  W4,#10,W0
056EE:  MOV     W0,W5
056F0:  ADD     W5,#8,W0
056F2:  MOV     #AB2,W4
056F4:  ADD     W0,W4,W5
056F6:  MOV     1B3E,W4
056F8:  MUL.UU  W4,#2,W0
056FA:  MOV     #A9E,W4
056FC:  ADD     W0,W4,W0
056FE:  MOV     [W0],W6
05700:  MOV     W6,W4
05702:  MUL.UU  W4,#10,W6
05704:  ADD     W6,#C,W0
05706:  MOV     #B72,W4
05708:  ADD     W0,W4,W0
0570A:  MOV     W0,W4
0570C:  MOV     #0,W3
0570E:  MOV     [W4++],[W3++]
05710:  MOV     [W4++],[W3++]
05712:  MOV     #0,W2
05714:  MOV     #0,W3
05716:  CALL    12E8
0571A:  MOV     #0,W4
0571C:  REPEAT  #3
0571E:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
05720:  MOV     #1,W4
05722:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
05724:  MOV     #1,W4
05726:  MOV     W4,A96
.................... 	            } 
05728:  GOTO    57A4
.................... 	            else if (posEnd == 1) 
0572C:  MOV     1B42,W4
0572E:  CP      W4,#1
05730:  BRA     NZ,57A4
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05732:  MOV     A9A,W4
05734:  MUL.UU  W4,#10,W0
05736:  MOV     W0,W5
05738:  MOV     #AB2,W4
0573A:  ADD     W5,W4,W6
0573C:  MOV     1B3E,W4
0573E:  MUL.UU  W4,#2,W0
05740:  MOV     #A9E,W4
05742:  ADD     W0,W4,W0
05744:  MOV     [W0],W7
05746:  MOV     W7,W4
05748:  MUL.UU  W4,#10,W0
0574A:  MOV     W0,W7
0574C:  MOV     #B72,W4
0574E:  ADD     W7,W4,W0
05750:  MOV     W0,W4
05752:  MOV     #0,W3
05754:  MOV     [W4++],[W3++]
05756:  MOV     [W4++],[W3++]
05758:  MOV     #0,W2
0575A:  MOV     #0,W3
0575C:  CALL    12E8
05760:  MOV     #0,W4
05762:  REPEAT  #3
05764:  MOV     [W4++],[W6++]
05766:  MOV     A9A,W4
05768:  MUL.UU  W4,#10,W0
0576A:  MOV     W0,W5
0576C:  ADD     W5,#8,W0
0576E:  MOV     #AB2,W4
05770:  ADD     W0,W4,W5
05772:  MOV     1B3E,W4
05774:  MUL.UU  W4,#2,W0
05776:  MOV     #A9E,W4
05778:  ADD     W0,W4,W0
0577A:  MOV     [W0],W6
0577C:  MOV     W6,W4
0577E:  MUL.UU  W4,#10,W6
05780:  ADD     W6,#4,W0
05782:  MOV     #B72,W4
05784:  ADD     W0,W4,W0
05786:  MOV     W0,W4
05788:  MOV     #0,W3
0578A:  MOV     [W4++],[W3++]
0578C:  MOV     [W4++],[W3++]
0578E:  MOV     #0,W2
05790:  MOV     #0,W3
05792:  CALL    12E8
05796:  MOV     #0,W4
05798:  REPEAT  #3
0579A:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0579C:  MOV     #1,W4
0579E:  MOV     W4,1B44
.................... 	                path_found = true; 
057A0:  MOV     #1,W4
057A2:  MOV     W4,A96
.................... 	            } 
....................  
.................... 	            break; 
057A4:  GOTO    5E6E
....................  
.................... 	        case 7: 
.................... 	            if (posEnd == 5 || posEnd == 4) 
057A8:  MOV     1B42,W4
057AA:  CP      W4,#5
057AC:  BRA     Z,57B4
057AE:  MOV     1B42,W4
057B0:  CP      W4,#4
057B2:  BRA     NZ,5834
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
057B4:  MOV     A9A,W4
057B6:  MUL.UU  W4,#10,W0
057B8:  MOV     W0,W5
057BA:  MOV     #AB2,W4
057BC:  ADD     W5,W4,W6
057BE:  MOV     1B3E,W4
057C0:  MUL.UU  W4,#2,W0
057C2:  MOV     #A9E,W4
057C4:  ADD     W0,W4,W0
057C6:  MOV     [W0],W7
057C8:  MOV     W7,W4
057CA:  MUL.UU  W4,#10,W0
057CC:  MOV     W0,W7
057CE:  MOV     1B1E,W4
057D0:  MUL.UU  W4,#4,W0
057D2:  ADD     W0,W7,W0
057D4:  MOV     #B72,W4
057D6:  ADD     W0,W4,W0
057D8:  MOV     W0,W4
057DA:  MOV     #0,W3
057DC:  MOV     [W4++],[W3++]
057DE:  MOV     [W4++],[W3++]
057E0:  MOV     #0,W2
057E2:  MOV     #0,W3
057E4:  CALL    12E8
057E8:  MOV     #0,W4
057EA:  REPEAT  #3
057EC:  MOV     [W4++],[W6++]
057EE:  MOV     A9A,W4
057F0:  MUL.UU  W4,#10,W0
057F2:  MOV     W0,W5
057F4:  ADD     W5,#8,W0
057F6:  MOV     #AB2,W4
057F8:  ADD     W0,W4,W5
057FA:  MOV     1B3E,W4
057FC:  MUL.UU  W4,#2,W0
057FE:  MOV     #A9E,W4
05800:  ADD     W0,W4,W0
05802:  MOV     [W0],W6
05804:  MOV     W6,W4
05806:  MUL.UU  W4,#10,W6
05808:  MOV     1B20,W4
0580A:  MUL.UU  W4,#4,W0
0580C:  ADD     W0,W6,W0
0580E:  MOV     #B72,W4
05810:  ADD     W0,W4,W0
05812:  MOV     W0,W4
05814:  MOV     #0,W3
05816:  MOV     [W4++],[W3++]
05818:  MOV     [W4++],[W3++]
0581A:  MOV     #0,W2
0581C:  MOV     #0,W3
0581E:  CALL    12E8
05822:  MOV     #0,W4
05824:  REPEAT  #3
05826:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05828:  MOV     #1,W4
0582A:  MOV     W4,1B44
.................... 	                path_found = true; 
0582C:  MOV     #1,W4
0582E:  MOV     W4,A96
.................... 	            } 
05830:  GOTO    5E5E
.................... 	            else if (posEnd == 3) 
05834:  MOV     1B42,W4
05836:  CP      W4,#3
05838:  BRA     NZ,5DE0
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
0583A:  MOV     1B36,W0
0583C:  CLR     W3
0583E:  BTSC    W0.F
05840:  SETM    W3
05842:  MOV     W3,W1
05844:  MOV     W3,W2
05846:  CALL    12E8
0584A:  MOV     W0,W5
0584C:  MOV     W1,W6
0584E:  MOV     W2,W7
05850:  MOV     W3,W8
05852:  MOV     1B38,W0
05854:  CLR     W3
05856:  BTSC    W0.F
05858:  SETM    W3
0585A:  MOV     W3,W1
0585C:  MOV     W3,W2
0585E:  CALL    12E8
05862:  MOV     W0,W9
05864:  MOV     W1,W10
05866:  MOV     W2,W11
05868:  MOV     W3,W12
0586A:  MOV     1B3E,W4
0586C:  MUL.UU  W4,#2,W0
0586E:  MOV     #A9E,W4
05870:  ADD     W0,W4,W0
05872:  MOV     [W0],W13
05874:  MOV     W13,W4
05876:  MUL.UU  W4,#10,W0
05878:  MOV     W0,W13
0587A:  MOV     #B72,W4
0587C:  ADD     W13,W4,W0
0587E:  MOV     W0,W4
05880:  MOV     #0,W3
05882:  MOV     [W4++],[W3++]
05884:  MOV     [W4++],[W3++]
05886:  MOV     #0,W2
05888:  MOV     #0,W3
0588A:  CALL    12E8
0588E:  MOV     W0,1B46
05890:  MOV     W1,1B48
05892:  MOV     W2,1B4A
05894:  MOV     W3,1B4C
05896:  MOV     1B3E,W4
05898:  MUL.UU  W4,#2,W0
0589A:  MOV     #A9E,W4
0589C:  ADD     W0,W4,W0
0589E:  MOV     [W0],[W15++]
058A0:  POP     1B4E
058A2:  MOV     1B4E,W4
058A4:  MUL.UU  W4,#10,W0
058A6:  MOV     W0,1B4E
058A8:  MOV     1B4E,W4
058AA:  ADD     W4,#4,W0
058AC:  MOV     #B72,W4
058AE:  ADD     W0,W4,W0
058B0:  MOV     W0,W4
058B2:  MOV     #0,W3
058B4:  MOV     [W4++],[W3++]
058B6:  MOV     [W4++],[W3++]
058B8:  MOV     #0,W2
058BA:  MOV     #0,W3
058BC:  CALL    12E8
058C0:  MOV     W0,1B4E
058C2:  MOV     W1,1B50
058C4:  MOV     W2,1B52
058C6:  MOV     W3,1B54
058C8:  MOV     W5,1B7A
058CA:  MOV     W6,1B7C
058CC:  MOV     W7,1B7E
058CE:  MOV     W8,1B80
058D0:  MOV     W9,1B82
058D2:  MOV     W10,1B84
058D4:  MOV     W11,1B86
058D6:  MOV     W12,1B88
058D8:  PUSH    1B46
058DA:  POP     1B8A
058DC:  PUSH    1B48
058DE:  POP     1B8C
058E0:  PUSH    1B4A
058E2:  POP     1B8E
058E4:  PUSH    1B4C
058E6:  POP     1B90
058E8:  PUSH    1B4E
058EA:  POP     1B92
058EC:  PUSH    1B50
058EE:  POP     1B94
058F0:  PUSH    1B52
058F2:  POP     1B96
058F4:  PUSH    1B54
058F6:  POP     1B98
058F8:  CALL    2AE8
058FC:  MOV     W0,W5
058FE:  MOV     W1,W6
05900:  MOV     W2,W7
05902:  MOV     W3,W8
05904:  MOV     1B3E,W4
05906:  MUL.UU  W4,#2,W0
05908:  MOV     #A9E,W4
0590A:  ADD     W0,W4,W0
0590C:  MOV     [W0],W9
0590E:  MOV     W9,W4
05910:  MUL.UU  W4,#10,W0
05912:  MOV     W0,W9
05914:  MOV     1B22,W4
05916:  MUL.UU  W4,#4,W0
05918:  ADD     W0,W9,W0
0591A:  MOV     #B72,W4
0591C:  ADD     W0,W4,W0
0591E:  MOV     W0,W4
05920:  MOV     #0,W3
05922:  MOV     [W4++],[W3++]
05924:  MOV     [W4++],[W3++]
05926:  MOV     #0,W2
05928:  MOV     #0,W3
0592A:  CALL    12E8
0592E:  MOV     W0,W9
05930:  MOV     W1,W10
05932:  MOV     W2,W11
05934:  MOV     W3,W12
05936:  MOV     1B3E,W4
05938:  MUL.UU  W4,#2,W0
0593A:  MOV     #A9E,W4
0593C:  ADD     W0,W4,W0
0593E:  MOV     [W0],[W15++]
05940:  POP     1B46
05942:  MOV     1B46,W4
05944:  MUL.UU  W4,#10,W0
05946:  MOV     W0,1B46
05948:  MOV     1B24,W4
0594A:  MUL.UU  W4,#4,W0
0594C:  MOV     1B46,W4
0594E:  ADD     W0,W4,W0
05950:  MOV     #B72,W4
05952:  ADD     W0,W4,W0
05954:  MOV     W0,W4
05956:  MOV     #0,W3
05958:  MOV     [W4++],[W3++]
0595A:  MOV     [W4++],[W3++]
0595C:  MOV     #0,W2
0595E:  MOV     #0,W3
05960:  CALL    12E8
05964:  MOV     W0,1B46
05966:  MOV     W1,1B48
05968:  MOV     W2,1B4A
0596A:  MOV     W3,1B4C
0596C:  MOV     1B3A,W0
0596E:  CLR     W3
05970:  BTSC    W0.F
05972:  SETM    W3
05974:  MOV     W3,W1
05976:  MOV     W3,W2
05978:  CALL    12E8
0597C:  MOV     W0,1B4E
0597E:  MOV     W1,1B50
05980:  MOV     W2,1B52
05982:  MOV     W3,1B54
05984:  MOV     1B3C,W0
05986:  CLR     W3
05988:  BTSC    W0.F
0598A:  SETM    W3
0598C:  MOV     W3,W1
0598E:  MOV     W3,W2
05990:  CALL    12E8
05994:  MOV     W0,1B56
05996:  MOV     W1,1B58
05998:  MOV     W2,1B5A
0599A:  MOV     W3,1B5C
0599C:  MOV     W9,1B7A
0599E:  MOV     W10,1B7C
059A0:  MOV     W11,1B7E
059A2:  MOV     W12,1B80
059A4:  PUSH    1B46
059A6:  POP     1B82
059A8:  PUSH    1B48
059AA:  POP     1B84
059AC:  PUSH    1B4A
059AE:  POP     1B86
059B0:  PUSH    1B4C
059B2:  POP     1B88
059B4:  PUSH    1B4E
059B6:  POP     1B8A
059B8:  PUSH    1B50
059BA:  POP     1B8C
059BC:  PUSH    1B52
059BE:  POP     1B8E
059C0:  PUSH    1B54
059C2:  POP     1B90
059C4:  PUSH    1B56
059C6:  POP     1B92
059C8:  PUSH    1B58
059CA:  POP     1B94
059CC:  PUSH    1B5A
059CE:  POP     1B96
059D0:  PUSH    1B5C
059D2:  POP     1B98
059D4:  CALL    2AE8
059D8:  BCLR.B  43.0
059DA:  MOV     W5,[W15++]
059DC:  MOV     W6,[W15++]
059DE:  MOV     W7,[W15++]
059E0:  MOV     W0,W4
059E2:  MOV     W5,W0
059E4:  MOV     W1,W5
059E6:  MOV     W6,W1
059E8:  MOV     W2,W6
059EA:  MOV     W7,W2
059EC:  MOV     W3,W7
059EE:  MOV     W8,W3
059F0:  CALL    13FC
059F4:  MOV     [--W15],W7
059F6:  MOV     [--W15],W6
059F8:  MOV     [--W15],W5
059FA:  MOV     W0,W5
059FC:  MOV     W1,W6
059FE:  MOV     W2,W7
05A00:  MOV     W3,W8
05A02:  MOV     1B36,W0
05A04:  CLR     W3
05A06:  BTSC    W0.F
05A08:  SETM    W3
05A0A:  MOV     W3,W1
05A0C:  MOV     W3,W2
05A0E:  CALL    12E8
05A12:  MOV     W0,W9
05A14:  MOV     W1,W10
05A16:  MOV     W2,W11
05A18:  MOV     W3,W12
05A1A:  MOV     1B38,W0
05A1C:  CLR     W3
05A1E:  BTSC    W0.F
05A20:  SETM    W3
05A22:  MOV     W3,W1
05A24:  MOV     W3,W2
05A26:  CALL    12E8
05A2A:  MOV     W0,1B46
05A2C:  MOV     W1,1B48
05A2E:  MOV     W2,1B4A
05A30:  MOV     W3,1B4C
05A32:  MOV     1B3E,W4
05A34:  MUL.UU  W4,#2,W0
05A36:  MOV     #A9E,W4
05A38:  ADD     W0,W4,W0
05A3A:  MOV     [W0],[W15++]
05A3C:  POP     1B4E
05A3E:  MOV     1B4E,W4
05A40:  MUL.UU  W4,#10,W0
05A42:  MOV     W0,1B4E
05A44:  MOV     1B1E,W4
05A46:  MUL.UU  W4,#4,W0
05A48:  MOV     1B4E,W4
05A4A:  ADD     W0,W4,W0
05A4C:  MOV     #B72,W4
05A4E:  ADD     W0,W4,W0
05A50:  MOV     W0,W4
05A52:  MOV     #0,W3
05A54:  MOV     [W4++],[W3++]
05A56:  MOV     [W4++],[W3++]
05A58:  MOV     #0,W2
05A5A:  MOV     #0,W3
05A5C:  CALL    12E8
05A60:  MOV     W0,1B4E
05A62:  MOV     W1,1B50
05A64:  MOV     W2,1B52
05A66:  MOV     W3,1B54
05A68:  MOV     1B3E,W4
05A6A:  MUL.UU  W4,#2,W0
05A6C:  MOV     #A9E,W4
05A6E:  ADD     W0,W4,W0
05A70:  MOV     [W0],[W15++]
05A72:  POP     1B56
05A74:  MOV     1B56,W4
05A76:  MUL.UU  W4,#10,W0
05A78:  MOV     W0,1B56
05A7A:  MOV     1B20,W4
05A7C:  MUL.UU  W4,#4,W0
05A7E:  MOV     1B56,W4
05A80:  ADD     W0,W4,W0
05A82:  MOV     #B72,W4
05A84:  ADD     W0,W4,W0
05A86:  MOV     W0,W4
05A88:  MOV     #0,W3
05A8A:  MOV     [W4++],[W3++]
05A8C:  MOV     [W4++],[W3++]
05A8E:  MOV     #0,W2
05A90:  MOV     #0,W3
05A92:  CALL    12E8
05A96:  MOV     W0,1B56
05A98:  MOV     W1,1B58
05A9A:  MOV     W2,1B5A
05A9C:  MOV     W3,1B5C
05A9E:  MOV     W9,1B7A
05AA0:  MOV     W10,1B7C
05AA2:  MOV     W11,1B7E
05AA4:  MOV     W12,1B80
05AA6:  PUSH    1B46
05AA8:  POP     1B82
05AAA:  PUSH    1B48
05AAC:  POP     1B84
05AAE:  PUSH    1B4A
05AB0:  POP     1B86
05AB2:  PUSH    1B4C
05AB4:  POP     1B88
05AB6:  PUSH    1B4E
05AB8:  POP     1B8A
05ABA:  PUSH    1B50
05ABC:  POP     1B8C
05ABE:  PUSH    1B52
05AC0:  POP     1B8E
05AC2:  PUSH    1B54
05AC4:  POP     1B90
05AC6:  PUSH    1B56
05AC8:  POP     1B92
05ACA:  PUSH    1B58
05ACC:  POP     1B94
05ACE:  PUSH    1B5A
05AD0:  POP     1B96
05AD2:  PUSH    1B5C
05AD4:  POP     1B98
05AD6:  CALL    2AE8
05ADA:  MOV     W0,W9
05ADC:  MOV     W1,W10
05ADE:  MOV     W2,W11
05AE0:  MOV     W3,W12
05AE2:  MOV     1B3E,W4
05AE4:  MUL.UU  W4,#2,W0
05AE6:  MOV     #A9E,W4
05AE8:  ADD     W0,W4,W0
05AEA:  MOV     [W0],[W15++]
05AEC:  POP     1B46
05AEE:  MOV     1B46,W4
05AF0:  MUL.UU  W4,#10,W0
05AF2:  MOV     W0,1B46
05AF4:  MOV     1B46,W4
05AF6:  ADD     W4,#8,W0
05AF8:  MOV     #B72,W4
05AFA:  ADD     W0,W4,W0
05AFC:  MOV     W0,W4
05AFE:  MOV     #0,W3
05B00:  MOV     [W4++],[W3++]
05B02:  MOV     [W4++],[W3++]
05B04:  MOV     #0,W2
05B06:  MOV     #0,W3
05B08:  CALL    12E8
05B0C:  MOV     W0,1B46
05B0E:  MOV     W1,1B48
05B10:  MOV     W2,1B4A
05B12:  MOV     W3,1B4C
05B14:  MOV     1B3E,W4
05B16:  MUL.UU  W4,#2,W0
05B18:  MOV     #A9E,W4
05B1A:  ADD     W0,W4,W0
05B1C:  MOV     [W0],[W15++]
05B1E:  POP     1B4E
05B20:  MOV     1B4E,W4
05B22:  MUL.UU  W4,#10,W0
05B24:  MOV     W0,1B4E
05B26:  MOV     1B4E,W4
05B28:  ADD     W4,#C,W0
05B2A:  MOV     #B72,W4
05B2C:  ADD     W0,W4,W0
05B2E:  MOV     W0,W4
05B30:  MOV     #0,W3
05B32:  MOV     [W4++],[W3++]
05B34:  MOV     [W4++],[W3++]
05B36:  MOV     #0,W2
05B38:  MOV     #0,W3
05B3A:  CALL    12E8
05B3E:  MOV     W0,1B4E
05B40:  MOV     W1,1B50
05B42:  MOV     W2,1B52
05B44:  MOV     W3,1B54
05B46:  MOV     1B3A,W0
05B48:  CLR     W3
05B4A:  BTSC    W0.F
05B4C:  SETM    W3
05B4E:  MOV     W3,W1
05B50:  MOV     W3,W2
05B52:  CALL    12E8
05B56:  MOV     W0,1B56
05B58:  MOV     W1,1B58
05B5A:  MOV     W2,1B5A
05B5C:  MOV     W3,1B5C
05B5E:  MOV     1B3C,W0
05B60:  CLR     W3
05B62:  BTSC    W0.F
05B64:  SETM    W3
05B66:  MOV     W3,W1
05B68:  MOV     W3,W2
05B6A:  CALL    12E8
05B6E:  MOV     W0,1B5E
05B70:  MOV     W1,1B60
05B72:  MOV     W2,1B62
05B74:  MOV     W3,1B64
05B76:  PUSH    1B46
05B78:  POP     1B7A
05B7A:  PUSH    1B48
05B7C:  POP     1B7C
05B7E:  PUSH    1B4A
05B80:  POP     1B7E
05B82:  PUSH    1B4C
05B84:  POP     1B80
05B86:  PUSH    1B4E
05B88:  POP     1B82
05B8A:  PUSH    1B50
05B8C:  POP     1B84
05B8E:  PUSH    1B52
05B90:  POP     1B86
05B92:  PUSH    1B54
05B94:  POP     1B88
05B96:  PUSH    1B56
05B98:  POP     1B8A
05B9A:  PUSH    1B58
05B9C:  POP     1B8C
05B9E:  PUSH    1B5A
05BA0:  POP     1B8E
05BA2:  PUSH    1B5C
05BA4:  POP     1B90
05BA6:  PUSH    1B5E
05BA8:  POP     1B92
05BAA:  PUSH    1B60
05BAC:  POP     1B94
05BAE:  PUSH    1B62
05BB0:  POP     1B96
05BB2:  PUSH    1B64
05BB4:  POP     1B98
05BB6:  CALL    2AE8
05BBA:  BCLR.B  43.0
05BBC:  MOV     W5,[W15++]
05BBE:  MOV     W6,[W15++]
05BC0:  MOV     W7,[W15++]
05BC2:  MOV     W0,W4
05BC4:  MOV     W1,W5
05BC6:  MOV     W2,W6
05BC8:  MOV     W3,W7
05BCA:  MOV     W9,W0
05BCC:  MOV     W10,W1
05BCE:  MOV     W11,W2
05BD0:  MOV     W12,W3
05BD2:  CALL    13FC
05BD6:  MOV     [--W15],W7
05BD8:  MOV     [--W15],W6
05BDA:  MOV     [--W15],W5
05BDC:  MOV     W5,[W15++]
05BDE:  MOV     W6,[W15++]
05BE0:  MOV     W7,[W15++]
05BE2:  MOV     W0,W4
05BE4:  MOV     W5,W0
05BE6:  MOV     W1,W5
05BE8:  MOV     W6,W1
05BEA:  MOV     W2,W6
05BEC:  MOV     W7,W2
05BEE:  MOV     W3,W7
05BF0:  MOV     W8,W3
05BF2:  CALL    15EA
05BF6:  MOV     [--W15],W7
05BF8:  MOV     [--W15],W6
05BFA:  MOV     [--W15],W5
05BFC:  BRA     NC,5CEC
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y1]; 
05BFE:  MOV     A9A,W4
05C00:  MUL.UU  W4,#10,W0
05C02:  MOV     W0,W5
05C04:  MOV     #AB2,W4
05C06:  ADD     W5,W4,W6
05C08:  MOV     1B3E,W4
05C0A:  MUL.UU  W4,#2,W0
05C0C:  MOV     #A9E,W4
05C0E:  ADD     W0,W4,W0
05C10:  MOV     [W0],W7
05C12:  MOV     W7,W4
05C14:  MUL.UU  W4,#10,W0
05C16:  MOV     W0,W7
05C18:  MOV     #B72,W4
05C1A:  ADD     W7,W4,W0
05C1C:  MOV     W0,W4
05C1E:  MOV     #0,W3
05C20:  MOV     [W4++],[W3++]
05C22:  MOV     [W4++],[W3++]
05C24:  MOV     #0,W2
05C26:  MOV     #0,W3
05C28:  CALL    12E8
05C2C:  MOV     #0,W4
05C2E:  REPEAT  #3
05C30:  MOV     [W4++],[W6++]
05C32:  MOV     A9A,W4
05C34:  ADD     W4,#1,W5
05C36:  MOV     W5,W4
05C38:  MUL.UU  W4,#10,W0
05C3A:  MOV     W0,W5
05C3C:  ADD     W5,#8,W0
05C3E:  MOV     #AB2,W4
05C40:  ADD     W0,W4,W5
05C42:  MOV     1B3E,W4
05C44:  MUL.UU  W4,#2,W0
05C46:  MOV     #A9E,W4
05C48:  ADD     W0,W4,W0
05C4A:  MOV     [W0],W6
05C4C:  MOV     W6,W4
05C4E:  MUL.UU  W4,#10,W6
05C50:  ADD     W6,#4,W0
05C52:  MOV     #B72,W4
05C54:  ADD     W0,W4,W0
05C56:  MOV     W0,W4
05C58:  MOV     #0,W3
05C5A:  MOV     [W4++],[W3++]
05C5C:  MOV     [W4++],[W3++]
05C5E:  MOV     #0,W2
05C60:  MOV     #0,W3
05C62:  CALL    12E8
05C66:  MOV     #0,W4
05C68:  REPEAT  #3
05C6A:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
05C6C:  MOV     A9A,W4
05C6E:  ADD     W4,#1,W5
05C70:  MOV     W5,W4
05C72:  MUL.UU  W4,#10,W0
05C74:  MOV     W0,W5
05C76:  MOV     #AB2,W4
05C78:  ADD     W5,W4,W6
05C7A:  MOV     1B3E,W4
05C7C:  MUL.UU  W4,#2,W0
05C7E:  MOV     #A9E,W4
05C80:  ADD     W0,W4,W0
05C82:  MOV     [W0],W7
05C84:  MOV     W7,W4
05C86:  MUL.UU  W4,#10,W0
05C88:  MOV     W0,W7
05C8A:  MOV     1B22,W4
05C8C:  MUL.UU  W4,#4,W0
05C8E:  ADD     W0,W7,W0
05C90:  MOV     #B72,W4
05C92:  ADD     W0,W4,W0
05C94:  MOV     W0,W4
05C96:  MOV     #0,W3
05C98:  MOV     [W4++],[W3++]
05C9A:  MOV     [W4++],[W3++]
05C9C:  MOV     #0,W2
05C9E:  MOV     #0,W3
05CA0:  CALL    12E8
05CA4:  MOV     #0,W4
05CA6:  REPEAT  #3
05CA8:  MOV     [W4++],[W6++]
05CAA:  MOV     A9A,W4
05CAC:  MUL.UU  W4,#10,W0
05CAE:  MOV     W0,W5
05CB0:  ADD     W5,#8,W0
05CB2:  MOV     #AB2,W4
05CB4:  ADD     W0,W4,W5
05CB6:  MOV     1B3E,W4
05CB8:  MUL.UU  W4,#2,W0
05CBA:  MOV     #A9E,W4
05CBC:  ADD     W0,W4,W0
05CBE:  MOV     [W0],W6
05CC0:  MOV     W6,W4
05CC2:  MUL.UU  W4,#10,W6
05CC4:  MOV     1B24,W4
05CC6:  MUL.UU  W4,#4,W0
05CC8:  ADD     W0,W6,W0
05CCA:  MOV     #B72,W4
05CCC:  ADD     W0,W4,W0
05CCE:  MOV     W0,W4
05CD0:  MOV     #0,W3
05CD2:  MOV     [W4++],[W3++]
05CD4:  MOV     [W4++],[W3++]
05CD6:  MOV     #0,W2
05CD8:  MOV     #0,W3
05CDA:  CALL    12E8
05CDE:  MOV     #0,W4
05CE0:  REPEAT  #3
05CE2:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
05CE4:  MOV     #2,W4
05CE6:  MOV     W4,1B44
.................... 	                } 
05CE8:  GOTO    5DD8
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3]; 
05CEC:  MOV     A9A,W4
05CEE:  MUL.UU  W4,#10,W0
05CF0:  MOV     W0,W5
05CF2:  MOV     #AB2,W4
05CF4:  ADD     W5,W4,W6
05CF6:  MOV     1B3E,W4
05CF8:  MUL.UU  W4,#2,W0
05CFA:  MOV     #A9E,W4
05CFC:  ADD     W0,W4,W0
05CFE:  MOV     [W0],W7
05D00:  MOV     W7,W4
05D02:  MUL.UU  W4,#10,W0
05D04:  MOV     W0,W7
05D06:  MOV     1B1E,W4
05D08:  MUL.UU  W4,#4,W0
05D0A:  ADD     W0,W7,W0
05D0C:  MOV     #B72,W4
05D0E:  ADD     W0,W4,W0
05D10:  MOV     W0,W4
05D12:  MOV     #0,W3
05D14:  MOV     [W4++],[W3++]
05D16:  MOV     [W4++],[W3++]
05D18:  MOV     #0,W2
05D1A:  MOV     #0,W3
05D1C:  CALL    12E8
05D20:  MOV     #0,W4
05D22:  REPEAT  #3
05D24:  MOV     [W4++],[W6++]
05D26:  MOV     A9A,W4
05D28:  ADD     W4,#1,W5
05D2A:  MOV     W5,W4
05D2C:  MUL.UU  W4,#10,W0
05D2E:  MOV     W0,W5
05D30:  ADD     W5,#8,W0
05D32:  MOV     #AB2,W4
05D34:  ADD     W0,W4,W5
05D36:  MOV     1B3E,W4
05D38:  MUL.UU  W4,#2,W0
05D3A:  MOV     #A9E,W4
05D3C:  ADD     W0,W4,W0
05D3E:  MOV     [W0],W6
05D40:  MOV     W6,W4
05D42:  MUL.UU  W4,#10,W6
05D44:  MOV     1B20,W4
05D46:  MUL.UU  W4,#4,W0
05D48:  ADD     W0,W6,W0
05D4A:  MOV     #B72,W4
05D4C:  ADD     W0,W4,W0
05D4E:  MOV     W0,W4
05D50:  MOV     #0,W3
05D52:  MOV     [W4++],[W3++]
05D54:  MOV     [W4++],[W3++]
05D56:  MOV     #0,W2
05D58:  MOV     #0,W3
05D5A:  CALL    12E8
05D5E:  MOV     #0,W4
05D60:  REPEAT  #3
05D62:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
05D64:  MOV     A9A,W4
05D66:  ADD     W4,#1,W5
05D68:  MOV     W5,W4
05D6A:  MUL.UU  W4,#10,W0
05D6C:  MOV     W0,W5
05D6E:  MOV     #AB2,W4
05D70:  ADD     W5,W4,W6
05D72:  MOV     1B3E,W4
05D74:  MUL.UU  W4,#2,W0
05D76:  MOV     #A9E,W4
05D78:  ADD     W0,W4,W0
05D7A:  MOV     [W0],W7
05D7C:  MOV     W7,W4
05D7E:  MUL.UU  W4,#10,W0
05D80:  MOV     W0,W7
05D82:  ADD     W7,#8,W0
05D84:  MOV     #B72,W4
05D86:  ADD     W0,W4,W0
05D88:  MOV     W0,W4
05D8A:  MOV     #0,W3
05D8C:  MOV     [W4++],[W3++]
05D8E:  MOV     [W4++],[W3++]
05D90:  MOV     #0,W2
05D92:  MOV     #0,W3
05D94:  CALL    12E8
05D98:  MOV     #0,W4
05D9A:  REPEAT  #3
05D9C:  MOV     [W4++],[W6++]
05D9E:  MOV     A9A,W4
05DA0:  MUL.UU  W4,#10,W0
05DA2:  MOV     W0,W5
05DA4:  ADD     W5,#8,W0
05DA6:  MOV     #AB2,W4
05DA8:  ADD     W0,W4,W5
05DAA:  MOV     1B3E,W4
05DAC:  MUL.UU  W4,#2,W0
05DAE:  MOV     #A9E,W4
05DB0:  ADD     W0,W4,W0
05DB2:  MOV     [W0],W6
05DB4:  MOV     W6,W4
05DB6:  MUL.UU  W4,#10,W6
05DB8:  ADD     W6,#C,W0
05DBA:  MOV     #B72,W4
05DBC:  ADD     W0,W4,W0
05DBE:  MOV     W0,W4
05DC0:  MOV     #0,W3
05DC2:  MOV     [W4++],[W3++]
05DC4:  MOV     [W4++],[W3++]
05DC6:  MOV     #0,W2
05DC8:  MOV     #0,W3
05DCA:  CALL    12E8
05DCE:  MOV     #0,W4
05DD0:  REPEAT  #3
05DD2:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
05DD4:  MOV     #2,W4
05DD6:  MOV     W4,1B44
.................... 	                } 
.................... 	                path_found = true; 
05DD8:  MOV     #1,W4
05DDA:  MOV     W4,A96
.................... 	            } 
05DDC:  GOTO    5E5E
.................... 	            else if (posEnd == 2 || posEnd == 1) 
05DE0:  MOV     1B42,W4
05DE2:  CP      W4,#2
05DE4:  BRA     Z,5DEC
05DE6:  MOV     1B42,W4
05DE8:  CP      W4,#1
05DEA:  BRA     NZ,5E5E
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05DEC:  MOV     A9A,W4
05DEE:  MUL.UU  W4,#10,W0
05DF0:  MOV     W0,W5
05DF2:  MOV     #AB2,W4
05DF4:  ADD     W5,W4,W6
05DF6:  MOV     1B3E,W4
05DF8:  MUL.UU  W4,#2,W0
05DFA:  MOV     #A9E,W4
05DFC:  ADD     W0,W4,W0
05DFE:  MOV     [W0],W7
05E00:  MOV     W7,W4
05E02:  MUL.UU  W4,#10,W0
05E04:  MOV     W0,W7
05E06:  MOV     #B72,W4
05E08:  ADD     W7,W4,W0
05E0A:  MOV     W0,W4
05E0C:  MOV     #0,W3
05E0E:  MOV     [W4++],[W3++]
05E10:  MOV     [W4++],[W3++]
05E12:  MOV     #0,W2
05E14:  MOV     #0,W3
05E16:  CALL    12E8
05E1A:  MOV     #0,W4
05E1C:  REPEAT  #3
05E1E:  MOV     [W4++],[W6++]
05E20:  MOV     A9A,W4
05E22:  MUL.UU  W4,#10,W0
05E24:  MOV     W0,W5
05E26:  ADD     W5,#8,W0
05E28:  MOV     #AB2,W4
05E2A:  ADD     W0,W4,W5
05E2C:  MOV     1B3E,W4
05E2E:  MUL.UU  W4,#2,W0
05E30:  MOV     #A9E,W4
05E32:  ADD     W0,W4,W0
05E34:  MOV     [W0],W6
05E36:  MOV     W6,W4
05E38:  MUL.UU  W4,#10,W6
05E3A:  ADD     W6,#4,W0
05E3C:  MOV     #B72,W4
05E3E:  ADD     W0,W4,W0
05E40:  MOV     W0,W4
05E42:  MOV     #0,W3
05E44:  MOV     [W4++],[W3++]
05E46:  MOV     [W4++],[W3++]
05E48:  MOV     #0,W2
05E4A:  MOV     #0,W3
05E4C:  CALL    12E8
05E50:  MOV     #0,W4
05E52:  REPEAT  #3
05E54:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05E56:  MOV     #1,W4
05E58:  MOV     W4,1B44
.................... 	                path_found = true; 
05E5A:  MOV     #1,W4
05E5C:  MOV     W4,A96
.................... 	            } 
....................  
....................  
.................... 	            break; 
05E5E:  GOTO    5E6E
....................  
.................... 	        case 8: 
....................  
.................... 	            path_found = false; 
05E62:  CLR     A96
....................  
.................... 	            break; 
05E64:  GOTO    5E6E
....................  
.................... 	        default: 
.................... 	            path_found = false; 
05E68:  CLR     A96
.................... 	            break; 
05E6A:  GOTO    5E6E
.................... 	    } 
....................  
.................... 	    i_rel = i_rel + relay_point_number;     
05E6E:  MOV     A9A,W0
05E70:  ADD     1B44,W0
05E72:  MOV     W0,A9A
....................     } 
05E74:  MOV     #1A,W5
05E76:  REPEAT  #7
05E78:  MOV     [--W15],[W5--]
05E7A:  MOV     [--W15],W5
05E7C:  RETURN  
....................   
.................... } 
....................  
.................... /* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y) 
.................... { 
.................... 	struct Coord spot; 
....................  
.................... 	 
.................... 	int isInZone = 0; 
.................... 	int zoneToCheck = 0; 
.................... 	enum{x1, y1, x2, y2, x3, y3, x4, y4}; 
....................  
.................... 	double dX = pt2X-pt1X; 
.................... 	double dY = pt2Y-pt1Y; 
....................  
.................... 	int i = 0; 
.................... 	do 
.................... 	{ 
.................... 		i++; 
....................  
.................... 		//On calcule des points le long du trajet 
.................... 		spot.X = (dX*i)/100; 
.................... 		spot.Y = (dY*i)/100; 
....................  
....................         isInZone = 0; 
....................  
....................         //Pour chaque point du trajet on vÃ©rifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < NbreZone_check; zoneToCheck++) 
.................... 		{ 
.................... 	        //On vÃ©rifie si le point se trouve dans la zone interdite 
.................... 			if ((spot.X+pt1X) >= TabZones[zoneToCheck][x1] && (spot.X+pt1X) <= TabZones[zoneToCheck][x4]) 
.................... 			{ 
.................... 				if ((spot.Y+pt1Y) >= TabZones[zoneToCheck][y1] && (spot.Y+pt1Y) <= TabZones[zoneToCheck][y4]) 
.................... 				{ 
.................... 					//Si on a dÃ©jÃ  trouvÃ© une intersection, 
.................... 					if (intersection_found > 0) 
.................... 					{ 
.................... 						//On vÃ©rifie si ce n'est pas avec la mÃªme zone alors on peut ajouter une intersection 
.................... 						if (TabIntersection[intersection_found-1] != zoneToCheck) 
.................... 						{ 
.................... 							TabIntersection[intersection_found] = zoneToCheck; 
.................... 							intersection_found++; 
.................... 						} 
.................... 					} 
.................... 					//Si c'est la premiÃ¨re intersection qu'on trouve alors on l'ajoute 
.................... 					else 
.................... 					{ 
.................... 						TabIntersection[intersection_found] = zoneToCheck; 
.................... 						intersection_found++; 
.................... 					} 
.................... 					 
.................... 				} 
.................... 					 
.................... 					 
.................... 			} 
.................... 		} 
.................... 			 
.................... 	}while (i < 100); 
.................... } 
....................  
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 4; //Le point se trouve en bas Ã  droite de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 3; //Le point se trouve Ã  droite de la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut Ã  droite de la zone 
....................         } 
....................     } 
....................     else if (px > rx1) 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
....................         } 
....................     } 
....................     else 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 6; //Le point se trouve en bas Ã  gauche de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 7; //Le point se trouve Ã  gauche de la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut Ã  gauche de la zone 
....................         } 
....................     } 
....................  
....................     return pos; 
....................          
.................... } 
....................  
.................... void findRel(int posStart, int posEnd, int i_zone) 
.................... { 
.................... 	int path_found = false; 
....................     int relay_point_number = 0;    
....................     switch (posStart) 
....................     { 
.................... 	    case 0: 
.................... 	        if (posEnd == 3) 
.................... 	        { 
.................... 	            PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	            relay_point_number = 1; 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        else if (posEnd == 4) 
.................... 	        { 
.................... 	            if ((getDist(Pos_x, Pos_y, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], oXp, oYp)) > (getDist(Pos_x, Pos_y, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], oXp, oYp))) 
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	                relay_point_number = 1; 
.................... 	            } 
.................... 	            else  
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
.................... 	                relay_point_number = 1; 
.................... 	            } 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        else if (posEnd ==5) 
.................... 	        { 
.................... 	        	PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	            relay_point_number = 1; 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        break; 
....................  
.................... 	    case 1: 
....................  
.................... 	        break; 
....................  
.................... 	    case 2: 
....................  
.................... 	        break; 
....................  
.................... 	    case 3: 
....................  
.................... 	        break; 
....................  
.................... 	    case 4: 
....................  
.................... 	        break; 
....................  
.................... 	    case 5: 
....................  
.................... 	        break; 
....................  
.................... 	    case 6: 
....................  
.................... 	        break; 
....................  
.................... 	    case 7: 
....................  
.................... 	        break; 
....................  
.................... 	    case 8: 
....................  
.................... 	        break; 
....................  
.................... 	    default : 
.................... 	        path_found = false; 
.................... 	        break; 
....................     } 
....................  
....................     i_rel = i_rel+relay_point_number; 
.................... } 
....................  
.................... void findPath() 
.................... { 
.................... 	enum{x1, y1, x2, y2, x3, y3, x4, y4}; 
....................  
.................... 	 
....................  
.................... 	//On rÃ©cupÃ¨re la position des deux points par rapport Ã  la zone 
.................... 	int pos1 = getPos(Pos_x, Pos_y, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
.................... 	int pos2 = getPos(oXp, oYp, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
....................  
.................... 	findRel(pos1, pos2, 0); 
....................  
.................... 	checkIntersection(PtsRelai[0].X, PtsRelai[0].Y, oXp, oYp); 
....................  
.................... 	if(intersection_found == 0) 
.................... 	{ 
.................... 		goToObj(); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		pos1 = getPos(PtsRelai[0].X, PtsRelai[0].Y, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
.................... 		findRel(pos1, pos2, 1) 
.................... 	} 
.................... 	 
....................  
.................... } 
....................  
.................... void checkPath() 
.................... { 
.................... 	checkIntersection(Pos_x, Pos_y, oXp, oYp); 
....................  
.................... 	if(intersection_found == 0) 
.................... 	{ 
.................... 		__DeplToDo(oType); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		findPath(); 
.................... 	} 
....................  
.................... } 
.................... */ 
....................  
.................... #endif  
....................  
....................  
.................... #endif  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////// 
.................... // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // 
.................... // La plage ROM 0 Ã  511 est rÃ©servÃ©e aux objectifs. // 
.................... // 512/513 : Nombre d'objectifs 
.................... // 514/515 : Si des objectifs sont chargÃ©s 
.................... ////////////////////////////////////////////////////// 
....................  
.................... //******************************************************************************** 
.................... //*  Main 
.................... //**************************************************************************************************** 
.................... void main(void) 
*
0986C:  MOV     W5,[W15++]
0986E:  MOV     W6,[W15++]
09870:  MOV     W7,[W15++]
09872:  MOV     #2000,W15
09874:  MOV     #27FF,W0
09876:  MOV     W0,20
09878:  NOP     
0987A:  MOV     #7444,W0
0987C:  MOV     W0,94
0987E:  MOV     #4744,W0
09880:  MOV     W0,96
09882:  BSET.B  81.7
09884:  BCLR.B  2E4.3
09886:  BCLR.B  2E4.2
09888:  BCLR.B  2E8.2
0988A:  BCLR.B  2E8.3
0988C:  BSET.B  207.7
0988E:  BSET.B  207.5
09890:  BSET.B  206.6
09892:  BCLR.B  207.3
09894:  BSET.B  206.7
09896:  BCLR.B  207.0
09898:  BSET.B  207.1
0989A:  BCLR.B  207.2
0989C:  CLR     20A
0989E:  MOV     #C2,W4
098A0:  MOV     W4,204
098A2:  MOV     #8000,W4
098A4:  MOV     W4,216
098A6:  MOV     #400,W4
098A8:  MOV     W4,218
098AA:  MOV     #A,W4
098AC:  MOV     W4,21E
098AE:  BCLR.B  85A.0
098B0:  BCLR.B  85A.1
098B2:  BCLR.B  85A.2
098B4:  BCLR.B  85A.3
098B6:  BCLR.B  85A.4
098B8:  BCLR.B  85A.5
098BA:  BCLR.B  85A.6
098BC:  BCLR.B  85A.7
098BE:  BCLR.B  85B.0
098C0:  BCLR.B  85B.1
098C2:  BCLR.B  85B.2
098C4:  BCLR.B  85B.3
098C6:  CLR     85C
098C8:  CLR     85E
098CA:  CLR.B   860
098CC:  CLR     862
098CE:  CLR     864
098D0:  CLR     866
098D2:  CLR     868
098D4:  CLR     86A
098D6:  CLR     86C
098D8:  CLR.B   861
098DA:  CLR.B   86E
098DC:  MOV.B   #6,W0L
098DE:  MOV.B   W0L,86F
098E0:  CLR.B   870
098E2:  CLR.B   871
098E4:  CLR.B   872
098E6:  MOV.B   #1,W0L
098E8:  MOV.B   W0L,873
098EA:  MOV.B   #1,W0L
098EC:  MOV.B   W0L,874
098EE:  CLR     876
098F0:  CLR     878
098F2:  CLR.B   875
098F4:  CLR.B   88E
098F6:  CLR.B   88F
098F8:  BCLR.B  85B.4
098FA:  BCLR.B  85B.5
098FC:  MOV     #BB8,W4
098FE:  MOV     W4,890
09900:  CLR.B   892
09902:  CLR     A94
09904:  CLR     A96
09906:  CLR     A98
09908:  CLR     A9A
0990A:  CLR     A9C
0990C:  MOV     #3E8,W4
0990E:  MOV     W4,C12
09910:  MOV.B   #A,W0L
09912:  MOV.B   W0L,893
09914:  CLR     C14
09916:  CLR     C16
09918:  CLR     C18
0991A:  CLR     C1A
0991C:  BCLR.B  85B.6
0991E:  CLR     14A4
09920:  CLR     14A6
09922:  CLR     14A8
09924:  CLR     14AA
09926:  CLR     14AC
09928:  CLR     14AE
0992A:  CLR     14B0
0992C:  CLR     14B2
0992E:  CLR     14B4
09930:  CLR     14B6
09932:  CLR     14B8
09934:  CLR     14BA
09936:  MOV.B   #14,W0L
09938:  MOV.B   W0L,14BC
0993A:  MOV.B   #5,W0L
0993C:  MOV.B   W0L,14BD
0993E:  MOV     #2,W4
09940:  MOV     W4,14BE
09942:  CLR     14C0
09944:  MOV.B   #3,W0L
09946:  MOV.B   W0L,14C2
09948:  MOV     #C8,W4
0994A:  MOV     W4,14C4
0994C:  BCLR.B  85B.7
0994E:  CLR     14C6
09950:  CLR     14C8
09952:  CLR     1588
09954:  MOV     #5AA,W4
09956:  MOV     W4,158A
09958:  MOV     #7D0,W4
0995A:  MOV     W4,158C
0995C:  MOV     #4B0,W4
0995E:  MOV     W4,158E
09960:  CLR     1590
09962:  CLR     1592
09964:  CLR.B   14C3
09966:  BCLR.B  1594.0
09968:  BCLR.B  1594.1
0996A:  BCLR.B  1594.2
0996C:  CLR     1596
0996E:  CLR     1598
09970:  MOV.B   #3,W0L
09972:  MOV.B   W0L,1595
09974:  CLR.B   159A
09976:  MOV     #C8,W4
09978:  MOV     W4,159E
0997A:  CLR     15A0
0997C:  CLR     15A2
0997E:  CLR.B   159B
09980:  BCLR.B  1594.3
09982:  CLR     15A4
09984:  CLR     15A6
09986:  CLR     15A8
09988:  CLR.B   15AA
0998A:  MOV.B   #1,W0L
0998C:  MOV.B   W0L,15AB
0998E:  BCLR.B  1594.4
09990:  CLR.B   15AC
09992:  BCLR.B  1594.5
09994:  CLR.B   15AD
09996:  MOV     #999A,W4
09998:  MOV     W4,15AE
0999A:  MOV     #9999,W4
0999C:  MOV     W4,15B0
0999E:  MOV     #9999,W4
099A0:  MOV     W4,15B2
099A2:  MOV     #3FF9,W4
099A4:  MOV     W4,15B4
099A6:  MOV     #64,W4
099A8:  MOV     W4,15B6
099AA:  CLR     15BA
099AC:  CLR     15BC
099AE:  CLR     15BE
099B0:  CLR     15C0
099B2:  CLR     15C2
099B4:  CLR     15C4
099B6:  CLR     15C6
099B8:  CLR     15C8
099BA:  CLR     15CA
099BC:  CLR     15CC
099BE:  CLR     15CE
099C0:  CLR     15D0
099C2:  MOV     #F8B6,W4
099C4:  MOV     W4,15D2
099C6:  MOV     #14,W4
099C8:  MOV     W4,15D4
099CA:  MOV     #D9E3,W4
099CC:  MOV     W4,15D6
099CE:  MOV     #400B,W4
099D0:  MOV     W4,15D8
099D2:  CLR     15DA
099D4:  CLR     15DC
099D6:  MOV     #8800,W4
099D8:  MOV     W4,15DE
099DA:  MOV     #40B3,W4
099DC:  MOV     W4,15E0
099DE:  MOV     #6DDB,W4
099E0:  MOV     W4,15E2
099E2:  MOV     #9A17,W4
099E4:  MOV     W4,15E4
099E6:  MOV     #84EB,W4
099E8:  MOV     W4,15E6
099EA:  MOV     #403D,W4
099EC:  MOV     W4,15E8
099EE:  MOV     15DA,W0
099F0:  MOV     15DC,W1
099F2:  MOV     15DE,W2
099F4:  MOV     15E0,W3
099F6:  MOV     #0,W4
099F8:  MOV     #0,W5
099FA:  MOV     #0,W6
099FC:  MOV     #4010,W7
099FE:  CALL    BCC
09A02:  MOV     W0,W5
09A04:  MOV     W1,W6
09A06:  MOV     W2,W7
09A08:  MOV     W3,W8
09A0A:  MOV     W5,[W15++]
09A0C:  MOV     W6,[W15++]
09A0E:  MOV     W7,[W15++]
09A10:  MOV     15D2,W0
09A12:  MOV     15D4,W1
09A14:  MOV     15D6,W2
09A16:  MOV     15D8,W3
09A18:  MOV     #2D18,W4
09A1A:  MOV     #5444,W5
09A1C:  MOV     #21FB,W6
09A1E:  MOV     #4009,W7
09A20:  CALL    BCC
09A24:  MOV     [--W15],W7
09A26:  MOV     [--W15],W6
09A28:  MOV     [--W15],W5
09A2A:  MOV     W5,[W15++]
09A2C:  MOV     W6,[W15++]
09A2E:  MOV     W7,[W15++]
09A30:  MOV     W0,W4
09A32:  MOV     W5,W0
09A34:  MOV     W1,W5
09A36:  MOV     W6,W1
09A38:  MOV     W2,W6
09A3A:  MOV     W7,W2
09A3C:  MOV     W3,W7
09A3E:  MOV     W8,W3
09A40:  CALL    CDC
09A44:  MOV     [--W15],W7
09A46:  MOV     [--W15],W6
09A48:  MOV     [--W15],W5
09A4A:  MOV     W0,15EA
09A4C:  MOV     W1,15EC
09A4E:  MOV     W2,15EE
09A50:  MOV     W3,15F0
09A52:  MOV     #9D39,W4
09A54:  MOV     W4,15F2
09A56:  MOV     #A252,W4
09A58:  MOV     W4,15F4
09A5A:  MOV     #DF46,W4
09A5C:  MOV     W4,15F6
09A5E:  MOV     #3F91,W4
09A60:  MOV     W4,15F8
09A62:  CLR.B   15FA
09A64:  CLR.B   15FB
09A66:  CLR     15FC
09A68:  CLR     15FE
09A6A:  CLR     1600
09A6C:  CLR     1602
09A6E:  CLR     1604
09A70:  CLR     1606
09A72:  CLR     1608
09A74:  CLR     160A
09A76:  CLR     160C
09A78:  CLR     160E
09A7A:  BCLR.B  1594.6
09A7C:  MOV     #8000,W4
09A7E:  MOV     W4,20C
09A80:  MOV     #400,W4
09A82:  MOV     W4,20E
09A84:  MOV     #A,W4
09A86:  MOV     W4,214
09A88:  BCLR.B  1611.1
09A8A:  BCLR.B  1611.2
09A8C:  CLR.B   1712
09A8E:  CLR.B   1713
09A90:  BCLR.B  1611.3
09A92:  CLR.B   1B14
09A94:  CLR     1B1E
09A96:  MOV     #3,W4
09A98:  MOV     W4,1B20
09A9A:  MOV     #2,W4
09A9C:  MOV     W4,1B22
09A9E:  MOV     #1,W4
09AA0:  MOV     W4,1B24
09AA2:  CLR     1B26
09AA4:  BCLR.B  1611.4
09AA6:  SETM    2A8
09AA8:  MOV     [--W15],W7
09AAA:  MOV     [--W15],W6
09AAC:  MOV     [--W15],W5
09AAE:  BCLR.B  1594.7
09AB0:  BCLR.B  1611.0
09AB2:  BRA     9BA8
09AB4:  DATA    C0,14,08
09AB6:  DATA    7A,00,C2
09AB8:  DATA    00,08,94
09ABA:  DATA    00,80,1D
09ABC:  DATA    0B,72,C8
09ABE:  DATA    00,00,00
09AC0:  DATA    96,00,00
09AC2:  DATA    00,0E,01
09AC4:  DATA    00,00,B4
09AC6:  DATA    00,00,00
09AC8:  DATA    14,00,00
09ACA:  DATA    00,96,00
09ACC:  DATA    00,00,46
09ACE:  DATA    00,00,00
09AD0:  DATA    B4,40,23
09AD2:  DATA    00,00,0D
09AD4:  DATA    50,00,00
09AD6:  DATA    00,46,00
09AD8:  DATA    00,00,B4
09ADA:  DATA    00,00,00
09ADC:  DATA    64,40,23
09ADE:  DATA    00,00,0D
09AE0:  DATA    1E,00,00
09AE2:  DATA    00,1E,00
09AE4:  DATA    00,00,32
09AE6:  DATA    00,00,00
09AE8:  DATA    32,40,13
09AEA:  DATA    00,00,10
09AEC:  DATA    96,00,00
09AEE:  DATA    00,0F,00
09AF0:  DATA    00,00,FA
09AF2:  DATA    00,00,00
09AF4:  DATA    32,00,00
09AF6:  DATA    00,C8,88
09AF8:  DATA    0C,1C,00
09AFA:  DATA    C0,06,14
09AFC:  DATA    CA,00,00
09AFE:  DATA    4B,F0,3F
09B00:  DATA    5C,0A,58
09B02:  DATA    F6,3B,8F
09B04:  DATA    00,C0,3C
09B06:  DATA    8B,28,AC
09B08:  DATA    3C,BE,F6
09B0A:  DATA    3F,D2,D5
09B0C:  DATA    44,16,8C
09B0E:  DATA    15,D7,BF
09B10:  DATA    69,00,5A
09B12:  DATA    2E,1B,87
09B14:  DATA    99,3F,9A
09B16:  DATA    5F,AD,4B
09B18:  DATA    91,E4,01
09B1A:  DATA    C0,5D,11
09B1C:  DATA    2F,92,E4
09B1E:  DATA    81,FB,3F
09B20:  DATA    38,DA,91
09B22:  DATA    80,9D,C5
09B24:  DATA    E0,BF,6F
09B26:  DATA    12,C0,B4
09B28:  DATA    C3,09,AB
09B2A:  DATA    3F,6B,C1
09B2C:  DATA    03,4E,C1
09B2E:  DATA    B5,45,BF
09B30:  DATA    F7,40,05
09B32:  DATA    FF,00,5C
09B34:  DATA    EF,3F,F3
09B36:  DATA    A3,E2,F7
09B38:  DATA    D7,FF,01
09B3A:  DATA    40,C0,B4
09B3C:  DATA    FF,05,3C
09B3E:  DATA    58,FC,3F
09B40:  DATA    3B,D3,C0
09B42:  DATA    B5,BA,8C
09B44:  DATA    E2,3F,39
09B46:  DATA    D3,C7,3D
09B48:  DATA    41,79,B2
09B4A:  DATA    3F,87,0D
09B4C:  DATA    3C,50,D0
09B4E:  DATA    AF,62,3F
09B50:  DATA    30,4B,8D
09B52:  DATA    A2,82,AA
09B54:  DATA    04,40,09
09B56:  DATA    A0,40,4A
09B58:  DATA    05,76,03
09B5A:  DATA    40,EC,9E
09B5C:  DATA    37,88,A6
09B5E:  DATA    44,F0,3F
09B60:  DATA    8F,12,8D
09B62:  DATA    29,9A,5B
09B64:  DATA    C7,3F,0E
09B66:  DATA    E0,80,7C
09B68:  DATA    A1,D8,86
09B6A:  DATA    3F,29,4B
09B6C:  DATA    FB,95,C2
09B6E:  DATA    37,1A,3F
09B70:  DATA    00,00,80
09B72:  DATA    02,15,9C
09B74:  DATA    00,00,80
09B76:  DATA    01,16,10
09B78:  DATA    00,C1,00
09B7A:  DATA    16,12,00
09B7C:  DATA    C4,00,17
09B7E:  DATA    14,00,80
09B80:  DATA    04,1B,15
09B82:  DATA    00,00,00
09B84:  DATA    00,80,04
09B86:  DATA    1B,1A,00
09B88:  DATA    00,00,00
09B8A:  DATA    00,00,00
09B8C:  INC     W2,W2
09B8E:  CP      W2,#1
09B90:  BRA     NZ,9B9A
09B92:  TBLRDL  [W1],W3
09B94:  TBLRDH  [W1++],W4
09B96:  MOV.B   6,W0L
09B98:  RETURN  
09B9A:  CP      W2,#2
09B9C:  BRA     NZ,9BA2
09B9E:  MOV.B   7,W0L
09BA0:  RETURN  
09BA2:  MOV.B   8,W0L
09BA4:  CLR     W2
09BA6:  RETURN  
09BA8:  MOV     #0,W6
09BAA:  MOV     #0,W0
09BAC:  MOV     W0,32
09BAE:  MOV     #9AB4,W0
09BB0:  MOV     W0,W1
09BB2:  CLR     W2
09BB4:  CALL    9B8C
09BB8:  MOV.B   W0L,B
09BBA:  CALL    9B8C
09BBE:  MOV.B   W0L,A
09BC0:  CP0     W5
09BC2:  BRA     Z,9BF6
09BC4:  BTSS    W5.F
09BC6:  BRA     9BD6
09BC8:  CALL    9B8C
09BCC:  MOV.B   W0L,D
09BCE:  CALL    9B8C
09BD2:  MOV.B   W0L,C
09BD4:  BCLR    W5.F
09BD6:  BTSS    W5.E
09BD8:  BRA     9BEA
09BDA:  BCLR    W5.E
09BDC:  DEC     W5,W5
09BDE:  CALL    9B8C
09BE2:  MOV.B   W0L,W7L
09BE4:  REPEAT  W5
09BE6:  MOV.B   W7L,[W6++]
09BE8:  BRA     9BB4
09BEA:  CALL    9B8C
09BEE:  MOV.B   W0L,[W6++]
09BF0:  DEC     W5,W5
09BF2:  BRA     NZ,9BEA
09BF4:  BRA     9BB4
.................... { 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////	INITIALISATION DE TOUS LES MODULES	//////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 		// Initialisation du dsPIC 
.................... 	__Init_dsPIC();	 
09BF6:  CALL    F50
.................... 	__Init_UART(); 
09BFA:  CALL    100A
.................... 	delay_ms(1000); 
09BFE:  MOV     #3E8,W0
09C00:  CALL    E90
.................... 		 
.................... 		// Si le dÃ©marreur n'est pas en place on affiche une erreur 
.................... 	if(!_DEMA) 
09C04:  BTSC.B  2C3.2
09C06:  BRA     9C10
.................... 	{ 
.................... 		__Affichage_Erreur(1); 
09C08:  MOV.B   #1,W0L
09C0A:  MOV.B   W0L,1B2E
09C0C:  CALL    100E
.................... 	} 
.................... 				 
.................... 	// Configuration de la balise 
.................... 	Balise_config_plage(0, 12, 14);	// En avanÃ§ant 
09C10:  CLR.B   1B2A
09C12:  MOV.B   #C,W0L
09C14:  MOV.B   W0L,1B2B
09C16:  MOV.B   #E,W0L
09C18:  MOV.B   W0L,1B2C
09C1A:  CALL    1016
.................... 	delay_ms(100); 
09C1E:  MOV     #64,W0
09C20:  CALL    E90
.................... 	Balise_config_plage(1, 4, 6); // En reculant 
09C24:  MOV.B   #1,W0L
09C26:  MOV.B   W0L,1B2A
09C28:  MOV.B   #4,W0L
09C2A:  MOV.B   W0L,1B2B
09C2C:  MOV.B   #6,W0L
09C2E:  MOV.B   W0L,1B2C
09C30:  CALL    1016
.................... 	delay_ms(100); 
09C34:  MOV     #64,W0
09C36:  CALL    E90
....................  
.................... 	//On dÃ©finit de quel cÃ´tÃ© de la table on se trouve 
.................... 	if(_TEAM==0) 
09C3A:  BTSC.B  2C3.4
09C3C:  BRA     9C48
.................... 	{ 
.................... 		_LDT1=0; 
09C3E:  BCLR.B  2D6.5
.................... 		_LDT2=1; 
09C40:  BSET.B  2D6.6
.................... 		Team=0; 
09C42:  BCLR.B  85B.3
.................... 	} 
09C44:  GOTO    9C52
.................... 	else if(_TEAM==1) 
09C48:  BTSS.B  2C3.4
09C4A:  BRA     9C52
.................... 	{ 
.................... 		_LDT2=0; 
09C4C:  BCLR.B  2D6.6
.................... 		_LDT1=1; 
09C4E:  BSET.B  2D6.5
.................... 		Team=1; 
09C50:  BSET.B  85B.3
.................... 	}	 
.................... 	 
.................... 	//On enlÃ¨ve l'arrÃªt d'urgence 
.................... 	fprintf(ROBOTEQ,"!MG\r"); 
09C52:  MOV     #0,W1
09C54:  MOV     W1,W0
09C56:  CLR.B   1
09C58:  CALL    3F6
09C5C:  INC     W1,W1
09C5E:  BTSC.B  219.1
09C60:  BRA     9C5E
09C62:  MOV     W0,21A
09C64:  MOV     #3,W0
09C66:  CPSGT   W1,W0
09C68:  BRA     9C54
.................... 	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 			 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	/////////////////////////////////	PROGRAMME PRINCIPAL	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	int1 action_ok1 = 0; 
.................... 	int1 action_ok2 = 0; 
.................... 	int1 action_ok3 = 0; 
09C6A:  BCLR.B  1B28.0
09C6C:  BCLR.B  1B28.1
09C6E:  BCLR.B  1B28.2
....................  
.................... 	while(1) 
.................... 	{ 
.................... 		switch(Etat_rob) 
09C70:  MOV.B   875,W0L
09C72:  CLR.B   1
09C74:  XOR     #0,W0
09C76:  BRA     Z,9C9A
09C78:  XOR     #1,W0
09C7A:  BRA     Z,9D0E
09C7C:  XOR     #3,W0
09C7E:  BRA     Z,9D12
09C80:  XOR     #1,W0
09C82:  BRA     Z,9D2E
09C84:  XOR     #7,W0
09C86:  BRA     Z,9D66
09C88:  XOR     #1,W0
09C8A:  BRA     Z,9DDE
09C8C:  XOR     #3,W0
09C8E:  BRA     Z,9E6C
09C90:  XOR     #1,W0
09C92:  BRA     Z,9EF2
09C94:  XOR     #F,W0
09C96:  BRA     Z,9FBA
09C98:  BRA     A006
.................... 		{ 
.................... 			case Init: 
.................... 			 
.................... 				if(NbreObjectifs > 0 && !_DEMA  && !flag_end)//si on a des objectifs et qu'il sont charger 
09C9A:  CP0     14C6
09C9C:  BRA     Z,9CDE
09C9E:  BTSC.B  2C3.2
09CA0:  BRA     9CDE
09CA2:  BTSC.B  85A.7
09CA4:  BRA     9CDE
.................... 				{ 
.................... 					if(BeginTimeMS==0)  
09CA6:  CP0     866
09CA8:  BRA     NZ,9CBC
09CAA:  CP0     868
09CAC:  BRA     NZ,9CBC
.................... 					{ 
.................... 						BeginTimeMS = RealTimeMS; 
09CAE:  PUSH    862
09CB0:  POP     866
09CB2:  PUSH    864
09CB4:  POP     868
.................... 						delay_ms(1000);  
09CB6:  MOV     #3E8,W0
09CB8:  CALL    E90
.................... 					} 
.................... 					__Afficheur_7segments(0); 
09CBC:  CLR.B   1B2E
09CBE:  CLR.B   1B2F
09CC0:  CALL    1060
.................... 					__LoadObj(NoObj,NoPts);//on mets l'objectifs dans des variables 
09CC4:  MOV.B   873,W0L
09CC6:  MOV.B   W0L,1B2C
09CC8:  CLR.B   1B2D
09CCA:  MOV.B   874,W0L
09CCC:  MOV.B   W0L,1B2E
09CCE:  CLR.B   1B2F
09CD0:  CALL    10B4
....................  
.................... 					Etat_rob = Check_ZI;//on change d'etat 
09CD4:  MOV.B   #2,W0L
09CD6:  MOV.B   W0L,875
.................... 					Depl_send = 0;		 
09CD8:  BCLR.B  85B.4
.................... 				} 
09CDA:  GOTO    9D0A
.................... 				else if(NbreObjectifs == 0) 
09CDE:  CP0     14C6
09CE0:  BRA     NZ,9CF4
.................... 				{ 
.................... 					__Afficheur_7segments(1); 
09CE2:  MOV.B   #1,W0L
09CE4:  MOV.B   W0L,1B2E
09CE6:  CLR.B   1B2F
09CE8:  CALL    1060
.................... 					__ReadObjectifs();	 
09CEC:  CALL    124E
.................... 				} 
09CF0:  GOTO    9D0A
.................... 				else if(_DEMA == 1 && NbreObjectifs != 0) 
09CF4:  BTSS.B  2C3.2
09CF6:  BRA     9D0A
09CF8:  CP0     14C6
09CFA:  BRA     Z,9D0A
.................... 				{				 
.................... 					__Afficheur_7segments(2); 
09CFC:  MOV.B   #2,W0L
09CFE:  MOV.B   W0L,1B2E
09D00:  CLR.B   1B2F
09D02:  CALL    1060
.................... 					__Init_pos();					 
09D06:  CALL    1352
.................... 				} 
.................... 				break; 
09D0A:  GOTO    A012
.................... 				 
.................... 			case Choose_objectif: 
....................  
.................... 				/* 
.................... 				static int obj_todo = 0; //L'objectif qu'on regarde si on peut le faire 
....................  
.................... 				obj_todo++; //On passe Ã  l'objectif suivant 
.................... 				__LoadObj(obj_todo, 1); //On rÃ©cupÃ¨re les donnÃ©es de l'objectif dans les variables 
....................  
.................... 				if(oTime < (TimeLimit - GameTimeS) && !obj_done && !obj_notcontinuable) 
.................... 				{ 
.................... 					Etat_rob = Send_depl_action; 
.................... 				} 
....................  
.................... 				if (obj_todo >= (NbreObjectifs))  
.................... 				{ 
.................... 					obj_todo = 0; 
.................... 				} 
.................... 				*/ 
.................... 				break; 
09D0E:  GOTO    A012
.................... 				 
....................  
.................... 			case Check_ZI: 
....................  
.................... 				if(checkPath()) 
09D12:  CALL    1930
09D16:  CP0     W0
09D18:  BRA     Z,9D22
.................... 				{ 
.................... 					Etat_rob = Send_depl_action; 
09D1A:  MOV.B   #3,W0L
09D1C:  MOV.B   W0L,875
.................... 				} 
09D1E:  GOTO    9D2A
.................... 				else 
.................... 				{ 
.................... 					findPath(); 
09D22:  CALL    5E7E
.................... 					Etat_rob = Send_depl_action_ZI; 
09D26:  MOV.B   #4,W0L
09D28:  MOV.B   W0L,875
.................... 				} 
....................  
.................... 				break; 
09D2A:  GOTO    A012
....................  
.................... 			case Send_depl_action: 
....................  
.................... 				if(!Depl_send && !flag_end)//si le deplacement n'as pas ete envoye 
09D2E:  BTSC.B  85B.4
09D30:  BRA     9D3E
09D32:  BTSC.B  85A.7
09D34:  BRA     9D3E
.................... 				{ 
.................... 					__DeplToDo(oType);//envoie le dÃ©placment 
09D36:  MOV.B   14A8,W0L
09D38:  MOV.B   W0L,1B2A
09D3A:  CALL    8580
.................... 				} 
.................... 				if(!Action_send && !flag_end)//si l'action n'a pas ete envoyee 
09D3E:  BTSC.B  85B.6
09D40:  BRA     9D4E
09D42:  BTSC.B  85A.7
09D44:  BRA     9D4E
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
09D46:  MOV.B   14B0,W0L
09D48:  MOV.B   W0L,1B2A
09D4A:  CALL    85D8
.................... 				} 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
09D4E:  BTSS.B  85B.4
09D50:  BRA     9D62
09D52:  BTSS.B  85B.6
09D54:  BRA     9D62
09D56:  BTSC.B  85A.7
09D58:  BRA     9D62
.................... 				{ 
.................... 					Depl_send = 0; 
09D5A:  BCLR.B  85B.4
.................... 					Action_send = 0; 
09D5C:  BCLR.B  85B.6
.................... 					Etat_rob = Depl_action_process; 
09D5E:  MOV.B   #5,W0L
09D60:  MOV.B   W0L,875
.................... 				} 
.................... 				break; 
09D62:  GOTO    A012
....................  
....................  
.................... 			case Send_depl_action_ZI: 
....................  
.................... 				if(!Action_send)//si l'action n'a pas ete envoyee 
09D66:  BTSC.B  85B.6
09D68:  BRA     9D72
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
09D6A:  MOV.B   14B0,W0L
09D6C:  MOV.B   W0L,1B2A
09D6E:  CALL    85D8
.................... 				} 
....................  
.................... 				if(!Depl_send && i_depl< i_rel) 
09D72:  BTSC.B  85B.4
09D74:  BRA     9DB8
09D76:  MOV     A9C,W0
09D78:  MOV     A9A,W4
09D7A:  CP      W4,W0
09D7C:  BRA     LE,9DB8
.................... 				{ 
.................... 					__PaP(PtsRelai[i_depl].X, PtsRelai[i_depl].Y); 
09D7E:  MOV     A9C,W4
09D80:  MUL.UU  W4,#10,W0
09D82:  MOV     W0,W5
09D84:  MOV     #AB2,W4
09D86:  ADD     W5,W4,W0
09D88:  MOV     W0,W4
09D8A:  MOV     #0,W3
09D8C:  REPEAT  #3
09D8E:  MOV     [W4++],[W3++]
09D90:  CALL    19EC
09D94:  MOV     W0,W6
09D96:  MOV     A9C,W4
09D98:  MUL.UU  W4,#10,W0
09D9A:  MOV     W0,W7
09D9C:  ADD     W7,#8,W0
09D9E:  MOV     #AB2,W4
09DA0:  ADD     W0,W4,W0
09DA2:  MOV     W0,W4
09DA4:  MOV     #0,W3
09DA6:  REPEAT  #3
09DA8:  MOV     [W4++],[W3++]
09DAA:  CALL    19EC
09DAE:  MOV     W0,W7
09DB0:  MOV     W6,1B30
09DB2:  MOV     W7,1B32
09DB4:  CALL    72AC
.................... 				} 
....................  
.................... 				if (flag_depl_ok) 
09DB8:  BTSS.B  85A.6
09DBA:  BRA     9DC2
.................... 				{ 
.................... 					i_depl++; 
09DBC:  INC     0A9C
.................... 					Depl_send = 0; 
09DBE:  BCLR.B  85B.4
.................... 					flag_depl_ok = 0; 
09DC0:  BCLR.B  85A.6
.................... 				} 
....................  
.................... 				if(i_depl >= i_rel && Action_send)//si tout a ete envoye 
09DC2:  MOV     A9A,W0
09DC4:  MOV     A9C,W4
09DC6:  CP      W4,W0
09DC8:  BRA     LT,9DD6
09DCA:  BTSS.B  85B.6
09DCC:  BRA     9DD6
.................... 				{ 
.................... 					Depl_send = 0; 
09DCE:  BCLR.B  85B.4
.................... 					Action_send = 0; 
09DD0:  BCLR.B  85B.6
.................... 					Etat_rob = Depl_action_process_ZI; 
09DD2:  MOV.B   #6,W0L
09DD4:  MOV.B   W0L,875
.................... 				} 
....................  
.................... 				__Check_commande_atteint(); 
09DD6:  CALL    6F6A
....................  
.................... 				break; 
09DDA:  GOTO    A012
....................  
.................... 			case Depl_action_process : 
....................  
.................... 				__Check_commande_atteint(); 
09DDE:  CALL    6F6A
.................... 				action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
09DE2:  MOV.B   #C0,W0L
09DE4:  MOV.B   W0L,1B2A
09DE6:  CALL    880A
09DEA:  BCLR.B  1B28.0
09DEC:  BTSC.B  0.0
09DEE:  BSET.B  1B28.0
.................... 				action_ok2 = __Check_action_end(0xC2); 
09DF0:  MOV.B   #C2,W0L
09DF2:  MOV.B   W0L,1B2A
09DF4:  CALL    880A
09DF8:  BCLR.B  1B28.1
09DFA:  BTSC.B  0.0
09DFC:  BSET.B  1B28.1
.................... 				action_ok3 = __Check_action_end(0xC4); 
09DFE:  MOV.B   #C4,W0L
09E00:  MOV.B   W0L,1B2A
09E02:  CALL    880A
09E06:  BCLR.B  1B28.2
09E08:  BTSC.B  0.0
09E0A:  BSET.B  1B28.2
.................... 				if(flag_depl_ok && action_ok1 && action_ok2 && action_ok3 && !flag_end && !_Detected)//on attend que tout soit fini 
09E0C:  BTSS.B  85A.6
09E0E:  BRA     9E68
09E10:  BTSS.B  1B28.0
09E12:  BRA     9E68
09E14:  BTSS.B  1B28.1
09E16:  BRA     9E68
09E18:  BTSS.B  1B28.2
09E1A:  BRA     9E68
09E1C:  BTSC.B  85A.7
09E1E:  BRA     9E68
09E20:  BTSC.B  85B.0
09E22:  BRA     9E68
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
09E24:  MOV     872,W4
09E26:  LSR     W4,#8,W4
09E28:  CP.B    W4L,#1
09E2A:  BRA     NZ,9E38
09E2C:  MOV     874,W4
09E2E:  CP.B    W4L,#1
09E30:  BRA     NZ,9E38
09E32:  MOV     #3E8,W0
09E34:  CALL    E90
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
09E38:  MOV     15BC,W0
09E3A:  ADD     15B8,W0
09E3C:  MOV     W0,15BC
.................... 					Pos_y += Dist_y; 
09E3E:  MOV     15BE,W0
09E40:  ADD     15BA,W0
09E42:  MOV     W0,15BE
.................... 					 
.................... 					__Afficheur_7segments(3); 
09E44:  MOV.B   #3,W0L
09E46:  MOV.B   W0L,1B2E
09E48:  CLR.B   1B2F
09E4A:  CALL    1060
.................... 	 
.................... 					Dist_x=0; 
09E4E:  CLR     15B8
.................... 					Dist_y=0; 
09E50:  CLR     15BA
.................... 					Dorient = 0; 
09E52:  CLR     15C2
09E54:  CLR     15C4
09E56:  CLR     15C6
09E58:  CLR     15C8
.................... 					balise_on = 0; 
09E5A:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
09E5C:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
09E5E:  BCLR.B  1B28.0
.................... 					action_ok2 = 0; 
09E60:  BCLR.B  1B28.1
.................... 					action_ok3 = 0; 
09E62:  BCLR.B  1B28.2
.................... 					Etat_rob = Switch_end_obj; 
09E64:  MOV.B   #7,W0L
09E66:  MOV.B   W0L,875
.................... 				} 
.................... 				break; 
09E68:  GOTO    A012
....................  
.................... 			case Depl_action_process_ZI: 
....................  
.................... 				action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
09E6C:  MOV.B   #C0,W0L
09E6E:  MOV.B   W0L,1B2A
09E70:  CALL    880A
09E74:  BCLR.B  1B28.0
09E76:  BTSC.B  0.0
09E78:  BSET.B  1B28.0
.................... 				action_ok2 = __Check_action_end(0xC2); 
09E7A:  MOV.B   #C2,W0L
09E7C:  MOV.B   W0L,1B2A
09E7E:  CALL    880A
09E82:  BCLR.B  1B28.1
09E84:  BTSC.B  0.0
09E86:  BSET.B  1B28.1
.................... 				action_ok3 = __Check_action_end(0xC4); 
09E88:  MOV.B   #C4,W0L
09E8A:  MOV.B   W0L,1B2A
09E8C:  CALL    880A
09E90:  BCLR.B  1B28.2
09E92:  BTSC.B  0.0
09E94:  BSET.B  1B28.2
.................... 				if(action_ok1 && action_ok2 && action_ok3 && !flag_end && !_Detected)//on attend que tout soit fini 
09E96:  BTSS.B  1B28.0
09E98:  BRA     9EEE
09E9A:  BTSS.B  1B28.1
09E9C:  BRA     9EEE
09E9E:  BTSS.B  1B28.2
09EA0:  BRA     9EEE
09EA2:  BTSC.B  85A.7
09EA4:  BRA     9EEE
09EA6:  BTSC.B  85B.0
09EA8:  BRA     9EEE
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
09EAA:  MOV     872,W4
09EAC:  LSR     W4,#8,W4
09EAE:  CP.B    W4L,#1
09EB0:  BRA     NZ,9EBE
09EB2:  MOV     874,W4
09EB4:  CP.B    W4L,#1
09EB6:  BRA     NZ,9EBE
09EB8:  MOV     #3E8,W0
09EBA:  CALL    E90
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
09EBE:  MOV     15BC,W0
09EC0:  ADD     15B8,W0
09EC2:  MOV     W0,15BC
.................... 					Pos_y += Dist_y; 
09EC4:  MOV     15BE,W0
09EC6:  ADD     15BA,W0
09EC8:  MOV     W0,15BE
.................... 					 
.................... 					__Afficheur_7segments(3); 
09ECA:  MOV.B   #3,W0L
09ECC:  MOV.B   W0L,1B2E
09ECE:  CLR.B   1B2F
09ED0:  CALL    1060
.................... 	 
.................... 					Dist_x=0; 
09ED4:  CLR     15B8
.................... 					Dist_y=0; 
09ED6:  CLR     15BA
.................... 					Dorient = 0; 
09ED8:  CLR     15C2
09EDA:  CLR     15C4
09EDC:  CLR     15C6
09EDE:  CLR     15C8
.................... 					balise_on = 0; 
09EE0:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
09EE2:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
09EE4:  BCLR.B  1B28.0
.................... 					action_ok2 = 0; 
09EE6:  BCLR.B  1B28.1
.................... 					action_ok3 = 0; 
09EE8:  BCLR.B  1B28.2
.................... 					Etat_rob = Switch_end_obj; 
09EEA:  MOV.B   #7,W0L
09EEC:  MOV.B   W0L,875
.................... 				} 
.................... 				break;	 
09EEE:  GOTO    A012
....................  
.................... 			case Switch_end_obj: 
.................... 				if(keep_obj==0)  
09EF2:  CP0     14BA
09EF4:  BRA     NZ,9F0E
.................... 				{ 
.................... 					TabObjectifs[NoObj][1][8] = 0; // mise de la ponderation a 0 --> on le remploie plus 
09EF6:  MOV.B   873,W0L
09EF8:  CLR.B   1
09EFA:  MOV     #138,W4
09EFC:  MUL.UU  W0,W4,W0
09EFE:  MOV     W0,W5
09F00:  ADD     W5,#18,W5
09F02:  ADD     W5,#10,W0
09F04:  MOV     #C1C,W4
09F06:  ADD     W0,W4,W5
09F08:  CLR.B   [W5]
09F0A:  MOV.B   #0,W0L
09F0C:  MOV.B   W0L,[W5+#1]
.................... 				} 
.................... 			 	if(Obj_end)//si fini l'objectifs,passe a l'obj suivant 
09F0E:  CP0     14B6
09F10:  BRA     Z,9F7E
.................... 				{ 
.................... 					if(Next_obj!=0) // 0--> passe a l'obj suivant, sinon va a l'obj marquer 
09F12:  CP0     14B8
09F14:  BRA     Z,9F3A
.................... 					{ 
.................... 						last_obj = NoObj; 
09F16:  MOV.B   873,W0L
09F18:  MOV.B   W0L,876
09F1A:  CLR.B   877
09F1C:  CLR     878
.................... 						NoObj = Next_Obj; 
09F1E:  MOV.B   14B8,W0L
09F20:  MOV.B   W0L,873
.................... 						NoPts = 1; 
09F22:  MOV.B   #1,W0L
09F24:  MOV.B   W0L,874
.................... 						__LoadObj(NoObj,NoPts);//charge le nouveau pts						 
09F26:  MOV.B   873,W0L
09F28:  MOV.B   W0L,1B2C
09F2A:  CLR.B   1B2D
09F2C:  MOV.B   874,W0L
09F2E:  MOV.B   W0L,1B2E
09F30:  CLR.B   1B2F
09F32:  CALL    10B4
.................... 					} 
09F36:  GOTO    9F7A
.................... 					else 
.................... 					{ 
.................... 						last_obj = NoObj; 
09F3A:  MOV.B   873,W0L
09F3C:  MOV.B   W0L,876
09F3E:  CLR.B   877
09F40:  CLR     878
.................... 						do //prochain objectifs avec pondÃ©ration de 10 
.................... 						{ 
.................... 							__Afficheur_7segments(4); 
09F42:  MOV.B   #4,W0L
09F44:  MOV.B   W0L,1B2E
09F46:  CLR.B   1B2F
09F48:  CALL    1060
.................... 							NoObj++; // on passe a l'objectifs suivant 
09F4C:  INC.B   0873
.................... 							NoPts=1; // on reprend au premier pts 
09F4E:  MOV.B   #1,W0L
09F50:  MOV.B   W0L,874
.................... 							if(NoObj == 10) 
09F52:  MOV     872,W4
09F54:  LSR     W4,#8,W4
09F56:  CP.B    W4L,#A
09F58:  BRA     NZ,9F64
.................... 							{ 
.................... 								Flag_end = 1; 
09F5A:  BSET.B  85A.7
.................... 								Ponderation = 10; 
09F5C:  MOV     #A,W4
09F5E:  MOV     W4,14B4
.................... 							} 
09F60:  GOTO    9F74
.................... 							else __LoadObj(NoObj,NoPts);//charge le nouveau pts 
09F64:  MOV.B   873,W0L
09F66:  MOV.B   W0L,1B2C
09F68:  CLR.B   1B2D
09F6A:  MOV.B   874,W0L
09F6C:  MOV.B   W0L,1B2E
09F6E:  CLR.B   1B2F
09F70:  CALL    10B4
.................... 	 
.................... 						}while(Ponderation!=10); 
09F74:  MOV     14B4,W4
09F76:  CP      W4,#A
09F78:  BRA     NZ,9F42
....................  
.................... 					} 
.................... 				} 
09F7A:  GOTO    9FA0
.................... 				else 
.................... 				{ 
.................... 					if(Pt_commun==1) NoPts+=2; // skip le pts droite 
09F7E:  MOV     14B2,W4
09F80:  CP      W4,#1
09F82:  BRA     NZ,9F8E
09F84:  MOV     874,W4
09F86:  ADD.B   W4L,#2,W0L
09F88:  MOV.B   W0L,874
09F8A:  GOTO    9F90
.................... 					else NoPts++; // passe au pt suivant suivant																 
09F8E:  INC.B   0874
.................... 					__LoadObj(NoObj,NoPts);//charge le nouveau pts 
09F90:  MOV.B   873,W0L
09F92:  MOV.B   W0L,1B2C
09F94:  CLR.B   1B2D
09F96:  MOV.B   874,W0L
09F98:  MOV.B   W0L,1B2E
09F9A:  CLR.B   1B2F
09F9C:  CALL    10B4
.................... 				}	 
.................... 				if(Pt_commun!=0)//si point pas symetrique 
09FA0:  CP0     14B2
09FA2:  BRA     Z,9FB0
.................... 				{ 
.................... 					if(Team)//pt droite 
09FA4:  BTSS.B  85B.3
09FA6:  BRA     9FB0
.................... 					{ 
.................... 						if(Pt_commun==1) NoPts++; // passe Ã  l'obj suivant (pt droite) 
09FA8:  MOV     14B2,W4
09FAA:  CP      W4,#1
09FAC:  BRA     NZ,9FB0
09FAE:  INC.B   0874
.................... 					} 
.................... 				} 
.................... 				 
.................... 				if(!Flag_end) Etat_rob = Init; 
09FB0:  BTSC.B  85A.7
09FB2:  BRA     9FB6
09FB4:  CLR.B   875
.................... 				break; 
09FB6:  GOTO    A012
.................... 			case Wait_end: //case wait 
.................... 				if(flag_error) //erreur --> clignotement 7 segments 
09FBA:  BTSS.B  85B.2
09FBC:  BRA     9FE0
.................... 				{ 
.................... 					__Afficheur_7segments(No_erreur,1); 
09FBE:  MOV.B   870,W0L
09FC0:  MOV.B   W0L,1B2E
09FC2:  MOV.B   #1,W0L
09FC4:  MOV.B   W0L,1B2F
09FC6:  CALL    1060
.................... 					delay_ms(1000); 
09FCA:  MOV     #3E8,W0
09FCC:  CALL    E90
.................... 					__Afficheur_7segments(No_erreur,0); 
09FD0:  MOV.B   870,W0L
09FD2:  MOV.B   W0L,1B2E
09FD4:  CLR.B   1B2F
09FD6:  CALL    1060
.................... 					delay_ms(1000); 
09FDA:  MOV     #3E8,W0
09FDC:  CALL    E90
.................... 				} 
.................... 				if(flagGameEnd) 
09FE0:  BTSS.B  85A.0
09FE2:  BRA     A002
.................... 				{ 
.................... 					__Afficheur_7segments(99); 
09FE4:  MOV.B   #63,W0L
09FE6:  MOV.B   W0L,1B2E
09FE8:  CLR.B   1B2F
09FEA:  CALL    1060
.................... 					// Desactive tout le reste 
.................... 					MoveServo(0,20); 
09FEE:  CLR     1B2A
09FF0:  MOV     #14,W4
09FF2:  MOV     W4,1B2C
09FF4:  CALL    8BF4
.................... 					disable_interrupts(INTR_GLOBAL); 
09FF8:  BCLR.B  81.7
09FFA:  MOV     #E0,W4
09FFC:  MOV     W4,42
09FFE:  BSET.B  81.7
.................... 					flagGameEnd=0;			 
0A000:  BCLR.B  85A.0
.................... 				}				 
.................... 				break;			 
0A002:  GOTO    A012
.................... 			default: 
.................... 				__Affichage_erreur(3);  
0A006:  MOV.B   #3,W0L
0A008:  MOV.B   W0L,1B2E
0A00A:  CALL    100E
.................... 				break; 
0A00E:  GOTO    A012
.................... 				 
.................... 		} 
0A012:  GOTO    9C70
....................  
.................... 	} 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
....................  
....................         //////////////////////////////////////////////////////////////////////////////////// 
.................... 		////////////////////////	ACTION PARALLELES	//////////////////////////////////// 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
.................... 		 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        BALISE          ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(flagBaliseCheck && !flag_end && balise_on && !flag_error) 
0A016:  BTSS.B  85A.2
0A018:  BRA     A1BC
0A01A:  BTSC.B  85A.7
0A01C:  BRA     A1BC
0A01E:  BTSS.B  85B.1
0A020:  BRA     A1BC
0A022:  BTSC.B  85B.2
0A024:  BRA     A1BC
....................       	{ 
....................         	Value_bal = Check_balise(); 			//Recuperation de la valeur de la bailse 
0A026:  CALL    8C2A
0A02A:  MOV.B   W0L,871
....................         	tempo_bal++; 							//temporisation de la balise, d'une fois detecte, il faut passer 4  tempo bal = 4 pour continuer 
0A02C:  INC.B   0872
.................... 	        if(Value_bal>=MAX_VALUE_DETECT_BALISE) 	//si adversaire trop proche 
0A02E:  MOV.B   14C2,W0L
0A030:  MOV     870,W4
0A032:  LSR     W4,#8,W4
0A034:  CP.B    W4L,W0L
0A036:  BRA     NC,A148
.................... 	        {    
.................... 	       		tempo_bal = 0;						//remise a 0 de la tempo 
0A038:  CLR.B   872
....................            		__Afficheur_7segments(44); 
0A03A:  MOV.B   #2C,W0L
0A03C:  MOV.B   W0L,1B2E
0A03E:  CLR.B   1B2F
0A040:  CALL    1060
.................... 	           	_LED2,_LED3,_LED4 = 1; 
0A044:  BSET.B  2D0.4
.................... 	           	_Detected = 1;						//indique que l'on a detecte l'adversaire 
0A046:  BSET.B  85B.0
.................... 	         
.................... 	            /////////////////// Arret du robot /////////////////////////////////////// 
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 9000_^MDEC 2 9000\r");	//rampe de dec. plus raide  
0A048:  MOV     #0,W1
0A04A:  MOV     W1,W0
0A04C:  CLR.B   1
0A04E:  CALL    408
0A052:  INC     W1,W1
0A054:  BTSC.B  219.1
0A056:  BRA     A054
0A058:  MOV     W0,21A
0A05A:  MOV     #19,W0
0A05C:  CPSGT   W1,W0
0A05E:  BRA     A04A
.................... 	            delay_ms(20); 
0A060:  MOV     #14,W0
0A062:  CALL    E90
.................... 	            fprintf(ROBOTEQ,"!S 1 0_!S 2 0\r");				//vitesse du robot a 0 --> il va freiner 
0A066:  MOV     #0,W1
0A068:  MOV     W1,W0
0A06A:  CLR.B   1
0A06C:  CALL    430
0A070:  INC     W1,W1
0A072:  BTSC.B  219.1
0A074:  BRA     A072
0A076:  MOV     W0,21A
0A078:  MOV     #D,W0
0A07A:  CPSGT   W1,W0
0A07C:  BRA     A068
....................  
.................... 	            if(Time_detected==0) // recuperation du temps de la detection 
0A07E:  CP0.B   86E
0A080:  BRA     NZ,A08A
.................... 	            { 
.................... 	               Time_detected = GameTimeS; 
0A082:  MOV.B   861,W0L
0A084:  MOV.B   W0L,86E
.................... 	            } 
0A086:  GOTO    A144
.................... 	            else if(((GameTimeS - Time_detected) >= TIME_tempo_dectected))//on attend 6s 
0A08A:  MOV     860,W4
0A08C:  LSR     W4,#8,W4
0A08E:  MOV     86E,W3
0A090:  SUB.B   W4L,W3L,W0L
0A092:  MOV     86E,W4
0A094:  LSR     W4,#8,W4
0A096:  CP.B    W4L,W0L
0A098:  BRA     GTU,A144
.................... 	            {       
.................... 	               if(TabObjectifs[(NoObj+1)][1][8]!=10 && TabObjectifs[(NoObj+1)][1][8]!=0)//si obj suivant pond entre 1 et 9 --> on switch l'obj 
0A09A:  MOV     872,W4
0A09C:  LSR     W4,#8,W4
0A09E:  ADD     W4,#1,W5
0A0A0:  MOV     #138,W4
0A0A2:  MUL.UU  W5,W4,W0
0A0A4:  MOV     W0,W5
0A0A6:  ADD     W5,#18,W5
0A0A8:  ADD     W5,#10,W0
0A0AA:  MOV     #C1C,W4
0A0AC:  ADD     W0,W4,W0
0A0AE:  MOV     [W0],W5
0A0B0:  CP      W5,#A
0A0B2:  BRA     Z,A144
0A0B4:  MOV     872,W4
0A0B6:  LSR     W4,#8,W4
0A0B8:  ADD     W4,#1,W5
0A0BA:  MOV     #138,W4
0A0BC:  MUL.UU  W5,W4,W0
0A0BE:  MOV     W0,W5
0A0C0:  ADD     W5,#18,W5
0A0C2:  ADD     W5,#10,W0
0A0C4:  MOV     #C1C,W4
0A0C6:  ADD     W0,W4,W0
0A0C8:  MOV     [W0],W5
0A0CA:  CP0     W5
0A0CC:  BRA     Z,A144
.................... 	               { 
.................... 	                   /////////////////// actualisation position x,y /////////////////// 
.................... 	                  __actual_pos();// actualisation de la Pos xy  
0A0CE:  CALL    8C66
....................  
.................... 	                   /////////////////// effacer l'ordre en cours  ///////////////////  
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
0A0D2:  MOV     #0,W1
0A0D4:  MOV     W1,W0
0A0D6:  CLR.B   1
0A0D8:  CALL    380
0A0DC:  INC     W1,W1
0A0DE:  BTSC.B  219.1
0A0E0:  BRA     A0DE
0A0E2:  MOV     W0,21A
0A0E4:  MOV     #13,W0
0A0E6:  CPSGT   W1,W0
0A0E8:  BRA     A0D4
.................... 	                  delay_ms(10); 
0A0EA:  MOV     #A,W0
0A0EC:  CALL    E90
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
0A0F0:  MOV     #0,W1
0A0F2:  MOV     W1,W0
0A0F4:  CLR.B   1
0A0F6:  CALL    3A2
0A0FA:  INC     W1,W1
0A0FC:  BTSC.B  219.1
0A0FE:  BRA     A0FC
0A100:  MOV     W0,21A
0A102:  MOV     #13,W0
0A104:  CPSGT   W1,W0
0A106:  BRA     A0F2
....................  
.................... 	                   /////////////////// Passage a l'obj suivant  /////////////////// 
.................... 	                  NoObj++; // passage a l'objectif suivant 
0A108:  INC.B   0873
.................... 	                  NoPts = 1; // on demarre par le premier pts 
0A10A:  MOV.B   #1,W0L
0A10C:  MOV.B   W0L,874
.................... 	                  __LoadObj(NoObj,NoPts);//charge le nouveau pts 
0A10E:  MOV.B   873,W0L
0A110:  MOV.B   W0L,1B2C
0A112:  CLR.B   1B2D
0A114:  MOV.B   874,W0L
0A116:  MOV.B   W0L,1B2E
0A118:  CLR.B   1B2F
0A11A:  CALL    10B4
.................... 	                
.................... 	                  if(Pt_commun!=0)//si point pas symetrique 
0A11E:  CP0     14B2
0A120:  BRA     Z,A12E
.................... 	                  { 
.................... 	                  if(Team)//pt droite 
0A122:  BTSS.B  85B.3
0A124:  BRA     A12E
.................... 	                  { 
.................... 	                     if(Pt_commun==1) NoPts++; // passe Ã  l'obj suivant (pt droite) 
0A126:  MOV     14B2,W4
0A128:  CP      W4,#1
0A12A:  BRA     NZ,A12E
0A12C:  INC.B   0874
.................... 	                  } 
.................... 	                  } 
.................... 	                  Etat_rob = Init; // on recommence le programme 
0A12E:  CLR.B   875
.................... 	                  _Detected = 0; 
0A130:  BCLR.B  85B.0
.................... 	                  balise_on = 0; 
0A132:  BCLR.B  85B.1
.................... 	                  Dist_x = 0; 
0A134:  CLR     15B8
.................... 	                  Dist_y = 0; 
0A136:  CLR     15BA
.................... 	                  Dorient = 0;  
0A138:  CLR     15C2
0A13A:  CLR     15C4
0A13C:  CLR     15C6
0A13E:  CLR     15C8
.................... 	                  _LED2,_LED3,_LED4 = 0; 
0A140:  BCLR.B  2D0.4
.................... 	                  Time_detected=0; 
0A142:  CLR.B   86E
.................... 	               } 
.................... 	            } 
.................... 	        } 
0A144:  GOTO    A1B8
.................... 	        else if(_Detected && tempo_bal == 4) // si detecte et que l'adv n'est plus la  
0A148:  BTSS.B  85B.0
0A14A:  BRA     A1B8
0A14C:  MOV     872,W4
0A14E:  CP.B    W4L,#4
0A150:  BRA     NZ,A1B8
.................... 	        { 
.................... 	             /////////////////// Reprise de l'ordre  ///////////////////          
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 6000_^MDEC 2 6000\r");//on reprend le dernier ordre    
0A152:  MOV     #0,W1
0A154:  MOV     W1,W0
0A156:  CLR.B   1
0A158:  CALL    44C
0A15C:  INC     W1,W1
0A15E:  BTSC.B  219.1
0A160:  BRA     A15E
0A162:  MOV     W0,21A
0A164:  MOV     #19,W0
0A166:  CPSGT   W1,W0
0A168:  BRA     A154
.................... 	            fprintf(ROBOTEQ,"!S 1 %u_!S 2 %u\r",oVitMax,oVitMax); 
0A16A:  MOV     #0,W1
0A16C:  MOV     W1,W0
0A16E:  CLR.B   1
0A170:  CALL    474
0A174:  INC     W1,W1
0A176:  BTSC.B  219.1
0A178:  BRA     A176
0A17A:  MOV     W0,21A
0A17C:  MOV     #4,W0
0A17E:  CPSGT   W1,W0
0A180:  BRA     A16C
0A182:  MOV     14AE,W0
0A184:  MOV     #0,W4
0A186:  CALL    65B6
0A18A:  MOV     #7,W1
0A18C:  MOV     W1,W0
0A18E:  CLR.B   1
0A190:  CALL    474
0A194:  INC     W1,W1
0A196:  BTSC.B  219.1
0A198:  BRA     A196
0A19A:  MOV     W0,21A
0A19C:  MOV     #C,W0
0A19E:  CPSGT   W1,W0
0A1A0:  BRA     A18C
0A1A2:  MOV     14AE,W0
0A1A4:  MOV     #0,W4
0A1A6:  CALL    65B6
0A1AA:  BTSC.B  219.1
0A1AC:  BRA     A1AA
0A1AE:  MOV     #D,W4
0A1B0:  MOV     W4,21A
....................  
.................... 	            Time_detected = 0;  
0A1B2:  CLR.B   86E
.................... 	            _LED1=0; 
0A1B4:  BCLR.B  2D0.1
.................... 	            _Detected = 0; 
0A1B6:  BCLR.B  85B.0
....................              
.................... 	        } 
.................... 	        _LED1=!_LED1;  
0A1B8:  BTG.B   2D0.1
.................... 	        flagBaliseCheck = 0; 
0A1BA:  BCLR.B  85A.2
.................... 	    }    
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        UART            ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(PCh_flagUARTReadyToDecode) __UART_Decode(TabDecoded); 
0A1BC:  BTSS.B  1611.1
0A1BE:  BRA     A1C8
0A1C0:  MOV     #1714,W4
0A1C2:  MOV     W4,1B2A
0A1C4:  CALL    9574
....................  
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        Fin du prog.    ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if((Flag_end || flagTimeOut || flag_error) && !IsPassedTimeOut) 
0A1C8:  BTSC.B  85A.7
0A1CA:  BRA     A1D4
0A1CC:  BTSC.B  85A.1
0A1CE:  BRA     A1D4
0A1D0:  BTSS.B  85B.2
0A1D2:  BRA     A21E
0A1D4:  BTSC.B  85A.5
0A1D6:  BRA     A21E
.................... 		{ 
.................... 			__Afficheur_7segments(98); 
0A1D8:  MOV.B   #62,W0L
0A1DA:  MOV.B   W0L,1B2E
0A1DC:  CLR.B   1B2F
0A1DE:  CALL    1060
....................  
.................... 			IsPassedTimeOut=1; 
0A1E2:  BSET.B  85A.5
.................... 			// arret moteurs 
.................... 			fprintf(ROBOTEQ, "!EX \r");  
0A1E4:  MOV     #0,W1
0A1E6:  MOV     W1,W0
0A1E8:  CLR.B   1
0A1EA:  CALL    492
0A1EE:  INC     W1,W1
0A1F0:  BTSC.B  219.1
0A1F2:  BRA     A1F0
0A1F4:  MOV     W0,21A
0A1F6:  MOV     #4,W0
0A1F8:  CPSGT   W1,W0
0A1FA:  BRA     A1E6
.................... 			driver_moteur(0xC0,0); 
0A1FC:  MOV.B   #C0,W0L
0A1FE:  MOV.B   W0L,1B2E
0A200:  CLR.B   1B2F
0A202:  CALL    865A
.................... 			driver_moteur(0xC2,0); 
0A206:  MOV.B   #C2,W0L
0A208:  MOV.B   W0L,1B2E
0A20A:  CLR.B   1B2F
0A20C:  CALL    865A
.................... 			driver_moteur(0xC4,0); 
0A210:  MOV.B   #C4,W0L
0A212:  MOV.B   W0L,1B2E
0A214:  CLR.B   1B2F
0A216:  CALL    865A
.................... 			Etat_rob = Wait_end; 
0A21A:  MOV.B   #8,W0L
0A21C:  MOV.B   W0L,875
.................... 		}		 
.................... 	 
.................... } 
....................  
....................  
.................... /** 
.................... * \fn void TIMER1_isr(void) 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 19.10.2015 
.................... * 
.................... * \brief Met Ã  jour la pose, gÃ¨re le profil trapÃ©zoÃ¯dal et le PID 
.................... *		 S'active chaque 1 [ms] 
.................... * 
.................... */ 
.................... #INT_TIMER1 HIGH 
.................... void TIMER1_isr(void) 
*
00AB2:  PUSH    42
00AB4:  PUSH    36
00AB6:  PUSH    32
00AB8:  MOV     W0,[W15++]
00ABA:  MOV     #2,W0
00ABC:  REPEAT  #C
00ABE:  MOV     [W0++],[W15++]
*
0A21E:  BRA     A21E
.................... { 
.................... 	// Compte le temps rÃ©el 
.................... 	RealTimeMS ++; 
*
00AC0:  INC     0862
00AC2:  BTSC.B  42.1
00AC4:  INC     0864
.................... 	// Temps de jeu 
.................... 	if(BeginTimeMS!=0) 
00AC6:  CP0     866
00AC8:  BRA     NZ,ACE
00ACA:  CP0     868
00ACC:  BRA     Z,AFA
.................... 	{ 
.................... 		GameTimeMS=RealTimeMS-BeginTimeMS; 
00ACE:  MOV     862,W4
00AD0:  MOV     866,W3
00AD2:  SUB     W4,W3,W0
00AD4:  MOV     W0,86A
00AD6:  MOV     864,W4
00AD8:  MOV     868,W3
00ADA:  SUBB    W4,W3,W0
00ADC:  MOV     W0,86C
.................... 		if(GameTimeMS%1000==0)GameTimeS++; 
00ADE:  BSET.B  43.0
00AE0:  MOV     86A,W0
00AE2:  MOV     86C,W1
00AE4:  MOV     #3E8,W2
00AE6:  MOV     #0,W3
00AE8:  CALL    A5E
00AEC:  MOV     W0,W5
00AEE:  MOV     W1,W6
00AF0:  CP0     W5
00AF2:  BRA     NZ,AFA
00AF4:  CP0     W6
00AF6:  BRA     NZ,AFA
00AF8:  INC.B   0861
.................... 	}	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	//////////////////////////////////	TASK GIVER	//////////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Balise Ã  checker 
.................... 	if(GameTimeS == 92) FlagGameEnd = 1;  
00AFA:  MOV     860,W4
00AFC:  LSR     W4,#8,W4
00AFE:  XOR.B   #5C,W4L
00B00:  BRA     NZ,B04
00B02:  BSET.B  85A.0
.................... 	if(BeginTimeMS!=0 && GameTimeMS%TIME_TO_CHECK_BAL==0) 
00B04:  CP0     866
00B06:  BRA     NZ,B0C
00B08:  CP0     868
00B0A:  BRA     Z,B28
00B0C:  BSET.B  43.0
00B0E:  MOV     86A,W0
00B10:  MOV     86C,W1
00B12:  MOV     14C4,W2
00B14:  MOV     #0,W3
00B16:  CALL    A5E
00B1A:  MOV     W0,W5
00B1C:  MOV     W1,W6
00B1E:  CP0     W5
00B20:  BRA     NZ,B28
00B22:  CP0     W6
00B24:  BRA     NZ,B28
.................... 	{ 
.................... 		// Check Balise 
.................... 		flagBaliseCheck=1; 
00B26:  BSET.B  85A.2
.................... 	} 
.................... 	if(BeginTimeMS!=0 && GameTimeMS%500==0)ToDisplay=!ToDisplay; 
00B28:  CP0     866
00B2A:  BRA     NZ,B30
00B2C:  CP0     868
00B2E:  BRA     Z,B4C
00B30:  BSET.B  43.0
00B32:  MOV     86A,W0
00B34:  MOV     86C,W1
00B36:  MOV     #1F4,W2
00B38:  MOV     #0,W3
00B3A:  CALL    A5E
00B3E:  MOV     W0,W5
00B40:  MOV     W1,W6
00B42:  CP0     W5
00B44:  BRA     NZ,B4C
00B46:  CP0     W6
00B48:  BRA     NZ,B4C
00B4A:  BTG.B   85A.4
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////	WATCHDOG INTERRUPTS	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// WD Times 
.................... 	static unsigned int16 UART_WD_TIME=0; 
.................... 	 
.................... 	// Watchdog UART, rÃ©initialise la capture 
.................... 	if(PCh_flagUARTWatchdog==1) 
00B4C:  BTSS.B  1611.2
00B4E:  BRA     B6A
.................... 	{ 
.................... 		UART_WD_TIME++; 
00B50:  INC     1B26
.................... 		if(UART_WD_TIME>=UART_WD_DELAY) 
00B52:  MOV.B   14BC,W0L
00B54:  CLR.B   1
00B56:  MOV     1B26,W4
00B58:  CP      W4,W0
00B5A:  BRA     NC,B66
.................... 		{ 
.................... 			// Reset UART 
.................... 			ToDoUART = 0; 
00B5C:  CLR.B   1713
.................... 			PosTabToDecode=0; 
00B5E:  CLR.B   1712
.................... 			UARTToSendBack=0; 
00B60:  CLR.B   1B14
.................... 			UARTWaitResp=0; 
00B62:  BCLR.B  1611.3
.................... 			// Desactive le watchdog UART 
.................... 			PCh_flagUARTWatchdog = 0; 
00B64:  BCLR.B  1611.2
.................... 		} 
.................... 	} 
00B66:  GOTO    B6C
.................... 	else UART_WD_TIME=0; 
00B6A:  CLR     1B26
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////		PROGRAM END		//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// AprÃ¨s 1min30, on arrÃªte les Ã©lÃ©ments essentiels 
.................... 	if(BeginTimeMS!=0 && GameTimeS>=88) 
00B6C:  CP0     866
00B6E:  BRA     NZ,B74
00B70:  CP0     868
00B72:  BRA     Z,B80
00B74:  MOV     860,W4
00B76:  LSR     W4,#8,W4
00B78:  MOV     #58,W3
00B7A:  CP.B    W3L,W4L
00B7C:  BRA     GTU,B80
.................... 	{ 
.................... 		flagTimeOut=1; 
00B7E:  BSET.B  85A.1
.................... 	} 
.................... 	// AprÃ¨s la fin de jeu, on ouvre le parasol  
.................... 	if(BeginTimeMS!=0 && GameTimeS>=92) 
00B80:  CP0     866
00B82:  BRA     NZ,B88
00B84:  CP0     868
00B86:  BRA     Z,B94
00B88:  MOV     860,W4
00B8A:  LSR     W4,#8,W4
00B8C:  MOV     #5C,W3
00B8E:  CP.B    W3L,W4L
00B90:  BRA     GTU,B94
.................... 	{ 
.................... 		flagGameEnd=1; 
00B92:  BSET.B  85A.0
.................... 	}	 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... //// Timer de clignotement d'erreur. //// 
.................... //////////////////////////////////////// 
00B94:  BCLR.B  84.3
00B96:  MOV     #1A,W0
00B98:  REPEAT  #C
00B9A:  MOV     [--W15],[W0--]
00B9C:  MOV     [--W15],W0
00B9E:  POP     32
00BA0:  POP     36
00BA2:  POP     42
00BA4:  RETFIE  
.................... #INT_TIMER3 
.................... void TIMER3_isr(void) 
00BA6:  PUSH    42
00BA8:  PUSH    36
00BAA:  PUSH    32
00BAC:  MOV     W0,[W15++]
00BAE:  MOV     #2,W0
00BB0:  REPEAT  #C
00BB2:  MOV     [W0++],[W15++]
.................... { 
.................... 	static int1 On_Off_Error = 0; 
.................... 	 
.................... 	// Si doit afficher une erreur 
.................... 	if(flagError) 
00BB4:  BTSS.B  85A.3
00BB6:  BRA     BBA
.................... 	{ 
.................... 	//	__Afficheur_7segments(NO_ERROR,On_Off_Error); 
.................... 		On_Off_Error =! On_Off_Error; 
00BB8:  BTG.B   1611.4
.................... 	}	 
00BBA:  BCLR.B  84.7
00BBC:  MOV     #1A,W0
00BBE:  REPEAT  #C
00BC0:  MOV     [--W15],[W0--]
00BC2:  MOV     [--W15],W0
00BC4:  POP     32
00BC6:  POP     36
00BC8:  POP     42
00BCA:  RETFIE  
.................... }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

Configuration Fuses:
   Word  1L: C712   HS2_PLL8
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8730   NOPUT BORRES NOBROWNOUT MCLR
          H: 0000  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: 0000  
   Word  6L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  7L: 4003   ICSP1 DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
