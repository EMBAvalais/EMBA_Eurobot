CCS PCD C Compiler, Version 5.074, 38375               24-nov.-17 13:48

               Filename:   D:\Années\2017 - MoonVillage\Programmation\Grand robot\90_Carte principale\Carte principale\main.lst

               ROM used:   24992 bytes (25%)
                           Largest free fragment is 40544
               RAM used:   6626 (82%) at main() level
                           6927 (85%) worst case
               Stack used: 112 locations (50 in main + 62 for interrupts)
               Stack size: 2048

*
00000:  GOTO    58D8
*
0001A:  DATA    A6,0A,00
00020:  DATA    58,05,00
00022:  DATA    9A,0B,00
00026:  DATA    DA,08,00
*
00044:  DATA    7E,05,00
.................... /* 
.................... ==================================================================================================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*==================================================================================================== 
.................... =											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy				  												== 
.................... ===  Date				: 8.6.2017																	== 
.................... ===  Nom du programme 	: InterfaceRoboteQ.mcp (fichier main.c)										== 
.................... ===  Version 			: V2.0.0.0.0																== 
.................... =====================================================================================================*/ 
....................  
.................... #include <30F6014A.h> 
.................... //////////// Standard Header file for the DSPIC30F6014A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014A 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    52,45,00
0010E:  DATA    53,45,00
00110:  DATA    54,20,00
00112:  DATA    33,32,00
00114:  DATA    31,36,00
00116:  DATA    35,34,00
00118:  DATA    39,38,00
0011A:  DATA    37,20,00
0011C:  DATA    0D,00,00
0011E:  CLR     32
00120:  MOV     #12A,W3
00122:  ADD     W3,W0,W0
00124:  TBLRDL.B[W0],W0L
00126:  CLR.B   1
00128:  RETURN  
0012A:  DATA    7E,4B,00
0012C:  DATA    50,20,00
0012E:  DATA    31,20,00
00130:  DATA    0D,00,00
00132:  CLR     32
00134:  MOV     #13E,W3
00136:  ADD     W3,W0,W0
00138:  TBLRDL.B[W0],W0L
0013A:  CLR.B   1
0013C:  RETURN  
0013E:  DATA    7E,4B,00
00140:  DATA    49,20,00
00142:  DATA    31,20,00
00144:  DATA    0D,00,00
00146:  CLR     32
00148:  MOV     #152,W3
0014A:  ADD     W3,W0,W0
0014C:  TBLRDL.B[W0],W0L
0014E:  CLR.B   1
00150:  RETURN  
00152:  DATA    7E,4B,00
00154:  DATA    44,20,00
00156:  DATA    31,20,00
00158:  DATA    0D,00,00
0015A:  CLR     32
0015C:  MOV     #166,W3
0015E:  ADD     W3,W0,W0
00160:  TBLRDL.B[W0],W0L
00162:  CLR.B   1
00164:  RETURN  
00166:  DATA    7E,4B,00
00168:  DATA    50,20,00
0016A:  DATA    32,20,00
0016C:  DATA    0D,00,00
0016E:  CLR     32
00170:  MOV     #17A,W3
00172:  ADD     W3,W0,W0
00174:  TBLRDL.B[W0],W0L
00176:  CLR.B   1
00178:  RETURN  
0017A:  DATA    7E,4B,00
0017C:  DATA    49,20,00
0017E:  DATA    32,20,00
00180:  DATA    0D,00,00
00182:  CLR     32
00184:  MOV     #18E,W3
00186:  ADD     W3,W0,W0
00188:  TBLRDL.B[W0],W0L
0018A:  CLR.B   1
0018C:  RETURN  
0018E:  DATA    7E,4B,00
00190:  DATA    44,20,00
00192:  DATA    32,20,00
00194:  DATA    0D,00,00
00196:  CLR     32
00198:  MOV     #1A2,W3
0019A:  ADD     W3,W0,W0
0019C:  TBLRDL.B[W0],W0L
0019E:  CLR.B   1
001A0:  RETURN  
001A2:  DATA    7E,4D,00
001A4:  DATA    41,43,00
001A6:  DATA    20,31,00
001A8:  DATA    20,0D,00
001AA:  DATA    00,00,00
001AC:  CLR     32
001AE:  MOV     #1B8,W3
001B0:  ADD     W3,W0,W0
001B2:  TBLRDL.B[W0],W0L
001B4:  CLR.B   1
001B6:  RETURN  
001B8:  DATA    7E,4D,00
001BA:  DATA    44,45,00
001BC:  DATA    43,20,00
001BE:  DATA    31,20,00
001C0:  DATA    0D,00,00
001C2:  CLR     32
001C4:  MOV     #1CE,W3
001C6:  ADD     W3,W0,W0
001C8:  TBLRDL.B[W0],W0L
001CA:  CLR.B   1
001CC:  RETURN  
001CE:  DATA    7E,4D,00
001D0:  DATA    41,43,00
001D2:  DATA    20,32,00
001D4:  DATA    20,0D,00
001D6:  DATA    00,00,00
001D8:  CLR     32
001DA:  MOV     #1E4,W3
001DC:  ADD     W3,W0,W0
001DE:  TBLRDL.B[W0],W0L
001E0:  CLR.B   1
001E2:  RETURN  
001E4:  DATA    7E,4D,00
001E6:  DATA    44,45,00
001E8:  DATA    43,20,00
001EA:  DATA    32,20,00
001EC:  DATA    0D,00,00
001EE:  CLR     32
001F0:  MOV     #26,W3
001F2:  SUB     W0,W3,W3
001F4:  BRA     C,200
001F6:  MOV     #20A,W3
001F8:  ADD     W3,W0,W0
001FA:  TBLRDL.B[W0],W0L
001FC:  CLR.B   1
001FE:  RETURN  
00200:  MOV     #20A,W0
00202:  ADD     W3,W3,W3
00204:  ADD     W3,W0,W3
00206:  TBLRDH  [W3],W0
00208:  RETURN  
0020A:  DATA    5E,4B,49
0020C:  DATA    50,20,20
0020E:  DATA    31,20,32
00210:  DATA    25,75,20
00212:  DATA    5F,5E,25
00214:  DATA    4B,49,75
00216:  DATA    20,31,5F
00218:  DATA    20,25,5E
0021A:  DATA    75,5F,4B
0021C:  DATA    5E,4B,44
0021E:  DATA    44,20,20
00220:  DATA    31,20,32
00222:  DATA    25,75,20
00224:  DATA    5F,5E,25
00226:  DATA    4B,50,75
00228:  DATA    20,32,20
0022A:  DATA    20,25,0D
0022C:  DATA    75,5F,00
0022E:  DATA    5E,4B,00
00230:  CLR     32
00232:  MOV     #1E,W3
00234:  SUB     W0,W3,W3
00236:  BRA     C,242
00238:  MOV     #24C,W3
0023A:  ADD     W3,W0,W0
0023C:  TBLRDL.B[W0],W0L
0023E:  CLR.B   1
00240:  RETURN  
00242:  MOV     #24C,W0
00244:  ADD     W3,W3,W3
00246:  ADD     W3,W0,W3
00248:  TBLRDH  [W3],W0
0024A:  RETURN  
0024C:  DATA    5E,4D,5F
0024E:  DATA    41,43,5E
00250:  DATA    20,31,4D
00252:  DATA    20,25,44
00254:  DATA    75,5F,45
00256:  DATA    5E,4D,43
00258:  DATA    44,45,20
0025A:  DATA    43,20,32
0025C:  DATA    31,20,20
0025E:  DATA    25,75,25
00260:  DATA    5F,5E,75
00262:  DATA    4D,41,20
00264:  DATA    43,20,0D
00266:  DATA    32,20,00
00268:  DATA    25,75,00
0026A:  CLR     32
0026C:  MOV     #276,W3
0026E:  ADD     W3,W0,W0
00270:  TBLRDL.B[W0],W0L
00272:  CLR.B   1
00274:  RETURN  
00276:  DATA    45,45,00
00278:  DATA    53,41,00
0027A:  DATA    56,20,00
0027C:  DATA    0D,00,00
0027E:  CLR     32
00280:  MOV     #28A,W3
00282:  ADD     W3,W0,W0
00284:  TBLRDL.B[W0],W0L
00286:  CLR.B   1
00288:  RETURN  
0028A:  DATA    3F,44,00
0028C:  DATA    52,0D,00
0028E:  DATA    00,00,00
00290:  CLR     32
00292:  MOV     #29C,W3
00294:  ADD     W3,W0,W0
00296:  TBLRDL.B[W0],W0L
00298:  CLR.B   1
0029A:  RETURN  
0029C:  DATA    3F,41,00
0029E:  DATA    20,31,00
002A0:  DATA    0D,00,00
002A2:  CLR     32
002A4:  MOV     #2AE,W3
002A6:  ADD     W3,W0,W0
002A8:  TBLRDL.B[W0],W0L
002AA:  CLR.B   1
002AC:  RETURN  
002AE:  DATA    3F,41,00
002B0:  DATA    20,32,00
002B2:  DATA    0D,00,00
002B4:  CLR     32
002B6:  MOV     #2C0,W3
002B8:  ADD     W3,W0,W0
002BA:  TBLRDL.B[W0],W0L
002BC:  CLR.B   1
002BE:  RETURN  
002C0:  DATA    21,53,00
002C2:  DATA    20,31,00
002C4:  DATA    20,25,00
002C6:  DATA    30,34,00
002C8:  DATA    75,5F,00
002CA:  DATA    21,53,00
002CC:  DATA    20,32,00
002CE:  DATA    20,25,00
002D0:  DATA    30,34,00
002D2:  DATA    75,20,00
002D4:  DATA    0D,00,00
002D6:  CLR     32
002D8:  MOV     #2E2,W3
002DA:  ADD     W3,W0,W0
002DC:  TBLRDL.B[W0],W0L
002DE:  CLR.B   1
002E0:  RETURN  
002E2:  DATA    21,50,00
002E4:  DATA    52,20,00
002E6:  DATA    31,20,00
002E8:  DATA    25,64,00
002EA:  DATA    5F,21,00
002EC:  DATA    50,52,00
002EE:  DATA    20,32,00
002F0:  DATA    20,25,00
002F2:  DATA    64,20,00
002F4:  DATA    0D,00,00
002F6:  CLR     32
002F8:  MOV     #302,W3
002FA:  ADD     W3,W0,W0
002FC:  TBLRDL.B[W0],W0L
002FE:  CLR.B   1
00300:  RETURN  
00302:  DATA    21,53,00
00304:  DATA    20,31,00
00306:  DATA    20,33,00
00308:  DATA    30,30,00
0030A:  DATA    5F,21,00
0030C:  DATA    53,20,00
0030E:  DATA    32,20,00
00310:  DATA    33,30,00
00312:  DATA    30,0D,00
00314:  DATA    00,00,00
00316:  CLR     32
00318:  MOV     #322,W3
0031A:  ADD     W3,W0,W0
0031C:  TBLRDL.B[W0],W0L
0031E:  CLR.B   1
00320:  RETURN  
00322:  DATA    21,50,00
00324:  DATA    52,20,00
00326:  DATA    31,20,00
00328:  DATA    31,5F,00
0032A:  DATA    21,50,00
0032C:  DATA    52,20,00
0032E:  DATA    32,20,00
00330:  DATA    31,0D,00
00332:  DATA    00,00,00
00334:  CLR     32
00336:  MOV     #340,W3
00338:  ADD     W3,W0,W0
0033A:  TBLRDL.B[W0],W0L
0033C:  CLR.B   1
0033E:  RETURN  
00340:  DATA    21,50,00
00342:  DATA    52,20,00
00344:  DATA    31,20,00
00346:  DATA    25,30,00
00348:  DATA    37,64,00
0034A:  DATA    5F,21,00
0034C:  DATA    50,52,00
0034E:  DATA    20,32,00
00350:  DATA    20,25,00
00352:  DATA    30,37,00
00354:  DATA    64,20,00
00356:  DATA    0D,00,00
00358:  CLR     32
0035A:  MOV     #364,W3
0035C:  ADD     W3,W0,W0
0035E:  TBLRDL.B[W0],W0L
00360:  CLR.B   1
00362:  RETURN  
00364:  DATA    21,4D,00
00366:  DATA    53,20,00
00368:  DATA    31,0D,00
0036A:  DATA    00,00,00
0036C:  CLR     32
0036E:  MOV     #378,W3
00370:  ADD     W3,W0,W0
00372:  TBLRDL.B[W0],W0L
00374:  CLR.B   1
00376:  RETURN  
00378:  DATA    21,4D,00
0037A:  DATA    53,20,00
0037C:  DATA    32,0D,00
0037E:  DATA    00,00,00
00380:  CLR     32
00382:  MOV     #38C,W3
00384:  ADD     W3,W0,W0
00386:  TBLRDL.B[W0],W0L
00388:  CLR.B   1
0038A:  RETURN  
0038C:  DATA    5E,4D,00
0038E:  DATA    4D,4F,00
00390:  DATA    44,20,00
00392:  DATA    31,20,00
00394:  DATA    30,5F,00
00396:  DATA    5E,4D,00
00398:  DATA    4D,4F,00
0039A:  DATA    44,20,00
0039C:  DATA    32,20,00
0039E:  DATA    30,0D,00
003A0:  DATA    00,00,00
003A2:  CLR     32
003A4:  MOV     #3AE,W3
003A6:  ADD     W3,W0,W0
003A8:  TBLRDL.B[W0],W0L
003AA:  CLR.B   1
003AC:  RETURN  
003AE:  DATA    5E,4D,00
003B0:  DATA    4D,4F,00
003B2:  DATA    44,20,00
003B4:  DATA    31,20,00
003B6:  DATA    33,5F,00
003B8:  DATA    5E,4D,00
003BA:  DATA    4D,4F,00
003BC:  DATA    44,20,00
003BE:  DATA    32,20,00
003C0:  DATA    33,0D,00
003C2:  DATA    00,00,00
003C4:  CLR     32
003C6:  MOV     #3D0,W3
003C8:  ADD     W3,W0,W0
003CA:  TBLRDL.B[W0],W0L
003CC:  CLR.B   1
003CE:  RETURN  
003D0:  DATA    43,61,00
003D2:  DATA    72,74,00
003D4:  DATA    65,20,00
003D6:  DATA    50,72,00
003D8:  DATA    69,6E,00
003DA:  DATA    63,69,00
003DC:  DATA    70,61,00
003DE:  DATA    6C,65,00
003E0:  DATA    20,3A,00
003E2:  DATA    20,43,00
003E4:  DATA    6F,6D,00
003E6:  DATA    6D,61,00
003E8:  DATA    6E,64,00
003EA:  DATA    65,20,00
003EC:  DATA    49,6E,00
003EE:  DATA    63,6F,00
003F0:  DATA    6E,6E,00
003F2:  DATA    75,65,00
003F4:  DATA    0D,00,00
003F6:  CLR     32
003F8:  MOV     #402,W3
003FA:  ADD     W3,W0,W0
003FC:  TBLRDL.B[W0],W0L
003FE:  CLR.B   1
00400:  RETURN  
00402:  DATA    21,4D,00
00404:  DATA    47,0D,00
00406:  DATA    00,00,00
00408:  CLR     32
0040A:  MOV     #414,W3
0040C:  ADD     W3,W0,W0
0040E:  TBLRDL.B[W0],W0L
00410:  CLR.B   1
00412:  RETURN  
00414:  DATA    5E,4D,00
00416:  DATA    44,45,00
00418:  DATA    43,20,00
0041A:  DATA    31,20,00
0041C:  DATA    39,30,00
0041E:  DATA    30,30,00
00420:  DATA    5F,5E,00
00422:  DATA    4D,44,00
00424:  DATA    45,43,00
00426:  DATA    20,32,00
00428:  DATA    20,39,00
0042A:  DATA    30,30,00
0042C:  DATA    30,0D,00
0042E:  DATA    00,00,00
00430:  CLR     32
00432:  MOV     #43C,W3
00434:  ADD     W3,W0,W0
00436:  TBLRDL.B[W0],W0L
00438:  CLR.B   1
0043A:  RETURN  
0043C:  DATA    21,53,00
0043E:  DATA    20,31,00
00440:  DATA    20,30,00
00442:  DATA    5F,21,00
00444:  DATA    53,20,00
00446:  DATA    32,20,00
00448:  DATA    30,0D,00
0044A:  DATA    00,00,00
0044C:  CLR     32
0044E:  MOV     #458,W3
00450:  ADD     W3,W0,W0
00452:  TBLRDL.B[W0],W0L
00454:  CLR.B   1
00456:  RETURN  
00458:  DATA    5E,4D,00
0045A:  DATA    44,45,00
0045C:  DATA    43,20,00
0045E:  DATA    31,20,00
00460:  DATA    36,30,00
00462:  DATA    30,30,00
00464:  DATA    5F,5E,00
00466:  DATA    4D,44,00
00468:  DATA    45,43,00
0046A:  DATA    20,32,00
0046C:  DATA    20,36,00
0046E:  DATA    30,30,00
00470:  DATA    30,0D,00
00472:  DATA    00,00,00
00474:  CLR     32
00476:  MOV     #480,W3
00478:  ADD     W3,W0,W0
0047A:  TBLRDL.B[W0],W0L
0047C:  CLR.B   1
0047E:  RETURN  
00480:  DATA    21,53,00
00482:  DATA    20,31,00
00484:  DATA    20,25,00
00486:  DATA    75,5F,00
00488:  DATA    21,53,00
0048A:  DATA    20,32,00
0048C:  DATA    20,25,00
0048E:  DATA    75,0D,00
00490:  DATA    00,00,00
00492:  CLR     32
00494:  MOV     #49E,W3
00496:  ADD     W3,W0,W0
00498:  TBLRDL.B[W0],W0L
0049A:  CLR.B   1
0049C:  RETURN  
0049E:  DATA    21,45,00
004A0:  DATA    58,20,00
004A2:  DATA    0D,00,00
*
00628:  MOV     W5,[W15++]
0062A:  MOV     #C,W5
0062C:  REPEAT  #3
0062E:  MOV     [W5++],[W15++]
00630:  MUL.UU  W0,W2,W4
00632:  BTSS    W3.F
00634:  BRA     63A
00636:  MUL.SS  W0,W3,W6
00638:  BRA     63C
0063A:  MUL.UU  W0,W3,W6
0063C:  BCLR.B  42.0
0063E:  ADD     W6,W5,W5
00640:  ADDC    W7,#0,W8
00642:  BTSS    W1.F
00644:  BRA     64A
00646:  MUL.SS  W1,W2,W6
00648:  BRA     64C
0064A:  MUL.UU  W1,W2,W6
0064C:  ADDC    W6,W5,W5
0064E:  ADDC    W7,W8,W8
00650:  ADDC    #0,W9
00652:  MUL.SS  W1,W3,W6
00654:  ADDC    W6,W8,W8
00656:  ADDC    W9,W7,W7
00658:  MOV     W7,W3
0065A:  MOV     W8,W2
0065C:  MOV     W5,W1
0065E:  MOV     W4,W0
00660:  MOV     #12,W5
00662:  REPEAT  #3
00664:  MOV     [--W15],[W5--]
00666:  MOV     [--W15],W5
00668:  RETURN  
*
00A52:  MOV     W5,[W15++]
00A54:  MOV     #C,W5
00A56:  REPEAT  #3
00A58:  MOV     [W5++],[W15++]
00A5A:  MOV     #0,W9
00A5C:  BTSC.B  43.0
00A5E:  MOV     #1,W9
00A60:  MOV     W9,[W15++]
00A62:  CLR     W4
00A64:  CLR     W5
00A66:  CLR     W6
00A68:  CLR     W7
00A6A:  XOR     W2,W3,W8
00A6C:  BRA     Z,A90
00A6E:  MOV     #20,W8
00A70:  BCLR.B  42.0
00A72:  RLC     W0,W0
00A74:  RLC     W1,W1
00A76:  RLC     W4,W4
00A78:  RLC     W5,W5
00A7A:  CP      W5,W3
00A7C:  BRA     NZ,A80
00A7E:  CPB     W4,W2
00A80:  BRA     NC,A88
00A82:  SUB     W4,W2,W4
00A84:  SUBB    W5,W3,W5
00A86:  BSET.B  42.0
00A88:  RLC     W6,W6
00A8A:  RLC     W7,W7
00A8C:  DEC     W8,W8
00A8E:  BRA     NZ,A70
00A90:  MOV     W7,W1
00A92:  MOV     W6,W0
00A94:  MOV     [--W15],W9
00A96:  CP0     W9
00A98:  BRA     Z,A9C
00A9A:  MOV.D   W4,W0
00A9C:  MOV     #12,W5
00A9E:  REPEAT  #3
00AA0:  MOV     [--W15],[W5--]
00AA2:  MOV     [--W15],W5
00AA4:  RETURN  
*
00BC0:  MOV     W8,[W15++]
00BC2:  MOV     #12,W8
00BC4:  REPEAT  #4
00BC6:  MOV     [W8++],[W15++]
00BC8:  CLR     W11
00BCA:  MUL.UU  W12,#0,W12
00BCC:  MOV     W3,W8
00BCE:  MOV     W7,W9
00BD0:  MOV     #7FF,W10
00BD2:  BCLR.B  42.0
00BD4:  BCLR.B  42.1
00BD6:  ASR     W8,#4,W8
00BD8:  AND     W10,W8,W8
00BDA:  CP0     W8
00BDC:  BRA     Z,CC0
00BDE:  BCLR.B  42.0
00BE0:  BCLR.B  42.1
00BE2:  ASR     W9,#4,W9
00BE4:  AND     W10,W9,W9
00BE6:  CP0     W9
00BE8:  BRA     Z,CC0
00BEA:  ADD     W9,W8,W8
00BEC:  BTSC    W9.B
00BEE:  BRA     BF8
00BF0:  SUB     #3FF,W8
00BF2:  BRA     Z,CC0
00BF4:  BRA     NC,CC0
00BF6:  BRA     BFE
00BF8:  MOV     #401,W10
00BFA:  ADD.B   W10L,W5L,W5L
00BFC:  BRA     C,CC0
00BFE:  XOR     W3,W7,W13
00C00:  BCLR.B  42.0
00C02:  BCLR.B  42.1
00C04:  AND     #F,W3
00C06:  BSET    W3.4
00C08:  AND     #F,W7
00C0A:  BSET    W7.4
00C0C:  MOV     W8,[W15++]
00C0E:  MUL.UU  W4,W1,W8
00C10:  MUL.UU  W5,W0,W10
00C12:  ADD     W8,W10,W10
00C14:  ADDC    W9,W11,W11
00C16:  ADDC    #0,W12
00C18:  MUL.UU  W4,W2,W8
00C1A:  ADD     W8,W11,W11
00C1C:  ADDC    W9,W12,W12
00C1E:  MUL.UU  W5,W1,W8
00C20:  CLR     W10
00C22:  ADD     W8,W11,W11
00C24:  ADDC    W9,W12,W12
00C26:  ADDC    #0,W10
00C28:  MUL.UU  W6,W0,W8
00C2A:  ADD     W8,W11,W11
00C2C:  ADDC    W9,W12,W12
00C2E:  ADDC    #0,W10
00C30:  CLR     W11
00C32:  MUL.UU  W4,W3,W8
00C34:  ADD     W8,W12,W12
00C36:  ADDC    W9,W10,W10
00C38:  ADDC    #0,W11
00C3A:  MUL.UU  W5,W2,W8
00C3C:  ADD     W8,W12,W12
00C3E:  ADDC    W9,W10,W10
00C40:  ADDC    #0,W11
00C42:  MUL.UU  W6,W1,W8
00C44:  ADD     W8,W12,W12
00C46:  ADDC    W9,W10,W10
00C48:  ADDC    #0,W11
00C4A:  MUL.UU  W7,W0,W8
00C4C:  ADD     W8,W12,W12
00C4E:  ADDC    W9,W10,W10
00C50:  ADDC    #0,W11
00C52:  MOV     W12,W0
00C54:  CLR     W12
00C56:  MUL.UU  W5,W3,W8
00C58:  ADD     W8,W10,W10
00C5A:  ADDC    W9,W11,W11
00C5C:  ADDC    #0,W12
00C5E:  MUL.UU  W6,W2,W8
00C60:  ADD     W8,W10,W10
00C62:  ADDC    W9,W11,W11
00C64:  ADDC    #0,W12
00C66:  MUL.UU  W6,W3,W8
00C68:  ADD     W8,W11,W11
00C6A:  ADDC    W9,W12,W12
00C6C:  MUL.UU  W7,W1,W8
00C6E:  ADD     W8,W10,W10
00C70:  ADDC    W9,W11,W11
00C72:  ADDC    #0,W12
00C74:  MUL.UU  W7,W2,W8
00C76:  ADD     W8,W11,W11
00C78:  ADDC    W9,W12,W12
00C7A:  MUL.UU  W7,W3,W8
00C7C:  ADD     W8,W12,W12
00C7E:  MOV     W10,W1
00C80:  MOV     W11,W2
00C82:  MOV     W12,W3
00C84:  MOV     #5,W4
00C86:  BCLR.B  42.0
00C88:  RRC     W3,W3
00C8A:  RRC     W2,W2
00C8C:  RRC     W1,W1
00C8E:  RRC     W0,W0
00C90:  DEC     W4,W4
00C92:  BRA     NZ,C86
00C94:  MOV     [--W15],W8
00C96:  INC     W8,W8
00C98:  IOR      W0,  W1,W6
00C9A:  BRA     Z,C9E
00C9C:  BRA     CA2
00C9E:  IOR      W2,  W3,W6
00CA0:  BRA     Z,CB2
00CA2:  BTSC    W3.4
00CA4:  BRA     CB2
00CA6:  BCLR.B  42.0
00CA8:  RLC     W0,W0
00CAA:  RLC     W1,W1
00CAC:  RLC     W2,W2
00CAE:  RLC     W3,W3
00CB0:  DEC     W8,W8
00CB2:  SL      W8,#4,W8
00CB4:  BCLR    W3.F
00CB6:  BTSC    W13.F
00CB8:  BSET    W3.F
00CBA:  BCLR    W3.4
00CBC:  XOR     W8,W3,W3
00CBE:  BRA     CC6
00CC0:  MUL.UU  W0,#0,W0
00CC2:  MUL.UU  W0,#0,W2
00CC4:  BRA     CC6
00CC6:  MOV     #1A,W8
00CC8:  REPEAT  #4
00CCA:  MOV     [--W15],[W8--]
00CCC:  MOV     [--W15],W8
00CCE:  RETURN  
00CD0:  MOV     W8,[W15++]
00CD2:  MOV     #12,W8
00CD4:  REPEAT  #4
00CD6:  MOV     [W8++],[W15++]
00CD8:  XOR     W3,W7,W13
00CDA:  MOV     W3,W8
00CDC:  MOV     W7,W9
00CDE:  MOV     #7FF,W10
00CE0:  BCLR.B  42.0
00CE2:  BCLR.B  42.1
00CE4:  ASR     W8,#4,W8
00CE6:  AND     W10,W8,W8
00CE8:  CP0     W8
00CEA:  BRA     Z,DC4
00CEC:  BCLR.B  42.0
00CEE:  BCLR.B  42.1
00CF0:  ASR     W9,#4,W9
00CF2:  AND     W10,W9,W9
00CF4:  CP0     W9
00CF6:  BRA     Z,DC4
00CF8:  CLR     W10
00CFA:  SUB     W8,W9,W12
00CFC:  BRA     NC,D04
00CFE:  ADD     #3FF,W12
00D00:  BRA     C,DC4
00D02:  BRA     D0C
00D04:  MOV     #401,W11
00D06:  SUB     W12,W11,W12
00D08:  BRA     NC,DC4
00D0A:  BRA     Z,DC4
00D0C:  CLR     W8
00D0E:  CLR     W9
00D10:  CLR     W10
00D12:  CLR     W11
00D14:  AND     #1F,W3
00D16:  BSET    W3.4
00D18:  AND     #1F,W7
00D1A:  BSET    W7.4
00D1C:  MOV     W12,[W15++]
00D1E:  MOV     #36,W12
00D20:  SUB     W0,W4,W0
00D22:  SUBB    W1,W5,W1
00D24:  SUBB    W2,W6,W2
00D26:  SUBB    W3,W7,W3
00D28:  BRA     N,D2E
00D2A:  BRA     C,D38
00D2C:  BRA     NZ,D3A
00D2E:  ADD     W0,W4,W0
00D30:  ADDC    W1,W5,W1
00D32:  ADDC    W2,W6,W2
00D34:  ADDC    W3,W7,W3
00D36:  BRA     D3A
00D38:  BSET    W8.0
00D3A:  DEC     W12,W12
00D3C:  BRA     Z,D54
00D3E:  BCLR.B  42.0
00D40:  RLC     W0,W0
00D42:  RLC     W1,W1
00D44:  RLC     W2,W2
00D46:  RLC     W3,W3
00D48:  BCLR.B  42.0
00D4A:  RLC     W8,W8
00D4C:  RLC     W9,W9
00D4E:  RLC     W10,W10
00D50:  RLC     W11,W11
00D52:  BRA     D20
00D54:  MOV     [--W15],W12
00D56:  BTSC    W11.5
00D58:  BRA     D5C
00D5A:  BRA     D68
00D5C:  BCLR.B  42.0
00D5E:  RRC     W11,W11
00D60:  RRC     W10,W10
00D62:  RRC     W9,W9
00D64:  RRC     W8,W8
00D66:  BRA     D6E
00D68:  DEC     W12,W12
00D6A:  BCLR.B  42.0
00D6C:  BRA     Z,DC4
00D6E:  BTSC.B  42.0
00D70:  BRA     D84
00D72:  RLC     W0,W0
00D74:  RLC     W1,W1
00D76:  RLC     W2,W2
00D78:  RLC     W3,W3
00D7A:  SUB     W0,W4,W4
00D7C:  SUBB    W1,W5,W5
00D7E:  SUBB    W2,W6,W6
00D80:  SUBB    W3,W7,W7
00D82:  BRA     NC,DAE
00D84:  INC     W8,W8
00D86:  BRA     NZ,DAE
00D88:  INC     W9,W9
00D8A:  BRA     NZ,DAE
00D8C:  INC     W10,W10
00D8E:  BRA     NZ,DAE
00D90:  INC     W11,W11
00D92:  BRA     NZ,DAE
00D94:  INC     W12,W12
00D96:  BRA     Z,DC4
00D98:  BRA     DAE
00D9A:  DEC     W12,W12
00D9C:  BRA     Z,DC4
00D9E:  BTSC    W11.4
00DA0:  BRA     DAE
00DA2:  BCLR.B  42.0
00DA4:  RLC     W8,W8
00DA6:  RLC     W9,W9
00DA8:  RLC     W10,W10
00DAA:  RLC     W11,W11
00DAC:  BRA     D9E
00DAE:  SL      W12,#4,W12
00DB0:  BCLR.B  42.0
00DB2:  BCLR    W12.F
00DB4:  BTSC    W13.F
00DB6:  BSET    W12.F
00DB8:  BCLR    W11.4
00DBA:  XOR     W12,W11,W3
00DBC:  MOV     W10,W2
00DBE:  MOV     W9,W1
00DC0:  MOV     W8,W0
00DC2:  BRA     DCE
00DC4:  MOV     #0,W0
00DC6:  MOV     #0,W1
00DC8:  MOV     #0,W2
00DCA:  MOV     #0,W3
00DCC:  BRA     DCE
00DCE:  MOV     #1A,W8
00DD0:  REPEAT  #4
00DD2:  MOV     [--W15],[W8--]
00DD4:  MOV     [--W15],W8
00DD6:  RETURN  
*
01A24:  MOV     #F000,W1
01A26:  ADD     W1,W3,W3
01A28:  MOV     #7F,W1
01A2A:  ADDC    W1,#0,W1
01A2C:  MOV     W1,32
01A2E:  BCLR    W5.0
01A30:  CP0     W5
01A32:  BRA     Z,1A3A
01A34:  TBLRDL  [W3++],[W4++]
01A36:  DEC2    W5,W5
01A38:  BRA     NZ,1A32
01A3A:  RETURN  
*
01AD6:  MOV     W5,[W15++]
01AD8:  MOV     #C,W5
01ADA:  REPEAT  #3
01ADC:  MOV     [W5++],[W15++]
01ADE:  MOV     W0,W4
01AE0:  MOV     W1,W5
01AE2:  MOV     W2,W6
01AE4:  MOV     W3,W7
01AE6:  CLR     W0
01AE8:  CLR     W1
01AEA:  CLR     W2
01AEC:  CLR     W3
01AEE:  BCLR    W8.0
01AF0:  BTSS    W7.F
01AF2:  BRA     1B04
01AF4:  BSET    W8.0
01AF6:  COM     W7,W7
01AF8:  COM     W6,W6
01AFA:  COM     W5,W5
01AFC:  NEG     W4,W4
01AFE:  ADDC    W5,#0,W5
01B00:  ADDC    W6,#0,W6
01B02:  ADDC    W7,#0,W7
01B04:  IOR      W4,  W5,W9
01B06:  BRA     NZ,1B0C
01B08:  IOR      W6,  W7,W9
01B0A:  BRA     Z,1B36
01B0C:  MOV     #473,W9
01B0E:  BTSC    W3.4
01B10:  BRA     1B28
01B12:  BCLR.B  42.0
01B14:  RLC     W4,W4
01B16:  RLC     W5,W5
01B18:  RLC     W6,W6
01B1A:  RLC     W7,W7
01B1C:  RLC     W0,W0
01B1E:  RLC     W1,W1
01B20:  RLC     W2,W2
01B22:  RLC     W3,W3
01B24:  DEC     W9,W9
01B26:  BRA     NZ,1B0E
01B28:  SL      W9,#4,W9
01B2A:  BCLR.B  42.0
01B2C:  BCLR    W9.F
01B2E:  BCLR    W3.4
01B30:  XOR     W9,W3,W3
01B32:  BTSC    W8.0
01B34:  BSET    W3.F
01B36:  MOV     #12,W5
01B38:  REPEAT  #3
01B3A:  MOV     [--W15],[W5--]
01B3C:  MOV     [--W15],W5
01B3E:  RETURN  
*
01BEA:  MOV     W8,[W15++]
01BEC:  MOV     #12,W8
01BEE:  REPEAT  #4
01BF0:  MOV     [W8++],[W15++]
01BF2:  MOV     #8000,W8
01BF4:  BTSC.B  43.0
01BF6:  XOR     W8,W7,W7
01BF8:  CP0     W0
01BFA:  BRA     NZ,1C0A
01BFC:  CP0     W1
01BFE:  BRA     NZ,1C0A
01C00:  CP0     W2
01C02:  BRA     NZ,1C0A
01C04:  MOV     #7FFF,W10
01C06:  AND     W3,W10,W10
01C08:  BTSS.B  42.1
01C0A:  MOV     W3,W10
01C0C:  XOR     W7,W10,W11
01C0E:  MOV     W3,W8
01C10:  MOV     W7,W9
01C12:  MOV     W7,W12
01C14:  MOV     #7FF,W13
01C16:  BCLR.B  42.1
01C18:  BCLR.B  42.0
01C1A:  ASR     W8,#4,W8
01C1C:  AND     W13,W8,W8
01C1E:  CP0     W8
01C20:  BRA     Z,1D9A
01C22:  BCLR.B  42.1
01C24:  BCLR.B  42.0
01C26:  ASR     W9,#4,W9
01C28:  AND     W13,W9,W9
01C2A:  CP0     W9
01C2C:  BRA     Z,1DAA
01C2E:  CLR     W13
01C30:  BCLR.B  42.1
01C32:  BCLR.B  42.0
01C34:  CP      W9,W8
01C36:  BRA     Z,1DAC
01C38:  BRA     N,1DBC
01C3A:  BCLR    W13.0
01C3C:  BSET    W13.1
01C3E:  SUB     W9,W8,W8
01C40:  AND     #F,W3
01C42:  BSET    W3.4
01C44:  AND     #F,W7
01C46:  BSET    W7.4
01C48:  SUB     #34,W8
01C4A:  BRA     NN,1C78
01C4C:  ADD     #34,W8
01C4E:  BCLR.B  42.1
01C50:  BCLR.B  42.0
01C52:  RRC     W3,W3
01C54:  RRC     W2,W2
01C56:  RRC     W1,W1
01C58:  RRC     W0,W0
01C5A:  DEC     W8,W8
01C5C:  BRA     NZ,1C4E
01C5E:  BRA     1C88
01C60:  SUB     #34,W8
01C62:  BRA     NN,1C82
01C64:  ADD     #34,W8
01C66:  BCLR.B  42.1
01C68:  BCLR.B  42.0
01C6A:  RRC     W7,W7
01C6C:  RRC     W6,W6
01C6E:  RRC     W5,W5
01C70:  RRC     W4,W4
01C72:  DEC     W8,W8
01C74:  BRA     NZ,1C66
01C76:  BRA     1CAE
01C78:  MOV     W4,W0
01C7A:  MOV     W5,W1
01C7C:  MOV     W6,W2
01C7E:  MOV     W7,W3
01C80:  XOR     W11,W12,W12
01C82:  BTSC    W12.F
01C84:  BTG     W11.F
01C86:  BRA     1D7A
01C88:  BTSS    W11.F
01C8A:  BRA     1CCA
01C8C:  BTSC    W13.4
01C8E:  MOV     W12,W11
01C90:  COM     W0,W0
01C92:  COM     W1,W1
01C94:  COM     W2,W2
01C96:  COM.B   W3L,W3L
01C98:  AND.B   #1F,W3L
01C9A:  INC     W0,W0
01C9C:  BRA     NZ,1CA8
01C9E:  INC     W1,W1
01CA0:  BRA     NZ,1CA8
01CA2:  INC     W2,W2
01CA4:  BRA     NZ,1CA8
01CA6:  INC.B   W3L,W3L
01CA8:  BTSC    W13.4
01CAA:  BRA     1D10
01CAC:  BRA     1CCA
01CAE:  BTSS    W11.F
01CB0:  BRA     1CCA
01CB2:  COM     W4,W4
01CB4:  COM     W5,W5
01CB6:  COM     W6,W6
01CB8:  COM.B   W7L,W7L
01CBA:  AND.B   #1F,W7L
01CBC:  INC     W4,W4
01CBE:  BRA     NZ,1CCA
01CC0:  INC     W5,W5
01CC2:  BRA     NZ,1CCA
01CC4:  INC     W6,W6
01CC6:  BRA     NZ,1CCA
01CC8:  INC.B   W7L,W7L
01CCA:  BCLR.B  42.1
01CCC:  BCLR.B  42.0
01CCE:  ADD     W0,W4,W0
01CD0:  ADDC    W1,W5,W1
01CD2:  ADDC    W2,W6,W2
01CD4:  ADDC.B  W3L,W7L,W3L
01CD6:  BTSC    W3.5
01CD8:  BSET    W13.3
01CDA:  BTSC    W13.0
01CDC:  BRA     1CF0
01CDE:  BTSC    W13.1
01CE0:  BRA     1CE4
01CE2:  BRA     1CFA
01CE4:  BTSC    W11.F
01CE6:  BRA     1D10
01CE8:  BTSC    W13.3
01CEA:  BRA     1D3E
01CEC:  BSET    W13.6
01CEE:  BRA     1D32
01CF0:  BTSC    W11.F
01CF2:  BRA     1D10
01CF4:  BTSC    W13.3
01CF6:  BRA     1D3E
01CF8:  BRA     1D32
01CFA:  BTSC    W11.F
01CFC:  BRA     1D06
01CFE:  MOV     W10,W11
01D00:  BTSC    W13.3
01D02:  BRA     1D3E
01D04:  BRA     1D7A
01D06:  BSET    W13.4
01D08:  XOR.B   #10,W3L
01D0A:  BTSC    W3.4
01D0C:  BRA     1C8C
01D0E:  MOV     W10,W11
01D10:  AND     #1F,W3
01D12:  IOR      W3,  W2,W8
01D14:  BRA     NZ,1D1A
01D16:  IOR      W1,  W0,W8
01D18:  BRA     Z,1D32
01D1A:  BTSC    W3.4
01D1C:  BRA     1D32
01D1E:  BCLR.B  42.1
01D20:  BCLR.B  42.0
01D22:  RLC     W0,W0
01D24:  RLC     W1,W1
01D26:  RLC     W2,W2
01D28:  RLC     W3,W3
01D2A:  DEC     W9,W9
01D2C:  BTSC.B  42.1
01D2E:  BRA     1D94
01D30:  BRA     1D1A
01D32:  BTSC    W13.0
01D34:  MOV     W10,W11
01D36:  BTSC    W13.1
01D38:  MOV     W12,W11
01D3A:  BTSS    W13.5
01D3C:  BRA     1D7A
01D3E:  BCLR.B  42.0
01D40:  RRC.B   W3L,W3L
01D42:  RRC     W2,W2
01D44:  RRC     W1,W1
01D46:  RRC     W0,W0
01D48:  BTSC.B  42.0
01D4A:  BSET    W13.5
01D4C:  INC     W9,W9
01D4E:  BTSC.B  42.1
01D50:  BRA     1D94
01D52:  BTSS    W13.5
01D54:  BRA     1D72
01D56:  INC     W0,W0
01D58:  BRA     NZ,1D72
01D5A:  INC     W1,W1
01D5C:  BRA     NZ,1D72
01D5E:  INC     W2,W2
01D60:  BRA     NZ,1D72
01D62:  INC     W3,W3
01D64:  BRA     NZ,1D72
01D66:  RRC.B   W3L,W3L
01D68:  RRC     W2,W2
01D6A:  RRC     W1,W1
01D6C:  RRC     W0,W0
01D6E:  INC     W9,W9
01D70:  BRA     Z,1D94
01D72:  BTSC    W13.0
01D74:  MOV     W10,W11
01D76:  BTSC    W13.1
01D78:  MOV     W12,W11
01D7A:  IOR      W0,  W1,W4
01D7C:  BRA     NZ,1D82
01D7E:  IOR      W2,  W3,W4
01D80:  BRA     Z,1DCE
01D82:  BCLR    W3.4
01D84:  BCLR.B  42.1
01D86:  BCLR.B  42.0
01D88:  SL      W9,#4,W9
01D8A:  XOR     W9,W3,W3
01D8C:  BSET    W3.F
01D8E:  BTSS    W11.F
01D90:  BCLR    W3.F
01D92:  BRA     1DCE
01D94:  MUL.UU  W0,#0,W0
01D96:  MUL.UU  W2,#0,W2
01D98:  BRA     1DCE
01D9A:  MOV     #8000,W8
01D9C:  BTSC    W10.F
01D9E:  XOR     W8,W7,W7
01DA0:  MOV     W5,W1
01DA2:  MOV     W4,W0
01DA4:  MOV     W6,W2
01DA6:  MOV     W7,W3
01DA8:  BRA     1DCE
01DAA:  BRA     1DCE
01DAC:  AND     #F,W7
01DAE:  BSET    W7.4
01DB0:  AND     #F,W3
01DB2:  BSET    W3.4
01DB4:  BTSC    W11.F
01DB6:  BCLR    W7.4
01DB8:  BSET    W13.2
01DBA:  BRA     1CAE
01DBC:  AND     #F,W3
01DBE:  BSET    W3.4
01DC0:  AND     #F,W7
01DC2:  BSET    W7.4
01DC4:  SUB     W8,W9,W8
01DC6:  ADD     W8,W9,W9
01DC8:  BCLR    W13.1
01DCA:  BSET    W13.0
01DCC:  BRA     1C60
01DCE:  MOV     #1A,W8
01DD0:  REPEAT  #4
01DD2:  MOV     [--W15],[W8--]
01DD4:  MOV     [--W15],W8
01DD6:  RETURN  
01DD8:  MOV     W8,[W15++]
01DDA:  MOV     W9,[W15++]
01DDC:  MOV     W10,[W15++]
01DDE:  XOR     W3,W7,W9
01DE0:  BTSS    W9.F
01DE2:  BRA     1DF0
01DE4:  BCLR.B  42.0
01DE6:  BCLR.B  42.1
01DE8:  BTSS    W3.F
01DEA:  BRA     1E54
01DEC:  BSET.B  42.0
01DEE:  BRA     1E54
01DF0:  MOV     #7FF,W10
01DF2:  MOV     W3,W8
01DF4:  MOV     W7,W9
01DF6:  ASR     W8,#4,W8
01DF8:  AND     W10,W8,W8
01DFA:  ASR     W9,#4,W9
01DFC:  AND     W10,W9,W9
01DFE:  SUB     W9,W8,W10
01E00:  BRA     Z,1E0C
01E02:  BTSS    W3.F
01E04:  BRA     1E54
01E06:  MOV     #1,W0
01E08:  XOR.B   42
01E0A:  BRA     1E54
01E0C:  MOV     W3,W8
01E0E:  MOV     W7,W9
01E10:  AND     #1F,W3
01E12:  AND     #1F,W7
01E14:  BCLR    W3.4
01E16:  BCLR    W7.4
01E18:  SUB.B   W7L,W3L,W10L
01E1A:  BRA     Z,1E26
01E1C:  BTSS    W8.F
01E1E:  BRA     1E54
01E20:  MOV     #1,W0
01E22:  XOR.B   42
01E24:  BRA     1E54
01E26:  SUB     W6,W2,W10
01E28:  BRA     Z,1E34
01E2A:  BTSS    W8.F
01E2C:  BRA     1E54
01E2E:  MOV     #1,W0
01E30:  XOR.B   42
01E32:  BRA     1E54
01E34:  SUB     W5,W1,W10
01E36:  BRA     Z,1E42
01E38:  BTSS    W8.F
01E3A:  BRA     1E54
01E3C:  MOV     #1,W0
01E3E:  XOR.B   42
01E40:  BRA     1E54
01E42:  SUB     W4,W0,W10
01E44:  BRA     Z,1E50
01E46:  BTSS    W8.F
01E48:  BRA     1E54
01E4A:  MOV     #1,W0
01E4C:  XOR.B   42
01E4E:  BRA     1E54
01E50:  BCLR.B  42.0
01E52:  BRA     1E54
01E54:  MOV     [--W15],W10
01E56:  MOV     [--W15],W9
01E58:  MOV     [--W15],W8
01E5A:  RETURN  
01E5C:  MOV     W5,[W15++]
01E5E:  MOV     W6,[W15++]
01E60:  MOV     W3,W4
01E62:  MOV     W3,W6
01E64:  BCLR.B  42.0
01E66:  ASR     W4,#4,W4
01E68:  MOV     #7FF,W5
01E6A:  AND     W5,W4,W4
01E6C:  BRA     NZ,1E74
01E6E:  MUL.UU  W0,#0,W0
01E70:  CLR     W2
01E72:  BRA     1E9A
01E74:  SUB     #380,W4
01E76:  AND     #F,W3
01E78:  MOV     #3,W7
01E7A:  BCLR.B  42.0
01E7C:  RLC     W0,W0
01E7E:  RLC     W1,W1
01E80:  RLC     W2,W2
01E82:  RLC     W3,W3
01E84:  DEC     W7,W7
01E86:  BRA     NZ,1E7A
01E88:  MOV     W1,W0
01E8A:  MOV     W2,W1
01E8C:  BCLR    W3.7
01E8E:  SWAP    W4
01E90:  BCLR.B  42.0
01E92:  RRC     W4,W4
01E94:  BTSC    W6.F
01E96:  BSET    W4.F
01E98:  XOR     W4,W3,W2
01E9A:  MOV     [--W15],W6
01E9C:  MOV     [--W15],W5
01E9E:  RETURN  
01EA0:  MOV     W5,[W15++]
01EA2:  MOV     W6,[W15++]
01EA4:  MOV     W7,[W15++]
01EA6:  XOR     W1,W3,W4
01EA8:  BTSS    W4.F
01EAA:  BRA     1EB8
01EAC:  BCLR.B  42.0
01EAE:  BCLR.B  42.1
01EB0:  BTSS    W1.F
01EB2:  BRA     1F00
01EB4:  BSET.B  42.0
01EB6:  BRA     1F00
01EB8:  MOV     W1,W4
01EBA:  MOV     W0,W5
01EBC:  MOV     W3,W6
01EBE:  MOV     W2,W7
01EC0:  RLC     W1,W1
01EC2:  SWAP    W1
01EC4:  RLC     W3,W3
01EC6:  SWAP    W3
01EC8:  SUB.B   W3L,W1L,W1L
01ECA:  BRA     Z,1ED6
01ECC:  BTSS    W4.F
01ECE:  BRA     1F00
01ED0:  MOV     #1,W0
01ED2:  XOR.B   42
01ED4:  BRA     1F00
01ED6:  MOV.B   W4L,W1L
01ED8:  MOV.B   W6L,W3L
01EDA:  BCLR    W1.7
01EDC:  BCLR    W3.7
01EDE:  SUB.B   W3L,W1L,W1L
01EE0:  BRA     Z,1EEC
01EE2:  BTSS    W4.F
01EE4:  BRA     1F00
01EE6:  MOV     #1,W0
01EE8:  XOR.B   42
01EEA:  BRA     1F00
01EEC:  SUB     W7,W5,W1
01EEE:  BRA     Z,1EFA
01EF0:  BTSS    W4.F
01EF2:  BRA     1F00
01EF4:  MOV     #1,W0
01EF6:  XOR.B   42
01EF8:  BRA     1F00
01EFA:  BCLR.B  42.0
01EFC:  BRA     1F00
01EFE:  BRA     1F00
01F00:  MOV     [--W15],W7
01F02:  MOV     [--W15],W6
01F04:  MOV     [--W15],W5
01F06:  RETURN  
01F08:  MOV     W0,W2
01F0A:  MOV     W1,W3
01F0C:  MOV.B   W1L,W0L
01F0E:  SWAP    W0
01F10:  BSET    W0.F
01F12:  RLC     W1,W1
01F14:  SWAP    W1
01F16:  ZE      W1,W1
01F18:  MOV     #8E,W4
01F1A:  SUB.B   W4L,W1L,W1L
01F1C:  BRA     Z,1F2A
01F1E:  CP0     W0
01F20:  BRA     Z,1F2A
01F22:  BCLR.B  42.0
01F24:  RRC     W0,W0
01F26:  DEC     W1,W1
01F28:  BRA     NZ,1F1E
01F2A:  BTSS    W3.F
01F2C:  BRA     1F32
01F2E:  NEG     W0,W0
01F30:  BRA     1F32
01F32:  RETURN  
01F34:  MOV     W5,[W15++]
01F36:  MOV     W6,[W15++]
01F38:  MOV     #8E,W1
01F3A:  CP0     W0
01F3C:  BRA     Z,1F62
01F3E:  BTSC    W0.F
01F40:  BRA     1F4A
01F42:  BCLR.B  42.0
01F44:  RLC     W0,W0
01F46:  DEC     W1,W1
01F48:  BRA     1F3E
01F4A:  SWAP    W1
01F4C:  BCLR.B  42.0
01F4E:  RRC     W1,W1
01F50:  BCLR    W0.F
01F52:  SWAP    W0
01F54:  XOR.B   W0L,W1L,W1L
01F56:  AND.B   #0,W0L
01F58:  BRA     1F68
01F5A:  MOV.B   W1L,W0L
01F5C:  BSET    W1.7
01F5E:  AND.B   #0,W1L
01F60:  BRA     1F68
01F62:  CLR     W0
01F64:  CLR     W1
01F66:  BRA     1F68
01F68:  MOV     [--W15],W6
01F6A:  MOV     [--W15],W5
01F6C:  RETURN  
01F6E:  MOV     W5,[W15++]
01F70:  MOV     #C,W5
01F72:  REPEAT  #4
01F74:  MOV     [W5++],[W15++]
01F76:  MOV     W0,W4
01F78:  MOV     W1,W5
01F7A:  MOV     W3,W7
01F7C:  MOV     W2,W6
01F7E:  BCLR.B  42.0
01F80:  BCLR.B  42.1
01F82:  RLC     W1,W1
01F84:  SWAP    W1
01F86:  AND     #FF,W1
01F88:  CP0     W1
01F8A:  BRA     Z,2022
01F8C:  BCLR.B  42.0
01F8E:  BCLR.B  42.1
01F90:  RLC     W3,W3
01F92:  SWAP    W3
01F94:  AND     #FF,W3
01F96:  CP0     W3
01F98:  BRA     Z,2022
01F9A:  ZE      W0,W0
01F9C:  ADD.B   W3L,W1L,W0L
01F9E:  BRA     C,1FA8
01FA0:  SUB     #7F,W0
01FA2:  BRA     Z,2022
01FA4:  BRA     NC,2022
01FA6:  BRA     1FAC
01FA8:  ADD.B   #81,W0L
01FAA:  BRA     C,2022
01FAC:  XOR     W5,W7,W10
01FAE:  BCLR.B  42.0
01FB0:  BCLR.B  42.1
01FB2:  AND     #FF,W5
01FB4:  BSET    W5.7
01FB6:  BCLR.B  42.0
01FB8:  AND     #FF,W7
01FBA:  BSET    W7.7
01FBC:  MUL.UU  W4,W6,W2
01FBE:  MUL.UU  W5,W6,W8
01FC0:  ADDC    W8,W3,W3
01FC2:  MOV     W9,W1
01FC4:  BTSC.B  42.0
01FC6:  INC     W1,W1
01FC8:  BCLR.B  42.0
01FCA:  MUL.UU  W7,W4,W8
01FCC:  ADDC    W8,W3,W3
01FCE:  ADDC    W9,W1,W1
01FD0:  MUL.UU  W5,W7,W8
01FD2:  ADDC    W8,W1,W1
01FD4:  INC     W0,W0
01FD6:  CP0     W1
01FD8:  BTSC.B  42.1
01FDA:  BRA     1FDE
01FDC:  BRA     1FE4
01FDE:  CP0     W3
01FE0:  BTSC.B  42.1
01FE2:  BRA     1FEE
01FE4:  BTSC    W1.F
01FE6:  BRA     1FEE
01FE8:  RLC     W3,W3
01FEA:  RLC     W1,W1
01FEC:  DEC     W0,W0
01FEE:  MOV     W1,W2
01FF0:  BCLR.B  42.0
01FF2:  BTSS    W3.7
01FF4:  BRA     2008
01FF6:  MOV     #FF00,W7
01FF8:  AND     W3,W7,W3
01FFA:  ADD     #100,W3
01FFC:  ADDC    W2,#0,W2
01FFE:  CP0     W2
02000:  BRA     NZ,2008
02002:  CP0     W3
02004:  BRA     NZ,2008
02006:  INC     W0,W0
02008:  SWAP    W0
0200A:  BCLR.B  42.0
0200C:  BCLR.B  42.1
0200E:  RRC     W0,W1
02010:  BTSC    W10.F
02012:  BSET    W1.F
02014:  BCLR    W2.F
02016:  SWAP    W2
02018:  XOR.B   W2L,W1L,W1L
0201A:  SWAP    W3
0201C:  MOV.B   W3L,W2L
0201E:  MOV     W2,W0
02020:  BRA     2028
02022:  MOV     #0,W0
02024:  MOV     #0,W1
02026:  BRA     2028
02028:  MOV     #14,W5
0202A:  REPEAT  #4
0202C:  MOV     [--W15],[W5--]
0202E:  MOV     [--W15],W5
02030:  RETURN  
02032:  MOV     W5,[W15++]
02034:  MOV     #C,W5
02036:  REPEAT  #3
02038:  MOV     [W5++],[W15++]
0203A:  CLR     W9
0203C:  MOV     #8000,W8
0203E:  BTSC.B  43.0
02040:  XOR     W8,W3,W3
02042:  CP0     W0
02044:  BRA     NZ,204C
02046:  MOV     #7FFF,W10
02048:  AND     W1,W10,W10
0204A:  BTSS.B  42.1
0204C:  MOV     W1,W10
0204E:  XOR     W3,W10,W11
02050:  MOV     W1,W6
02052:  MOV     W3,W7
02054:  MOV     W3,W12
02056:  BCLR.B  42.1
02058:  BCLR.B  42.0
0205A:  RLC     W6,W6
0205C:  SWAP    W6
0205E:  AND     #FF,W6
02060:  CP0     W6
02062:  BRA     Z,21A6
02064:  BCLR.B  42.1
02066:  BCLR.B  42.0
02068:  RLC     W7,W7
0206A:  SWAP    W7
0206C:  AND     #FF,W7
0206E:  CP0     W7
02070:  BRA     Z,21B0
02072:  BCLR.B  42.1
02074:  BCLR.B  42.0
02076:  CP      W7,W6
02078:  BRA     Z,21B2
0207A:  BRA     N,21C2
0207C:  BCLR    W9.0
0207E:  BSET    W9.1
02080:  SUB     W7,W6,W8
02082:  MOV     W7,W6
02084:  AND     #FF,W1
02086:  BSET    W1.7
02088:  AND     #FF,W3
0208A:  BSET    W3.7
0208C:  MOV     #28,W7
0208E:  CP      W7,W8
02090:  BRA     N,20B4
02092:  BCLR.B  42.1
02094:  BCLR.B  42.0
02096:  RRC     W1,W1
02098:  RRC     W0,W0
0209A:  DEC     W8,W8
0209C:  BRA     NZ,2092
0209E:  BRA     20BA
020A0:  MOV     #28,W7
020A2:  CP      W7,W8
020A4:  BRA     N,20B8
020A6:  BCLR.B  42.1
020A8:  BCLR.B  42.0
020AA:  RRC     W3,W3
020AC:  RRC     W2,W2
020AE:  DEC     W8,W8
020B0:  BRA     NZ,20A6
020B2:  BRA     20D2
020B4:  MOV     W2,W0
020B6:  MOV     W3,W1
020B8:  BRA     2140
020BA:  BTSS    W11.F
020BC:  BRA     20E0
020BE:  BTSC    W9.4
020C0:  MOV     W12,W11
020C2:  NEG     W0,W0
020C4:  BRA     Z,20CA
020C6:  COM.B   W1L,W1L
020C8:  BRA     20CC
020CA:  NEG     W1,W1
020CC:  BTSC    W9.4
020CE:  BRA     2126
020D0:  BRA     20E0
020D2:  BTSS    W11.F
020D4:  BRA     20E0
020D6:  NEG     W2,W2
020D8:  BRA     Z,20DE
020DA:  COM.B   W3L,W3L
020DC:  BRA     20E0
020DE:  NEG     W3,W3
020E0:  AND     #FF,W5
020E2:  BCLR.B  42.1
020E4:  BCLR.B  42.0
020E6:  ADD     W0,W2,W0
020E8:  ADDC.B  W1L,W3L,W1L
020EA:  BTSC.B  42.0
020EC:  BSET    W9.3
020EE:  BTSC    W9.0
020F0:  BRA     2104
020F2:  BTSC    W9.1
020F4:  BRA     20F8
020F6:  BRA     210E
020F8:  BTSC    W11.F
020FA:  BRA     2126
020FC:  BTSC    W9.3
020FE:  BRA     2152
02100:  BSET    W9.6
02102:  BRA     2140
02104:  BTSC    W11.F
02106:  BRA     2126
02108:  BTSC    W9.3
0210A:  BRA     2152
0210C:  BRA     2140
0210E:  BCLR    W9.2
02110:  BTSC    W11.F
02112:  BRA     211C
02114:  MOV     W10,W11
02116:  BTSC    W9.3
02118:  BRA     2152
0211A:  BRA     2188
0211C:  BSET    W9.4
0211E:  XOR.B   #80,W1L
02120:  BTSC    W1.7
02122:  BRA     20BE
02124:  MOV     W10,W11
02126:  AND     #FF,W1
02128:  IOR      W0,  W1,W7
0212A:  BRA     Z,2140
0212C:  BTSC    W1.7
0212E:  BRA     2140
02130:  BCLR.B  42.1
02132:  BCLR.B  42.0
02134:  RLC     W0,W0
02136:  RLC     W1,W1
02138:  DEC     W6,W6
0213A:  BTSC.B  42.1
0213C:  BRA     21A0
0213E:  BRA     212C
02140:  BTSC    W9.0
02142:  MOV     W10,W11
02144:  BTSC    W9.1
02146:  MOV     W12,W11
02148:  BTSS    W9.5
0214A:  BRA     2180
0214C:  BTSC    W10.F
0214E:  BSET    W0.8
02150:  BRA     2188
02152:  BSET.B  42.0
02154:  RRC.B   W1L,W1L
02156:  RRC     W0,W0
02158:  BTSC.B  42.0
0215A:  BSET    W9.5
0215C:  INC     W6,W6
0215E:  BRA     Z,21A0
02160:  BTSS    W9.5
02162:  BRA     2174
02164:  INC     W0,W0
02166:  BRA     NZ,2174
02168:  INC.B   W1L,W1L
0216A:  BRA     NZ,2174
0216C:  RRC.B   W1L,W1L
0216E:  RRC     W0,W0
02170:  INC     W6,W6
02172:  BRA     Z,21A0
02174:  BTSC    W9.0
02176:  MOV     W10,W11
02178:  BTSC    W9.1
0217A:  MOV     W12,W11
0217C:  BTSC.B  42.1
0217E:  BRA     21A0
02180:  BTSC    W9.6
02182:  MOV     W10,W11
02184:  BTSC    W9.7
02186:  MOV     W12,W11
02188:  IOR      W0,  W1,W2
0218A:  BRA     Z,21D2
0218C:  BCLR    W1.7
0218E:  SWAP    W6
02190:  BCLR.B  42.1
02192:  BCLR.B  42.0
02194:  RRC     W6,W6
02196:  XOR     W6,W1,W1
02198:  BSET    W1.F
0219A:  BTSS    W11.F
0219C:  BCLR    W1.F
0219E:  BRA     21D2
021A0:  MOV     #0,W0
021A2:  MOV     #0,W1
021A4:  BRA     21D2
021A6:  BTSC    W10.F
021A8:  XOR     W8,W3,W3
021AA:  MOV     W2,W0
021AC:  MOV     W3,W1
021AE:  BRA     21D2
021B0:  BRA     21D2
021B2:  AND     #FF,W3
021B4:  BSET    W3.7
021B6:  AND     #FF,W1
021B8:  BSET    W1.7
021BA:  BTSC    W11.F
021BC:  BCLR    W3.7
021BE:  BSET    W9.2
021C0:  BRA     20D2
021C2:  SUB     W6,W7,W8
021C4:  AND     #FF,W1
021C6:  BSET    W1.7
021C8:  AND     #FF,W3
021CA:  BSET    W3.7
021CC:  BCLR    W9.1
021CE:  BSET    W9.0
021D0:  BRA     20A0
021D2:  MOV     #12,W5
021D4:  REPEAT  #3
021D6:  MOV     [--W15],[W5--]
021D8:  MOV     [--W15],W5
021DA:  RETURN  
*
0236E:  MOV     W5,[W15++]
02370:  MOV     W1,W5
02372:  MOV     W0,W2
02374:  MOV     #B6,W4
02376:  RLC     W1,W1
02378:  SWAP    W1
0237A:  AND     #FF,W1
0237C:  SUB.B   W4L,W1L,W4L
0237E:  MOV.B   W5L,W3L
02380:  BSET    W3.7
02382:  AND     #FF,W3
02384:  CLR     W0
02386:  CLR     W1
02388:  CP      W4,#18
0238A:  BRA     N,23AA
0238C:  BCLR.B  42.0
0238E:  RRC     W3,W3
02390:  RRC     W2,W2
02392:  RRC     W1,W1
02394:  RRC     W0,W0
02396:  DEC     W4,W4
02398:  BRA     NZ,238C
0239A:  BTSS    W5.F
0239C:  BRA     23AA
0239E:  NEG     W0,W0
023A0:  BRA     Z,23A6
023A2:  COM     W1,W1
023A4:  BRA     23AA
023A6:  NEG     W1,W1
023A8:  BRA     23AA
023AA:  MOV     [--W15],W5
023AC:  RETURN  
*
0240A:  MOV     W5,[W15++]
0240C:  MOV     #C,W5
0240E:  REPEAT  #3
02410:  MOV     [W5++],[W15++]
02412:  MOV     W0,W7
02414:  MOV     W4,W9
02416:  BCLR    W4.F
02418:  CP0     W4
0241A:  BRA     NZ,2428
0241C:  BTSC    W9.F
0241E:  BRA     2424
02420:  MOV     #0,W5
02422:  BRA     2446
02424:  MOV     #0,W5
02426:  BRA     2446
02428:  SUB.B   W4L,#6,W5L
0242A:  BRA     NC,2444
0242C:  MOV     #30,W0
0242E:  BTSS    W9.F
02430:  MOV     #20,W0
02432:  MOV     W0,[W15++]
02434:  BTSC.B  219.1
02436:  BRA     2434
02438:  MOV     W0,21A
0243A:  MOV     [--W15],W0
0243C:  DEC     W5,W5
0243E:  BRA     NN,2432
02440:  MOV     #5,W5
02442:  BRA     2446
02444:  MOV     W4,W5
02446:  MOV     #6,W4
02448:  BSET    W5.E
0244A:  BTSC    W9.F
0244C:  BSET    W5.F
0244E:  MOV     #2710,W8
02450:  REPEAT  #11
02452:  DIV.U   W7,W8
02454:  CALL    2488
02458:  MOV     W1,W7
0245A:  MOV     #3E8,W8
0245C:  REPEAT  #11
0245E:  DIV.U   W7,W8
02460:  CALL    2488
02464:  MOV     W1,W7
02466:  MOV     #64,W8
02468:  REPEAT  #11
0246A:  DIV.U   W7,W8
0246C:  CALL    2488
02470:  MOV     W1,W7
02472:  MOV     #A,W8
02474:  REPEAT  #11
02476:  DIV.U   W7,W8
02478:  CALL    2488
0247C:  MOV     #30,W0
0247E:  ADD.B   W1L,W0L,W0L
02480:  BTSC.B  219.1
02482:  BRA     2480
02484:  MOV     W0,21A
02486:  BRA     24B6
02488:  MOV     #30,W6
0248A:  CP0     W0
0248C:  BRA     NZ,24AA
0248E:  BTSS    W5.E
02490:  BRA     24AC
02492:  DEC     W4,W4
02494:  CP.B    W4L,W5L
02496:  BRA     Z,249C
02498:  BTSC.B  42.0
0249A:  RETURN  
0249C:  CP0     W0
0249E:  BRA     NZ,24AA
024A0:  BTSS    W5.E
024A2:  BRA     24AC
024A4:  BTSS    W5.F
024A6:  MOV     #20,W6
024A8:  BRA     24AC
024AA:  BCLR    W5.E
024AC:  ADD.B   W6L,W0L,W0L
024AE:  BTSC.B  219.1
024B0:  BRA     24AE
024B2:  MOV     W0,21A
024B4:  RETURN  
024B6:  MOV     #12,W5
024B8:  REPEAT  #3
024BA:  MOV     [--W15],[W5--]
024BC:  MOV     [--W15],W5
024BE:  RETURN  
024C0:  MOV     W6,[W15++]
024C2:  MOV     W7,[W15++]
024C4:  MOV     W8,[W15++]
024C6:  MOV     W9,[W15++]
024C8:  CLR     W4
024CA:  CLR     W5
024CC:  CLR     W6
024CE:  CLR     W7
024D0:  XOR     W2,W3,W8
024D2:  BRA     Z,24F6
024D4:  MOV     #20,W8
024D6:  BCLR.B  42.0
024D8:  RLC     W0,W0
024DA:  RLC     W1,W1
024DC:  RLC     W4,W4
024DE:  RLC     W5,W5
024E0:  CP      W5,W3
024E2:  BRA     NZ,24E6
024E4:  CPB     W4,W2
024E6:  BRA     NC,24EE
024E8:  SUB     W4,W2,W4
024EA:  SUBB    W5,W3,W5
024EC:  BSET.B  42.0
024EE:  RLC     W6,W6
024F0:  RLC     W7,W7
024F2:  DEC     W8,W8
024F4:  BRA     NZ,24D6
024F6:  MOV     W7,W1
024F8:  MOV     W6,W0
024FA:  MOV     [--W15],W9
024FC:  MOV     [--W15],W8
024FE:  MOV     [--W15],W7
02500:  MOV     [--W15],W6
02502:  RETURN  
02504:  MOV     W5,[W15++]
02506:  MOV     #C,W5
02508:  REPEAT  #7
0250A:  MOV     [W5++],[W15++]
0250C:  BTSS    W1.F
0250E:  BRA     251E
02510:  NEG     W0,W0
02512:  BRA     Z,2516
02514:  BRA     NZ,251A
02516:  NEG     W1,W1
02518:  BRA     251C
0251A:  COM     W1,W1
0251C:  BSET    W4.8
0251E:  CLR     W5
02520:  MOV     W0,W6
02522:  MOV     W1,W7
02524:  MOV     W4,W12
02526:  BCLR    W4.F
02528:  CP0.B   W4L
0252A:  BRA     NZ,252E
0252C:  BRA     2562
0252E:  SUB.B   W4L,#B,W5L
02530:  BRA     NC,2562
02532:  SUB.B   W4L,W5L,W4L
02534:  BTSS    W12.F
02536:  BRA     254E
02538:  BTSS    W4.8
0253A:  BRA     254A
0253C:  MOV     #2D,W0
0253E:  BTSC.B  219.1
02540:  BRA     253E
02542:  MOV     W0,21A
02544:  BCLR    W4.8
02546:  DEC     W5,W5
02548:  BRA     N,2562
0254A:  MOV     #30,W0
0254C:  BRA     2550
0254E:  MOV     #20,W0
02550:  MOV     W0,[W15++]
02552:  BTSC.B  219.1
02554:  BRA     2552
02556:  MOV     W0,21A
02558:  MOV     [--W15],W0
0255A:  DEC     W5,W5
0255C:  BRA     NN,2550
0255E:  BTSC    W4.8
02560:  DEC.B   W4L,W4L
02562:  MOV     #E,W8
02564:  MOV     #0,W9
02566:  LNK     #10
02568:  MOV     W12,[W14+W8]
0256A:  DEC2    W8,W8
0256C:  BRA     NN,2568
0256E:  MOV     W4,W5
02570:  MOV     #A,W4
02572:  BTSC    W5.8
02574:  INC     W4,W4
02576:  BSET    W5.E
02578:  BTSC    W12.F
0257A:  BSET    W5.F
0257C:  CP0.B   W5L
0257E:  BRA     Z,2582
02580:  DEC.B   W5L,W5L
02582:  MOV     W4,[W14]
02584:  MOV     W5,[W14+#2]
02586:  MOV     W6,W0
02588:  MOV     W7,W1
0258A:  MOV     #CA00,W2
0258C:  MOV     #3B9A,W3
0258E:  MOV     #2710,W8
02590:  BCLR    W13.F
02592:  BCLR.B  43.0
02594:  CALL    24C0
02598:  BTG     W13.F
0259A:  BTSC    W13.F
0259C:  BRA     25AC
0259E:  MOV     W0,[W14+#8]
025A0:  MOV     W1,[W14+#A]
025A2:  MOV     W0,W2
025A4:  MOV     W1,W3
025A6:  MOV     [W14+#4],W0
025A8:  MOV     [W14+#6],W1
025AA:  BRA     2592
025AC:  MOV     W2,[W14+#8]
025AE:  MOV     W3,[W14+#A]
025B0:  MOV     W4,[W14+#4]
025B2:  MOV     W5,[W14+#6]
025B4:  MOV     [W14],W4
025B6:  MOV     [W14+#2],W5
025B8:  MOV     #30,W6
025BA:  CP0     W0
025BC:  BRA     NZ,25E0
025BE:  BTSS    W5.E
025C0:  BRA     25E4
025C2:  DEC     W4,W4
025C4:  MOV     W4,[W14]
025C6:  CP0     W4
025C8:  BRA     Z,25E4
025CA:  CP.B    W4L,W5L
025CC:  BRA     Z,25D2
025CE:  BTSC.B  42.0
025D0:  BRA     2602
025D2:  BTSS    W5.F
025D4:  BRA     25DC
025D6:  BTSS    W5.8
025D8:  BRA     25FA
025DA:  BRA     25EA
025DC:  MOV     #20,W6
025DE:  BRA     25FA
025E0:  BCLR    W5.E
025E2:  MOV     W5,[W14+#2]
025E4:  MOV     [W14+#2],W5
025E6:  BTSS    W5.8
025E8:  BRA     25FA
025EA:  BCLR    W5.8
025EC:  MOV     W5,[W14+#2]
025EE:  MOV     W0,W10
025F0:  MOV     #2D,W0
025F2:  BTSC.B  219.1
025F4:  BRA     25F2
025F6:  MOV     W0,21A
025F8:  MOV     W10,W0
025FA:  ADD.B   W6L,W0L,W0L
025FC:  BTSC.B  219.1
025FE:  BRA     25FC
02600:  MOV     W0,21A
02602:  MOV     [W14+#8],W0
02604:  MOV     [W14+#A],W1
02606:  MOV     #A,W2
02608:  CLR     W3
0260A:  CP      W0,#1
0260C:  BRA     Z,2610
0260E:  BRA     2592
02610:  ULNK    
02612:  MOV     #1A,W5
02614:  REPEAT  #7
02616:  MOV     [--W15],[W5--]
02618:  MOV     [--W15],W5
0261A:  RETURN  
*
02A7C:  MOV     W5,[W15++]
02A7E:  MOV     #C,W5
02A80:  REPEAT  #5
02A82:  MOV     [W5++],[W15++]
02A84:  MOV     W3,W8
02A86:  MOV     W2,W7
02A88:  MOV     W1,W6
02A8A:  MOV     W0,W5
02A8C:  MOV     W3,W9
02A8E:  MOV     #473,W11
02A90:  ASR     W3,#4,W3
02A92:  MOV     #7FF,W10
02A94:  AND     W10,W3,W3
02A96:  SUB     W11,W3,W11
02A98:  AND     #1F,W8
02A9A:  BSET    W8.4
02A9C:  CLR     W0
02A9E:  CLR     W1
02AA0:  CLR     W2
02AA2:  CLR     W3
02AA4:  BCLR.B  42.0
02AA6:  RRC     W8,W8
02AA8:  RRC     W7,W7
02AAA:  RRC     W6,W6
02AAC:  RRC     W5,W5
02AAE:  RRC     W3,W3
02AB0:  RRC     W2,W2
02AB2:  RRC     W1,W1
02AB4:  RRC     W0,W0
02AB6:  DEC     W11,W11
02AB8:  BRA     NZ,2AA4
02ABA:  BTSS    W9.F
02ABC:  BRA     2AD0
02ABE:  COM     W0,W0
02AC0:  COM     W1,W1
02AC2:  COM     W2,W2
02AC4:  COM     W3,W3
02AC6:  INC     W0,W0
02AC8:  ADDC    #0,W1
02ACA:  ADDC    #0,W2
02ACC:  ADDC    #0,W3
02ACE:  BRA     2AD0
02AD0:  MOV     #16,W5
02AD2:  REPEAT  #5
02AD4:  MOV     [--W15],[W5--]
02AD6:  MOV     [--W15],W5
02AD8:  RETURN  
*
02F96:  MOV     W5,[W15++]
02F98:  MOV     #C,W5
02F9A:  REPEAT  #3
02F9C:  MOV     [W5++],[W15++]
02F9E:  MOV     #0,W9
02FA0:  BTSC.B  43.0
02FA2:  MOV     #1,W9
02FA4:  MOV     W9,[W15++]
02FA6:  XOR     W1,W3,W9
02FA8:  BTSS    W1.F
02FAA:  BRA     2FB2
02FAC:  COM     W1,W1
02FAE:  NEG     W0,W0
02FB0:  ADDC    W1,#0,W1
02FB2:  BTSS    W3.F
02FB4:  BRA     2FBC
02FB6:  COM     W3,W3
02FB8:  NEG     W2,W2
02FBA:  ADDC    W3,#0,W3
02FBC:  XOR     W2,W3,W4
02FBE:  BRA     Z,2FEA
02FC0:  CLR     W4
02FC2:  CLR     W5
02FC4:  CLR     W6
02FC6:  CLR     W7
02FC8:  MOV     #20,W8
02FCA:  BCLR.B  42.0
02FCC:  RLC     W0,W0
02FCE:  RLC     W1,W1
02FD0:  RLC     W4,W4
02FD2:  RLC     W5,W5
02FD4:  CP      W5,W3
02FD6:  BRA     NZ,2FDA
02FD8:  CPB     W4,W2
02FDA:  BRA     NC,2FE2
02FDC:  SUB     W4,W2,W4
02FDE:  SUBB    W5,W3,W5
02FE0:  BSET.B  42.0
02FE2:  RLC     W6,W6
02FE4:  RLC     W7,W7
02FE6:  DEC     W8,W8
02FE8:  BRA     NZ,2FCA
02FEA:  BTSS    W9.F
02FEC:  BRA     2FFC
02FEE:  NEG     W6,W0
02FF0:  BRA     Z,2FF4
02FF2:  BRA     NZ,2FF8
02FF4:  NEG     W7,W1
02FF6:  BRA     3002
02FF8:  COM     W7,W1
02FFA:  BRA     3002
02FFC:  MOV     W7,W1
02FFE:  MOV     W6,W0
03000:  BRA     3002
03002:  MOV     [--W15],W9
03004:  CP0     W9
03006:  BRA     Z,300A
03008:  MOV.D   W4,W0
0300A:  MOV     #12,W5
0300C:  REPEAT  #3
0300E:  MOV     [--W15],[W5--]
03010:  MOV     [--W15],W5
03012:  RETURN  
*
03A24:  MOV     W5,[W15++]
03A26:  MOV     W6,[W15++]
03A28:  MOV     #8E,W1
03A2A:  BCLR    W6.0
03A2C:  BTSS    W0.F
03A2E:  BRA     3A36
03A30:  BSET    W6.0
03A32:  NEG     W0,W0
03A34:  BRA     3A36
03A36:  CP0     W0
03A38:  BRA     Z,3A62
03A3A:  BTSC    W0.F
03A3C:  BRA     3A46
03A3E:  BCLR.B  42.0
03A40:  RLC     W0,W0
03A42:  DEC     W1,W1
03A44:  BRA     3A3A
03A46:  SWAP    W1
03A48:  BCLR.B  42.0
03A4A:  RRC     W1,W1
03A4C:  BCLR    W0.F
03A4E:  SWAP    W0
03A50:  XOR.B   W0L,W1L,W1L
03A52:  AND.B   #0,W0L
03A54:  BTSC    W6.0
03A56:  BSET    W1.F
03A58:  BRA     3A68
03A5A:  MOV.B   W1L,W0L
03A5C:  BSET    W1.7
03A5E:  AND.B   #0,W1L
03A60:  BRA     3A68
03A62:  CLR     W0
03A64:  CLR     W1
03A66:  BRA     3A68
03A68:  MOV     [--W15],W6
03A6A:  MOV     [--W15],W5
03A6C:  RETURN  
03A6E:  MOV     W5,[W15++]
03A70:  MOV     #C,W5
03A72:  REPEAT  #4
03A74:  MOV     [W5++],[W15++]
03A76:  CLR     W9
03A78:  XOR     W1,W3,W9
03A7A:  MOV     W1,W6
03A7C:  MOV     W0,W5
03A7E:  MOV     W3,W8
03A80:  MOV     W2,W7
03A82:  RLC     W1,W1
03A84:  SWAP    W1
03A86:  ZE      W1,W1
03A88:  CP0     W1
03A8A:  BRA     Z,3B28
03A8C:  RLC     W3,W3
03A8E:  SWAP    W3
03A90:  ZE      W3,W3
03A92:  CP0     W3
03A94:  BRA     Z,3B28
03A96:  CLR     W0
03A98:  SUB.B   W1L,W3L,W0L
03A9A:  BRA     NC,3AA2
03A9C:  ADD.B   #7F,W0L
03A9E:  BRA     C,3B28
03AA0:  BRA     3AA8
03AA2:  SUB.B   #81,W0L
03AA4:  BRA     NC,3B28
03AA6:  BRA     Z,3B28
03AA8:  MOV     W5,W1
03AAA:  MOV     W6,W2
03AAC:  BSET    W2.7
03AAE:  AND     #FF,W2
03AB0:  AND     #FF,W8
03AB2:  BSET    W8.7
03AB4:  MOV     #19,W10
03AB6:  CLR     W3
03AB8:  CLR     W4
03ABA:  SUB     W1,W7,W1
03ABC:  SUBB    W2,W8,W2
03ABE:  BRA     N,3AC4
03AC0:  BRA     C,3ACA
03AC2:  BRA     NZ,3ACC
03AC4:  ADD     W1,W7,W1
03AC6:  ADDC    W2,W8,W2
03AC8:  BRA     3ACC
03ACA:  BSET    W4.0
03ACC:  DEC     W10,W10
03ACE:  BRA     Z,3ADE
03AD0:  BCLR.B  42.0
03AD2:  RLC     W1,W1
03AD4:  RLC     W2,W2
03AD6:  BCLR.B  42.0
03AD8:  RLC     W4,W4
03ADA:  RLC     W3,W3
03ADC:  BRA     3ABA
03ADE:  CLR     W10
03AE0:  BTSC    W3.8
03AE2:  BRA     3AE6
03AE4:  BRA     3AF2
03AE6:  BCLR.B  42.0
03AE8:  RRC     W3,W3
03AEA:  BCLR    W3.7
03AEC:  RRC     W4,W4
03AEE:  RLC     W10,W10
03AF0:  BRA     3AF6
03AF2:  DEC     W0,W0
03AF4:  BRA     Z,3B28
03AF6:  BTSC    W10.F
03AF8:  BRA     NC,3B04
03AFA:  RLC     W1,W1
03AFC:  RLC     W2,W2
03AFE:  SUB     W1,W7,W1
03B00:  SUBB    W2,W8,W2
03B02:  BRA     NC,3B16
03B04:  INC     W4,W4
03B06:  BRA     NZ,3B16
03B08:  INC     W3,W3
03B0A:  BRA     NZ,3B16
03B0C:  INC     W0,W0
03B0E:  BRA     Z,3B28
03B10:  BRA     3B16
03B12:  DEC     W0,W0
03B14:  BRA     Z,3B28
03B16:  SWAP    W0
03B18:  RRC     W0,W1
03B1A:  BSET    W1.F
03B1C:  BTSS    W9.F
03B1E:  BCLR    W1.F
03B20:  BCLR    W3.7
03B22:  XOR.B   W3L,W1L,W1L
03B24:  MOV     W4,W0
03B26:  BRA     3B2E
03B28:  MOV     #0,W0
03B2A:  MOV     #0,W1
03B2C:  BRA     3B2E
03B2E:  MOV     #14,W5
03B30:  REPEAT  #4
03B32:  MOV     [--W15],[W5--]
03B34:  MOV     [--W15],W5
03B36:  RETURN  
*
03C18:  MOV     W5,[W15++]
03C1A:  MOV     W6,[W15++]
03C1C:  MOV     W2,W3
03C1E:  MOV     W2,W5
03C20:  BCLR.B  42.0
03C22:  RLC     W3,W3
03C24:  SWAP    W3
03C26:  AND     #FF,W3
03C28:  BRA     NZ,3C30
03C2A:  MUL.UU  W0,#0,W0
03C2C:  MUL.UU  W2,#0,W2
03C2E:  BRA     3C5C
03C30:  ADD     #380,W3
03C32:  AND     #7F,W2
03C34:  MOV     #3,W6
03C36:  CLR     W4
03C38:  BCLR.B  42.0
03C3A:  RRC     W2,W2
03C3C:  RRC     W1,W1
03C3E:  RRC     W0,W0
03C40:  BTSC.B  42.0
03C42:  INC     W4,W4
03C44:  DEC     W6,W6
03C46:  BRA     NZ,3C38
03C48:  BCLR    W2.7
03C4A:  SL      W3,#4,W3
03C4C:  BCLR    W3.F
03C4E:  BTSC    W5.F
03C50:  BSET    W3.F
03C52:  XOR     W2,W3,W3
03C54:  MOV     W1,W2
03C56:  MOV     W0,W1
03C58:  ADD     W4,W1,W1
03C5A:  CLR     W0
03C5C:  MOV     [--W15],W6
03C5E:  MOV     [--W15],W5
03C60:  RETURN  
03C62:  MOV     W12,[W15++]
03C64:  MOV     W13,[W15++]
03C66:  CLR     W8
03C68:  CLR     W9
03C6A:  CLR     W10
03C6C:  CLR     W11
03C6E:  CLR     W12
03C70:  CLR     W13
03C72:  MOV     #E,W8
03C74:  MOV     #0,W9
03C76:  LNK     #10
03C78:  MOV     W12,[W14+W8]
03C7A:  DEC2    W8,W8
03C7C:  BRA     NN,3C78
03C7E:  XOR     W4,W5,W8
03C80:  BRA     NZ,3C86
03C82:  XOR     W6,W7,W8
03C84:  BRA     Z,3CE4
03C86:  CLR     W8
03C88:  MOV     #40,W13
03C8A:  MOV     #40,W13
03C8C:  BCLR.B  42.0
03C8E:  RLC     W0,W0
03C90:  RLC     W1,W1
03C92:  RLC     W2,W2
03C94:  RLC     W3,W3
03C96:  RLC     W8,W8
03C98:  RLC     W9,W9
03C9A:  RLC     W10,W10
03C9C:  RLC     W11,W11
03C9E:  CP      W11,W7
03CA0:  BRA     NZ,3CAC
03CA2:  CPB     W10,W6
03CA4:  BRA     NZ,3CAC
03CA6:  CPB     W9,W5
03CA8:  BRA     NZ,3CAC
03CAA:  CPB     W8,W4
03CAC:  BRA     NC,3CB8
03CAE:  SUB     W8,W4,W8
03CB0:  SUBB    W9,W5,W9
03CB2:  SUBB    W10,W6,W10
03CB4:  SUBB    W11,W7,W11
03CB6:  BSET.B  42.0
03CB8:  MOV     W8,[W14]
03CBA:  MOV     W9,[W14+#2]
03CBC:  MOV     W10,[W14+#4]
03CBE:  MOV     W11,[W14+#6]
03CC0:  MOV     [W14+#8],W8
03CC2:  MOV     [W14+#A],W9
03CC4:  MOV     [W14+#C],W10
03CC6:  MOV     [W14+#E],W11
03CC8:  RLC     W8,W8
03CCA:  RLC     W9,W9
03CCC:  RLC     W10,W10
03CCE:  RLC     W11,W11
03CD0:  MOV     W8,[W14+#8]
03CD2:  MOV     W9,[W14+#A]
03CD4:  MOV     W10,[W14+#C]
03CD6:  MOV     W11,[W14+#E]
03CD8:  MOV     [W14],W8
03CDA:  MOV     [W14+#2],W9
03CDC:  MOV     [W14+#4],W10
03CDE:  MOV     [W14+#6],W11
03CE0:  DEC     W13,W13
03CE2:  BRA     NZ,3C8C
03CE4:  MOV     [W14+#8],W0
03CE6:  MOV     [W14+#A],W1
03CE8:  MOV     [W14+#C],W2
03CEA:  MOV     [W14+#E],W3
03CEC:  ULNK    
03CEE:  BRA     3CF0
03CF0:  MOV     [--W15],W13
03CF2:  MOV     [--W15],W12
03CF4:  RETURN  
03CF6:  MOV     W5,[W15++]
03CF8:  MOV     #C,W5
03CFA:  REPEAT  #5
03CFC:  MOV     [W5++],[W15++]
03CFE:  BTSS    W3.F
03D00:  BRA     3D12
03D02:  COM     W1,W1
03D04:  COM     W2,W2
03D06:  COM     W3,W3
03D08:  NEG     W0,W0
03D0A:  ADDC    W1,#0,W1
03D0C:  ADDC    W2,#0,W2
03D0E:  ADDC    W3,#0,W3
03D10:  BSET    W4.8
03D12:  MOV     W0,W6
03D14:  MOV     W4,W12
03D16:  BCLR    W4.F
03D18:  CP0     W4
03D1A:  BRA     NZ,3D1E
03D1C:  BRA     3D52
03D1E:  SUB.B   W4L,#14,W5L
03D20:  BRA     NC,3D52
03D22:  SUB.B   W4L,W5L,W4L
03D24:  BTSS    W12.F
03D26:  BRA     3D3E
03D28:  BTSS    W4.8
03D2A:  BRA     3D3A
03D2C:  MOV     #2D,W0
03D2E:  BTSC.B  219.1
03D30:  BRA     3D2E
03D32:  MOV     W0,21A
03D34:  BCLR    W4.8
03D36:  DEC     W5,W5
03D38:  BRA     N,3D52
03D3A:  MOV     #30,W0
03D3C:  BRA     3D40
03D3E:  MOV     #20,W0
03D40:  MOV     W0,[W15++]
03D42:  BTSC.B  219.1
03D44:  BRA     3D42
03D46:  MOV     W0,21A
03D48:  MOV     [--W15],W0
03D4A:  DEC     W5,W5
03D4C:  BRA     NN,3D40
03D4E:  BTSC    W4.8
03D50:  DEC.B   W4L,W4L
03D52:  MOV     #E,W8
03D54:  MOV     #0,W9
03D56:  LNK     #16
03D58:  MOV     W12,[W14+W8]
03D5A:  DEC2    W8,W8
03D5C:  BRA     NN,3D58
03D5E:  MOV     W4,W5
03D60:  MOV     #13,W4
03D62:  BTSC    W5.8
03D64:  INC     W4,W4
03D66:  BSET    W5.E
03D68:  BTSC    W12.F
03D6A:  BSET    W5.F
03D6C:  CP0.B   W5L
03D6E:  BRA     Z,3D72
03D70:  DEC.B   W5L,W5L
03D72:  MOV     W4,[W14]
03D74:  MOV     W5,[W14+#2]
03D76:  MOV     W6,W0
03D78:  CLR     W4
03D7A:  MOV     #A764,W5
03D7C:  MOV     #B6B3,W6
03D7E:  MOV     #DE0,W7
03D80:  BCLR    W13.F
03D82:  MOV     W13,[W14+#14]
03D84:  CALL    3C62
03D88:  MOV     [W14+#14],W13
03D8A:  BTG     W13.F
03D8C:  MOV     W13,[W14+#14]
03D8E:  BTSC    W13.F
03D90:  BRA     3DAC
03D92:  MOV     W0,[W14+#C]
03D94:  MOV     W1,[W14+#E]
03D96:  MOV     W2,[W14+#10]
03D98:  MOV     W3,[W14+#12]
03D9A:  MOV     W0,W4
03D9C:  MOV     W1,W5
03D9E:  MOV     W2,W6
03DA0:  MOV     W3,W7
03DA2:  MOV     [W14+#4],W0
03DA4:  MOV     [W14+#6],W1
03DA6:  MOV     [W14+#8],W2
03DA8:  MOV     [W14+#A],W3
03DAA:  BRA     3D84
03DAC:  MOV     W4,[W14+#C]
03DAE:  MOV     W5,[W14+#E]
03DB0:  MOV     W6,[W14+#10]
03DB2:  MOV     W7,[W14+#12]
03DB4:  MOV     W8,[W14+#4]
03DB6:  MOV     W9,[W14+#6]
03DB8:  MOV     W10,[W14+#8]
03DBA:  MOV     W11,[W14+#A]
03DBC:  MOV     [W14],W4
03DBE:  MOV     [W14+#2],W5
03DC0:  MOV     #30,W6
03DC2:  CP0     W0
03DC4:  BRA     NZ,3DE8
03DC6:  BTSS    W5.E
03DC8:  BRA     3DEC
03DCA:  DEC     W4,W4
03DCC:  MOV     W4,[W14]
03DCE:  CP0     W4
03DD0:  BRA     Z,3DEC
03DD2:  CP.B    W4L,W5L
03DD4:  BRA     Z,3DDA
03DD6:  BTSC.B  42.0
03DD8:  BRA     3E08
03DDA:  BTSS    W5.F
03DDC:  BRA     3DE4
03DDE:  BTSS    W5.8
03DE0:  BRA     3E00
03DE2:  BRA     3DF0
03DE4:  MOV     #20,W6
03DE6:  BRA     3E00
03DE8:  BCLR    W5.E
03DEA:  MOV     W5,[W14+#2]
03DEC:  BTSS    W5.8
03DEE:  BRA     3E00
03DF0:  BCLR    W5.8
03DF2:  MOV     W5,[W14+#2]
03DF4:  MOV     W0,W10
03DF6:  MOV     #2D,W0
03DF8:  BTSC.B  219.1
03DFA:  BRA     3DF8
03DFC:  MOV     W0,21A
03DFE:  MOV     W10,W0
03E00:  ADD.B   W6L,W0L,W0L
03E02:  BTSC.B  219.1
03E04:  BRA     3E02
03E06:  MOV     W0,21A
03E08:  MOV     [W14+#C],W0
03E0A:  MOV     [W14+#E],W1
03E0C:  MOV     [W14+#10],W2
03E0E:  MOV     [W14+#12],W3
03E10:  MOV     #A,W4
03E12:  CLR     W5
03E14:  MUL.UU  W6,#0,W6
03E16:  CP      W0,#1
03E18:  BRA     Z,3E1C
03E1A:  BRA     3D84
03E1C:  ULNK    
03E1E:  MOV     #16,W5
03E20:  REPEAT  #5
03E22:  MOV     [--W15],[W5--]
03E24:  MOV     [--W15],W5
03E26:  RETURN  
03E28:  MOV     W5,[W15++]
03E2A:  MOV     #C,W5
03E2C:  REPEAT  #3
03E2E:  MOV     [W5++],[W15++]
03E30:  MOV     W0,W4
03E32:  MOV     W1,W5
03E34:  MOV     W2,W6
03E36:  MOV     W3,W7
03E38:  CLR     W0
03E3A:  CLR     W1
03E3C:  CLR     W2
03E3E:  CLR     W3
03E40:  BCLR    W8.0
03E42:  BTSS    W7.F
03E44:  BRA     3E56
03E46:  BSET    W8.0
03E48:  COM     W7,W7
03E4A:  COM     W6,W6
03E4C:  COM     W5,W5
03E4E:  NEG     W4,W4
03E50:  ADDC    W5,#0,W5
03E52:  ADDC    W6,#0,W6
03E54:  ADDC    W7,#0,W7
03E56:  IOR      W4,  W5,W9
03E58:  BRA     NZ,3E5E
03E5A:  IOR      W6,  W7,W9
03E5C:  BRA     Z,3E88
03E5E:  MOV     #473,W9
03E60:  BTSC    W3.4
03E62:  BRA     3E7A
03E64:  BCLR.B  42.0
03E66:  RLC     W4,W4
03E68:  RLC     W5,W5
03E6A:  RLC     W6,W6
03E6C:  RLC     W7,W7
03E6E:  RLC     W0,W0
03E70:  RLC     W1,W1
03E72:  RLC     W2,W2
03E74:  RLC     W3,W3
03E76:  DEC     W9,W9
03E78:  BRA     NZ,3E60
03E7A:  SL      W9,#4,W9
03E7C:  BCLR.B  42.0
03E7E:  BCLR    W9.F
03E80:  BCLR    W3.4
03E82:  XOR     W9,W3,W3
03E84:  BTSC    W8.0
03E86:  BSET    W3.F
03E88:  MOV     #12,W5
03E8A:  REPEAT  #3
03E8C:  MOV     [--W15],[W5--]
03E8E:  MOV     [--W15],W5
03E90:  RETURN  
*
03F42:  MOV     W5,[W15++]
03F44:  MOV     #C,W5
03F46:  REPEAT  #5
03F48:  MOV     [W5++],[W15++]
03F4A:  MOV     W3,W8
03F4C:  MOV     W2,W7
03F4E:  MOV     W1,W6
03F50:  MOV     W0,W5
03F52:  MOV     W3,W9
03F54:  MOV     #473,W11
03F56:  ASR     W3,#4,W3
03F58:  MOV     #7FF,W10
03F5A:  AND     W10,W3,W3
03F5C:  SUB     W11,W3,W11
03F5E:  AND     #1F,W8
03F60:  BSET    W8.4
03F62:  CLR     W0
03F64:  CLR     W1
03F66:  CLR     W2
03F68:  CLR     W3
03F6A:  BCLR.B  42.0
03F6C:  RRC     W8,W8
03F6E:  RRC     W7,W7
03F70:  RRC     W6,W6
03F72:  RRC     W5,W5
03F74:  RRC     W3,W3
03F76:  RRC     W2,W2
03F78:  RRC     W1,W1
03F7A:  RRC     W0,W0
03F7C:  DEC     W11,W11
03F7E:  BRA     NZ,3F6A
03F80:  BTSS    W9.F
03F82:  BRA     3F96
03F84:  COM     W0,W0
03F86:  COM     W1,W1
03F88:  COM     W2,W2
03F8A:  COM     W3,W3
03F8C:  INC     W0,W0
03F8E:  ADDC    #0,W1
03F90:  ADDC    #0,W2
03F92:  ADDC    #0,W3
03F94:  BRA     3F96
03F96:  MOV     #16,W5
03F98:  REPEAT  #5
03F9A:  MOV     [--W15],[W5--]
03F9C:  MOV     [--W15],W5
03F9E:  RETURN  
*
050EE:  PUSH    42
050F0:  MOV     W0,[W15++]
050F2:  BCLR.B  81.7
050F4:  MOV     42,W4
050F6:  IOR     #E0,W4
050F8:  MOV     W4,42
050FA:  BSET.B  81.7
050FC:  MOV     W1,760
050FE:  MOV     #55,W4
05100:  MOV     W4,766
05102:  MOV     #AA,W4
05104:  MOV     W4,766
05106:  BSET.B  761.7
05108:  NOP     
0510A:  NOP     
0510C:  BTSC.B  761.7
0510E:  BRA     510C
05110:  MOV     [--W15],W0
05112:  BCLR.B  81.7
05114:  POP     42
05116:  BSET.B  81.7
05118:  RETURN  
0511A:  MOV     W1,[W15++]
0511C:  MOV     #F000,W1
0511E:  ADD     W1,W0,W0
05120:  CLR     W1
05122:  MOV     #7F,W1
05124:  ADDC    W1,#0,W1
05126:  MOV     W1,32
05128:  MOV     [--W15],W1
0512A:  BCLR    W2.0
0512C:  CP0     W2
0512E:  BRA     Z,5152
05130:  TBLWTL  [W1],[W0]
05132:  MOV     W1,[W15++]
05134:  MOV     #4044,W1
05136:  CALL    50EE
0513A:  MOV     [--W15],W1
0513C:  TBLWTL  [W1++],[W0]
0513E:  INC2    W0,W0
05140:  BRA     NZ,5144
05142:  INC     0032
05144:  MOV     W1,[W15++]
05146:  MOV     #4004,W1
05148:  CALL    50EE
0514C:  MOV     [--W15],W1
0514E:  DEC2    W2,W2
05150:  BRA     NZ,5130
05152:  RETURN  
....................  
.................... #list 
....................  
.................... #include "DSPIC30F_registers.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... #word WREG0 = 0x000 
.................... #word WREG1 = 0x002 
.................... #word WREG2 = 0x004 
.................... #word WREG3 = 0x006 
.................... #word WREG4 = 0x008 
.................... #word WREG5 = 0x00A 
.................... #word WREG6 = 0x00C 
.................... #word WREG7 = 0x00E 
.................... #word WREG8 = 0x010 
.................... #word WREG9 = 0x012 
.................... #word WREG10 = 0x014 
.................... #word WREG11 = 0x016 
.................... #word WREG12 = 0x018 
.................... #word WREG13 = 0x01A 
.................... #word WREG14 = 0x01C 
.................... #word WREG15 = 0x01E 
.................... #word SPLIM = 0x020 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x022 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x024 
.................... #word ACCAU = 0x026 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x028 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x02A 
.................... #word ACCBU = 0x02C 
.................... #word PC = 0x02E 
.................... #word PCH = 0x02E 
.................... #word PC = 0x02E 
.................... #word PCH = 0x030 
.................... #word TBLPAG = 0x032 
.................... #word PSVPAG = 0x034 
.................... #word RCOUNT = 0x036 
.................... #word DCOUNT = 0x038 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03A 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03C 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x03E 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x040 
.................... #word SR = 0x042 
.................... #word CORCON = 0x044 
.................... #word MODCON = 0x046 
.................... #word XMODSRT = 0x048 
.................... #word XMODEND = 0x04A 
.................... #word YMODSRT = 0x04C 
.................... #word YMODEND = 0x04E 
.................... #word XBREV = 0x050 
.................... #word DISICNT = 0x052 
.................... #word INTCON1 = 0x080 
.................... #word INTCON2 = 0x082 
.................... #word IFS0 = 0x084 
.................... #word IFS1 = 0x086 
.................... #word IFS2 = 0x088 
.................... #word IEC0 = 0x08C 
.................... #word IEC1 = 0x08E 
.................... #word IEC2 = 0x090 
.................... #word IPC0 = 0x094 
.................... #word IPC1 = 0x096 
.................... #word IPC2 = 0x098 
.................... #word IPC3 = 0x09A 
.................... #word IPC4 = 0x09C 
.................... #word IPC5 = 0x09E 
.................... #word IPC6 = 0x0A0 
.................... #word IPC7 = 0x0A2 
.................... #word IPC8 = 0x0A4 
.................... #word IPC9 = 0x0A6 
.................... #word IPC10 = 0x0A8 
.................... #word INTREG = 0x0B0 
.................... #word CNEN1 = 0x0C0 
.................... #word CNEN2 = 0x0C2 
.................... #word CNPU1 = 0x0C4 
.................... #word CNPU2 = 0x0C6 
.................... #word TMR1 = 0x100 
.................... #word PR1 = 0x102 
.................... #word T1CON = 0x104 
.................... #word TMR2 = 0x106 
.................... #word TMR3HLD = 0x108 
.................... #word TMR3 = 0x10A 
.................... #word PR2 = 0x10C 
.................... #word PR3 = 0x10E 
.................... #word T2CON = 0x110 
.................... #word T3CON = 0x112 
.................... #word TMR4 = 0x114 
.................... #word TMR5HLD = 0x116 
.................... #word TMR5 = 0x118 
.................... #word PR4 = 0x11A 
.................... #word PR5 = 0x11C 
.................... #word T4CON = 0x11E 
.................... #word T5CON = 0x120 
.................... #word IC1BUF = 0x140 
.................... #word IC1CON = 0x142 
.................... #word IC2BUF = 0x144 
.................... #word IC2CON = 0x146 
.................... #word IC3BUF = 0x148 
.................... #word IC3CON = 0x14A 
.................... #word IC4BUF = 0x14C 
.................... #word IC4CON = 0x14E 
.................... #word IC5BUF = 0x150 
.................... #word IC5CON = 0x152 
.................... #word IC6BUF = 0x154 
.................... #word IC6CON = 0x156 
.................... #word IC7BUF = 0x158 
.................... #word IC7CON = 0x15A 
.................... #word IC8BUF = 0x15C 
.................... #word IC8CON = 0x15E 
.................... #word OC1RS = 0x180 
.................... #word OC1R = 0x182 
.................... #word OC1CON = 0x184 
.................... #word OC2RS = 0x186 
.................... #word OC2R = 0x188 
.................... #word OC2CON = 0x18A 
.................... #word OC3RS = 0x18C 
.................... #word OC3R = 0x18E 
.................... #word OC3CON = 0x190 
.................... #word OC4RS = 0x192 
.................... #word OC4R = 0x194 
.................... #word OC4CON = 0x196 
.................... #word OC5RS = 0x198 
.................... #word OC5R = 0x19A 
.................... #word OC5CON = 0x19C 
.................... #word OC6RS = 0x19E 
.................... #word OC6R = 0x1A0 
.................... #word OC6CON = 0x1A2 
.................... #word OC7RS = 0x1A4 
.................... #word OC7R = 0x1A6 
.................... #word OC7CON = 0x1A8 
.................... #word OC8RS = 0x1AA 
.................... #word OC8R = 0x1AC 
.................... #word OC8CON = 0x1AE 
.................... #word I2CRCV = 0x200 
.................... #word I2CTRN = 0x202 
.................... #word I2CBRG = 0x204 
.................... #word I2CCON = 0x206 
.................... #word I2CSTAT = 0x208 
.................... #word I2CADD = 0x20A 
.................... #word U1MODE = 0x20C 
.................... #word U1STA = 0x20E 
.................... #word U1TXREG = 0x210 
.................... #word U1RXREG = 0x212 
.................... #word U1BRG = 0x214 
.................... #word U2MODE = 0x216 
.................... #word U2STA = 0x218 
.................... #word U2TXREG = 0x21A 
.................... #word U2RXREG = 0x21C 
.................... #word U2BRG = 0x21E 
.................... #word SPI1STAT = 0x220 
.................... #word SPI1CON = 0x222 
.................... #word SPI1BUF = 0x224 
.................... #word SPI2STAT = 0x226 
.................... #word SPI2CON = 0x228 
.................... #word SPI2BUF = 0x22A 
.................... #word DCICON1 = 0x240 
.................... #word DCICON2 = 0x242 
.................... #word DCICON3 = 0x244 
.................... #word DCISTAT = 0x246 
.................... #word TSCON = 0x248 
.................... #word RSCON = 0x24C 
.................... #word RXBUF0 = 0x250 
.................... #word RXBUF1 = 0x252 
.................... #word RXBUF2 = 0x254 
.................... #word RXBUF3 = 0x256 
.................... #word TXBUF0 = 0x258 
.................... #word TXBUF1 = 0x25A 
.................... #word TXBUF2 = 0x25C 
.................... #word TXBUF3 = 0x25E 
.................... #word ADCBUF0 = 0x280 
.................... #word ADCBUF1 = 0x282 
.................... #word ADCBUF2 = 0x284 
.................... #word ADCBUF3 = 0x286 
.................... #word ADCBUF4 = 0x288 
.................... #word ADCBUF5 = 0x28A 
.................... #word ADCBUF6 = 0x28C 
.................... #word ADCBUF7 = 0x28E 
.................... #word ADCBUF8 = 0x290 
.................... #word ADCBUF9 = 0x292 
.................... #word ADCBUFA = 0x294 
.................... #word ADCBUFB = 0x296 
.................... #word ADCBUFC = 0x298 
.................... #word ADCBUFD = 0x29A 
.................... #word ADCBUFE = 0x29C 
.................... #word ADCBUFF = 0x29E 
.................... #word ADCON1 = 0x2A0 
.................... #word ADCON2 = 0x2A2 
.................... #word ADCON3 = 0x2A4 
.................... #word ADCHS = 0x2A6 
.................... #word ADPCFG = 0x2A8 
.................... #word ADCSSL = 0x2AA 
.................... #word TRISA = 0x2C0 
.................... #word PORTA = 0x2C2 
.................... #word LATA = 0x2C4 
.................... #word TRISB = 0x2C6 
.................... #word PORTB = 0x2C8 
.................... #word LATB = 0x2CA 
.................... #word TRISC = 0x2CC 
.................... #word PORTC = 0x2CE 
.................... #word LATC = 0x2D0 
.................... #word TRISD = 0x2D2 
.................... #word PORTD = 0x2D4 
.................... #word LATD = 0x2D6 
.................... #word TRISF = 0x2DE 
.................... #word PORTF = 0x2E0 
.................... #word LATF = 0x2E2 
.................... #word TRISG = 0x2E4 
.................... #word PORTG = 0x2E6 
.................... #word LATG = 0x2E8 
.................... #word C1RXF0SID = 0x300 
.................... #word C1RXF0EIDH = 0x302 
.................... #word C1RXF0EIDL = 0x304 
.................... #word C1RXF1SID = 0x308 
.................... #word C1RXF1EIDH = 0x30A 
.................... #word C1RXF1EIDL = 0x30C 
.................... #word C1RXF2SID = 0x310 
.................... #word C1RXF2EIDH = 0x312 
.................... #word C1RXF2EIDL = 0x314 
.................... #word C1RXF3SID = 0x318 
.................... #word C1RXF3EIDH = 0x31A 
.................... #word C1RXF3EIDL = 0x31C 
.................... #word C1RXF4SID = 0x320 
.................... #word C1RXF4EIDH = 0x322 
.................... #word C1RXF4EIDL = 0x324 
.................... #word C1RXF5SID = 0x328 
.................... #word C1RXF5EIDH = 0x32A 
.................... #word C1RXF5EIDL = 0x32C 
.................... #word C1RXM0SID = 0x330 
.................... #word C1RXM0EIDH = 0x332 
.................... #word C1RXM0EIDL = 0x334 
.................... #word C1RXM1SID = 0x338 
.................... #word C1RXM1EIDH = 0x33A 
.................... #word C1RXM1EIDL = 0x33C 
.................... #word C1TX2SID = 0x340 
.................... #word C1TX2EID = 0x342 
.................... #word C1TX2DLC = 0x344 
.................... #word C1TX2B1 = 0x346 
.................... #word C1TX2B2 = 0x348 
.................... #word C1TX2B3 = 0x34A 
.................... #word C1TX2B4 = 0x34C 
.................... #word C1TX2CON = 0x34E 
.................... #word C1TX1SID = 0x350 
.................... #word C1TX1EID = 0x352 
.................... #word C1TX1DLC = 0x354 
.................... #word C1TX1B1 = 0x356 
.................... #word C1TX1B2 = 0x358 
.................... #word C1TX1B3 = 0x35A 
.................... #word C1TX1B4 = 0x35C 
.................... #word C1TX1CON = 0x35E 
.................... #word C1TX0SID = 0x360 
.................... #word C1TX0EID = 0x362 
.................... #word C1TX0DLC = 0x364 
.................... #word C1TX0B1 = 0x366 
.................... #word C1TX0B2 = 0x368 
.................... #word C1TX0B3 = 0x36A 
.................... #word C1TX0B4 = 0x36C 
.................... #word C1TX0CON = 0x36E 
.................... #word C1RX1SID = 0x370 
.................... #word C1RX1EID = 0x372 
.................... #word C1RX1DLC = 0x374 
.................... #word C1RX1B1 = 0x376 
.................... #word C1RX1B2 = 0x378 
.................... #word C1RX1B3 = 0x37A 
.................... #word C1RX1B4 = 0x37C 
.................... #word C1RX1CON = 0x37E 
.................... #word C1RX0SID = 0x380 
.................... #word C1RX0EID = 0x382 
.................... #word C1RX0DLC = 0x384 
.................... #word C1RX0B1 = 0x386 
.................... #word C1RX0B2 = 0x388 
.................... #word C1RX0B3 = 0x38A 
.................... #word C1RX0B4 = 0x38C 
.................... #word C1RX0CON = 0x38E 
.................... #word C1CTRL = 0x390 
.................... #word C1CFG1 = 0x392 
.................... #word C1CFG2 = 0x394 
.................... #word C1INTF = 0x396 
.................... #word C1INTE = 0x398 
.................... #word C1EC = 0x39A 
.................... #word C2RXF0SID = 0x3C0 
.................... #word C2RXF0EIDH = 0x3C2 
.................... #word C2RXF0EIDL = 0x3C4 
.................... #word C2RXF1SID = 0x3C8 
.................... #word C2RXF1EIDH = 0x3CA 
.................... #word C2RXF1EIDL = 0x3CC 
.................... #word C2RXF2SID = 0x3D0 
.................... #word C2RXF2EIDH = 0x3D2 
.................... #word C2RXF2EIDL = 0x3D4 
.................... #word C2RXF3SID = 0x3D8 
.................... #word C2RXF3EIDH = 0x3DA 
.................... #word C2RXF3EIDL = 0x3DC 
.................... #word C2RXF4SID = 0x3E0 
.................... #word C2RXF4EIDH = 0x3E2 
.................... #word C2RXF4EIDL = 0x3E4 
.................... #word C2RXF5SID = 0x3E8 
.................... #word C2RXF5EIDH = 0x3EA 
.................... #word C2RXF5EIDL = 0x3EC 
.................... #word C2RXM0SID = 0x3F0 
.................... #word C2RXM0EIDH = 0x3F2 
.................... #word C2RXM0EIDL = 0x3F4 
.................... #word C2RXM1SID = 0x3F8 
.................... #word C2RXM1EIDH = 0x3FA 
.................... #word C2RXM1EIDL = 0x3FC 
.................... #word C2TX2SID = 0x400 
.................... #word C2TX2EID = 0x402 
.................... #word C2TX2DLC = 0x404 
.................... #word C2TX2B1 = 0x406 
.................... #word C2TX2B2 = 0x408 
.................... #word C2TX2B3 = 0x40A 
.................... #word C2TX2B4 = 0x40C 
.................... #word C2TX2CON = 0x40E 
.................... #word C2TX1SID = 0x410 
.................... #word C2TX1EID = 0x412 
.................... #word C2TX1DLC = 0x414 
.................... #word C2TX1B1 = 0x416 
.................... #word C2TX1B2 = 0x418 
.................... #word C2TX1B3 = 0x41A 
.................... #word C2TX1B4 = 0x41C 
.................... #word C2TX1CON = 0x41E 
.................... #word C2TX0SID = 0x420 
.................... #word C2TX0EID = 0x422 
.................... #word C2TX0DLC = 0x424 
.................... #word C2TX0B1 = 0x426 
.................... #word C2TX0B2 = 0x428 
.................... #word C2TX0B3 = 0x42A 
.................... #word C2TX0B4 = 0x42C 
.................... #word C2TX0CON = 0x42E 
.................... #word C2RX1SID = 0x430 
.................... #word C2RX1EID = 0x432 
.................... #word C2RX1DLC = 0x434 
.................... #word C2RX1B1 = 0x436 
.................... #word C2RX1B2 = 0x438 
.................... #word C2RX1B3 = 0x43A 
.................... #word C2RX1B4 = 0x43C 
.................... #word C2RX1CON = 0x43E 
.................... #word C2RX0SID = 0x440 
.................... #word C2RX0EID = 0x442 
.................... #word C2RX0DLC = 0x444 
.................... #word C2RX0B1 = 0x446 
.................... #word C2RX0B2 = 0x448 
.................... #word C2RX0B3 = 0x44A 
.................... #word C2RX0B4 = 0x44C 
.................... #word C2RX0CON = 0x44E 
.................... #word C2CTRL = 0x450 
.................... #word C2CFG1 = 0x452 
.................... #word C2CFG2 = 0x454 
.................... #word C2INTF = 0x456 
.................... #word C2INTE = 0x458 
.................... #word C2EC = 0x45A 
.................... #word RCON = 0x740 
.................... #word OSCCON = 0x742 
.................... #word OSCTUN = 0x744 
.................... #word NVMCON = 0x760 
.................... #word NVMADR = 0x762 
.................... #word NVMADRU = 0x764 
.................... #word NVMKEY = 0x766 
.................... #word PMD1 = 0x770 
.................... #word PMD2 = 0x772 
....................  
....................  
.................... // Fuses 
.................... #fuses NOWDT, HS2_PLL8, NOPUT, NOPROTECT, DEBUG, NOBROWNOUT, NOWRTÂ  
.................... #device ICD=TRUE 
.................... // DÃ©finit la vitesse du quartz (prendre en compte si PLL employÃ©e) 
.................... #use delay(clock=80000000) 
*
00E84:  CP0     W0
00E86:  BTSC.B  42.1
00E88:  BRA     E96
00E8A:  REPEAT  #E1B
00E8C:  NOP     
00E8E:  REPEAT  #3FFE
00E90:  NOP     
00E92:  DEC     W0,W0
00E94:  BRA     NZ,E8A
00E96:  RETURN  
.................... // Config IIC 
.................... #use i2c(master,force_hw,slow,I2C1) 
*
00DD8:  MOV     #FFFF,W0
00DDA:  BTSS.B  208.3
00DDC:  BRA     DE8
00DDE:  BTSC.B  209.6
00DE0:  BRA     DDE
00DE2:  MOV     W1,202
00DE4:  BTSC.B  209.6
00DE6:  BRA     DE4
00DE8:  MOV     #0,W0
00DEA:  BTSC.B  209.7
00DEC:  INC     W0,W0
00DEE:  RETURN  
*
010D0:  MOV     #FFFF,W0
010D2:  BTSS.B  208.3
010D4:  BRA     10F8
010D6:  MOV     206,W2
010D8:  AND     W2,#1F,W2
010DA:  BRA     NZ,10D6
010DC:  BSET.B  206.3
010DE:  BTSC    W1.0
010E0:  BCLR.B  206.5
010E2:  BTSS    W1.0
010E4:  BSET.B  206.5
010E6:  MOV     206,W2
010E8:  AND     W2,#1F,W2
010EA:  BRA     NZ,10E6
010EC:  BSET.B  206.4
010EE:  BTSS.B  208.1
010F0:  BRA     10EE
010F2:  MOV     200,W0
010F4:  BTSC.B  208.6
010F6:  BCLR.B  208.6
010F8:  RETURN  
.................... #build(stack=2048) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,STREAM=ROBOTEQ) // Pour pouvoir utiliser le RS232/2 
....................  
....................  
.................... // Variables utiles (globales) 
.................... int1 flagGameEnd=0,flagTimeOut=0;	// DÃ©finit si le temps est dÃ©passÃ© 
.................... int1 flagBaliseCheck=0;				// DÃ©finit si adversaire dÃ©tectÃ© 
.................... int1 flagError=0; 					// Si une erreur doit Ãªtre affichÃ©e 
.................... //int1 HasBegun = 0;				// Permet de savoir si le jeu Ã  dÃ©marrer 
.................... int1 ToDisplay=0; 
.................... int1 IsPassedTimeOut=0; 
.................... int1 flag_depl_ok = 0; 
.................... int1 flag_end = 0; 
.................... int1 _Detected = 0;  
.................... int1 balise_on = 0; 
.................... int1 flag_error = 0;  
.................... int1 Team=0; 
.................... signed int32 ActualPosition = 0; 
.................... unsigned int8 value_balise=0;	// Valeur de la balise en dÃ©tection 
.................... unsigned int32 RealTimeMS=0,BeginTimeMS=0,GameTimeMS=0; 
.................... unsigned int8 GameTimeS=0;	// Temps de jeu 
.................... unsigned int8 Time_detected = 0; 
.................... unsigned int8 TIME_tempo_dectected = 6; 
.................... unsigned int8 No_erreur = 0;  
.................... unsigned int8 Value_bal = 0;  
.................... unsigned int8 Tempo_bal = 0 ;  
....................  
....................  
.................... unsigned int8 NoObj = 1; 
.................... unsigned int8 NoPts = 1; 
.................... unsigned int32 last_obj = 0; 
....................  
....................  
.................... // DÃ©finit les constantes ASCII, comme il n'a pas l'air de les prendre ... 
.................... enum{NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL,BS,TAB,LF,VT,FF,CR,SO,SI,DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB,CAN,EM,SUB,ESC,FS,GS,RS,US,SPACE}; 
.................... enum{Init,Send_depl_action,Depl_action_process,Switch_end_obj,Wait_end} Etat_rob = Init; 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	#define BalSensitivity 4 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Inclusion des fichiers sources 
.................... #include "driver_moteur.c" 
.................... //========================================================================================== 
.................... //																							 
.................... //						EMVs - Fonctions pour DRIVER MOTEUR MAXON 											 
.................... //						--------------------------												 
.................... //																							 
.................... //========================================================================================= 
.................... //	Développé par:		: Carrupt Aurélien    												 
.................... //						: Duay Daniel    												 
.................... //  Date				: 15.03.2013															 
.................... //  Date de modif.		: 14.02.2017															 
.................... //  Nom de la lib	 	: driver_moteur.c													 
.................... //  Version 			: V2.1																 
.................... //========================================================================================= 
.................... // Description :																			 
.................... //=============																			 
.................... //	Ce code contient les fonctions qui permettent au master de communiquer avec le driver  	 
.................... //	de moteur V3.0																			 
.................... //   
.................... //======================================================================================== 
.................... //DIRECTIVES DE PRECOMPILATIONS 
.................... //======================================================================================== 
....................  
.................... #DEFINE DRV_MODE_COURANT 0		// !!!!!!  NON IMPLEMENTE !!!!!   régulation en mode courant  
.................... #DEFINE DRV_MODE_VITESSE 1		// régulation en mode vitesse  
.................... #DEFINE DRV_MODE_NON_REGUL 2	// mode régulation désactivée  
.................... #DEFINE DRV_STOP 0				// Arrêt du moteur et arrêt d'urgence 
.................... #DEFINE DRV_RESET 1				// Reset du driver 
....................  
.................... #DEFINE DRV_ARRET_COURANT 0					// Arret en courant  
.................... #DEFINE DRV_ARRET_POSITION_ABSOLUE 1		// Arret en position absoulue 
.................... #DEFINE DRV_ARRET_POSITION_RELATIVE 2		// Arret en position relative 
.................... #DEFINE DRV_ARRET_TEMPS 3					// Arret en position temps  
.................... 			 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: go_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer un ordre de déplacement au moteur		 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					direction :			sens de rotation du moteur (int8) -> 0 ou 1																			 
.................... //					mode_regulation : 	!!!!!!  NON IMPLEMENTE !!!!!  DRV_MODE_COURANT (int8) -> régulation en courant ->paramètre_1 = valeur du courant qu'on souhaite maintenir [mA] (int16) 
.................... //										DRV_MODE_VITESSE (int8) -> régulation en vitesse  ->paramètre_1 = valeur de vitesse qu'on souhaite maintenir [impulse/s] (int16) 
.................... //										DRV_MODE_NON_REGUL (int8) -> régulation désactivée ->paramètre_1 = valeur de la PWM 0-100 en %  (int16) 
.................... //					mode_d'arret 	: 	DRV_ARRET_POSITION_ABSOLUE (int8)	-> 	parametre_2 = position a atteindre [impulse] (int32)																			   
.................... //										DRV_ARRET_POSITION_RELATIVE (int8)	->	parametre_2 = nombre d'impulsion d'encodeur a effectuer [impulse] (int32) 
.................... //										DRV_ARRET_TEMPS (int8)				->	parametre_2 = temps du parcours [ms] (int32) 
.................... //										DRV_ARRET_COURANT (int8)			->	parametre_2 = valeur du courant d'arrêt souhaité [mA] (int32)								 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 go_driver_moteur(int8 adresse_driver, int8 direction, int8 mode_regulation, int16 parametre_1, int8 mode_arret, signed int32 parametre_2) 
*
011E0:  MOV     W5,[W15++]
011E2:  MOV     W6,[W15++]
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
.................... 	int8 config; 
.................... 	 
.................... 	 
.................... 	config = ((mode_regulation & 0b00000111)<<5) + ((direction & 0b00000001)<<4) + (mode_arret & 0b00000111); 
011E4:  MOV.B   1A4E,W0L
011E6:  SE      W0,W0
011E8:  AND     W0,#7,W5
011EA:  SL      W5,#5,W5
011EC:  MOV.B   1A4D,W0L
011EE:  SE      W0,W0
011F0:  AND     W0,#1,W6
011F2:  SL      W6,#4,W0
011F4:  ADD     W0,W5,W5
011F6:  MOV.B   1A4F,W0L
011F8:  SE      W0,W0
011FA:  AND     W0,#7,W0
011FC:  ADD     W0,W5,W0
011FE:  MOV.B   W0L,1A5C
.................... 	val1 = make8(parametre_1, 0); 
01200:  MOV.B   1A50,W0L
01202:  MOV.B   W0L,1A56
.................... 	val2 = make8(parametre_1, 1); 
01204:  MOV.B   1A51,W0L
01206:  MOV.B   W0L,1A57
.................... 	val3 = make8(parametre_2, 0); 
01208:  MOV.B   1A52,W0L
0120A:  MOV.B   W0L,1A58
.................... 	val4 = make8(parametre_2, 1); 
0120C:  MOV.B   1A53,W0L
0120E:  MOV.B   W0L,1A59
.................... 	val5 = make8(parametre_2, 2); 
01210:  MOV.B   1A54,W0L
01212:  MOV.B   W0L,1A5A
.................... 	val6 = make8(parametre_2, 3); 
01214:  MOV.B   1A55,W0L
01216:  MOV.B   W0L,1A5B
.................... 	 
.................... 	i2c_start(); 
01218:  BTSS.B  208.3
0121A:  BRA     1224
0121C:  BSET.B  206.1
0121E:  BTSC.B  206.1
01220:  BRA     121E
01222:  BRA     122A
01224:  BSET.B  206.0
01226:  BTSC.B  206.0
01228:  BRA     1226
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
0122A:  MOV.B   1A4C,W0L
0122C:  MOV.B   W0L,2
0122E:  CALL    DD8
01232:  CP0.B   W0L
01234:  BRA     NZ,1278
.................... 	{ 
.................... 		i2c_write(0x48);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
01236:  MOV.B   #48,W1L
01238:  CALL    DD8
.................... 		i2c_write(config);					//configuration 
0123C:  MOV.B   1A5C,W0L
0123E:  MOV.B   W0L,2
01240:  CALL    DD8
.................... 		i2c_write(val1);					// parametre_1 
01244:  MOV.B   1A56,W0L
01246:  MOV.B   W0L,2
01248:  CALL    DD8
.................... 		i2c_write(val2); 
0124C:  MOV.B   1A57,W0L
0124E:  MOV.B   W0L,W1L
01250:  CALL    DD8
.................... 		i2c_write(val3);					// parametre_2 
01254:  MOV.B   1A58,W0L
01256:  MOV.B   W0L,2
01258:  CALL    DD8
.................... 		i2c_write(val4); 
0125C:  MOV.B   1A59,W0L
0125E:  MOV.B   W0L,W1L
01260:  CALL    DD8
.................... 		i2c_write(val5);					 
01264:  MOV.B   1A5A,W0L
01266:  MOV.B   W0L,2
01268:  CALL    DD8
.................... 		i2c_write(val6); 
0126C:  MOV.B   1A5B,W0L
0126E:  MOV.B   W0L,W1L
01270:  CALL    DD8
.................... 	} 
01274:  GOTO    128A
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
01278:  MOV     #1F,W0
0127A:  AND     206,W0
0127C:  BRA     NZ,1278
0127E:  BSET.B  206.2
01280:  BTSC.B  206.2
01282:  BRA     1280
.................... 		return 2; 
01284:  MOV.B   #2,W0L
01286:  MOV.B   W0L,0
01288:  BRA     129A
.................... 	} 
.................... 	i2c_stop();	 
0128A:  MOV     #1F,W0
0128C:  AND     206,W0
0128E:  BRA     NZ,128A
01290:  BSET.B  206.2
01292:  BTSC.B  206.2
01294:  BRA     1292
.................... 	return 1; 
01296:  MOV.B   #1,W0L
01298:  MOV.B   W0L,0
0129A:  MOV     [--W15],W6
0129C:  MOV     [--W15],W5
0129E:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur_pid																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les valeurs du PID du régulateur driver moteur	 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					reg_P 			= Valeur P du régulateur (int16)  valeur en millième  ex: 1250 = 1.25 
.................... //					reg_I 			= Valeur I du régulateur (int16)			idem 
.................... //					reg_D 			= Valeur D du régulateur (int16)			idem 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur_pid(int8 adresse_driver, int16 reg_P, int16 reg_I, int16 reg_D) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
....................  
.................... 	val1 = make8(reg_P, 0); 
*
00DF0:  MOV.B   1A40,W0L
00DF2:  MOV.B   W0L,1A3F
.................... 	val2 = make8(reg_P, 1); 
00DF4:  MOV.B   1A41,W0L
00DF6:  MOV.B   W0L,1A46
.................... 	val3 = make8(reg_I, 0); 
00DF8:  MOV.B   1A42,W0L
00DFA:  MOV.B   W0L,1A47
.................... 	val4 = make8(reg_I, 1); 
00DFC:  MOV.B   1A43,W0L
00DFE:  MOV.B   W0L,1A48
.................... 	val5 = make8(reg_D, 0); 
00E00:  MOV.B   1A44,W0L
00E02:  MOV.B   W0L,1A49
.................... 	val6 = make8(reg_D, 1); 
00E04:  MOV.B   1A45,W0L
00E06:  MOV.B   W0L,1A4A
....................  
.................... 	i2c_start(); 
00E08:  BTSS.B  208.3
00E0A:  BRA     E14
00E0C:  BSET.B  206.1
00E0E:  BTSC.B  206.1
00E10:  BRA     E0E
00E12:  BRA     E1A
00E14:  BSET.B  206.0
00E16:  BTSC.B  206.0
00E18:  BRA     E16
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00E1A:  MOV.B   1A3E,W0L
00E1C:  MOV.B   W0L,2
00E1E:  CALL    DD8
00E22:  CP0.B   W0L
00E24:  BRA     NZ,E60
.................... 	{ 
.................... 		i2c_write(0x37);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00E26:  MOV.B   #37,W1L
00E28:  CALL    DD8
.................... 		i2c_write(val1);					// parametre P 
00E2C:  MOV.B   1A3F,W0L
00E2E:  MOV.B   W0L,W1L
00E30:  CALL    DD8
.................... 		i2c_write(val2); 
00E34:  MOV.B   1A46,W0L
00E36:  MOV.B   W0L,2
00E38:  CALL    DD8
.................... 		i2c_write(val3);					// parametre I 
00E3C:  MOV.B   1A47,W0L
00E3E:  MOV.B   W0L,W1L
00E40:  CALL    DD8
.................... 		i2c_write(val4); 
00E44:  MOV.B   1A48,W0L
00E46:  MOV.B   W0L,2
00E48:  CALL    DD8
.................... 		i2c_write(val5);					// parametre D					 
00E4C:  MOV.B   1A49,W0L
00E4E:  MOV.B   W0L,W1L
00E50:  CALL    DD8
.................... 		i2c_write(val6); 
00E54:  MOV.B   1A4A,W0L
00E56:  MOV.B   W0L,2
00E58:  CALL    DD8
.................... 	} 
00E5C:  GOTO    E72
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00E60:  MOV     #1F,W0
00E62:  AND     206,W0
00E64:  BRA     NZ,E60
00E66:  BSET.B  206.2
00E68:  BTSC.B  206.2
00E6A:  BRA     E68
.................... 		return 2; 
00E6C:  MOV.B   #2,W0L
00E6E:  MOV.B   W0L,0
00E70:  BRA     E82
.................... 	} 
.................... 	i2c_stop();	 
00E72:  MOV     #1F,W0
00E74:  AND     206,W0
00E76:  BRA     NZ,E72
00E78:  BSET.B  206.2
00E7A:  BTSC.B  206.2
00E7C:  BRA     E7A
.................... 	return 1; 
00E7E:  MOV.B   #1,W0L
00E80:  MOV.B   W0L,0
00E82:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 18.03.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les rampes d'accélération et de décélération ainsi que le courant max du moteur 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					acceleration 	= valeur d'accélération en imp./sec (int16) 
.................... //					deceleration 	= valeur de décélération en imp./sec (int16)  
.................... //					courant_max 	= Valeur du courant max en mA (int16) 
.................... //					impuls_tour		= Impulsion par tour de moteur après le réducteur -> encodeur * réducteur 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur(int8 adresse_driver, int16 acceleration, int16 deceleration, int16 courant_max, int16 impuls_tour) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6, val7, val8; 
....................  
.................... 	val1 = make8(acceleration, 0); 
*
00E98:  MOV.B   1A40,W0L
00E9A:  MOV.B   W0L,1A3F
.................... 	val2 = make8(acceleration, 1); 
00E9C:  MOV.B   1A41,W0L
00E9E:  MOV.B   W0L,1A48
.................... 	val3 = make8(deceleration, 0); 
00EA0:  MOV.B   1A42,W0L
00EA2:  MOV.B   W0L,1A49
.................... 	val4 = make8(deceleration, 1); 
00EA4:  MOV.B   1A43,W0L
00EA6:  MOV.B   W0L,1A4A
.................... 	val5 = make8(courant_max, 0); 
00EA8:  MOV.B   1A44,W0L
00EAA:  MOV.B   W0L,1A4B
.................... 	val6 = make8(courant_max, 1); 
00EAC:  MOV.B   1A45,W0L
00EAE:  MOV.B   W0L,1A4C
.................... 	val7 = make8(impuls_tour, 0); 
00EB0:  MOV.B   1A46,W0L
00EB2:  MOV.B   W0L,1A4D
.................... 	val8 = make8(impuls_tour, 1); 
00EB4:  MOV.B   1A47,W0L
00EB6:  MOV.B   W0L,1A4E
....................  
.................... 	i2c_start(); 
00EB8:  BTSS.B  208.3
00EBA:  BRA     EC4
00EBC:  BSET.B  206.1
00EBE:  BTSC.B  206.1
00EC0:  BRA     EBE
00EC2:  BRA     ECA
00EC4:  BSET.B  206.0
00EC6:  BTSC.B  206.0
00EC8:  BRA     EC6
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00ECA:  MOV.B   1A3E,W0L
00ECC:  MOV.B   W0L,2
00ECE:  CALL    DD8
00ED2:  CP0.B   W0L
00ED4:  BRA     NZ,F20
.................... 	{ 
.................... 		i2c_write(0x29);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00ED6:  MOV.B   #29,W1L
00ED8:  CALL    DD8
.................... 		i2c_write(val1);					// accélération 
00EDC:  MOV.B   1A3F,W0L
00EDE:  MOV.B   W0L,W1L
00EE0:  CALL    DD8
.................... 		i2c_write(val2); 
00EE4:  MOV.B   1A48,W0L
00EE6:  MOV.B   W0L,2
00EE8:  CALL    DD8
.................... 		i2c_write(val3);					// décélération 
00EEC:  MOV.B   1A49,W0L
00EEE:  MOV.B   W0L,W1L
00EF0:  CALL    DD8
.................... 		i2c_write(val4); 
00EF4:  MOV.B   1A4A,W0L
00EF6:  MOV.B   W0L,2
00EF8:  CALL    DD8
.................... 		i2c_write(val5);					// courant max					 
00EFC:  MOV.B   1A4B,W0L
00EFE:  MOV.B   W0L,W1L
00F00:  CALL    DD8
.................... 		i2c_write(val6); 
00F04:  MOV.B   1A4C,W0L
00F06:  MOV.B   W0L,2
00F08:  CALL    DD8
.................... 		i2c_write(val7);					// impulsion par tour					 
00F0C:  MOV.B   1A4D,W0L
00F0E:  MOV.B   W0L,W1L
00F10:  CALL    DD8
.................... 		i2c_write(val8); 
00F14:  MOV.B   1A4E,W0L
00F16:  MOV.B   W0L,2
00F18:  CALL    DD8
.................... 	} 
00F1C:  GOTO    F32
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00F20:  MOV     #1F,W0
00F22:  AND     206,W0
00F24:  BRA     NZ,F20
00F26:  BSET.B  206.2
00F28:  BTSC.B  206.2
00F2A:  BRA     F28
.................... 		return 2; 
00F2C:  MOV.B   #2,W0L
00F2E:  MOV.B   W0L,0
00F30:  BRA     F42
.................... 	} 
.................... 	i2c_stop();	 
00F32:  MOV     #1F,W0
00F34:  AND     206,W0
00F36:  BRA     NZ,F32
00F38:  BSET.B  206.2
00F3A:  BTSC.B  206.2
00F3C:  BRA     F3A
.................... 	return 1; 
00F3E:  MOV.B   #1,W0L
00F40:  MOV.B   W0L,0
00F42:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer des ordres courts direct comme d'arrêter le moteur même s'il n'a pas fini l'ordre précédent ou reset le driver 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver	(int8) 
.................... //					ordre		 	= ordre à effectuer (stop = 0, reset = 1) (int8) 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 driver_moteur(int8 adresse_driver, int8 ordre) 
*
012A0:  MOV     W5,[W15++]
.................... { 
.................... 	i2c_start(); 
012A2:  BTSS.B  208.3
012A4:  BRA     12AE
012A6:  BSET.B  206.1
012A8:  BTSC.B  206.1
012AA:  BRA     12A8
012AC:  BRA     12B4
012AE:  BSET.B  206.0
012B0:  BTSC.B  206.0
012B2:  BRA     12B0
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
012B4:  MOV.B   1A4A,W0L
012B6:  MOV.B   W0L,2
012B8:  CALL    DD8
012BC:  CP0.B   W0L
012BE:  BRA     NZ,12D4
.................... 	{ 
.................... 		i2c_write(((ordre << 4) & 0b00010000) + 0x01);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
012C0:  MOV     1A4A,W5
012C2:  LSR     W5,#8,W5
012C4:  SL      W5,#4,W5
012C6:  AND     W5,#10,W5
012C8:  ADD     W5,#1,W5
012CA:  MOV.B   W5L,W1L
012CC:  CALL    DD8
.................... 	} 
012D0:  GOTO    12E6
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
012D4:  MOV     #1F,W0
012D6:  AND     206,W0
012D8:  BRA     NZ,12D4
012DA:  BSET.B  206.2
012DC:  BTSC.B  206.2
012DE:  BRA     12DC
.................... 		return 2; 
012E0:  MOV.B   #2,W0L
012E2:  MOV.B   W0L,0
012E4:  BRA     12F6
.................... 	} 
.................... 	i2c_stop();	 
012E6:  MOV     #1F,W0
012E8:  AND     206,W0
012EA:  BRA     NZ,12E6
012EC:  BSET.B  206.2
012EE:  BTSC.B  206.2
012F0:  BRA     12EE
.................... 	return 1; 
012F2:  MOV.B   #1,W0L
012F4:  MOV.B   W0L,0
012F6:  MOV     [--W15],W5
012F8:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_driver_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  Permet de lire l'état du driver								      	 
.................... == paramètre 	:  Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  retourne le status du driver											 
.................... ==				   0-> Arret  (le driver a fini tout traitement et attend le prochain ordre)	 
.................... ==				   1-> Marche (le driver est entrain d'exécuter l'ordre)													 
.................... ==				   2-> Surcharge (le driver a dépassé la limite de courant max. défini par l'utilisateur)															 
.................... ==				   3-> Erreur PONT-H (Température IC trop élevée, courant trop élevé) 
.................... ==				   4-> BUSY (le slave est entrain de traiter la prochaine commande) 
.................... ==				   5-> not ready  (le slave ne répond pas)															 
.................... /*===================================================================================================================================================================================================*/ 
.................... unsigned int8 read_driver_moteur(int8 adresse_driver) 
*
010FA:  MOV     W5,[W15++]
010FC:  CLR.B   1A55
010FE:  CLR.B   1A56
.................... { 
.................... 	int8 driver_etat=0; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
01100:  BTSS.B  208.3
01102:  BRA     110C
01104:  BSET.B  206.1
01106:  BTSC.B  206.1
01108:  BRA     1106
0110A:  BRA     1112
0110C:  BSET.B  206.0
0110E:  BTSC.B  206.0
01110:  BRA     110E
.................... 	ack = i2c_write(adresse_driver+1); 
01112:  MOV.B   1A54,W0L
01114:  SE      W0,W0
01116:  ADD     W0,#1,W5
01118:  MOV.B   W5L,W1L
0111A:  CALL    DD8
0111E:  MOV.B   W0L,1A56
.................... 	if(ack == 0) 
01120:  MOV.B   1A56,W0L
01122:  SE      W0,W0
01124:  CP0     W0
01126:  BRA     NZ,1134
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
01128:  CLR.B   W1
0112A:  CALL    10D0
0112E:  MOV.B   W0L,1A55
.................... 	} 
01130:  GOTO    1138
.................... 	else driver_etat = 5; 
01134:  MOV.B   #5,W0L
01136:  MOV.B   W0L,1A55
....................  
.................... 	i2c_stop(); 
01138:  MOV     #1F,W0
0113A:  AND     206,W0
0113C:  BRA     NZ,1138
0113E:  BSET.B  206.2
01140:  BTSC.B  206.2
01142:  BRA     1140
.................... 	return driver_etat; 
01144:  MOV.B   1A55,W0L
01146:  MOV     [--W15],W5
01148:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_pos_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  	Permet de lire la valeur du capteur incrémental du moteur 
.................... ==					Attention n'utiliser cette fonction seulement quand le moteur est à l'arrêt, sinon il y a un risque de faire planter la communication I2C						      	 
.................... == paramètre 	:  	Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  	signed 32bits -> la valeur actuel du capteur incrémental du moteur 
.................... ==					2147483647 -> interdiction de lire la position pendant un mouvement 
.................... ==					2147483648 -> not ready  (le slave ne répond pas)  
.................... ==				    
.................... /*===================================================================================================================================================================================================*/ 
.................... signed int32 read_pos_moteur(int8 adresse_driver) 
0114A:  MOV     W5,[W15++]
0114C:  CLR.B   1A4B
.................... { 
.................... 	int8 ack=0; 
.................... 	unsigned int8 buffer[4]; 
.................... 	signed int32 pos_value; 
....................  
.................... 	if (read_driver_moteur(adresse_driver) != 1) 
0114E:  MOV.B   1A4A,W0L
01150:  MOV.B   W0L,1A54
01152:  CALL    10FA
01156:  CP.B    W0L,#1
01158:  BRA     Z,11D2
.................... 		{ 
.................... 			i2c_start(); 
0115A:  BTSS.B  208.3
0115C:  BRA     1166
0115E:  BSET.B  206.1
01160:  BTSC.B  206.1
01162:  BRA     1160
01164:  BRA     116C
01166:  BSET.B  206.0
01168:  BTSC.B  206.0
0116A:  BRA     1168
.................... 			ack = i2c_write(adresse_driver+1); 
0116C:  MOV.B   1A4A,W0L
0116E:  SE      W0,W0
01170:  ADD     W0,#1,W5
01172:  MOV.B   W5L,W1L
01174:  CALL    DD8
01178:  MOV.B   W0L,1A4B
.................... 			if(ack == 0) 
0117A:  MOV.B   1A4B,W0L
0117C:  SE      W0,W0
0117E:  CP0     W0
01180:  BRA     NZ,11BC
.................... 			{ 
.................... 				i2c_read(1); 
01182:  MOV.B   #1,W1L
01184:  CALL    10D0
.................... 				buffer[0]=i2c_read(1); 
01188:  MOV.B   #1,W1L
0118A:  CALL    10D0
0118E:  MOV.B   W0L,1A4C
.................... 				buffer[1]=i2c_read(1); 
01190:  MOV.B   #1,W1L
01192:  CALL    10D0
01196:  MOV.B   W0L,1A4D
.................... 				buffer[2]=i2c_read(1); 
01198:  MOV.B   #1,W1L
0119A:  CALL    10D0
0119E:  MOV.B   W0L,1A4E
.................... 				buffer[3]=i2c_read(0); 
011A0:  CLR.B   W1
011A2:  CALL    10D0
011A6:  MOV.B   W0L,1A4F
.................... 				pos_value = make32(buffer[3],buffer[2],buffer[1],buffer[0]); 
011A8:  MOV.B   1A4F,W0L
011AA:  MOV.B   W0L,1A53
011AC:  MOV.B   1A4E,W0L
011AE:  MOV.B   W0L,1A52
011B0:  MOV.B   1A4D,W0L
011B2:  MOV.B   W0L,1A51
011B4:  MOV.B   1A4C,W0L
011B6:  MOV.B   W0L,1A50
.................... 			} 
011B8:  GOTO    11C2
.................... 			else pos_value = 2147483648; 
011BC:  CLR     1A50
011BE:  MOV     #8000,W4
011C0:  MOV     W4,1A52
.................... 		 
.................... 			i2c_stop(); 
011C2:  MOV     #1F,W0
011C4:  AND     206,W0
011C6:  BRA     NZ,11C2
011C8:  BSET.B  206.2
011CA:  BTSC.B  206.2
011CC:  BRA     11CA
.................... 		} 
011CE:  GOTO    11D8
.................... 	else pos_value = 2147483647; 
011D2:  SETM    1A50
011D4:  MOV     #7FFF,W4
011D6:  MOV     W4,1A52
....................  
.................... 	return pos_value; 
011D8:  MOV     1A50,W0
011DA:  MOV     1A52,W1
011DC:  MOV     [--W15],W5
011DE:  RETURN  
.................... }	 
.................... 	 
.................... //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... #include "Com_balises.c" 
.................... #ifndef Com_balises 
.................... #define Com_balises 
.................... 	 
.................... void Balise_config_plage(int8 no_plage, int8 deb_plage, int8 fin_plage) 
.................... {	 
.................... 	i2c_start(); 
*
01086:  BTSS.B  208.3
01088:  BRA     1092
0108A:  BSET.B  206.1
0108C:  BTSC.B  206.1
0108E:  BRA     108C
01090:  BRA     1098
01092:  BSET.B  206.0
01094:  BTSC.B  206.0
01096:  BRA     1094
.................... 	i2c_write(0x20);			// adresse de la balise 
01098:  MOV.B   #20,W1L
0109A:  CALL    DD8
.................... 	i2c_write(0x10);			// instruction de config 
0109E:  MOV.B   #10,W1L
010A0:  CALL    DD8
.................... 	i2c_write(no_plage); 
010A4:  MOV.B   1A3E,W0L
010A6:  MOV.B   W0L,2
010A8:  CALL    DD8
.................... 	i2c_write(deb_plage); 
010AC:  MOV.B   1A3F,W0L
010AE:  MOV.B   W0L,W1L
010B0:  CALL    DD8
.................... 	i2c_write(fin_plage); 
010B4:  MOV.B   1A40,W0L
010B6:  MOV.B   W0L,2
010B8:  CALL    DD8
.................... 	i2c_write('@');				// fin de la communication 
010BC:  MOV.B   #40,W1L
010BE:  CALL    DD8
.................... 	i2c_stop(); 
010C2:  MOV     #1F,W0
010C4:  AND     206,W0
010C6:  BRA     NZ,10C2
010C8:  BSET.B  206.2
010CA:  BTSC.B  206.2
010CC:  BRA     10CA
010CE:  RETURN  
.................... } 
....................  
.................... void Balise_set_plage(int8 select_plage) 
.................... { 
.................... 	i2c_start(); 
*
03240:  BTSS.B  208.3
03242:  BRA     324C
03244:  BSET.B  206.1
03246:  BTSC.B  206.1
03248:  BRA     3246
0324A:  BRA     3252
0324C:  BSET.B  206.0
0324E:  BTSC.B  206.0
03250:  BRA     324E
.................... 	i2c_write(0x20);			// adresse de la balise 
03252:  MOV.B   #20,W1L
03254:  CALL    DD8
.................... 	i2c_write(0x80);			// instruction de set 
03258:  MOV.B   #80,W1L
0325A:  CALL    DD8
.................... 	i2c_write(select_plage); 
0325E:  MOV.B   1A7C,W0L
03260:  MOV.B   W0L,2
03262:  CALL    DD8
.................... 	i2c_write('@');				// fin de la communication 
03266:  MOV.B   #40,W1L
03268:  CALL    DD8
.................... 	i2c_stop();	 
0326C:  MOV     #1F,W0
0326E:  AND     206,W0
03270:  BRA     NZ,326C
03272:  BSET.B  206.2
03274:  BTSC.B  206.2
03276:  BRA     3274
03278:  RETURN  
.................... } 
....................  
.................... unsigned int8 Check_balise(void) 
.................... { 
.................... 	static unsigned int8 ack_balise=0; 
....................  
.................... 	i2c_start(); 
*
04C9E:  BTSS.B  208.3
04CA0:  BRA     4CAA
04CA2:  BSET.B  206.1
04CA4:  BTSC.B  206.1
04CA6:  BRA     4CA4
04CA8:  BRA     4CB0
04CAA:  BSET.B  206.0
04CAC:  BTSC.B  206.0
04CAE:  BRA     4CAC
.................... 	ack_balise=i2c_write(0x21);			// adresse de balise en lecture 
04CB0:  MOV.B   #21,W1L
04CB2:  CALL    DD8
04CB6:  MOV.B   W0L,87A
.................... 	if(ack_balise==0) 
04CB8:  CP0.B   87A
04CBA:  BRA     NZ,4CC8
.................... 	{					// si elle est dÃ©tectÃ©e - demander sa lecture 
.................... 		delay_us(30); 
04CBC:  REPEAT  #256
04CBE:  NOP     
.................... 		value_balise=i2c_read(0); 
04CC0:  CLR.B   W1
04CC2:  CALL    10D0
04CC6:  MOV.B   W0L,860
.................... 	} 
.................... 	i2c_stop(); 
04CC8:  MOV     #1F,W0
04CCA:  AND     206,W0
04CCC:  BRA     NZ,4CC8
04CCE:  BSET.B  206.2
04CD0:  BTSC.B  206.2
04CD2:  BRA     4CD0
....................  
.................... 	return value_balise; 
04CD4:  MOV.B   860,W0L
04CD6:  MOV.B   W0L,0
04CD8:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Init.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 05.03.2015																== 
.................... ===  Nom du programme 	: InterfaceRoboteQuC.mcp													== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Fonctions d'initialisation du dsPIC30F6014A.				    								== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Init 
.................... #define ___Init 
....................  
.................... //**************************************************************************************************** 
.................... //*  Défintion des bits 
.................... //*  ! Utiliser LATx pour des sorties et PORTx pour des entrées lorsque commandes succintes rapides. ! 
.................... //**************************************************************************************************** 
.................... #bit _LED1 = LATC.1			//--| 
.................... #bit _LED2 = LATC.2			//	| 
.................... #bit _LED3 = LATC.3			//	|- LEDs 
.................... #bit _LED4 = LATC.4			//	| 
....................  
.................... #bit _DEMA = PORTA.10		//--| 
.................... #bit _TEAM = PORTA.12		//	| 
.................... #bit _Dig3 = PORTA.13		//	|- Digital Inputs 
.................... #bit _Dig4 = PORTA.6		//	| 
.................... #bit _ZeroPoint = PORTA.7		//  | 
.................... #bit _Dig6 = PORTA.9		//	| 
....................  
.................... #bit _Out1 = LATD.0 		//--| 
.................... #bit _Out2 = LATD.1	    //	| 
.................... #bit _Out3 = LATD.2 	 	//	| 
.................... #bit _Out4 = LATD.3 		//	|- Outputs 
.................... #bit _SERV = LATD.4		//	| 
.................... #bit _LDT1 = LATD.5 		//	| 
.................... #bit _LDT2 = LATD.6		//  | 
.................... #bit _Out8 = LATD.7		//	| 
....................  
.................... #bit _Tim1On = T1CON.15 
.................... #bit _Tim2On = T2CON.15 
.................... #bit _Tim3On = T3CON.15 
....................  
.................... #bit _I2CEN = I2CCON.15 
.................... #bit _GCEN = I2CCON.7 
....................  
.................... #bit _En_Diz = PORTB.10 
.................... #bit _EN_Uni = PORTB.11 
....................  
....................  
.................... enum{STOP,CHARGE_OBJ,DRIVER_GO,OBJ_PERSO,DRIVER_DONE,OBJ_DONE,WAIT}State=STOP; 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    __Init_dsPIC 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    30.01.2015 
.................... //  Statut :    Fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Config. et initialisation du dsPIC30F6014A. 
.................... //	Paramètre(s): / 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Init_dsPIC(void) 
.................... { 
.................... 	//------------------------------------------------------------------------------ 
.................... 	// Configuration des I/O 
.................... 	TRISA = 0b0011011011000000;		// RA6,7,9,10,12,13 : Digital Input 
*
00F44:  MOV     #36C0,W4
00F46:  MOV     W4,2C0
.................... 	PORTA=0; 
00F48:  CLR     2C2
.................... 	TRISB = 0b0000000000111100;		// RB2-5: Analog Input 
00F4A:  MOV     #3C,W4
00F4C:  MOV     W4,2C6
.................... 	PORTB=0; 
00F4E:  CLR     2C8
.................... 	TRISC = 0b0000000000000000;		// RC1-4: LEDs 
00F50:  CLR     2CC
.................... 	PORTC=0; 
00F52:  CLR     2CE
.................... 	TRISD = 0b0000000000000000;		// RD0-7: Outputs 
00F54:  CLR     2D2
.................... 	PORTD=0; 
00F56:  CLR     2D4
.................... 	TRISF = 0b0000000000010100;		// RF2-5: Rx1, Tx1, Rx2, Tx2 
00F58:  MOV     #14,W4
00F5A:  MOV     W4,2DE
.................... 	PORTF=0; 
00F5C:  CLR     2E0
.................... 	TRISG = 0b0000000000001100;		// RG2-3: SCL-SDA 
00F5E:  MOV     #C,W4
00F60:  MOV     W4,2E4
.................... 	PORTG=0;  
00F62:  CLR     2E6
....................  
....................  
.................... // configuration de l'I2C 
.................... 	I2CCON = 0x800f;//LAISSER, SINON L'I2C PLANTE 
00F64:  MOV     #800F,W4
00F66:  MOV     W4,206
.................... //	_GCEN=0; 
.................... //	_I2CEN=1; 
.................... 	 
.................... 	// Temps de jeu 
.................... 	// Set le timer1 à 1 [ms] 
.................... 	setup_timer1(TMR_INTERNAL,0x4E20);	 
00F68:  CLR     104
00F6A:  MOV     #4E20,W4
00F6C:  MOV     W4,102
00F6E:  MOV     #8000,W4
00F70:  MOV     W4,104
....................  
.................... 	// Capture balise 
.................... 	// Set le timer3 avec la fréquence interne, incrément chaque 64 instructions, jusque 31250 => 100 [ms] 
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, 31250); 
00F72:  CLR     112
00F74:  MOV     #7A12,W4
00F76:  MOV     W4,10E
00F78:  MOV     #8020,W4
00F7A:  MOV     W4,112
.................... 	 
.................... 	// Autorise le timer1 
.................... 	enable_interrupts(INT_TIMER1); 
00F7C:  BSET.B  8C.3
.................... 	// Autorise le timer3 
.................... 	enable_interrupts(INT_TIMER3); 
00F7E:  BSET.B  8C.7
.................... 	// Interruptions RS232 
.................... 	enable_interrupts(INT_RDA2);	// Réception RS232/1 
00F80:  BSET.B  8F.0
.................... 	// Autorise les interruptions globalement 
.................... 	enable_interrupts(INTR_GLOBAL); 
00F82:  BCLR.B  81.7
00F84:  CLR     42
00F86:  BSET.B  81.7
.................... 	 
.................... 	config_driver_moteur_pid(0xC0, 200, 1, 0); 
00F88:  MOV.B   #C0,W0L
00F8A:  MOV.B   W0L,1A3E
00F8C:  MOV     #C8,W4
00F8E:  MOV     W4,1A40
00F90:  MOV     #1,W4
00F92:  MOV     W4,1A42
00F94:  CLR     1A44
00F96:  CALL    DF0
.................... 	config_driver_moteur_pid(0xC2, 200, 1, 0); 
00F9A:  MOV.B   #C2,W0L
00F9C:  MOV.B   W0L,1A3E
00F9E:  MOV     #C8,W4
00FA0:  MOV     W4,1A40
00FA2:  MOV     #1,W4
00FA4:  MOV     W4,1A42
00FA6:  CLR     1A44
00FA8:  CALL    DF0
.................... 	delay_ms(10); 
00FAC:  MOV     #A,W0
00FAE:  CALL    E84
.................... 	 
.................... 	config_driver_moteur(0xC0, 5000, 5000, 1000,4556);//moteur barillet 
00FB2:  MOV.B   #C0,W0L
00FB4:  MOV.B   W0L,1A3E
00FB6:  MOV     #1388,W4
00FB8:  MOV     W4,1A40
00FBA:  MOV     #1388,W4
00FBC:  MOV     W4,1A42
00FBE:  MOV     #3E8,W4
00FC0:  MOV     W4,1A44
00FC2:  MOV     #11CC,W4
00FC4:  MOV     W4,1A46
00FC6:  CALL    E98
.................... 	config_driver_moteur(0xC2, 5000, 5000, 2000,0);//moteur éjection 
00FCA:  MOV.B   #C2,W0L
00FCC:  MOV.B   W0L,1A3E
00FCE:  MOV     #1388,W4
00FD0:  MOV     W4,1A40
00FD2:  MOV     #1388,W4
00FD4:  MOV     W4,1A42
00FD6:  MOV     #7D0,W4
00FD8:  MOV     W4,1A44
00FDA:  CLR     1A46
00FDC:  CALL    E98
.................... 	config_driver_moteur(0xC4, 5000, 5000, 1000,0);//moteur poussage 
00FE0:  MOV.B   #C4,W0L
00FE2:  MOV.B   W0L,1A3E
00FE4:  MOV     #1388,W4
00FE6:  MOV     W4,1A40
00FE8:  MOV     #1388,W4
00FEA:  MOV     W4,1A42
00FEC:  MOV     #3E8,W4
00FEE:  MOV     W4,1A44
00FF0:  CLR     1A46
00FF2:  CALL    E98
.................... 	delay_ms(10); 
00FF6:  MOV     #A,W0
00FF8:  CALL    E84
.................... 	 
.................... 	return; 
00FFC:  RETURN  
.................... 	 
.................... } 
.................... 	 
.................... #endif 
....................  
.................... #include "data/___data.h" 
.................... /* 
.................... * \file ___data.h 
.................... * \brief Data pour le robot. 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.03.2016 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___data_H 
.................... #define ___data_H 
....................  
.................... 	 
.................... 	int1 Depl_send = 0; 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	////////// Gestion erreurs 
.................... 	int1 Base = 0; 
.................... 	int16 TableWidth =3000; 
.................... 	unsigned int8 NbreZone_check = 0; 
.................... 	char RoboteQ_receiveBuffer[256]={};			// Buffer des donnÃ©es reÃ§ues 
.................... 	unsigned int8 TabSentRS232[256]={0}; 
....................  
....................  
.................... 	 
.................... 	unsigned int16 TIME_SURCHAUFFE_MS = 1000; 
.................... 	unsigned int8 Erreur_max_surchauffe = 10; 
.................... 	unsigned int32 Time_ejection = 0; 
.................... 	unsigned int32 Time_ejection_toDo = 0; 
.................... 	int1 Action_send = 0;	 
....................  
.................... 	signed int16 TabObjectifs[7][13][12] = {0}; 
.................... 	unsigned int16 TabZones[10][8] = {0}; 
....................  
.................... 	// Objectif en cours 
.................... 	signed int16 oXp=0,oYp=0,oType=0,oAvAr=0,oCoteTourn=0,oVitMax=0,Obj_Action = 0,Pt_commun = 0,Ponderation = 0,Obj_end = 0,Next_obj = 0,keep_obj = 0;	 
.................... 	 
.................... 	 
.................... 	////////// UART 
.................... 	unsigned int8 UART_WD_DELAY = 20;	// Délai du watchdog UART, en [ms]; par pas de 1 [ms] 
.................... 	unsigned int8 UART_NBR_REP_NAK = 5;	// Combien de fois maximum il faut répéter une commande si le récepteur n'a pas compris  
.................... 	// Adresse UART du driver 
.................... 	unsigned int32 UART_ADDR = 2; 
.................... 	 
.................... 	////////// IIC 
.................... 	// Combien de fois maximum il faut répéter une commande si le récepteur n'a pas compris 
.................... //	unsigned int8 IIC_NBR_REP_NAK = 5;	 
.................... 	// Combien de fois on rééssaie un envoie 
.................... //	unsigned int8 IIC_NBR_REP_ENV = 5; 
....................  	//Adresse IIC du driver 
.................... //	unsigned int8 DRIVER_IIC_ADR = 0x50; 
.................... //	unsigned int8 TabToSendIIC[60]={0}; 
....................  
.................... 	 
.................... 	////////// Balise ///////// 
.................... 	unsigned int8 MAX_VALUE_DETECT_BALISE = 3; // Valeur maximum pour la détection de l'adversaire (action trig si <=) 
.................... 	unsigned int16 TIME_TO_CHECK_BAL=200;	// Temps avant chaque check balise 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Mise en marche/arrêt 
.................... int1 flagMarche = 0; 
....................  
.................... // Pour le nombre d'objectifs déjà enregistrés 
.................... unsigned int16 NbreObjectifs = 0; 
.................... 	// Pour connaître le prochain objectif à atteindre 
.................... unsigned int16 NextObj = 0; 
....................  
.................... ////PC 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
021DC:  MOV     W5,[W15++]
021DE:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
021E0:  BCLR.B  1A97.0
....................    y = x; 
021E2:  PUSH    1A92
021E4:  POP     1A98
021E6:  PUSH    1A94
021E8:  POP     1A9A
....................  
....................    if (x < 0) 
021EA:  MOV     1A92,W0
021EC:  MOV     1A94,W1
021EE:  MOV     #0,W2
021F0:  MOV     #0,W3
021F2:  CALL    1EA0
021F6:  BRA     NC,2204
....................    { 
....................       s = 1; 
021F8:  BSET.B  1A97.0
....................       y = -y; 
021FA:  MOV     #1A98,W0
021FC:  MOV     #1A98,W1
021FE:  REPEAT  #3
02200:  MOV     [W0++],[W1++]
02202:  BTG.B   1A9B.7
....................    } 
....................  
....................    if (y <= 32768.0) 
02204:  MOV     1A98,W0
02206:  MOV     1A9A,W1
02208:  MOV     #0,W2
0220A:  MOV     #4700,W3
0220C:  CALL    1EA0
02210:  BRA     C,2214
02212:  BRA     NZ,2228
....................       res = (float32)(unsigned int16)y; 
02214:  MOV     1A98,W0
02216:  MOV     1A9A,W1
02218:  CALL    1F08
0221C:  CALL    1F34
02220:  MOV     W0,1A9C
02222:  MOV     W1,1A9E
02224:  GOTO    22BC
....................  
....................  else if (y < 10000000.0) 
02228:  MOV     1A98,W0
0222A:  MOV     1A9A,W1
0222C:  MOV     #9680,W2
0222E:  MOV     #4B18,W3
02230:  CALL    1EA0
02234:  BRA     NC,22B4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
02236:  MOV     1A98,W0
02238:  MOV     1A9A,W1
0223A:  MOV     #0,W2
0223C:  MOV     #3800,W3
0223E:  CALL    1F6E
02242:  CALL    1F08
02246:  MOV     W0,1AA0
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
02248:  MOV     1A98,W0
0224A:  MOV     1A9A,W1
0224C:  MOV     #0,W2
0224E:  MOV     #3800,W3
02250:  CALL    1F6E
02254:  MOV     W0,W5
02256:  MOV     W1,W6
02258:  MOV     1AA0,W0
0225A:  CALL    1F34
0225E:  BSET.B  43.0
02260:  MOV     W0,W2
02262:  MOV     W1,W3
02264:  MOV     W5,W0
02266:  MOV     W6,W1
02268:  CALL    2032
0226C:  MOV     W0,W2
0226E:  MOV     W1,W3
02270:  MOV     #0,W0
02272:  MOV     #4700,W1
02274:  CALL    1F6E
02278:  MOV     W0,1A98
0227A:  MOV     W1,1A9A
....................       res = 32768.0*(float32)l; 
0227C:  MOV     1AA0,W0
0227E:  CALL    1F34
02282:  MOV     W0,W2
02284:  MOV     W1,W3
02286:  MOV     #0,W0
02288:  MOV     #4700,W1
0228A:  CALL    1F6E
0228E:  MOV     W0,1A9C
02290:  MOV     W1,1A9E
....................       res += (float32)(unsigned int16)y; 
02292:  MOV     1A98,W0
02294:  MOV     1A9A,W1
02296:  CALL    1F08
0229A:  CALL    1F34
0229E:  BCLR.B  43.0
022A0:  MOV     W0,W2
022A2:  MOV     W1,W3
022A4:  MOV     1A9C,W0
022A6:  MOV     1A9E,W1
022A8:  CALL    2032
022AC:  MOV     W0,1A9C
022AE:  MOV     W1,1A9E
....................    } 
022B0:  GOTO    22BC
....................  
....................  else 
....................   res = y; 
022B4:  PUSH    1A98
022B6:  POP     1A9C
022B8:  PUSH    1A9A
022BA:  POP     1A9E
....................  
....................  y = y - (float32)(unsigned int16)y; 
022BC:  MOV     1A98,W0
022BE:  MOV     1A9A,W1
022C0:  CALL    1F08
022C4:  CALL    1F34
022C8:  BSET.B  43.0
022CA:  MOV     W0,W2
022CC:  MOV     W1,W3
022CE:  MOV     1A98,W0
022D0:  MOV     1A9A,W1
022D2:  CALL    2032
022D6:  MOV     W0,1A98
022D8:  MOV     W1,1A9A
....................  
....................  if (s) 
022DA:  BTSS.B  1A97.0
022DC:  BRA     22E8
....................   res = -res; 
022DE:  MOV     #1A9C,W0
022E0:  MOV     #1A9C,W1
022E2:  REPEAT  #3
022E4:  MOV     [W0++],[W1++]
022E6:  BTG.B   1A9F.7
....................  
....................  if (y != 0) 
022E8:  MOV     1A98,W0
022EA:  MOV     1A9A,W1
022EC:  MOV     #0,W2
022EE:  MOV     #0,W3
022F0:  CALL    1EA0
022F4:  BRA     Z,232C
....................  { 
....................   if (s == 1 && n == 0) 
022F6:  BTSS.B  1A97.0
022F8:  BRA     2310
022FA:  CP0.B   1A96
022FC:  BRA     NZ,2310
....................    res -= 1.0; 
022FE:  BSET.B  43.0
02300:  MOV     1A9C,W0
02302:  MOV     1A9E,W1
02304:  MOV     #0,W2
02306:  MOV     #3F80,W3
02308:  CALL    2032
0230C:  MOV     W0,1A9C
0230E:  MOV     W1,1A9E
....................  
....................   if (s == 0 && n == 1) 
02310:  BTSC.B  1A97.0
02312:  BRA     232C
02314:  MOV     1A96,W4
02316:  CP.B    W4L,#1
02318:  BRA     NZ,232C
....................    res += 1.0; 
0231A:  BCLR.B  43.0
0231C:  MOV     1A9C,W0
0231E:  MOV     1A9E,W1
02320:  MOV     #0,W2
02322:  MOV     #3F80,W3
02324:  CALL    2032
02328:  MOV     W0,1A9C
0232A:  MOV     W1,1A9E
....................  } 
....................  if (x == 0) 
0232C:  MOV     1A92,W0
0232E:  MOV     1A94,W1
02330:  MOV     #0,W2
02332:  MOV     #0,W3
02334:  CALL    1EA0
02338:  BRA     NZ,233E
....................     res = 0; 
0233A:  CLR     1A9C
0233C:  CLR     1A9E
....................  
....................  return (res); 
0233E:  MOV     1A9C,W0
02340:  MOV     1A9E,W1
02342:  MOV     [--W15],W6
02344:  MOV     [--W15],W5
02346:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
02348:  CLR.B   1A96
0234A:  PUSH    1A88
0234C:  POP     1A92
0234E:  PUSH    1A8A
02350:  POP     1A94
02352:  CALL    21DC
02356:  MOV.D   W0,W0
02358:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
0235A:  MOV.B   #1,W0L
0235C:  MOV.B   W0L,1A96
0235E:  PUSH    1A88
02360:  POP     1A92
02362:  PUSH    1A8A
02364:  POP     1A94
02366:  CALL    21DC
0236A:  MOV.D   W0,W0
0236C:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
03B38:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
03B3A:  MOV     1A60,W0
03B3C:  MOV     1A62,W1
03B3E:  MOV     #0,W2
03B40:  MOV     #0,W3
03B42:  CALL    1EA0
03B46:  BRA     C,3B4A
03B48:  BRA     NZ,3B50
....................       return(0.0); 
03B4A:  MOV     #0,W0
03B4C:  MOV     #0,W1
03B4E:  BRA     3C14
....................  
....................    y=x; 
03B50:  PUSH    1A60
03B52:  POP     1A64
03B54:  PUSH    1A62
03B56:  POP     1A66
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
03B58:  MOV     #1A67,W4
03B5A:  MOV     W4,1A70
....................     data1 = *(((unsigned int8 *)(&y))+3); 
03B5C:  MOV     #1A67,W0
03B5E:  MOV     1A6C,W4
03B60:  MOV.B   [W0+#0],W4L
03B62:  MOV     W4,1A6C
03B64:  CLR.B   1A6D
....................     data2 = *(((unsigned int8 *)(&y))+2); 
03B66:  MOV     #1A66,W0
03B68:  MOV     1A6E,W4
03B6A:  MOV.B   [W0+#0],W4L
03B6C:  MOV     W4,1A6E
03B6E:  CLR.B   1A6F
....................     rotate_left(&data1,1);     
03B70:  MOV     #1A6C,W1
03B72:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
03B74:  BTSS.B  1A6E.7
03B76:  BRA     3B7C
....................        bit_set(data1,0);     
03B78:  MOV     #1A6C,W4
03B7A:  BSET    [W4].0
....................     data1 = ((data1+127) >>1); 
03B7C:  MOV     #7F,W4
03B7E:  MOV     1A6C,W3
03B80:  ADD     W3,W4,W5
03B82:  MOV     W5,1A6C
03B84:  LSR     1A6C
....................     bit_clear(data2,7); 
03B86:  MOV     #1A6E,W4
03B88:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
03B8A:  BTSS.B  1A6C.0
03B8C:  BRA     3B92
....................        bit_set(data2,7); 
03B8E:  MOV     #1A6E,W4
03B90:  BSET    [W4].7
....................     data1 = data1 >>1; 
03B92:  LSR     1A6C
....................     *(((unsigned int8 *)(&y))+3) = data1; 
03B94:  MOV     #1A67,W5
03B96:  MOV     1A6C,W0
03B98:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
03B9A:  MOV     #1A66,W5
03B9C:  MOV     1A6E,W0
03B9E:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
03BA0:  PUSH    1A64
03BA2:  POP     1A68
03BA4:  PUSH    1A66
03BA6:  POP     1A6A
....................       y+=(x/y); 
03BA8:  MOV     1A60,W0
03BAA:  MOV     1A62,W1
03BAC:  MOV     1A64,W2
03BAE:  MOV     1A66,W3
03BB0:  CALL    3A6E
03BB4:  BCLR.B  43.0
03BB6:  MOV     W0,W2
03BB8:  MOV     W1,W3
03BBA:  MOV     1A64,W0
03BBC:  MOV     1A66,W1
03BBE:  CALL    2032
03BC2:  MOV     W0,1A64
03BC4:  MOV     W1,1A66
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
03BC6:  MOV     #1A67,W0
03BC8:  MOV     1A6C,W4
03BCA:  MOV.B   [W0+#0],W4L
03BCC:  MOV     W4,1A6C
03BCE:  CLR.B   1A6D
....................     data2 = *(((unsigned int8 *)(&y))+2); 
03BD0:  MOV     #1A66,W0
03BD2:  MOV     1A6E,W4
03BD4:  MOV.B   [W0+#0],W4L
03BD6:  MOV     W4,1A6E
03BD8:  CLR.B   1A6F
....................     rotate_left(&data1,1); 
03BDA:  MOV     #1A6C,W1
03BDC:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
03BDE:  BTSS.B  1A6E.7
03BE0:  BRA     3BE6
....................        bit_set(data1,0);     
03BE2:  MOV     #1A6C,W4
03BE4:  BSET    [W4].0
....................     data1--; 
03BE6:  DEC     1A6C
....................     bit_clear(data2,7); 
03BE8:  MOV     #1A6E,W4
03BEA:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
03BEC:  BTSS.B  1A6C.0
03BEE:  BRA     3BF4
....................        bit_set(data2,7); 
03BF0:  MOV     #1A6E,W4
03BF2:  BSET    [W4].7
....................     data1 = data1 >>1; 
03BF4:  LSR     1A6C
....................     *(((unsigned int8 *)(&y))+3) = data1; 
03BF6:  MOV     #1A67,W5
03BF8:  MOV     1A6C,W0
03BFA:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
03BFC:  MOV     #1A66,W5
03BFE:  MOV     1A6E,W0
03C00:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
03C02:  MOV     1A68,W0
03C04:  MOV     1A6A,W1
03C06:  MOV     1A64,W2
03C08:  MOV     1A66,W3
03C0A:  CALL    1EA0
03C0E:  BRA     NZ,3BA0
....................  
....................    return(res); 
03C10:  MOV     1A68,W0
03C12:  MOV     1A6A,W1
03C14:  MOV     [--W15],W5
03C16:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
*
02960:  MOV     W5,[W15++]
02962:  MOV     W6,[W15++]
02964:  MOV     W7,[W15++]
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
02966:  MOV     1AD0,W0
02968:  MOV     1AD2,W1
0296A:  MOV     1AD4,W2
0296C:  MOV     1AD6,W3
0296E:  MOV     #0,W4
02970:  MOV     #0,W5
02972:  MOV     #0,W6
02974:  MOV     #0,W7
02976:  CALL    1DD8
0297A:  BRA     C,297E
0297C:  BRA     NZ,2988
....................       return(0.0); 
0297E:  MOV     #0,W0
02980:  MOV     #0,W1
02982:  MOV     #0,W2
02984:  MOV     #0,W3
02986:  BRA     2A74
....................  
....................    y=x; 
02988:  PUSH    1AD0
0298A:  POP     1AD8
0298C:  PUSH    1AD2
0298E:  POP     1ADA
02990:  PUSH    1AD4
02992:  POP     1ADC
02994:  PUSH    1AD6
02996:  POP     1ADE
....................    p= (((unsigned int16 *)(&y))+3); 
02998:  MOV     #1ADE,W4
0299A:  MOV     W4,1AE8
....................    temp1 = *p; 
0299C:  MOV     1AE8,W0
0299E:  MOV     [W0],[W15++]
029A0:  POP     1AEA
....................    temp2 = *p; 
029A2:  MOV     1AE8,W0
029A4:  MOV     [W0],[W15++]
029A6:  POP     1AEC
....................    bit_clear(temp1,15); 
029A8:  MOV     #1AEA,W4
029AA:  BCLR    [W4].F
....................    temp1 = (temp1>>4)+1023; 
029AC:  MOV     1AEA,W5
029AE:  LSR     W5,#4,W5
029B0:  MOV     #3FF,W4
029B2:  ADD     W5,W4,W0
029B4:  MOV     W0,1AEA
....................    temp1 = temp1 >> 1; 
029B6:  LSR     1AEA
....................    temp1 = (temp1<<4) & 0xFFF0; 
029B8:  MOV     1AEA,W5
029BA:  SL      W5,#4,W5
029BC:  MOV     #FFF0,W0
029BE:  AND     W0,W5,W0
029C0:  MOV     W0,1AEA
....................    if(bit_test(temp2,15)) 
029C2:  BTSS.B  1AED.7
029C4:  BRA     29CA
....................       bit_set(temp1,15); 
029C6:  MOV     #1AEA,W4
029C8:  BSET    [W4].F
....................    temp2 = temp2 & 0x000F; 
029CA:  MOV     1AEC,W0
029CC:  AND     W0,#F,W0
029CE:  MOV     W0,1AEC
....................    temp1 ^= temp2; 
029D0:  MOV     1AEC,W0
029D2:  XOR     1AEA
....................     
....................    (*p) = temp1; 
029D4:  MOV     1AE8,W5
029D6:  MOV     1AEA,W4
029D8:  MOV     W4,[W5+#0]
....................     
....................    do { 
....................       res=y; 
029DA:  PUSH    1AD8
029DC:  POP     1AE0
029DE:  PUSH    1ADA
029E0:  POP     1AE2
029E2:  PUSH    1ADC
029E4:  POP     1AE4
029E6:  PUSH    1ADE
029E8:  POP     1AE6
....................       y+=(x/y); 
029EA:  MOV     1AD0,W0
029EC:  MOV     1AD2,W1
029EE:  MOV     1AD4,W2
029F0:  MOV     1AD6,W3
029F2:  MOV     1AD8,W4
029F4:  MOV     1ADA,W5
029F6:  MOV     1ADC,W6
029F8:  MOV     1ADE,W7
029FA:  CALL    CD0
029FE:  BCLR.B  43.0
02A00:  MOV     W0,W4
02A02:  MOV     W1,W5
02A04:  MOV     W2,W6
02A06:  MOV     W3,W7
02A08:  MOV     1AD8,W0
02A0A:  MOV     1ADA,W1
02A0C:  MOV     1ADC,W2
02A0E:  MOV     1ADE,W3
02A10:  CALL    1BEA
02A14:  MOV     W0,1AD8
02A16:  MOV     W1,1ADA
02A18:  MOV     W2,1ADC
02A1A:  MOV     W3,1ADE
....................      temp1 = *p; 
02A1C:  MOV     1AE8,W0
02A1E:  MOV     [W0],[W15++]
02A20:  POP     1AEA
....................      temp2 = *p; 
02A22:  MOV     1AE8,W0
02A24:  MOV     [W0],[W15++]
02A26:  POP     1AEC
....................      bit_clear(temp1,15); 
02A28:  MOV     #1AEA,W4
02A2A:  BCLR    [W4].F
....................      temp1 = (temp1>>4); 
02A2C:  MOV     1AEA,W0
02A2E:  LSR     W0,#4,W0
02A30:  MOV     W0,1AEA
....................      temp1--; 
02A32:  DEC     1AEA
....................      temp1 = (temp1<<4) & 0xFFF0; 
02A34:  MOV     1AEA,W5
02A36:  SL      W5,#4,W5
02A38:  MOV     #FFF0,W0
02A3A:  AND     W0,W5,W0
02A3C:  MOV     W0,1AEA
....................      if(bit_test(temp2,15)) 
02A3E:  BTSS.B  1AED.7
02A40:  BRA     2A46
....................         bit_set(temp1,15); 
02A42:  MOV     #1AEA,W4
02A44:  BSET    [W4].F
....................      temp2 = temp2 & 0x000F; 
02A46:  MOV     1AEC,W0
02A48:  AND     W0,#F,W0
02A4A:  MOV     W0,1AEC
....................      temp1 ^= temp2; 
02A4C:  MOV     1AEC,W0
02A4E:  XOR     1AEA
....................      (*p) = temp1; 
02A50:  MOV     1AE8,W5
02A52:  MOV     1AEA,W4
02A54:  MOV     W4,[W5+#0]
....................  
....................    } while(res != y); 
02A56:  MOV     1AE0,W0
02A58:  MOV     1AE2,W1
02A5A:  MOV     1AE4,W2
02A5C:  MOV     1AE6,W3
02A5E:  MOV     1AD8,W4
02A60:  MOV     1ADA,W5
02A62:  MOV     1ADC,W6
02A64:  MOV     1ADE,W7
02A66:  CALL    1DD8
02A6A:  BRA     NZ,29DA
....................  
....................    return(res); 
02A6C:  MOV     1AE0,W0
02A6E:  MOV     1AE2,W1
02A70:  MOV     1AE4,W2
02A72:  MOV     1AE6,W3
02A74:  MOV     [--W15],W7
02A76:  MOV     [--W15],W6
02A78:  MOV     [--W15],W5
02A7A:  RETURN  
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
*
03FA0:  MOV     W5,[W15++]
03FA2:  MOV     W6,[W15++]
03FA4:  MOV     W7,[W15++]
03FA6:  MOV     W8,[W15++]
03FA8:  CLR     1A88
03FAA:  CLR     1A8A
03FAC:  CLR     1A8C
03FAE:  MOV     #3FF0,W4
03FB0:  MOV     W4,1A8E
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
03FB2:  MOV     #FF1F,W4
03FB4:  MOV     W4,1A98
03FB6:  SETM    1A9A
03FB8:  SETM    1A9C
03FBA:  MOV     #BFDF,W4
03FBC:  MOV     W4,1A9E
03FBE:  MOV     #1C35,W4
03FC0:  MOV     W4,1AA0
03FC2:  MOV     #5555,W4
03FC4:  MOV     W4,1AA2
03FC6:  MOV     #5555,W4
03FC8:  MOV     W4,1AA4
03FCA:  MOV     #3FA5,W4
03FCC:  MOV     W4,1AA6
03FCE:  MOV     #3F1C,W4
03FD0:  MOV     W4,1AA8
03FD2:  MOV     #16A7,W4
03FD4:  MOV     W4,1AAA
03FD6:  MOV     #C16C,W4
03FD8:  MOV     W4,1AAC
03FDA:  MOV     #BF56,W4
03FDC:  MOV     W4,1AAE
03FDE:  MOV     #F3E6,W4
03FE0:  MOV     W4,1AB0
03FE2:  MOV     #D65,W4
03FE4:  MOV     W4,1AB2
03FE6:  MOV     #1A0,W4
03FE8:  MOV     W4,1AB4
03FEA:  MOV     #3EFA,W4
03FEC:  MOV     W4,1AB6
03FEE:  MOV     #A3E,W4
03FF0:  MOV     W4,1AB8
03FF2:  MOV     #3931,W4
03FF4:  MOV     W4,1ABA
03FF6:  MOV     #7E4C,W4
03FF8:  MOV     W4,1ABC
03FFA:  MOV     #BE92,W4
03FFC:  MOV     W4,1ABE
03FFE:  MOV     #DDFB,W4
04000:  MOV     W4,1AC0
04002:  MOV     #2B77,W4
04004:  MOV     W4,1AC2
04006:  MOV     #EDB1,W4
04008:  MOV     W4,1AC4
0400A:  MOV     #3E21,W4
0400C:  MOV     W4,1AC6
0400E:  MOV     #6FCC,W4
04010:  MOV     W4,1AC8
04012:  MOV     #8FF7,W4
04014:  MOV     W4,1ACA
04016:  MOV     #C610,W4
04018:  MOV     W4,1ACC
0401A:  MOV     #BDA8,W4
0401C:  MOV     W4,1ACE
0401E:  MOV     #124C,W4
04020:  MOV     W4,1AD0
04022:  MOV     #8E1C,W4
04024:  MOV     W4,1AD2
04026:  MOV     #3AF9,W4
04028:  MOV     W4,1AD4
0402A:  MOV     #3CF3,W4
0402C:  MOV     W4,1AD6
0402E:  MOV     #7676,W4
04030:  MOV     W4,1AD8
04032:  MOV     #350F,W4
04034:  MOV     W4,1ADA
04036:  MOV     #C0DE,W4
04038:  MOV     W4,1ADC
0403A:  MOV     #3CF0,W4
0403C:  MOV     W4,1ADE
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0403E:  MOV     1A6E,W0
04040:  MOV     1A70,W1
04042:  MOV     1A72,W2
04044:  MOV     1A74,W3
04046:  MOV     #0,W4
04048:  MOV     #0,W5
0404A:  MOV     #0,W6
0404C:  MOV     #0,W7
0404E:  CALL    1DD8
04052:  BRA     NC,405E
04054:  MOV     #1A6E,W0
04056:  MOV     #1A6E,W1
04058:  REPEAT  #7
0405A:  MOV     [W0++],[W1++]
0405C:  BTG.B   1A75.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0405E:  MOV     1A6E,W0
04060:  MOV     1A70,W1
04062:  MOV     1A72,W2
04064:  MOV     1A74,W3
04066:  MOV     #C884,W4
04068:  MOV     #6DC9,W5
0406A:  MOV     #5F30,W6
0406C:  MOV     #3FE4,W7
0406E:  CALL    BC0
04072:  CALL    3F42
04076:  MOV.B   W0L,1A76
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
04078:  MOV     1A6E,W0
0407A:  MOV     1A70,W1
0407C:  MOV     1A72,W2
0407E:  MOV     1A74,W3
04080:  MOV     #C884,W4
04082:  MOV     #6DC9,W5
04084:  MOV     #5F30,W6
04086:  MOV     #3FE4,W7
04088:  CALL    BC0
0408C:  MOV     W0,W5
0408E:  MOV     W1,W6
04090:  MOV     W2,W7
04092:  MOV     W3,W8
04094:  MOV     #0,W1
04096:  MOV     #0,W2
04098:  MOV     #0,W3
0409A:  MOV.B   1A76,W0L
0409C:  CLR.B   1
0409E:  CALL    3E28
040A2:  BSET.B  43.0
040A4:  MOV     W5,[W15++]
040A6:  MOV     W6,[W15++]
040A8:  MOV     W7,[W15++]
040AA:  MOV     W0,W4
040AC:  MOV     W5,W0
040AE:  MOV     W1,W5
040B0:  MOV     W6,W1
040B2:  MOV     W2,W6
040B4:  MOV     W7,W2
040B6:  MOV     W3,W7
040B8:  MOV     W8,W3
040BA:  CALL    1BEA
040BE:  MOV     [--W15],W7
040C0:  MOV     [--W15],W6
040C2:  MOV     [--W15],W5
040C4:  MOV     W0,1A90
040C6:  MOV     W1,1A92
040C8:  MOV     W2,1A94
040CA:  MOV     W3,1A96
....................    quad = quad % 4;                    // quadrant (0 to 3) 
040CC:  MOV.B   1A76,W0L
040CE:  AND.B   W0L,#3,W0L
040D0:  MOV.B   W0L,1A76
....................  
....................    if (quad == 0 || quad == 2) 
040D2:  CP0.B   1A76
040D4:  BRA     Z,40DC
040D6:  MOV     1A76,W4
040D8:  CP.B    W4L,#2
040DA:  BRA     NZ,40FC
....................       t = frac * PI_DIV_BY_TWO; 
040DC:  MOV     1A90,W0
040DE:  MOV     1A92,W1
040E0:  MOV     1A94,W2
040E2:  MOV     1A96,W3
040E4:  MOV     #2D18,W4
040E6:  MOV     #5444,W5
040E8:  MOV     #21FB,W6
040EA:  MOV     #3FF9,W7
040EC:  CALL    BC0
040F0:  MOV     W0,1A80
040F2:  MOV     W1,1A82
040F4:  MOV     W2,1A84
040F6:  MOV     W3,1A86
040F8:  GOTO    4192
....................    else if (quad == 1) 
040FC:  MOV     1A76,W4
040FE:  CP.B    W4L,#1
04100:  BRA     NZ,414C
....................       t = (1-frac) * PI_DIV_BY_TWO; 
04102:  BSET.B  43.0
04104:  MOV     #0,W0
04106:  MOV     #0,W1
04108:  MOV     #0,W2
0410A:  MOV     #3FF0,W3
0410C:  MOV     1A90,W4
0410E:  MOV     1A92,W5
04110:  MOV     1A94,W6
04112:  MOV     1A96,W7
04114:  CALL    1BEA
04118:  MOV     W0,W5
0411A:  MOV     W1,W6
0411C:  MOV     W2,W7
0411E:  MOV     W3,W8
04120:  MOV     W5,[W15++]
04122:  MOV     W6,[W15++]
04124:  MOV     W7,[W15++]
04126:  MOV     W5,W0
04128:  MOV     W6,W1
0412A:  MOV     W7,W2
0412C:  MOV     W8,W3
0412E:  MOV     #2D18,W4
04130:  MOV     #5444,W5
04132:  MOV     #21FB,W6
04134:  MOV     #3FF9,W7
04136:  CALL    BC0
0413A:  MOV     [--W15],W7
0413C:  MOV     [--W15],W6
0413E:  MOV     [--W15],W5
04140:  MOV     W0,1A80
04142:  MOV     W1,1A82
04144:  MOV     W2,1A84
04146:  MOV     W3,1A86
04148:  GOTO    4192
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0414C:  BSET.B  43.0
0414E:  MOV     1A90,W0
04150:  MOV     1A92,W1
04152:  MOV     1A94,W2
04154:  MOV     1A96,W3
04156:  MOV     #0,W4
04158:  MOV     #0,W5
0415A:  MOV     #0,W6
0415C:  MOV     #3FF0,W7
0415E:  CALL    1BEA
04162:  MOV     W0,W5
04164:  MOV     W1,W6
04166:  MOV     W2,W7
04168:  MOV     W3,W8
0416A:  MOV     W5,[W15++]
0416C:  MOV     W6,[W15++]
0416E:  MOV     W7,[W15++]
04170:  MOV     W5,W0
04172:  MOV     W6,W1
04174:  MOV     W7,W2
04176:  MOV     W8,W3
04178:  MOV     #2D18,W4
0417A:  MOV     #5444,W5
0417C:  MOV     #21FB,W6
0417E:  MOV     #3FF9,W7
04180:  CALL    BC0
04184:  MOV     [--W15],W7
04186:  MOV     [--W15],W6
04188:  MOV     [--W15],W5
0418A:  MOV     W0,1A80
0418C:  MOV     W1,1A82
0418E:  MOV     W2,1A84
04190:  MOV     W3,1A86
....................  
....................    y = 1.0; 
04192:  CLR     1A78
04194:  CLR     1A7A
04196:  CLR     1A7C
04198:  MOV     #3FF0,W4
0419A:  MOV     W4,1A7E
....................    t = t * t; 
0419C:  MOV     1A80,W0
0419E:  MOV     1A82,W1
041A0:  MOV     1A84,W2
041A2:  MOV     1A86,W3
041A4:  MOV     1A80,W4
041A6:  MOV     1A82,W5
041A8:  MOV     1A84,W6
041AA:  MOV     1A86,W7
041AC:  CALL    BC0
041B0:  MOV     W0,1A80
041B2:  MOV     W1,1A82
041B4:  MOV     W2,1A84
041B6:  MOV     W3,1A86
....................    for (i = 0; i <= 8; i++) 
041B8:  CLR.B   1A77
041BA:  MOV     1A76,W4
041BC:  LSR     W4,#8,W4
041BE:  CP.B    W4L,#8
041C0:  BRA     GTU,4232
....................    { 
....................       t2 = t2 * t; 
041C2:  MOV     1A88,W0
041C4:  MOV     1A8A,W1
041C6:  MOV     1A8C,W2
041C8:  MOV     1A8E,W3
041CA:  MOV     1A80,W4
041CC:  MOV     1A82,W5
041CE:  MOV     1A84,W6
041D0:  MOV     1A86,W7
041D2:  CALL    BC0
041D6:  MOV     W0,1A88
041D8:  MOV     W1,1A8A
041DA:  MOV     W2,1A8C
041DC:  MOV     W3,1A8E
....................       y = y + p_64[i] * t2; 
041DE:  MOV.B   1A77,W0L
041E0:  CLR.B   1
041E2:  SL      W0,#3,W0
041E4:  MOV     #1A98,W4
041E6:  ADD     W0,W4,W0
041E8:  MOV     #A,W4
041EA:  REPEAT  #3
041EC:  MOV     [W0++],[W4++]
041EE:  MOV     W5,[W15++]
041F0:  MOV     W6,[W15++]
041F2:  MOV     W7,[W15++]
041F4:  MOV     W5,W0
041F6:  MOV     W6,W1
041F8:  MOV     W7,W2
041FA:  MOV     W8,W3
041FC:  MOV     1A88,W4
041FE:  MOV     1A8A,W5
04200:  MOV     1A8C,W6
04202:  MOV     1A8E,W7
04204:  CALL    BC0
04208:  MOV     [--W15],W7
0420A:  MOV     [--W15],W6
0420C:  MOV     [--W15],W5
0420E:  BCLR.B  43.0
04210:  MOV     W0,W4
04212:  MOV     W1,W5
04214:  MOV     W2,W6
04216:  MOV     W3,W7
04218:  MOV     1A78,W0
0421A:  MOV     1A7A,W1
0421C:  MOV     1A7C,W2
0421E:  MOV     1A7E,W3
04220:  CALL    1BEA
04224:  MOV     W0,1A78
04226:  MOV     W1,1A7A
04228:  MOV     W2,1A7C
0422A:  MOV     W3,1A7E
0422C:  INC.B   1A77
0422E:  GOTO    41BA
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
04232:  MOV     1A76,W4
04234:  CP.B    W4L,#2
04236:  BRA     Z,423E
04238:  MOV     1A76,W4
0423A:  CP.B    W4L,#1
0423C:  BRA     NZ,4248
....................       y = -y;  // correct sign 
0423E:  MOV     #1A78,W0
04240:  MOV     #1A78,W1
04242:  REPEAT  #7
04244:  MOV     [W0++],[W1++]
04246:  BTG.B   1A7F.7
....................  
....................    return (y); 
04248:  MOV     1A78,W0
0424A:  MOV     1A7A,W1
0424C:  MOV     1A7C,W2
0424E:  MOV     1A7E,W3
04250:  MOV     [--W15],W8
04252:  MOV     [--W15],W7
04254:  MOV     [--W15],W6
04256:  MOV     [--W15],W5
04258:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
0425A:  MOV     W5,[W15++]
0425C:  MOV     W6,[W15++]
0425E:  MOV     W7,[W15++]
04260:  MOV     W8,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
04262:  BSET.B  43.0
04264:  MOV     1A5C,W0
04266:  MOV     1A5E,W1
04268:  MOV     1A60,W2
0426A:  MOV     1A62,W3
0426C:  MOV     #2D18,W4
0426E:  MOV     #5444,W5
04270:  MOV     #21FB,W6
04272:  MOV     #3FF9,W7
04274:  CALL    1BEA
04278:  MOV     W0,W5
0427A:  MOV     W1,W6
0427C:  MOV     W2,W7
0427E:  MOV     W3,W8
04280:  MOV     W5,1A6E
04282:  MOV     W6,1A70
04284:  MOV     W7,1A72
04286:  MOV     W8,1A74
04288:  CALL    3FA0
0428C:  MOV     [--W15],W8
0428E:  MOV     [--W15],W7
04290:  MOV     [--W15],W6
04292:  MOV     [--W15],W5
04294:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
*
02ADA:  MOV     W5,[W15++]
02ADC:  MOV     W6,[W15++]
02ADE:  MOV     W7,[W15++]
02AE0:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
02AE2:  BCLR.B  1AA7.0
....................    y = x; 
02AE4:  PUSH    1A9E
02AE6:  POP     1AA8
02AE8:  PUSH    1AA0
02AEA:  POP     1AAA
02AEC:  PUSH    1AA2
02AEE:  POP     1AAC
02AF0:  PUSH    1AA4
02AF2:  POP     1AAE
....................  
....................    if (x < 0) 
02AF4:  MOV     1A9E,W0
02AF6:  MOV     1AA0,W1
02AF8:  MOV     1AA2,W2
02AFA:  MOV     1AA4,W3
02AFC:  MOV     #0,W4
02AFE:  MOV     #0,W5
02B00:  MOV     #0,W6
02B02:  MOV     #0,W7
02B04:  CALL    1DD8
02B08:  BRA     NC,2B16
....................    { 
....................       s = 1; 
02B0A:  BSET.B  1AA7.0
....................       y = -y; 
02B0C:  MOV     #1AA8,W0
02B0E:  MOV     #1AA8,W1
02B10:  REPEAT  #7
02B12:  MOV     [W0++],[W1++]
02B14:  BTG.B   1AAF.7
....................    } 
....................  
....................    if (y > 0.5) 
02B16:  MOV     #0,W0
02B18:  MOV     #0,W1
02B1A:  MOV     #0,W2
02B1C:  MOV     #3FE0,W3
02B1E:  MOV     1AA8,W4
02B20:  MOV     1AAA,W5
02B22:  MOV     1AAC,W6
02B24:  MOV     1AAE,W7
02B26:  CALL    1DD8
02B2A:  BRA     NC,2B8C
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
02B2C:  BSET.B  43.0
02B2E:  MOV     #0,W0
02B30:  MOV     #0,W1
02B32:  MOV     #0,W2
02B34:  MOV     #3FF0,W3
02B36:  MOV     1AA8,W4
02B38:  MOV     1AAA,W5
02B3A:  MOV     1AAC,W6
02B3C:  MOV     1AAE,W7
02B3E:  CALL    1BEA
02B42:  MOV     W0,W5
02B44:  MOV     W1,W6
02B46:  MOV     W2,W7
02B48:  MOV     W3,W8
02B4A:  MOV     W5,[W15++]
02B4C:  MOV     W6,[W15++]
02B4E:  MOV     W7,[W15++]
02B50:  MOV     W5,W0
02B52:  MOV     W6,W1
02B54:  MOV     W7,W2
02B56:  MOV     W8,W3
02B58:  MOV     #0,W4
02B5A:  MOV     #0,W5
02B5C:  MOV     #0,W6
02B5E:  MOV     #3FE0,W7
02B60:  CALL    BC0
02B64:  MOV     [--W15],W7
02B66:  MOV     [--W15],W6
02B68:  MOV     [--W15],W5
02B6A:  MOV     W0,W5
02B6C:  MOV     W1,W6
02B6E:  MOV     W2,W7
02B70:  MOV     W3,W8
02B72:  MOV     W5,1AD0
02B74:  MOV     W6,1AD2
02B76:  MOV     W7,1AD4
02B78:  MOV     W8,1AD6
02B7A:  CALL    2960
02B7E:  MOV     W0,1AA8
02B80:  MOV     W1,1AAA
02B82:  MOV     W2,1AAC
02B84:  MOV     W3,1AAE
....................       n += 2; 
02B86:  MOV     1AA6,W4
02B88:  ADD.B   W4L,#2,W0L
02B8A:  MOV.B   W0L,1AA6
....................    } 
....................  
....................    y2=y*y; 
02B8C:  MOV     1AA8,W0
02B8E:  MOV     1AAA,W1
02B90:  MOV     1AAC,W2
02B92:  MOV     1AAE,W3
02B94:  MOV     1AA8,W4
02B96:  MOV     1AAA,W5
02B98:  MOV     1AAC,W6
02B9A:  MOV     1AAE,W7
02B9C:  CALL    BC0
02BA0:  MOV     W0,1AC0
02BA2:  MOV     W1,1AC2
02BA4:  MOV     W2,1AC4
02BA6:  MOV     W3,1AC6
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
02BA8:  MOV     13F8,W0
02BAA:  MOV     13FA,W1
02BAC:  MOV     13FC,W2
02BAE:  MOV     13FE,W3
02BB0:  MOV     1AC0,W4
02BB2:  MOV     1AC2,W5
02BB4:  MOV     1AC4,W6
02BB6:  MOV     1AC6,W7
02BB8:  CALL    BC0
02BBC:  MOV     W0,W5
02BBE:  MOV     W1,W6
02BC0:  MOV     W2,W7
02BC2:  MOV     W3,W8
02BC4:  BCLR.B  43.0
02BC6:  MOV     W5,[W15++]
02BC8:  MOV     W6,[W15++]
02BCA:  MOV     W7,[W15++]
02BCC:  MOV     W5,W0
02BCE:  MOV     W6,W1
02BD0:  MOV     W7,W2
02BD2:  MOV     W8,W3
02BD4:  MOV     13F0,W4
02BD6:  MOV     13F2,W5
02BD8:  MOV     13F4,W6
02BDA:  MOV     13F6,W7
02BDC:  CALL    1BEA
02BE0:  MOV     [--W15],W7
02BE2:  MOV     [--W15],W6
02BE4:  MOV     [--W15],W5
02BE6:  MOV     W0,1AB0
02BE8:  MOV     W1,1AB2
02BEA:  MOV     W2,1AB4
02BEC:  MOV     W3,1AB6
....................    res = res*y2 + pas_64[2]; 
02BEE:  MOV     1AB0,W0
02BF0:  MOV     1AB2,W1
02BF2:  MOV     1AB4,W2
02BF4:  MOV     1AB6,W3
02BF6:  MOV     1AC0,W4
02BF8:  MOV     1AC2,W5
02BFA:  MOV     1AC4,W6
02BFC:  MOV     1AC6,W7
02BFE:  CALL    BC0
02C02:  MOV     W0,W5
02C04:  MOV     W1,W6
02C06:  MOV     W2,W7
02C08:  MOV     W3,W8
02C0A:  BCLR.B  43.0
02C0C:  MOV     W5,[W15++]
02C0E:  MOV     W6,[W15++]
02C10:  MOV     W7,[W15++]
02C12:  MOV     W5,W0
02C14:  MOV     W6,W1
02C16:  MOV     W7,W2
02C18:  MOV     W8,W3
02C1A:  MOV     13E8,W4
02C1C:  MOV     13EA,W5
02C1E:  MOV     13EC,W6
02C20:  MOV     13EE,W7
02C22:  CALL    1BEA
02C26:  MOV     [--W15],W7
02C28:  MOV     [--W15],W6
02C2A:  MOV     [--W15],W5
02C2C:  MOV     W0,1AB0
02C2E:  MOV     W1,1AB2
02C30:  MOV     W2,1AB4
02C32:  MOV     W3,1AB6
....................    res = res*y2 + pas_64[1]; 
02C34:  MOV     1AB0,W0
02C36:  MOV     1AB2,W1
02C38:  MOV     1AB4,W2
02C3A:  MOV     1AB6,W3
02C3C:  MOV     1AC0,W4
02C3E:  MOV     1AC2,W5
02C40:  MOV     1AC4,W6
02C42:  MOV     1AC6,W7
02C44:  CALL    BC0
02C48:  MOV     W0,W5
02C4A:  MOV     W1,W6
02C4C:  MOV     W2,W7
02C4E:  MOV     W3,W8
02C50:  BCLR.B  43.0
02C52:  MOV     W5,[W15++]
02C54:  MOV     W6,[W15++]
02C56:  MOV     W7,[W15++]
02C58:  MOV     W5,W0
02C5A:  MOV     W6,W1
02C5C:  MOV     W7,W2
02C5E:  MOV     W8,W3
02C60:  MOV     13E0,W4
02C62:  MOV     13E2,W5
02C64:  MOV     13E4,W6
02C66:  MOV     13E6,W7
02C68:  CALL    1BEA
02C6C:  MOV     [--W15],W7
02C6E:  MOV     [--W15],W6
02C70:  MOV     [--W15],W5
02C72:  MOV     W0,1AB0
02C74:  MOV     W1,1AB2
02C76:  MOV     W2,1AB4
02C78:  MOV     W3,1AB6
....................    res = res*y2 + pas_64[0]; 
02C7A:  MOV     1AB0,W0
02C7C:  MOV     1AB2,W1
02C7E:  MOV     1AB4,W2
02C80:  MOV     1AB6,W3
02C82:  MOV     1AC0,W4
02C84:  MOV     1AC2,W5
02C86:  MOV     1AC4,W6
02C88:  MOV     1AC6,W7
02C8A:  CALL    BC0
02C8E:  MOV     W0,W5
02C90:  MOV     W1,W6
02C92:  MOV     W2,W7
02C94:  MOV     W3,W8
02C96:  BCLR.B  43.0
02C98:  MOV     W5,[W15++]
02C9A:  MOV     W6,[W15++]
02C9C:  MOV     W7,[W15++]
02C9E:  MOV     W5,W0
02CA0:  MOV     W6,W1
02CA2:  MOV     W7,W2
02CA4:  MOV     W8,W3
02CA6:  MOV     13D8,W4
02CA8:  MOV     13DA,W5
02CAA:  MOV     13DC,W6
02CAC:  MOV     13DE,W7
02CAE:  CALL    1BEA
02CB2:  MOV     [--W15],W7
02CB4:  MOV     [--W15],W6
02CB6:  MOV     [--W15],W5
02CB8:  MOV     W0,1AB0
02CBA:  MOV     W1,1AB2
02CBC:  MOV     W2,1AB4
02CBE:  MOV     W3,1AB6
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
02CC0:  MOV     1420,W0
02CC2:  MOV     1422,W1
02CC4:  MOV     1424,W2
02CC6:  MOV     1426,W3
02CC8:  MOV     1AC0,W4
02CCA:  MOV     1AC2,W5
02CCC:  MOV     1AC4,W6
02CCE:  MOV     1AC6,W7
02CD0:  CALL    BC0
02CD4:  MOV     W0,W5
02CD6:  MOV     W1,W6
02CD8:  MOV     W2,W7
02CDA:  MOV     W3,W8
02CDC:  BCLR.B  43.0
02CDE:  MOV     W5,[W15++]
02CE0:  MOV     W6,[W15++]
02CE2:  MOV     W7,[W15++]
02CE4:  MOV     W5,W0
02CE6:  MOV     W6,W1
02CE8:  MOV     W7,W2
02CEA:  MOV     W8,W3
02CEC:  MOV     1418,W4
02CEE:  MOV     141A,W5
02CF0:  MOV     141C,W6
02CF2:  MOV     141E,W7
02CF4:  CALL    1BEA
02CF8:  MOV     [--W15],W7
02CFA:  MOV     [--W15],W6
02CFC:  MOV     [--W15],W5
02CFE:  MOV     W0,1AB8
02D00:  MOV     W1,1ABA
02D02:  MOV     W2,1ABC
02D04:  MOV     W3,1ABE
....................    r = r*y2 + qas_64[2]; 
02D06:  MOV     1AB8,W0
02D08:  MOV     1ABA,W1
02D0A:  MOV     1ABC,W2
02D0C:  MOV     1ABE,W3
02D0E:  MOV     1AC0,W4
02D10:  MOV     1AC2,W5
02D12:  MOV     1AC4,W6
02D14:  MOV     1AC6,W7
02D16:  CALL    BC0
02D1A:  MOV     W0,W5
02D1C:  MOV     W1,W6
02D1E:  MOV     W2,W7
02D20:  MOV     W3,W8
02D22:  BCLR.B  43.0
02D24:  MOV     W5,[W15++]
02D26:  MOV     W6,[W15++]
02D28:  MOV     W7,[W15++]
02D2A:  MOV     W5,W0
02D2C:  MOV     W6,W1
02D2E:  MOV     W7,W2
02D30:  MOV     W8,W3
02D32:  MOV     1410,W4
02D34:  MOV     1412,W5
02D36:  MOV     1414,W6
02D38:  MOV     1416,W7
02D3A:  CALL    1BEA
02D3E:  MOV     [--W15],W7
02D40:  MOV     [--W15],W6
02D42:  MOV     [--W15],W5
02D44:  MOV     W0,1AB8
02D46:  MOV     W1,1ABA
02D48:  MOV     W2,1ABC
02D4A:  MOV     W3,1ABE
....................    r = r*y2 + qas_64[1]; 
02D4C:  MOV     1AB8,W0
02D4E:  MOV     1ABA,W1
02D50:  MOV     1ABC,W2
02D52:  MOV     1ABE,W3
02D54:  MOV     1AC0,W4
02D56:  MOV     1AC2,W5
02D58:  MOV     1AC4,W6
02D5A:  MOV     1AC6,W7
02D5C:  CALL    BC0
02D60:  MOV     W0,W5
02D62:  MOV     W1,W6
02D64:  MOV     W2,W7
02D66:  MOV     W3,W8
02D68:  BCLR.B  43.0
02D6A:  MOV     W5,[W15++]
02D6C:  MOV     W6,[W15++]
02D6E:  MOV     W7,[W15++]
02D70:  MOV     W5,W0
02D72:  MOV     W6,W1
02D74:  MOV     W7,W2
02D76:  MOV     W8,W3
02D78:  MOV     1408,W4
02D7A:  MOV     140A,W5
02D7C:  MOV     140C,W6
02D7E:  MOV     140E,W7
02D80:  CALL    1BEA
02D84:  MOV     [--W15],W7
02D86:  MOV     [--W15],W6
02D88:  MOV     [--W15],W5
02D8A:  MOV     W0,1AB8
02D8C:  MOV     W1,1ABA
02D8E:  MOV     W2,1ABC
02D90:  MOV     W3,1ABE
....................    r = r*y2 + qas_64[0]; 
02D92:  MOV     1AB8,W0
02D94:  MOV     1ABA,W1
02D96:  MOV     1ABC,W2
02D98:  MOV     1ABE,W3
02D9A:  MOV     1AC0,W4
02D9C:  MOV     1AC2,W5
02D9E:  MOV     1AC4,W6
02DA0:  MOV     1AC6,W7
02DA2:  CALL    BC0
02DA6:  MOV     W0,W5
02DA8:  MOV     W1,W6
02DAA:  MOV     W2,W7
02DAC:  MOV     W3,W8
02DAE:  BCLR.B  43.0
02DB0:  MOV     W5,[W15++]
02DB2:  MOV     W6,[W15++]
02DB4:  MOV     W7,[W15++]
02DB6:  MOV     W5,W0
02DB8:  MOV     W6,W1
02DBA:  MOV     W7,W2
02DBC:  MOV     W8,W3
02DBE:  MOV     1400,W4
02DC0:  MOV     1402,W5
02DC2:  MOV     1404,W6
02DC4:  MOV     1406,W7
02DC6:  CALL    1BEA
02DCA:  MOV     [--W15],W7
02DCC:  MOV     [--W15],W6
02DCE:  MOV     [--W15],W5
02DD0:  MOV     W0,1AB8
02DD2:  MOV     W1,1ABA
02DD4:  MOV     W2,1ABC
02DD6:  MOV     W3,1ABE
....................    r = r*y2 + 1.0; 
02DD8:  MOV     1AB8,W0
02DDA:  MOV     1ABA,W1
02DDC:  MOV     1ABC,W2
02DDE:  MOV     1ABE,W3
02DE0:  MOV     1AC0,W4
02DE2:  MOV     1AC2,W5
02DE4:  MOV     1AC4,W6
02DE6:  MOV     1AC6,W7
02DE8:  CALL    BC0
02DEC:  MOV     W0,W5
02DEE:  MOV     W1,W6
02DF0:  MOV     W2,W7
02DF2:  MOV     W3,W8
02DF4:  BCLR.B  43.0
02DF6:  MOV     W5,[W15++]
02DF8:  MOV     W6,[W15++]
02DFA:  MOV     W7,[W15++]
02DFC:  MOV     W5,W0
02DFE:  MOV     W6,W1
02E00:  MOV     W7,W2
02E02:  MOV     W8,W3
02E04:  MOV     #0,W4
02E06:  MOV     #0,W5
02E08:  MOV     #0,W6
02E0A:  MOV     #3FF0,W7
02E0C:  CALL    1BEA
02E10:  MOV     [--W15],W7
02E12:  MOV     [--W15],W6
02E14:  MOV     [--W15],W5
02E16:  MOV     W0,1AB8
02E18:  MOV     W1,1ABA
02E1A:  MOV     W2,1ABC
02E1C:  MOV     W3,1ABE
....................  
....................    res = y*res/r; 
02E1E:  MOV     1AA8,W0
02E20:  MOV     1AAA,W1
02E22:  MOV     1AAC,W2
02E24:  MOV     1AAE,W3
02E26:  MOV     1AB0,W4
02E28:  MOV     1AB2,W5
02E2A:  MOV     1AB4,W6
02E2C:  MOV     1AB6,W7
02E2E:  CALL    BC0
02E32:  MOV     W0,W5
02E34:  MOV     W1,W6
02E36:  MOV     W2,W7
02E38:  MOV     W3,W8
02E3A:  MOV     W5,[W15++]
02E3C:  MOV     W6,[W15++]
02E3E:  MOV     W7,[W15++]
02E40:  MOV     W5,W0
02E42:  MOV     W6,W1
02E44:  MOV     W7,W2
02E46:  MOV     W8,W3
02E48:  MOV     1AB8,W4
02E4A:  MOV     1ABA,W5
02E4C:  MOV     1ABC,W6
02E4E:  MOV     1ABE,W7
02E50:  CALL    CD0
02E54:  MOV     [--W15],W7
02E56:  MOV     [--W15],W6
02E58:  MOV     [--W15],W5
02E5A:  MOV     W0,1AB0
02E5C:  MOV     W1,1AB2
02E5E:  MOV     W2,1AB4
02E60:  MOV     W3,1AB6
....................  
....................    if (n & 2)     // |x| > 0.5 
02E62:  MOV.B   1AA6,W0L
02E64:  CLR.B   1
02E66:  AND     W0,#2,W0
02E68:  CP0     W0
02E6A:  BRA     Z,2E9E
....................       res = PI_DIV_BY_TWO - 2.0*res; 
02E6C:  MOV     #0,W0
02E6E:  MOV     #0,W1
02E70:  MOV     #0,W2
02E72:  MOV     #4000,W3
02E74:  MOV     1AB0,W4
02E76:  MOV     1AB2,W5
02E78:  MOV     1AB4,W6
02E7A:  MOV     1AB6,W7
02E7C:  CALL    BC0
02E80:  BSET.B  43.0
02E82:  MOV     W0,W4
02E84:  MOV     W1,W5
02E86:  MOV     W2,W6
02E88:  MOV     W3,W7
02E8A:  MOV     #2D18,W0
02E8C:  MOV     #5444,W1
02E8E:  MOV     #21FB,W2
02E90:  MOV     #3FF9,W3
02E92:  CALL    1BEA
02E96:  MOV     W0,1AB0
02E98:  MOV     W1,1AB2
02E9A:  MOV     W2,1AB4
02E9C:  MOV     W3,1AB6
....................    if (s) 
02E9E:  BTSS.B  1AA7.0
02EA0:  BRA     2EAC
....................       res = -res; 
02EA2:  MOV     #1AB0,W0
02EA4:  MOV     #1AB0,W1
02EA6:  REPEAT  #7
02EA8:  MOV     [W0++],[W1++]
02EAA:  BTG.B   1AB7.7
....................    if (n & 1)           // take arccos 
02EAC:  MOV.B   1AA6,W0L
02EAE:  CLR.B   1
02EB0:  AND     W0,#1,W0
02EB2:  CP0     W0
02EB4:  BRA     Z,2ED4
....................       res = PI_DIV_BY_TWO - res; 
02EB6:  BSET.B  43.0
02EB8:  MOV     #2D18,W0
02EBA:  MOV     #5444,W1
02EBC:  MOV     #21FB,W2
02EBE:  MOV     #3FF9,W3
02EC0:  MOV     1AB0,W4
02EC2:  MOV     1AB2,W5
02EC4:  MOV     1AB4,W6
02EC6:  MOV     1AB6,W7
02EC8:  CALL    1BEA
02ECC:  MOV     W0,1AB0
02ECE:  MOV     W1,1AB2
02ED0:  MOV     W2,1AB4
02ED2:  MOV     W3,1AB6
....................  
....................    return(res); 
02ED4:  MOV     1AB0,W0
02ED6:  MOV     1AB2,W1
02ED8:  MOV     1AB4,W2
02EDA:  MOV     1AB6,W3
02EDC:  MOV     [--W15],W8
02EDE:  MOV     [--W15],W7
02EE0:  MOV     [--W15],W6
02EE2:  MOV     [--W15],W5
02EE4:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
02EE6:  CLR.B   1AA6
02EE8:  PUSH    1A84
02EEA:  POP     1A9E
02EEC:  PUSH    1A86
02EEE:  POP     1AA0
02EF0:  PUSH    1A88
02EF2:  POP     1AA2
02EF4:  PUSH    1A8A
02EF6:  POP     1AA4
02EF8:  CALL    2ADA
02EFC:  MOV     W0,1A8C
02EFE:  MOV     W1,1A8E
02F00:  MOV     W2,1A90
02F02:  MOV     W3,1A92
....................    return(r); 
02F04:  MOV     1A8C,W0
02F06:  MOV     1A8E,W1
02F08:  MOV     1A90,W2
02F0A:  MOV     1A92,W3
02F0C:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
02F0E:  MOV.B   #1,W0L
02F10:  MOV.B   W0L,1AA6
02F12:  PUSH    1A84
02F14:  POP     1A9E
02F16:  PUSH    1A86
02F18:  POP     1AA0
02F1A:  PUSH    1A88
02F1C:  POP     1AA2
02F1E:  PUSH    1A8A
02F20:  POP     1AA4
02F22:  CALL    2ADA
02F26:  MOV     W0,1A8C
02F28:  MOV     W1,1A8E
02F2A:  MOV     W2,1A90
02F2C:  MOV     W3,1A92
....................    return(r); 
02F2E:  MOV     1A8C,W0
02F30:  MOV     1A8E,W1
02F32:  MOV     1A90,W2
02F34:  MOV     1A92,W3
02F36:  RETURN  
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
0066A:  MOV     W5,[W15++]
0066C:  MOV     W6,[W15++]
0066E:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
00670:  CLR     1B60
....................    sign = 0; 
00672:  CLR     1B5C
....................    base = 10; 
00674:  MOV     #A,W4
00676:  MOV     W4,1B5E
....................    result = 0; 
00678:  CLR     1B58
0067A:  CLR     1B5A
....................  
....................    if (!s) 
0067C:  CP0     1B54
0067E:  BRA     NZ,686
....................       return 0; 
00680:  MOV     #0,W0
00682:  MOV     #0,W1
00684:  BRA     856
....................    c = s[index++]; 
00686:  MOV     1B60,W0
00688:  INC     1B60
0068A:  MOV     W0,W5
0068C:  MOV     W5,W0
0068E:  ADD     1B54,W0
00690:  MOV     1B56,W4
00692:  MOV.B   [W0+#0],W4L
00694:  MOV     W4,1B56
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00696:  MOV     1B56,W4
00698:  XOR.B   #2D,W4L
0069A:  BRA     NZ,6B4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0069C:  MOV     #1,W4
0069E:  MOV     W4,1B5C
....................       c = s[index++]; 
006A0:  MOV     1B60,W0
006A2:  INC     1B60
006A4:  MOV     W0,W5
006A6:  MOV     W5,W0
006A8:  ADD     1B54,W0
006AA:  MOV     1B56,W4
006AC:  MOV.B   [W0+#0],W4L
006AE:  MOV     W4,1B56
....................    } 
006B0:  GOTO    6CA
....................    else if (c == '+') 
006B4:  MOV     1B56,W4
006B6:  XOR.B   #2B,W4L
006B8:  BRA     NZ,6CA
....................    { 
....................       c = s[index++]; 
006BA:  MOV     1B60,W0
006BC:  INC     1B60
006BE:  MOV     W0,W5
006C0:  MOV     W5,W0
006C2:  ADD     1B54,W0
006C4:  MOV     1B56,W4
006C6:  MOV.B   [W0+#0],W4L
006C8:  MOV     W4,1B56
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
006CA:  MOV     1B56,W4
006CC:  MOV     #30,W3
006CE:  CP.B    W3L,W4L
006D0:  BRA     GT,836
006D2:  MOV     1B56,W4
006D4:  MOV     #39,W3
006D6:  CP.B    W3L,W4L
006D8:  BRA     LT,836
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
006DA:  MOV     1B56,W4
006DC:  XOR.B   #30,W4L
006DE:  BRA     NZ,70A
006E0:  MOV     1B60,W0
006E2:  ADD     1B54,W0
006E4:  MOV.B   [W0],W4L
006E6:  XOR.B   #78,W4L
006E8:  BRA     Z,6F4
006EA:  MOV     1B60,W0
006EC:  ADD     1B54,W0
006EE:  MOV.B   [W0],W4L
006F0:  XOR.B   #58,W4L
006F2:  BRA     NZ,70A
....................       { 
....................          base = 16; 
006F4:  MOV     #10,W4
006F6:  MOV     W4,1B5E
....................          index++; 
006F8:  INC     1B60
....................          c = s[index++]; 
006FA:  MOV     1B60,W0
006FC:  INC     1B60
006FE:  MOV     W0,W5
00700:  MOV     W5,W0
00702:  ADD     1B54,W0
00704:  MOV     1B56,W4
00706:  MOV.B   [W0+#0],W4L
00708:  MOV     W4,1B56
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0070A:  MOV     1B5E,W4
0070C:  CP      W4,#A
0070E:  BRA     NZ,760
....................       { 
....................          while (c >= '0' && c <= '9') 
00710:  MOV     1B56,W4
00712:  MOV     #30,W3
00714:  CP.B    W3L,W4L
00716:  BRA     GT,75C
00718:  MOV     1B56,W4
0071A:  MOV     #39,W3
0071C:  CP.B    W3L,W4L
0071E:  BRA     LT,75C
....................          { 
....................             result = 10*result + (c - '0'); 
00720:  MOV     #A,W0
00722:  MOV     #0,W1
00724:  MOV     1B58,W2
00726:  MOV     1B5A,W3
00728:  CALL    628
0072C:  MOV     W0,W5
0072E:  MOV     W1,W6
00730:  MOV     1B56,W4
00732:  SUB.B   #30,W4L
00734:  MOV.B   W4L,W0L
00736:  MOV.B   W0L,0
00738:  SE      W0,W0
0073A:  CLR     W1
0073C:  BTSC    W0.F
0073E:  SETM    W1
00740:  ADD     W0,W5,W0
00742:  MOV     W0,1B58
00744:  ADDC    W1,W6,W0
00746:  MOV     W0,1B5A
....................             c = s[index++]; 
00748:  MOV     1B60,W0
0074A:  INC     1B60
0074C:  MOV     W0,W5
0074E:  MOV     W5,W0
00750:  ADD     1B54,W0
00752:  MOV     1B56,W4
00754:  MOV.B   [W0+#0],W4L
00756:  MOV     W4,1B56
00758:  GOTO    710
....................          } 
....................       } 
0075C:  GOTO    836
....................       else if (base == 16)    // The number is a hexa number 
00760:  MOV     1B5E,W4
00762:  CP      W4,#10
00764:  BRA     NZ,836
....................       { 
....................          c = toupper(c); 
00766:  MOV     1B56,W4
00768:  MOV     #61,W3
0076A:  CP.B    W3L,W4L
0076C:  BRA     GTU,77C
0076E:  MOV     1B56,W4
00770:  MOV     #7A,W3
00772:  CP.B    W3L,W4L
00774:  BRA     NC,77C
00776:  MOV.B   1B56,W0L
00778:  AND.B   #DF,W0L
0077A:  BRA     77E
0077C:  MOV.B   1B56,W0L
0077E:  MOV.B   W0L,1B56
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
00780:  MOV     1B56,W4
00782:  MOV     #30,W3
00784:  CP.B    W3L,W4L
00786:  BRA     GT,792
00788:  MOV     1B56,W4
0078A:  MOV     #39,W3
0078C:  CP.B    W3L,W4L
0078E:  BRA     LT,792
00790:  BRA     7A2
00792:  MOV     1B56,W4
00794:  MOV     #41,W3
00796:  CP.B    W3L,W4L
00798:  BRA     GT,836
0079A:  MOV     1B56,W4
0079C:  MOV     #46,W3
0079E:  CP.B    W3L,W4L
007A0:  BRA     LT,836
....................          { 
....................             if (c >= '0' && c <= '9') 
007A2:  MOV     1B56,W4
007A4:  MOV     #30,W3
007A6:  CP.B    W3L,W4L
007A8:  BRA     GT,7E0
007AA:  MOV     1B56,W4
007AC:  MOV     #39,W3
007AE:  CP.B    W3L,W4L
007B0:  BRA     LT,7E0
....................                result = (result << 4) + (c - '0'); 
007B2:  MOV     #4,W4
007B4:  MOV     1B58,W5
007B6:  MOV     1B5A,W6
007B8:  INC     W4,W4
007BA:  DEC     W4,W4
007BC:  BRA     Z,7C4
007BE:  SL      W5,W5
007C0:  RLC     W6,W6
007C2:  BRA     7BA
007C4:  MOV     1B56,W4
007C6:  SUB.B   #30,W4L
007C8:  MOV.B   W4L,W0L
007CA:  MOV.B   W0L,0
007CC:  SE      W0,W0
007CE:  CLR     W1
007D0:  BTSC    W0.F
007D2:  SETM    W1
007D4:  ADD     W0,W5,W0
007D6:  MOV     W0,1B58
007D8:  ADDC    W1,W6,W0
007DA:  MOV     W0,1B5A
007DC:  GOTO    808
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
007E0:  MOV     #4,W4
007E2:  MOV     1B58,W5
007E4:  MOV     1B5A,W6
007E6:  INC     W4,W4
007E8:  DEC     W4,W4
007EA:  BRA     Z,7F2
007EC:  SL      W5,W5
007EE:  RLC     W6,W6
007F0:  BRA     7E8
007F2:  MOV     1B56,W4
007F4:  SUB.B   #41,W4L
007F6:  MOV.B   W4L,W0L
007F8:  MOV.B   W0L,0
007FA:  ZE      W0,W0
007FC:  ADD     W0,#A,W0
007FE:  ADD     W0,W5,W0
00800:  MOV     W0,1B58
00802:  MOV     #0,W4
00804:  ADDC    W4,W6,W0
00806:  MOV     W0,1B5A
....................  
....................             c = s[index++];c = toupper(c); 
00808:  MOV     1B60,W0
0080A:  INC     1B60
0080C:  MOV     W0,W5
0080E:  MOV     W5,W0
00810:  ADD     1B54,W0
00812:  MOV     1B56,W4
00814:  MOV.B   [W0+#0],W4L
00816:  MOV     W4,1B56
00818:  MOV     1B56,W4
0081A:  MOV     #61,W3
0081C:  CP.B    W3L,W4L
0081E:  BRA     GTU,82E
00820:  MOV     1B56,W4
00822:  MOV     #7A,W3
00824:  CP.B    W3L,W4L
00826:  BRA     NC,82E
00828:  MOV.B   1B56,W0L
0082A:  AND.B   #DF,W0L
0082C:  BRA     830
0082E:  MOV.B   1B56,W0L
00830:  MOV.B   W0L,1B56
00832:  GOTO    780
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
00836:  MOV     1B5E,W4
00838:  CP      W4,#A
0083A:  BRA     NZ,852
0083C:  MOV     1B5C,W4
0083E:  CP      W4,#1
00840:  BRA     NZ,852
....................       result = -result; 
00842:  MOV     #0,W4
00844:  MOV     1B58,W3
00846:  SUB     W4,W3,W0
00848:  MOV     W0,1B58
0084A:  MOV     #0,W4
0084C:  MOV     1B5A,W3
0084E:  SUBB    W4,W3,W0
00850:  MOV     W0,1B5A
....................  
....................    return(result); 
00852:  MOV     1B58,W0
00854:  MOV     1B5A,W1
00856:  MOV     [--W15],W7
00858:  MOV     [--W15],W6
0085A:  MOV     [--W15],W5
0085C:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "servomoteur/servomoteur.h" 
.................... #ifndef _SERVOMOTEUR_H 
.................... #define _SERVOMOTEUR_H 
....................  
.................... // Nombre de servomoteurs (0 Ã  MAXSERVO-1) 
.................... #DEFINE MAXSERVO 1 
.................... // Valeurs min et max de l'impulsion en [100us] pour la protection des servomoteurs 
.................... #DEFINE MINSERVOPOSITION 9 
.................... #DEFINE MAXSERVOPOSITION 20 
.................... // Normalement 9 et 21 pour 900us et 2.1ms 
....................  
.................... // Structure pour la gestion des servomoteurs 
.................... struct T_Servo{ 
.................... 	int Position; 
.................... 	int Count; 
.................... 	int OpenValue; 
.................... 	int CloseValue; 
.................... }; 
....................  
.................... struct T_Servo ServoTab[MAXSERVO]; 
....................  
.................... void MoveServo(int number, int position); 
.................... void SetServo(int number, int state); 
.................... void OpenServo(int number); 
.................... void CloseServo(int number); 
.................... void CheckServo(); 
.................... void __Init_Servos(); 
....................  
.................... #include "servomoteur/servomoteur.c" 
.................... ///============================================================================================ 
.................... ///	void MoveServo(int number, int position) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de modifier la valeur de consigne (l'angle) d'un servomoteur 
.................... ///	Position défini la longueur de l'impulsion en [100us] 
.................... ///============================================================================================ 
.................... void MoveServo(int number, int position) 
*
01050:  MOV     W5,[W15++]
01052:  MOV     W6,[W15++]
.................... { 
.................... 	// Protection pour ne pas bloquer le servo en butée 
.................... 	if(position < MINSERVOPOSITION) 
01054:  MOV     1A40,W4
01056:  CP      W4,#9
01058:  BRA     GE,105E
.................... 		position = MINSERVOPOSITION; 
0105A:  MOV     #9,W4
0105C:  MOV     W4,1A40
.................... 	 
.................... 	if (position > MAXSERVOPOSITION) 
0105E:  MOV     1A40,W4
01060:  CP      W4,#14
01062:  BRA     LE,1068
.................... 		position = MAXSERVOPOSITION; 
01064:  MOV     #14,W4
01066:  MOV     W4,1A40
.................... 	// Définition de position du servomoteur 
.................... 	ServoTab[number].Position = position; 
01068:  MOV     1A3E,W4
0106A:  MUL.UU  W4,#8,W0
0106C:  MOV     W0,W5
0106E:  MOV     #148E,W4
01070:  ADD     W5,W4,W6
01072:  MOV     1A40,W4
01074:  MOV     W4,[W6+#0]
.................... 	 
.................... 	enable_interrupts(INT_TIMER2); 
01076:  BSET.B  8C.6
.................... 	delay_ms(500); 
01078:  MOV     #1F4,W0
0107A:  CALL    E84
.................... 	disable_interrupts(INT_TIMER2); 
0107E:  BCLR.B  8C.6
01080:  MOV     [--W15],W6
01082:  MOV     [--W15],W5
01084:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void SetServo(int number, int state) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de définir la sortie propre à chaque servomoteur 
.................... ///	output_bit() demande l'adresse du bit utilisé (par exemple avec un "#define PIN_A3 5651") 
.................... ///============================================================================================ 
.................... void SetServo(int number, int state) 
.................... { 
.................... 	switch (number) 
*
004A4:  MOV     1B66,W0
004A6:  XOR     #0,W0
004A8:  BRA     Z,4AC
004AA:  BRA     4BC
.................... 	{ 
.................... 		case 0:		// Pour le servomoteur droit 
.................... 			output_bit(PIN_D4,state);	 
004AC:  CP0     1B68
004AE:  BRA     NZ,4B4
004B0:  BCLR.B  2D6.4
004B2:  BRA     4B6
004B4:  BSET.B  2D6.4
004B6:  BCLR.B  2D2.4
.................... 			break; 
004B8:  GOTO    4C0
.................... 		default : 
.................... 			break; 
004BC:  GOTO    4C0
.................... 	} 
004C0:  RETURN  
.................... 	 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void CheckServo() 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Gère la commande des servomoteurs 
.................... ///	Doit être appelé toutes les 100us 
.................... ///============================================================================================ 
.................... void CheckServo() 
004C2:  MOV     W5,[W15++]
004C4:  MOV     W6,[W15++]
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
004C6:  CLR     1B64
004C8:  MOV     1B64,W4
004CA:  CP      W4,#1
004CC:  BRA     GE,552
.................... 	{ 
.................... 		if(ServoTab[i].Count<ServoTab[i].Position) 
004CE:  MOV     1B64,W4
004D0:  MUL.UU  W4,#8,W0
004D2:  MOV     W0,W5
004D4:  ADD     W5,#2,W0
004D6:  MOV     #148E,W4
004D8:  ADD     W0,W4,W0
004DA:  MOV     [W0],W5
004DC:  MOV     1B64,W4
004DE:  MUL.UU  W4,#8,W6
004E0:  MOV     #148E,W4
004E2:  ADD     W6,W4,W0
004E4:  MOV     W0,W4
004E6:  MOV     [W4],W0
004E8:  CP      W5,W0
004EA:  BRA     GE,50A
.................... 		{ 
.................... 			// Ton 
.................... 			SetServo(i,1); 
004EC:  PUSH    1B64
004EE:  POP     1B66
004F0:  MOV     #1,W4
004F2:  MOV     W4,1B68
004F4:  CALL    4A4
.................... 			ServoTab[i].Count++; 
004F8:  MOV     1B64,W4
004FA:  MUL.UU  W4,#8,W0
004FC:  MOV     W0,W5
004FE:  ADD     W5,#2,W0
00500:  MOV     #148E,W4
00502:  ADD     W0,W4,W5
00504:  INC     [W5],[W5]
.................... 		}  
00506:  GOTO    54C
.................... 		else  
.................... 		{ 
.................... 			if(ServoTab[i].Count<197)  
0050A:  MOV     1B64,W4
0050C:  MUL.UU  W4,#8,W0
0050E:  MOV     W0,W5
00510:  ADD     W5,#2,W0
00512:  MOV     #148E,W4
00514:  ADD     W0,W4,W0
00516:  MOV     [W0],W5
00518:  MOV     #C5,W4
0051A:  CP      W4,W5
0051C:  BRA     LE,53A
.................... 			{ 
.................... 				// Toff 
.................... 				SetServo(i,0); 
0051E:  PUSH    1B64
00520:  POP     1B66
00522:  CLR     1B68
00524:  CALL    4A4
.................... 				ServoTab[i].Count++; 
00528:  MOV     1B64,W4
0052A:  MUL.UU  W4,#8,W0
0052C:  MOV     W0,W5
0052E:  ADD     W5,#2,W0
00530:  MOV     #148E,W4
00532:  ADD     W0,W4,W5
00534:  INC     [W5],[W5]
.................... 			}  
00536:  GOTO    54C
.................... 			else  
.................... 			{ 
.................... 				// Fin de la période 
.................... 				ServoTab[i].Count = 0; 
0053A:  MOV     1B64,W4
0053C:  MUL.UU  W4,#8,W0
0053E:  MOV     W0,W5
00540:  ADD     W5,#2,W0
00542:  MOV     #148E,W4
00544:  ADD     W0,W4,W5
00546:  CLR.B   [W5]
00548:  MOV.B   #0,W0L
0054A:  MOV.B   W0L,[W5+#1]
.................... 			} 
.................... 		} 
0054C:  INC     1B64
0054E:  GOTO    4C8
.................... 	} 
00552:  MOV     [--W15],W6
00554:  MOV     [--W15],W5
00556:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void OpenServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position ouverte définie avec ServoTab[x].OpenValue 
.................... ///============================================================================================ 
.................... void OpenServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].OpenValue); 
.................... } 
.................... ///============================================================================================ 
.................... /// void CloseServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position fermée définie avec ServoTab[x].CloseValue 
.................... ///============================================================================================ 
.................... void CloseServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].CloseValue); 
.................... } 
....................  
.................... ///	Initialisation de la structure des servomoteurs: 
.................... void __Init_Servos(void) 
*
0100A:  MOV     W5,[W15++]
0100C:  MOV     W6,[W15++]
0100E:  CLR.B   1A3E
.................... { 
.................... 	unsigned int8 i=0; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
01010:  CLR.B   1A3E
01012:  CP0.B   1A3E
01014:  BRA     NZ,103E
.................... 	{ 
.................... 		ServoTab[i].Position = 0; 
01016:  MOV.B   1A3E,W0L
01018:  CLR.B   1
0101A:  SL      W0,#3,W5
0101C:  MOV     #148E,W4
0101E:  ADD     W5,W4,W6
01020:  CLR.B   [W6]
01022:  MOV.B   #0,W0L
01024:  MOV.B   W0L,[W6+#1]
.................... 		ServoTab[i].Count = 0; 
01026:  MOV.B   1A3E,W0L
01028:  CLR.B   1
0102A:  SL      W0,#3,W5
0102C:  ADD     W5,#2,W0
0102E:  MOV     #148E,W4
01030:  ADD     W0,W4,W5
01032:  CLR.B   [W5]
01034:  MOV.B   #0,W0L
01036:  MOV.B   W0L,[W5+#1]
01038:  INC.B   1A3E
0103A:  GOTO    1012
.................... 	} 
....................  
.................... 	///	Configuration du TIMER2 pour 100us: 
.................... ///-------------------------------------------------------------------- 
.................... 	setup_timer2(TMR_INTERNAL, 1973); 
0103E:  CLR     110
01040:  MOV     #7B5,W4
01042:  MOV     W4,10C
01044:  MOV     #8000,W4
01046:  MOV     W4,110
.................... 	// 1/((80MHz)/4)*1*2000 = 100us 
.................... 	enable_interrupts(INT_TIMER2); 
01048:  BSET.B  8C.6
0104A:  MOV     [--W15],W6
0104C:  MOV     [--W15],W5
0104E:  RETURN  
.................... } 
....................  
.................... ///	Interruption TIMER2 
.................... ///-------------------------------------------------------------------- 
.................... 	#INT_TIMER2 HIGH 
.................... 	void timer2_isr() 
*
00558:  PUSH    42
0055A:  PUSH    36
0055C:  PUSH    32
0055E:  MOV     W0,[W15++]
00560:  MOV     #2,W0
00562:  REPEAT  #C
00564:  MOV     [W0++],[W15++]
.................... 	{ 
.................... 		set_timer2(0); 
00566:  CLR     106
.................... 		CheckServo(); 
00568:  CALL    4C2
.................... 	} 
....................  
....................  
.................... #endif 
....................  
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS - PRINCIPE 
.................... ///==================================================================== 
.................... /// 
.................... ///	Le but est de gÃ©nÃ©rer des sorties pour la commandes de servomoteurs. 
.................... ///	Les sorties sont mises Ã  jour chaque 100us grÃ¢ce au TIMER2. 
.................... ///	Les impulsions de commande sont envoyÃ©es en continu. 
.................... /// 
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS  - UTILISATION 
.................... ///==================================================================== 
.................... /// 
.................... ///	MAXSERVO permet de dÃ©finir le nombre de servomoteurs utilisÃ©s 
.................... ///	MINSERVOPOSITION et MAXSERVOPOSITION fixent les valeurs min et max 
.................... ///	des impulsions Ã  gÃ©nÃ©rer pour la commande des servomoteurs, en 
.................... ///	gÃ©nÃ©ral on se limite Ã  900us (9) et 2.1ms (21) 
.................... /// 
.................... ///	CheckServo(): gÃ¨re la commande des servomoteurs, Ã  appeler toutes 
.................... ///	toutes les 100us 
.................... /// 
.................... ///	MoveServo(number, position): permet de modifier la valeur de consigne 
.................... ///	d'un servomoteur 
.................... /// 
.................... ///	SetServo(numer, state): utilisÃ© par CheckServo(), le switch case 
.................... ///	permet de dÃ©finir les sorties propres Ã  chaque servomoteurs. 
....................  
.................... #include "LCD/___LCD.h" 
.................... /* 
.................... * \file ___LCD.h 
.................... * \brief Gère l'afficheur LCD I2C (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_H 
0056C:  BCLR.B  84.6
0056E:  MOV     #1A,W0
00570:  REPEAT  #C
00572:  MOV     [--W15],[W0--]
00574:  MOV     [--W15],W0
00576:  POP     32
00578:  POP     36
0057A:  POP     42
0057C:  RETFIE  
.................... #define ___LCD_H 
....................  
.................... void __Init_LCD(void); // Init LCD 
.................... void __ClearLCD(void);	// Efface l'écran 
.................... void __WriteLCD(unsigned int8 _Command);	// Ecrit la commande  
.................... void __WriteCount(float64 _Value, int1 _Mode);	// Ecrit une valeur, int32 si mode = 0, float si mode = 1 
.................... void __SautLig(unsigned int8 _Lig);	// Saute d'une ligne sur l'écran 
....................  
.................... #include "LCD/___LCD.c" 
.................... /* 
.................... * \file ___LCD.c 
.................... * \brief Gère l'afficheur LCD I2C (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_C 
.................... #define ___LCD_C 
....................  
.................... void __Init_LCD(void) 
.................... { 
.................... 	// Config LCD IIC 
.................... 	i2c_start(); 
.................... 	i2c_write(0x50);	// Adresse du LCD 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x52);	// Contraste 
.................... 	i2c_write(0x24);	// 36 sur 50 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x53);	// Brightness backlight 
.................... 	i2c_write(6);		// 6 sur 8 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x51);	// Efface l'écran 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __ClearLCD 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __ClearLCD(void) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Clear le LCD 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x51); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteLCD 
.................... // Ecrit ou envoi une commande au LCD. 
.................... // Prend quoi écrire. 
.................... // Ne retourne rien. 
.................... void __WriteLCD(unsigned int8 _Command) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
.................... unsigned int8 ack=i2c_write(0x50); 
.................... 	// Se connecte au LCD 
.................... 	if(ack==0) 
.................... 	// Ecrit ou envoi la comande au LCD 
.................... 	i2c_write(_Command); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteCount 
.................... // Permet d'écrire la valeur de la roue folle. 
.................... // Prend la valeur à écrire et le mode (0 = écrit. int, 1 = écrit. float tronqué) 
.................... // Ne retourne rien. 
.................... void __WriteCount(float64 _Value, int1 _Mode) 
.................... { 
.................... 	// Index d'affichage 
.................... 	unsigned int8 IAff=0, TabValue[16]; 
.................... 	 
.................... 	// Selon mode d'affichage choisi 
.................... 	// Transforme le nombre en chaîne de caractère 
.................... 	if(_Mode == 0) 
.................... 	sprintf(TabValue,"%7Ld ",(int32)_Value); 
.................... 	else	 
.................... 	sprintf(TabValue,"%6.3f ",(float64)_Value); 
.................... 		 
.................... 	// Affiche les caractères à la suite 
.................... 	while(TabValue[IAff]!=0x00) 
.................... 	{ 
.................... 		__WriteLCD(TabValue[IAff]); 
.................... 		Iaff++; 
.................... 	}	 
....................  
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... }	 
....................  
.................... // __SautLig 
.................... // Saute à la seconde ligne 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __SautLig(unsigned int8 _Lig) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Saute à la seconde ligne 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x45); 
.................... 	i2c_write(_Lig); 
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: TestCartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contrôle du robor secondaire.																	== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_h 
.................... #define ___Functions_h 
....................  
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0); 
.................... int1 Eject(void); 
....................  
.................... unsigned int16 soll_vit_rot  = 1450; 
.................... unsigned int16 soll_vit_rot_zero = 2000;  
.................... unsigned int16 soll_vit_mov = 1200; 
....................  
.................... signed int32 Endposition = 0; //position qui doit etre atteinte a la fin du depl 
.................... unsigned int8 Etat_ejection = 0; 
.................... int1 bras_out = 0; 
.................... int1 bras_in  = 0; 
.................... int1 flag_module_fond = 0; 
.................... void __ReadObjectifs(void); 
.................... int1 Ejecte(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
.................... void __resetEEPROM(void); 
.................... void __reset_roboteq(void); 
.................... void __GetRoboteqPID(unsigned int8 valeur); 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2); 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr); 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend); 
.................... void Ramassage(void); 
.................... void __Gestion_surcharge(unsigned int8 Adresse_driver); 
.................... void EjectionModule(unsigned int8 nbre_repet_ToDo); 
.................... void __Action_Writting(unsigned int8 ActionToDo); 
.................... void __ReadZones_Interdites(void); 
.................... int1 __Poussage(void); 
.................... int1 __Rentrage(void); 
.................... int1 __GoToZero(void); 
.................... void Deposage(void); 
.................... void Pos_barillet_module_du_fond(void); 
.................... void Ramassage_1module(void); 
.................... #include "Functions.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel 
.................... 						: Borgeat Rémy     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Function.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient des fonctions pour le robot																== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_c 
.................... #define ___Functions_c 
....................  
.................... //********************************************************************************************************************* 
.................... // arrondi_float 
.................... // 
.................... // Cette fonction permet d'arrondir un nombre decimal en entier relatif 
.................... // 12.7863 => 13 
.................... // 14.45621 => 14  
.................... // 
.................... // Developpe par : Louis Mayencourt 
.................... // Date :          01.12.2010  
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : nombre a convertir  
.................... // return      : nombre converti 
.................... // 
.................... //********************************************************************************************************************* 
.................... signed int32 arrondi_float_signed(float nombre) 
.................... { 
.................... 	float chiffres_apres_virgule;		// contient les chiffres apres la virgule du float a convertir  
....................  
.................... // prend les chiffres apres la virgule 
.................... 	chiffres_apres_virgule = nombre-floor(nombre); 
*
023AE:  PUSH    1A80
023B0:  POP     1A88
023B2:  PUSH    1A82
023B4:  POP     1A8A
023B6:  CALL    2348
023BA:  BSET.B  43.0
023BC:  MOV     W0,W2
023BE:  MOV     W1,W3
023C0:  MOV     1A80,W0
023C2:  MOV     1A82,W1
023C4:  CALL    2032
023C8:  MOV     W0,1A84
023CA:  MOV     W1,1A86
....................  
.................... // test si il faut arrondir vers le bas ou le haut 
.................... 	if(chiffres_apres_virgule>=0.5) return( (signed int32)(ceil(nombre))); 
023CC:  MOV     #0,W0
023CE:  MOV     #3F00,W1
023D0:  MOV     1A84,W2
023D2:  MOV     1A86,W3
023D4:  CALL    1EA0
023D8:  BRA     C,23DC
023DA:  BRA     NZ,23F4
023DC:  PUSH    1A80
023DE:  POP     1A88
023E0:  PUSH    1A82
023E2:  POP     1A8A
023E4:  CALL    235A
023E8:  CALL    236E
023EC:  MOV.D   W0,W0
023EE:  BRA     2408
023F0:  GOTO    2408
.................... 	else return( (signed int32)(floor(nombre))); 
023F4:  PUSH    1A80
023F6:  POP     1A88
023F8:  PUSH    1A82
023FA:  POP     1A8A
023FC:  CALL    2348
02400:  CALL    236E
02404:  MOV.D   W0,W0
02406:  BRA     2408
02408:  RETURN  
.................... } 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Afficheur 7 segments 
.................... //	Auteur :	BORR 
.................... //	Date:	    6.1.16 
.................... //  Statut :    Fonctionnel 
.................... //  Futur :     n.a. 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Gère 2 afficheur 7 segments 
.................... //	Paramètre(s): int8 nombre -> nombre<=99 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0) 
.................... { 
.................... 	_EN_Uni = _En_Diz = 1; 
*
0139E:  BSET.B  2C9.2
013A0:  BSET.B  2C9.3
.................... 	 
.................... 	if(ToBlank) 
013A2:  CP0.B   1A4B
013A4:  BRA     Z,13B6
.................... 	{ 
.................... 		PORTB |= 0b1111<<12; 
013A6:  MOV     #F000,W0
013A8:  IOR     2C8
.................... 		// charge sur les latchs 
.................... 		_EN_Uni = _En_Diz = 0; 
013AA:  BCLR.B  2C9.2
013AC:  BCLR.B  2C9.3
.................... 		_EN_Uni = _En_Diz = 1; 
013AE:  BSET.B  2C9.2
013B0:  BSET.B  2C9.3
.................... 	} 
013B2:  GOTO    13F0
.................... 	else 
.................... 	{		 
.................... 		static unsigned int16 dizaine = 0; // variable qui va récupérer le chiffre des dizaine  
.................... 		static unsigned int16 unite = 0; // variable qui va récupérer le chiffre des unité 
.................... 	 
.................... 		dizaine = nombre/10; //récupération du nombre des dizaine 
013B6:  MOV.B   1A4A,W0L
013B8:  SE      W0,W0
013BA:  MOV     W0,W4
013BC:  MOV     #A,W3
013BE:  REPEAT  #11
013C0:  DIV.S   W4,W3
013C2:  MOV     W0,14A4
.................... 		unite   = nombre%10; //récupération du nombre des unités 
013C4:  MOV.B   1A4A,W0L
013C6:  SE      W0,W0
013C8:  MOV     W0,W4
013CA:  MOV     #A,W3
013CC:  REPEAT  #11
013CE:  DIV.S   W4,W3
013D0:  MOV     W1,W0
013D2:  MOV     W0,14A6
.................... 	 
.................... 		dizaine = dizaine * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
013D4:  MOV     14A4,W0
013D6:  SL      W0,#C,W0
013D8:  MOV     W0,14A4
.................... 		unite = unite * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
013DA:  MOV     14A6,W0
013DC:  SL      W0,#C,W0
013DE:  MOV     W0,14A6
.................... 		 
.................... 		_En_Diz = 0; // possibilité d'afficher sur l'afficheur des dizaine	 
013E0:  BCLR.B  2C9.2
.................... 		PORTB = dizaine; //affichage de la valeur sur l'afficheur 
013E2:  PUSH    14A4
013E4:  POP     2C8
.................... 		_En_Diz = 1; // Afficheur dizaine allumé, mais on ne peux plus changer la valeur 
013E6:  BSET.B  2C9.2
.................... 	 
.................... 		_EN_Uni = 0; // possibilité d'afficher sur afficheur unité  
013E8:  BCLR.B  2C9.3
.................... 		PORTB = unite; // affichage des unité sur l'afficheur des unité  
013EA:  PUSH    14A6
013EC:  POP     2C8
.................... 		_EN_Uni = 1; // Afficheur unité allumé, mais on ne peux plus changer la valeur 
013EE:  BSET.B  2C9.3
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
013F0:  RETURN  
.................... } 
.................... void __Affichage_Erreur(int8 nombre) 
.................... { 
.................... 	No_erreur = nombre;  
*
01002:  MOV.B   1A4A,W0L
01004:  MOV.B   W0L,870
.................... 	flag_error = 1;  
01006:  BSET.B  85B.2
.................... 		// Quitte la fonction 
.................... 	return; 
01008:  RETURN  
.................... } 
....................  
.................... /* 
.................... 	Fct qui reset une partie de l'eeprom en 
.................... 	remettant les valeurs à 0xffff 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 9.2.2017 
.................... */ 
.................... void __resetEEPROM(void) 
*
05540:  MOV     W5,[W15++]
05542:  CLR     1A4A
.................... { 
.................... 	unsigned int16 adresse = 0; 
.................... 	for(adresse = 0; adresse <= 820; adresse +=  2) 
05544:  CLR     1A4A
05546:  MOV     1A4A,W4
05548:  MOV     #334,W3
0554A:  CP      W3,W4
0554C:  BRA     NC,5564
.................... 	{ 
.................... 		write_eeprom(adresse, 0xFFFF);//on écrase l'eeprom 
0554E:  MOV     #FFFF,W5
05550:  MOV     1A4A,W0
05552:  MOV     #A,W1
05554:  MOV     #2,W2
05556:  CALL    511A
0555A:  MOV     1A4A,W4
0555C:  ADD     W4,#2,W0
0555E:  MOV     W0,1A4A
05560:  GOTO    5546
.................... 	} 
05564:  MOV     [--W15],W5
05566:  RETURN  
.................... } 
.................... void __reset_roboteq(void) 
.................... { 
.................... 	fputc('%',ROBOTEQ); 
*
0551C:  MOV.B   #25,W0L
0551E:  BTSC.B  219.1
05520:  BRA     551E
05522:  MOV.B   W0L,21A
05524:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"RESET 321654987 \r"); 
05526:  MOV     #0,W1
05528:  MOV     W1,W0
0552A:  CLR.B   1
0552C:  CALL    100
05530:  INC     W1,W1
05532:  BTSC.B  219.1
05534:  BRA     5532
05536:  MOV     W0,21A
05538:  MOV     #10,W0
0553A:  CPSGT   W1,W0
0553C:  BRA     5528
0553E:  RETURN  
.................... } 
.................... /*======================================================================================= 
.................... 	Fct qui va recuperer les pid du roboteq et les mettre dans un tableau 
.................... =========================================================================================	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date : 16.2.2017 
.................... =========================================================================================	 
.................... 	! on doit faire passer 6x dans la fct. 
.................... 	On doit mettre une boucle exeterieur, car avec dans la fct, 
.................... 	on resete la dedans, et donc on ne peut pas recuperer des caractere 
.................... 	 
.................... 	Trame envoyer : Tab{2,0,:,10,...\r) 
.................... 					Tab{kp1 : ki1 : ...) 
.................... 	Les : separe les donnes, le \r annonce la fin du tableau 
.................... 	 
.................... 	!on peut pas chainer les commande, car il ecrase a chaque fois la reponse de l'ordre precdent 
.................... ==========================================================================================*/ 
.................... void __GetRoboteqPID(unsigned int8 valeur) 
*
05154:  MOV     W5,[W15++]
05156:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 i = 3; // car on recoit KP=110 -> on veut que la valeur --> on saute les 3 premiers caractere 
.................... 	static int8 y = 0; 
.................... 	 
.................... 	switch(valeur) // on demande au roboteq es valeur 
05158:  MOV.B   1A4A,W0L
0515A:  CLR.B   1
0515C:  XOR     #0,W0
0515E:  BRA     Z,5186
05160:  XOR     #1,W0
05162:  BRA     Z,51A8
05164:  XOR     #3,W0
05166:  BRA     Z,51CA
05168:  XOR     #1,W0
0516A:  BRA     Z,51EC
0516C:  XOR     #7,W0
0516E:  BRA     Z,520E
05170:  XOR     #1,W0
05172:  BRA     Z,5230
05174:  XOR     #3,W0
05176:  BRA     Z,5252
05178:  XOR     #1,W0
0517A:  BRA     Z,5278
0517C:  XOR     #F,W0
0517E:  BRA     Z,529E
05180:  XOR     #1,W0
05182:  BRA     Z,52C4
05184:  BRA     52EA
.................... 	{ 
.................... 		case 0: 
.................... 			fprintf(ROBOTEQ,"~KP 1 \r");			 
05186:  MOV     #0,W1
05188:  MOV     W1,W0
0518A:  CLR.B   1
0518C:  CALL    11E
05190:  INC     W1,W1
05192:  BTSC.B  219.1
05194:  BRA     5192
05196:  MOV     W0,21A
05198:  MOV     #6,W0
0519A:  CPSGT   W1,W0
0519C:  BRA     5188
.................... 			delay_ms(10);			 
0519E:  MOV     #A,W0
051A0:  CALL    E84
.................... 			break; 
051A4:  GOTO    52EA
.................... 		case 1: 
.................... 			fprintf(ROBOTEQ,"~KI 1 \r"); 
051A8:  MOV     #0,W1
051AA:  MOV     W1,W0
051AC:  CLR.B   1
051AE:  CALL    132
051B2:  INC     W1,W1
051B4:  BTSC.B  219.1
051B6:  BRA     51B4
051B8:  MOV     W0,21A
051BA:  MOV     #6,W0
051BC:  CPSGT   W1,W0
051BE:  BRA     51AA
.................... 			delay_ms(10); 
051C0:  MOV     #A,W0
051C2:  CALL    E84
.................... 			break; 
051C6:  GOTO    52EA
.................... 		case 2: 
.................... 			fprintf(ROBOTEQ,"~KD 1 \r"); 
051CA:  MOV     #0,W1
051CC:  MOV     W1,W0
051CE:  CLR.B   1
051D0:  CALL    146
051D4:  INC     W1,W1
051D6:  BTSC.B  219.1
051D8:  BRA     51D6
051DA:  MOV     W0,21A
051DC:  MOV     #6,W0
051DE:  CPSGT   W1,W0
051E0:  BRA     51CC
.................... 			delay_ms(10); 
051E2:  MOV     #A,W0
051E4:  CALL    E84
.................... 			break; 
051E8:  GOTO    52EA
.................... 		case 3: 
.................... 			fprintf(ROBOTEQ,"~KP 2 \r"); 
051EC:  MOV     #0,W1
051EE:  MOV     W1,W0
051F0:  CLR.B   1
051F2:  CALL    15A
051F6:  INC     W1,W1
051F8:  BTSC.B  219.1
051FA:  BRA     51F8
051FC:  MOV     W0,21A
051FE:  MOV     #6,W0
05200:  CPSGT   W1,W0
05202:  BRA     51EE
.................... 			delay_ms(10); 
05204:  MOV     #A,W0
05206:  CALL    E84
.................... 			break; 
0520A:  GOTO    52EA
.................... 		case 4: 
.................... 			fprintf(ROBOTEQ,"~KI 2 \r"); 
0520E:  MOV     #0,W1
05210:  MOV     W1,W0
05212:  CLR.B   1
05214:  CALL    16E
05218:  INC     W1,W1
0521A:  BTSC.B  219.1
0521C:  BRA     521A
0521E:  MOV     W0,21A
05220:  MOV     #6,W0
05222:  CPSGT   W1,W0
05224:  BRA     5210
.................... 			delay_ms(10); 
05226:  MOV     #A,W0
05228:  CALL    E84
.................... 			break; 
0522C:  GOTO    52EA
.................... 		case 5: 
.................... 			fprintf(ROBOTEQ,"~KD 2 \r"); 
05230:  MOV     #0,W1
05232:  MOV     W1,W0
05234:  CLR.B   1
05236:  CALL    182
0523A:  INC     W1,W1
0523C:  BTSC.B  219.1
0523E:  BRA     523C
05240:  MOV     W0,21A
05242:  MOV     #6,W0
05244:  CPSGT   W1,W0
05246:  BRA     5232
.................... 			delay_ms(10); 
05248:  MOV     #A,W0
0524A:  CALL    E84
.................... 			break;	 
0524E:  GOTO    52EA
.................... 		case 6: 
.................... 			fprintf(ROBOTEQ,"~MAC 1 \r"); 
05252:  MOV     #0,W1
05254:  MOV     W1,W0
05256:  CLR.B   1
05258:  CALL    196
0525C:  INC     W1,W1
0525E:  BTSC.B  219.1
05260:  BRA     525E
05262:  MOV     W0,21A
05264:  MOV     #7,W0
05266:  CPSGT   W1,W0
05268:  BRA     5254
.................... 			delay_ms(10); 
0526A:  MOV     #A,W0
0526C:  CALL    E84
.................... 			i = 4; 
05270:  MOV.B   #4,W0L
05272:  MOV.B   W0L,14A3
.................... 			break;	 
05274:  GOTO    52EA
.................... 		case 7: 
.................... 			fprintf(ROBOTEQ,"~MDEC 1 \r"); 
05278:  MOV     #0,W1
0527A:  MOV     W1,W0
0527C:  CLR.B   1
0527E:  CALL    1AC
05282:  INC     W1,W1
05284:  BTSC.B  219.1
05286:  BRA     5284
05288:  MOV     W0,21A
0528A:  MOV     #8,W0
0528C:  CPSGT   W1,W0
0528E:  BRA     527A
.................... 			delay_ms(10); 
05290:  MOV     #A,W0
05292:  CALL    E84
.................... 			i = 5; 
05296:  MOV.B   #5,W0L
05298:  MOV.B   W0L,14A3
.................... 			break;	 
0529A:  GOTO    52EA
.................... 		case 8: 
.................... 			fprintf(ROBOTEQ,"~MAC 2 \r"); 
0529E:  MOV     #0,W1
052A0:  MOV     W1,W0
052A2:  CLR.B   1
052A4:  CALL    1C2
052A8:  INC     W1,W1
052AA:  BTSC.B  219.1
052AC:  BRA     52AA
052AE:  MOV     W0,21A
052B0:  MOV     #7,W0
052B2:  CPSGT   W1,W0
052B4:  BRA     52A0
.................... 			delay_ms(10); 
052B6:  MOV     #A,W0
052B8:  CALL    E84
.................... 			i = 4; 
052BC:  MOV.B   #4,W0L
052BE:  MOV.B   W0L,14A3
.................... 			break;	 
052C0:  GOTO    52EA
.................... 		case 9: 
.................... 			fprintf(ROBOTEQ,"~MDEC 2 \r"); 
052C4:  MOV     #0,W1
052C6:  MOV     W1,W0
052C8:  CLR.B   1
052CA:  CALL    1D8
052CE:  INC     W1,W1
052D0:  BTSC.B  219.1
052D2:  BRA     52D0
052D4:  MOV     W0,21A
052D6:  MOV     #8,W0
052D8:  CPSGT   W1,W0
052DA:  BRA     52C6
.................... 			delay_ms(10); 
052DC:  MOV     #A,W0
052DE:  CALL    E84
.................... 			i = 5; 
052E2:  MOV.B   #5,W0L
052E4:  MOV.B   W0L,14A3
.................... 			break;	 
052E6:  GOTO    52EA
.................... 	}	 
....................  
.................... 	if(RoboteQ_receiveBuffer[0] == 'K' || RoboteQ_receiveBuffer[0] == 'M') 
052EA:  MOV     880,W4
052EC:  XOR.B   #4B,W4L
052EE:  BRA     Z,52F6
052F0:  MOV     880,W4
052F2:  XOR.B   #4D,W4L
052F4:  BRA     NZ,534A
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i] != 0x0D) // On commence du [2] pour sauter le 'C='. Le +3 est pour le C,= et : (C=xxx:xxx). 
052F6:  MOV.B   14A3,W0L
052F8:  SE      W0,W0
052FA:  MOV     #880,W4
052FC:  ADD     W0,W4,W0
052FE:  MOV.B   [W0],W5L
05300:  SE      W5,W5
05302:  CP      W5,#D
05304:  BRA     Z,5320
.................... 		{  
.................... 			TabSentRS232[y] = RoboteQ_receiveBuffer[i];				 
05306:  MOV.B   14A8,W0L
05308:  SE      W0,W0
0530A:  MOV     #980,W4
0530C:  ADD     W0,W4,W5
0530E:  MOV.B   14A3,W0L
05310:  SE      W0,W0
05312:  MOV     #880,W4
05314:  ADD     W0,W4,W0
05316:  MOV.B   [W0],[W5]
.................... 			i++; 
05318:  INC.B   14A3
.................... 			y++; 
0531A:  INC.B   14A8
0531C:  GOTO    52F6
.................... 		} 
.................... 		if(valeur<9) 
05320:  MOV     1A4A,W4
05322:  CP.B    W4L,#9
05324:  BRA     C,5338
.................... 		{	 
.................... 			TabSentRS232[y] = ':';//seperation des valeur	 
05326:  MOV.B   14A8,W0L
05328:  SE      W0,W0
0532A:  MOV     #980,W4
0532C:  ADD     W0,W4,W5
0532E:  MOV.B   #3A,W0L
05330:  MOV.B   W0L,[W5]
.................... 			y++; 
05332:  INC.B   14A8
.................... 		} 
05334:  GOTO    5346
.................... 		else 
.................... 		{ 
.................... 			TabSentRS232[y] = '\r'; // fin de transmssion 
05338:  MOV.B   14A8,W0L
0533A:  SE      W0,W0
0533C:  MOV     #980,W4
0533E:  ADD     W0,W4,W5
05340:  MOV.B   #D,W0L
05342:  MOV.B   W0L,[W5]
.................... 			y = 0 ;	 
05344:  CLR.B   14A8
.................... 		} 
.................... 		i = 3; 
05346:  MOV.B   #3,W0L
05348:  MOV.B   W0L,14A3
.................... 	}	 
0534A:  MOV     [--W15],W6
0534C:  MOV     [--W15],W5
0534E:  RETURN  
....................  
.................... } 
.................... /* 
.................... 	Fct qui va changer les paramètre PID du roboteq. 
.................... 	Les parametre ont ete recu du pc et ont les save en 
.................... 	dans l'eeprom du roboteq 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 16.2.2017 
.................... */ 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2) 
05350:  MOV     W5,[W15++]
.................... { 
.................... 	//envoi des paramètres PID au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"^KP 1 %u_^KI 1 %u_^KD 1 %u_^KP 2 %u_^KI 2 %u_^KD 2 %u \r",P1,I1,D1,P2,I2,D2); 
05352:  MOV     #0,W1
05354:  MOV     W1,W0
05356:  CLR.B   1
05358:  CALL    1EE
0535C:  INC     W1,W1
0535E:  BTSC.B  219.1
05360:  BRA     535E
05362:  MOV     W0,21A
05364:  MOV     #5,W0
05366:  CPSGT   W1,W0
05368:  BRA     5354
0536A:  MOV.B   1A60,W0L
0536C:  CLR.B   1
0536E:  MOV     #0,W4
05370:  CALL    240A
05374:  MOV     #8,W1
05376:  MOV     W1,W0
05378:  CLR.B   1
0537A:  CALL    1EE
0537E:  INC     W1,W1
05380:  BTSC.B  219.1
05382:  BRA     5380
05384:  MOV     W0,21A
05386:  MOV     #E,W0
05388:  CPSGT   W1,W0
0538A:  BRA     5376
0538C:  MOV     1A62,W0
0538E:  MOV     #0,W4
05390:  CALL    240A
05394:  MOV     #11,W1
05396:  MOV     W1,W0
05398:  CLR.B   1
0539A:  CALL    1EE
0539E:  INC     W1,W1
053A0:  BTSC.B  219.1
053A2:  BRA     53A0
053A4:  MOV     W0,21A
053A6:  MOV     #17,W0
053A8:  CPSGT   W1,W0
053AA:  BRA     5396
053AC:  MOV     1A64,W0
053AE:  MOV     #0,W4
053B0:  CALL    240A
053B4:  MOV     #1A,W1
053B6:  MOV     W1,W0
053B8:  CLR.B   1
053BA:  CALL    1EE
053BE:  INC     W1,W1
053C0:  BTSC.B  219.1
053C2:  BRA     53C0
053C4:  MOV     W0,21A
053C6:  MOV     #20,W0
053C8:  CPSGT   W1,W0
053CA:  BRA     53B6
053CC:  MOV     1A66,W0
053CE:  MOV     #0,W4
053D0:  CALL    240A
053D4:  MOV     #23,W1
053D6:  MOV     W1,W0
053D8:  CLR.B   1
053DA:  CALL    1EE
053DE:  INC     W1,W1
053E0:  BTSC.B  219.1
053E2:  BRA     53E0
053E4:  MOV     W0,21A
053E6:  MOV     #29,W0
053E8:  CPSGT   W1,W0
053EA:  BRA     53D6
053EC:  MOV     1A68,W0
053EE:  MOV     #0,W4
053F0:  CALL    240A
053F4:  MOV     #2C,W1
053F6:  MOV     W1,W0
053F8:  CLR.B   1
053FA:  CALL    1EE
053FE:  INC     W1,W1
05400:  BTSC.B  219.1
05402:  BRA     5400
05404:  MOV     W0,21A
05406:  MOV     #32,W0
05408:  CPSGT   W1,W0
0540A:  BRA     53F6
0540C:  MOV     1A6A,W0
0540E:  MOV     #0,W4
05410:  CALL    240A
05414:  BTSC.B  219.1
05416:  BRA     5414
05418:  MOV     #20,W4
0541A:  MOV     W4,21A
0541C:  BTSC.B  219.1
0541E:  BRA     541C
05420:  MOV     #D,W4
05422:  MOV     W4,21A
.................... 	fprintf(ROBOTEQ,"^MAC 1 %u_^MDEC 1 %u_^MAC 2 %u_^MDEC 2 %u \r",ac1,dc1,ac2,dc2);// envoie au Roboteq 
05424:  MOV     #0,W1
05426:  MOV     W1,W0
05428:  CLR.B   1
0542A:  CALL    230
0542E:  INC     W1,W1
05430:  BTSC.B  219.1
05432:  BRA     5430
05434:  MOV     W0,21A
05436:  MOV     #6,W0
05438:  CPSGT   W1,W0
0543A:  BRA     5426
0543C:  MOV     1A6C,W0
0543E:  MOV     #0,W4
05440:  CALL    240A
05444:  MOV     #9,W1
05446:  MOV     W1,W0
05448:  CLR.B   1
0544A:  CALL    230
0544E:  INC     W1,W1
05450:  BTSC.B  219.1
05452:  BRA     5450
05454:  MOV     W0,21A
05456:  MOV     #11,W0
05458:  CPSGT   W1,W0
0545A:  BRA     5446
0545C:  MOV     1A6E,W0
0545E:  MOV     #0,W4
05460:  CALL    240A
05464:  MOV     #14,W1
05466:  MOV     W1,W0
05468:  CLR.B   1
0546A:  CALL    230
0546E:  INC     W1,W1
05470:  BTSC.B  219.1
05472:  BRA     5470
05474:  MOV     W0,21A
05476:  MOV     #1B,W0
05478:  CPSGT   W1,W0
0547A:  BRA     5466
0547C:  MOV     1A70,W0
0547E:  MOV     #0,W4
05480:  CALL    240A
05484:  MOV     #1E,W1
05486:  MOV     W1,W0
05488:  CLR.B   1
0548A:  CALL    230
0548E:  INC     W1,W1
05490:  BTSC.B  219.1
05492:  BRA     5490
05494:  MOV     W0,21A
05496:  MOV     #26,W0
05498:  CPSGT   W1,W0
0549A:  BRA     5486
0549C:  MOV     1A72,W0
0549E:  MOV     #0,W4
054A0:  CALL    240A
054A4:  BTSC.B  219.1
054A6:  BRA     54A4
054A8:  MOV     #20,W4
054AA:  MOV     W4,21A
054AC:  BTSC.B  219.1
054AE:  BRA     54AC
054B0:  MOV     #D,W4
054B2:  MOV     W4,21A
....................  
.................... 	write_eeprom(300,P1); 
054B4:  MOV.B   1A60,W0L
054B6:  MOV.B   W0L,A
054B8:  CLR.B   B
054BA:  MOV     #12C,W0
054BC:  MOV     #A,W1
054BE:  MOV     #2,W2
054C0:  CALL    511A
.................... 	write_eeprom(302,I1); 
054C4:  MOV     #12E,W0
054C6:  MOV     #1A62,W1
054C8:  MOV     #2,W2
054CA:  CALL    511A
.................... 	write_eeprom(304,D1); 
054CE:  MOV     #130,W0
054D0:  MOV     #1A64,W1
054D2:  MOV     #2,W2
054D4:  CALL    511A
.................... 	write_eeprom(306,P2); 
054D8:  MOV     #132,W0
054DA:  MOV     #1A66,W1
054DC:  MOV     #2,W2
054DE:  CALL    511A
.................... 	write_eeprom(308,I2); 
054E2:  MOV     #134,W0
054E4:  MOV     #1A68,W1
054E6:  MOV     #2,W2
054E8:  CALL    511A
.................... 	write_eeprom(310,D2); 
054EC:  MOV     #136,W0
054EE:  MOV     #1A6A,W1
054F0:  MOV     #2,W2
054F2:  CALL    511A
.................... 	 
.................... 	//Sauvegarde en eeprom 
.................... 	fputc('%',ROBOTEQ);//pas le choix de faire un putc, car le % est un caractère réservé pour le pritnf 
054F6:  MOV.B   #25,W0L
054F8:  BTSC.B  219.1
054FA:  BRA     54F8
054FC:  MOV.B   W0L,21A
054FE:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"EESAV \r");//envoie du reste de la commande 
05500:  MOV     #0,W1
05502:  MOV     W1,W0
05504:  CLR.B   1
05506:  CALL    26A
0550A:  INC     W1,W1
0550C:  BTSC.B  219.1
0550E:  BRA     550C
05510:  MOV     W0,21A
05512:  MOV     #6,W0
05514:  CPSGT   W1,W0
05516:  BRA     5502
05518:  MOV     [--W15],W5
0551A:  RETURN  
....................  
.................... } 
....................  
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadObjectifs(void) 
*
01A3C:  MOV     W5,[W15++]
01A3E:  MOV     W6,[W15++]
01A40:  CLR     1A4A
01A42:  CLR     1A4C
01A44:  CLR     1A4E
01A46:  CLR     1A50
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset; 
.................... 	unsigned int16 NumObj = 0; 
.................... 	unsigned int16 Obj = 0; 
....................  
.................... 	while(y==0) 
01A48:  CP0     1A4C
01A4A:  BRA     NZ,1AD0
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
01A4C:  MOV     14AA,W3
01A4E:  MOV     #0,W4
01A50:  MOV     #2,W5
01A52:  CALL    1A24
01A56:  MOV     W0,1A50
.................... 		NumObj = read_eeprom(offset+2); 
01A58:  MOV     14AA,W4
01A5A:  ADD     W4,#2,W5
01A5C:  MOV     W5,[W15++]
01A5E:  MOV     W5,W3
01A60:  MOV     #0,W4
01A62:  MOV     #2,W5
01A64:  CALL    1A24
01A68:  MOV     [--W15],W5
01A6A:  MOV     W0,1A4E
.................... 		if(Obj!=0xFFFF)//Si il en reste 
01A6C:  MOV     1A50,W4
01A6E:  MOV     #FFFF,W3
01A70:  CP      W3,W4
01A72:  BRA     Z,1AC8
.................... 		{ 
.................... 			for( i = 0 ; i < 24; i += 2) 
01A74:  CLR     1A4A
01A76:  MOV     1A4A,W4
01A78:  CP      W4,#18
01A7A:  BRA     C,1ABA
.................... 			{			 
.................... 				TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
01A7C:  MOV     1A50,W4
01A7E:  MOV     #138,W3
01A80:  MUL.UU  W4,W3,W0
01A82:  MOV     W0,W5
01A84:  MOV     1A4E,W4
01A86:  MUL.UU  W4,#18,W0
01A88:  ADD     W0,W5,W5
01A8A:  MOV     1A4A,W6
01A8C:  LSR     W6,#1,W6
01A8E:  SL      W6,#1,W0
01A90:  ADD     W0,W5,W0
01A92:  MOV     #A8A,W4
01A94:  ADD     W0,W4,W5
01A96:  MOV     1A4A,W4
01A98:  ADD     W4,#4,W6
01A9A:  MOV     W6,W0
01A9C:  ADD     14AA,W0
01A9E:  MOV     W0,W6
01AA0:  MOV     W5,[W15++]
01AA2:  MOV     W6,W3
01AA4:  MOV     #0,W4
01AA6:  MOV     #2,W5
01AA8:  CALL    1A24
01AAC:  MOV     [--W15],W5
01AAE:  MOV     W0,[W5]
01AB0:  MOV     1A4A,W4
01AB2:  ADD     W4,#2,W0
01AB4:  MOV     W0,1A4A
01AB6:  GOTO    1A76
.................... 			}	 
.................... 			offset += 28;// offset de +24,afin de lire les objectifs suivant	 
01ABA:  MOV     14AA,W4
01ABC:  ADD     W4,#1C,W0
01ABE:  MOV     W0,14AA
.................... 			NbreObjectifs=Obj;	 
01AC0:  PUSH    1A50
01AC2:  POP     13D4
.................... 		} 
01AC4:  GOTO    1ACC
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
01AC8:  MOV     #1,W4
01ACA:  MOV     W4,1A4C
.................... 		} 
01ACC:  GOTO    1A48
.................... 	} 
01AD0:  MOV     [--W15],W6
01AD2:  MOV     [--W15],W5
01AD4:  RETURN  
....................  
.................... } 
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadZones_Interdites(void) 
*
05568:  MOV     W5,[W15++]
0556A:  MOV     W6,[W15++]
0556C:  CLR     1A4A
0556E:  CLR     1A4C
05570:  CLR     1A4E
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset = 200; 
.................... 	unsigned int16 NumZone = 0; 
....................  
.................... 	while(y==0) 
05572:  CP0     1A4C
05574:  BRA     NZ,55DA
.................... 	{ 
.................... 		NumZone = read_eeprom(offset);//on check si il reste des objectifs 
05576:  MOV     14AC,W3
05578:  MOV     #0,W4
0557A:  MOV     #2,W5
0557C:  CALL    1A24
05580:  MOV     W0,1A4E
.................... 		if(NumZone!=0xFFFF)//Si il en reste 
05582:  MOV     1A4E,W4
05584:  MOV     #FFFF,W3
05586:  CP      W3,W4
05588:  BRA     Z,55D2
.................... 		{ 
.................... 			for( i = 0 ; i < 16; i += 2) 
0558A:  CLR     1A4A
0558C:  MOV     1A4A,W4
0558E:  CP      W4,#10
05590:  BRA     C,55C6
.................... 			{ 
.................... 				TabZones[NumZone][(i/2)] = read_eeprom(i+2+offset);//remplir le tableau avec les objectifs 
05592:  MOV     1A4E,W5
05594:  SL      W5,#4,W5
05596:  MOV     1A4A,W6
05598:  LSR     W6,#1,W6
0559A:  SL      W6,#1,W0
0559C:  ADD     W0,W5,W0
0559E:  MOV     #1312,W4
055A0:  ADD     W0,W4,W5
055A2:  MOV     1A4A,W4
055A4:  ADD     W4,#2,W6
055A6:  MOV     W6,W0
055A8:  ADD     14AC,W0
055AA:  MOV     W0,W6
055AC:  MOV     W5,[W15++]
055AE:  MOV     W6,W3
055B0:  MOV     #0,W4
055B2:  MOV     #2,W5
055B4:  CALL    1A24
055B8:  MOV     [--W15],W5
055BA:  MOV     W0,[W5]
055BC:  MOV     1A4A,W4
055BE:  ADD     W4,#2,W0
055C0:  MOV     W0,1A4A
055C2:  GOTO    558C
.................... 			}	 
.................... 			offset += 18;// offset de +24,afin de lire les objectifs suivant	 
055C6:  MOV     14AC,W4
055C8:  ADD     W4,#12,W0
055CA:  MOV     W0,14AC
.................... 			NbreZone_check++; 
055CC:  INC.B   087E
.................... 		} 
055CE:  GOTO    55D6
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
055D2:  MOV     #1,W4
055D4:  MOV     W4,1A4C
.................... 		} 
055D6:  GOTO    5572
.................... 			 
.................... 	} 
055DA:  MOV     [--W15],W6
055DC:  MOV     [--W15],W5
055DE:  RETURN  
.................... //	NbreZone = read_eeprom(512);	 
.................... } 
....................  
.................... // Actions à effectuer 
.................... void __Action_Writting(unsigned int8 ActionToDo) 
.................... { 
.................... //	unsigned int8 StateDriver = 0; 
.................... 	switch(ActionToDo) 
*
04C1A:  MOV.B   1A3E,W0L
04C1C:  CLR.B   1
04C1E:  XOR     #0,W0
04C20:  BRA     Z,4C44
04C22:  XOR     #1,W0
04C24:  BRA     Z,4C4A
04C26:  XOR     #3,W0
04C28:  BRA     Z,4C52
04C2A:  XOR     #1,W0
04C2C:  BRA     Z,4C5E
04C2E:  XOR     #7,W0
04C30:  BRA     Z,4C66
04C32:  XOR     #1,W0
04C34:  BRA     Z,4C70
04C36:  XOR     #2,W0
04C38:  BRA     Z,4C78
04C3A:  XOR     #F,W0
04C3C:  BRA     Z,4C80
04C3E:  XOR     #1,W0
04C40:  BRA     Z,4C88
04C42:  BRA     4C90
.................... 	{ 
.................... 		// Ne fait rien 
.................... 		case 0 : 
.................... 			Action_send=1; 
04C44:  BSET.B  85B.6
.................... 			break;		 
04C46:  GOTO    4C9C
.................... 		case 1 : 
.................... 			Ramassage(); 
04C4A:  CALL    466E
.................... 			break;	 
04C4E:  GOTO    4C9C
.................... 		case 2 :  
.................... 			EjectionModule(3); 
04C52:  MOV.B   #3,W0L
04C54:  MOV.B   W0L,1A40
04C56:  CALL    475A
.................... 			break; 
04C5A:  GOTO    4C9C
.................... 		case 3 :  
.................... 			__Rentrage(); 
04C5E:  CALL    4718
.................... 			break; 
04C62:  GOTO    4C9C
.................... 		case 4 :  
.................... 			EjectionModule(0); 
04C66:  CLR.B   1A40
04C68:  CALL    475A
.................... 			break; 
04C6C:  GOTO    4C9C
.................... 		case 5 :  
.................... 			__GoToZero(); 
04C70:  CALL    12FA
.................... 			break; 
04C74:  GOTO    4C9C
.................... 		case 7 : 
.................... 			Ramassage_1module(); 
04C78:  CALL    4A90
.................... 			break; 
04C7C:  GOTO    4C9C
.................... 		case 8 :  
.................... 			Pos_barillet_module_du_fond(); 
04C80:  CALL    4B26
.................... 			break; 
04C84:  GOTO    4C9C
.................... 		case 9 :  
.................... 			Deposage(); 
04C88:  CALL    4BAA
.................... 			break; 
04C8C:  GOTO    4C9C
.................... 		default : 
.................... 			__Affichage_erreur(5); 
04C90:  MOV.B   #5,W0L
04C92:  MOV.B   W0L,1A4A
04C94:  CALL    1002
.................... 			break; 
04C98:  GOTO    4C9C
.................... 	} 
04C9C:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: EjectionModule																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy   												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui éjecte 1 module du barillet 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne le status du driver											 
.................... //					0-> non utilisé																 
.................... //					1-> OK : ordre transmis et terminé													 
.................... //					2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... void EjectionModule(unsigned int8 nbre_repet_ToDo) 
*
0475A:  MOV     W5,[W15++]
0475C:  MOV     W6,[W15++]
0475E:  CLR.B   1A41
04760:  CLR.B   1A42
.................... {	 
.................... //	signed int32 ActualPosition = 0; 
.................... 	static unsigned int8 Etat_driver 	= 0; //retourne si l'ordre a ete transmis ou non	 
.................... 	unsigned int8 Etat_dmot2 	= 0; //retourne l'etat du moteur 2 
.................... 	unsigned int8 Etat_dmot1 	= 0; //retourne l'etat du moteur 1 
.................... 	static int1 module_eject 			= 0; //retourne 1 quand on a envoyer le depl pour coucher les modules 
.................... 	static unsigned int8 nbre_repet_Do 	= 0; //nbre de fois fait le depl 
.................... 	static unsigned int8 Etat_depl 		= 0; //varaible du switch case, gere les depl 
.................... 	static unsigned int8 etat_old 		= 0; //sauvegarde du dernier depl fait	 
.................... 	static int1 eject_first_module 		= 0; 
.................... 	static int1 barillet_stop			= 0; 
.................... 	static int1 read 					= 0; 
.................... 	static int1 flag_motor_running_out 	= 0; 
.................... 	static int1 Order_send              = 0; 
.................... 	static int1 Order_send2             = 0; 
.................... 	static int1 flag_motor_wait_to_go   = 0; 
.................... 	//tourner, ejecter, reprendre cycle normale 
.................... 	 
.................... 	if(flag_motor_wait_to_go) 
04762:  BTSS.B  14B1.2
04764:  BRA     4774
.................... 	{ 
.................... 		flag_motor_running_out = __Check_action_end(0xC2); 
04766:  MOV.B   #C2,W0L
04768:  MOV.B   W0L,1A46
0476A:  CALL    13F2
0476E:  BCLR.B  14A2.7
04770:  BTSC.B  0.0
04772:  BSET.B  14A2.7
.................... 	}	 
.................... 	if(flag_motor_running_out) 
04774:  BTSS.B  14A2.7
04776:  BRA     479C
.................... 	{ 
.................... 		bras_in = 0; 
04778:  BCLR.B  14A2.1
.................... 		flag_motor_wait_to_go = 0; 
0477A:  BCLR.B  14B1.2
.................... 		if(!Order_send)Order_send=__Poussage(); 
0477C:  BTSC.B  14B1.0
0477E:  BRA     478E
04780:  CALL    46E0
04784:  BCLR.B  14B1.0
04786:  BTSC.B  0.0
04788:  BSET.B  14B1.0
0478A:  GOTO    479C
.................... 		else bras_out = __Check_action_end(0xC4); // attendre la fin de l'ordre	 
0478E:  MOV.B   #C4,W0L
04790:  MOV.B   W0L,1A46
04792:  CALL    13F2
04796:  BCLR.B  14A2.0
04798:  BTSC.B  0.0
0479A:  BSET.B  14A2.0
.................... 	} 
.................... 	if(bras_out) 
0479C:  BTSS.B  14A2.0
0479E:  BRA     47C4
.................... 	{ 
.................... 		flag_motor_running_out = 0; 
047A0:  BCLR.B  14A2.7
.................... 		Order_send = 0; 
047A2:  BCLR.B  14B1.0
.................... 		if(!Order_send2)Order_send2=__Rentrage(); 
047A4:  BTSC.B  14B1.1
047A6:  BRA     47B6
047A8:  CALL    4718
047AC:  BCLR.B  14B1.1
047AE:  BTSC.B  0.0
047B0:  BSET.B  14B1.1
047B2:  GOTO    47C4
.................... 		else bras_in = __Check_action_end(0xC4); // attendre la fin de l'ordre	 
047B6:  MOV.B   #C4,W0L
047B8:  MOV.B   W0L,1A46
047BA:  CALL    13F2
047BE:  BCLR.B  14A2.1
047C0:  BTSC.B  0.0
047C2:  BSET.B  14A2.1
.................... 	} 
.................... 	if(bras_in) 
047C4:  BTSS.B  14A2.1
047C6:  BRA     47CC
.................... 	{ 
.................... 		bras_out=0; 
047C8:  BCLR.B  14A2.0
.................... 		Order_send2=0; 
047CA:  BCLR.B  14B1.1
.................... 	} 
.................... 	 
....................    if(nbre_repet_Do<=nbre_repet_ToDo) 
047CC:  MOV.B   14AE,W0L
047CE:  MOV     1A40,W4
047D0:  CP.B    W4L,W0L
047D2:  BRA     NC,4A76
....................    { 
.................... 		switch(Etat_depl) 
047D4:  MOV.B   14AF,W0L
047D6:  CLR.B   1
047D8:  XOR     #0,W0
047DA:  BRA     Z,47EE
047DC:  XOR     #1,W0
047DE:  BRA     Z,4922
047E0:  XOR     #3,W0
047E2:  BRA     Z,498E
047E4:  XOR     #1,W0
047E6:  BRA     Z,4A00
047E8:  XOR     #7,W0
047EA:  BRA     Z,4A20
047EC:  BRA     4A72
.................... 		{ 
.................... 			case 0: 
.................... 				if(Etat_driver!=1 || eject_first_module == 0) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
047EE:  MOV     14A8,W4
047F0:  LSR     W4,#8,W4
047F2:  CP.B    W4L,#1
047F4:  BRA     NZ,47FA
047F6:  BTSC.B  14A2.4
047F8:  BRA     4910
.................... 				{ 
.................... 					if(read==0) 
047FA:  BTSC.B  14A2.6
047FC:  BRA     480C
.................... 					{ 
.................... 						ActualPosition = read_pos_moteur(0xC0); 
047FE:  MOV.B   #C0,W0L
04800:  MOV.B   W0L,1A4A
04802:  CALL    114A
04806:  MOV     W0,85C
04808:  MOV     W1,85E
.................... 						read=1; 
0480A:  BSET.B  14A2.6
.................... 					} 
.................... 					delay_ms(10); 
0480C:  MOV     #A,W0
0480E:  CALL    E84
.................... 					if(nbre_repet_Do==0 && module_eject == 0)//Si premier mouvement 
04812:  CP0.B   14AE
04814:  BRA     NZ,4892
04816:  BTSC.B  14A2.3
04818:  BRA     4892
.................... 					{ 
.................... 						if(barillet_stop==0)//on tourne le barillet 
0481A:  BTSC.B  14A2.5
0481C:  BRA     487C
.................... 						{			 
.................... 							if(Etat_driver!=1)  
0481E:  MOV     14A8,W4
04820:  LSR     W4,#8,W4
04822:  CP.B    W4L,#1
04824:  BRA     Z,4864
.................... 							{ 
.................... 								Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,ActualPosition+500); 
04826:  MOV     #1F4,W4
04828:  MOV     85C,W3
0482A:  ADD     W3,W4,W5
0482C:  MOV     85E,W4
0482E:  ADDC    W4,#0,W6
04830:  MOV.B   #C0,W0L
04832:  MOV.B   W0L,1A4C
04834:  CLR.B   1A4D
04836:  MOV.B   #1,W0L
04838:  MOV.B   W0L,1A4E
0483A:  MOV.B   #1,W0L
0483C:  MOV.B   W0L,1A4F
0483E:  PUSH    149C
04840:  POP     1A50
04842:  MOV     W5,1A52
04844:  MOV     W6,1A54
04846:  CALL    11E0
0484A:  MOV.B   W0L,14A9
.................... 								Endposition = ActualPosition + 500; 
0484C:  MOV     #1F4,W4
0484E:  MOV     85C,W3
04850:  ADD     W3,W4,W0
04852:  MOV     W0,149E
04854:  MOV     85E,W4
04856:  ADDC    W4,#0,W0
04858:  MOV     W0,14A0
.................... 								delay_ms(10); 
0485A:  MOV     #A,W0
0485C:  CALL    E84
.................... 							} 
04860:  GOTO    4878
.................... 							else  
.................... 							{ 
.................... 								barillet_stop = __Check_action_end(0xC0); 
04864:  MOV.B   #C0,W0L
04866:  MOV.B   W0L,1A46
04868:  CALL    13F2
0486C:  BCLR.B  14A2.5
0486E:  BTSC.B  0.0
04870:  BSET.B  14A2.5
.................... 								delay_ms(10); 
04872:  MOV     #A,W0
04874:  CALL    E84
.................... 							} 
.................... 						} 
04878:  GOTO    4888
.................... 						else  
.................... 						{ 
.................... 							module_eject = Ejecte();//d'une fois le barillet bouger et ejecte le tube 
0487C:  CALL    17DC
04880:  BCLR.B  14A2.3
04882:  BTSC.B  0.0
04884:  BSET.B  14A2.3
.................... 							read = 0; 
04886:  BCLR.B  14A2.6
.................... 						} 
.................... 						if(module_eject)flag_motor_wait_to_go = 1; 
04888:  BTSS.B  14A2.3
0488A:  BRA     488E
0488C:  BSET.B  14B1.2
.................... 					} 
0488E:  GOTO    4904
.................... 					else 
.................... 					{ 
.................... 						eject_first_module = 1;  
04892:  BSET.B  14A2.4
.................... 						//619 
.................... 						if(nbre_repet_do==0) 
04894:  CP0.B   14AE
04896:  BRA     NZ,48D0
.................... 						{ 
.................... 							Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,ActualPosition+619); 
04898:  MOV     #26B,W4
0489A:  MOV     85C,W3
0489C:  ADD     W3,W4,W5
0489E:  MOV     85E,W4
048A0:  ADDC    W4,#0,W6
048A2:  MOV.B   #C0,W0L
048A4:  MOV.B   W0L,1A4C
048A6:  CLR.B   1A4D
048A8:  MOV.B   #1,W0L
048AA:  MOV.B   W0L,1A4E
048AC:  MOV.B   #1,W0L
048AE:  MOV.B   W0L,1A4F
048B0:  PUSH    149C
048B2:  POP     1A50
048B4:  MOV     W5,1A52
048B6:  MOV     W6,1A54
048B8:  CALL    11E0
048BC:  MOV.B   W0L,14A9
.................... 							Endposition = ActualPosition + 619; 
048BE:  MOV     #26B,W4
048C0:  MOV     85C,W3
048C2:  ADD     W3,W4,W0
048C4:  MOV     W0,149E
048C6:  MOV     85E,W4
048C8:  ADDC    W4,#0,W0
048CA:  MOV     W0,14A0
.................... 						} 
048CC:  GOTO    4904
.................... 						else  
.................... 						{ 
.................... 							Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,ActualPosition+739); 
048D0:  MOV     #2E3,W4
048D2:  MOV     85C,W3
048D4:  ADD     W3,W4,W5
048D6:  MOV     85E,W4
048D8:  ADDC    W4,#0,W6
048DA:  MOV.B   #C0,W0L
048DC:  MOV.B   W0L,1A4C
048DE:  CLR.B   1A4D
048E0:  MOV.B   #1,W0L
048E2:  MOV.B   W0L,1A4E
048E4:  MOV.B   #1,W0L
048E6:  MOV.B   W0L,1A4F
048E8:  PUSH    149C
048EA:  POP     1A50
048EC:  MOV     W5,1A52
048EE:  MOV     W6,1A54
048F0:  CALL    11E0
048F4:  MOV.B   W0L,14A9
.................... 							Endposition = ActualPosition + 739; 
048F6:  MOV     #2E3,W4
048F8:  MOV     85C,W3
048FA:  ADD     W3,W4,W0
048FC:  MOV     W0,149E
048FE:  MOV     85E,W4
04900:  ADDC    W4,#0,W0
04902:  MOV     W0,14A0
.................... 						} 
.................... 					} 
.................... 					etat_old = 0;						//retient le dernier depl		 
04904:  CLR.B   14B0
.................... 					delay_ms(20);			 
04906:  MOV     #14,W0
04908:  CALL    E84
.................... 				} 
0490C:  GOTO    491E
.................... 				else 
.................... 				{ 
.................... 					eject_first_module = 1; 
04910:  BSET.B  14A2.4
.................... 					module_eject = 0; 
04912:  BCLR.B  14A2.3
.................... 					Etat_depl = 4; //on attend que le depl soit fini 
04914:  MOV.B   #4,W0L
04916:  MOV.B   W0L,14AF
.................... 					Etat_driver = 0; 
04918:  CLR.B   14A9
.................... 					read = 0; 
0491A:  BCLR.B  14A2.6
.................... 					barillet_stop = 0; 
0491C:  BCLR.B  14A2.5
.................... 				}			 
.................... 				break;			 
0491E:  GOTO    4A72
.................... 			 
.................... 			case 1: 
.................... 				if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
04922:  MOV     14A8,W4
04924:  LSR     W4,#8,W4
04926:  CP.B    W4L,#1
04928:  BRA     Z,4982
.................... 				{ 
.................... 					if(read==0)  
0492A:  BTSC.B  14A2.6
0492C:  BRA     493C
.................... 					{ 
.................... 						ActualPosition = read_pos_moteur(0xC0); 
0492E:  MOV.B   #C0,W0L
04930:  MOV.B   W0L,1A4A
04932:  CALL    114A
04936:  MOV     W0,85C
04938:  MOV     W1,85E
.................... 						read = 1; 
0493A:  BSET.B  14A2.6
.................... 					} 
.................... 					delay_ms(5); 
0493C:  MOV     #5,W0
0493E:  CALL    E84
.................... 					Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,ActualPosition-920);//-875 
04942:  MOV     85C,W4
04944:  SUB     #398,W4
04946:  MOV     W4,W5
04948:  MOV     85E,W4
0494A:  SUBB    W4,#0,W6
0494C:  MOV.B   #C0,W0L
0494E:  MOV.B   W0L,1A4C
04950:  CLR.B   1A4D
04952:  MOV.B   #1,W0L
04954:  MOV.B   W0L,1A4E
04956:  MOV.B   #1,W0L
04958:  MOV.B   W0L,1A4F
0495A:  PUSH    149C
0495C:  POP     1A50
0495E:  MOV     W5,1A52
04960:  MOV     W6,1A54
04962:  CALL    11E0
04966:  MOV.B   W0L,14A9
.................... 					Endposition = ActualPosition - 920; 
04968:  MOV     85C,W4
0496A:  SUB     #398,W4
0496C:  MOV     W4,149E
0496E:  MOV     85E,W4
04970:  SUBB    W4,#0,W0
04972:  MOV     W0,14A0
.................... 					etat_old = 1;						//retient le dernier depl 
04974:  MOV.B   #1,W0L
04976:  MOV.B   W0L,14B0
.................... 					delay_ms(20); 
04978:  MOV     #14,W0
0497A:  CALL    E84
.................... 				} 
0497E:  GOTO    498A
.................... 				else 
.................... 				{ 
.................... 					read = 0; 
04982:  BCLR.B  14A2.6
.................... 					Etat_depl = 4; //on attend que la depl soit fini  
04984:  MOV.B   #4,W0L
04986:  MOV.B   W0L,14AF
.................... 					Etat_driver = 0; 
04988:  CLR.B   14A9
.................... 				} 
.................... 				break; 
0498A:  GOTO    4A72
.................... 			 
.................... 			case 2: 
.................... 			 if(bras_in) 
0498E:  BTSS.B  14A2.1
04990:  BRA     49FC
.................... 			 { 
.................... 				if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
04992:  MOV     14A8,W4
04994:  LSR     W4,#8,W4
04996:  CP.B    W4L,#1
04998:  BRA     Z,49F4
.................... 				{ 
.................... 					if(read==0)  
0499A:  BTSC.B  14A2.6
0499C:  BRA     49AC
.................... 					{ 
.................... 						ActualPosition = read_pos_moteur(0xC0); 
0499E:  MOV.B   #C0,W0L
049A0:  MOV.B   W0L,1A4A
049A2:  CALL    114A
049A6:  MOV     W0,85C
049A8:  MOV     W1,85E
.................... 						read = 1; 
049AA:  BSET.B  14A2.6
.................... 					} 
.................... 					delay_ms(5); 
049AC:  MOV     #5,W0
049AE:  CALL    E84
.................... 					Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,ActualPosition+1320);//+1325 
049B2:  MOV     #528,W4
049B4:  MOV     85C,W3
049B6:  ADD     W3,W4,W5
049B8:  MOV     85E,W4
049BA:  ADDC    W4,#0,W6
049BC:  MOV.B   #C0,W0L
049BE:  MOV.B   W0L,1A4C
049C0:  CLR.B   1A4D
049C2:  MOV.B   #1,W0L
049C4:  MOV.B   W0L,1A4E
049C6:  MOV.B   #1,W0L
049C8:  MOV.B   W0L,1A4F
049CA:  PUSH    149C
049CC:  POP     1A50
049CE:  MOV     W5,1A52
049D0:  MOV     W6,1A54
049D2:  CALL    11E0
049D6:  MOV.B   W0L,14A9
.................... 					Endposition = ActualPosition + 1320; 
049D8:  MOV     #528,W4
049DA:  MOV     85C,W3
049DC:  ADD     W3,W4,W0
049DE:  MOV     W0,149E
049E0:  MOV     85E,W4
049E2:  ADDC    W4,#0,W0
049E4:  MOV     W0,14A0
.................... 					etat_old = 2;						//retient le dernier depl 
049E6:  MOV.B   #2,W0L
049E8:  MOV.B   W0L,14B0
.................... 					delay_ms(20); 
049EA:  MOV     #14,W0
049EC:  CALL    E84
.................... 				} 
049F0:  GOTO    49FC
.................... 				else 
.................... 				{ 
.................... 					read = 0; 
049F4:  BCLR.B  14A2.6
.................... 					Etat_depl = 4; //on attend que la depl soit fini  
049F6:  MOV.B   #4,W0L
049F8:  MOV.B   W0L,14AF
.................... 					Etat_driver = 0; 
049FA:  CLR.B   14A9
.................... 				} 
.................... 			} 
.................... 				break; 
049FC:  GOTO    4A72
.................... 				 
.................... 			case 3: 
.................... 				if(module_eject==0) // si on a coucher le module 
04A00:  BTSC.B  14A2.3
04A02:  BRA     4A0E
.................... 				{ 
.................... 					module_eject = Ejecte(); 
04A04:  CALL    17DC
04A08:  BCLR.B  14A2.3
04A0A:  BTSC.B  0.0
04A0C:  BSET.B  14A2.3
.................... 				} 
.................... 				if(module_eject) 
04A0E:  BTSS.B  14A2.3
04A10:  BRA     4A18
.................... 				{	 
.................... 					Etat_depl = 4; 
04A12:  MOV.B   #4,W0L
04A14:  MOV.B   W0L,14AF
.................... 					module_eject = 0; 
04A16:  BCLR.B  14A2.3
.................... 				} 
.................... 				etat_old = 3;		//retient le dernier depl 
04A18:  MOV.B   #3,W0L
04A1A:  MOV.B   W0L,14B0
.................... 				break;			 
04A1C:  GOTO    4A72
.................... 			 
.................... 			case 4: 	 
.................... 				if(etat_old != 3)// etat_old = 3--> on doit faire tourner l'autre moteur 
04A20:  MOV     14B0,W4
04A22:  CP.B    W4L,#3
04A24:  BRA     Z,4A48
.................... 				{ 
.................... 					Etat_dmot1 = __Check_action_end(0xC0);//check que le moteur est stopper 
04A26:  MOV.B   #C0,W0L
04A28:  MOV.B   W0L,1A46
04A2A:  CALL    13F2
04A2E:  MOV.B   W0L,1A42
.................... 					if(Etat_dmot1 == 1)//si le moteur est arreter  
04A30:  MOV     1A42,W4
04A32:  CP.B    W4L,#1
04A34:  BRA     NZ,4A44
.................... 					{ 
.................... 						Etat_depl = Etat_old+1;//on passe au depl suivant 
04A36:  MOV     14B0,W4
04A38:  ADD.B   W4L,#1,W0L
04A3A:  MOV.B   W0L,14AF
.................... 						Etat_driver = 0; 
04A3C:  CLR.B   14A9
.................... 						delay_ms(30); 
04A3E:  MOV     #1E,W0
04A40:  CALL    E84
.................... 					} 
.................... 	 
.................... 				} 
04A44:  GOTO    4A6E
.................... 				else 
.................... 				{ 
.................... 					Etat_dmot2 = __Check_action_end(0xC2); //check que le moteur est stopper  
04A48:  MOV.B   #C2,W0L
04A4A:  MOV.B   W0L,1A46
04A4C:  CALL    13F2
04A50:  MOV.B   W0L,1A41
.................... 					delay_ms(5); 
04A52:  MOV     #5,W0
04A54:  CALL    E84
.................... 					if(Etat_dmot2 == 1)//ordre precedent fini 
04A58:  MOV     1A40,W4
04A5A:  LSR     W4,#8,W4
04A5C:  CP.B    W4L,#1
04A5E:  BRA     NZ,4A6E
.................... 					{ 
.................... 						nbre_repet_Do++; 
04A60:  INC.B   14AE
.................... 						flag_motor_running_out = 1;						 
04A62:  BSET.B  14A2.7
.................... 						Etat_depl = 0; // on recommence  
04A64:  CLR.B   14AF
.................... 						delay_ms(30); 
04A66:  MOV     #1E,W0
04A68:  CALL    E84
.................... 						Etat_dmot2 = 0; 
04A6C:  CLR.B   1A41
.................... 					} 
.................... 				} 
.................... 				break; 
04A6E:  GOTO    4A72
.................... 		} 
.................... 	} 
04A72:  GOTO    4A8A
.................... 	else  
.................... 	{	 
.................... 		if(bras_in == 1 && flag_motor_running_out == 0) 
04A76:  BTSS.B  14A2.1
04A78:  BRA     4A8A
04A7A:  BTSC.B  14A2.7
04A7C:  BRA     4A8A
.................... 		{ 
.................... 			Action_send = 1; 
04A7E:  BSET.B  85B.6
.................... 			Etat_driver = 0; 
04A80:  CLR.B   14A9
.................... 			nbre_repet_Do = 0; 
04A82:  CLR.B   14AE
.................... 			eject_first_module = 0; 
04A84:  BCLR.B  14A2.4
.................... 			module_eject = 0; 
04A86:  BCLR.B  14A2.3
.................... 			return; 
04A88:  BRA     4A8A
.................... 		} 
.................... 	}	 
04A8A:  MOV     [--W15],W6
04A8C:  MOV     [--W15],W5
04A8E:  RETURN  
....................  
.................... }	 
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Poussage																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui pousse les modules dans le village 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Poussage(void) 
.................... { 
.................... 	static int8 Etat; 
.................... 	if(Etat!=1)  
*
046E0:  MOV.B   14B2,W0L
046E2:  SE      W0,W0
046E4:  CP      W0,#1
046E6:  BRA     Z,470E
.................... 	{ 
.................... 		Etat = go_driver_moteur(0xC4,1,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,250); 
046E8:  MOV.B   #C4,W0L
046EA:  MOV.B   W0L,1A4C
046EC:  MOV.B   #1,W0L
046EE:  MOV.B   W0L,1A4D
046F0:  MOV.B   #2,W0L
046F2:  MOV.B   W0L,1A4E
046F4:  CLR.B   1A4F
046F6:  MOV     #64,W4
046F8:  MOV     W4,1A50
046FA:  MOV     #FA,W4
046FC:  MOV     W4,1A52
046FE:  CLR     1A54
04700:  CALL    11E0
04704:  MOV.B   W0L,14B2
.................... 		return(0); 
04706:  CLR.B   0
04708:  BRA     4716
.................... 	} 
0470A:  GOTO    4716
.................... 	else  
.................... 	{	 
.................... 		Etat = 0 ; 
0470E:  CLR.B   14B2
.................... 		return(1); 
04710:  MOV.B   #1,W0L
04712:  MOV.B   W0L,0
04714:  BRA     4716
.................... 	} 
04716:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Rentrage																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui pousse les modules dans le village 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Rentrage(void) 
.................... { 
....................  
.................... 	static int8 Etat; 
.................... 	if(Etat!=1) 
04718:  MOV.B   14B3,W0L
0471A:  SE      W0,W0
0471C:  CP      W0,#1
0471E:  BRA     Z,4744
....................     {    
.................... 		Etat = go_driver_moteur(0xC4,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,250); 
04720:  MOV.B   #C4,W0L
04722:  MOV.B   W0L,1A4C
04724:  CLR.B   1A4D
04726:  MOV.B   #2,W0L
04728:  MOV.B   W0L,1A4E
0472A:  CLR.B   1A4F
0472C:  MOV     #64,W4
0472E:  MOV     W4,1A50
04730:  MOV     #FA,W4
04732:  MOV     W4,1A52
04734:  CLR     1A54
04736:  CALL    11E0
0473A:  MOV.B   W0L,14B3
.................... 		return(0); 
0473C:  CLR.B   0
0473E:  BRA     4758
.................... 	} 
04740:  GOTO    4758
.................... 	else  
.................... 	{	 
.................... 		Etat = 0 ; 
04744:  CLR.B   14B3
.................... 		if(obj_Action==3) Action_send=1; 
04746:  MOV     13BE,W4
04748:  CP      W4,#3
0474A:  BRA     NZ,4752
0474C:  BSET.B  85B.6
0474E:  GOTO    4758
.................... 		else return(1); 
04752:  MOV.B   #1,W0L
04754:  MOV.B   W0L,0
04756:  BRA     4758
.................... 	} 
04758:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Pos_barillet_module_du_fond()																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui ramasse les modules dans une fusée (1 tour complet) 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... void Pos_barillet_module_du_fond(void) 
*
04B26:  MOV     W5,[W15++]
04B28:  MOV     W6,[W15++]
04B2A:  CLR     1A40
04B2C:  CLR     1A42
.................... { 
.................... 	signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	static int1 barillet_in_place;	 
.................... 	if(barillet_in_place) 
04B2E:  BTSS.B  14B1.4
04B30:  BRA     4B9A
.................... 	{ 
.................... 		if(Etat!=1) 
04B32:  MOV.B   14B4,W0L
04B34:  SE      W0,W0
04B36:  CP      W0,#1
04B38:  BRA     Z,4B86
.................... 		{ 
.................... 			if(!read) 
04B3A:  BTSC.B  14B1.3
04B3C:  BRA     4B4C
.................... 			{ 
.................... 				ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
04B3E:  MOV.B   #C0,W0L
04B40:  MOV.B   W0L,1A4A
04B42:  CALL    114A
04B46:  MOV     W0,1A40
04B48:  MOV     W1,1A42
.................... 				read = 1; 
04B4A:  BSET.B  14B1.3
.................... 			} 
.................... 			delay_ms(20); 
04B4C:  MOV     #14,W0
04B4E:  CALL    E84
.................... 			Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot,DRV_ARRET_POSITION_ABSOLUE, (ActualPosition+1500)); 
04B52:  MOV     #5DC,W4
04B54:  MOV     1A40,W3
04B56:  ADD     W3,W4,W5
04B58:  MOV     1A42,W4
04B5A:  ADDC    W4,#0,W6
04B5C:  MOV.B   #C0,W0L
04B5E:  MOV.B   W0L,1A4C
04B60:  CLR.B   1A4D
04B62:  MOV.B   #1,W0L
04B64:  MOV.B   W0L,1A4E
04B66:  MOV.B   #1,W0L
04B68:  MOV.B   W0L,1A4F
04B6A:  PUSH    1498
04B6C:  POP     1A50
04B6E:  MOV     W5,1A52
04B70:  MOV     W6,1A54
04B72:  CALL    11E0
04B76:  MOV.B   W0L,14B4
.................... 			Endposition	= ActualPosition+1500; 
04B78:  MOV     #5DC,W4
04B7A:  MOV     1A40,W3
04B7C:  ADD     W3,W4,W0
04B7E:  MOV     W0,149E
04B80:  MOV     1A42,W4
04B82:  ADDC    W4,#0,W0
04B84:  MOV     W0,14A0
.................... 		} 
.................... 		if(Etat == 1) 
04B86:  MOV.B   14B4,W0L
04B88:  SE      W0,W0
04B8A:  CP      W0,#1
04B8C:  BRA     NZ,4B96
.................... 		{ 
.................... 			Etat = 0; 
04B8E:  CLR.B   14B4
.................... 			read = 0; 
04B90:  BCLR.B  14B1.3
.................... 			Action_send = 1; 
04B92:  BSET.B  85B.6
.................... 			flag_module_fond = 1; 
04B94:  BSET.B  14A2.2
.................... 		} 
.................... 	} 
04B96:  GOTO    4BA4
.................... 	else barillet_in_place = __GoToZero();		 
04B9A:  CALL    12FA
04B9E:  BCLR.B  14B1.4
04BA0:  BTSC.B  0.0
04BA2:  BSET.B  14B1.4
04BA4:  MOV     [--W15],W6
04BA6:  MOV     [--W15],W5
04BA8:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Deposage																															 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui ramasse les modules dans une fusée (1 tour complet) 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... void Deposage(void) 
04BAA:  MOV     W5,[W15++]
04BAC:  MOV     W6,[W15++]
04BAE:  CLR     1A40
04BB0:  CLR     1A42
.................... { 
.................... 	signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	if(Etat!=1) 
04BB2:  MOV.B   14B5,W0L
04BB4:  SE      W0,W0
04BB6:  CP      W0,#1
04BB8:  BRA     Z,4C06
.................... 	{ 
.................... 		if(!read) 
04BBA:  BTSC.B  14B1.5
04BBC:  BRA     4BCC
.................... 		{ 
.................... 			ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
04BBE:  MOV.B   #C0,W0L
04BC0:  MOV.B   W0L,1A4A
04BC2:  CALL    114A
04BC6:  MOV     W0,1A40
04BC8:  MOV     W1,1A42
.................... 			read = 1; 
04BCA:  BSET.B  14B1.5
.................... 		} 
.................... 		delay_ms(20); 
04BCC:  MOV     #14,W0
04BCE:  CALL    E84
.................... 		Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot,DRV_ARRET_POSITION_ABSOLUE, ActualPosition-5420);	 
04BD2:  MOV     1A40,W4
04BD4:  MOV     #152C,W3
04BD6:  SUB     W4,W3,W5
04BD8:  MOV     1A42,W4
04BDA:  SUBB    W4,#0,W6
04BDC:  MOV.B   #C0,W0L
04BDE:  MOV.B   W0L,1A4C
04BE0:  CLR.B   1A4D
04BE2:  MOV.B   #1,W0L
04BE4:  MOV.B   W0L,1A4E
04BE6:  MOV.B   #1,W0L
04BE8:  MOV.B   W0L,1A4F
04BEA:  PUSH    1498
04BEC:  POP     1A50
04BEE:  MOV     W5,1A52
04BF0:  MOV     W6,1A54
04BF2:  CALL    11E0
04BF6:  MOV.B   W0L,14B5
.................... 		Endposition = ActualPosition-5420; 
04BF8:  MOV     1A40,W4
04BFA:  MOV     #152C,W3
04BFC:  SUB     W4,W3,W0
04BFE:  MOV     W0,149E
04C00:  MOV     1A42,W4
04C02:  SUBB    W4,#0,W0
04C04:  MOV     W0,14A0
.................... 	} 
.................... 	if(Etat == 1) 
04C06:  MOV.B   14B5,W0L
04C08:  SE      W0,W0
04C0A:  CP      W0,#1
04C0C:  BRA     NZ,4C14
.................... 	{ 
.................... 		Etat = 0; 
04C0E:  CLR.B   14B5
.................... 		read = 0; 
04C10:  BCLR.B  14B1.5
.................... 		Action_send = 1; 
04C12:  BSET.B  85B.6
.................... 	}		 
04C14:  MOV     [--W15],W6
04C16:  MOV     [--W15],W5
04C18:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Ramassage																															 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui ramasse les modules dans une fusée (1 tour complet) 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... void Ramassage(void) 
*
0466E:  MOV     W5,[W15++]
04670:  MOV     W6,[W15++]
04672:  CLR     1A40
04674:  CLR     1A42
.................... { 
.................... 	signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	if(Etat!=1) 
04676:  MOV.B   14B6,W0L
04678:  SE      W0,W0
0467A:  CP      W0,#1
0467C:  BRA     Z,46CC
.................... 	{ 
.................... 		if(!read) 
0467E:  BTSC.B  14B1.6
04680:  BRA     4690
.................... 		{ 
.................... 			ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
04682:  MOV.B   #C0,W0L
04684:  MOV.B   W0L,1A4A
04686:  CALL    114A
0468A:  MOV     W0,1A40
0468C:  MOV     W1,1A42
.................... 			read = 1; 
0468E:  BSET.B  14B1.6
.................... 		} 
.................... 		delay_ms(20); 
04690:  MOV     #14,W0
04692:  CALL    E84
.................... 		Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot,DRV_ARRET_POSITION_ABSOLUE,5420 + ActualPosition);	 
04696:  MOV     #152C,W0
04698:  ADD     1A40,W0
0469A:  MOV     W0,W5
0469C:  MOV     #0,W0
0469E:  ADDC    1A42,W0
046A0:  MOV     W0,W6
046A2:  MOV.B   #C0,W0L
046A4:  MOV.B   W0L,1A4C
046A6:  CLR.B   1A4D
046A8:  MOV.B   #1,W0L
046AA:  MOV.B   W0L,1A4E
046AC:  MOV.B   #1,W0L
046AE:  MOV.B   W0L,1A4F
046B0:  PUSH    1498
046B2:  POP     1A50
046B4:  MOV     W5,1A52
046B6:  MOV     W6,1A54
046B8:  CALL    11E0
046BC:  MOV.B   W0L,14B6
.................... 		Endposition = 5420 + ActualPosition; 
046BE:  MOV     #152C,W0
046C0:  ADD     1A40,W0
046C2:  MOV     W0,149E
046C4:  MOV     1A42,W4
046C6:  MOV     #0,W3
046C8:  ADDC    W3,W4,W0
046CA:  MOV     W0,14A0
.................... 	} 
.................... 	if(Etat == 1) 
046CC:  MOV.B   14B6,W0L
046CE:  SE      W0,W0
046D0:  CP      W0,#1
046D2:  BRA     NZ,46DA
.................... 	{ 
.................... 		Etat = 0; 
046D4:  CLR.B   14B6
.................... 		read = 0; 
046D6:  BCLR.B  14B1.6
.................... 		Action_send = 1; 
046D8:  BSET.B  85B.6
.................... 	}		 
046DA:  MOV     [--W15],W6
046DC:  MOV     [--W15],W5
046DE:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Ramassage																															 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy    												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui ramasse les modules dans une fusée (1 tour complet) 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne rien											 
.................... 												 
.................... //=================================================================================================================================================================================================== 
.................... void Ramassage_1module(void) 
*
04A90:  MOV     W5,[W15++]
04A92:  MOV     W6,[W15++]
04A94:  CLR     1A40
04A96:  CLR     1A42
.................... { 
.................... 	signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	if(Etat!=1) 
04A98:  MOV.B   14B7,W0L
04A9A:  SE      W0,W0
04A9C:  CP      W0,#1
04A9E:  BRA     Z,4B10
.................... 	{ 
.................... 		if(!read) 
04AA0:  BTSC.B  14B1.7
04AA2:  BRA     4AB2
.................... 		{ 
.................... 			ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
04AA4:  MOV.B   #C0,W0L
04AA6:  MOV.B   W0L,1A4A
04AA8:  CALL    114A
04AAC:  MOV     W0,1A40
04AAE:  MOV     W1,1A42
.................... 			read = 1; 
04AB0:  BSET.B  14B1.7
.................... 		} 
.................... 		delay_ms(20); 
04AB2:  MOV     #14,W0
04AB4:  CALL    E84
.................... 		if(flag_module_fond)Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot,DRV_ARRET_POSITION_ABSOLUE,4100 + ActualPosition); 
04AB8:  BTSS.B  14A2.2
04ABA:  BRA     4AE8
04ABC:  MOV     #1004,W0
04ABE:  ADD     1A40,W0
04AC0:  MOV     W0,W5
04AC2:  MOV     #0,W0
04AC4:  ADDC    1A42,W0
04AC6:  MOV     W0,W6
04AC8:  MOV.B   #C0,W0L
04ACA:  MOV.B   W0L,1A4C
04ACC:  CLR.B   1A4D
04ACE:  MOV.B   #1,W0L
04AD0:  MOV.B   W0L,1A4E
04AD2:  MOV.B   #1,W0L
04AD4:  MOV.B   W0L,1A4F
04AD6:  PUSH    1498
04AD8:  POP     1A50
04ADA:  MOV     W5,1A52
04ADC:  MOV     W6,1A54
04ADE:  CALL    11E0
04AE2:  MOV.B   W0L,14B7
04AE4:  GOTO    4B10
.................... 		else Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot,DRV_ARRET_POSITION_ABSOLUE,4450 + ActualPosition); 
04AE8:  MOV     #1162,W0
04AEA:  ADD     1A40,W0
04AEC:  MOV     W0,W5
04AEE:  MOV     #0,W0
04AF0:  ADDC    1A42,W0
04AF2:  MOV     W0,W6
04AF4:  MOV.B   #C0,W0L
04AF6:  MOV.B   W0L,1A4C
04AF8:  CLR.B   1A4D
04AFA:  MOV.B   #1,W0L
04AFC:  MOV.B   W0L,1A4E
04AFE:  MOV.B   #1,W0L
04B00:  MOV.B   W0L,1A4F
04B02:  PUSH    1498
04B04:  POP     1A50
04B06:  MOV     W5,1A52
04B08:  MOV     W6,1A54
04B0A:  CALL    11E0
04B0E:  MOV.B   W0L,14B7
.................... 	} 
.................... 	if(Etat == 1) 
04B10:  MOV.B   14B7,W0L
04B12:  SE      W0,W0
04B14:  CP      W0,#1
04B16:  BRA     NZ,4B20
.................... 	{ 
.................... 		Etat = 0; 
04B18:  CLR.B   14B7
.................... 		read = 0; 
04B1A:  BCLR.B  14B1.7
.................... 		Action_send = 1; 
04B1C:  BSET.B  85B.6
.................... 		flag_module_fond = 0; 
04B1E:  BCLR.B  14A2.2
.................... 	}		 
04B20:  MOV     [--W15],W6
04B22:  MOV     [--W15],W5
04B24:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: Eject																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Remy   												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui coche le module 
.................... // paramètres 	:	retourne 1 quand depl envoyer 
.................... // retourne 	:  	Ne retourne rien			 
.................... //=================================================================================================================================================================================================== 
.................... int1 Ejecte(void) 
*
017DC:  CLR.B   1A44
.................... { 
.................... 	static int8 Etat_deplacement = 0; 
.................... 	static unsigned int8 Etat_driver = 0; 
.................... 	unsigned int8 Etat_dmot2  = 0; 
.................... 	 
.................... 	switch(Etat_deplacement) 
017DE:  MOV.B   14B8,W0L
017E0:  SE      W0,W0
017E2:  XOR     #0,W0
017E4:  BRA     Z,17F0
017E6:  XOR     #1,W0
017E8:  BRA     Z,1836
017EA:  XOR     #3,W0
017EC:  BRA     Z,187E
017EE:  BRA     189E
.................... 	{ 
.................... 		case 0://il faut que bras soit in 
.................... 			if(Etat_driver!=1) 
017F0:  MOV     14B8,W4
017F2:  LSR     W4,#8,W4
017F4:  CP.B    W4L,#1
017F6:  BRA     Z,1820
.................... 			{  
.................... 				Etat_driver = go_driver_moteur(0xC2,0,DRV_MODE_NON_REGUL,100,DRV_ARRET_TEMPS,180); 
017F8:  MOV.B   #C2,W0L
017FA:  MOV.B   W0L,1A4C
017FC:  CLR.B   1A4D
017FE:  MOV.B   #2,W0L
01800:  MOV.B   W0L,1A4E
01802:  MOV.B   #3,W0L
01804:  MOV.B   W0L,1A4F
01806:  MOV     #64,W4
01808:  MOV     W4,1A50
0180A:  MOV     #B4,W4
0180C:  MOV     W4,1A52
0180E:  CLR     1A54
01810:  CALL    11E0
01814:  MOV.B   W0L,14B9
.................... 				delay_ms(5); 
01816:  MOV     #5,W0
01818:  CALL    E84
.................... 			} 
0181C:  GOTO    1832
.................... 			else 
.................... 			{ 
.................... 				Etat_deplacement = 2; 
01820:  MOV.B   #2,W0L
01822:  MOV.B   W0L,14B8
.................... 				Time_ejection_toDo = 100; 
01824:  MOV     #64,W4
01826:  MOV     W4,A86
01828:  CLR     A88
.................... 				Time_ejection = GameTimeMS; 
0182A:  PUSH    86A
0182C:  POP     A82
0182E:  PUSH    86C
01830:  POP     A84
.................... 			//	return(0); 
.................... 			} 
.................... 			break; 
01832:  GOTO    189E
.................... 		case 1: 
.................... 			if(Etat_driver!=1) 
01836:  MOV     14B8,W4
01838:  LSR     W4,#8,W4
0183A:  CP.B    W4L,#1
0183C:  BRA     Z,1866
.................... 			{ 
.................... 				Etat_driver = go_driver_moteur(0xC2,0,DRV_MODE_NON_REGUL,50,DRV_ARRET_TEMPS,440); 
0183E:  MOV.B   #C2,W0L
01840:  MOV.B   W0L,1A4C
01842:  CLR.B   1A4D
01844:  MOV.B   #2,W0L
01846:  MOV.B   W0L,1A4E
01848:  MOV.B   #3,W0L
0184A:  MOV.B   W0L,1A4F
0184C:  MOV     #32,W4
0184E:  MOV     W4,1A50
01850:  MOV     #1B8,W4
01852:  MOV     W4,1A52
01854:  CLR     1A54
01856:  CALL    11E0
0185A:  MOV.B   W0L,14B9
.................... 				delay_ms(5); 
0185C:  MOV     #5,W0
0185E:  CALL    E84
.................... 			} 
01862:  GOTO    187E
.................... 			else 
.................... 			{ 
.................... 				Time_ejection_toDo = 100; 
01866:  MOV     #64,W4
01868:  MOV     W4,A86
0186A:  CLR     A88
.................... 				Time_ejection = GameTimeMS; 
0186C:  PUSH    86A
0186E:  POP     A82
01870:  PUSH    86C
01872:  POP     A84
.................... 				Etat_driver = 0; 
01874:  CLR.B   14B9
.................... 				Etat_deplacement = 0; 
01876:  CLR.B   14B8
.................... 				return(1); //bras out; attendre que ejection fini 
01878:  MOV.B   #1,W0L
0187A:  MOV.B   W0L,0
0187C:  BRA     18A0
.................... 			} 
.................... 		case 2: 
.................... 			Etat_dmot2 = __Check_action_end(0xC2);//check que le moteur est stopper 
0187E:  MOV.B   #C2,W0L
01880:  MOV.B   W0L,1A46
01882:  CALL    13F2
01886:  MOV.B   W0L,1A44
.................... 			if(Etat_dmot2 == 1) 
01888:  MOV     1A44,W4
0188A:  CP.B    W4L,#1
0188C:  BRA     NZ,189A
.................... 			{ 
.................... 				Etat_deplacement = 1;//on passe au depl suivant	 
0188E:  MOV.B   #1,W0L
01890:  MOV.B   W0L,14B8
.................... 				delay_ms(5); 
01892:  MOV     #5,W0
01894:  CALL    E84
.................... 				Etat_driver = 0 ; 
01898:  CLR.B   14B9
.................... 			} 
.................... 			break; 
0189A:  GOTO    189E
.................... 	} 
.................... 	return(0); 
0189E:  CLR.B   0
018A0:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: GoToZero																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Rémy     												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 17.3.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui place le barillet à son point zéro 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne le status du driver											 
.................... //					0-> non utilisé																 
.................... //					1-> OK : ordre transmis et terminé													 
.................... //					2-> not ready  (le slave ne répond pas)															 
.................... //					3-> Le barillet n'a pas trouvé le point zéro															 
.................... //=================================================================================================================================================================================================== 
.................... int1 __GoToZero(void) 
*
012FA:  MOV     W5,[W15++]
012FC:  MOV     W6,[W15++]
.................... { 
.................... 	static signed int32 ActualPosition = 0; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
....................  
.................... 	if(_ZeroPoint == 0 && Etat == 0) return(1); 
012FE:  BTSC.B  2C2.7
01300:  BRA     1314
01302:  MOV.B   14BE,W0L
01304:  SE      W0,W0
01306:  CP0     W0
01308:  BRA     NZ,1314
0130A:  MOV.B   #1,W0L
0130C:  MOV.B   W0L,0
0130E:  BRA     1398
01310:  GOTO    1398
.................... 	else 
.................... 	{	 
.................... 		if(Etat!=1) 
01314:  MOV.B   14BE,W0L
01316:  SE      W0,W0
01318:  CP      W0,#1
0131A:  BRA     Z,136A
.................... 		{ 
.................... 			if(!read) 
0131C:  BTSC.B  14BF.0
0131E:  BRA     1334
.................... 			{ 
.................... 				ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
01320:  MOV.B   #C0,W0L
01322:  MOV.B   W0L,1A4A
01324:  CALL    114A
01328:  MOV     W0,14BA
0132A:  MOV     W1,14BC
.................... 				delay_ms(20); 
0132C:  MOV     #14,W0
0132E:  CALL    E84
.................... 				read = 1; 
01332:  BSET.B  14BF.0
.................... 			}		 
.................... 			Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_rot_zero,DRV_ARRET_POSITION_ABSOLUE,(5400 + ActualPosition));	 
01334:  MOV     #1518,W0
01336:  ADD     14BA,W0
01338:  MOV     W0,W5
0133A:  MOV     #0,W0
0133C:  ADDC    14BC,W0
0133E:  MOV     W0,W6
01340:  MOV.B   #C0,W0L
01342:  MOV.B   W0L,1A4C
01344:  CLR.B   1A4D
01346:  MOV.B   #1,W0L
01348:  MOV.B   W0L,1A4E
0134A:  MOV.B   #1,W0L
0134C:  MOV.B   W0L,1A4F
0134E:  PUSH    149A
01350:  POP     1A50
01352:  MOV     W5,1A52
01354:  MOV     W6,1A54
01356:  CALL    11E0
0135A:  MOV.B   W0L,14BE
.................... 			delay_ms(20); 
0135C:  MOV     #14,W0
0135E:  CALL    E84
.................... 			return(0); 
01362:  CLR.B   0
01364:  BRA     1398
.................... 		} 
01366:  GOTO    1398
.................... 		else 
.................... 		{ 
.................... 			if(!_ZeroPoint) 
0136A:  BTSC.B  2C2.7
0136C:  BRA     1394
.................... 			{ 
.................... 				Etat = 0; 
0136E:  CLR.B   14BE
.................... 				read = 0; 
01370:  BCLR.B  14BF.0
.................... 				driver_moteur(0xC0,0); //arrêt du driver 
01372:  MOV.B   #C0,W0L
01374:  MOV.B   W0L,1A4A
01376:  CLR.B   1A4B
01378:  CALL    12A0
.................... 				if(obj_Action==8)Action_send = 0; 
0137C:  MOV     13BE,W4
0137E:  CP      W4,#8
01380:  BRA     NZ,1388
01382:  BCLR.B  85B.6
01384:  GOTO    138A
.................... 				else Action_send=1; 
01388:  BSET.B  85B.6
.................... 				return(1); 
0138A:  MOV.B   #1,W0L
0138C:  MOV.B   W0L,0
0138E:  BRA     1398
.................... 			} 
01390:  GOTO    1398
.................... 			else return(0); 
01394:  CLR.B   0
01396:  BRA     1398
.................... 		} 
.................... 	} 
01398:  MOV     [--W15],W6
0139A:  MOV     [--W15],W5
0139C:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: __Check_action_end																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Borgeat Remy   
.................... //						:   												 
.................... //  Date				: 28.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui check l'etat du driver moteur 
.................... // 				: 	En cas de surcharge ou driver pas connecte --> on affiche l'erreur 
.................... //				: 	En cas de surchauffe --> on attend 1s pour renvoyer l'ordre 
.................... // paramètres 	:	Addresse du driver 
.................... // retourne 	:	1 -> ordre fini, 0 -> ordre en cours ou erreur	 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Check_action_end(unsigned int8 driver_address) 
*
013F2:  MOV     W5,[W15++]
013F4:  MOV     W6,[W15++]
013F6:  CLR     1A48
.................... { 
.................... 	static unsigned int32 Time_ms = 0; 
.................... 	static signed int16 impulses_toDo = 0; 
.................... 	signed int16 ActualPosition = 0; 
.................... 	static unsigned int8 passage_erreur = 0; 
.................... 	static unsigned int8 Etat_d = 1; 
.................... 	static unsigned int1 ok = 0; 
.................... 	static unsigned int8 Etat = 0; 
.................... 	static unsigned int1 read = 0; 
.................... 	static unsigned int8 Etat_driver = 0; 
.................... 	Etat_d = read_driver_moteur(driver_address); 
013F8:  MOV.B   1A46,W0L
013FA:  MOV.B   W0L,1A54
013FC:  CALL    10FA
01400:  MOV.B   W0L,14C7
.................... 	delay_ms(20); 
01402:  MOV     #14,W0
01404:  CALL    E84
....................  
.................... 	switch(Etat_d) 
01408:  MOV.B   14C7,W0L
0140A:  CLR.B   1
0140C:  XOR     #0,W0
0140E:  BRA     Z,1426
01410:  XOR     #1,W0
01412:  BRA     Z,1436
01414:  XOR     #3,W0
01416:  BRA     Z,1476
01418:  XOR     #1,W0
0141A:  BRA     Z,1580
0141C:  XOR     #7,W0
0141E:  BRA     Z,1758
01420:  XOR     #1,W0
01422:  BRA     Z,1798
01424:  BRA     17D6
.................... 	{ 
.................... 		case 0:  
.................... 			Erreur_max_surchauffe = 0; 
01426:  CLR.B   87F
.................... 			Time_ms = 0; 
01428:  CLR     14C0
0142A:  CLR     14C2
.................... 			return(1); //driver arreter --> ordre fini  
0142C:  MOV.B   #1,W0L
0142E:  MOV.B   W0L,0
01430:  BRA     17D6
.................... 			break;	 
01432:  GOTO    17D6
.................... 			 
.................... 		case 1:	//en cours 
.................... 			 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(10); 
01436:  MOV     1A46,W4
01438:  XOR.B   #C0,W4L
0143A:  BRA     NZ,144A
0143C:  MOV.B   #A,W0L
0143E:  MOV.B   W0L,1A4A
01440:  CLR.B   1A4B
01442:  CALL    139E
01446:  GOTO    146E
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(11); 
0144A:  MOV     1A46,W4
0144C:  XOR.B   #C2,W4L
0144E:  BRA     NZ,145E
01450:  MOV.B   #B,W0L
01452:  MOV.B   W0L,1A4A
01454:  CLR.B   1A4B
01456:  CALL    139E
0145A:  GOTO    146E
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(12); 
0145E:  MOV     1A46,W4
01460:  XOR.B   #C4,W4L
01462:  BRA     NZ,146E
01464:  MOV.B   #C,W0L
01466:  MOV.B   W0L,1A4A
01468:  CLR.B   1A4B
0146A:  CALL    139E
....................  
.................... 			return(0);//driver en mouvement, ou en erreur --> on renvoie 0	 
0146E:  CLR.B   0
01470:  BRA     17D6
.................... 			break; 
01472:  GOTO    17D6
.................... 					 
.................... 		case 2: // surcharge on tire plus de courant que le maximum configure 
.................... 	 
.................... 			if(driver_address==0xC0) 
01476:  MOV     1A46,W4
01478:  XOR.B   #C0,W4L
0147A:  BRA     NZ,1556
.................... 			{ 
.................... 				while(!ok) 
0147C:  BTSC.B  14BF.1
0147E:  BRA     1552
.................... 				{ 
.................... 					switch(Etat) 
01480:  MOV.B   14C8,W0L
01482:  CLR.B   1
01484:  XOR     #0,W0
01486:  BRA     Z,148E
01488:  XOR     #1,W0
0148A:  BRA     Z,14E8
0148C:  BRA     154E
.................... 					{ 
.................... 						case 0: 
.................... 							if(!read) 
0148E:  BTSC.B  14BF.2
01490:  BRA     14A8
.................... 							{ 
.................... 								driver_moteur(0xC0,0); 
01492:  MOV.B   #C0,W0L
01494:  MOV.B   W0L,1A4A
01496:  CLR.B   1A4B
01498:  CALL    12A0
.................... 								ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
0149C:  MOV.B   #C0,W0L
0149E:  MOV.B   W0L,1A4A
014A0:  CALL    114A
014A4:  MOV     W0,1A48
.................... 								read = 1; 
014A6:  BSET.B  14BF.2
.................... 							} 
.................... 							if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
014A8:  MOV     14C8,W4
014AA:  LSR     W4,#8,W4
014AC:  CP.B    W4L,#1
014AE:  BRA     Z,14DE
.................... 							{ 
.................... 								Etat_driver = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition-250)); 
014B0:  MOV     1A48,W4
014B2:  SUB     #FA,W4
014B4:  MOV     W4,W5
014B6:  MOV.B   #C0,W0L
014B8:  MOV.B   W0L,1A4C
014BA:  MOV.B   #1,W0L
014BC:  MOV.B   W0L,1A4D
014BE:  MOV.B   #1,W0L
014C0:  MOV.B   W0L,1A4E
014C2:  MOV.B   #1,W0L
014C4:  MOV.B   W0L,1A4F
014C6:  PUSH    149C
014C8:  POP     1A50
014CA:  MOV     W5,1A52
014CC:  CLR     W4
014CE:  BTSC.B  1A53.7
014D0:  SETM    W4
014D2:  MOV     W4,1A54
014D4:  CALL    11E0
014D8:  MOV.B   W0L,14C9
.................... 							} 
014DA:  GOTO    14E4
.................... 							else 
.................... 							{ 
.................... 								Etat_driver = 0; 
014DE:  CLR.B   14C9
.................... 								Etat++; // passe au depl suivant 
014E0:  INC.B   14C8
.................... 								read = 0; 
014E2:  BCLR.B  14BF.2
.................... 							} 
.................... 							break; 
014E4:  GOTO    154E
.................... 						case 1://retourne a la postion  
.................... 							Etat_d = read_driver_moteur(0xC0); 
014E8:  MOV.B   #C0,W0L
014EA:  MOV.B   W0L,1A54
014EC:  CALL    10FA
014F0:  MOV.B   W0L,14C7
.................... 							if(Etat_d == 0) 
014F2:  CP0.B   14C7
014F4:  BRA     NZ,154A
.................... 							{ 
.................... 								if(!read) 
014F6:  BTSC.B  14BF.2
014F8:  BRA     1514
.................... 								{ 
.................... 									ActualPosition = ActualPosition - 250; 
014FA:  MOV     1A48,W4
014FC:  SUB     #FA,W4
014FE:  MOV     W4,1A48
.................... 									impulses_toDo = EndPosition - ActualPosition ; 
01500:  MOV     1A48,W0
01502:  CLR     W1
01504:  BTSC    W0.F
01506:  SETM    W1
01508:  MOV     149E,W4
0150A:  SUB     W4,W0,W0
0150C:  MOV     14A0,W4
0150E:  SUBB    W4,W1,W1
01510:  MOV     W0,14C4
.................... 									read = 1;   
01512:  BSET.B  14BF.2
.................... 								} 
.................... 								if(Etat_driver!=1) 
01514:  MOV     14C8,W4
01516:  LSR     W4,#8,W4
01518:  CP.B    W4L,#1
0151A:  BRA     Z,1548
.................... 								{ 
.................... 									Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition + impulses_toDo)); 
0151C:  MOV     1A48,W0
0151E:  ADD     14C4,W0
01520:  MOV     W0,W5
01522:  MOV.B   #C0,W0L
01524:  MOV.B   W0L,1A4C
01526:  CLR.B   1A4D
01528:  MOV.B   #1,W0L
0152A:  MOV.B   W0L,1A4E
0152C:  MOV.B   #1,W0L
0152E:  MOV.B   W0L,1A4F
01530:  PUSH    149C
01532:  POP     1A50
01534:  MOV     W5,1A52
01536:  CLR     W4
01538:  BTSC.B  1A53.7
0153A:  SETM    W4
0153C:  MOV     W4,1A54
0153E:  CALL    11E0
01542:  MOV.B   W0L,14C9
.................... 									 
.................... 								} 
01544:  GOTO    154A
.................... 								else 
.................... 								{ 
.................... 									ok = 1;  
01548:  BSET.B  14BF.1
.................... 								} 
.................... 							}								 
.................... 							break; 
0154A:  GOTO    154E
.................... 					} 
0154E:  GOTO    147C
.................... 					} 
.................... 			} 
01552:  GOTO    1576
.................... 			else if(driver_address==0xC2) __Affichage_erreur(11); // surcharge ejection 
01556:  MOV     1A46,W4
01558:  XOR.B   #C2,W4L
0155A:  BRA     NZ,1568
0155C:  MOV.B   #B,W0L
0155E:  MOV.B   W0L,1A4A
01560:  CALL    1002
01564:  GOTO    1576
.................... 			else if(driver_address==0xC4) __Affichage_erreur(12); // surcharge cremaillere		 
01568:  MOV     1A46,W4
0156A:  XOR.B   #C4,W4L
0156C:  BRA     NZ,1576
0156E:  MOV.B   #C,W0L
01570:  MOV.B   W0L,1A4A
01572:  CALL    1002
.................... 			ok = 0; 
01576:  BCLR.B  14BF.1
.................... 			return(0); 
01578:  CLR.B   0
0157A:  BRA     17D6
.................... 			break; 
0157C:  GOTO    17D6
.................... 			 
.................... 		case 3: // surchauffe pont-h 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(16); 
01580:  MOV     1A46,W4
01582:  XOR.B   #C0,W4L
01584:  BRA     NZ,1594
01586:  MOV.B   #10,W0L
01588:  MOV.B   W0L,1A4A
0158A:  CLR.B   1A4B
0158C:  CALL    139E
01590:  GOTO    15B8
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(17); 
01594:  MOV     1A46,W4
01596:  XOR.B   #C2,W4L
01598:  BRA     NZ,15A8
0159A:  MOV.B   #11,W0L
0159C:  MOV.B   W0L,1A4A
0159E:  CLR.B   1A4B
015A0:  CALL    139E
015A4:  GOTO    15B8
.................... 			else if(driver_address==0xC4) __Afficheur_7segments(18); 
015A8:  MOV     1A46,W4
015AA:  XOR.B   #C4,W4L
015AC:  BRA     NZ,15B8
015AE:  MOV.B   #12,W0L
015B0:  MOV.B   W0L,1A4A
015B2:  CLR.B   1A4B
015B4:  CALL    139E
.................... 			 
.................... 			if(Time_ms==0)Time_ms = GameTimeMS; 
015B8:  CP0     14C0
015BA:  BRA     NZ,15CC
015BC:  CP0     14C2
015BE:  BRA     NZ,15CC
015C0:  PUSH    86A
015C2:  POP     14C0
015C4:  PUSH    86C
015C6:  POP     14C2
015C8:  GOTO    1750
.................... 			else if(GameTimeMS - Time_ms >= TIME_SURCHAUFFE_MS)//on attend 1s 
015CC:  MOV     86A,W4
015CE:  MOV     14C0,W3
015D0:  SUB     W4,W3,W5
015D2:  MOV     86C,W4
015D4:  MOV     14C2,W3
015D6:  SUBB    W4,W3,W6
015D8:  CP      W6,#0
015DA:  BRA     NC,1750
015DC:  BRA     GTU,15E4
015DE:  MOV     A80,W4
015E0:  CP      W4,W5
015E2:  BRA     GTU,1750
.................... 			{ 
.................... 				Time_ms = 0; 
015E4:  CLR     14C0
015E6:  CLR     14C2
.................... 				 
.................... 				if(driver_address == 0xC0)//moteur barillet 
015E8:  MOV     1A46,W4
015EA:  XOR.B   #C0,W4L
015EC:  BRA     NZ,1648
.................... 				{ 
.................... 					ActualPosition = read_pos_moteur(0xC0); //on reprend l'ordre 
015EE:  MOV.B   #C0,W0L
015F0:  MOV.B   W0L,1A4A
015F2:  CALL    114A
015F6:  MOV     W0,1A48
.................... 					if((ActualPosition-EndPosition)!= 0) 
015F8:  MOV     1A48,W0
015FA:  CLR     W1
015FC:  BTSC    W0.F
015FE:  SETM    W1
01600:  MOV     149E,W4
01602:  SUB     W0,W4,W5
01604:  MOV     14A0,W4
01606:  SUBB    W1,W4,W6
01608:  CP0     W5
0160A:  BRA     NZ,1610
0160C:  CP0     W6
0160E:  BRA     Z,1644
.................... 					{ 
.................... 						impulses_toDo = EndPosition - ActualPosition ;  
01610:  MOV     1A48,W0
01612:  CLR     W1
01614:  BTSC    W0.F
01616:  SETM    W1
01618:  MOV     149E,W4
0161A:  SUB     W4,W0,W0
0161C:  MOV     14A0,W4
0161E:  SUBB    W4,W1,W1
01620:  MOV     W0,14C4
.................... 						go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,impulses_toDo); 
01622:  MOV.B   #C0,W0L
01624:  MOV.B   W0L,1A4C
01626:  CLR.B   1A4D
01628:  MOV.B   #1,W0L
0162A:  MOV.B   W0L,1A4E
0162C:  MOV.B   #1,W0L
0162E:  MOV.B   W0L,1A4F
01630:  PUSH    149C
01632:  POP     1A50
01634:  PUSH    14C4
01636:  POP     1A52
01638:  CLR     W4
0163A:  BTSC.B  1A53.7
0163C:  SETM    W4
0163E:  MOV     W4,1A54
01640:  CALL    11E0
.................... 					} 
.................... 				} 
01644:  GOTO    1714
.................... 				else if(driver_address == 0xC2)//moteur qui couche les modules 
01648:  MOV     1A46,W4
0164A:  XOR.B   #C2,W4L
0164C:  BRA     NZ,16D0
.................... 				{ 
.................... 					if((GameTimeMS-Time_ejection)<Time_ejection_toDo) 
0164E:  MOV     86A,W4
01650:  MOV     A82,W3
01652:  SUB     W4,W3,W5
01654:  MOV     86C,W4
01656:  MOV     A84,W3
01658:  SUBB    W4,W3,W6
0165A:  MOV     A88,W4
0165C:  CP      W4,W6
0165E:  BRA     NC,16CC
01660:  BRA     GTU,1668
01662:  MOV     A86,W4
01664:  CP      W4,W5
01666:  BRA     LEU,16CC
.................... 					{ 
.................... 						Time_ejection_toDo = Time_ejection_toDo - (GameTimeMS-Time_ejection); //calcul du temps qu'il reste a faire 
01668:  MOV     86A,W4
0166A:  MOV     A82,W3
0166C:  SUB     W4,W3,W0
0166E:  MOV     86C,W4
01670:  MOV     A84,W3
01672:  SUBB    W4,W3,W1
01674:  MOV     A86,W4
01676:  SUB     W4,W0,W0
01678:  MOV     W0,A86
0167A:  MOV     A88,W4
0167C:  SUBB    W4,W1,W0
0167E:  MOV     W0,A88
.................... 						//renvoi de la suite de l'ordre 
.................... 						if(Etat_ejection == 1) go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,100,DRV_ARRET_TEMPS, Time_ejection_toDo);						 
01680:  MOV     13D0,W4
01682:  LSR     W4,#8,W4
01684:  CP.B    W4L,#1
01686:  BRA     NZ,16AC
01688:  MOV.B   #C2,W0L
0168A:  MOV.B   W0L,1A4C
0168C:  MOV.B   #1,W0L
0168E:  MOV.B   W0L,1A4D
01690:  MOV.B   #2,W0L
01692:  MOV.B   W0L,1A4E
01694:  MOV.B   #3,W0L
01696:  MOV.B   W0L,1A4F
01698:  MOV     #64,W4
0169A:  MOV     W4,1A50
0169C:  PUSH    A86
0169E:  POP     1A52
016A0:  PUSH    A88
016A2:  POP     1A54
016A4:  CALL    11E0
016A8:  GOTO    16CC
.................... 						else go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,25,DRV_ARRET_TEMPS,Time_ejection_toDo); 
016AC:  MOV.B   #C2,W0L
016AE:  MOV.B   W0L,1A4C
016B0:  MOV.B   #1,W0L
016B2:  MOV.B   W0L,1A4D
016B4:  MOV.B   #2,W0L
016B6:  MOV.B   W0L,1A4E
016B8:  MOV.B   #3,W0L
016BA:  MOV.B   W0L,1A4F
016BC:  MOV     #19,W4
016BE:  MOV     W4,1A50
016C0:  PUSH    A86
016C2:  POP     1A52
016C4:  PUSH    A88
016C6:  POP     1A54
016C8:  CALL    11E0
.................... 					}	 
.................... 				} 
016CC:  GOTO    1714
.................... 				else if(driver_address == 0xC4) 
016D0:  MOV     1A46,W4
016D2:  XOR.B   #C4,W4L
016D4:  BRA     NZ,1714
.................... 				{ 
.................... 					if(bras_out)go_driver_moteur(0xC4,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200); // rentre le bras 
016D6:  BTSS.B  14A2.0
016D8:  BRA     16F8
016DA:  MOV.B   #C4,W0L
016DC:  MOV.B   W0L,1A4C
016DE:  CLR.B   1A4D
016E0:  MOV.B   #2,W0L
016E2:  MOV.B   W0L,1A4E
016E4:  CLR.B   1A4F
016E6:  MOV     #64,W4
016E8:  MOV     W4,1A50
016EA:  MOV     #C8,W4
016EC:  MOV     W4,1A52
016EE:  CLR     1A54
016F0:  CALL    11E0
016F4:  GOTO    1714
.................... 					else go_driver_moteur(0xC4,1,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200);	   // sort le bras		 
016F8:  MOV.B   #C4,W0L
016FA:  MOV.B   W0L,1A4C
016FC:  MOV.B   #1,W0L
016FE:  MOV.B   W0L,1A4D
01700:  MOV.B   #2,W0L
01702:  MOV.B   W0L,1A4E
01704:  CLR.B   1A4F
01706:  MOV     #64,W4
01708:  MOV     W4,1A50
0170A:  MOV     #C8,W4
0170C:  MOV     W4,1A52
0170E:  CLR     1A54
01710:  CALL    11E0
.................... 				} 
.................... 				passage_erreur++; 
01714:  INC.B   14C6
.................... 				if(passage_erreur > Erreur_max_surchauffe)// si on a 10 erreurs a la suite de surchauffe 
01716:  MOV.B   87F,W0L
01718:  MOV     14C6,W4
0171A:  CP.B    W4L,W0L
0171C:  BRA     LEU,1750
.................... 				{ 
.................... 					if(driver_address == 0xC0)    __Affichage_erreur(13); //surcahuffe driver barrilet 
0171E:  MOV     1A46,W4
01720:  XOR.B   #C0,W4L
01722:  BRA     NZ,1730
01724:  MOV.B   #D,W0L
01726:  MOV.B   W0L,1A4A
01728:  CALL    1002
0172C:  GOTO    1750
.................... 					else if(driver_address==0xC2) __Affichage_erreur(14); //surchauffe driver ejection 
01730:  MOV     1A46,W4
01732:  XOR.B   #C2,W4L
01734:  BRA     NZ,1742
01736:  MOV.B   #E,W0L
01738:  MOV.B   W0L,1A4A
0173A:  CALL    1002
0173E:  GOTO    1750
.................... 					else if(driver_address==0xC4) __Affichage_erreur(15); //surchauffe driver cremaillere	 
01742:  MOV     1A46,W4
01744:  XOR.B   #C4,W4L
01746:  BRA     NZ,1750
01748:  MOV.B   #F,W0L
0174A:  MOV.B   W0L,1A4A
0174C:  CALL    1002
.................... 				} 
.................... 				 
.................... 			} 	 
.................... 			return(0);						 
01750:  CLR.B   0
01752:  BRA     17D6
.................... 			break; 
01754:  GOTO    17D6
.................... 		case 4://processing 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(13); 
01758:  MOV     1A46,W4
0175A:  XOR.B   #C0,W4L
0175C:  BRA     NZ,176C
0175E:  MOV.B   #D,W0L
01760:  MOV.B   W0L,1A4A
01762:  CLR.B   1A4B
01764:  CALL    139E
01768:  GOTO    1790
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(14); 
0176C:  MOV     1A46,W4
0176E:  XOR.B   #C2,W4L
01770:  BRA     NZ,1780
01772:  MOV.B   #E,W0L
01774:  MOV.B   W0L,1A4A
01776:  CLR.B   1A4B
01778:  CALL    139E
0177C:  GOTO    1790
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(15); 
01780:  MOV     1A46,W4
01782:  XOR.B   #C4,W4L
01784:  BRA     NZ,1790
01786:  MOV.B   #F,W0L
01788:  MOV.B   W0L,1A4A
0178A:  CLR.B   1A4B
0178C:  CALL    139E
.................... 			return(0);  
01790:  CLR.B   0
01792:  BRA     17D6
.................... 			break;  
01794:  GOTO    17D6
.................... 		case 5://slave ne repond pas 
.................... 			if(driver_address == 0xC0)    __Affichage_erreur(16); //driver barillet ne repond pas 
01798:  MOV     1A46,W4
0179A:  XOR.B   #C0,W4L
0179C:  BRA     NZ,17AA
0179E:  MOV.B   #10,W0L
017A0:  MOV.B   W0L,1A4A
017A2:  CALL    1002
017A6:  GOTO    17CE
.................... 			else if(driver_address==0xC2) __Affichage_erreur(17); //driver ejection ne repond pas 
017AA:  MOV     1A46,W4
017AC:  XOR.B   #C2,W4L
017AE:  BRA     NZ,17BC
017B0:  MOV.B   #11,W0L
017B2:  MOV.B   W0L,1A4A
017B4:  CALL    1002
017B8:  GOTO    17CE
.................... 			else if(driver_address==0xC4) __Affichage_erreur(18); //driver cremaillere ne repond pas			 
017BC:  MOV     1A46,W4
017BE:  XOR.B   #C4,W4L
017C0:  BRA     NZ,17CE
017C2:  MOV.B   #12,W0L
017C4:  MOV.B   W0L,1A4A
017C6:  CALL    1002
017CA:  GOTO    17CE
.................... 			else ;//__Affichage_erreur();	 
.................... 			return(0);			 
017CE:  CLR.B   0
017D0:  BRA     17D6
.................... 			break; 
017D2:  GOTO    17D6
.................... 	} 
017D6:  MOV     [--W15],W6
017D8:  MOV     [--W15],W5
017DA:  RETURN  
.................... } 
.................... /* 
....................  
.................... // Demande une information à un module IIC 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr) 
.................... { 
.................... 	// Ack et données 
.................... 	unsigned int8 Ack=1,Data=0,i=0; 
.................... 	Adr++; 
.................... 	 
.................... 	// Demande 
.................... 	while(Ack!=0 && i!=IIC_NBR_REP_NAK) 
.................... 	{ 
.................... 		i2c_start(); 
.................... 		Ack=i2c_write(Adr); 
.................... 		if(Ack==0) 
.................... 		{	 
.................... 			// Si module détecté, demande de lecture 
.................... 			Data=i2c_read(0); 
.................... 		} 
.................... 		i2c_stop(); 
.................... 		i++; 
.................... 	} 
.................... //	if(i==IIC_NBR_REP_NAK&&Ack!=0)__Affichage_Erreur(7); 
.................... 	 
.................... 	return Data; 
.................... }		 
....................  
.................... // Envoi une trame IIC traitée 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend) 
.................... { 
.................... 	// Pour l'envoi 
.................... 	unsigned int8 i=0,j=0; 
.................... 	// Ack 
.................... 	unsigned int8 Ack=1;	 
.................... 	 
.................... 	if(UseIICProtocol) 
.................... 	{ 
.................... 		// Pour l'encodage 
.................... 		unsigned int8 Hash1=2*0x20+Adr,Hash2=0x20; 
.................... 		// Ajout de l'adresse 
.................... 		Hash2=(Hash2+Adr)*2; 
.................... 		Hash2=(Hash2+0x20)*3; 
.................... 		 
.................... 		//Encode 
.................... 		while(TabToSend[i]!=NUL) 
.................... 		{ 
.................... 			Hash1=(Hash1+TabToSend[i]); 
.................... 			Hash2=(Hash2+TabToSend[i])*(i+4); 
.................... 			i++; 
.................... 		}	 
.................... 			// Ajoute l'espace traité en plus 
.................... 		Hash1+=SPACE; 
.................... 		Hash2=(Hash2+SPACE)*(i+4); //(i+2); 
.................... 			// Empêche que soit égal à ETX 
.................... 		if(Hash1==ETX||Hash1==CR)Hash1++; 
.................... 		if(Hash2==ETX||Hash2==CR)Hash2++; 
.................... 		 
.................... 		// Envoie 
.................... 		while(j!=IIC_NBR_REP_ENV && Ack!=0) 
.................... 		{ 
.................... 			i=0; 
.................... 			i2c_start(); 
.................... 			Ack=i2c_write(Adr); 
.................... 			if(Ack==0) 
.................... 			{ 
.................... 				i2c_write(0x02); 
.................... 				i2c_write(SPACE); 
.................... 				i2c_write(Hash1); 
.................... 				i2c_write(SPACE); 
.................... 				i2c_write(Hash2); 
.................... 				i2c_write(SPACE); 
.................... 				i2c_write(Adr); 
.................... 				i2c_write(SPACE); 
.................... 				while(TabToSend[i]!=NUL) 
.................... 				{ 
.................... 					i2c_write(TabToSend[i]); 
.................... 					i++; 
.................... 				}	 
.................... 				i2c_write(SPACE); 
.................... 				i2c_write(0x03); 
.................... 			}	 
.................... 			i2c_stop(); 
.................... 			j++; 
.................... 		} 
.................... 	//	if(j==IIC_NBR_REP_ENV&&Ack!=0)__Affichage_Erreur(6); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		// Envoie 
.................... 		while(j!=IIC_NBR_REP_ENV && Ack!=0) 
.................... 		{ 
.................... 			i=0; 
.................... 			i2c_start(); 
.................... 			Ack=i2c_write(Adr); 
.................... 			if(Ack==0) 
.................... 			{ 
.................... 				while(TabToSend[i]!=NUL) 
.................... 				{ 
.................... 					i2c_write(TabToSend[i]); 
.................... 					i++; 
.................... 				} 
.................... 				i2c_write(SPACE); 
.................... 				i2c_write(0x03);	 
.................... 			}	 
.................... 			i2c_stop(); 
.................... 			j++; 
.................... 		} 
.................... 	//	if(j==IIC_NBR_REP_ENV&&Ack!=0)__Affichage_Erreur(6);		 
.................... 	} 
.................... 		 
.................... 	// Quitte la fonction 
.................... 	return Ack; 
.................... }*/ 
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Deplacement/___Depl.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl 
.................... #define ___Depl 
....................  
....................  
.................... /////////////////  Deplacement Progress  //////////////////////////////// 
.................... float64 amp_limit = 1.6;				 // limite de courant depl progress 
.................... unsigned int16 DIST_SECU_PROGRESS = 100; // distance de secu sur le deplacement progress en mm 
.................... 	 
.................... /////////////////  Localisation  //////////////////////////////// 
.................... signed int16 Dist_x,Dist_y=0; 
.................... signed int16 Pos_x = 0; //en mm 
.................... signed int16 Pos_y = 0;//en mm 
.................... signed int16 Orient_deg = 0; 
.................... float64 Dorient = 0;  
.................... float64 Orient = 0; 
.................... float64 DIAM_ENCO = 3.48139;	// Diamètre des encodeurs, en [cm] 
.................... float64 IMPULSES_ENCO = 5000;	// Nombre d'impulsions de l'encodeur (sans compter le x4 du QEI) 
.................... float64 ENTRAXE_ROUESFOLLES = 29.51922;//31.6006	// Entraxe entre les deux centres des roues folles, en [cm] 
....................  
.................... ///////////////// Calcul //////////////////////////////////////// 
.................... float64 COEFF_D	= (float64) (IMPULSES_ENCO*4)/(DIAM_ENCO*PI);	// Nbre de pas pour 1 [cm] 
.................... float64 CONV_DEG_RAD = (float64) (PI / 180); 
....................  
.................... ////////////////////// Gestion de la reception //////////////////////////////////// 
.................... unsigned int8 RoboteQ_receiveToProceed = 0;	// Position maximale pour la rÃ©ception 
.................... unsigned int8 RoboteQ_receiveLenght = 0;	// Longeur totale de la donnÃ©e 
.................... signed int32 Dist_Do = 0; 
....................  
.................... ///////////////////// Impulsions ////////////////////////////////////////////////// 
.................... signed int32 value_enco_g_start = 0;		//valeur enco debut deplacment 
.................... signed int32 value_enco_d_start = 0;		//valeur enco debut deplacement 
.................... signed int32 value_enco_g_end = 0;			//valeur enco fin deplacment 
.................... signed int32 value_enco_d_end = 0;			//valeur enco fin deplacement	 
....................  
....................  
.................... /////////////////  Prototype fct  //////////////////////////////// 
.................... void __DeplToDo(unsigned int8 _Command);	// 0--> turn, 1--> PaP, 2--> progress, 4-->nothing 
.................... void __Turn(signed int16 _Ang);				 
.................... void __PaP(int16 _X, int16 _Y); 
.................... void __Progress(int16 _X, int16 _Y); 
.................... void __Nothing(void); 
.................... float64 __Get_amp(int channel); 
.................... void __Init_pos(void); 
.................... void __LoadObj(unsigned int16 _Obj); // Charge les différents paramètres des objectifs selon lequel est sélectionné 
.................... float64 __Conv_Ang_4Quadr(float64 _Ang); // Convertit un angle selon le cadran de l'objectif. 
.................... void __Get_enco_value(int1 start_end); 
....................  
.................... #include "Deplacement/___Depl.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl_c 
.................... #define ___Depl_c 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Check_commande_atteint 
.................... //	Auteur :	BORREM 
.................... //	Date:	    18.2.15 
.................... //  Statut :    fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Check si la commande donnÃ© aux moteurs a Ã©tÃ© finie 
.................... void __Check_commande_atteint(void) 
*
02F38:  MOV     W5,[W15++]
02F3A:  MOV     W6,[W15++]
02F3C:  BCLR.B  1A7C.1
.................... { 
.................... 	int1 comm_atteinte_m1,comm_atteinte_m2 = 0; 
.................... 	fprintf(ROBOTEQ,"?DR\r"); 
02F3E:  MOV     #0,W1
02F40:  MOV     W1,W0
02F42:  CLR.B   1
02F44:  CALL    27E
02F48:  INC     W1,W1
02F4A:  BTSC.B  219.1
02F4C:  BRA     2F4A
02F4E:  MOV     W0,21A
02F50:  MOV     #3,W0
02F52:  CPSGT   W1,W0
02F54:  BRA     2F40
.................... //il renvoie DR=x:x 
.................... 	delay_ms(20); 
02F56:  MOV     #14,W0
02F58:  CALL    E84
.................... //on vÃ©rifie que le premier caractÃ¨re n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] != '!' && RoboteQ_receiveBuffer[0] != '?' && RoboteQ_receiveBuffer[0] != '~' && RoboteQ_receiveBuffer[0] != '^' && RoboteQ_receiveBuffer[0] != '#') 
02F5C:  MOV     880,W4
02F5E:  XOR.B   #21,W4L
02F60:  BRA     Z,2F86
02F62:  MOV     880,W4
02F64:  XOR.B   #3F,W4L
02F66:  BRA     Z,2F86
02F68:  MOV     880,W4
02F6A:  XOR.B   #7E,W4L
02F6C:  BRA     Z,2F86
02F6E:  MOV     880,W4
02F70:  XOR.B   #5E,W4L
02F72:  BRA     Z,2F86
02F74:  MOV     880,W4
02F76:  XOR.B   #23,W4L
02F78:  BRA     Z,2F86
.................... 	{ 
.................... 		comm_atteinte_m1 = RoboteQ_receiveBuffer[3]; // affectation du premier x dans la variable 
02F7A:  BCLR.B  1A7C.0
02F7C:  BTSC.B  883.0
02F7E:  BSET.B  1A7C.0
.................... 		comm_atteinte_m2 = RoboteQ_receiveBuffer[5]; // affectation du deuxiÃ¨me x dans la variable 
02F80:  BCLR.B  1A7C.1
02F82:  BTSC.B  885.0
02F84:  BSET.B  1A7C.1
.................... 	} 
.................... 	if(comm_atteinte_m1 == 1 && comm_atteinte_m2== 1) // si commande des deux moteurs dini  
02F86:  BTSS.B  1A7C.0
02F88:  BRA     2F90
02F8A:  BTSS.B  1A7C.1
02F8C:  BRA     2F90
.................... 	{ 
.................... 		flag_depl_ok =1 ; // on peut passer au dÃ©placement suivant 
02F8E:  BSET.B  85A.6
.................... 	} 
02F90:  MOV     [--W15],W6
02F92:  MOV     [--W15],W5
02F94:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_amp(int channel) 
.................... * \brief Recupere la valeur du courant dans les moteurs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] channel--> 1 moteur 1, 2  moteur 2  
.................... * \return Ne retourne rien 
.................... */ 
.................... float64 __Get_amp(int channel) 
*
03E92:  MOV     W5,[W15++]
03E94:  MOV     W6,[W15++]
03E96:  CLR     1A60
03E98:  MOV.B   #2,W0L
03E9A:  MOV.B   W0L,1A5E
.................... { 
.................... 	unsigned int16 ampere = 0; 
.................... 	unsigned int8 i = 2; 
.................... 	if(channel == 1) 
03E9C:  MOV     1A5C,W4
03E9E:  CP      W4,#1
03EA0:  BRA     NZ,3EBE
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 1\r"); 
03EA2:  MOV     #0,W1
03EA4:  MOV     W1,W0
03EA6:  CLR.B   1
03EA8:  CALL    290
03EAC:  INC     W1,W1
03EAE:  BTSC.B  219.1
03EB0:  BRA     3EAE
03EB2:  MOV     W0,21A
03EB4:  MOV     #4,W0
03EB6:  CPSGT   W1,W0
03EB8:  BRA     3EA4
.................... 	} 
03EBA:  GOTO    3ED6
.................... 	else 
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 2\r"); 
03EBE:  MOV     #0,W1
03EC0:  MOV     W1,W0
03EC2:  CLR.B   1
03EC4:  CALL    2A2
03EC8:  INC     W1,W1
03ECA:  BTSC.B  219.1
03ECC:  BRA     3ECA
03ECE:  MOV     W0,21A
03ED0:  MOV     #4,W0
03ED2:  CPSGT   W1,W0
03ED4:  BRA     3EC0
.................... 	}  
.................... 	//il renvoie DR=x:x 
.................... 	delay_ms(10); 
03ED6:  MOV     #A,W0
03ED8:  CALL    E84
.................... 	//on verifie que le premier caractere n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] == 'A') 
03EDC:  MOV     880,W4
03EDE:  XOR.B   #41,W4L
03EE0:  BRA     NZ,3F32
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= '\r') 
03EE2:  MOV     1A5E,W4
03EE4:  CLR.B   9
03EE6:  MOV     #880,W3
03EE8:  ADD     W4,W3,W0
03EEA:  MOV.B   [W0],W4L
03EEC:  CP.B    W4L,#D
03EEE:  BRA     Z,3F20
.................... 		{ 
.................... 			if(RoboteQ_receiveBuffer[i]!=0x2D) // 0x2D -> signe '-' en ascii, courant neg -> on prend en abs 
03EF0:  MOV     1A5E,W4
03EF2:  CLR.B   9
03EF4:  MOV     #880,W3
03EF6:  ADD     W4,W3,W0
03EF8:  MOV.B   [W0],W5L
03EFA:  SE      W5,W5
03EFC:  MOV     #2D,W4
03EFE:  CP      W4,W5
03F00:  BRA     Z,3F1A
.................... 			{ 
.................... 				ampere  *= 10; 
03F02:  MOV     1A60,W4
03F04:  MUL.UU  W4,#A,W0
03F06:  MOV     W0,1A60
.................... 				ampere  += RoboteQ_receiveBuffer[i]-0x30; 
03F08:  MOV     1A5E,W4
03F0A:  CLR.B   9
03F0C:  MOV     #880,W3
03F0E:  ADD     W4,W3,W0
03F10:  MOV.B   [W0],W5L
03F12:  SE      W5,W5
03F14:  MOV     #30,W4
03F16:  SUB     W5,W4,W0
03F18:  ADD     1A60
.................... 			} 
.................... 			i++;  
03F1A:  INC.B   1A5E
03F1C:  GOTO    3EE2
.................... 		} 
.................... 		return(ampere); 
03F20:  MOV     1A60,W0
03F22:  MOV     #0,W1
03F24:  MOV     #0,W2
03F26:  MOV     #0,W3
03F28:  CALL    3E28
03F2C:  BRA     3F3C
.................... 	} 
03F2E:  GOTO    3F3C
.................... 	else 
.................... 	{ 
.................... 		return(0); 
03F32:  MOV     #0,W0
03F34:  MOV     #0,W1
03F36:  MOV     #0,W2
03F38:  MOV     #0,W3
03F3A:  BRA     3F3C
.................... 	} 
03F3C:  MOV     [--W15],W6
03F3E:  MOV     [--W15],W5
03F40:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_enco_value(int1 start_end) 
.................... * \brief Recupere la valeur des encodeurs du robot 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] 1 -> enco au depart, 0 -> enco a la fin 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Get_enco_value(int1 start_end) 
*
03014:  MOV     W5,[W15++]
03016:  MOV     W6,[W15++]
03018:  MOV.B   #2,W0L
0301A:  MOV.B   W0L,1A7D
0301C:  BCLR.B  1A7E.0
.................... { 
.................... 	unsigned int8 i = 2; 
.................... 	int1 flag_inverted = 0; 
.................... 	if(start_end) // si recuperation enco au depart --> on clear tout 
0301E:  CP0.B   1A7C
03020:  BRA     Z,3032
.................... 	{ 
.................... 		value_enco_g_start = 0; 
03022:  CLR     151C
03024:  CLR     151E
.................... 		value_enco_d_start = 0; 
03026:  CLR     1520
03028:  CLR     1522
.................... 		value_enco_g_end   = 0; 
0302A:  CLR     1524
0302C:  CLR     1526
.................... 		value_enco_d_end   = 0; 
0302E:  CLR     1528
03030:  CLR     152A
.................... 	} 
....................  
.................... 	fprintf(ROBOTEQ,"?C\r"); // on demande la valeur des encodeurs 
03032:  BTSC.B  219.1
03034:  BRA     3032
03036:  MOV     #3F,W4
03038:  MOV     W4,21A
0303A:  BTSC.B  219.1
0303C:  BRA     303A
0303E:  MOV     #43,W4
03040:  MOV     W4,21A
03042:  BTSC.B  219.1
03044:  BRA     3042
03046:  MOV     #D,W4
03048:  MOV     W4,21A
.................... 	delay_ms(20); 
0304A:  MOV     #14,W0
0304C:  CALL    E84
.................... 	 
.................... 	if(RoboteQ_receiveBuffer[0] == 'C') // si on reçoit C=xxxx:xxxx 
03050:  MOV     880,W4
03052:  XOR.B   #43,W4L
03054:  BRA     NZ,3208
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= ':') 
03056:  MOV     1A7C,W4
03058:  LSR     W4,#8,W4
0305A:  MOV     #880,W3
0305C:  ADD     W4,W3,W0
0305E:  MOV.B   [W0],W4L
03060:  XOR.B   #3A,W4L
03062:  BRA     Z,30FE
.................... 		{ 
.................... 			if(start_end) 
03064:  CP0.B   1A7C
03066:  BRA     Z,30B2
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
03068:  MOV     1A7C,W4
0306A:  LSR     W4,#8,W4
0306C:  MOV     #880,W3
0306E:  ADD     W4,W3,W0
03070:  MOV.B   [W0],W5L
03072:  SE      W5,W5
03074:  MOV     #2D,W4
03076:  CP      W4,W5
03078:  BRA     NZ,3080
.................... 				{ 
.................... 					flag_inverted = 1; 
0307A:  BSET.B  1A7E.0
.................... 				} 
0307C:  GOTO    30AE
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_start *= 10; 
03080:  MOV     151C,W0
03082:  MOV     151E,W1
03084:  MOV     #A,W2
03086:  MOV     #0,W3
03088:  CALL    628
0308C:  MOV     W0,151C
0308E:  MOV     W1,151E
.................... 					value_enco_g_start += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
03090:  MOV     1A7C,W4
03092:  LSR     W4,#8,W4
03094:  MOV     #880,W3
03096:  ADD     W4,W3,W0
03098:  MOV.B   [W0],W5L
0309A:  SE      W5,W5
0309C:  MOV     #30,W4
0309E:  SUB     W5,W4,W0
030A0:  CLR     W1
030A2:  BTSC    W0.F
030A4:  SETM    W1
030A6:  ADD     151C
030A8:  MOV     151E,W4
030AA:  ADDC    W1,W4,W0
030AC:  MOV     W0,151E
.................... 				}				 
.................... 			} 
030AE:  GOTO    30F8
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
030B2:  MOV     1A7C,W4
030B4:  LSR     W4,#8,W4
030B6:  MOV     #880,W3
030B8:  ADD     W4,W3,W0
030BA:  MOV.B   [W0],W5L
030BC:  SE      W5,W5
030BE:  MOV     #2D,W4
030C0:  CP      W4,W5
030C2:  BRA     NZ,30CA
.................... 				{ 
.................... 					flag_inverted = 1; 
030C4:  BSET.B  1A7E.0
.................... 				} 
030C6:  GOTO    30F8
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_end *= 10; 
030CA:  MOV     1524,W0
030CC:  MOV     1526,W1
030CE:  MOV     #A,W2
030D0:  MOV     #0,W3
030D2:  CALL    628
030D6:  MOV     W0,1524
030D8:  MOV     W1,1526
.................... 					value_enco_g_end += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
030DA:  MOV     1A7C,W4
030DC:  LSR     W4,#8,W4
030DE:  MOV     #880,W3
030E0:  ADD     W4,W3,W0
030E2:  MOV.B   [W0],W5L
030E4:  SE      W5,W5
030E6:  MOV     #30,W4
030E8:  SUB     W5,W4,W0
030EA:  CLR     W1
030EC:  BTSC    W0.F
030EE:  SETM    W1
030F0:  ADD     1524
030F2:  MOV     1526,W4
030F4:  ADDC    W1,W4,W0
030F6:  MOV     W0,1526
.................... 				} 
.................... 			} 
.................... 			i++; 
030F8:  INC.B   1A7D
030FA:  GOTO    3056
.................... 		} 
.................... 		if(flag_inverted) //si l'on a recu un nbre d'impulses negatifs 
030FE:  BTSS.B  1A7E.0
03100:  BRA     312E
.................... 		{ 
.................... 			if(start_end)  
03102:  CP0.B   1A7C
03104:  BRA     Z,311C
.................... 			{ 
.................... 				value_enco_g_start = 0-value_enco_g_start; // on inverse tout 
03106:  MOV     #0,W4
03108:  MOV     151C,W3
0310A:  SUB     W4,W3,W0
0310C:  MOV     W0,151C
0310E:  MOV     #0,W4
03110:  MOV     151E,W3
03112:  SUBB    W4,W3,W0
03114:  MOV     W0,151E
.................... 				flag_inverted = 0; 
03116:  BCLR.B  1A7E.0
.................... 			} 
03118:  GOTO    312E
.................... 			else 
.................... 			{ 
.................... 				value_enco_g_end = 0-value_enco_g_end;	// on inverse tout 
0311C:  MOV     #0,W4
0311E:  MOV     1524,W3
03120:  SUB     W4,W3,W0
03122:  MOV     W0,1524
03124:  MOV     #0,W4
03126:  MOV     1526,W3
03128:  SUBB    W4,W3,W0
0312A:  MOV     W0,1526
.................... 				flag_inverted = 0; 
0312C:  BCLR.B  1A7E.0
.................... 			} 
.................... 		} 
.................... 		i++; 
0312E:  INC.B   1A7D
.................... 		while(RoboteQ_receiveBuffer[i]!='\r')//tant que la transmission n'est pas fini 
03130:  MOV     1A7C,W4
03132:  LSR     W4,#8,W4
03134:  MOV     #880,W3
03136:  ADD     W4,W3,W0
03138:  MOV.B   [W0],W4L
0313A:  CP.B    W4L,#D
0313C:  BRA     Z,31D8
.................... 		{ 
.................... 			if(start_end) 
0313E:  CP0.B   1A7C
03140:  BRA     Z,318C
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
03142:  MOV     1A7C,W4
03144:  LSR     W4,#8,W4
03146:  MOV     #880,W3
03148:  ADD     W4,W3,W0
0314A:  MOV.B   [W0],W5L
0314C:  SE      W5,W5
0314E:  MOV     #2D,W4
03150:  CP      W4,W5
03152:  BRA     NZ,315A
.................... 				{ 
.................... 					flag_inverted = 1; 
03154:  BSET.B  1A7E.0
.................... 				} 
03156:  GOTO    3188
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_start *= 10; 
0315A:  MOV     1520,W0
0315C:  MOV     1522,W1
0315E:  MOV     #A,W2
03160:  MOV     #0,W3
03162:  CALL    628
03166:  MOV     W0,1520
03168:  MOV     W1,1522
.................... 					value_enco_d_start += RoboteQ_receiveBuffer[i]-0x30; 
0316A:  MOV     1A7C,W4
0316C:  LSR     W4,#8,W4
0316E:  MOV     #880,W3
03170:  ADD     W4,W3,W0
03172:  MOV.B   [W0],W5L
03174:  SE      W5,W5
03176:  MOV     #30,W4
03178:  SUB     W5,W4,W0
0317A:  CLR     W1
0317C:  BTSC    W0.F
0317E:  SETM    W1
03180:  ADD     1520
03182:  MOV     1522,W4
03184:  ADDC    W1,W4,W0
03186:  MOV     W0,1522
.................... 				} 
.................... 			} 
03188:  GOTO    31D2
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
0318C:  MOV     1A7C,W4
0318E:  LSR     W4,#8,W4
03190:  MOV     #880,W3
03192:  ADD     W4,W3,W0
03194:  MOV.B   [W0],W5L
03196:  SE      W5,W5
03198:  MOV     #2D,W4
0319A:  CP      W4,W5
0319C:  BRA     NZ,31A4
.................... 				{ 
.................... 					flag_inverted = 1; 
0319E:  BSET.B  1A7E.0
.................... 				} 
031A0:  GOTO    31D2
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_end *= 10; 
031A4:  MOV     1528,W0
031A6:  MOV     152A,W1
031A8:  MOV     #A,W2
031AA:  MOV     #0,W3
031AC:  CALL    628
031B0:  MOV     W0,1528
031B2:  MOV     W1,152A
.................... 					value_enco_d_end += RoboteQ_receiveBuffer[i]-0x30;			 
031B4:  MOV     1A7C,W4
031B6:  LSR     W4,#8,W4
031B8:  MOV     #880,W3
031BA:  ADD     W4,W3,W0
031BC:  MOV.B   [W0],W5L
031BE:  SE      W5,W5
031C0:  MOV     #30,W4
031C2:  SUB     W5,W4,W0
031C4:  CLR     W1
031C6:  BTSC    W0.F
031C8:  SETM    W1
031CA:  ADD     1528
031CC:  MOV     152A,W4
031CE:  ADDC    W1,W4,W0
031D0:  MOV     W0,152A
.................... 				} 
.................... 			} 
.................... 			i++;		 
031D2:  INC.B   1A7D
031D4:  GOTO    3130
.................... 		} 
.................... 		if(flag_inverted)//si l'on a recu un nbre d'impulses negatifs 
031D8:  BTSS.B  1A7E.0
031DA:  BRA     3208
.................... 		{ 
.................... 			if(start_end) 
031DC:  CP0.B   1A7C
031DE:  BRA     Z,31F6
.................... 			{ 
.................... 				value_enco_d_start = 0-value_enco_d_start;// on inverse tout 
031E0:  MOV     #0,W4
031E2:  MOV     1520,W3
031E4:  SUB     W4,W3,W0
031E6:  MOV     W0,1520
031E8:  MOV     #0,W4
031EA:  MOV     1522,W3
031EC:  SUBB    W4,W3,W0
031EE:  MOV     W0,1522
.................... 				flag_inverted = 0; 
031F0:  BCLR.B  1A7E.0
.................... 			} 
031F2:  GOTO    3208
.................... 			else 
.................... 			{ 
.................... 				value_enco_d_end = 0-value_enco_d_end;// on inverse tout 
031F6:  MOV     #0,W4
031F8:  MOV     1528,W3
031FA:  SUB     W4,W3,W0
031FC:  MOV     W0,1528
031FE:  MOV     #0,W4
03200:  MOV     152A,W3
03202:  SUBB    W4,W3,W0
03204:  MOV     W0,152A
.................... 				flag_inverted = 0; 
03206:  BCLR.B  1A7E.0
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	if(!start_end) 
03208:  CP0.B   1A7C
0320A:  BRA     NZ,323A
.................... 	{ 
.................... 		Dist_Do = ((value_enco_g_end-value_enco_g_start)+(value_enco_d_end-value_enco_d_start))/2; // calcul distance parcourue 
0320C:  MOV     1524,W4
0320E:  MOV     151C,W3
03210:  SUB     W4,W3,W5
03212:  MOV     1526,W4
03214:  MOV     151E,W3
03216:  SUBB    W4,W3,W6
03218:  MOV     1528,W4
0321A:  MOV     1520,W3
0321C:  SUB     W4,W3,W0
0321E:  MOV     152A,W4
03220:  MOV     1522,W3
03222:  SUBB    W4,W3,W1
03224:  ADD     W0,W5,W5
03226:  ADDC    W1,W6,W6
03228:  BCLR.B  43.0
0322A:  MOV     W5,W0
0322C:  MOV     W6,W1
0322E:  MOV     #2,W2
03230:  MOV     #0,W3
03232:  CALL    2F96
03236:  MOV     W0,1518
03238:  MOV     W1,151A
.................... 	} 
0323A:  MOV     [--W15],W6
0323C:  MOV     [--W15],W5
0323E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Actual_pos(void) 
.................... * \brief Actualise la position xy du robot s'il doit switcher d'objectifs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] - 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __actual_pos(void) 
*
04CDA:  MOV     W5,[W15++]
04CDC:  MOV     W6,[W15++]
04CDE:  MOV     W7,[W15++]
04CE0:  MOV     W8,[W15++]
04CE2:  CLR     1A3E
04CE4:  CLR     1A40
04CE6:  CLR     1A42
04CE8:  CLR     1A44
04CEA:  CLR     1A46
04CEC:  CLR     1A48
.................... { 
.................... 	signed int32 Dist_Do_mm = 0; 
.................... 	signed int32 dx = 0; 
.................... 	signed int32 dy = 0; 
.................... 	__Get_enco_value(0); // recuperation delta x,y 
04CEE:  CLR.B   1A7C
04CF0:  CALL    3014
.................... 							 
.................... 	Dist_Do_mm = (signed int32)(Dist_Do/(COEFF_D/10)); 
04CF4:  MOV     1506,W0
04CF6:  MOV     1508,W1
04CF8:  MOV     150A,W2
04CFA:  MOV     150C,W3
04CFC:  MOV     #0,W4
04CFE:  MOV     #0,W5
04D00:  MOV     #0,W6
04D02:  MOV     #4024,W7
04D04:  CALL    CD0
04D08:  MOV     W0,W5
04D0A:  MOV     W1,W6
04D0C:  MOV     W2,W7
04D0E:  MOV     W3,W8
04D10:  MOV     1518,W0
04D12:  MOV     151A,W1
04D14:  CLR     W3
04D16:  BTSC    W1.F
04D18:  SETM    W3
04D1A:  MOV     W3,W2
04D1C:  CALL    1AD6
04D20:  MOV     W5,[W15++]
04D22:  MOV     W6,[W15++]
04D24:  MOV     W7,[W15++]
04D26:  MOV     W5,W4
04D28:  MOV     W6,W5
04D2A:  MOV     W7,W6
04D2C:  MOV     W8,W7
04D2E:  CALL    CD0
04D32:  MOV     [--W15],W7
04D34:  MOV     [--W15],W6
04D36:  MOV     [--W15],W5
04D38:  CALL    2A7C
04D3C:  MOV     W0,1A3E
04D3E:  MOV     W1,1A40
.................... 	///////////////////////// Calcul dx,dy //////////////////////////// 
.................... 	if(0 <= Orient && Orient <= PI)//entre 0 et 180deg 
04D40:  MOV     #0,W0
04D42:  MOV     #0,W1
04D44:  MOV     #0,W2
04D46:  MOV     #0,W3
04D48:  MOV     14E6,W4
04D4A:  MOV     14E8,W5
04D4C:  MOV     14EA,W6
04D4E:  MOV     14EC,W7
04D50:  CALL    1DD8
04D54:  BRA     C,4D58
04D56:  BRA     NZ,4E28
04D58:  MOV     14E6,W0
04D5A:  MOV     14E8,W1
04D5C:  MOV     14EA,W2
04D5E:  MOV     14EC,W3
04D60:  MOV     #2D18,W4
04D62:  MOV     #5444,W5
04D64:  MOV     #21FB,W6
04D66:  MOV     #4009,W7
04D68:  CALL    1DD8
04D6C:  BRA     C,4D70
04D6E:  BRA     NZ,4E28
.................... 	{ 
.................... 		dx =  (signed int16)(cos(Orient) * Dist_Do_mm); 
04D70:  PUSH    14E6
04D72:  POP     1A6E
04D74:  PUSH    14E8
04D76:  POP     1A70
04D78:  PUSH    14EA
04D7A:  POP     1A72
04D7C:  PUSH    14EC
04D7E:  POP     1A74
04D80:  CALL    3FA0
04D84:  MOV     W0,W5
04D86:  MOV     W1,W6
04D88:  MOV     W2,W7
04D8A:  MOV     W3,W8
04D8C:  MOV     1A3E,W0
04D8E:  MOV     1A40,W1
04D90:  CLR     W3
04D92:  BTSC    W1.F
04D94:  SETM    W3
04D96:  MOV     W3,W2
04D98:  CALL    1AD6
04D9C:  MOV     W5,[W15++]
04D9E:  MOV     W6,[W15++]
04DA0:  MOV     W7,[W15++]
04DA2:  MOV     W0,W4
04DA4:  MOV     W5,W0
04DA6:  MOV     W1,W5
04DA8:  MOV     W6,W1
04DAA:  MOV     W2,W6
04DAC:  MOV     W7,W2
04DAE:  MOV     W3,W7
04DB0:  MOV     W8,W3
04DB2:  CALL    BC0
04DB6:  MOV     [--W15],W7
04DB8:  MOV     [--W15],W6
04DBA:  MOV     [--W15],W5
04DBC:  CALL    2A7C
04DC0:  CLR     W1
04DC2:  BTSC    W0.F
04DC4:  SETM    W1
04DC6:  MOV     W0,1A42
04DC8:  MOV     W1,1A44
.................... 		dy =  (signed int16)(sin(Orient) * Dist_Do_mm);	 
04DCA:  PUSH    14E6
04DCC:  POP     1A5C
04DCE:  PUSH    14E8
04DD0:  POP     1A5E
04DD2:  PUSH    14EA
04DD4:  POP     1A60
04DD6:  PUSH    14EC
04DD8:  POP     1A62
04DDA:  CALL    425A
04DDE:  MOV     W0,W5
04DE0:  MOV     W1,W6
04DE2:  MOV     W2,W7
04DE4:  MOV     W3,W8
04DE6:  MOV     1A3E,W0
04DE8:  MOV     1A40,W1
04DEA:  CLR     W3
04DEC:  BTSC    W1.F
04DEE:  SETM    W3
04DF0:  MOV     W3,W2
04DF2:  CALL    1AD6
04DF6:  MOV     W5,[W15++]
04DF8:  MOV     W6,[W15++]
04DFA:  MOV     W7,[W15++]
04DFC:  MOV     W0,W4
04DFE:  MOV     W5,W0
04E00:  MOV     W1,W5
04E02:  MOV     W6,W1
04E04:  MOV     W2,W6
04E06:  MOV     W7,W2
04E08:  MOV     W3,W7
04E0A:  MOV     W8,W3
04E0C:  CALL    BC0
04E10:  MOV     [--W15],W7
04E12:  MOV     [--W15],W6
04E14:  MOV     [--W15],W5
04E16:  CALL    2A7C
04E1A:  CLR     W1
04E1C:  BTSC    W0.F
04E1E:  SETM    W1
04E20:  MOV     W0,1A46
04E22:  MOV     W1,1A48
.................... 	} 
04E24:  GOTO    50C0
.................... 	else if(( (Orient>PI) && ((3*PI)/2 >= Orient)) || (Orient <= (-PI/2) && Orient > -PI))//180 et 270deg 
04E28:  MOV     #2D18,W0
04E2A:  MOV     #5444,W1
04E2C:  MOV     #21FB,W2
04E2E:  MOV     #4009,W3
04E30:  MOV     14E6,W4
04E32:  MOV     14E8,W5
04E34:  MOV     14EA,W6
04E36:  MOV     14EC,W7
04E38:  CALL    1DD8
04E3C:  BRA     NC,4E56
04E3E:  MOV     14E6,W0
04E40:  MOV     14E8,W1
04E42:  MOV     14EA,W2
04E44:  MOV     14EC,W3
04E46:  MOV     #21D2,W4
04E48:  MOV     #7F33,W5
04E4A:  MOV     #D97C,W6
04E4C:  MOV     #4012,W7
04E4E:  CALL    1DD8
04E52:  BRA     C,4E84
04E54:  BRA     Z,4E84
04E56:  MOV     14E6,W0
04E58:  MOV     14E8,W1
04E5A:  MOV     14EA,W2
04E5C:  MOV     14EC,W3
04E5E:  MOV     #2D18,W4
04E60:  MOV     #5444,W5
04E62:  MOV     #21FB,W6
04E64:  MOV     #BFF9,W7
04E66:  CALL    1DD8
04E6A:  BRA     C,4E6E
04E6C:  BRA     NZ,4F78
04E6E:  MOV     #2D18,W0
04E70:  MOV     #5444,W1
04E72:  MOV     #21FB,W2
04E74:  MOV     #C009,W3
04E76:  MOV     14E6,W4
04E78:  MOV     14E8,W5
04E7A:  MOV     14EA,W6
04E7C:  MOV     14EC,W7
04E7E:  CALL    1DD8
04E82:  BRA     NC,4F78
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm; 
04E84:  MOV     #0,W4
04E86:  MOV     1A3E,W3
04E88:  SUB     W4,W3,W0
04E8A:  MOV     W0,1A3E
04E8C:  MOV     #0,W4
04E8E:  MOV     1A40,W3
04E90:  SUBB    W4,W3,W0
04E92:  MOV     W0,1A40
.................... 		dx = (signed int16)(sin(3*(PI/2)-Orient) * Dist_Do_mm); 
04E94:  BSET.B  43.0
04E96:  MOV     #21D2,W0
04E98:  MOV     #7F33,W1
04E9A:  MOV     #D97C,W2
04E9C:  MOV     #4012,W3
04E9E:  MOV     14E6,W4
04EA0:  MOV     14E8,W5
04EA2:  MOV     14EA,W6
04EA4:  MOV     14EC,W7
04EA6:  CALL    1BEA
04EAA:  MOV     W0,W5
04EAC:  MOV     W1,W6
04EAE:  MOV     W2,W7
04EB0:  MOV     W3,W8
04EB2:  MOV     W5,1A5C
04EB4:  MOV     W6,1A5E
04EB6:  MOV     W7,1A60
04EB8:  MOV     W8,1A62
04EBA:  CALL    425A
04EBE:  MOV     W0,W5
04EC0:  MOV     W1,W6
04EC2:  MOV     W2,W7
04EC4:  MOV     W3,W8
04EC6:  MOV     1A3E,W0
04EC8:  MOV     1A40,W1
04ECA:  CLR     W3
04ECC:  BTSC    W1.F
04ECE:  SETM    W3
04ED0:  MOV     W3,W2
04ED2:  CALL    1AD6
04ED6:  MOV     W5,[W15++]
04ED8:  MOV     W6,[W15++]
04EDA:  MOV     W7,[W15++]
04EDC:  MOV     W0,W4
04EDE:  MOV     W5,W0
04EE0:  MOV     W1,W5
04EE2:  MOV     W6,W1
04EE4:  MOV     W2,W6
04EE6:  MOV     W7,W2
04EE8:  MOV     W3,W7
04EEA:  MOV     W8,W3
04EEC:  CALL    BC0
04EF0:  MOV     [--W15],W7
04EF2:  MOV     [--W15],W6
04EF4:  MOV     [--W15],W5
04EF6:  CALL    2A7C
04EFA:  CLR     W1
04EFC:  BTSC    W0.F
04EFE:  SETM    W1
04F00:  MOV     W0,1A42
04F02:  MOV     W1,1A44
.................... 		dy = (signed int16)(cos(3*(PI/2)-Orient) * Dist_Do_mm); 
04F04:  BSET.B  43.0
04F06:  MOV     #21D2,W0
04F08:  MOV     #7F33,W1
04F0A:  MOV     #D97C,W2
04F0C:  MOV     #4012,W3
04F0E:  MOV     14E6,W4
04F10:  MOV     14E8,W5
04F12:  MOV     14EA,W6
04F14:  MOV     14EC,W7
04F16:  CALL    1BEA
04F1A:  MOV     W0,W5
04F1C:  MOV     W1,W6
04F1E:  MOV     W2,W7
04F20:  MOV     W3,W8
04F22:  MOV     W5,1A6E
04F24:  MOV     W6,1A70
04F26:  MOV     W7,1A72
04F28:  MOV     W8,1A74
04F2A:  CALL    3FA0
04F2E:  MOV     W0,W5
04F30:  MOV     W1,W6
04F32:  MOV     W2,W7
04F34:  MOV     W3,W8
04F36:  MOV     1A3E,W0
04F38:  MOV     1A40,W1
04F3A:  CLR     W3
04F3C:  BTSC    W1.F
04F3E:  SETM    W3
04F40:  MOV     W3,W2
04F42:  CALL    1AD6
04F46:  MOV     W5,[W15++]
04F48:  MOV     W6,[W15++]
04F4A:  MOV     W7,[W15++]
04F4C:  MOV     W0,W4
04F4E:  MOV     W5,W0
04F50:  MOV     W1,W5
04F52:  MOV     W6,W1
04F54:  MOV     W2,W6
04F56:  MOV     W7,W2
04F58:  MOV     W3,W7
04F5A:  MOV     W8,W3
04F5C:  CALL    BC0
04F60:  MOV     [--W15],W7
04F62:  MOV     [--W15],W6
04F64:  MOV     [--W15],W5
04F66:  CALL    2A7C
04F6A:  CLR     W1
04F6C:  BTSC    W0.F
04F6E:  SETM    W1
04F70:  MOV     W0,1A46
04F72:  MOV     W1,1A48
.................... 	} 
04F74:  GOTO    50C0
.................... 	else if(((Orient>(3*PI/2)) && (Orient < (2*PI))) || (Orient < 0 && Orient > (-PI/2)))//270deg et 360deg 
04F78:  MOV     #21D2,W0
04F7A:  MOV     #7F33,W1
04F7C:  MOV     #D97C,W2
04F7E:  MOV     #4012,W3
04F80:  MOV     14E6,W4
04F82:  MOV     14E8,W5
04F84:  MOV     14EA,W6
04F86:  MOV     14EC,W7
04F88:  CALL    1DD8
04F8C:  BRA     NC,4FA4
04F8E:  MOV     14E6,W0
04F90:  MOV     14E8,W1
04F92:  MOV     14EA,W2
04F94:  MOV     14EC,W3
04F96:  MOV     #2D18,W4
04F98:  MOV     #5444,W5
04F9A:  MOV     #21FB,W6
04F9C:  MOV     #4019,W7
04F9E:  CALL    1DD8
04FA2:  BRA     C,4FD0
04FA4:  MOV     14E6,W0
04FA6:  MOV     14E8,W1
04FA8:  MOV     14EA,W2
04FAA:  MOV     14EC,W3
04FAC:  MOV     #0,W4
04FAE:  MOV     #0,W5
04FB0:  MOV     #0,W6
04FB2:  MOV     #0,W7
04FB4:  CALL    1DD8
04FB8:  BRA     NC,50C0
04FBA:  MOV     #2D18,W0
04FBC:  MOV     #5444,W1
04FBE:  MOV     #21FB,W2
04FC0:  MOV     #BFF9,W3
04FC2:  MOV     14E6,W4
04FC4:  MOV     14E8,W5
04FC6:  MOV     14EA,W6
04FC8:  MOV     14EC,W7
04FCA:  CALL    1DD8
04FCE:  BRA     NC,50C0
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm;  
04FD0:  MOV     #0,W4
04FD2:  MOV     1A3E,W3
04FD4:  SUB     W4,W3,W0
04FD6:  MOV     W0,1A3E
04FD8:  MOV     #0,W4
04FDA:  MOV     1A40,W3
04FDC:  SUBB    W4,W3,W0
04FDE:  MOV     W0,1A40
.................... 		dx = (signed int16)(sin(-(PI/2)-Orient) * Dist_Do_mm); 
04FE0:  BSET.B  43.0
04FE2:  MOV     #2D18,W0
04FE4:  MOV     #5444,W1
04FE6:  MOV     #21FB,W2
04FE8:  MOV     #BFF9,W3
04FEA:  MOV     14E6,W4
04FEC:  MOV     14E8,W5
04FEE:  MOV     14EA,W6
04FF0:  MOV     14EC,W7
04FF2:  CALL    1BEA
04FF6:  MOV     W0,W5
04FF8:  MOV     W1,W6
04FFA:  MOV     W2,W7
04FFC:  MOV     W3,W8
04FFE:  MOV     W5,1A5C
05000:  MOV     W6,1A5E
05002:  MOV     W7,1A60
05004:  MOV     W8,1A62
05006:  CALL    425A
0500A:  MOV     W0,W5
0500C:  MOV     W1,W6
0500E:  MOV     W2,W7
05010:  MOV     W3,W8
05012:  MOV     1A3E,W0
05014:  MOV     1A40,W1
05016:  CLR     W3
05018:  BTSC    W1.F
0501A:  SETM    W3
0501C:  MOV     W3,W2
0501E:  CALL    1AD6
05022:  MOV     W5,[W15++]
05024:  MOV     W6,[W15++]
05026:  MOV     W7,[W15++]
05028:  MOV     W0,W4
0502A:  MOV     W5,W0
0502C:  MOV     W1,W5
0502E:  MOV     W6,W1
05030:  MOV     W2,W6
05032:  MOV     W7,W2
05034:  MOV     W3,W7
05036:  MOV     W8,W3
05038:  CALL    BC0
0503C:  MOV     [--W15],W7
0503E:  MOV     [--W15],W6
05040:  MOV     [--W15],W5
05042:  CALL    2A7C
05046:  CLR     W1
05048:  BTSC    W0.F
0504A:  SETM    W1
0504C:  MOV     W0,1A42
0504E:  MOV     W1,1A44
.................... 		dy = (signed int16)(cos(-(PI/2)-Orient) * Dist_Do_mm); 
05050:  BSET.B  43.0
05052:  MOV     #2D18,W0
05054:  MOV     #5444,W1
05056:  MOV     #21FB,W2
05058:  MOV     #BFF9,W3
0505A:  MOV     14E6,W4
0505C:  MOV     14E8,W5
0505E:  MOV     14EA,W6
05060:  MOV     14EC,W7
05062:  CALL    1BEA
05066:  MOV     W0,W5
05068:  MOV     W1,W6
0506A:  MOV     W2,W7
0506C:  MOV     W3,W8
0506E:  MOV     W5,1A6E
05070:  MOV     W6,1A70
05072:  MOV     W7,1A72
05074:  MOV     W8,1A74
05076:  CALL    3FA0
0507A:  MOV     W0,W5
0507C:  MOV     W1,W6
0507E:  MOV     W2,W7
05080:  MOV     W3,W8
05082:  MOV     1A3E,W0
05084:  MOV     1A40,W1
05086:  CLR     W3
05088:  BTSC    W1.F
0508A:  SETM    W3
0508C:  MOV     W3,W2
0508E:  CALL    1AD6
05092:  MOV     W5,[W15++]
05094:  MOV     W6,[W15++]
05096:  MOV     W7,[W15++]
05098:  MOV     W0,W4
0509A:  MOV     W5,W0
0509C:  MOV     W1,W5
0509E:  MOV     W6,W1
050A0:  MOV     W2,W6
050A2:  MOV     W7,W2
050A4:  MOV     W3,W7
050A6:  MOV     W8,W3
050A8:  CALL    BC0
050AC:  MOV     [--W15],W7
050AE:  MOV     [--W15],W6
050B0:  MOV     [--W15],W5
050B2:  CALL    2A7C
050B6:  CLR     W1
050B8:  BTSC    W0.F
050BA:  SETM    W1
050BC:  MOV     W0,1A46
050BE:  MOV     W1,1A48
.................... 	} 
.................... 	Pos_x = (signed int16)(Pos_x + dx); //mise a jour pos x 
050C0:  MOV     14D8,W0
050C2:  CLR     W1
050C4:  BTSC    W0.F
050C6:  SETM    W1
050C8:  MOV     1A42,W4
050CA:  ADD     W0,W4,W0
050CC:  MOV     1A44,W4
050CE:  ADDC    W1,W4,W1
050D0:  MOV     W0,14D8
.................... 	Pos_y = (signed int16)(Pos_y + dy);	//mise a jour pos y 
050D2:  MOV     14DA,W0
050D4:  CLR     W1
050D6:  BTSC    W0.F
050D8:  SETM    W1
050DA:  MOV     1A46,W4
050DC:  ADD     W0,W4,W0
050DE:  MOV     1A48,W4
050E0:  ADDC    W1,W4,W1
050E2:  MOV     W0,14DA
050E4:  MOV     [--W15],W8
050E6:  MOV     [--W15],W7
050E8:  MOV     [--W15],W6
050EA:  MOV     [--W15],W5
050EC:  RETURN  
.................... } 
.................... /* 
.................... 	Borgeat Rémy 
....................  
.................... 	20.2.2017 
....................  
.................... 	Initialise la postion de départ du robot. 
.................... 	Gere le cote duquel se trouve le robot 
.................... */ 
.................... void __Init_pos(void) 
*
01B40:  MOV     W5,[W15++]
01B42:  MOV     W6,[W15++]
01B44:  MOV     W7,[W15++]
01B46:  MOV     W8,[W15++]
.................... { 
.................... 	Pos_x = read_eeprom(800); 
01B48:  MOV     #320,W3
01B4A:  MOV     #0,W4
01B4C:  MOV     #2,W5
01B4E:  CALL    1A24
01B52:  MOV     W0,14D8
.................... 	Pos_y = read_eeprom(802); 
01B54:  MOV     #322,W3
01B56:  MOV     #0,W4
01B58:  MOV     #2,W5
01B5A:  CALL    1A24
01B5E:  MOV     W0,14DA
.................... 	Orient_deg = read_eeprom(804); 
01B60:  MOV     #324,W3
01B62:  MOV     #0,W4
01B64:  MOV     #2,W5
01B66:  CALL    1A24
01B6A:  MOV     W0,14DC
....................  
.................... 	//si on est de l'autre cote du terrain 
.................... 	if(_TEAM) 
01B6C:  BTSS.B  2C3.4
01B6E:  BRA     1B94
.................... 	{ 
.................... 		Pos_x = TableWidth-Pos_x; 
01B70:  MOV     87C,W4
01B72:  MOV     14D8,W3
01B74:  SUB     W4,W3,W0
01B76:  MOV     W0,14D8
.................... 		if(Orient_deg<=180)Orient_deg=180-Orient_deg ; 
01B78:  MOV     14DC,W4
01B7A:  MOV     #B4,W3
01B7C:  CP      W3,W4
01B7E:  BRA     LT,1B8C
01B80:  MOV     #B4,W4
01B82:  MOV     14DC,W3
01B84:  SUB     W4,W3,W0
01B86:  MOV     W0,14DC
01B88:  GOTO    1B94
.................... 		else Orient_deg = 540 - Orient_deg ; 
01B8C:  MOV     #21C,W4
01B8E:  MOV     14DC,W3
01B90:  SUB     W4,W3,W0
01B92:  MOV     W0,14DC
.................... 	}		 
.................... 	Orient = (float64)(Orient_deg*PI/180); 
01B94:  MOV     14DC,W0
01B96:  CLR     W3
01B98:  BTSC    W0.F
01B9A:  SETM    W3
01B9C:  MOV     W3,W1
01B9E:  MOV     W3,W2
01BA0:  CALL    1AD6
01BA4:  MOV     #2D18,W4
01BA6:  MOV     #5444,W5
01BA8:  MOV     #21FB,W6
01BAA:  MOV     #4009,W7
01BAC:  CALL    BC0
01BB0:  MOV     W0,W5
01BB2:  MOV     W1,W6
01BB4:  MOV     W2,W7
01BB6:  MOV     W3,W8
01BB8:  MOV     W5,[W15++]
01BBA:  MOV     W6,[W15++]
01BBC:  MOV     W7,[W15++]
01BBE:  MOV     W5,W0
01BC0:  MOV     W6,W1
01BC2:  MOV     W7,W2
01BC4:  MOV     W8,W3
01BC6:  MOV     #0,W4
01BC8:  MOV     #0,W5
01BCA:  MOV     #8000,W6
01BCC:  MOV     #4066,W7
01BCE:  CALL    CD0
01BD2:  MOV     [--W15],W7
01BD4:  MOV     [--W15],W6
01BD6:  MOV     [--W15],W5
01BD8:  MOV     W0,14E6
01BDA:  MOV     W1,14E8
01BDC:  MOV     W2,14EA
01BDE:  MOV     W3,14EC
01BE0:  MOV     [--W15],W8
01BE2:  MOV     [--W15],W7
01BE4:  MOV     [--W15],W6
01BE6:  MOV     [--W15],W5
01BE8:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __Action_Writting(unsigned int8 _Command) 
.................... * \brief Demande d'Ã©criture, entre 0x00 et 0x79. 
.................... * 
.................... * \author Barman Corentin / rev. Amand Axel 
.................... * \version 2.0 
.................... * \date 19.11.2015 
.................... * 
.................... * \param[in] _Command Choisit la commande Ã  effectuer 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __DeplToDo(unsigned int8 _Command) 
.................... { 
.................... 	switch(_Command) 
*
04616:  MOV.B   1A3E,W0L
04618:  CLR.B   1
0461A:  XOR     #0,W0
0461C:  BRA     Z,462C
0461E:  XOR     #1,W0
04620:  BRA     Z,4638
04622:  XOR     #3,W0
04624:  BRA     Z,4648
04626:  XOR     #1,W0
04628:  BRA     Z,4658
0462A:  BRA     4660
.................... 	{ 
.................... 		// !!! En ajoutant des types de dÃ©placement, 
.................... 		//		pensez Ã  les gÃ©rer dans __LoadObj() tout en bas du fichier. 
.................... 		//		Comme le X est par exemple utiliser pour donner un angle, 
.................... 		//		si comme un dÃ©pl. PÃ P vous faÃ®tes TailleTable - X .... 
.................... 		//		Autant dire que le robot va faire n'importe quoi ^^ 
.................... 		case 0 : 
.................... 			__Turn((signed int16) oXp);			 
0462C:  PUSH    13B2
0462E:  POP     1A40
04630:  CALL    261C
.................... 			break; 
04634:  GOTO    466C
.................... 		case 1 : 
.................... 			__PaP(oXp, oYp); 
04638:  PUSH    13B2
0463A:  POP     1A40
0463C:  PUSH    13B4
0463E:  POP     1A42
04640:  CALL    327A
.................... 			break; 
04644:  GOTO    466C
.................... 		case 2 : 
.................... 			__Progress(oXp, oYp); //se déplace d'une certaine distance, jusqu'a ce qu'on tape dans un bord, ou que l'ordre soit fini 
04648:  PUSH    13B2
0464A:  POP     1A40
0464C:  PUSH    13B4
0464E:  POP     1A42
04650:  CALL    4296
.................... 			break; 
04654:  GOTO    466C
.................... 		case 3 : 
.................... 			__Nothing(); 
04658:  CALL    460E
.................... 			break; 
0465C:  GOTO    466C
.................... 		default: 
.................... 			__Affichage_erreur(4); 
04660:  MOV.B   #4,W0L
04662:  MOV.B   W0L,1A4A
04664:  CALL    1002
.................... 			break; 
04668:  GOTO    466C
.................... 	} 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
0466C:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Turn(signed int16 _Ang) 
.................... * \brief Tourne sur place jusqu'a l'angle donne. 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] Angle d'arrive  
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Turn(signed int16 _Ang) 
*
0261C:  MOV     W5,[W15++]
0261E:  MOV     W6,[W15++]
02620:  MOV     W7,[W15++]
02622:  MOV     W8,[W15++]
02624:  CLR     1A42
02626:  CLR     1A44
02628:  CLR     1A46
0262A:  CLR     1A48
0262C:  CLR     1A4A
0262E:  CLR     1A4C
02630:  CLR     1A4E
02632:  CLR     1A50
02634:  CLR     1A52
02636:  CLR     1A54
02638:  CLR     1A56
0263A:  CLR     1A58
0263C:  CLR     1A5A
0263E:  CLR     1A5C
.................... { 
.................... 	float64 AngToDo = 0;			 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer en nombre d'impulses 
.................... 	signed int32 impulse_g = 0; 	//impulse mot g 
.................... 	signed int32 impulse_d = 0;		//impulse mot d 
.................... 	float64 temporaire = 0; 
....................  
.................... 	// Convertit la valeur de l'angle en radian 
.................... 	AngToDo = (_Ang * CONV_DEG_RAD) - Orient ; 
02640:  MOV     1A40,W0
02642:  CLR     W3
02644:  BTSC    W0.F
02646:  SETM    W3
02648:  MOV     W3,W1
0264A:  MOV     W3,W2
0264C:  CALL    1AD6
02650:  MOV     150E,W4
02652:  MOV     1510,W5
02654:  MOV     1512,W6
02656:  MOV     1514,W7
02658:  CALL    BC0
0265C:  MOV     W0,W5
0265E:  MOV     W1,W6
02660:  MOV     W2,W7
02662:  MOV     W3,W8
02664:  BSET.B  43.0
02666:  MOV     W5,[W15++]
02668:  MOV     W6,[W15++]
0266A:  MOV     W7,[W15++]
0266C:  MOV     W5,W0
0266E:  MOV     W6,W1
02670:  MOV     W7,W2
02672:  MOV     W8,W3
02674:  MOV     14E6,W4
02676:  MOV     14E8,W5
02678:  MOV     14EA,W6
0267A:  MOV     14EC,W7
0267C:  CALL    1BEA
02680:  MOV     [--W15],W7
02682:  MOV     [--W15],W6
02684:  MOV     [--W15],W5
02686:  MOV     W0,1A42
02688:  MOV     W1,1A44
0268A:  MOV     W2,1A46
0268C:  MOV     W3,1A48
....................  
.................... 	if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
0268E:  MOV     13BA,W4
02690:  CP      W4,#2
02692:  BRA     NZ,26CC
02694:  MOV     #0,W0
02696:  MOV     #0,W1
02698:  MOV     #0,W2
0269A:  MOV     #0,W3
0269C:  MOV     1A42,W4
0269E:  MOV     1A44,W5
026A0:  MOV     1A46,W6
026A2:  MOV     1A48,W7
026A4:  CALL    1DD8
026A8:  BRA     NC,26CC
.................... 	{ 
.................... 		AngToDo += -2 * PI; //on tourne sur la gauche 
026AA:  BCLR.B  43.0
026AC:  MOV     1A42,W0
026AE:  MOV     1A44,W1
026B0:  MOV     1A46,W2
026B2:  MOV     1A48,W3
026B4:  MOV     #2D18,W4
026B6:  MOV     #5444,W5
026B8:  MOV     #21FB,W6
026BA:  MOV     #C019,W7
026BC:  CALL    1BEA
026C0:  MOV     W0,1A42
026C2:  MOV     W1,1A44
026C4:  MOV     W2,1A46
026C6:  MOV     W3,1A48
.................... 	}	 
026C8:  GOTO    2706
.................... 	else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
026CC:  MOV     13BA,W4
026CE:  CP      W4,#1
026D0:  BRA     NZ,2706
026D2:  MOV     1A42,W0
026D4:  MOV     1A44,W1
026D6:  MOV     1A46,W2
026D8:  MOV     1A48,W3
026DA:  MOV     #0,W4
026DC:  MOV     #0,W5
026DE:  MOV     #0,W6
026E0:  MOV     #0,W7
026E2:  CALL    1DD8
026E6:  BRA     NC,2706
.................... 	{ 
.................... 		AngToDo += 2 * PI;//On tourne sur la droite	 
026E8:  BCLR.B  43.0
026EA:  MOV     1A42,W0
026EC:  MOV     1A44,W1
026EE:  MOV     1A46,W2
026F0:  MOV     1A48,W3
026F2:  MOV     #2D18,W4
026F4:  MOV     #5444,W5
026F6:  MOV     #21FB,W6
026F8:  MOV     #4019,W7
026FA:  CALL    1BEA
026FE:  MOV     W0,1A42
02700:  MOV     W1,1A44
02702:  MOV     W2,1A46
02704:  MOV     W3,1A48
.................... 	} 
.................... 	 
.................... 	if(AngToDo > PI && oCoteTourn==0) // on a plus de 180Â° 
02706:  MOV     #2D18,W0
02708:  MOV     #5444,W1
0270A:  MOV     #21FB,W2
0270C:  MOV     #4009,W3
0270E:  MOV     1A42,W4
02710:  MOV     1A44,W5
02712:  MOV     1A46,W6
02714:  MOV     1A48,W7
02716:  CALL    1DD8
0271A:  BRA     NC,2742
0271C:  CP0     13BA
0271E:  BRA     NZ,2742
.................... 	{ 
.................... 		AngToDo -= 2*PI; // on tourne ds l'autre sens 
02720:  BSET.B  43.0
02722:  MOV     1A42,W0
02724:  MOV     1A44,W1
02726:  MOV     1A46,W2
02728:  MOV     1A48,W3
0272A:  MOV     #2D18,W4
0272C:  MOV     #5444,W5
0272E:  MOV     #21FB,W6
02730:  MOV     #4019,W7
02732:  CALL    1BEA
02736:  MOV     W0,1A42
02738:  MOV     W1,1A44
0273A:  MOV     W2,1A46
0273C:  MOV     W3,1A48
.................... 	} 
0273E:  GOTO    277A
.................... 	else if(AngToDo < -PI  && oCoteTourn==0) // si on moins que -180Â°   
02742:  MOV     1A42,W0
02744:  MOV     1A44,W1
02746:  MOV     1A46,W2
02748:  MOV     1A48,W3
0274A:  MOV     #2D18,W4
0274C:  MOV     #5444,W5
0274E:  MOV     #21FB,W6
02750:  MOV     #C009,W7
02752:  CALL    1DD8
02756:  BRA     NC,277A
02758:  CP0     13BA
0275A:  BRA     NZ,277A
.................... 	{ 
.................... 		AngToDo += 2 * PI; // on tourne ds l'autre sens 
0275C:  BCLR.B  43.0
0275E:  MOV     1A42,W0
02760:  MOV     1A44,W1
02762:  MOV     1A46,W2
02764:  MOV     1A48,W3
02766:  MOV     #2D18,W4
02768:  MOV     #5444,W5
0276A:  MOV     #21FB,W6
0276C:  MOV     #4019,W7
0276E:  CALL    1BEA
02772:  MOV     W0,1A42
02774:  MOV     W1,1A44
02776:  MOV     W2,1A46
02778:  MOV     W3,1A48
.................... 	}	 
....................  
.................... 	if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
0277A:  MOV     #432D,W0
0277C:  MOV     #EB1C,W1
0277E:  MOV     #36E2,W2
02780:  MOV     #BF1A,W3
02782:  MOV     1A42,W4
02784:  MOV     1A44,W5
02786:  MOV     1A46,W6
02788:  MOV     1A48,W7
0278A:  CALL    1DD8
0278E:  BRA     NC,27AE
02790:  MOV     1A42,W0
02792:  MOV     1A44,W1
02794:  MOV     1A46,W2
02796:  MOV     1A48,W3
02798:  MOV     #432D,W4
0279A:  MOV     #EB1C,W5
0279C:  MOV     #36E2,W6
0279E:  MOV     #3F1A,W7
027A0:  CALL    1DD8
027A4:  BRA     NC,27AE
027A6:  CLR     1A42
027A8:  CLR     1A44
027AA:  CLR     1A46
027AC:  CLR     1A48
.................... 	temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
027AE:  MOV     14FE,W0
027B0:  MOV     1500,W1
027B2:  MOV     1502,W2
027B4:  MOV     1504,W3
027B6:  MOV     14EE,W4
027B8:  MOV     14F0,W5
027BA:  MOV     14F2,W6
027BC:  MOV     14F4,W7
027BE:  CALL    CD0
027C2:  MOV     W0,W4
027C4:  MOV     W1,W5
027C6:  MOV     W2,W6
027C8:  MOV     W3,W7
027CA:  MOV     1A42,W0
027CC:  MOV     1A44,W1
027CE:  MOV     1A46,W2
027D0:  MOV     1A48,W3
027D2:  CALL    BC0
027D6:  MOV     W0,W5
027D8:  MOV     W1,W6
027DA:  MOV     W2,W7
027DC:  MOV     W3,W8
027DE:  MOV     W5,[W15++]
027E0:  MOV     W6,[W15++]
027E2:  MOV     W7,[W15++]
027E4:  MOV     W5,W0
027E6:  MOV     W6,W1
027E8:  MOV     W7,W2
027EA:  MOV     W8,W3
027EC:  MOV     14F6,W4
027EE:  MOV     14F8,W5
027F0:  MOV     14FA,W6
027F2:  MOV     14FC,W7
027F4:  CALL    BC0
027F8:  MOV     [--W15],W7
027FA:  MOV     [--W15],W6
027FC:  MOV     [--W15],W5
027FE:  MOV     W0,W5
02800:  MOV     W1,W6
02802:  MOV     W2,W7
02804:  MOV     W3,W8
02806:  MOV     W5,[W15++]
02808:  MOV     W6,[W15++]
0280A:  MOV     W7,[W15++]
0280C:  MOV     W5,W0
0280E:  MOV     W6,W1
02810:  MOV     W7,W2
02812:  MOV     W8,W3
02814:  MOV     #0,W4
02816:  MOV     #0,W5
02818:  MOV     #0,W6
0281A:  MOV     #4000,W7
0281C:  CALL    BC0
02820:  MOV     [--W15],W7
02822:  MOV     [--W15],W6
02824:  MOV     [--W15],W5
02826:  MOV     W0,W5
02828:  MOV     W1,W6
0282A:  MOV     W2,W7
0282C:  MOV     W3,W8
0282E:  MOV     W5,[W15++]
02830:  MOV     W6,[W15++]
02832:  MOV     W7,[W15++]
02834:  MOV     W5,W0
02836:  MOV     W6,W1
02838:  MOV     W7,W2
0283A:  MOV     W8,W3
0283C:  MOV     #2D18,W4
0283E:  MOV     #5444,W5
02840:  MOV     #21FB,W6
02842:  MOV     #4009,W7
02844:  CALL    CD0
02848:  MOV     [--W15],W7
0284A:  MOV     [--W15],W6
0284C:  MOV     [--W15],W5
0284E:  MOV     W0,1A56
02850:  MOV     W1,1A58
02852:  MOV     W2,1A5A
02854:  MOV     W3,1A5C
.................... 	AngToDo_int = (signed int32)(arrondi_float_signed(temporaire));	 
02856:  MOV     1A56,W0
02858:  MOV     1A58,W1
0285A:  MOV     1A5A,W2
0285C:  MOV     1A5C,W3
0285E:  CALL    1E5C
02862:  MOV     W1,W5
02864:  MOV     W2,W6
02866:  MOV     W5,1A80
02868:  MOV     W6,1A82
0286A:  CALL    23AE
0286E:  MOV     W0,1A4A
02870:  MOV     W1,1A4C
.................... 	// on envoie les donnee au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
02872:  MOV     #0,W1
02874:  MOV     W1,W0
02876:  CLR.B   1
02878:  CALL    2B4
0287C:  INC     W1,W1
0287E:  BTSC.B  219.1
02880:  BRA     287E
02882:  MOV     W0,21A
02884:  MOV     #4,W0
02886:  CPSGT   W1,W0
02888:  BRA     2874
0288A:  MOV     13BC,W0
0288C:  MOV     #8004,W4
0288E:  CALL    240A
02892:  MOV     #9,W1
02894:  MOV     W1,W0
02896:  CLR.B   1
02898:  CALL    2B4
0289C:  INC     W1,W1
0289E:  BTSC.B  219.1
028A0:  BRA     289E
028A2:  MOV     W0,21A
028A4:  MOV     #E,W0
028A6:  CPSGT   W1,W0
028A8:  BRA     2894
028AA:  MOV     13BC,W0
028AC:  MOV     #8004,W4
028AE:  CALL    240A
028B2:  BTSC.B  219.1
028B4:  BRA     28B2
028B6:  MOV     #20,W4
028B8:  MOV     W4,21A
028BA:  BTSC.B  219.1
028BC:  BRA     28BA
028BE:  MOV     #D,W4
028C0:  MOV     W4,21A
.................... 	 
.................... 	//balise  
.................... 	balise_on = 0; 
028C2:  BCLR.B  85B.1
.................... 	 
.................... 	impulse_g = AngToDo_int; 
028C4:  PUSH    1A4A
028C6:  POP     1A4E
028C8:  PUSH    1A4C
028CA:  POP     1A50
.................... 	impulse_d = 0-AngToDo_int; 
028CC:  MOV     #0,W4
028CE:  MOV     1A4A,W3
028D0:  SUB     W4,W3,W0
028D2:  MOV     W0,1A52
028D4:  MOV     #0,W4
028D6:  MOV     1A4C,W3
028D8:  SUBB    W4,W3,W0
028DA:  MOV     W0,1A54
.................... 	fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
028DC:  MOV     #0,W1
028DE:  MOV     W1,W0
028E0:  CLR.B   1
028E2:  CALL    2D6
028E6:  INC     W1,W1
028E8:  BTSC.B  219.1
028EA:  BRA     28E8
028EC:  MOV     W0,21A
028EE:  MOV     #5,W0
028F0:  CPSGT   W1,W0
028F2:  BRA     28DE
028F4:  MOV     1A4E,W0
028F6:  MOV     1A50,W1
028F8:  MOV     #0,W4
028FA:  CALL    2504
028FE:  MOV     #8,W1
02900:  MOV     W1,W0
02902:  CLR.B   1
02904:  CALL    2D6
02908:  INC     W1,W1
0290A:  BTSC.B  219.1
0290C:  BRA     290A
0290E:  MOV     W0,21A
02910:  MOV     #E,W0
02912:  CPSGT   W1,W0
02914:  BRA     2900
02916:  MOV     1A52,W0
02918:  MOV     1A54,W1
0291A:  MOV     #0,W4
0291C:  CALL    2504
02920:  BTSC.B  219.1
02922:  BRA     2920
02924:  MOV     #20,W4
02926:  MOV     W4,21A
02928:  BTSC.B  219.1
0292A:  BRA     2928
0292C:  MOV     #D,W4
0292E:  MOV     W4,21A
.................... 	 
.................... 	Depl_send = 1; 
02930:  BSET.B  85B.4
.................... 	Orient = (float64)(_Ang * CONV_DEG_RAD); // mise à jour de l'angle 
02932:  MOV     1A40,W0
02934:  CLR     W3
02936:  BTSC    W0.F
02938:  SETM    W3
0293A:  MOV     W3,W1
0293C:  MOV     W3,W2
0293E:  CALL    1AD6
02942:  MOV     150E,W4
02944:  MOV     1510,W5
02946:  MOV     1512,W6
02948:  MOV     1514,W7
0294A:  CALL    BC0
0294E:  MOV     W0,14E6
02950:  MOV     W1,14E8
02952:  MOV     W2,14EA
02954:  MOV     W3,14EC
02956:  MOV     [--W15],W8
02958:  MOV     [--W15],W7
0295A:  MOV     [--W15],W6
0295C:  MOV     [--W15],W5
0295E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __PaP(signed int16 _X, signed int16 _Y) 
.................... * \brief Depl Pap du robot. 
.................... *		Le deplacement se fait tel que : 
.................... *			- Rotation vers le point a  atteindre 
.................... *			- Deplacement ligne droite 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] coordonee x,y de la pos d'arrivee 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __PaP(signed int16 _X, signed int16 _Y) 
*
0327A:  MOV     W5,[W15++]
0327C:  MOV     #C,W5
0327E:  REPEAT  #3
03280:  MOV     [W5++],[W15++]
03282:  CLR     1A54
03284:  CLR     1A56
03286:  CLR     1A58
03288:  CLR     1A5A
0328A:  CLR     1A5C
0328C:  CLR     1A5E
0328E:  CLR     1A60
03290:  CLR     1A62
03292:  CLR     1A64
03294:  CLR     1A66
03296:  CLR     1A68
03298:  CLR     1A6A
0329A:  CLR     1A6C
0329C:  CLR     1A6E
0329E:  CLR     1A70
032A0:  CLR     1A72
032A2:  CLR     1A74
032A4:  CLR     1A76
032A6:  CLR     1A78
032A8:  CLR     1A7A
.................... { 
....................  
.................... 	float64	dx,dy,distToDo = 0;	 
.................... 	signed int32 distToDo_int = 0;	//dist a effectuer 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer 
.................... 	signed int32 impulse_g = 0;	 	//impulse mot gauche 
.................... 	signed int32 impulse_d = 0;		//impulse mot droite 
.................... 	static int1 etat_deplacement = 0; 
.................... 	float64 AngToDo = 0; 
.................... 	float64 temporaire = 0; 
.................... 	 
.................... 	 
.................... 	dx = (_X - Pos_x) * (COEFF_D/10); //calcul deplacment en x et transformation en pas 
032AA:  MOV     1A40,W4
032AC:  MOV     14D8,W3
032AE:  SUB     W4,W3,W5
032B0:  MOV     W5,[W15++]
032B2:  MOV     1506,W0
032B4:  MOV     1508,W1
032B6:  MOV     150A,W2
032B8:  MOV     150C,W3
032BA:  MOV     #0,W4
032BC:  MOV     #0,W5
032BE:  MOV     #0,W6
032C0:  MOV     #4024,W7
032C2:  CALL    CD0
032C6:  MOV     [--W15],W5
032C8:  MOV     W0,W6
032CA:  MOV     W1,W7
032CC:  MOV     W2,W8
032CE:  MOV     W3,W9
032D0:  MOV     W5,W0
032D2:  CLR     W3
032D4:  BTSC    W0.F
032D6:  SETM    W3
032D8:  MOV     W3,W1
032DA:  MOV     W3,W2
032DC:  CALL    1AD6
032E0:  MOV     W5,[W15++]
032E2:  MOV     W6,[W15++]
032E4:  MOV     W7,[W15++]
032E6:  MOV     W6,W4
032E8:  MOV     W7,W5
032EA:  MOV     W8,W6
032EC:  MOV     W9,W7
032EE:  CALL    BC0
032F2:  MOV     [--W15],W7
032F4:  MOV     [--W15],W6
032F6:  MOV     [--W15],W5
032F8:  MOV     W0,1A44
032FA:  MOV     W1,1A46
032FC:  MOV     W2,1A48
032FE:  MOV     W3,1A4A
.................... 	dy = (_Y - Pos_Y) * (COEFF_D/10); //calcul deplacment en y et transformation en pas 
03300:  MOV     1A42,W4
03302:  MOV     14DA,W3
03304:  SUB     W4,W3,W5
03306:  MOV     W5,[W15++]
03308:  MOV     1506,W0
0330A:  MOV     1508,W1
0330C:  MOV     150A,W2
0330E:  MOV     150C,W3
03310:  MOV     #0,W4
03312:  MOV     #0,W5
03314:  MOV     #0,W6
03316:  MOV     #4024,W7
03318:  CALL    CD0
0331C:  MOV     [--W15],W5
0331E:  MOV     W0,W6
03320:  MOV     W1,W7
03322:  MOV     W2,W8
03324:  MOV     W3,W9
03326:  MOV     W5,W0
03328:  CLR     W3
0332A:  BTSC    W0.F
0332C:  SETM    W3
0332E:  MOV     W3,W1
03330:  MOV     W3,W2
03332:  CALL    1AD6
03336:  MOV     W5,[W15++]
03338:  MOV     W6,[W15++]
0333A:  MOV     W7,[W15++]
0333C:  MOV     W6,W4
0333E:  MOV     W7,W5
03340:  MOV     W8,W6
03342:  MOV     W9,W7
03344:  CALL    BC0
03348:  MOV     [--W15],W7
0334A:  MOV     [--W15],W6
0334C:  MOV     [--W15],W5
0334E:  MOV     W0,1A4C
03350:  MOV     W1,1A4E
03352:  MOV     W2,1A50
03354:  MOV     W3,1A52
.................... 	distToDo = sqrt((dx*dx)+(dy*dy)); //calcul de la distance 
03356:  MOV     1A44,W0
03358:  MOV     1A46,W1
0335A:  MOV     1A48,W2
0335C:  MOV     1A4A,W3
0335E:  MOV     1A44,W4
03360:  MOV     1A46,W5
03362:  MOV     1A48,W6
03364:  MOV     1A4A,W7
03366:  CALL    BC0
0336A:  MOV     W0,W5
0336C:  MOV     W1,W6
0336E:  MOV     W2,W7
03370:  MOV     W3,W8
03372:  MOV     W5,[W15++]
03374:  MOV     W6,[W15++]
03376:  MOV     W7,[W15++]
03378:  MOV     1A4C,W0
0337A:  MOV     1A4E,W1
0337C:  MOV     1A50,W2
0337E:  MOV     1A52,W3
03380:  MOV     1A4C,W4
03382:  MOV     1A4E,W5
03384:  MOV     1A50,W6
03386:  MOV     1A52,W7
03388:  CALL    BC0
0338C:  MOV     [--W15],W7
0338E:  MOV     [--W15],W6
03390:  MOV     [--W15],W5
03392:  BCLR.B  43.0
03394:  MOV     W5,[W15++]
03396:  MOV     W6,[W15++]
03398:  MOV     W7,[W15++]
0339A:  MOV     W0,W4
0339C:  MOV     W5,W0
0339E:  MOV     W1,W5
033A0:  MOV     W6,W1
033A2:  MOV     W2,W6
033A4:  MOV     W7,W2
033A6:  MOV     W3,W7
033A8:  MOV     W8,W3
033AA:  CALL    1BEA
033AE:  MOV     [--W15],W7
033B0:  MOV     [--W15],W6
033B2:  MOV     [--W15],W5
033B4:  MOV     W0,W5
033B6:  MOV     W1,W6
033B8:  MOV     W2,W7
033BA:  MOV     W3,W8
033BC:  MOV     W5,1AD0
033BE:  MOV     W6,1AD2
033C0:  MOV     W7,1AD4
033C2:  MOV     W8,1AD6
033C4:  CALL    2960
033C8:  MOV     W0,1A54
033CA:  MOV     W1,1A56
033CC:  MOV     W2,1A58
033CE:  MOV     W3,1A5A
.................... 	distToDo_int = distToDo ; 
033D0:  MOV     1A54,W0
033D2:  MOV     1A56,W1
033D4:  MOV     1A58,W2
033D6:  MOV     1A5A,W3
033D8:  CALL    2A7C
033DC:  MOV     W0,1A5C
033DE:  MOV     W1,1A5E
....................  
.................... 	switch(etat_deplacement) 
033E0:  CLR     W0
033E2:  BTSC.B  14BF.3
033E4:  INC     W0,W0
033E6:  CLR.B   1
033E8:  XOR     #0,W0
033EA:  BRA     Z,33F2
033EC:  XOR     #1,W0
033EE:  BRA     Z,3906
033F0:  BRA     3A1A
.................... 	{ 
.................... 		case 0: // gestion de l'angle 
.................... 		 
.................... 			/////////////////////////////////////////////// 
.................... 			//////////Calcul de l'angle//////////////////// 
.................... 			/////////////////////////////////////////////// 
.................... 				if(dx >= 0) // 1er et 4eme quadrant 
033F2:  MOV     #0,W0
033F4:  MOV     #0,W1
033F6:  MOV     #0,W2
033F8:  MOV     #0,W3
033FA:  MOV     1A44,W4
033FC:  MOV     1A46,W5
033FE:  MOV     1A48,W6
03400:  MOV     1A4A,W7
03402:  CALL    1DD8
03406:  BRA     C,340A
03408:  BRA     NZ,3468
.................... 				{ 
.................... 					AngToDo = asin(dy/distToDo) - Orient;	 
0340A:  MOV     1A4C,W0
0340C:  MOV     1A4E,W1
0340E:  MOV     1A50,W2
03410:  MOV     1A52,W3
03412:  MOV     1A54,W4
03414:  MOV     1A56,W5
03416:  MOV     1A58,W6
03418:  MOV     1A5A,W7
0341A:  CALL    CD0
0341E:  MOV     W0,W5
03420:  MOV     W1,W6
03422:  MOV     W2,W7
03424:  MOV     W3,W8
03426:  MOV     W5,1A84
03428:  MOV     W6,1A86
0342A:  MOV     W7,1A88
0342C:  MOV     W8,1A8A
0342E:  CALL    2EE6
03432:  MOV     W0,W5
03434:  MOV     W1,W6
03436:  MOV     W2,W7
03438:  MOV     W3,W8
0343A:  BSET.B  43.0
0343C:  MOV     W5,[W15++]
0343E:  MOV     W6,[W15++]
03440:  MOV     W7,[W15++]
03442:  MOV     W5,W0
03444:  MOV     W6,W1
03446:  MOV     W7,W2
03448:  MOV     W8,W3
0344A:  MOV     14E6,W4
0344C:  MOV     14E8,W5
0344E:  MOV     14EA,W6
03450:  MOV     14EC,W7
03452:  CALL    1BEA
03456:  MOV     [--W15],W7
03458:  MOV     [--W15],W6
0345A:  MOV     [--W15],W5
0345C:  MOV     W0,1A6C
0345E:  MOV     W1,1A6E
03460:  MOV     W2,1A70
03462:  MOV     W3,1A72
.................... 				} 
03464:  GOTO    35C4
.................... 				 
.................... 				else if(dx <= 0 && dy > 0)//2eme quandrant 
03468:  MOV     1A44,W0
0346A:  MOV     1A46,W1
0346C:  MOV     1A48,W2
0346E:  MOV     1A4A,W3
03470:  MOV     #0,W4
03472:  MOV     #0,W5
03474:  MOV     #0,W6
03476:  MOV     #0,W7
03478:  CALL    1DD8
0347C:  BRA     C,3480
0347E:  BRA     NZ,34F4
03480:  MOV     #0,W0
03482:  MOV     #0,W1
03484:  MOV     #0,W2
03486:  MOV     #0,W3
03488:  MOV     1A4C,W4
0348A:  MOV     1A4E,W5
0348C:  MOV     1A50,W6
0348E:  MOV     1A52,W7
03490:  CALL    1DD8
03494:  BRA     NC,34F4
.................... 				{ 
.................... 					AngToDo = acos(dx/distToDo) - Orient; 
03496:  MOV     1A44,W0
03498:  MOV     1A46,W1
0349A:  MOV     1A48,W2
0349C:  MOV     1A4A,W3
0349E:  MOV     1A54,W4
034A0:  MOV     1A56,W5
034A2:  MOV     1A58,W6
034A4:  MOV     1A5A,W7
034A6:  CALL    CD0
034AA:  MOV     W0,W5
034AC:  MOV     W1,W6
034AE:  MOV     W2,W7
034B0:  MOV     W3,W8
034B2:  MOV     W5,1A84
034B4:  MOV     W6,1A86
034B6:  MOV     W7,1A88
034B8:  MOV     W8,1A8A
034BA:  CALL    2F0E
034BE:  MOV     W0,W5
034C0:  MOV     W1,W6
034C2:  MOV     W2,W7
034C4:  MOV     W3,W8
034C6:  BSET.B  43.0
034C8:  MOV     W5,[W15++]
034CA:  MOV     W6,[W15++]
034CC:  MOV     W7,[W15++]
034CE:  MOV     W5,W0
034D0:  MOV     W6,W1
034D2:  MOV     W7,W2
034D4:  MOV     W8,W3
034D6:  MOV     14E6,W4
034D8:  MOV     14E8,W5
034DA:  MOV     14EA,W6
034DC:  MOV     14EC,W7
034DE:  CALL    1BEA
034E2:  MOV     [--W15],W7
034E4:  MOV     [--W15],W6
034E6:  MOV     [--W15],W5
034E8:  MOV     W0,1A6C
034EA:  MOV     W1,1A6E
034EC:  MOV     W2,1A70
034EE:  MOV     W3,1A72
.................... 				} 
034F0:  GOTO    35C4
.................... 				 
.................... 				else if(dx < 0 && dy <= 0)//3eme quadrant 
034F4:  MOV     1A44,W0
034F6:  MOV     1A46,W1
034F8:  MOV     1A48,W2
034FA:  MOV     1A4A,W3
034FC:  MOV     #0,W4
034FE:  MOV     #0,W5
03500:  MOV     #0,W6
03502:  MOV     #0,W7
03504:  CALL    1DD8
03508:  BRA     NC,35C4
0350A:  MOV     1A4C,W0
0350C:  MOV     1A4E,W1
0350E:  MOV     1A50,W2
03510:  MOV     1A52,W3
03512:  MOV     #0,W4
03514:  MOV     #0,W5
03516:  MOV     #0,W6
03518:  MOV     #0,W7
0351A:  CALL    1DD8
0351E:  BRA     C,3522
03520:  BRA     NZ,35C4
.................... 				{ 
.................... 					AngToDo = asin(abs(dy)/distToDo) + PI - Orient;	 
03522:  MOV     1A4C,W0
03524:  MOV     1A4E,W1
03526:  MOV     1A50,W2
03528:  MOV     1A52,W3
0352A:  BCLR    W3.F
0352C:  MOV     W0,W5
0352E:  MOV     W1,W6
03530:  MOV     W2,W7
03532:  MOV     W3,W8
03534:  MOV     W5,[W15++]
03536:  MOV     W6,[W15++]
03538:  MOV     W7,[W15++]
0353A:  MOV     W5,W0
0353C:  MOV     W6,W1
0353E:  MOV     W7,W2
03540:  MOV     W8,W3
03542:  MOV     1A54,W4
03544:  MOV     1A56,W5
03546:  MOV     1A58,W6
03548:  MOV     1A5A,W7
0354A:  CALL    CD0
0354E:  MOV     [--W15],W7
03550:  MOV     [--W15],W6
03552:  MOV     [--W15],W5
03554:  MOV     W0,W5
03556:  MOV     W1,W6
03558:  MOV     W2,W7
0355A:  MOV     W3,W8
0355C:  MOV     W5,1A84
0355E:  MOV     W6,1A86
03560:  MOV     W7,1A88
03562:  MOV     W8,1A8A
03564:  CALL    2EE6
03568:  MOV     W0,W5
0356A:  MOV     W1,W6
0356C:  MOV     W2,W7
0356E:  MOV     W3,W8
03570:  BCLR.B  43.0
03572:  MOV     W5,[W15++]
03574:  MOV     W6,[W15++]
03576:  MOV     W7,[W15++]
03578:  MOV     W5,W0
0357A:  MOV     W6,W1
0357C:  MOV     W7,W2
0357E:  MOV     W8,W3
03580:  MOV     #2D18,W4
03582:  MOV     #5444,W5
03584:  MOV     #21FB,W6
03586:  MOV     #4009,W7
03588:  CALL    1BEA
0358C:  MOV     [--W15],W7
0358E:  MOV     [--W15],W6
03590:  MOV     [--W15],W5
03592:  MOV     W0,W5
03594:  MOV     W1,W6
03596:  MOV     W2,W7
03598:  MOV     W3,W8
0359A:  BSET.B  43.0
0359C:  MOV     W5,[W15++]
0359E:  MOV     W6,[W15++]
035A0:  MOV     W7,[W15++]
035A2:  MOV     W5,W0
035A4:  MOV     W6,W1
035A6:  MOV     W7,W2
035A8:  MOV     W8,W3
035AA:  MOV     14E6,W4
035AC:  MOV     14E8,W5
035AE:  MOV     14EA,W6
035B0:  MOV     14EC,W7
035B2:  CALL    1BEA
035B6:  MOV     [--W15],W7
035B8:  MOV     [--W15],W6
035BA:  MOV     [--W15],W5
035BC:  MOV     W0,1A6C
035BE:  MOV     W1,1A6E
035C0:  MOV     W2,1A70
035C2:  MOV     W3,1A72
.................... 				} 
.................... 				 
.................... 			//////////////////////////////////////////////// 
.................... 			////////////Gestion de l'angle////////////////// 
.................... 			//////////////////////////////////////////////// 
.................... 				if(oAvAr) 
035C4:  CP0     13B8
035C6:  BRA     Z,3652
.................... 				{ 
.................... 					AngToDo += PI;	 
035C8:  BCLR.B  43.0
035CA:  MOV     1A6C,W0
035CC:  MOV     1A6E,W1
035CE:  MOV     1A70,W2
035D0:  MOV     1A72,W3
035D2:  MOV     #2D18,W4
035D4:  MOV     #5444,W5
035D6:  MOV     #21FB,W6
035D8:  MOV     #4009,W7
035DA:  CALL    1BEA
035DE:  MOV     W0,1A6C
035E0:  MOV     W1,1A6E
035E2:  MOV     W2,1A70
035E4:  MOV     W3,1A72
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
035E6:  MOV     #2D18,W0
035E8:  MOV     #5444,W1
035EA:  MOV     #21FB,W2
035EC:  MOV     #4009,W3
035EE:  MOV     1A6C,W4
035F0:  MOV     1A6E,W5
035F2:  MOV     1A70,W6
035F4:  MOV     1A72,W7
035F6:  CALL    1DD8
035FA:  BRA     NC,361E
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
035FC:  BSET.B  43.0
035FE:  MOV     1A6C,W0
03600:  MOV     1A6E,W1
03602:  MOV     1A70,W2
03604:  MOV     1A72,W3
03606:  MOV     #2D18,W4
03608:  MOV     #5444,W5
0360A:  MOV     #21FB,W6
0360C:  MOV     #4019,W7
0360E:  CALL    1BEA
03612:  MOV     W0,1A6C
03614:  MOV     W1,1A6E
03616:  MOV     W2,1A70
03618:  MOV     W3,1A72
.................... 					} 
0361A:  GOTO    3652
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
0361E:  MOV     1A6C,W0
03620:  MOV     1A6E,W1
03622:  MOV     1A70,W2
03624:  MOV     1A72,W3
03626:  MOV     #2D18,W4
03628:  MOV     #5444,W5
0362A:  MOV     #21FB,W6
0362C:  MOV     #C009,W7
0362E:  CALL    1DD8
03632:  BRA     NC,3652
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
03634:  BCLR.B  43.0
03636:  MOV     1A6C,W0
03638:  MOV     1A6E,W1
0363A:  MOV     1A70,W2
0363C:  MOV     1A72,W3
0363E:  MOV     #2D18,W4
03640:  MOV     #5444,W5
03642:  MOV     #21FB,W6
03644:  MOV     #4019,W7
03646:  CALL    1BEA
0364A:  MOV     W0,1A6C
0364C:  MOV     W1,1A6E
0364E:  MOV     W2,1A70
03650:  MOV     W3,1A72
.................... 					} 
.................... 				}					 
.................... 				if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
03652:  MOV     13BA,W4
03654:  CP      W4,#2
03656:  BRA     NZ,3690
03658:  MOV     #0,W0
0365A:  MOV     #0,W1
0365C:  MOV     #0,W2
0365E:  MOV     #0,W3
03660:  MOV     1A6C,W4
03662:  MOV     1A6E,W5
03664:  MOV     1A70,W6
03666:  MOV     1A72,W7
03668:  CALL    1DD8
0366C:  BRA     NC,3690
.................... 				{ 
.................... 					AngToDo += -2 * PI; //on tourne sur la gauche 
0366E:  BCLR.B  43.0
03670:  MOV     1A6C,W0
03672:  MOV     1A6E,W1
03674:  MOV     1A70,W2
03676:  MOV     1A72,W3
03678:  MOV     #2D18,W4
0367A:  MOV     #5444,W5
0367C:  MOV     #21FB,W6
0367E:  MOV     #C019,W7
03680:  CALL    1BEA
03684:  MOV     W0,1A6C
03686:  MOV     W1,1A6E
03688:  MOV     W2,1A70
0368A:  MOV     W3,1A72
.................... 				}	 
0368C:  GOTO    373E
.................... 				 
.................... 				else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
03690:  MOV     13BA,W4
03692:  CP      W4,#1
03694:  BRA     NZ,36CE
03696:  MOV     1A6C,W0
03698:  MOV     1A6E,W1
0369A:  MOV     1A70,W2
0369C:  MOV     1A72,W3
0369E:  MOV     #0,W4
036A0:  MOV     #0,W5
036A2:  MOV     #0,W6
036A4:  MOV     #0,W7
036A6:  CALL    1DD8
036AA:  BRA     NC,36CE
.................... 				{ 
.................... 					AngToDo += 2 * PI;//On tourne sur la droite	 
036AC:  BCLR.B  43.0
036AE:  MOV     1A6C,W0
036B0:  MOV     1A6E,W1
036B2:  MOV     1A70,W2
036B4:  MOV     1A72,W3
036B6:  MOV     #2D18,W4
036B8:  MOV     #5444,W5
036BA:  MOV     #21FB,W6
036BC:  MOV     #4019,W7
036BE:  CALL    1BEA
036C2:  MOV     W0,1A6C
036C4:  MOV     W1,1A6E
036C6:  MOV     W2,1A70
036C8:  MOV     W3,1A72
.................... 				}				 
036CA:  GOTO    373E
.................... 				 
.................... 				else if(oCoteTourn==0) 
036CE:  CP0     13BA
036D0:  BRA     NZ,373E
.................... 				{ 
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
036D2:  MOV     #2D18,W0
036D4:  MOV     #5444,W1
036D6:  MOV     #21FB,W2
036D8:  MOV     #4009,W3
036DA:  MOV     1A6C,W4
036DC:  MOV     1A6E,W5
036DE:  MOV     1A70,W6
036E0:  MOV     1A72,W7
036E2:  CALL    1DD8
036E6:  BRA     NC,370A
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
036E8:  BSET.B  43.0
036EA:  MOV     1A6C,W0
036EC:  MOV     1A6E,W1
036EE:  MOV     1A70,W2
036F0:  MOV     1A72,W3
036F2:  MOV     #2D18,W4
036F4:  MOV     #5444,W5
036F6:  MOV     #21FB,W6
036F8:  MOV     #4019,W7
036FA:  CALL    1BEA
036FE:  MOV     W0,1A6C
03700:  MOV     W1,1A6E
03702:  MOV     W2,1A70
03704:  MOV     W3,1A72
.................... 					} 
03706:  GOTO    373E
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
0370A:  MOV     1A6C,W0
0370C:  MOV     1A6E,W1
0370E:  MOV     1A70,W2
03710:  MOV     1A72,W3
03712:  MOV     #2D18,W4
03714:  MOV     #5444,W5
03716:  MOV     #21FB,W6
03718:  MOV     #C009,W7
0371A:  CALL    1DD8
0371E:  BRA     NC,373E
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
03720:  BCLR.B  43.0
03722:  MOV     1A6C,W0
03724:  MOV     1A6E,W1
03726:  MOV     1A70,W2
03728:  MOV     1A72,W3
0372A:  MOV     #2D18,W4
0372C:  MOV     #5444,W5
0372E:  MOV     #21FB,W6
03730:  MOV     #4019,W7
03732:  CALL    1BEA
03736:  MOV     W0,1A6C
03738:  MOV     W1,1A6E
0373A:  MOV     W2,1A70
0373C:  MOV     W3,1A72
.................... 					}	 
.................... 				} 
.................... 			if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
0373E:  MOV     #432D,W0
03740:  MOV     #EB1C,W1
03742:  MOV     #36E2,W2
03744:  MOV     #BF1A,W3
03746:  MOV     1A6C,W4
03748:  MOV     1A6E,W5
0374A:  MOV     1A70,W6
0374C:  MOV     1A72,W7
0374E:  CALL    1DD8
03752:  BRA     NC,3772
03754:  MOV     1A6C,W0
03756:  MOV     1A6E,W1
03758:  MOV     1A70,W2
0375A:  MOV     1A72,W3
0375C:  MOV     #432D,W4
0375E:  MOV     #EB1C,W5
03760:  MOV     #36E2,W6
03762:  MOV     #3F1A,W7
03764:  CALL    1DD8
03768:  BRA     NC,3772
0376A:  CLR     1A6C
0376C:  CLR     1A6E
0376E:  CLR     1A70
03770:  CLR     1A72
.................... 			temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
03772:  MOV     14FE,W0
03774:  MOV     1500,W1
03776:  MOV     1502,W2
03778:  MOV     1504,W3
0377A:  MOV     14EE,W4
0377C:  MOV     14F0,W5
0377E:  MOV     14F2,W6
03780:  MOV     14F4,W7
03782:  CALL    CD0
03786:  MOV     W0,W4
03788:  MOV     W1,W5
0378A:  MOV     W2,W6
0378C:  MOV     W3,W7
0378E:  MOV     1A6C,W0
03790:  MOV     1A6E,W1
03792:  MOV     1A70,W2
03794:  MOV     1A72,W3
03796:  CALL    BC0
0379A:  MOV     W0,W5
0379C:  MOV     W1,W6
0379E:  MOV     W2,W7
037A0:  MOV     W3,W8
037A2:  MOV     W5,[W15++]
037A4:  MOV     W6,[W15++]
037A6:  MOV     W7,[W15++]
037A8:  MOV     W5,W0
037AA:  MOV     W6,W1
037AC:  MOV     W7,W2
037AE:  MOV     W8,W3
037B0:  MOV     14F6,W4
037B2:  MOV     14F8,W5
037B4:  MOV     14FA,W6
037B6:  MOV     14FC,W7
037B8:  CALL    BC0
037BC:  MOV     [--W15],W7
037BE:  MOV     [--W15],W6
037C0:  MOV     [--W15],W5
037C2:  MOV     W0,W5
037C4:  MOV     W1,W6
037C6:  MOV     W2,W7
037C8:  MOV     W3,W8
037CA:  MOV     W5,[W15++]
037CC:  MOV     W6,[W15++]
037CE:  MOV     W7,[W15++]
037D0:  MOV     W5,W0
037D2:  MOV     W6,W1
037D4:  MOV     W7,W2
037D6:  MOV     W8,W3
037D8:  MOV     #0,W4
037DA:  MOV     #0,W5
037DC:  MOV     #0,W6
037DE:  MOV     #4000,W7
037E0:  CALL    BC0
037E4:  MOV     [--W15],W7
037E6:  MOV     [--W15],W6
037E8:  MOV     [--W15],W5
037EA:  MOV     W0,W5
037EC:  MOV     W1,W6
037EE:  MOV     W2,W7
037F0:  MOV     W3,W8
037F2:  MOV     W5,[W15++]
037F4:  MOV     W6,[W15++]
037F6:  MOV     W7,[W15++]
037F8:  MOV     W5,W0
037FA:  MOV     W6,W1
037FC:  MOV     W7,W2
037FE:  MOV     W8,W3
03800:  MOV     #2D18,W4
03802:  MOV     #5444,W5
03804:  MOV     #21FB,W6
03806:  MOV     #4009,W7
03808:  CALL    CD0
0380C:  MOV     [--W15],W7
0380E:  MOV     [--W15],W6
03810:  MOV     [--W15],W5
03812:  MOV     W0,1A74
03814:  MOV     W1,1A76
03816:  MOV     W2,1A78
03818:  MOV     W3,1A7A
.................... 			AngToDo_int = (signed int32)(arrondi_float_signed(temporaire)); 
0381A:  MOV     1A74,W0
0381C:  MOV     1A76,W1
0381E:  MOV     1A78,W2
03820:  MOV     1A7A,W3
03822:  CALL    1E5C
03826:  MOV     W1,W5
03828:  MOV     W2,W6
0382A:  MOV     W5,1A80
0382C:  MOV     W6,1A82
0382E:  CALL    23AE
03832:  MOV     W0,1A60
03834:  MOV     W1,1A62
.................... 			/////////////////////////////////////////////////// 
.................... 			/////////////////Envoi de l'angle au Roboteq/////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			if(AngToDo_int != 0) 
03836:  CP0     1A60
03838:  BRA     NZ,383E
0383A:  CP0     1A62
0383C:  BRA     Z,38CA
.................... 			{ 
.................... 				//balise 
.................... 				balise_on = 0; //desactive la balise sur une rotation 
0383E:  BCLR.B  85B.1
.................... 				 
.................... 				fprintf(ROBOTEQ,"!S 1 300_!S 2 300\r"); 
03840:  MOV     #0,W1
03842:  MOV     W1,W0
03844:  CLR.B   1
03846:  CALL    2F6
0384A:  INC     W1,W1
0384C:  BTSC.B  219.1
0384E:  BRA     384C
03850:  MOV     W0,21A
03852:  MOV     #11,W0
03854:  CPSGT   W1,W0
03856:  BRA     3842
.................... 				// on envoie les donnee au ROBOTEQ 
.................... 							 
.................... 				impulse_g = AngToDo_int; 
03858:  PUSH    1A60
0385A:  POP     1A64
0385C:  PUSH    1A62
0385E:  POP     1A66
.................... 				impulse_d = 0-AngToDo_int; 
03860:  MOV     #0,W4
03862:  MOV     1A60,W3
03864:  SUB     W4,W3,W0
03866:  MOV     W0,1A68
03868:  MOV     #0,W4
0386A:  MOV     1A62,W3
0386C:  SUBB    W4,W3,W0
0386E:  MOV     W0,1A6A
.................... 				fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
03870:  MOV     #0,W1
03872:  MOV     W1,W0
03874:  CLR.B   1
03876:  CALL    2D6
0387A:  INC     W1,W1
0387C:  BTSC.B  219.1
0387E:  BRA     387C
03880:  MOV     W0,21A
03882:  MOV     #5,W0
03884:  CPSGT   W1,W0
03886:  BRA     3872
03888:  MOV     1A64,W0
0388A:  MOV     1A66,W1
0388C:  MOV     #0,W4
0388E:  CALL    2504
03892:  MOV     #8,W1
03894:  MOV     W1,W0
03896:  CLR.B   1
03898:  CALL    2D6
0389C:  INC     W1,W1
0389E:  BTSC.B  219.1
038A0:  BRA     389E
038A2:  MOV     W0,21A
038A4:  MOV     #E,W0
038A6:  CPSGT   W1,W0
038A8:  BRA     3894
038AA:  MOV     1A68,W0
038AC:  MOV     1A6A,W1
038AE:  MOV     #0,W4
038B0:  CALL    2504
038B4:  BTSC.B  219.1
038B6:  BRA     38B4
038B8:  MOV     #20,W4
038BA:  MOV     W4,21A
038BC:  BTSC.B  219.1
038BE:  BRA     38BC
038C0:  MOV     #D,W4
038C2:  MOV     W4,21A
.................... 				 
.................... 				etat_deplacement  = 1;	 
038C4:  BSET.B  14BF.3
.................... 			}					 
038C6:  GOTO    38E4
.................... 			else 
.................... 			{			 
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r"); 
038CA:  MOV     #0,W1
038CC:  MOV     W1,W0
038CE:  CLR.B   1
038D0:  CALL    316
038D4:  INC     W1,W1
038D6:  BTSC.B  219.1
038D8:  BRA     38D6
038DA:  MOV     W0,21A
038DC:  MOV     #F,W0
038DE:  CPSGT   W1,W0
038E0:  BRA     38CC
.................... 				etat_deplacement = 1; 
038E2:  BSET.B  14BF.3
.................... 			}	 
.................... 			Orient = (float64)(Orient + AngToDo);	 
038E4:  BCLR.B  43.0
038E6:  MOV     14E6,W0
038E8:  MOV     14E8,W1
038EA:  MOV     14EA,W2
038EC:  MOV     14EC,W3
038EE:  MOV     1A6C,W4
038F0:  MOV     1A6E,W5
038F2:  MOV     1A70,W6
038F4:  MOV     1A72,W7
038F6:  CALL    1BEA
038FA:  MOV     W0,14E6
038FC:  MOV     W1,14E8
038FE:  MOV     W2,14EA
03900:  MOV     W3,14EC
.................... 			break; 
03902:  GOTO    3A1A
.................... 		case 1 : // gestion de la distance 
.................... 		 
.................... 			if(distToDo!=0)//si on doit faire avancer le robot 
03906:  MOV     1A54,W0
03908:  MOV     1A56,W1
0390A:  MOV     1A58,W2
0390C:  MOV     1A5A,W3
0390E:  MOV     #0,W4
03910:  MOV     #0,W5
03912:  MOV     #0,W6
03914:  MOV     #0,W7
03916:  CALL    1DD8
0391A:  BRA     Z,3A12
.................... 			{		 
.................... 				__Check_commande_atteint();  
0391C:  CALL    2F38
.................... 				__Get_enco_value(1);	//recupere la valeur des encos du pt de depart 
03920:  MOV.B   #1,W0L
03922:  MOV.B   W0L,1A7C
03924:  CALL    3014
.................... 				 
.................... 				if(flag_depl_ok == 1)//On attend que le deplacment precedent soit fini(angle) 
03928:  BTSS.B  85A.6
0392A:  BRA     3A0E
.................... 				{ 
.................... 					fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
0392C:  MOV     #0,W1
0392E:  MOV     W1,W0
03930:  CLR.B   1
03932:  CALL    2B4
03936:  INC     W1,W1
03938:  BTSC.B  219.1
0393A:  BRA     3938
0393C:  MOV     W0,21A
0393E:  MOV     #4,W0
03940:  CPSGT   W1,W0
03942:  BRA     392E
03944:  MOV     13BC,W0
03946:  MOV     #8004,W4
03948:  CALL    240A
0394C:  MOV     #9,W1
0394E:  MOV     W1,W0
03950:  CLR.B   1
03952:  CALL    2B4
03956:  INC     W1,W1
03958:  BTSC.B  219.1
0395A:  BRA     3958
0395C:  MOV     W0,21A
0395E:  MOV     #E,W0
03960:  CPSGT   W1,W0
03962:  BRA     394E
03964:  MOV     13BC,W0
03966:  MOV     #8004,W4
03968:  CALL    240A
0396C:  BTSC.B  219.1
0396E:  BRA     396C
03970:  MOV     #20,W4
03972:  MOV     W4,21A
03974:  BTSC.B  219.1
03976:  BRA     3974
03978:  MOV     #D,W4
0397A:  MOV     W4,21A
.................... 					 
.................... 					flag_depl_ok = 0; 
0397C:  BCLR.B  85A.6
.................... 					 
.................... 					if(oAvAr)//si on recule 
0397E:  CP0     13B8
03980:  BRA     Z,399E
.................... 					{		 
.................... 						Balise_set_plage(1);//plage à l'arriere du robot						 
03982:  MOV.B   #1,W0L
03984:  MOV.B   W0L,1A7C
03986:  CALL    3240
.................... 						distToDo_int = 0 - distToDo_int; //impulse negative --> recule 
0398A:  MOV     #0,W4
0398C:  MOV     1A5C,W3
0398E:  SUB     W4,W3,W0
03990:  MOV     W0,1A5C
03992:  MOV     #0,W4
03994:  MOV     1A5E,W3
03996:  SUBB    W4,W3,W0
03998:  MOV     W0,1A5E
.................... 					} 
0399A:  GOTO    39A4
.................... 					else  
.................... 					{ 
.................... 						Balise_set_plage(0);//plage à l'avant du robot 
0399E:  CLR.B   1A7C
039A0:  CALL    3240
.................... 					} 
.................... 					//balise	 
.................... 					balise_on = 1; // active la balise sur un depl 
039A4:  BSET.B  85B.1
.................... 					//////////////////////////////////////////////////// 
.................... 					////////////envoie au Roobreq/////////////////////// 
.................... 					/////////////////////////////////////////////////// 
.................... 	 
.................... 					fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",distToDo_int,distToDo_int);						 
039A6:  MOV     #0,W1
039A8:  MOV     W1,W0
039AA:  CLR.B   1
039AC:  CALL    334
039B0:  INC     W1,W1
039B2:  BTSC.B  219.1
039B4:  BRA     39B2
039B6:  MOV     W0,21A
039B8:  MOV     #5,W0
039BA:  CPSGT   W1,W0
039BC:  BRA     39A8
039BE:  MOV     1A5C,W0
039C0:  MOV     1A5E,W1
039C2:  MOV     #8007,W4
039C4:  CALL    2504
039C8:  MOV     #A,W1
039CA:  MOV     W1,W0
039CC:  CLR.B   1
039CE:  CALL    334
039D2:  INC     W1,W1
039D4:  BTSC.B  219.1
039D6:  BRA     39D4
039D8:  MOV     W0,21A
039DA:  MOV     #10,W0
039DC:  CPSGT   W1,W0
039DE:  BRA     39CA
039E0:  MOV     1A5C,W0
039E2:  MOV     1A5E,W1
039E4:  MOV     #8007,W4
039E6:  CALL    2504
039EA:  BTSC.B  219.1
039EC:  BRA     39EA
039EE:  MOV     #20,W4
039F0:  MOV     W4,21A
039F2:  BTSC.B  219.1
039F4:  BRA     39F2
039F6:  MOV     #D,W4
039F8:  MOV     W4,21A
.................... 					Depl_send = 1;							//indique que l'on a fini d'envoyer les ordres du dÃ©placment 
039FA:  BSET.B  85B.4
.................... 					etat_deplacement = 0; 
039FC:  BCLR.B  14BF.3
.................... 					Dist_x = (signed int16)(_X - Pos_x);	//mise a jour pos x 
039FE:  MOV     1A40,W4
03A00:  MOV     14D8,W3
03A02:  SUB     W4,W3,W0
03A04:  MOV     W0,14D4
.................... 					Dist_y = (signed int16)(_Y - Pos_y); 	//mise a jour pos y 
03A06:  MOV     1A42,W4
03A08:  MOV     14DA,W3
03A0A:  SUB     W4,W3,W0
03A0C:  MOV     W0,14D6
.................... 				}	 
.................... 			} 
03A0E:  GOTO    3A16
.................... 			else 
.................... 			{				 
.................... 				Depl_send = 1; 
03A12:  BSET.B  85B.4
.................... 				etat_deplacement = 0; 
03A14:  BCLR.B  14BF.3
.................... 			} 
.................... 		break; 
03A16:  GOTO    3A1A
.................... 	} 
.................... 	// Quitte la fonction 
.................... 	return; 
03A1A:  MOV     #12,W5
03A1C:  REPEAT  #3
03A1E:  MOV     [--W15],[W5--]
03A20:  MOV     [--W15],W5
03A22:  RETURN  
.................... } 
.................... /* 
.................... 	/** 
.................... * \fn void __Progress(int16 _X, int16 _Y) 
.................... * \brief Fonction utile pour s'etalonner dans un bord  
.................... * \		 s'arrete en detectant une limite de courant  
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 23.2.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Progress(int16 _X, int16 _Y) 
*
04296:  MOV     W5,[W15++]
04298:  MOV     W6,[W15++]
0429A:  MOV     W7,[W15++]
0429C:  MOV     W8,[W15++]
0429E:  CLR     1A44
042A0:  CLR     1A46
042A2:  CLR     1A48
042A4:  CLR     1A4A
042A6:  CLR     1A4C
042A8:  CLR     1A4E
042AA:  CLR     1A50
042AC:  CLR     1A52
042AE:  CLR     1A54
042B0:  CLR     1A56
042B2:  CLR     1A58
042B4:  CLR     1A5A
.................... { 
.................... 	static unsigned int8 etat_depl; 
.................... 	float64 amp = 0;				//courant dans le moteur 1 
.................... 	float64 amp2 = 0;				//courant dans le moteur 2  
.................... 	static int1 m1_stop,m2_stop;	//arret moteur 1 et arret moteur 2 
....................  
.................... 	float64 Dist = 0;  
....................  
.................... 	switch(etat_depl) 
042B6:  MOV.B   152C,W0L
042B8:  CLR.B   1
042BA:  XOR     #0,W0
042BC:  BRA     Z,42C4
042BE:  XOR     #1,W0
042C0:  BRA     Z,4440
042C2:  BRA     4604
.................... 	{ 
.................... 		case 0: 
.................... 		 	Dist = sqrt(((_X - Pos_x) * (_X - Pos_x)) + ((_Y - Pos_y) * (_Y - Pos_y))) + DIST_SECU_PROGRESS; // calcul distance de depl  
042C4:  MOV     1A40,W4
042C6:  MOV     14D8,W3
042C8:  SUB     W4,W3,W5
042CA:  MOV     1A40,W4
042CC:  MOV     14D8,W3
042CE:  SUB     W4,W3,W0
042D0:  MUL.SS  W5,W0,W0
042D2:  MOV     W0,W5
042D4:  MOV     1A42,W4
042D6:  MOV     14DA,W3
042D8:  SUB     W4,W3,W6
042DA:  MOV     1A42,W4
042DC:  MOV     14DA,W3
042DE:  SUB     W4,W3,W0
042E0:  MUL.SS  W6,W0,W0
042E2:  ADD     W0,W5,W0
042E4:  CALL    3A24
042E8:  MOV     W0,W5
042EA:  MOV     W1,W6
042EC:  MOV     W5,1A60
042EE:  MOV     W6,1A62
042F0:  CALL    3B38
042F4:  MOV     W0,W5
042F6:  MOV     W1,W6
042F8:  MOV     14D2,W0
042FA:  CALL    1F34
042FE:  BCLR.B  43.0
04300:  MOV     W0,W2
04302:  MOV     W1,W3
04304:  MOV     W5,W0
04306:  MOV     W6,W1
04308:  CALL    2032
0430C:  MOV     W1,W2
0430E:  MOV     W0,W1
04310:  MOV     #0,W0
04312:  CALL    3C18
04316:  MOV     W0,1A54
04318:  MOV     W1,1A56
0431A:  MOV     W2,1A58
0431C:  MOV     W3,1A5A
.................... 		 	Dist *= (COEFF_D/10);	//conversion mm en pas 
0431E:  MOV     1506,W0
04320:  MOV     1508,W1
04322:  MOV     150A,W2
04324:  MOV     150C,W3
04326:  MOV     #0,W4
04328:  MOV     #0,W5
0432A:  MOV     #0,W6
0432C:  MOV     #4024,W7
0432E:  CALL    CD0
04332:  MOV     W0,W4
04334:  MOV     W1,W5
04336:  MOV     W2,W6
04338:  MOV     W3,W7
0433A:  MOV     1A54,W0
0433C:  MOV     1A56,W1
0433E:  MOV     1A58,W2
04340:  MOV     1A5A,W3
04342:  CALL    BC0
04346:  MOV     W0,1A54
04348:  MOV     W1,1A56
0434A:  MOV     W2,1A58
0434C:  MOV     W3,1A5A
.................... 			flag_depl_ok = 0; 
0434E:  BCLR.B  85A.6
.................... 			 
.................... 			//balise	 
.................... 			balise_on = 1; // active la balise sur un depl				 
04350:  BSET.B  85B.1
.................... 			 
.................... 			if(oAvAr)//si on recule 
04352:  CP0     13B8
04354:  BRA     Z,4380
.................... 			{	 
.................... 				Balise_set_plage(1);//plage à l'arriere du robot					 
04356:  MOV.B   #1,W0L
04358:  MOV.B   W0L,1A7C
0435A:  CALL    3240
.................... 				Dist = 0 - Dist; 	// on inverse la distance 
0435E:  BSET.B  43.0
04360:  MOV     #0,W0
04362:  MOV     #0,W1
04364:  MOV     #0,W2
04366:  MOV     #0,W3
04368:  MOV     1A54,W4
0436A:  MOV     1A56,W5
0436C:  MOV     1A58,W6
0436E:  MOV     1A5A,W7
04370:  CALL    1BEA
04374:  MOV     W0,1A54
04376:  MOV     W1,1A56
04378:  MOV     W2,1A58
0437A:  MOV     W3,1A5A
.................... 			} 
0437C:  GOTO    4386
.................... 			else  
.................... 			{ 
.................... 				Balise_set_plage(0);//plage à l'avant du robot 
04380:  CLR.B   1A7C
04382:  CALL    3240
.................... 			} 
.................... 			//////////////////////////////////////////////////// 
.................... 			////////////envoie au Roobreq/////////////////////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			//__Get_enco_value(1); 
.................... 			 
.................... 			fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax);	 
04386:  MOV     #0,W1
04388:  MOV     W1,W0
0438A:  CLR.B   1
0438C:  CALL    2B4
04390:  INC     W1,W1
04392:  BTSC.B  219.1
04394:  BRA     4392
04396:  MOV     W0,21A
04398:  MOV     #4,W0
0439A:  CPSGT   W1,W0
0439C:  BRA     4388
0439E:  MOV     13BC,W0
043A0:  MOV     #8004,W4
043A2:  CALL    240A
043A6:  MOV     #9,W1
043A8:  MOV     W1,W0
043AA:  CLR.B   1
043AC:  CALL    2B4
043B0:  INC     W1,W1
043B2:  BTSC.B  219.1
043B4:  BRA     43B2
043B6:  MOV     W0,21A
043B8:  MOV     #E,W0
043BA:  CPSGT   W1,W0
043BC:  BRA     43A8
043BE:  MOV     13BC,W0
043C0:  MOV     #8004,W4
043C2:  CALL    240A
043C6:  BTSC.B  219.1
043C8:  BRA     43C6
043CA:  MOV     #20,W4
043CC:  MOV     W4,21A
043CE:  BTSC.B  219.1
043D0:  BRA     43CE
043D2:  MOV     #D,W4
043D4:  MOV     W4,21A
.................... 			fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",Dist,Dist);		 
043D6:  MOV     #0,W1
043D8:  MOV     W1,W0
043DA:  CLR.B   1
043DC:  CALL    2D6
043E0:  INC     W1,W1
043E2:  BTSC.B  219.1
043E4:  BRA     43E2
043E6:  MOV     W0,21A
043E8:  MOV     #5,W0
043EA:  CPSGT   W1,W0
043EC:  BRA     43D8
043EE:  MOV     1A54,W0
043F0:  MOV     1A56,W1
043F2:  MOV     1A58,W2
043F4:  MOV     1A5A,W3
043F6:  MOV     #0,W4
043F8:  CALL    3CF6
043FC:  MOV     #8,W1
043FE:  MOV     W1,W0
04400:  CLR.B   1
04402:  CALL    2D6
04406:  INC     W1,W1
04408:  BTSC.B  219.1
0440A:  BRA     4408
0440C:  MOV     W0,21A
0440E:  MOV     #E,W0
04410:  CPSGT   W1,W0
04412:  BRA     43FE
04414:  MOV     1A54,W0
04416:  MOV     1A56,W1
04418:  MOV     1A58,W2
0441A:  MOV     1A5A,W3
0441C:  MOV     #0,W4
0441E:  CALL    3CF6
04422:  BTSC.B  219.1
04424:  BRA     4422
04426:  MOV     #20,W4
04428:  MOV     W4,21A
0442A:  BTSC.B  219.1
0442C:  BRA     442A
0442E:  MOV     #D,W4
04430:  MOV     W4,21A
.................... 			 
.................... 			etat_depl = 1; 
04432:  MOV.B   #1,W0L
04434:  MOV.B   W0L,152C
.................... 			delay_ms(20); 
04436:  MOV     #14,W0
04438:  CALL    E84
.................... 			 
.................... 			break; 
0443C:  GOTO    4604
.................... 		case 1:  
.................... 			amp = (float64)(__Get_amp(1));	//recup du courant du mot 1 
04440:  MOV     #1,W4
04442:  MOV     W4,1A5C
04444:  CALL    3E92
04448:  MOV     W0,1A44
0444A:  MOV     W1,1A46
0444C:  MOV     W2,1A48
0444E:  MOV     W3,1A4A
.................... 			amp2 =(float64)(__Get_amp(2));	//recup du courant du mot 2 
04450:  MOV     #2,W4
04452:  MOV     W4,1A5C
04454:  CALL    3E92
04458:  MOV     W0,1A4C
0445A:  MOV     W1,1A4E
0445C:  MOV     W2,1A50
0445E:  MOV     W3,1A52
.................... 			amp /= 10;					  	// roboteq envoie 15A pour 1,5A --> /10 
04460:  MOV     1A44,W0
04462:  MOV     1A46,W1
04464:  MOV     1A48,W2
04466:  MOV     1A4A,W3
04468:  MOV     #0,W4
0446A:  MOV     #0,W5
0446C:  MOV     #0,W6
0446E:  MOV     #4024,W7
04470:  CALL    CD0
04474:  MOV     W0,1A44
04476:  MOV     W1,1A46
04478:  MOV     W2,1A48
0447A:  MOV     W3,1A4A
.................... 			amp2 /= 10;					 	// roboteq envoie 15A pour 1,5A --> /10 
0447C:  MOV     1A4C,W0
0447E:  MOV     1A4E,W1
04480:  MOV     1A50,W2
04482:  MOV     1A52,W3
04484:  MOV     #0,W4
04486:  MOV     #0,W5
04488:  MOV     #0,W6
0448A:  MOV     #4024,W7
0448C:  CALL    CD0
04490:  MOV     W0,1A4C
04492:  MOV     W1,1A4E
04494:  MOV     W2,1A50
04496:  MOV     W3,1A52
.................... 			if(amp >= amp_limit)		 	//Seuil courant ds mot 1 detecte  
04498:  MOV     14CA,W0
0449A:  MOV     14CC,W1
0449C:  MOV     14CE,W2
0449E:  MOV     14D0,W3
044A0:  MOV     1A44,W4
044A2:  MOV     1A46,W5
044A4:  MOV     1A48,W6
044A6:  MOV     1A4A,W7
044A8:  CALL    1DD8
044AC:  BRA     C,44B0
044AE:  BRA     NZ,44CA
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 1\r");	//Stop le mot 1  
044B0:  MOV     #0,W1
044B2:  MOV     W1,W0
044B4:  CLR.B   1
044B6:  CALL    358
044BA:  INC     W1,W1
044BC:  BTSC.B  219.1
044BE:  BRA     44BC
044C0:  MOV     W0,21A
044C2:  MOV     #5,W0
044C4:  CPSGT   W1,W0
044C6:  BRA     44B2
.................... 				m1_stop = 1; 
044C8:  BSET.B  14BF.4
.................... 			} 
.................... 			if(amp2 >= amp_limit)			//Seuil courant ds mot 2 detecte 
044CA:  MOV     14CA,W0
044CC:  MOV     14CC,W1
044CE:  MOV     14CE,W2
044D0:  MOV     14D0,W3
044D2:  MOV     1A4C,W4
044D4:  MOV     1A4E,W5
044D6:  MOV     1A50,W6
044D8:  MOV     1A52,W7
044DA:  CALL    1DD8
044DE:  BRA     C,44E2
044E0:  BRA     NZ,44FC
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 2\r");	//Stop le mot 2 
044E2:  MOV     #0,W1
044E4:  MOV     W1,W0
044E6:  CLR.B   1
044E8:  CALL    36C
044EC:  INC     W1,W1
044EE:  BTSC.B  219.1
044F0:  BRA     44EE
044F2:  MOV     W0,21A
044F4:  MOV     #5,W0
044F6:  CPSGT   W1,W0
044F8:  BRA     44E4
.................... 				m2_stop = 1; 
044FA:  BSET.B  14BF.5
.................... 			}	 
.................... 			if(m1_stop==1 && m2_stop==1)	//les 2 moteurs stopes 
044FC:  BTSS.B  14BF.4
044FE:  BRA     456A
04500:  BTSS.B  14BF.5
04502:  BRA     456A
.................... 			{ 
....................  
.................... 				fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); 	//passage en open loop speed 
04504:  MOV     #0,W1
04506:  MOV     W1,W0
04508:  CLR.B   1
0450A:  CALL    380
0450E:  INC     W1,W1
04510:  BTSC.B  219.1
04512:  BRA     4510
04514:  MOV     W0,21A
04516:  MOV     #13,W0
04518:  CPSGT   W1,W0
0451A:  BRA     4506
.................... 				delay_ms(10); 
0451C:  MOV     #A,W0
0451E:  CALL    E84
.................... 				fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); 	//passage en closed loop count postion 
04522:  MOV     #0,W1
04524:  MOV     W1,W0
04526:  CLR.B   1
04528:  CALL    3A2
0452C:  INC     W1,W1
0452E:  BTSC.B  219.1
04530:  BRA     452E
04532:  MOV     W0,21A
04534:  MOV     #13,W0
04536:  CPSGT   W1,W0
04538:  BRA     4524
.................... 								 
.................... 				Depl_send = 1; 							  	//fin du déplacment 
0453A:  BSET.B  85B.4
.................... 				etat_depl = 0; 
0453C:  CLR.B   152C
....................  
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r");	   
0453E:  MOV     #0,W1
04540:  MOV     W1,W0
04542:  CLR.B   1
04544:  CALL    316
04548:  INC     W1,W1
0454A:  BTSC.B  219.1
0454C:  BRA     454A
0454E:  MOV     W0,21A
04550:  MOV     #F,W0
04552:  CPSGT   W1,W0
04554:  BRA     4540
.................... 				 
.................... 				Dist_x = (signed int16)(_X-Pos_x);			//mise a jour pos x 
04556:  MOV     1A40,W4
04558:  MOV     14D8,W3
0455A:  SUB     W4,W3,W0
0455C:  MOV     W0,14D4
.................... 				Dist_y = (signed int16)(_Y-Pos_y);			//mise a jour pos y 
0455E:  MOV     1A42,W4
04560:  MOV     14DA,W3
04562:  SUB     W4,W3,W0
04564:  MOV     W0,14D6
.................... 			} 
04566:  GOTO    4600
.................... 			else // si pos atteinte 
.................... 			{					 
.................... 				__Check_commande_atteint();  
0456A:  CALL    2F38
.................... 				if(flag_depl_ok == 1) //On attend que le deplacment precedent soit fini(angle) 
0456E:  BTSS.B  85A.6
04570:  BRA     4600
.................... 				{ 
.................... 					Dist_x =  cos(Orient) * Dist;			//mise a jour pos x 
04572:  PUSH    14E6
04574:  POP     1A6E
04576:  PUSH    14E8
04578:  POP     1A70
0457A:  PUSH    14EA
0457C:  POP     1A72
0457E:  PUSH    14EC
04580:  POP     1A74
04582:  CALL    3FA0
04586:  MOV     W0,W5
04588:  MOV     W1,W6
0458A:  MOV     W2,W7
0458C:  MOV     W3,W8
0458E:  MOV     W5,[W15++]
04590:  MOV     W6,[W15++]
04592:  MOV     W7,[W15++]
04594:  MOV     W5,W0
04596:  MOV     W6,W1
04598:  MOV     W7,W2
0459A:  MOV     W8,W3
0459C:  MOV     1A54,W4
0459E:  MOV     1A56,W5
045A0:  MOV     1A58,W6
045A2:  MOV     1A5A,W7
045A4:  CALL    BC0
045A8:  MOV     [--W15],W7
045AA:  MOV     [--W15],W6
045AC:  MOV     [--W15],W5
045AE:  CALL    2A7C
045B2:  MOV     W0,14D4
.................... 					Dist_y =  sin(Orient) * Dist;			//mise a jour pos y 
045B4:  PUSH    14E6
045B6:  POP     1A5C
045B8:  PUSH    14E8
045BA:  POP     1A5E
045BC:  PUSH    14EA
045BE:  POP     1A60
045C0:  PUSH    14EC
045C2:  POP     1A62
045C4:  CALL    425A
045C8:  MOV     W0,W5
045CA:  MOV     W1,W6
045CC:  MOV     W2,W7
045CE:  MOV     W3,W8
045D0:  MOV     W5,[W15++]
045D2:  MOV     W6,[W15++]
045D4:  MOV     W7,[W15++]
045D6:  MOV     W5,W0
045D8:  MOV     W6,W1
045DA:  MOV     W7,W2
045DC:  MOV     W8,W3
045DE:  MOV     1A54,W4
045E0:  MOV     1A56,W5
045E2:  MOV     1A58,W6
045E4:  MOV     1A5A,W7
045E6:  CALL    BC0
045EA:  MOV     [--W15],W7
045EC:  MOV     [--W15],W6
045EE:  MOV     [--W15],W5
045F0:  CALL    2A7C
045F4:  MOV     W0,14D6
....................  
.................... 					//remise a zero des varaibles 
.................... 					flag_depl_ok = 0; 
045F6:  BCLR.B  85A.6
.................... 					Depl_send = 1; 
045F8:  BSET.B  85B.4
.................... 					m1_stop = 0; 
045FA:  BCLR.B  14BF.4
.................... 					m2_stop = 0;								 
045FC:  BCLR.B  14BF.5
.................... 					etat_depl = 0;			 
045FE:  CLR.B   152C
.................... 				} 
.................... 			} 
.................... 			break; 
04600:  GOTO    4604
.................... 	} 
04604:  MOV     [--W15],W8
04606:  MOV     [--W15],W7
04608:  MOV     [--W15],W6
0460A:  MOV     [--W15],W5
0460C:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Nothing(void) 
.................... * \brief Passe l'objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
....................  
.................... void __Nothing(void) 
.................... { 
.................... 	flag_depl_ok = 1;  
0460E:  BSET.B  85A.6
.................... 	Depl_send=1; 
04610:  BSET.B  85B.4
.................... 	balise_on = 0; 
04612:  BCLR.B  85B.1
.................... 	// Quitte la fonction 
.................... 	return; 
04614:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __LoadObj(unsigned int8 _Obj) 
.................... * \brief Charge le prochain objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 2.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param [in] _Obj Numero de l'objectif desire 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __LoadObj(unsigned int16 _Obj,unsigned int16 pts) 
*
018A2:  MOV     W5,[W15++]
.................... {	 
.................... 	// Enregistre Xp, en [mm] 
.................... 	oXp=TabObjectifs[_Obj][pts][0]; 
018A4:  MOV     1A40,W4
018A6:  MOV     #138,W3
018A8:  MUL.UU  W4,W3,W0
018AA:  MOV     W0,W5
018AC:  MOV     1A42,W4
018AE:  MUL.UU  W4,#18,W0
018B0:  ADD     W0,W5,W5
018B2:  MOV     #A8A,W4
018B4:  ADD     W5,W4,W0
018B6:  MOV     [W0],[W15++]
018B8:  POP     13B2
....................  
.................... 	// Enregistre Yp, en [mm] 
.................... 	oYp=TabObjectifs[_Obj][pts][1]; 
018BA:  MOV     1A40,W4
018BC:  MOV     #138,W3
018BE:  MUL.UU  W4,W3,W0
018C0:  MOV     W0,W5
018C2:  MOV     1A42,W4
018C4:  MUL.UU  W4,#18,W0
018C6:  ADD     W0,W5,W5
018C8:  ADD     W5,#2,W0
018CA:  MOV     #A8A,W4
018CC:  ADD     W0,W4,W0
018CE:  MOV     [W0],[W15++]
018D0:  POP     13B4
....................  
.................... 	// Enregistre le type de deplacement, en [nbre] 
.................... 	oType=TabObjectifs[_Obj][pts][2]; 
018D2:  MOV     1A40,W4
018D4:  MOV     #138,W3
018D6:  MUL.UU  W4,W3,W0
018D8:  MOV     W0,W5
018DA:  MOV     1A42,W4
018DC:  MUL.UU  W4,#18,W0
018DE:  ADD     W0,W5,W5
018E0:  ADD     W5,#4,W0
018E2:  MOV     #A8A,W4
018E4:  ADD     W0,W4,W0
018E6:  MOV     [W0],[W15++]
018E8:  POP     13B6
....................  
.................... 	// Enregistre si avance ou recule 
.................... 	oAvAr=TabObjectifs[_Obj][pts][3]; 
018EA:  MOV     1A40,W4
018EC:  MOV     #138,W3
018EE:  MUL.UU  W4,W3,W0
018F0:  MOV     W0,W5
018F2:  MOV     1A42,W4
018F4:  MUL.UU  W4,#18,W0
018F6:  ADD     W0,W5,W5
018F8:  ADD     W5,#6,W0
018FA:  MOV     #A8A,W4
018FC:  ADD     W0,W4,W0
018FE:  MOV     [W0],[W15++]
01900:  POP     13B8
....................  
.................... 	// Enregistre le cote duquel tourner 
.................... 	oCoteTourn=TabObjectifs[_Obj][pts][4]; 
01902:  MOV     1A40,W4
01904:  MOV     #138,W3
01906:  MUL.UU  W4,W3,W0
01908:  MOV     W0,W5
0190A:  MOV     1A42,W4
0190C:  MUL.UU  W4,#18,W0
0190E:  ADD     W0,W5,W5
01910:  ADD     W5,#8,W0
01912:  MOV     #A8A,W4
01914:  ADD     W0,W4,W0
01916:  MOV     [W0],[W15++]
01918:  POP     13BA
....................  
.................... 	// Enregistre la vitesse maximum, en [mm/s] (en [0/000] pour RoboteQ) 
.................... 	oVitMax=TabObjectifs[_Obj][pts][5]; 
0191A:  MOV     1A40,W4
0191C:  MOV     #138,W3
0191E:  MUL.UU  W4,W3,W0
01920:  MOV     W0,W5
01922:  MOV     1A42,W4
01924:  MUL.UU  W4,#18,W0
01926:  ADD     W0,W5,W5
01928:  ADD     W5,#A,W0
0192A:  MOV     #A8A,W4
0192C:  ADD     W0,W4,W0
0192E:  MOV     [W0],[W15++]
01930:  POP     13BC
....................  
.................... 	//Enregistre l'action a faire 
.................... 	Obj_Action = TabObjectifs[_Obj][pts][6]; 
01932:  MOV     1A40,W4
01934:  MOV     #138,W3
01936:  MUL.UU  W4,W3,W0
01938:  MOV     W0,W5
0193A:  MOV     1A42,W4
0193C:  MUL.UU  W4,#18,W0
0193E:  ADD     W0,W5,W5
01940:  ADD     W5,#C,W0
01942:  MOV     #A8A,W4
01944:  ADD     W0,W4,W0
01946:  MOV     [W0],[W15++]
01948:  POP     13BE
.................... 	 
.................... 	//Enregistre si le pt est symetrique ou non 
.................... 	Pt_commun = TabObjectifs[_Obj][pts][7]; 
0194A:  MOV     1A40,W4
0194C:  MOV     #138,W3
0194E:  MUL.UU  W4,W3,W0
01950:  MOV     W0,W5
01952:  MOV     1A42,W4
01954:  MUL.UU  W4,#18,W0
01956:  ADD     W0,W5,W5
01958:  ADD     W5,#E,W0
0195A:  MOV     #A8A,W4
0195C:  ADD     W0,W4,W0
0195E:  MOV     [W0],[W15++]
01960:  POP     13C0
.................... 	 
.................... 	//ponderation objectifs 
.................... 	Ponderation = TabObjectifs[_Obj][pts][8];	 
01962:  MOV     1A40,W4
01964:  MOV     #138,W3
01966:  MUL.UU  W4,W3,W0
01968:  MOV     W0,W5
0196A:  MOV     1A42,W4
0196C:  MUL.UU  W4,#18,W0
0196E:  ADD     W0,W5,W5
01970:  ADD     W5,#10,W0
01972:  MOV     #A8A,W4
01974:  ADD     W0,W4,W0
01976:  MOV     [W0],[W15++]
01978:  POP     13C2
.................... 	 
.................... 	//Objectifs fini ou non 
.................... 	Obj_end	= TabObjectifs[_Obj][pts][9];  
0197A:  MOV     1A40,W4
0197C:  MOV     #138,W3
0197E:  MUL.UU  W4,W3,W0
01980:  MOV     W0,W5
01982:  MOV     1A42,W4
01984:  MUL.UU  W4,#18,W0
01986:  ADD     W0,W5,W5
01988:  ADD     W5,#12,W0
0198A:  MOV     #A8A,W4
0198C:  ADD     W0,W4,W0
0198E:  MOV     [W0],[W15++]
01990:  POP     13C4
.................... 	 
.................... 	//prochain objectifs 
.................... 	Next_obj = TabObjectifs[_Obj][pts][10]; 
01992:  MOV     1A40,W4
01994:  MOV     #138,W3
01996:  MUL.UU  W4,W3,W0
01998:  MOV     W0,W5
0199A:  MOV     1A42,W4
0199C:  MUL.UU  W4,#18,W0
0199E:  ADD     W0,W5,W5
019A0:  ADD     W5,#14,W0
019A2:  MOV     #A8A,W4
019A4:  ADD     W0,W4,W0
019A6:  MOV     [W0],[W15++]
019A8:  POP     13C6
.................... 	 
.................... 	keep_obj = TabObjectifs[_Obj][pts][11]; 
019AA:  MOV     1A40,W4
019AC:  MOV     #138,W3
019AE:  MUL.UU  W4,W3,W0
019B0:  MOV     W0,W5
019B2:  MOV     1A42,W4
019B4:  MUL.UU  W4,#18,W0
019B6:  ADD     W0,W5,W5
019B8:  ADD     W5,#16,W0
019BA:  MOV     #A8A,W4
019BC:  ADD     W0,W4,W0
019BE:  MOV     [W0],[W15++]
019C0:  POP     13C8
....................  
.................... 	// Switch les donnees selon la base choisie et le mode 
.................... 	if(TEAM) 
019C2:  BTSS.B  85B.3
019C4:  BRA     1A20
.................... 	{ 
.................... 		switch(oType) 
019C6:  MOV     13B6,W0
019C8:  XOR     #0,W0
019CA:  BRA     Z,19D2
019CC:  XOR     #1,W0
019CE:  BRA     Z,19F2
019D0:  BRA     1A1C
.................... 		{ 
.................... 			case 0 : 
.................... 				if(oXp<=180)oXp=180-oXp; //gestion angle 
019D2:  MOV     13B2,W4
019D4:  MOV     #B4,W3
019D6:  CP      W3,W4
019D8:  BRA     LT,19E6
019DA:  MOV     #B4,W4
019DC:  MOV     13B2,W3
019DE:  SUB     W4,W3,W0
019E0:  MOV     W0,13B2
019E2:  GOTO    19EE
.................... 				else oXp = 540 - oXp; 
019E6:  MOV     #21C,W4
019E8:  MOV     13B2,W3
019EA:  SUB     W4,W3,W0
019EC:  MOV     W0,13B2
.................... 				break; 
019EE:  GOTO    1A20
.................... 			case 1 : 
.................... 				// PaP ou retient sur place, calcul automatique de l'angle, inversion oX et oCoteTourn 
.................... 				// Enregistre Xp, en [mm] 
.................... 				oXp = TableWidth - oXp; 
019F2:  MOV     87C,W4
019F4:  MOV     13B2,W3
019F6:  SUB     W4,W3,W0
019F8:  MOV     W0,13B2
.................... 				// Enregistre le cote duquel tourner 
.................... 				if(oCoteTourn==1)oCoteTourn=2; 
019FA:  MOV     13BA,W4
019FC:  CP      W4,#1
019FE:  BRA     NZ,1A08
01A00:  MOV     #2,W4
01A02:  MOV     W4,13BA
01A04:  GOTO    1A18
.................... 				else if(oCoteTourn==2)oCoteTourn=1; 
01A08:  MOV     13BA,W4
01A0A:  CP      W4,#2
01A0C:  BRA     NZ,1A16
01A0E:  MOV     #1,W4
01A10:  MOV     W4,13BA
01A12:  GOTO    1A18
.................... 				else oCoteTourn=0; 
01A16:  CLR     13BA
.................... 	 
.................... 				break; 
01A18:  GOTO    1A20
.................... 			default : 
.................... 				break; 
01A1C:  GOTO    1A20
.................... 		}		 
.................... 	}						 
01A20:  MOV     [--W15],W5
01A22:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    RDA_isr 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    27.03.2015 
.................... //  Statut :    OK 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Interruption pour la rÃÂ©ception RS232.  
.................... #INT_RDA2 
.................... void RDA2_isr(void) 
*
0057E:  PUSH    42
00580:  PUSH    36
00582:  PUSH    32
00584:  MOV     W0,[W15++]
00586:  MOV     #2,W0
00588:  REPEAT  #C
0058A:  MOV     [W0++],[W15++]
.................... { 
.................... 	// Pour la lecture du caractÃÂ¨re reÃÂ§u 
.................... 	char myChar; 
.................... 	// RÃÂ©ception 
.................... 	myChar = fgetc(ROBOTEQ); 
0058C:  BTSS.B  218.0
0058E:  BRA     58C
00590:  MOV     21C,W0
00592:  MOV.B   W0L,1B3E
.................... 	// Ajout au buffer et incrÃÂ©mentation de la longeur du buffer 
.................... 	RoboteQ_receiveBuffer[RoboteQ_receiveLenght] = myChar; 
00594:  MOV     1516,W4
00596:  LSR     W4,#8,W4
00598:  MOV     #880,W3
0059A:  ADD     W4,W3,W5
0059C:  MOV     1B3E,W0
0059E:  MOV.B   W0L,[W5+#0]
.................... 	RoboteQ_receiveLenght++; 
005A0:  INC.B   1517
.................... 	 
.................... 	// Si on trouve la fin de la commande 
.................... 	if(myChar == '\r') 
005A2:  MOV     1B3E,W4
005A4:  CP.B    W4L,#D
005A6:  BRA     NZ,5AE
.................... 	{ 
.................... 		// On dit qu'on peut lire le buffer de rÃÂ©ception 
.................... 		RoboteQ_receiveToProceed = RoboteQ_receiveLenght; 
005A8:  MOV.B   1517,W0L
005AA:  MOV.B   W0L,1516
.................... 		RoboteQ_receiveLenght=0; 
005AC:  CLR.B   1517
.................... 	} 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "PC/___PC.h" 
.................... /* 
.................... * \file ___PC.h 
.................... * \brief Gère la communication PC (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_H 
.................... #define ___PC_H 
....................  
....................  
....................  
.................... // Config RS232 
005AE:  BCLR.B  87.0
005B0:  MOV     #1A,W0
005B2:  REPEAT  #C
005B4:  MOV     [--W15],[W0--]
005B6:  MOV     [--W15],W0
005B8:  POP     32
005BA:  POP     36
005BC:  POP     42
005BE:  RETFIE  
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=RS232) 
.................... // Config UART 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,stream=UARTi) 
....................  
.................... // Définit quand un tableau est à décoder 
.................... int1 PCh_flagUARTReadyToDecode = 0; 
.................... // Watchdog pour éviter un blocage UART 
.................... int1 PCh_flagUARTWatchdog = 0; 
....................  
....................  
.................... void __Init_UART(void);	// Initialise 
.................... void __UART_Decode(unsigned int32* _Tab);	// Décode une trame 
.................... void __SendBackUART(void); // Renvoi la dernière commande envoyée 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec); // Décode un tableau 
.................... #include "PC/___PC.c" 
.................... /* 
.................... * \file ___PC.c 
.................... * \brief Gère la communication PC (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_C 
.................... #define ___PC_C 
....................  
.................... // Bits & define 
.................... 	// Contient la trame à décoder 
.................... unsigned int8 TabToDecode[256]={0}; 
.................... unsigned int8 PosTabToDecode = 0; 
.................... unsigned int8 ToDoUART = 0; 
.................... 	// Contient les valeurs décodées 
.................... unsigned int32 TabDecoded[256]={0}; 
.................... 	// Attend une réponse 
.................... int1 UARTWaitResp=0; 
.................... 	// Nombre de fois à renvoyer 
.................... unsigned int8 UARTToSendBack=0; 
.................... 	 
....................  
.................... /** 
.................... * \fn void __Init_UART(void) 
.................... * \brief Initie l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Init_UART(void) 
.................... { 
.................... 	// Réception 
.................... 	enable_interrupts(INT_RDA); 
*
00FFE:  BSET.B  8D.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
01000:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void RDA_isr(void) 
.................... * \brief Interruption RDA, récupère les caractères du RS232. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... */ 
.................... #INT_RDA 
.................... void RDA_isr(void) 
*
008DA:  PUSH    42
008DC:  PUSH    36
008DE:  PUSH    32
008E0:  MOV     W0,[W15++]
008E2:  MOV     #2,W0
008E4:  REPEAT  #C
008E6:  MOV     [W0++],[W15++]
.................... {	 
.................... 	// Checksum UART 
.................... 	static unsigned int8 HashR1, HashR2, HashC1, HashC2; 
.................... 	if(PCh_flagUARTReadyToDecode==0) 
008E8:  BTSC.B  14BF.6
008EA:  BRA     A40
.................... 	{ 
.................... 		// Active le watchdog UART 
.................... 		PCh_flagUARTWatchdog = 1; 
008EC:  BSET.B  14BF.7
.................... 		// Traite la réception 
.................... 		while(kbhit(RS232)) 
008EE:  BTSS.B  20E.0
008F0:  BRA     A40
.................... 		{ 
.................... 			// Récupération donnée 
.................... 			unsigned int8 Dataa = fgetc(RS232); 
008F2:  BTSS.B  20E.0
008F4:  BRA     8F2
008F6:  MOV     212,W0
008F8:  MOV.B   W0L,1B3E
.................... 			 
.................... 			// Si c'est une réponse à un envoi, on remet à 0 l'attente de réponse et la fausse erreur 
.................... 			if(UARTWaitResp && Dataa==ACK)  
008FA:  BTSS.B  162F.0
008FC:  BRA     90C
008FE:  MOV     1B3E,W4
00900:  CP.B    W4L,#6
00902:  BRA     NZ,90C
.................... 			{ 
.................... 				UARTWaitResp=0; 
00904:  BCLR.B  162F.0
.................... 				UARTToSendBack=0; 
00906:  CLR.B   1A30
.................... 				 
.................... 			}	 
00908:  GOTO    A3C
.................... 			// Si ce n'est pas OK, renvoie un certain nombre de fois 
.................... 			else if(UARTWaitResp && Dataa==NAK) 
0090C:  BTSS.B  162F.0
0090E:  BRA     932
00910:  MOV     1B3E,W4
00912:  CP.B    W4L,#15
00914:  BRA     NZ,932
.................... 			{ 
.................... 				if(UARTToSendBack<UART_NBR_REP_NAK) {__SendBackUART();UARTToSendBack++;} 
00916:  MOV.B   1A30,W0L
00918:  MOV     13CA,W4
0091A:  LSR     W4,#8,W4
0091C:  CP.B    W4L,W0L
0091E:  BRA     LEU,92A
00920:  CALL    5C0
00924:  INC.B   1A30
00926:  GOTO    92E
.................... 				else {UARTWaitResp=0;UARTToSendBack=0;} 
0092A:  BCLR.B  162F.0
0092C:  CLR.B   1A30
.................... 			} 
0092E:  GOTO    A3C
.................... 			// Réception 
.................... 			else 
.................... 			{	 
.................... 				// Début de transmission 
.................... 				if(Dataa == STX&&ToDoUART==0) 
00932:  MOV     1B3E,W4
00934:  CP.B    W4L,#2
00936:  BRA     NZ,94C
00938:  CP0.B   162E
0093A:  BRA     NZ,94C
.................... 				{ 
.................... 					HashC1 = HashC2 = 0; 
0093C:  CLR.B   1A34
0093E:  MOV.B   1A34,W0L
00940:  MOV.B   W0L,1A33
.................... 					ToDoUART=1;  
00942:  MOV.B   #1,W0L
00944:  MOV.B   W0L,162E
.................... 					PosTabToDecode=0; 
00946:  CLR.B   152D
.................... 				} 
00948:  GOTO    A3C
.................... 				// Fin de transmission 
.................... 				else if(Dataa == ETX&&ToDoUART==5)		 
0094C:  MOV     1B3E,W4
0094E:  CP.B    W4L,#3
00950:  BRA     NZ,9D0
00952:  MOV     162E,W4
00954:  CP.B    W4L,#5
00956:  BRA     NZ,9D0
.................... 				{		 
.................... 					if(HashC1==ETX||HashC1==CR)HashC1++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
00958:  MOV     1A32,W4
0095A:  LSR     W4,#8,W4
0095C:  CP.B    W4L,#3
0095E:  BRA     Z,968
00960:  MOV     1A32,W4
00962:  LSR     W4,#8,W4
00964:  CP.B    W4L,#D
00966:  BRA     NZ,96A
00968:  INC.B   1A33
.................... 					if(HashC2==ETX||HashC2==CR)HashC2++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
0096A:  MOV     1A34,W4
0096C:  CP.B    W4L,#3
0096E:  BRA     Z,976
00970:  MOV     1A34,W4
00972:  CP.B    W4L,#D
00974:  BRA     NZ,978
00976:  INC.B   1A34
.................... 					// Si trame OK 
.................... 					if(HashC1==HashR1 && HashC2==HashR2) 
00978:  MOV.B   1A33,W0L
0097A:  CP.B    1A31
0097C:  BRA     NZ,9BA
0097E:  MOV.B   1A34,W0L
00980:  CP.B    1A32
00982:  BRA     NZ,9BA
.................... 					{ 
.................... 						TabToDecode[PosTabToDecode] = ETX; 
00984:  MOV     152C,W4
00986:  LSR     W4,#8,W4
00988:  MOV     #152E,W3
0098A:  ADD     W4,W3,W5
0098C:  MOV.B   #3,W0L
0098E:  MOV.B   W0L,[W5]
.................... 						// Décode le tableau 
.................... 						__CommDecode(TabToDecode,TabDecoded); 
00990:  MOV     #152E,W4
00992:  MOV     W4,1B40
00994:  MOV     #1630,W4
00996:  MOV     W4,1B42
00998:  CALL    85E
.................... 						if(TabDecoded[0]==UART_ADDR) 
0099C:  MOV     1630,W0
0099E:  CP      13CC
009A0:  BRA     NZ,9B6
009A2:  MOV     1632,W0
009A4:  CP      13CE
009A6:  BRA     NZ,9B6
.................... 						{	 
.................... 							// Dit qu'on est prêts à recevoir 
.................... 							PCh_flagUARTReadyToDecode=1; 
009A8:  BSET.B  14BF.6
.................... 							// Renvoie un simple OK 
.................... 							fputc(ACK,RS232); 
009AA:  MOV.B   #6,W0L
009AC:  BTSC.B  20F.1
009AE:  BRA     9AC
009B0:  MOV.B   W0L,210
009B2:  CLR.B   211
.................... 							// Dit qu'on attend une réponse 
.................... 							UARTWaitResp=1; 
009B4:  BSET.B  162F.0
.................... 						}	 
.................... 					} 
009B6:  GOTO    9C4
.................... 					else fputc(NAK,RS232); // Erreur de réception, envoi un pas ok 
009BA:  MOV.B   #15,W0L
009BC:  BTSC.B  20F.1
009BE:  BRA     9BC
009C0:  MOV.B   W0L,210
009C2:  CLR.B   211
.................... 					ToDoUART = 0; 
009C4:  CLR.B   162E
.................... 					PosTabToDecode=0; 
009C6:  CLR.B   152D
.................... 					UARTToSendBack=0; 
009C8:  CLR.B   1A30
.................... 					// Désactive le watchdog UART 
.................... 					PCh_flagUARTWatchdog = 0; 
009CA:  BCLR.B  14BF.7
.................... 				} 
009CC:  GOTO    A3C
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==1)ToDoUART=2; 
009D0:  MOV     162E,W4
009D2:  CP.B    W4L,#1
009D4:  BRA     NZ,9DE
009D6:  MOV.B   #2,W0L
009D8:  MOV.B   W0L,162E
009DA:  GOTO    A3C
.................... 				// Enregistre le premier Hash 
.................... 				else if(ToDoUART==2) 
009DE:  MOV     162E,W4
009E0:  CP.B    W4L,#2
009E2:  BRA     NZ,9F0
.................... 				{ 
.................... 					HashR1 = Dataa; 
009E4:  MOV.B   1B3E,W0L
009E6:  MOV.B   W0L,1A31
.................... 					ToDoUART=3;	 
009E8:  MOV.B   #3,W0L
009EA:  MOV.B   W0L,162E
.................... 				}	 
009EC:  GOTO    A3C
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==3)ToDoUART=4; 
009F0:  MOV     162E,W4
009F2:  CP.B    W4L,#3
009F4:  BRA     NZ,9FE
009F6:  MOV.B   #4,W0L
009F8:  MOV.B   W0L,162E
009FA:  GOTO    A3C
.................... 				// Enregistre le second Hash 
.................... 				else if(ToDoUART==4) 
009FE:  MOV     162E,W4
00A00:  CP.B    W4L,#4
00A02:  BRA     NZ,A10
.................... 				{ 
.................... 					HashR2 = Dataa; 
00A04:  MOV.B   1B3E,W0L
00A06:  MOV.B   W0L,1A32
.................... 					ToDoUART=5; 
00A08:  MOV.B   #5,W0L
00A0A:  MOV.B   W0L,162E
.................... 				} 
00A0C:  GOTO    A3C
.................... 				// Capture la trame 
.................... 				else if(ToDoUART == 5)  
00A10:  MOV     162E,W4
00A12:  CP.B    W4L,#5
00A14:  BRA     NZ,A3C
.................... 				{ 
.................... 					// Hash les valeurs reçues 
.................... 					HashC1 += Dataa; 
00A16:  MOV.B   1A33,W0L
00A18:  ADD.B   1B3E,W0L
00A1A:  MOV.B   W0L,1A33
.................... 					HashC2 = (HashC2+Dataa)*(PosTabToDecode+1);	 
00A1C:  MOV.B   1A34,W0L
00A1E:  ADD.B   1B3E,W0L
00A20:  MOV.B   W0L,A
00A22:  MOV     152C,W4
00A24:  LSR     W4,#8,W4
00A26:  ADD     W4,#1,W0
00A28:  CLR.B   B
00A2A:  MUL.UU  W5,W0,W0
00A2C:  MOV.B   W0L,1A34
.................... 					// Retire l'incrément ASCII et enregistre 
.................... 					TabToDecode[PosTabToDecode] = Dataa; 
00A2E:  MOV     152C,W4
00A30:  LSR     W4,#8,W4
00A32:  MOV     #152E,W3
00A34:  ADD     W4,W3,W5
00A36:  MOV     1B3E,W0
00A38:  MOV.B   W0L,[W5+#0]
.................... 					 
.................... 					PosTabToDecode++; 
00A3A:  INC.B   152D
.................... 				} 
.................... 			}			 
00A3C:  GOTO    8EE
.................... 		}	 
.................... 	}		 
.................... 	// Quitte l'interruption 
.................... 	return; 
00A40:  BCLR.B  85.1
00A42:  MOV     #1A,W0
00A44:  REPEAT  #C
00A46:  MOV     [--W15],[W0--]
00A48:  MOV     [--W15],W0
00A4A:  POP     32
00A4C:  POP     36
00A4E:  POP     42
00A50:  RETFIE  
.................... } 
....................  
.................... /** 
.................... * \fn void __UART_Decode(char* Tab) 
.................... * \brief Décode la trame de l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \param[in] (*)_Tab Tableau avec lequel travailler 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __UART_Decode(unsigned int32* _Tab) 
*
055E0:  MOV     W5,[W15++]
055E2:  MOV     #C,W5
055E4:  REPEAT  #7
055E6:  MOV     [W5++],[W15++]
055E8:  CLR     1A40
055EA:  CLR     1A44
055EC:  CLR     1A46
055EE:  CLR     1A48
.................... { 
.................... 	unsigned int16 index = 0; 
.................... 	unsigned int16 Xo,Yo = 0; 
.................... 	signed int16 phi = 0;	 
.................... 	static int16 memo; 
.................... 	static int16 Memorise; 
.................... 	unsigned int16 Adresse = 0; 
.................... 	// Regarde quoi faire 
.................... 	switch(*(_Tab+1)) // On saute la première adresse mémoire qui contient l'adresse du driver 
055F0:  MOV     1A3E,W4
055F2:  ADD     W4,#4,W0
055F4:  MOV     W0,W5
055F6:  MOV     #0,W3
055F8:  MOV     [W5++],[W3++]
055FA:  MOV     [W5++],[W3++]
055FC:  CP0     W0
055FE:  BRA     NZ,5604
05600:  CP0     W1
05602:  BRA     Z,5690
05604:  CP      W0,#1
05606:  BRA     NZ,560C
05608:  CP0     W1
0560A:  BRA     Z,569C
0560C:  CP      W0,#2
0560E:  BRA     NZ,5614
05610:  CP0     W1
05612:  BRA     Z,56AA
05614:  CP      W0,#3
05616:  BRA     NZ,561C
05618:  CP0     W1
0561A:  BRA     Z,56B0
0561C:  CP      W0,#4
0561E:  BRA     NZ,5624
05620:  CP0     W1
05622:  BRA     Z,56B4
05624:  CP      W0,#A
05626:  BRA     NZ,562C
05628:  CP0     W1
0562A:  BRA     Z,56B8
0562C:  CP      W0,#B
0562E:  BRA     NZ,5634
05630:  CP0     W1
05632:  BRA     Z,56D4
05634:  CP      W0,#C
05636:  BRA     NZ,563C
05638:  CP0     W1
0563A:  BRA     Z,56D8
0563C:  CP      W0,#14
0563E:  BRA     NZ,5644
05640:  CP0     W1
05642:  BRA     Z,571C
05644:  CP      W0,#15
05646:  BRA     NZ,564C
05648:  CP0     W1
0564A:  BRA     Z,5720
0564C:  CP      W0,#16
0564E:  BRA     NZ,5654
05650:  CP0     W1
05652:  BRA     Z,576E
05654:  CP      W0,#17
05656:  BRA     NZ,565C
05658:  CP0     W1
0565A:  BRA     Z,5780
0565C:  CP      W0,#18
0565E:  BRA     NZ,5664
05660:  CP0     W1
05662:  BRA     Z,57C8
05664:  CP      W0,#19
05666:  BRA     NZ,566C
05668:  CP0     W1
0566A:  BRA     Z,583C
0566C:  CP      W0,#1E
0566E:  BRA     NZ,5674
05670:  CP0     W1
05672:  BRA     Z,584A
05674:  CP      W0,#1F
05676:  BRA     NZ,567C
05678:  CP0     W1
0567A:  BRA     Z,584E
0567C:  CP      W0,#13
0567E:  BRA     NZ,5684
05680:  CP0     W1
05682:  BRA     Z,5852
05684:  MOV     #32,W4
05686:  CP      W0,W4
05688:  BRA     NZ,568E
0568A:  CP0     W1
0568C:  BRA     Z,58AC
0568E:  BRA     58B0
.................... 	{ 
.................... 		// Test Comm - LED Blink 
.................... 		case 0 : 
.................... 			_LED1=_LED2=_LED3=_LED4=1; 
05690:  BSET.B  2D0.4
05692:  BSET.B  2D0.3
05694:  BSET.B  2D0.2
05696:  BSET.B  2D0.1
.................... 			break; 
05698:  GOTO    58CC
.................... 		// Demande si est connecté	 
.................... 		case 1 : 
.................... 			fputc(0x31,RS232); 
0569C:  MOV.B   #31,W0L
0569E:  BTSC.B  20F.1
056A0:  BRA     569E
056A2:  MOV.B   W0L,210
056A4:  CLR.B   211
.................... 			break; 
056A6:  GOTO    58CC
.................... 		// Reset la plaque 
.................... 		case 2 : 
.................... 			reset_cpu(); 
056AA:  RESET   
.................... 			break; 
056AC:  GOTO    58CC
.................... 		// Demande si RoboteQ connecté 
.................... 		case 3 : 
.................... 			// ? 
.................... 			break; 
056B0:  GOTO    58CC
.................... 		// Configuration du robot 
.................... 		case 4 :			 
.................... 			break; 
056B4:  GOTO    58CC
.................... 		// Change d'objectif 
.................... 		case 10 : 
.................... 			flagMarche = (int1)(*(_Tab+2)); 
056B8:  MOV     1A3E,W4
056BA:  ADD     W4,#8,W0
056BC:  MOV     W0,[W15++]
056BE:  MOV.B   [W0],W0L
056C0:  MOV.B   W0L,FEF
056C2:  MOV     [--W15],W0
056C4:  CLR     W0
056C6:  BTSC.B  FEF.0
056C8:  INC     W0,W0
056CA:  BCLR.B  85B.7
056CC:  BTSC.B  0.0
056CE:  BSET.B  85B.7
.................... 			break; 
056D0:  GOTO    58CC
.................... 		//	Arrêt d'urgence 
.................... 		case 11 : 
.................... 			 
.................... 			break; 
056D4:  GOTO    58CC
.................... 		// Set la position de départ 
.................... 		case 12 : 
.................... 			Xo = *(_Tab+2); 
056D8:  MOV     1A3E,W4
056DA:  ADD     W4,#8,W0
056DC:  MOV     [W0],[W15++]
056DE:  POP     1A42
.................... 			Yo = *(_Tab+3); 
056E0:  MOV     1A3E,W4
056E2:  ADD     W4,#C,W0
056E4:  MOV     [W0],[W15++]
056E6:  POP     1A44
.................... 			phi = *(_Tab+4); 
056E8:  MOV     1A3E,W4
056EA:  ADD     W4,#10,W0
056EC:  MOV     W0,W4
056EE:  MOV     #0,W3
056F0:  MOV     [W4++],[W3++]
056F2:  MOV     [W4++],[W3++]
056F4:  MOV     W0,1A46
.................... 			 
.................... 			write_eeprom(800,Xo); 
056F6:  MOV     #320,W0
056F8:  MOV     #1A42,W1
056FA:  MOV     #2,W2
056FC:  CALL    511A
.................... 			write_eeprom(802,Yo); 
05700:  MOV     #322,W0
05702:  MOV     #1A44,W1
05704:  MOV     #2,W2
05706:  CALL    511A
.................... 			write_eeprom(804,phi); 
0570A:  MOV     #324,W0
0570C:  MOV     #1A46,W1
0570E:  MOV     #2,W2
05710:  CALL    511A
.................... 			 
.................... 			__Init_pos();	 
05714:  CALL    1B40
.................... 			break; 
05718:  GOTO    58CC
.................... 		 
.................... 		// Enregistre le nombre d'objectifs 
.................... 		case 20 : 
.................... 			break; 
0571C:  GOTO    58CC
.................... 		// Sauvegarde un objectif en EEPROM 
.................... 		case 21 : 
.................... 			for(index = memo; index <  (memo + 28); index += 2) 
05720:  PUSH    1A36
05722:  POP     1A40
05724:  MOV     1A36,W4
05726:  ADD     W4,#1C,W0
05728:  MOV     1A40,W4
0572A:  CP      W4,W0
0572C:  BRA     GE,5762
.................... 			{ 
.................... 				write_eeprom(index, *( _Tab +((index - memo)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0572E:  MOV     1A40,W4
05730:  MOV     1A36,W3
05732:  SUB     W4,W3,W5
05734:  MOV     W5,W4
05736:  MOV     #2,W3
05738:  REPEAT  #11
0573A:  DIV.S   W4,W3
0573C:  MOV     W0,W5
0573E:  MOV     W5,W4
05740:  MUL.UU  W4,#4,W0
05742:  MOV     1A3E,W4
05744:  ADD     W0,W4,W5
05746:  ADD     W5,#C,W0
05748:  MOV     #A,W4
0574A:  MOV     [W0++],[W4++]
0574C:  MOV     [W0++],[W4++]
0574E:  MOV     1A40,W0
05750:  MOV     #A,W1
05752:  MOV     #2,W2
05754:  CALL    511A
05758:  MOV     1A40,W4
0575A:  ADD     W4,#2,W0
0575C:  MOV     W0,1A40
0575E:  GOTO    5724
.................... 			} 
.................... 			memo = index; //offset afin d'aler écrie plus loin dans l'eeprom 
05762:  PUSH    1A40
05764:  POP     1A36
.................... 			__ReadObjectifs(); 
05766:  CALL    1A3C
.................... 		break; 
0576A:  GOTO    58CC
.................... 		// Définit le prochain objectif à charger 
.................... 		case 22 : 
.................... 			NextObj=(unsigned int16)*(_Tab+2); 
0576E:  MOV     1A3E,W4
05770:  ADD     W4,#8,W0
05772:  MOV     W0,W4
05774:  MOV     #0,W3
05776:  MOV     [W4++],[W3++]
05778:  MOV     [W4++],[W3++]
0577A:  MOV     W0,13D6
.................... 			break; 
0577C:  GOTO    58CC
.................... 		// Set les PIDs de roboteQ 
.................... 		case 23 : 
.................... 			while(index<250)//reset le tableau 
05780:  MOV     1A40,W4
05782:  MOV     #FA,W3
05784:  CP      W3,W4
05786:  BRA     LEU,5798
.................... 			{ 
.................... 				 TabSentRS232[index] = '\r'; 
05788:  MOV     #980,W4
0578A:  MOV     1A40,W3
0578C:  ADD     W3,W4,W5
0578E:  MOV.B   #D,W0L
05790:  MOV.B   W0L,[W5]
.................... 				 index++; 
05792:  INC     1A40
05794:  GOTO    5780
.................... 			} 
.................... 			index = 0; 
05798:  CLR     1A40
.................... 			index = 0; 
0579A:  CLR     1A40
.................... 			while(index<10) // on recupere les donnees 
0579C:  MOV     1A40,W4
0579E:  CP      W4,#A
057A0:  BRA     C,57B0
.................... 			{ 
.................... 				 __GetRoboteqPID(index); 
057A2:  MOV.B   1A40,W0L
057A4:  MOV.B   W0L,1A4A
057A6:  CALL    5154
.................... 				 index++; 
057AA:  INC     1A40
057AC:  GOTO    579C
057B0:  PUSH    42
057B2:  BCLR.B  81.7
057B4:  SETM.B  42
057B6:  BSET.B  81.7
.................... 			} 
.................... 			__SendBackUART(); // on envoie a la plaque 
057B8:  CALL    5C0
057BC:  BCLR.B  81.7
057BE:  POP     42
057C0:  BSET.B  81.7
.................... 			index = 0; 
057C2:  CLR     1A40
.................... 			break; 
057C4:  GOTO    58CC
.................... 		case 24 : 
.................... 			__SetRoboteqPID(*(_Tab+2),*(_Tab+3),*(_Tab+4),*(_Tab+5),*(_Tab+6),*(_Tab+7),*(_Tab+8),*(_Tab+9),*(_Tab+10),*(_Tab+11)); 
057C8:  MOV     1A3E,W4
057CA:  ADD     W4,#8,W0
057CC:  MOV     #A,W4
057CE:  MOV     [W0++],[W4++]
057D0:  MOV     [W0++],[W4++]
057D2:  MOV     1A3E,W4
057D4:  ADD     W4,#C,W0
057D6:  MOV     [W0],W7
057D8:  MOV     1A3E,W4
057DA:  ADD     W4,#10,W0
057DC:  MOV     [W0],W8
057DE:  MOV     1A3E,W4
057E0:  ADD     W4,#14,W0
057E2:  MOV     [W0],W9
057E4:  MOV     1A3E,W4
057E6:  ADD     W4,#18,W0
057E8:  MOV     [W0],W10
057EA:  MOV     1A3E,W4
057EC:  ADD     W4,#1C,W0
057EE:  MOV     [W0],W11
057F0:  MOV     #20,W4
057F2:  MOV     1A3E,W3
057F4:  ADD     W3,W4,W0
057F6:  MOV     [W0],W12
057F8:  MOV     #24,W4
057FA:  MOV     1A3E,W3
057FC:  ADD     W3,W4,W0
057FE:  MOV     [W0],W13
05800:  MOV     #28,W4
05802:  MOV     1A3E,W3
05804:  ADD     W3,W4,W0
05806:  MOV     [W0],[W15++]
05808:  POP     1A4A
0580A:  MOV     #2C,W4
0580C:  MOV     1A3E,W3
0580E:  ADD     W3,W4,W0
05810:  MOV     [W0],[W15++]
05812:  POP     1A4C
05814:  PUSH    1A60
05816:  MOV.B   W5L,[W15-#2]
05818:  POP     1A60
0581A:  MOV     W7,1A62
0581C:  MOV     W8,1A64
0581E:  MOV     W9,1A66
05820:  MOV     W10,1A68
05822:  MOV     W11,1A6A
05824:  MOV     W12,1A6C
05826:  MOV     W13,1A6E
05828:  PUSH    1A4A
0582A:  POP     1A70
0582C:  PUSH    1A4C
0582E:  POP     1A72
05830:  CALL    5350
.................... 			__reset_Roboteq(); 
05834:  CALL    551C
.................... 			break; 
05838:  GOTO    58CC
.................... 		 
.................... 		//erase eeprom 
.................... 		case 25 : 
.................... 			__resetEEPROM(); 
0583C:  CALL    5540
.................... 			reset_cpu();     
05840:  RESET   
.................... 			break;		 
05842:  GOTO    58CC
.................... 		 
.................... 			break; 
05846:  GOTO    58CC
.................... 		// Ouvre ou ferme l'étau 
.................... 		case 30 : 
.................... 			break; 
0584A:  GOTO    58CC
.................... 		// Position hold ou release du servo 
.................... 		case 31 : 
.................... 			break;			 
0584E:  GOTO    58CC
.................... 		case 19 : 
.................... 			for(Adresse = Memorise ; Adresse <= 16 + Memorise ; Adresse += 2) 
05852:  PUSH    1A38
05854:  POP     1A48
05856:  MOV     #10,W0
05858:  ADD     1A38,W0
0585A:  MOV     1A48,W4
0585C:  CP      W4,W0
0585E:  BRA     GT,58A0
.................... 			{ 
.................... 				write_eeprom(Adresse + 200 , *( _Tab +((Adresse - Memorise)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
05860:  MOV     #C8,W4
05862:  MOV     1A48,W3
05864:  ADD     W3,W4,W5
05866:  MOV     1A48,W4
05868:  MOV     1A38,W3
0586A:  SUB     W4,W3,W6
0586C:  MOV     W6,W4
0586E:  MOV     #2,W3
05870:  REPEAT  #11
05872:  DIV.S   W4,W3
05874:  MOV     W0,W6
05876:  MOV     W6,W4
05878:  MUL.UU  W4,#4,W0
0587A:  MOV     1A3E,W4
0587C:  ADD     W0,W4,W6
0587E:  ADD     W6,#C,W0
05880:  MOV     #C,W4
05882:  MOV     [W0++],[W4++]
05884:  MOV     [W0++],[W4++]
05886:  MOV     W5,W0
05888:  MOV     #C,W1
0588A:  MOV     #2,W2
0588C:  CALL    511A
.................... 				delay_ms(5); 
05890:  MOV     #5,W0
05892:  CALL    E84
05896:  MOV     1A48,W4
05898:  ADD     W4,#2,W0
0589A:  MOV     W0,1A48
0589C:  GOTO    5856
.................... 			} 
.................... 			Memorise = Adresse; //offset afin d'aler écrie plus loin dans l'eeprom 
058A0:  PUSH    1A48
058A2:  POP     1A38
.................... 			__ReadZones_Interdites();		 
058A4:  CALL    5568
.................... 			break; 
058A8:  GOTO    58CC
.................... 		// Ne lit plus les objectifs en ROM avant une nouvelle écriture	 
.................... 		case 50 :			 
.................... 			break;	 
058AC:  GOTO    58CC
.................... 			 
.................... 			// Avertit le PC d'une action inconnue 
.................... 		default : 
.................... 			fprintf(RS232,"Carte Principale : Commande Inconnue\r"); 
058B0:  MOV     #0,W1
058B2:  MOV     W1,W0
058B4:  CLR.B   1
058B6:  CALL    3C4
058BA:  INC     W1,W1
058BC:  BTSC.B  20F.1
058BE:  BRA     58BC
058C0:  MOV     W0,210
058C2:  MOV     #24,W0
058C4:  CPSGT   W1,W0
058C6:  BRA     58B2
.................... 			break; 
058C8:  GOTO    58CC
.................... 	} 
.................... 	 
.................... 	// Permet de recevoir à nouveau 
.................... 	PCh_flagUARTReadyToDecode = 0; 
058CC:  BCLR.B  14BF.6
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
058CE:  MOV     #1A,W5
058D0:  REPEAT  #7
058D2:  MOV     [--W15],[W5--]
058D4:  MOV     [--W15],W5
058D6:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __SendBackUART(void) 
.................... * \brief Envoi des commandes en UART 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.01.2016 
.................... * 
.................... * \return Ne retourne rien 
....................  
.................... */ 
.................... void __SendBackUART(void) 
*
005C0:  MOV     W5,[W15++]
005C2:  MOV     #980,W4
005C4:  MOV     W4,1B42
005C6:  CLR.B   1B40
.................... { 
.................... 	char* ptrBuffy = TabSentRS232; 
.................... 	// Envoi commande 
.................... 	unsigned int8 ToEndSend=0; 
.................... 	while(*(ptrBuffy+ToEndSend)!='\r' && *(ptrBuffy+ToEndSend)!=ETX) // Attend de voir la fin de tableau 
005C8:  MOV     1B40,W4
005CA:  CLR.B   9
005CC:  MOV     1B42,W3
005CE:  ADD     W3,W4,W0
005D0:  MOV.B   [W0],W4L
005D2:  CP.B    W4L,#D
005D4:  BRA     Z,5FE
005D6:  MOV     1B40,W4
005D8:  CLR.B   9
005DA:  MOV     1B42,W3
005DC:  ADD     W3,W4,W0
005DE:  MOV.B   [W0],W4L
005E0:  CP.B    W4L,#3
005E2:  BRA     Z,5FE
.................... 	{ 
.................... 		fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi la commande 
005E4:  MOV     1B40,W4
005E6:  CLR.B   9
005E8:  MOV     1B42,W3
005EA:  ADD     W3,W4,W0
005EC:  MOV.B   [W0],W5L
005EE:  MOV.B   W5L,W0L
005F0:  BTSC.B  20F.1
005F2:  BRA     5F0
005F4:  MOV.B   W0L,210
005F6:  CLR.B   211
.................... 		ToEndSend++; 
005F8:  INC.B   1B40
005FA:  GOTO    5C8
.................... 	}	 
.................... 	fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi le caractère de fin de commande 
005FE:  MOV     1B40,W4
00600:  CLR.B   9
00602:  MOV     1B42,W3
00604:  ADD     W3,W4,W0
00606:  MOV.B   [W0],W5L
00608:  MOV.B   W5L,W0L
0060A:  BTSC.B  20F.1
0060C:  BRA     60A
0060E:  MOV.B   W0L,210
00610:  CLR.B   211
.................... 	TabSentRS232[ToEndSend]=*(ptrBuffy+ToEndSend); 
00612:  MOV     1B40,W4
00614:  CLR.B   9
00616:  MOV     #980,W3
00618:  ADD     W4,W3,W5
0061A:  MOV     1B40,W4
0061C:  CLR.B   9
0061E:  MOV     1B42,W3
00620:  ADD     W3,W4,W0
00622:  MOV.B   [W0],[W5]
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
00624:  MOV     [--W15],W5
00626:  RETURN  
.................... }	 
....................  
.................... // Décode un tableau 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec) 
*
0085E:  MOV     W5,[W15++]
00860:  MOV.B   #1,W0L
00862:  MOV.B   W0L,1B44
00864:  CLR.B   1B45
00866:  CLR.B   1B46
.................... { 
.................... 	// Permet de se balader dans le tableau 
.................... 	unsigned int8 i=1,j=0,ki=0; 
.................... 	char TempTab[11]={0}; // Taille max d'un int32 + NULL 
00868:  CLR     1B48
0086A:  CLR     1B4A
0086C:  CLR     1B4C
0086E:  CLR     1B4E
00870:  CLR     1B50
00872:  CLR.B   1B52
.................... 	// On décode tout 
.................... 	while(_TabToDec[i]!=ETX) 
00874:  MOV     1B44,W4
00876:  CLR.B   9
00878:  MOV     W4,W0
0087A:  ADD     1B40,W0
0087C:  MOV.B   [W0],W4L
0087E:  CP.B    W4L,#3
00880:  BRA     Z,8D6
.................... 	{ 
.................... 		// On cherche la fin d'un nombre 
.................... 		while(_TabToDec[i]!=SPACE) 
00882:  MOV     1B44,W4
00884:  CLR.B   9
00886:  MOV     W4,W0
00888:  ADD     1B40,W0
0088A:  MOV.B   [W0],W4L
0088C:  XOR.B   #20,W4L
0088E:  BRA     Z,8AA
.................... 		{ 
.................... 			TempTab[j]=(char)(_TabToDec[i]); 
00890:  MOV     1B44,W4
00892:  LSR     W4,#8,W4
00894:  MOV     #1B48,W3
00896:  ADD     W4,W3,W5
00898:  MOV     1B44,W4
0089A:  CLR.B   9
0089C:  MOV     W4,W0
0089E:  ADD     1B40,W0
008A0:  MOV.B   [W0],[W5]
.................... 			i++;j++; 
008A2:  INC.B   1B44
008A4:  INC.B   1B45
008A6:  GOTO    882
.................... 		}	 
.................... 		TempTab[j]=NUL; 
008AA:  MOV     1B44,W4
008AC:  LSR     W4,#8,W4
008AE:  MOV     #1B48,W3
008B0:  ADD     W4,W3,W5
008B2:  CLR.B   [W5]
.................... 		i++;j=0; 
008B4:  INC.B   1B44
008B6:  CLR.B   1B45
.................... 		// On enregistre le nombres 
.................... 		_TabDec[ki]=(unsigned int32)atoi32(TempTab); 
008B8:  MOV.B   1B46,W0L
008BA:  CLR.B   1
008BC:  SL      W0,#2,W0
008BE:  MOV     1B42,W4
008C0:  ADD     W0,W4,W5
008C2:  MOV     #1B48,W4
008C4:  MOV     W4,1B54
008C6:  CALL    66A
008CA:  MOV     #0,W4
008CC:  MOV     [W4++],[W5++]
008CE:  MOV     [W4++],[W5++]
.................... 		ki++; 
008D0:  INC.B   1B46
008D2:  GOTO    874
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
008D6:  MOV     [--W15],W5
008D8:  RETURN  
.................... }	 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////// 
.................... // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // 
.................... // La plage ROM 0 Ã  511 est rÃ©servÃ©e aux objectifs. // 
.................... // 512/513 : Nombre d'objectifs 
.................... // 514/515 : Si des objectifs sont chargÃ©s 
.................... ////////////////////////////////////////////////////// 
....................  
.................... //******************************************************************************** 
.................... //*  Main 
.................... //**************************************************************************************************** 
.................... void main(void) 
*
058D8:  MOV     W5,[W15++]
058DA:  MOV     W6,[W15++]
058DC:  MOV     W7,[W15++]
058DE:  MOV     #2000,W15
058E0:  MOV     #27FF,W0
058E2:  MOV     W0,20
058E4:  NOP     
058E6:  MOV     #7444,W0
058E8:  MOV     W0,94
058EA:  MOV     #4744,W0
058EC:  MOV     W0,96
058EE:  BSET.B  81.7
058F0:  BCLR.B  2E4.3
058F2:  BCLR.B  2E4.2
058F4:  BCLR.B  2E8.2
058F6:  BCLR.B  2E8.3
058F8:  BSET.B  207.7
058FA:  BSET.B  207.5
058FC:  BSET.B  206.6
058FE:  BCLR.B  207.3
05900:  BSET.B  206.7
05902:  BCLR.B  207.0
05904:  BSET.B  207.1
05906:  BCLR.B  207.2
05908:  CLR     20A
0590A:  MOV     #C2,W4
0590C:  MOV     W4,204
0590E:  MOV     #8000,W4
05910:  MOV     W4,216
05912:  MOV     #400,W4
05914:  MOV     W4,218
05916:  MOV     #A,W4
05918:  MOV     W4,21E
0591A:  BCLR.B  85A.0
0591C:  BCLR.B  85A.1
0591E:  BCLR.B  85A.2
05920:  BCLR.B  85A.3
05922:  BCLR.B  85A.4
05924:  BCLR.B  85A.5
05926:  BCLR.B  85A.6
05928:  BCLR.B  85A.7
0592A:  BCLR.B  85B.0
0592C:  BCLR.B  85B.1
0592E:  BCLR.B  85B.2
05930:  BCLR.B  85B.3
05932:  CLR     85C
05934:  CLR     85E
05936:  CLR.B   860
05938:  CLR     862
0593A:  CLR     864
0593C:  CLR     866
0593E:  CLR     868
05940:  CLR     86A
05942:  CLR     86C
05944:  CLR.B   861
05946:  CLR.B   86E
05948:  MOV.B   #6,W0L
0594A:  MOV.B   W0L,86F
0594C:  CLR.B   870
0594E:  CLR.B   871
05950:  CLR.B   872
05952:  MOV.B   #1,W0L
05954:  MOV.B   W0L,873
05956:  MOV.B   #1,W0L
05958:  MOV.B   W0L,874
0595A:  CLR     876
0595C:  CLR     878
0595E:  CLR.B   875
05960:  CLR.B   87A
05962:  CLR.B   87B
05964:  BCLR.B  85B.4
05966:  BCLR.B  85B.5
05968:  MOV     #BB8,W4
0596A:  MOV     W4,87C
0596C:  CLR.B   87E
0596E:  MOV     #3E8,W4
05970:  MOV     W4,A80
05972:  MOV.B   #A,W0L
05974:  MOV.B   W0L,87F
05976:  CLR     A82
05978:  CLR     A84
0597A:  CLR     A86
0597C:  CLR     A88
0597E:  BCLR.B  85B.6
05980:  CLR     13B2
05982:  CLR     13B4
05984:  CLR     13B6
05986:  CLR     13B8
05988:  CLR     13BA
0598A:  CLR     13BC
0598C:  CLR     13BE
0598E:  CLR     13C0
05990:  CLR     13C2
05992:  CLR     13C4
05994:  CLR     13C6
05996:  CLR     13C8
05998:  MOV.B   #14,W0L
0599A:  MOV.B   W0L,13CA
0599C:  MOV.B   #5,W0L
0599E:  MOV.B   W0L,13CB
059A0:  MOV     #2,W4
059A2:  MOV     W4,13CC
059A4:  CLR     13CE
059A6:  MOV.B   #3,W0L
059A8:  MOV.B   W0L,13D0
059AA:  MOV     #C8,W4
059AC:  MOV     W4,13D2
059AE:  BCLR.B  85B.7
059B0:  CLR     13D4
059B2:  CLR     13D6
059B4:  CLR     1496
059B6:  MOV     #5AA,W4
059B8:  MOV     W4,1498
059BA:  MOV     #7D0,W4
059BC:  MOV     W4,149A
059BE:  MOV     #4B0,W4
059C0:  MOV     W4,149C
059C2:  CLR     149E
059C4:  CLR     14A0
059C6:  CLR.B   13D1
059C8:  BCLR.B  14A2.0
059CA:  BCLR.B  14A2.1
059CC:  BCLR.B  14A2.2
059CE:  CLR     14A4
059D0:  CLR     14A6
059D2:  MOV.B   #3,W0L
059D4:  MOV.B   W0L,14A3
059D6:  CLR.B   14A8
059D8:  MOV     #C8,W4
059DA:  MOV     W4,14AC
059DC:  CLR.B   14A9
059DE:  BCLR.B  14A2.3
059E0:  CLR.B   14AE
059E2:  CLR.B   14AF
059E4:  CLR.B   14B0
059E6:  BCLR.B  14A2.4
059E8:  BCLR.B  14A2.5
059EA:  BCLR.B  14A2.6
059EC:  BCLR.B  14A2.7
059EE:  BCLR.B  14B1.0
059F0:  BCLR.B  14B1.1
059F2:  BCLR.B  14B1.2
059F4:  CLR.B   14B4
059F6:  BCLR.B  14B1.3
059F8:  CLR.B   14B5
059FA:  BCLR.B  14B1.5
059FC:  CLR.B   14B6
059FE:  BCLR.B  14B1.6
05A00:  CLR.B   14B7
05A02:  BCLR.B  14B1.7
05A04:  CLR.B   14B8
05A06:  CLR.B   14B9
05A08:  CLR     14BA
05A0A:  CLR     14BC
05A0C:  CLR.B   14BE
05A0E:  BCLR.B  14BF.0
05A10:  CLR     14C0
05A12:  CLR     14C2
05A14:  CLR     14C4
05A16:  CLR.B   14C6
05A18:  MOV.B   #1,W0L
05A1A:  MOV.B   W0L,14C7
05A1C:  BCLR.B  14BF.1
05A1E:  CLR.B   14C8
05A20:  BCLR.B  14BF.2
05A22:  CLR.B   14C9
05A24:  MOV     #999A,W4
05A26:  MOV     W4,14CA
05A28:  MOV     #9999,W4
05A2A:  MOV     W4,14CC
05A2C:  MOV     #9999,W4
05A2E:  MOV     W4,14CE
05A30:  MOV     #3FF9,W4
05A32:  MOV     W4,14D0
05A34:  MOV     #64,W4
05A36:  MOV     W4,14D2
05A38:  CLR     14D6
05A3A:  CLR     14D8
05A3C:  CLR     14DA
05A3E:  CLR     14DC
05A40:  CLR     14DE
05A42:  CLR     14E0
05A44:  CLR     14E2
05A46:  CLR     14E4
05A48:  CLR     14E6
05A4A:  CLR     14E8
05A4C:  CLR     14EA
05A4E:  CLR     14EC
05A50:  MOV     #F8B6,W4
05A52:  MOV     W4,14EE
05A54:  MOV     #14,W4
05A56:  MOV     W4,14F0
05A58:  MOV     #D9E3,W4
05A5A:  MOV     W4,14F2
05A5C:  MOV     #400B,W4
05A5E:  MOV     W4,14F4
05A60:  CLR     14F6
05A62:  CLR     14F8
05A64:  MOV     #8800,W4
05A66:  MOV     W4,14FA
05A68:  MOV     #40B3,W4
05A6A:  MOV     W4,14FC
05A6C:  MOV     #6DDB,W4
05A6E:  MOV     W4,14FE
05A70:  MOV     #9A17,W4
05A72:  MOV     W4,1500
05A74:  MOV     #84EB,W4
05A76:  MOV     W4,1502
05A78:  MOV     #403D,W4
05A7A:  MOV     W4,1504
05A7C:  MOV     14F6,W0
05A7E:  MOV     14F8,W1
05A80:  MOV     14FA,W2
05A82:  MOV     14FC,W3
05A84:  MOV     #0,W4
05A86:  MOV     #0,W5
05A88:  MOV     #0,W6
05A8A:  MOV     #4010,W7
05A8C:  CALL    BC0
05A90:  MOV     W0,W5
05A92:  MOV     W1,W6
05A94:  MOV     W2,W7
05A96:  MOV     W3,W8
05A98:  MOV     W5,[W15++]
05A9A:  MOV     W6,[W15++]
05A9C:  MOV     W7,[W15++]
05A9E:  MOV     14EE,W0
05AA0:  MOV     14F0,W1
05AA2:  MOV     14F2,W2
05AA4:  MOV     14F4,W3
05AA6:  MOV     #2D18,W4
05AA8:  MOV     #5444,W5
05AAA:  MOV     #21FB,W6
05AAC:  MOV     #4009,W7
05AAE:  CALL    BC0
05AB2:  MOV     [--W15],W7
05AB4:  MOV     [--W15],W6
05AB6:  MOV     [--W15],W5
05AB8:  MOV     W5,[W15++]
05ABA:  MOV     W6,[W15++]
05ABC:  MOV     W7,[W15++]
05ABE:  MOV     W0,W4
05AC0:  MOV     W5,W0
05AC2:  MOV     W1,W5
05AC4:  MOV     W6,W1
05AC6:  MOV     W2,W6
05AC8:  MOV     W7,W2
05ACA:  MOV     W3,W7
05ACC:  MOV     W8,W3
05ACE:  CALL    CD0
05AD2:  MOV     [--W15],W7
05AD4:  MOV     [--W15],W6
05AD6:  MOV     [--W15],W5
05AD8:  MOV     W0,1506
05ADA:  MOV     W1,1508
05ADC:  MOV     W2,150A
05ADE:  MOV     W3,150C
05AE0:  MOV     #9D39,W4
05AE2:  MOV     W4,150E
05AE4:  MOV     #A252,W4
05AE6:  MOV     W4,1510
05AE8:  MOV     #DF46,W4
05AEA:  MOV     W4,1512
05AEC:  MOV     #3F91,W4
05AEE:  MOV     W4,1514
05AF0:  CLR.B   1516
05AF2:  CLR.B   1517
05AF4:  CLR     1518
05AF6:  CLR     151A
05AF8:  CLR     151C
05AFA:  CLR     151E
05AFC:  CLR     1520
05AFE:  CLR     1522
05B00:  CLR     1524
05B02:  CLR     1526
05B04:  CLR     1528
05B06:  CLR     152A
05B08:  BCLR.B  14BF.3
05B0A:  MOV     #8000,W4
05B0C:  MOV     W4,20C
05B0E:  MOV     #400,W4
05B10:  MOV     W4,20E
05B12:  MOV     #A,W4
05B14:  MOV     W4,214
05B16:  BCLR.B  14BF.6
05B18:  BCLR.B  14BF.7
05B1A:  CLR.B   152D
05B1C:  CLR.B   162E
05B1E:  BCLR.B  162F.0
05B20:  CLR.B   1A30
05B22:  CLR     1A3A
05B24:  BCLR.B  162F.1
05B26:  SETM    2A8
05B28:  MOV     [--W15],W7
05B2A:  MOV     [--W15],W6
05B2C:  MOV     [--W15],W5
05B2E:  BCLR.B  14B1.4
05B30:  BCLR.B  14BF.4
05B32:  BCLR.B  14BF.5
05B34:  BRA     5BEE
05B36:  DATA    C2,00,08
05B38:  DATA    80,00,C9
05B3A:  DATA    28,0A,8A
05B3C:  DATA    00,C0,06
05B3E:  DATA    13,D8,00
05B40:  DATA    00,4B,F0
05B42:  DATA    3F,5C,0A
05B44:  DATA    58,F6,3B
05B46:  DATA    8F,00,C0
05B48:  DATA    3C,8B,28
05B4A:  DATA    AC,3C,BE
05B4C:  DATA    F6,3F,D2
05B4E:  DATA    D5,44,16
05B50:  DATA    8C,15,D7
05B52:  DATA    BF,69,00
05B54:  DATA    5A,2E,1B
05B56:  DATA    87,99,3F
05B58:  DATA    9A,5F,AD
05B5A:  DATA    4B,91,E4
05B5C:  DATA    01,C0,5D
05B5E:  DATA    11,2F,92
05B60:  DATA    E4,81,FB
05B62:  DATA    3F,38,DA
05B64:  DATA    91,80,9D
05B66:  DATA    C5,E0,BF
05B68:  DATA    6F,12,C0
05B6A:  DATA    B4,C3,09
05B6C:  DATA    AB,3F,6B
05B6E:  DATA    C1,03,4E
05B70:  DATA    C1,B5,45
05B72:  DATA    BF,F7,40
05B74:  DATA    05,FF,00
05B76:  DATA    5C,EF,3F
05B78:  DATA    F3,A3,E2
05B7A:  DATA    F7,D7,FF
05B7C:  DATA    01,40,C0
05B7E:  DATA    B4,FF,05
05B80:  DATA    3C,58,FC
05B82:  DATA    3F,3B,D3
05B84:  DATA    C0,B5,BA
05B86:  DATA    8C,E2,3F
05B88:  DATA    39,D3,C7
05B8A:  DATA    3D,41,79
05B8C:  DATA    B2,3F,87
05B8E:  DATA    0D,3C,50
05B90:  DATA    D0,AF,62
05B92:  DATA    3F,30,4B
05B94:  DATA    8D,A2,82
05B96:  DATA    AA,04,40
05B98:  DATA    09,A0,40
05B9A:  DATA    4A,05,76
05B9C:  DATA    03,40,EC
05B9E:  DATA    9E,37,88
05BA0:  DATA    A6,44,F0
05BA2:  DATA    3F,8F,12
05BA4:  DATA    8D,29,9A
05BA6:  DATA    5B,C7,3F
05BA8:  DATA    0E,E0,80
05BAA:  DATA    7C,A1,D8
05BAC:  DATA    86,3F,29
05BAE:  DATA    4B,FB,95
05BB0:  DATA    C2,37,1A
05BB2:  DATA    3F,00,00
05BB4:  DATA    80,02,14
05BB6:  DATA    AA,00,00
05BB8:  DATA    80,02,14
05BBA:  DATA    B2,00,00
05BBC:  DATA    80,01,15
05BBE:  DATA    2C,00,C1
05BC0:  DATA    00,15,2E
05BC2:  DATA    00,C4,00
05BC4:  DATA    16,30,00
05BC6:  DATA    80,04,1A
05BC8:  DATA    31,00,00
05BCA:  DATA    00,00,80
05BCC:  DATA    04,1A,36
05BCE:  DATA    00,00,00
05BD0:  DATA    00,00,00
05BD2:  INC     W2,W2
05BD4:  CP      W2,#1
05BD6:  BRA     NZ,5BE0
05BD8:  TBLRDL  [W1],W3
05BDA:  TBLRDH  [W1++],W4
05BDC:  MOV.B   6,W0L
05BDE:  RETURN  
05BE0:  CP      W2,#2
05BE2:  BRA     NZ,5BE8
05BE4:  MOV.B   7,W0L
05BE6:  RETURN  
05BE8:  MOV.B   8,W0L
05BEA:  CLR     W2
05BEC:  RETURN  
05BEE:  MOV     #0,W6
05BF0:  MOV     #0,W0
05BF2:  MOV     W0,32
05BF4:  MOV     #5B36,W0
05BF6:  MOV     W0,W1
05BF8:  CLR     W2
05BFA:  CALL    5BD2
05BFE:  MOV.B   W0L,B
05C00:  CALL    5BD2
05C04:  MOV.B   W0L,A
05C06:  CP0     W5
05C08:  BRA     Z,5C3C
05C0A:  BTSS    W5.F
05C0C:  BRA     5C1C
05C0E:  CALL    5BD2
05C12:  MOV.B   W0L,D
05C14:  CALL    5BD2
05C18:  MOV.B   W0L,C
05C1A:  BCLR    W5.F
05C1C:  BTSS    W5.E
05C1E:  BRA     5C30
05C20:  BCLR    W5.E
05C22:  DEC     W5,W5
05C24:  CALL    5BD2
05C28:  MOV.B   W0L,W7L
05C2A:  REPEAT  W5
05C2C:  MOV.B   W7L,[W6++]
05C2E:  BRA     5BFA
05C30:  CALL    5BD2
05C34:  MOV.B   W0L,[W6++]
05C36:  DEC     W5,W5
05C38:  BRA     NZ,5C30
05C3A:  BRA     5BFA
.................... { 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////	INITIALISATION DE TOUS LES MODULES	//////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 		// Initialisation du dsPIC 
.................... 	__Init_dsPIC();	 
05C3C:  CALL    F44
.................... //	delay_ms(1300);  
.................... 	__Init_UART(); 
05C40:  CALL    FFE
.................... 	//__Init_pos(); 
.................... 	delay_ms(1000); 
05C44:  MOV     #3E8,W0
05C46:  CALL    E84
.................... 	 
.................... 		// Check si dÃ©marreur en place 
.................... 	if(!_DEMA)__Affichage_Erreur(1); 
05C4A:  BTSC.B  2C3.2
05C4C:  BRA     5C56
05C4E:  MOV.B   #1,W0L
05C50:  MOV.B   W0L,1A4A
05C52:  CALL    1002
....................  
.................... 		// Mise en place du servo 
....................  
.................... 		__Init_Servos(); 
05C56:  CALL    100A
.................... 		MoveServo(0,9); 
05C5A:  CLR     1A3E
05C5C:  MOV     #9,W4
05C5E:  MOV     W4,1A40
05C60:  CALL    1050
.................... 				 
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 			// Configuration de la balise 
.................... 		Balise_config_plage(0, 12, 14);	// En avanÃ§ant 
05C64:  CLR.B   1A3E
05C66:  MOV.B   #C,W0L
05C68:  MOV.B   W0L,1A3F
05C6A:  MOV.B   #E,W0L
05C6C:  MOV.B   W0L,1A40
05C6E:  CALL    1086
.................... 	delay_ms(100); 
05C72:  MOV     #64,W0
05C74:  CALL    E84
.................... 		Balise_config_plage(1, 4, 6); // En reculant 
05C78:  MOV.B   #1,W0L
05C7A:  MOV.B   W0L,1A3E
05C7C:  MOV.B   #4,W0L
05C7E:  MOV.B   W0L,1A3F
05C80:  MOV.B   #6,W0L
05C82:  MOV.B   W0L,1A40
05C84:  CALL    1086
.................... 	delay_ms(100); 
05C88:  MOV     #64,W0
05C8A:  CALL    E84
....................  
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 		// Set la base 
.................... 		// On n'affiche pas l'erreur ici car si on dÃ©branche le driver de dÃ©placement 
.................... 		// pour envoyer les objectifs, cela bloquerait le systÃ¨me 
.................... //	unsigned int8 ToSetBase=0; 
.................... 	if(_TEAM==0) 
05C8E:  BTSC.B  2C3.4
05C90:  BRA     5C9C
.................... 	{ 
.................... 		_LDT1=0; 
05C92:  BCLR.B  2D6.5
.................... 		_LDT2=1; 
05C94:  BSET.B  2D6.6
.................... 		Team=0; 
05C96:  BCLR.B  85B.3
.................... 	} 
05C98:  GOTO    5CA6
.................... 	else if(_TEAM==1) 
05C9C:  BTSS.B  2C3.4
05C9E:  BRA     5CA6
.................... 	{ 
.................... 		_LDT2=0; 
05CA0:  BCLR.B  2D6.6
.................... 		_LDT1=1; 
05CA2:  BSET.B  2D6.5
.................... 		Team=1; 
05CA4:  BSET.B  85B.3
.................... 	}	 
.................... 	fprintf(ROBOTEQ,"!MG\r"); 
05CA6:  MOV     #0,W1
05CA8:  MOV     W1,W0
05CAA:  CLR.B   1
05CAC:  CALL    3F6
05CB0:  INC     W1,W1
05CB2:  BTSC.B  219.1
05CB4:  BRA     5CB2
05CB6:  MOV     W0,21A
05CB8:  MOV     #3,W0
05CBA:  CPSGT   W1,W0
05CBC:  BRA     5CA8
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 			 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	/////////////////////////////////	PROGRAMME PRINCIPAL	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	int1 action_ok1 = 0; 
.................... 	int1 action_ok2 = 0; 
.................... 	int1 action_ok3 = 0; 
.................... 	int1 barillet_inplace = 0; 
05CBE:  BCLR.B  1A3C.0
05CC0:  BCLR.B  1A3C.1
05CC2:  BCLR.B  1A3C.2
05CC4:  BCLR.B  1A3C.3
....................  	 
.................... 	while(!barillet_inplace) barillet_inPlace=__GoToZero(); 
05CC6:  BTSC.B  1A3C.3
05CC8:  BRA     5CD8
05CCA:  CALL    12FA
05CCE:  BCLR.B  1A3C.3
05CD0:  BTSC.B  0.0
05CD2:  BSET.B  1A3C.3
05CD4:  GOTO    5CC6
.................... 	barillet_inplace = 0; 
05CD8:  BCLR.B  1A3C.3
.................... 	while(!barillet_inplace) barillet_inPlace=Ejecte(); 
05CDA:  BTSC.B  1A3C.3
05CDC:  BRA     5CEC
05CDE:  CALL    17DC
05CE2:  BCLR.B  1A3C.3
05CE4:  BTSC.B  0.0
05CE6:  BSET.B  1A3C.3
05CE8:  GOTO    5CDA
....................  
.................... 	while(1) 
.................... 	{ 
.................... 		switch(Etat_rob) 
05CEC:  MOV.B   875,W0L
05CEE:  CLR.B   1
05CF0:  XOR     #0,W0
05CF2:  BRA     Z,5D06
05CF4:  XOR     #1,W0
05CF6:  BRA     Z,5D7A
05CF8:  XOR     #3,W0
05CFA:  BRA     Z,5DDA
05CFC:  XOR     #1,W0
05CFE:  BRA     Z,5E72
05D00:  XOR     #7,W0
05D02:  BRA     Z,5F3A
05D04:  BRA     5F86
.................... 		{ 
.................... 			case Init: 
.................... 				 
.................... 				if(NbreObjectifs > 0 && !_DEMA  && !flag_end)//si on a des objectifs et qu'il sont charger 
05D06:  CP0     13D4
05D08:  BRA     Z,5D4A
05D0A:  BTSC.B  2C3.2
05D0C:  BRA     5D4A
05D0E:  BTSC.B  85A.7
05D10:  BRA     5D4A
.................... 				{ 
.................... 					if(BeginTimeMS==0)  
05D12:  CP0     866
05D14:  BRA     NZ,5D28
05D16:  CP0     868
05D18:  BRA     NZ,5D28
.................... 					{ 
.................... 						BeginTimeMS = RealTimeMS; 
05D1A:  PUSH    862
05D1C:  POP     866
05D1E:  PUSH    864
05D20:  POP     868
.................... 						delay_ms(1000);  
05D22:  MOV     #3E8,W0
05D24:  CALL    E84
.................... 					} 
.................... 					__Afficheur_7segments(0); 
05D28:  CLR.B   1A4A
05D2A:  CLR.B   1A4B
05D2C:  CALL    139E
.................... 					__LoadObj(NoObj,NoPts);//on mets l'objectifs dans des variables 
05D30:  MOV.B   873,W0L
05D32:  MOV.B   W0L,1A40
05D34:  CLR.B   1A41
05D36:  MOV.B   874,W0L
05D38:  MOV.B   W0L,1A42
05D3A:  CLR.B   1A43
05D3C:  CALL    18A2
.................... 					Etat_rob = Send_depl_action;//on change d'eta 
05D40:  MOV.B   #1,W0L
05D42:  MOV.B   W0L,875
.................... 					Depl_send = 0;			 
05D44:  BCLR.B  85B.4
.................... 				} 
05D46:  GOTO    5D76
.................... 				else if(NbreObjectifs == 0) 
05D4A:  CP0     13D4
05D4C:  BRA     NZ,5D60
.................... 				{ 
.................... 					__Afficheur_7segments(1); 
05D4E:  MOV.B   #1,W0L
05D50:  MOV.B   W0L,1A4A
05D52:  CLR.B   1A4B
05D54:  CALL    139E
.................... 				//	__ReadZones_Interdites(); 
.................... 					__ReadObjectifs();	 
05D58:  CALL    1A3C
.................... 				} 
05D5C:  GOTO    5D76
.................... 				else if(_DEMA == 1 && NbreObjectifs != 0) 
05D60:  BTSS.B  2C3.2
05D62:  BRA     5D76
05D64:  CP0     13D4
05D66:  BRA     Z,5D76
.................... 				{				 
.................... 					__Afficheur_7segments(2); 
05D68:  MOV.B   #2,W0L
05D6A:  MOV.B   W0L,1A4A
05D6C:  CLR.B   1A4B
05D6E:  CALL    139E
.................... 					__Init_pos();					 
05D72:  CALL    1B40
.................... 				} 
.................... 				break; 
05D76:  GOTO    5F92
.................... 			 
.................... 			case Send_depl_action: 
.................... 				__Afficheur_7segments(5); 
05D7A:  MOV.B   #5,W0L
05D7C:  MOV.B   W0L,1A4A
05D7E:  CLR.B   1A4B
05D80:  CALL    139E
.................... 				if(!Depl_send && !flag_end)//si le deplacement n'as pas ete envoye 
05D84:  BTSC.B  85B.4
05D86:  BRA     5D9E
05D88:  BTSC.B  85A.7
05D8A:  BRA     5D9E
.................... 				{ 
.................... 					__Afficheur_7segments(6); 
05D8C:  MOV.B   #6,W0L
05D8E:  MOV.B   W0L,1A4A
05D90:  CLR.B   1A4B
05D92:  CALL    139E
.................... 					__DeplToDo(oType);//envoie le dÃ©placment 
05D96:  MOV.B   13B6,W0L
05D98:  MOV.B   W0L,1A3E
05D9A:  CALL    4616
.................... 				} 
.................... 				if(!Action_send && !flag_end)//si l'action n'a pas ete envoyee 
05D9E:  BTSC.B  85B.6
05DA0:  BRA     5DB8
05DA2:  BTSC.B  85A.7
05DA4:  BRA     5DB8
.................... 				{ 
.................... 					__Afficheur_7segments(7); 
05DA6:  MOV.B   #7,W0L
05DA8:  MOV.B   W0L,1A4A
05DAA:  CLR.B   1A4B
05DAC:  CALL    139E
.................... 					__Action_Writting(obj_Action);//envoie l'action 
05DB0:  MOV.B   13BE,W0L
05DB2:  MOV.B   W0L,1A3E
05DB4:  CALL    4C1A
.................... 				} 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
05DB8:  BTSS.B  85B.4
05DBA:  BRA     5DD6
05DBC:  BTSS.B  85B.6
05DBE:  BRA     5DD6
05DC0:  BTSC.B  85A.7
05DC2:  BRA     5DD6
.................... 				{ 
.................... 					__Afficheur_7segments(8); 
05DC4:  MOV.B   #8,W0L
05DC6:  MOV.B   W0L,1A4A
05DC8:  CLR.B   1A4B
05DCA:  CALL    139E
.................... 					Depl_send = 0; 
05DCE:  BCLR.B  85B.4
.................... 					Action_send = 0; 
05DD0:  BCLR.B  85B.6
.................... 					Etat_rob = Depl_action_process; 
05DD2:  MOV.B   #2,W0L
05DD4:  MOV.B   W0L,875
.................... 				} 
.................... 				break; 
05DD6:  GOTO    5F92
.................... 			 
.................... 			case Depl_action_process : 
.................... 				__Afficheur_7segments(9); 
05DDA:  MOV.B   #9,W0L
05DDC:  MOV.B   W0L,1A4A
05DDE:  CLR.B   1A4B
05DE0:  CALL    139E
.................... 				__Check_commande_atteint(); 
05DE4:  CALL    2F38
.................... 				action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
05DE8:  MOV.B   #C0,W0L
05DEA:  MOV.B   W0L,1A46
05DEC:  CALL    13F2
05DF0:  BCLR.B  1A3C.0
05DF2:  BTSC.B  0.0
05DF4:  BSET.B  1A3C.0
.................... 				action_ok2 = __Check_action_end(0xC2); 
05DF6:  MOV.B   #C2,W0L
05DF8:  MOV.B   W0L,1A46
05DFA:  CALL    13F2
05DFE:  BCLR.B  1A3C.1
05E00:  BTSC.B  0.0
05E02:  BSET.B  1A3C.1
.................... 				action_ok3 = __Check_action_end(0xC4); 
05E04:  MOV.B   #C4,W0L
05E06:  MOV.B   W0L,1A46
05E08:  CALL    13F2
05E0C:  BCLR.B  1A3C.2
05E0E:  BTSC.B  0.0
05E10:  BSET.B  1A3C.2
.................... 				if(flag_depl_ok && action_ok1 && action_ok2 && action_ok3 && !flag_end && !_Detected)//on attend que tout soit fini 
05E12:  BTSS.B  85A.6
05E14:  BRA     5E6E
05E16:  BTSS.B  1A3C.0
05E18:  BRA     5E6E
05E1A:  BTSS.B  1A3C.1
05E1C:  BRA     5E6E
05E1E:  BTSS.B  1A3C.2
05E20:  BRA     5E6E
05E22:  BTSC.B  85A.7
05E24:  BRA     5E6E
05E26:  BTSC.B  85B.0
05E28:  BRA     5E6E
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
05E2A:  MOV     872,W4
05E2C:  LSR     W4,#8,W4
05E2E:  CP.B    W4L,#1
05E30:  BRA     NZ,5E3E
05E32:  MOV     874,W4
05E34:  CP.B    W4L,#1
05E36:  BRA     NZ,5E3E
05E38:  MOV     #3E8,W0
05E3A:  CALL    E84
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
05E3E:  MOV     14D8,W0
05E40:  ADD     14D4,W0
05E42:  MOV     W0,14D8
.................... 					Pos_y += Dist_y; 
05E44:  MOV     14DA,W0
05E46:  ADD     14D6,W0
05E48:  MOV     W0,14DA
.................... 					 
.................... 					__Afficheur_7segments(3); 
05E4A:  MOV.B   #3,W0L
05E4C:  MOV.B   W0L,1A4A
05E4E:  CLR.B   1A4B
05E50:  CALL    139E
.................... 	 
.................... 					Dist_x=0; 
05E54:  CLR     14D4
.................... 					Dist_y=0; 
05E56:  CLR     14D6
.................... 					Dorient = 0; 
05E58:  CLR     14DE
05E5A:  CLR     14E0
05E5C:  CLR     14E2
05E5E:  CLR     14E4
.................... 					balise_on = 0; 
05E60:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
05E62:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
05E64:  BCLR.B  1A3C.0
.................... 					action_ok2 = 0; 
05E66:  BCLR.B  1A3C.1
.................... 					action_ok3 = 0; 
05E68:  BCLR.B  1A3C.2
.................... 					Etat_rob = Switch_end_obj; 
05E6A:  MOV.B   #3,W0L
05E6C:  MOV.B   W0L,875
.................... 				} 
.................... 				break; 
05E6E:  GOTO    5F92
.................... 			 
.................... 			case Switch_end_obj: 
.................... 				if(keep_obj==0)  
05E72:  CP0     13C8
05E74:  BRA     NZ,5E8E
.................... 				{ 
.................... 					TabObjectifs[NoObj][1][8] = 0; // mise de la ponderation a 0 --> on le remploie plus 
05E76:  MOV.B   873,W0L
05E78:  CLR.B   1
05E7A:  MOV     #138,W4
05E7C:  MUL.UU  W0,W4,W0
05E7E:  MOV     W0,W5
05E80:  ADD     W5,#18,W5
05E82:  ADD     W5,#10,W0
05E84:  MOV     #A8A,W4
05E86:  ADD     W0,W4,W5
05E88:  CLR.B   [W5]
05E8A:  MOV.B   #0,W0L
05E8C:  MOV.B   W0L,[W5+#1]
.................... 				} 
.................... 			 	if(Obj_end)//si fini l'objectifs,passe a l'obj suivant 
05E8E:  CP0     13C4
05E90:  BRA     Z,5EFE
.................... 				{ 
.................... 					if(Next_obj!=0) // 0--> passe a l'obj suivant, sinon va a l'obj marquer 
05E92:  CP0     13C6
05E94:  BRA     Z,5EBA
.................... 					{ 
.................... 						last_obj = NoObj; 
05E96:  MOV.B   873,W0L
05E98:  MOV.B   W0L,876
05E9A:  CLR.B   877
05E9C:  CLR     878
.................... 						NoObj = Next_Obj; 
05E9E:  MOV.B   13C6,W0L
05EA0:  MOV.B   W0L,873
.................... 						NoPts = 1; 
05EA2:  MOV.B   #1,W0L
05EA4:  MOV.B   W0L,874
.................... 						__LoadObj(NoObj,NoPts);//charge le nouveau pts						 
05EA6:  MOV.B   873,W0L
05EA8:  MOV.B   W0L,1A40
05EAA:  CLR.B   1A41
05EAC:  MOV.B   874,W0L
05EAE:  MOV.B   W0L,1A42
05EB0:  CLR.B   1A43
05EB2:  CALL    18A2
.................... 					} 
05EB6:  GOTO    5EFA
.................... 					else 
.................... 					{ 
.................... 						last_obj = NoObj; 
05EBA:  MOV.B   873,W0L
05EBC:  MOV.B   W0L,876
05EBE:  CLR.B   877
05EC0:  CLR     878
.................... 						do //prochain objectifs avec pondÃ©ration de 10 
.................... 						{ 
.................... 							__Afficheur_7segments(4); 
05EC2:  MOV.B   #4,W0L
05EC4:  MOV.B   W0L,1A4A
05EC6:  CLR.B   1A4B
05EC8:  CALL    139E
.................... 							NoObj++; // on passe a l'objectifs suivant 
05ECC:  INC.B   0873
.................... 							NoPts=1; // on reprend au premier pts 
05ECE:  MOV.B   #1,W0L
05ED0:  MOV.B   W0L,874
.................... 							if(NoObj == 10) 
05ED2:  MOV     872,W4
05ED4:  LSR     W4,#8,W4
05ED6:  CP.B    W4L,#A
05ED8:  BRA     NZ,5EE4
.................... 							{ 
.................... 								Flag_end = 1; 
05EDA:  BSET.B  85A.7
.................... 								Ponderation = 10; 
05EDC:  MOV     #A,W4
05EDE:  MOV     W4,13C2
.................... 							} 
05EE0:  GOTO    5EF4
.................... 							else __LoadObj(NoObj,NoPts);//charge le nouveau pts 
05EE4:  MOV.B   873,W0L
05EE6:  MOV.B   W0L,1A40
05EE8:  CLR.B   1A41
05EEA:  MOV.B   874,W0L
05EEC:  MOV.B   W0L,1A42
05EEE:  CLR.B   1A43
05EF0:  CALL    18A2
.................... 	 
.................... 						}while(Ponderation!=10); 
05EF4:  MOV     13C2,W4
05EF6:  CP      W4,#A
05EF8:  BRA     NZ,5EC2
....................  
.................... 					} 
.................... 				} 
05EFA:  GOTO    5F20
.................... 				else 
.................... 				{ 
.................... 					if(Pt_commun==1) NoPts+=2; // skip le pts droite 
05EFE:  MOV     13C0,W4
05F00:  CP      W4,#1
05F02:  BRA     NZ,5F0E
05F04:  MOV     874,W4
05F06:  ADD.B   W4L,#2,W0L
05F08:  MOV.B   W0L,874
05F0A:  GOTO    5F10
.................... 					else NoPts++; // passe au pt suivant suivant																 
05F0E:  INC.B   0874
.................... 					__LoadObj(NoObj,NoPts);//charge le nouveau pts 
05F10:  MOV.B   873,W0L
05F12:  MOV.B   W0L,1A40
05F14:  CLR.B   1A41
05F16:  MOV.B   874,W0L
05F18:  MOV.B   W0L,1A42
05F1A:  CLR.B   1A43
05F1C:  CALL    18A2
.................... 				}	 
.................... 				if(Pt_commun!=0)//si point pas symetrique 
05F20:  CP0     13C0
05F22:  BRA     Z,5F30
.................... 				{ 
.................... 					if(Team)//pt droite 
05F24:  BTSS.B  85B.3
05F26:  BRA     5F30
.................... 					{ 
.................... 						if(Pt_commun==1) NoPts++; // passe Ã  l'obj suivant (pt droite) 
05F28:  MOV     13C0,W4
05F2A:  CP      W4,#1
05F2C:  BRA     NZ,5F30
05F2E:  INC.B   0874
.................... 					} 
.................... 				} 
.................... 				 
.................... 				if(!Flag_end) Etat_rob = Init; 
05F30:  BTSC.B  85A.7
05F32:  BRA     5F36
05F34:  CLR.B   875
.................... 				break; 
05F36:  GOTO    5F92
.................... 			case Wait_end: //case wait 
.................... 				if(flag_error) //erreur --> clignotement 7 segments 
05F3A:  BTSS.B  85B.2
05F3C:  BRA     5F60
.................... 				{ 
.................... 					__Afficheur_7segments(No_erreur,1); 
05F3E:  MOV.B   870,W0L
05F40:  MOV.B   W0L,1A4A
05F42:  MOV.B   #1,W0L
05F44:  MOV.B   W0L,1A4B
05F46:  CALL    139E
.................... 					delay_ms(1000); 
05F4A:  MOV     #3E8,W0
05F4C:  CALL    E84
.................... 					__Afficheur_7segments(No_erreur,0); 
05F50:  MOV.B   870,W0L
05F52:  MOV.B   W0L,1A4A
05F54:  CLR.B   1A4B
05F56:  CALL    139E
.................... 					delay_ms(1000); 
05F5A:  MOV     #3E8,W0
05F5C:  CALL    E84
.................... 				} 
.................... 				if(flagGameEnd) 
05F60:  BTSS.B  85A.0
05F62:  BRA     5F82
.................... 				{ 
.................... 					__Afficheur_7segments(99); 
05F64:  MOV.B   #63,W0L
05F66:  MOV.B   W0L,1A4A
05F68:  CLR.B   1A4B
05F6A:  CALL    139E
.................... 					// Desactive tout le reste 
.................... 					MoveServo(0,20); 
05F6E:  CLR     1A3E
05F70:  MOV     #14,W4
05F72:  MOV     W4,1A40
05F74:  CALL    1050
.................... 					disable_interrupts(INTR_GLOBAL); 
05F78:  BCLR.B  81.7
05F7A:  MOV     #E0,W4
05F7C:  MOV     W4,42
05F7E:  BSET.B  81.7
.................... 					flagGameEnd=0;			 
05F80:  BCLR.B  85A.0
.................... 				}				 
.................... 				break;			 
05F82:  GOTO    5F92
.................... 			default: 
.................... 				__Affichage_erreur(3);  
05F86:  MOV.B   #3,W0L
05F88:  MOV.B   W0L,1A4A
05F8A:  CALL    1002
.................... 				break; 
05F8E:  GOTO    5F92
.................... 		} 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
....................  
....................         //////////////////////////////////////////////////////////////////////////////////// 
.................... 		////////////////////////	ACTION PARALLELES	//////////////////////////////////// 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
.................... 		 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        BALISE          ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(flagBaliseCheck && !flag_end && balise_on && !flag_error) 
05F92:  BTSS.B  85A.2
05F94:  BRA     6138
05F96:  BTSC.B  85A.7
05F98:  BRA     6138
05F9A:  BTSS.B  85B.1
05F9C:  BRA     6138
05F9E:  BTSC.B  85B.2
05FA0:  BRA     6138
....................       	{ 
....................         	Value_bal = Check_balise(); 			//Recuperation de la valeur de la bailse 
05FA2:  CALL    4C9E
05FA6:  MOV.B   W0L,871
....................         	tempo_bal++; 							//temporisation de la balise, d'une fois detecte, il faut passer 4  tempo bal = 4 pour continuer 
05FA8:  INC.B   0872
.................... 	        if(Value_bal>=MAX_VALUE_DETECT_BALISE) 	//si adversaire trop proche 
05FAA:  MOV.B   13D0,W0L
05FAC:  MOV     870,W4
05FAE:  LSR     W4,#8,W4
05FB0:  CP.B    W4L,W0L
05FB2:  BRA     NC,60C4
.................... 	        {    
.................... 	       		tempo_bal = 0;						//remise a 0 de la tempo 
05FB4:  CLR.B   872
....................            		__Afficheur_7segments(44); 
05FB6:  MOV.B   #2C,W0L
05FB8:  MOV.B   W0L,1A4A
05FBA:  CLR.B   1A4B
05FBC:  CALL    139E
.................... 	           	_LED2,_LED3,_LED4 = 1; 
05FC0:  BSET.B  2D0.4
.................... 	           	_Detected = 1;						//indique que l'on a detecte l'adversaire 
05FC2:  BSET.B  85B.0
.................... 	         
.................... 	            /////////////////// Arret du robot /////////////////////////////////////// 
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 9000_^MDEC 2 9000\r");	//rampe de dec. plus raide  
05FC4:  MOV     #0,W1
05FC6:  MOV     W1,W0
05FC8:  CLR.B   1
05FCA:  CALL    408
05FCE:  INC     W1,W1
05FD0:  BTSC.B  219.1
05FD2:  BRA     5FD0
05FD4:  MOV     W0,21A
05FD6:  MOV     #19,W0
05FD8:  CPSGT   W1,W0
05FDA:  BRA     5FC6
.................... 	            delay_ms(20); 
05FDC:  MOV     #14,W0
05FDE:  CALL    E84
.................... 	            fprintf(ROBOTEQ,"!S 1 0_!S 2 0\r");				//vitesse du robot a 0 --> il va freiner 
05FE2:  MOV     #0,W1
05FE4:  MOV     W1,W0
05FE6:  CLR.B   1
05FE8:  CALL    430
05FEC:  INC     W1,W1
05FEE:  BTSC.B  219.1
05FF0:  BRA     5FEE
05FF2:  MOV     W0,21A
05FF4:  MOV     #D,W0
05FF6:  CPSGT   W1,W0
05FF8:  BRA     5FE4
....................  
.................... 	            if(Time_detected==0) // recuperation du temps de la detection 
05FFA:  CP0.B   86E
05FFC:  BRA     NZ,6006
.................... 	            { 
.................... 	               Time_detected = GameTimeS; 
05FFE:  MOV.B   861,W0L
06000:  MOV.B   W0L,86E
.................... 	            } 
06002:  GOTO    60C0
.................... 	            else if(((GameTimeS - Time_detected) >= TIME_tempo_dectected))//on attend 6s 
06006:  MOV     860,W4
06008:  LSR     W4,#8,W4
0600A:  MOV     86E,W3
0600C:  SUB.B   W4L,W3L,W0L
0600E:  MOV     86E,W4
06010:  LSR     W4,#8,W4
06012:  CP.B    W4L,W0L
06014:  BRA     GTU,60C0
.................... 	            {       
.................... 	               if(TabObjectifs[(NoObj+1)][1][8]!=10 && TabObjectifs[(NoObj+1)][1][8]!=0)//si obj suivant pond entre 1 et 9 --> on switch l'obj 
06016:  MOV     872,W4
06018:  LSR     W4,#8,W4
0601A:  ADD     W4,#1,W5
0601C:  MOV     #138,W4
0601E:  MUL.UU  W5,W4,W0
06020:  MOV     W0,W5
06022:  ADD     W5,#18,W5
06024:  ADD     W5,#10,W0
06026:  MOV     #A8A,W4
06028:  ADD     W0,W4,W0
0602A:  MOV     [W0],W5
0602C:  CP      W5,#A
0602E:  BRA     Z,60C0
06030:  MOV     872,W4
06032:  LSR     W4,#8,W4
06034:  ADD     W4,#1,W5
06036:  MOV     #138,W4
06038:  MUL.UU  W5,W4,W0
0603A:  MOV     W0,W5
0603C:  ADD     W5,#18,W5
0603E:  ADD     W5,#10,W0
06040:  MOV     #A8A,W4
06042:  ADD     W0,W4,W0
06044:  MOV     [W0],W5
06046:  CP0     W5
06048:  BRA     Z,60C0
.................... 	               { 
.................... 	                   /////////////////// actualisation position x,y /////////////////// 
.................... 	                  __actual_pos();// actualisation de la Pos xy  
0604A:  CALL    4CDA
....................  
.................... 	                   /////////////////// effacer l'ordre en cours  ///////////////////  
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
0604E:  MOV     #0,W1
06050:  MOV     W1,W0
06052:  CLR.B   1
06054:  CALL    380
06058:  INC     W1,W1
0605A:  BTSC.B  219.1
0605C:  BRA     605A
0605E:  MOV     W0,21A
06060:  MOV     #13,W0
06062:  CPSGT   W1,W0
06064:  BRA     6050
.................... 	                  delay_ms(10); 
06066:  MOV     #A,W0
06068:  CALL    E84
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
0606C:  MOV     #0,W1
0606E:  MOV     W1,W0
06070:  CLR.B   1
06072:  CALL    3A2
06076:  INC     W1,W1
06078:  BTSC.B  219.1
0607A:  BRA     6078
0607C:  MOV     W0,21A
0607E:  MOV     #13,W0
06080:  CPSGT   W1,W0
06082:  BRA     606E
....................  
.................... 	                   /////////////////// Passage a l'obj suivant  /////////////////// 
.................... 	                  NoObj++; // passage a l'objectif suivant 
06084:  INC.B   0873
.................... 	                  NoPts = 1; // on demarre par le premier pts 
06086:  MOV.B   #1,W0L
06088:  MOV.B   W0L,874
.................... 	                  __LoadObj(NoObj,NoPts);//charge le nouveau pts 
0608A:  MOV.B   873,W0L
0608C:  MOV.B   W0L,1A40
0608E:  CLR.B   1A41
06090:  MOV.B   874,W0L
06092:  MOV.B   W0L,1A42
06094:  CLR.B   1A43
06096:  CALL    18A2
.................... 	                
.................... 	                  if(Pt_commun!=0)//si point pas symetrique 
0609A:  CP0     13C0
0609C:  BRA     Z,60AA
.................... 	                  { 
.................... 	                  if(Team)//pt droite 
0609E:  BTSS.B  85B.3
060A0:  BRA     60AA
.................... 	                  { 
.................... 	                     if(Pt_commun==1) NoPts++; // passe Ã  l'obj suivant (pt droite) 
060A2:  MOV     13C0,W4
060A4:  CP      W4,#1
060A6:  BRA     NZ,60AA
060A8:  INC.B   0874
.................... 	                  } 
.................... 	                  } 
.................... 	                  Etat_rob = Init; // on recommence le programme 
060AA:  CLR.B   875
.................... 	                  _Detected = 0; 
060AC:  BCLR.B  85B.0
.................... 	                  balise_on = 0; 
060AE:  BCLR.B  85B.1
.................... 	                  Dist_x = 0; 
060B0:  CLR     14D4
.................... 	                  Dist_y = 0; 
060B2:  CLR     14D6
.................... 	                  Dorient = 0;  
060B4:  CLR     14DE
060B6:  CLR     14E0
060B8:  CLR     14E2
060BA:  CLR     14E4
.................... 	                  _LED2,_LED3,_LED4 = 0; 
060BC:  BCLR.B  2D0.4
.................... 	                  Time_detected=0; 
060BE:  CLR.B   86E
.................... 	               } 
.................... 	            } 
.................... 	        } 
060C0:  GOTO    6134
.................... 	        else if(_Detected && tempo_bal == 4) // si detecte et que l'adv n'est plus la  
060C4:  BTSS.B  85B.0
060C6:  BRA     6134
060C8:  MOV     872,W4
060CA:  CP.B    W4L,#4
060CC:  BRA     NZ,6134
.................... 	        { 
.................... 	             /////////////////// Reprise de l'ordre  ///////////////////          
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 6000_^MDEC 2 6000\r");//on reprend le dernier ordre    
060CE:  MOV     #0,W1
060D0:  MOV     W1,W0
060D2:  CLR.B   1
060D4:  CALL    44C
060D8:  INC     W1,W1
060DA:  BTSC.B  219.1
060DC:  BRA     60DA
060DE:  MOV     W0,21A
060E0:  MOV     #19,W0
060E2:  CPSGT   W1,W0
060E4:  BRA     60D0
.................... 	            fprintf(ROBOTEQ,"!S 1 %u_!S 2 %u\r",oVitMax,oVitMax); 
060E6:  MOV     #0,W1
060E8:  MOV     W1,W0
060EA:  CLR.B   1
060EC:  CALL    474
060F0:  INC     W1,W1
060F2:  BTSC.B  219.1
060F4:  BRA     60F2
060F6:  MOV     W0,21A
060F8:  MOV     #4,W0
060FA:  CPSGT   W1,W0
060FC:  BRA     60E8
060FE:  MOV     13BC,W0
06100:  MOV     #0,W4
06102:  CALL    240A
06106:  MOV     #7,W1
06108:  MOV     W1,W0
0610A:  CLR.B   1
0610C:  CALL    474
06110:  INC     W1,W1
06112:  BTSC.B  219.1
06114:  BRA     6112
06116:  MOV     W0,21A
06118:  MOV     #C,W0
0611A:  CPSGT   W1,W0
0611C:  BRA     6108
0611E:  MOV     13BC,W0
06120:  MOV     #0,W4
06122:  CALL    240A
06126:  BTSC.B  219.1
06128:  BRA     6126
0612A:  MOV     #D,W4
0612C:  MOV     W4,21A
....................  
.................... 	            Time_detected = 0;  
0612E:  CLR.B   86E
.................... 	            _LED1=0; 
06130:  BCLR.B  2D0.1
.................... 	            _Detected = 0; 
06132:  BCLR.B  85B.0
....................              
.................... 	        } 
.................... 	        _LED1=!_LED1;  
06134:  BTG.B   2D0.1
.................... 	        flagBaliseCheck = 0; 
06136:  BCLR.B  85A.2
.................... 	    }    
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        UART            ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(PCh_flagUARTReadyToDecode) __UART_Decode(TabDecoded); 
06138:  BTSS.B  14BF.6
0613A:  BRA     6144
0613C:  MOV     #1630,W4
0613E:  MOV     W4,1A3E
06140:  CALL    55E0
....................  
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        Fin du prog.    ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if((Flag_end || flagTimeOut || flag_error) && !IsPassedTimeOut) 
06144:  BTSC.B  85A.7
06146:  BRA     6150
06148:  BTSC.B  85A.1
0614A:  BRA     6150
0614C:  BTSS.B  85B.2
0614E:  BRA     619A
06150:  BTSC.B  85A.5
06152:  BRA     619A
.................... 		{ 
.................... 			__Afficheur_7segments(98); 
06154:  MOV.B   #62,W0L
06156:  MOV.B   W0L,1A4A
06158:  CLR.B   1A4B
0615A:  CALL    139E
....................  
.................... 			IsPassedTimeOut=1; 
0615E:  BSET.B  85A.5
.................... 			// arret moteurs 
.................... 			fprintf(ROBOTEQ, "!EX \r");  
06160:  MOV     #0,W1
06162:  MOV     W1,W0
06164:  CLR.B   1
06166:  CALL    492
0616A:  INC     W1,W1
0616C:  BTSC.B  219.1
0616E:  BRA     616C
06170:  MOV     W0,21A
06172:  MOV     #4,W0
06174:  CPSGT   W1,W0
06176:  BRA     6162
.................... 			driver_moteur(0xC0,0); 
06178:  MOV.B   #C0,W0L
0617A:  MOV.B   W0L,1A4A
0617C:  CLR.B   1A4B
0617E:  CALL    12A0
.................... 			driver_moteur(0xC2,0); 
06182:  MOV.B   #C2,W0L
06184:  MOV.B   W0L,1A4A
06186:  CLR.B   1A4B
06188:  CALL    12A0
.................... 			driver_moteur(0xC4,0); 
0618C:  MOV.B   #C4,W0L
0618E:  MOV.B   W0L,1A4A
06190:  CLR.B   1A4B
06192:  CALL    12A0
.................... 			Etat_rob = Wait_end; 
06196:  MOV.B   #4,W0L
06198:  MOV.B   W0L,875
.................... 		}		 
0619A:  GOTO    5CEC
.................... 	} 
.................... } 
....................  
....................  
.................... /** 
.................... * \fn void TIMER1_isr(void) 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 19.10.2015 
.................... * 
.................... * \brief Met Ã  jour la pose, gÃ¨re le profil trapÃ©zoÃ¯dal et le PID 
.................... *		 S'active chaque 1 [ms] 
.................... * 
.................... */ 
.................... #INT_TIMER1 HIGH 
.................... void TIMER1_isr(void) 
*
00AA6:  PUSH    42
00AA8:  PUSH    36
00AAA:  PUSH    32
00AAC:  MOV     W0,[W15++]
00AAE:  MOV     #2,W0
00AB0:  REPEAT  #C
00AB2:  MOV     [W0++],[W15++]
*
0619E:  BRA     619E
.................... { 
.................... 	// Compte le temps rÃ©el 
.................... 	RealTimeMS ++; 
*
00AB4:  INC     0862
00AB6:  BTSC.B  42.1
00AB8:  INC     0864
.................... 	// Temps de jeu 
.................... 	if(BeginTimeMS!=0) 
00ABA:  CP0     866
00ABC:  BRA     NZ,AC2
00ABE:  CP0     868
00AC0:  BRA     Z,AEE
.................... 	{ 
.................... 		GameTimeMS=RealTimeMS-BeginTimeMS; 
00AC2:  MOV     862,W4
00AC4:  MOV     866,W3
00AC6:  SUB     W4,W3,W0
00AC8:  MOV     W0,86A
00ACA:  MOV     864,W4
00ACC:  MOV     868,W3
00ACE:  SUBB    W4,W3,W0
00AD0:  MOV     W0,86C
.................... 		if(GameTimeMS%1000==0)GameTimeS++; 
00AD2:  BSET.B  43.0
00AD4:  MOV     86A,W0
00AD6:  MOV     86C,W1
00AD8:  MOV     #3E8,W2
00ADA:  MOV     #0,W3
00ADC:  CALL    A52
00AE0:  MOV     W0,W5
00AE2:  MOV     W1,W6
00AE4:  CP0     W5
00AE6:  BRA     NZ,AEE
00AE8:  CP0     W6
00AEA:  BRA     NZ,AEE
00AEC:  INC.B   0861
.................... 	}	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	//////////////////////////////////	TASK GIVER	//////////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Balise Ã  checker 
.................... 	if(GameTimeS == 92) FlagGameEnd = 1;  
00AEE:  MOV     860,W4
00AF0:  LSR     W4,#8,W4
00AF2:  XOR.B   #5C,W4L
00AF4:  BRA     NZ,AF8
00AF6:  BSET.B  85A.0
.................... 	if(BeginTimeMS!=0 && GameTimeMS%TIME_TO_CHECK_BAL==0) 
00AF8:  CP0     866
00AFA:  BRA     NZ,B00
00AFC:  CP0     868
00AFE:  BRA     Z,B1C
00B00:  BSET.B  43.0
00B02:  MOV     86A,W0
00B04:  MOV     86C,W1
00B06:  MOV     13D2,W2
00B08:  MOV     #0,W3
00B0A:  CALL    A52
00B0E:  MOV     W0,W5
00B10:  MOV     W1,W6
00B12:  CP0     W5
00B14:  BRA     NZ,B1C
00B16:  CP0     W6
00B18:  BRA     NZ,B1C
.................... 	{ 
.................... 		// Check Balise 
.................... 		flagBaliseCheck=1; 
00B1A:  BSET.B  85A.2
.................... 	} 
.................... 	if(BeginTimeMS!=0 && GameTimeMS%500==0)ToDisplay=!ToDisplay; 
00B1C:  CP0     866
00B1E:  BRA     NZ,B24
00B20:  CP0     868
00B22:  BRA     Z,B40
00B24:  BSET.B  43.0
00B26:  MOV     86A,W0
00B28:  MOV     86C,W1
00B2A:  MOV     #1F4,W2
00B2C:  MOV     #0,W3
00B2E:  CALL    A52
00B32:  MOV     W0,W5
00B34:  MOV     W1,W6
00B36:  CP0     W5
00B38:  BRA     NZ,B40
00B3A:  CP0     W6
00B3C:  BRA     NZ,B40
00B3E:  BTG.B   85A.4
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////	WATCHDOG INTERRUPTS	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// WD Times 
.................... 	static unsigned int16 UART_WD_TIME=0; 
.................... 	 
.................... 	// Watchdog UART, rÃ©initialise la capture 
.................... 	if(PCh_flagUARTWatchdog==1) 
00B40:  BTSS.B  14BF.7
00B42:  BRA     B5E
.................... 	{ 
.................... 		UART_WD_TIME++; 
00B44:  INC     1A3A
.................... 		if(UART_WD_TIME>=UART_WD_DELAY) 
00B46:  MOV.B   13CA,W0L
00B48:  CLR.B   1
00B4A:  MOV     1A3A,W4
00B4C:  CP      W4,W0
00B4E:  BRA     NC,B5A
.................... 		{ 
.................... 			// Reset UART 
.................... 			ToDoUART = 0; 
00B50:  CLR.B   162E
.................... 			PosTabToDecode=0; 
00B52:  CLR.B   152D
.................... 			UARTToSendBack=0; 
00B54:  CLR.B   1A30
.................... 			UARTWaitResp=0; 
00B56:  BCLR.B  162F.0
.................... 			// Desactive le watchdog UART 
.................... 			PCh_flagUARTWatchdog = 0; 
00B58:  BCLR.B  14BF.7
.................... 		} 
.................... 	} 
00B5A:  GOTO    B60
.................... 	else UART_WD_TIME=0; 
00B5E:  CLR     1A3A
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////		PROGRAM END		//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// AprÃ¨s 1min30, on arrÃªte les Ã©lÃ©ments essentiels 
.................... 	if(BeginTimeMS!=0 && GameTimeS>=88) 
00B60:  CP0     866
00B62:  BRA     NZ,B68
00B64:  CP0     868
00B66:  BRA     Z,B74
00B68:  MOV     860,W4
00B6A:  LSR     W4,#8,W4
00B6C:  MOV     #58,W3
00B6E:  CP.B    W3L,W4L
00B70:  BRA     GTU,B74
.................... 	{ 
.................... 		flagTimeOut=1; 
00B72:  BSET.B  85A.1
.................... 	} 
.................... 	// AprÃ¨s la fin de jeu, on ouvre le parasol  
.................... 	if(BeginTimeMS!=0 && GameTimeS>=92) 
00B74:  CP0     866
00B76:  BRA     NZ,B7C
00B78:  CP0     868
00B7A:  BRA     Z,B88
00B7C:  MOV     860,W4
00B7E:  LSR     W4,#8,W4
00B80:  MOV     #5C,W3
00B82:  CP.B    W3L,W4L
00B84:  BRA     GTU,B88
.................... 	{ 
.................... 		flagGameEnd=1; 
00B86:  BSET.B  85A.0
.................... 	}	 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... //// Timer de clignotement d'erreur. //// 
.................... //////////////////////////////////////// 
00B88:  BCLR.B  84.3
00B8A:  MOV     #1A,W0
00B8C:  REPEAT  #C
00B8E:  MOV     [--W15],[W0--]
00B90:  MOV     [--W15],W0
00B92:  POP     32
00B94:  POP     36
00B96:  POP     42
00B98:  RETFIE  
.................... #INT_TIMER3 
.................... void TIMER3_isr(void) 
00B9A:  PUSH    42
00B9C:  PUSH    36
00B9E:  PUSH    32
00BA0:  MOV     W0,[W15++]
00BA2:  MOV     #2,W0
00BA4:  REPEAT  #C
00BA6:  MOV     [W0++],[W15++]
.................... { 
.................... 	static int1 On_Off_Error = 0; 
.................... 	 
.................... 	// Si doit afficher une erreur 
.................... 	if(flagError) 
00BA8:  BTSS.B  85A.3
00BAA:  BRA     BAE
.................... 	{ 
.................... 	//	__Afficheur_7segments(NO_ERROR,On_Off_Error); 
.................... 		On_Off_Error =! On_Off_Error; 
00BAC:  BTG.B   162F.1
.................... 	}	 
00BAE:  BCLR.B  84.7
00BB0:  MOV     #1A,W0
00BB2:  REPEAT  #C
00BB4:  MOV     [--W15],[W0--]
00BB6:  MOV     [--W15],W0
00BB8:  POP     32
00BBA:  POP     36
00BBC:  POP     42
00BBE:  RETFIE  
.................... }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

Configuration Fuses:
   Word  1L: C712   HS2_PLL8
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8730   NOPUT BORRES NOBROWNOUT MCLR
          H: 0000  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: 0000  
   Word  6L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  7L: 4003   ICSP1 DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
