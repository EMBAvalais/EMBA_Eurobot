CCS PCD C Compiler, Version 5.074, 38375               23-oct.-18 11:44

               Filename:   D:\Années\2019 - Atom Factory\Programmation\Grand Robot\Carte principale\main.lst

               ROM used:   45858 bytes (47%)
                           Largest free fragment is 32768
               RAM used:   6870 (85%) at main() level
                           7237 (89%) worst case
               Stack used: 176 locations (114 in main + 62 for interrupts)
               Stack size: 2048

*
00000:  GOTO    A94C
*
0001A:  DATA    32,0B,00
00020:  DATA    D8,05,00
00022:  DATA    24,0C,00
00026:  DATA    5A,09,00
*
00044:  DATA    FE,05,00
.................... /* 
.................... ==================================================================================================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*==================================================================================================== 
.................... =											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy				  												== 
.................... ===  Date				: 8.6.2017																	== 
.................... ===  Nom du programme 	: InterfaceRoboteQ.mcp (fichier main.c)										== 
.................... ===  Version 			: V2.0.0.0.0																== 
.................... =====================================================================================================*/ 
....................  
.................... #include <30F6014A.h> 
.................... //////////// Standard Header file for the DSPIC30F6014A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014A 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    3F,44,00
0010E:  DATA    52,0D,00
00110:  DATA    00,00,00
00112:  CLR     32
00114:  MOV     #11E,W3
00116:  ADD     W3,W0,W0
00118:  TBLRDL.B[W0],W0L
0011A:  CLR.B   1
0011C:  RETURN  
0011E:  DATA    3F,41,00
00120:  DATA    20,31,00
00122:  DATA    0D,00,00
00124:  CLR     32
00126:  MOV     #130,W3
00128:  ADD     W3,W0,W0
0012A:  TBLRDL.B[W0],W0L
0012C:  CLR.B   1
0012E:  RETURN  
00130:  DATA    3F,41,00
00132:  DATA    20,32,00
00134:  DATA    0D,00,00
00136:  CLR     32
00138:  MOV     #142,W3
0013A:  ADD     W3,W0,W0
0013C:  TBLRDL.B[W0],W0L
0013E:  CLR.B   1
00140:  RETURN  
00142:  DATA    21,53,00
00144:  DATA    20,31,00
00146:  DATA    20,25,00
00148:  DATA    30,34,00
0014A:  DATA    75,5F,00
0014C:  DATA    21,53,00
0014E:  DATA    20,32,00
00150:  DATA    20,25,00
00152:  DATA    30,34,00
00154:  DATA    75,20,00
00156:  DATA    0D,00,00
00158:  CLR     32
0015A:  MOV     #164,W3
0015C:  ADD     W3,W0,W0
0015E:  TBLRDL.B[W0],W0L
00160:  CLR.B   1
00162:  RETURN  
00164:  DATA    21,50,00
00166:  DATA    52,20,00
00168:  DATA    31,20,00
0016A:  DATA    25,64,00
0016C:  DATA    5F,21,00
0016E:  DATA    50,52,00
00170:  DATA    20,32,00
00172:  DATA    20,25,00
00174:  DATA    64,20,00
00176:  DATA    0D,00,00
00178:  CLR     32
0017A:  MOV     #184,W3
0017C:  ADD     W3,W0,W0
0017E:  TBLRDL.B[W0],W0L
00180:  CLR.B   1
00182:  RETURN  
00184:  DATA    21,53,00
00186:  DATA    20,31,00
00188:  DATA    20,31,00
0018A:  DATA    30,30,00
0018C:  DATA    5F,21,00
0018E:  DATA    53,20,00
00190:  DATA    32,20,00
00192:  DATA    31,30,00
00194:  DATA    30,0D,00
00196:  DATA    00,00,00
00198:  CLR     32
0019A:  MOV     #1A4,W3
0019C:  ADD     W3,W0,W0
0019E:  TBLRDL.B[W0],W0L
001A0:  CLR.B   1
001A2:  RETURN  
001A4:  DATA    21,50,00
001A6:  DATA    52,20,00
001A8:  DATA    31,20,00
001AA:  DATA    31,5F,00
001AC:  DATA    21,50,00
001AE:  DATA    52,20,00
001B0:  DATA    32,20,00
001B2:  DATA    31,0D,00
001B4:  DATA    00,00,00
001B6:  CLR     32
001B8:  MOV     #1C2,W3
001BA:  ADD     W3,W0,W0
001BC:  TBLRDL.B[W0],W0L
001BE:  CLR.B   1
001C0:  RETURN  
001C2:  DATA    21,50,00
001C4:  DATA    52,20,00
001C6:  DATA    31,20,00
001C8:  DATA    25,30,00
001CA:  DATA    37,64,00
001CC:  DATA    5F,21,00
001CE:  DATA    50,52,00
001D0:  DATA    20,32,00
001D2:  DATA    20,25,00
001D4:  DATA    30,37,00
001D6:  DATA    64,20,00
001D8:  DATA    0D,00,00
001DA:  CLR     32
001DC:  MOV     #1E6,W3
001DE:  ADD     W3,W0,W0
001E0:  TBLRDL.B[W0],W0L
001E2:  CLR.B   1
001E4:  RETURN  
001E6:  DATA    21,4D,00
001E8:  DATA    53,20,00
001EA:  DATA    31,0D,00
001EC:  DATA    00,00,00
001EE:  CLR     32
001F0:  MOV     #1FA,W3
001F2:  ADD     W3,W0,W0
001F4:  TBLRDL.B[W0],W0L
001F6:  CLR.B   1
001F8:  RETURN  
001FA:  DATA    21,4D,00
001FC:  DATA    53,20,00
001FE:  DATA    32,0D,00
00200:  DATA    00,00,00
00202:  CLR     32
00204:  MOV     #20E,W3
00206:  ADD     W3,W0,W0
00208:  TBLRDL.B[W0],W0L
0020A:  CLR.B   1
0020C:  RETURN  
0020E:  DATA    5E,4D,00
00210:  DATA    4D,4F,00
00212:  DATA    44,20,00
00214:  DATA    31,20,00
00216:  DATA    30,5F,00
00218:  DATA    5E,4D,00
0021A:  DATA    4D,4F,00
0021C:  DATA    44,20,00
0021E:  DATA    32,20,00
00220:  DATA    30,0D,00
00222:  DATA    00,00,00
00224:  CLR     32
00226:  MOV     #230,W3
00228:  ADD     W3,W0,W0
0022A:  TBLRDL.B[W0],W0L
0022C:  CLR.B   1
0022E:  RETURN  
00230:  DATA    5E,4D,00
00232:  DATA    4D,4F,00
00234:  DATA    44,20,00
00236:  DATA    31,20,00
00238:  DATA    33,5F,00
0023A:  DATA    5E,4D,00
0023C:  DATA    4D,4F,00
0023E:  DATA    44,20,00
00240:  DATA    32,20,00
00242:  DATA    33,0D,00
00244:  DATA    00,00,00
00246:  CLR     32
00248:  MOV     #252,W3
0024A:  ADD     W3,W0,W0
0024C:  TBLRDL.B[W0],W0L
0024E:  CLR.B   1
00250:  RETURN  
00252:  DATA    52,45,00
00254:  DATA    53,45,00
00256:  DATA    54,20,00
00258:  DATA    33,32,00
0025A:  DATA    31,36,00
0025C:  DATA    35,34,00
0025E:  DATA    39,38,00
00260:  DATA    37,20,00
00262:  DATA    0D,00,00
00264:  CLR     32
00266:  MOV     #270,W3
00268:  ADD     W3,W0,W0
0026A:  TBLRDL.B[W0],W0L
0026C:  CLR.B   1
0026E:  RETURN  
00270:  DATA    7E,4B,00
00272:  DATA    50,20,00
00274:  DATA    31,20,00
00276:  DATA    0D,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    7E,4B,00
00286:  DATA    49,20,00
00288:  DATA    31,20,00
0028A:  DATA    0D,00,00
0028C:  CLR     32
0028E:  MOV     #298,W3
00290:  ADD     W3,W0,W0
00292:  TBLRDL.B[W0],W0L
00294:  CLR.B   1
00296:  RETURN  
00298:  DATA    7E,4B,00
0029A:  DATA    44,20,00
0029C:  DATA    31,20,00
0029E:  DATA    0D,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    7E,4B,00
002AE:  DATA    50,20,00
002B0:  DATA    32,20,00
002B2:  DATA    0D,00,00
002B4:  CLR     32
002B6:  MOV     #2C0,W3
002B8:  ADD     W3,W0,W0
002BA:  TBLRDL.B[W0],W0L
002BC:  CLR.B   1
002BE:  RETURN  
002C0:  DATA    7E,4B,00
002C2:  DATA    49,20,00
002C4:  DATA    32,20,00
002C6:  DATA    0D,00,00
002C8:  CLR     32
002CA:  MOV     #2D4,W3
002CC:  ADD     W3,W0,W0
002CE:  TBLRDL.B[W0],W0L
002D0:  CLR.B   1
002D2:  RETURN  
002D4:  DATA    7E,4B,00
002D6:  DATA    44,20,00
002D8:  DATA    32,20,00
002DA:  DATA    0D,00,00
002DC:  CLR     32
002DE:  MOV     #2E8,W3
002E0:  ADD     W3,W0,W0
002E2:  TBLRDL.B[W0],W0L
002E4:  CLR.B   1
002E6:  RETURN  
002E8:  DATA    7E,4D,00
002EA:  DATA    41,43,00
002EC:  DATA    20,31,00
002EE:  DATA    20,0D,00
002F0:  DATA    00,00,00
002F2:  CLR     32
002F4:  MOV     #2FE,W3
002F6:  ADD     W3,W0,W0
002F8:  TBLRDL.B[W0],W0L
002FA:  CLR.B   1
002FC:  RETURN  
002FE:  DATA    7E,4D,00
00300:  DATA    44,45,00
00302:  DATA    43,20,00
00304:  DATA    31,20,00
00306:  DATA    0D,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    7E,4D,00
00316:  DATA    41,43,00
00318:  DATA    20,32,00
0031A:  DATA    20,0D,00
0031C:  DATA    00,00,00
0031E:  CLR     32
00320:  MOV     #32A,W3
00322:  ADD     W3,W0,W0
00324:  TBLRDL.B[W0],W0L
00326:  CLR.B   1
00328:  RETURN  
0032A:  DATA    7E,4D,00
0032C:  DATA    44,45,00
0032E:  DATA    43,20,00
00330:  DATA    32,20,00
00332:  DATA    0D,00,00
00334:  CLR     32
00336:  MOV     #26,W3
00338:  SUB     W0,W3,W3
0033A:  BRA     C,346
0033C:  MOV     #350,W3
0033E:  ADD     W3,W0,W0
00340:  TBLRDL.B[W0],W0L
00342:  CLR.B   1
00344:  RETURN  
00346:  MOV     #350,W0
00348:  ADD     W3,W3,W3
0034A:  ADD     W3,W0,W3
0034C:  TBLRDH  [W3],W0
0034E:  RETURN  
00350:  DATA    5E,4B,49
00352:  DATA    50,20,20
00354:  DATA    31,20,32
00356:  DATA    25,75,20
00358:  DATA    5F,5E,25
0035A:  DATA    4B,49,75
0035C:  DATA    20,31,5F
0035E:  DATA    20,25,5E
00360:  DATA    75,5F,4B
00362:  DATA    5E,4B,44
00364:  DATA    44,20,20
00366:  DATA    31,20,32
00368:  DATA    25,75,20
0036A:  DATA    5F,5E,25
0036C:  DATA    4B,50,75
0036E:  DATA    20,32,20
00370:  DATA    20,25,0D
00372:  DATA    75,5F,00
00374:  DATA    5E,4B,00
00376:  CLR     32
00378:  MOV     #1E,W3
0037A:  SUB     W0,W3,W3
0037C:  BRA     C,388
0037E:  MOV     #392,W3
00380:  ADD     W3,W0,W0
00382:  TBLRDL.B[W0],W0L
00384:  CLR.B   1
00386:  RETURN  
00388:  MOV     #392,W0
0038A:  ADD     W3,W3,W3
0038C:  ADD     W3,W0,W3
0038E:  TBLRDH  [W3],W0
00390:  RETURN  
00392:  DATA    5E,4D,5F
00394:  DATA    41,43,5E
00396:  DATA    20,31,4D
00398:  DATA    20,25,44
0039A:  DATA    75,5F,45
0039C:  DATA    5E,4D,43
0039E:  DATA    44,45,20
003A0:  DATA    43,20,32
003A2:  DATA    31,20,20
003A4:  DATA    25,75,25
003A6:  DATA    5F,5E,75
003A8:  DATA    4D,41,20
003AA:  DATA    43,20,0D
003AC:  DATA    32,20,00
003AE:  DATA    25,75,00
003B0:  CLR     32
003B2:  MOV     #3BC,W3
003B4:  ADD     W3,W0,W0
003B6:  TBLRDL.B[W0],W0L
003B8:  CLR.B   1
003BA:  RETURN  
003BC:  DATA    45,45,00
003BE:  DATA    53,41,00
003C0:  DATA    56,20,00
003C2:  DATA    0D,00,00
003C4:  CLR     32
003C6:  MOV     #3D0,W3
003C8:  ADD     W3,W0,W0
003CA:  TBLRDL.B[W0],W0L
003CC:  CLR.B   1
003CE:  RETURN  
003D0:  DATA    21,53,00
003D2:  DATA    20,31,00
003D4:  DATA    20,25,00
003D6:  DATA    30,37,00
003D8:  DATA    64,5F,00
003DA:  DATA    21,53,00
003DC:  DATA    20,32,00
003DE:  DATA    20,25,00
003E0:  DATA    30,37,00
003E2:  DATA    64,20,00
003E4:  DATA    0D,00,00
003E6:  CLR     32
003E8:  MOV     #3F2,W3
003EA:  ADD     W3,W0,W0
003EC:  TBLRDL.B[W0],W0L
003EE:  CLR.B   1
003F0:  RETURN  
003F2:  DATA    21,4D,00
003F4:  DATA    53,20,00
003F6:  DATA    31,5F,00
003F8:  DATA    21,4D,00
003FA:  DATA    53,20,00
003FC:  DATA    32,0D,00
003FE:  DATA    00,00,00
00400:  CLR     32
00402:  MOV     #40C,W3
00404:  ADD     W3,W0,W0
00406:  TBLRDL.B[W0],W0L
00408:  CLR.B   1
0040A:  RETURN  
0040C:  DATA    5E,6D,00
0040E:  DATA    6D,6F,00
00410:  DATA    64,20,00
00412:  DATA    31,20,00
00414:  DATA    30,5F,00
00416:  DATA    5E,6D,00
00418:  DATA    6D,6F,00
0041A:  DATA    64,20,00
0041C:  DATA    32,20,00
0041E:  DATA    30,0D,00
00420:  DATA    00,00,00
00422:  CLR     32
00424:  MOV     #42E,W3
00426:  ADD     W3,W0,W0
00428:  TBLRDL.B[W0],W0L
0042A:  CLR.B   1
0042C:  RETURN  
0042E:  DATA    5E,6D,00
00430:  DATA    6D,6F,00
00432:  DATA    64,20,00
00434:  DATA    31,20,00
00436:  DATA    33,5F,00
00438:  DATA    5E,6D,00
0043A:  DATA    6D,6F,00
0043C:  DATA    64,20,00
0043E:  DATA    32,20,00
00440:  DATA    33,0D,00
00442:  DATA    00,00,00
00444:  CLR     32
00446:  MOV     #450,W3
00448:  ADD     W3,W0,W0
0044A:  TBLRDL.B[W0],W0L
0044C:  CLR.B   1
0044E:  RETURN  
00450:  DATA    43,61,00
00452:  DATA    72,74,00
00454:  DATA    65,20,00
00456:  DATA    50,72,00
00458:  DATA    69,6E,00
0045A:  DATA    63,69,00
0045C:  DATA    70,61,00
0045E:  DATA    6C,65,00
00460:  DATA    20,3A,00
00462:  DATA    20,43,00
00464:  DATA    6F,6D,00
00466:  DATA    6D,61,00
00468:  DATA    6E,64,00
0046A:  DATA    65,20,00
0046C:  DATA    49,6E,00
0046E:  DATA    63,6F,00
00470:  DATA    6E,6E,00
00472:  DATA    75,65,00
00474:  DATA    0D,00,00
00476:  CLR     32
00478:  MOV     #482,W3
0047A:  ADD     W3,W0,W0
0047C:  TBLRDL.B[W0],W0L
0047E:  CLR.B   1
00480:  RETURN  
00482:  DATA    21,4D,00
00484:  DATA    47,0D,00
00486:  DATA    00,00,00
00488:  CLR     32
0048A:  MOV     #494,W3
0048C:  ADD     W3,W0,W0
0048E:  TBLRDL.B[W0],W0L
00490:  CLR.B   1
00492:  RETURN  
00494:  DATA    5E,4D,00
00496:  DATA    44,45,00
00498:  DATA    43,20,00
0049A:  DATA    31,20,00
0049C:  DATA    39,30,00
0049E:  DATA    30,30,00
004A0:  DATA    5F,5E,00
004A2:  DATA    4D,44,00
004A4:  DATA    45,43,00
004A6:  DATA    20,32,00
004A8:  DATA    20,39,00
004AA:  DATA    30,30,00
004AC:  DATA    30,0D,00
004AE:  DATA    00,00,00
004B0:  CLR     32
004B2:  MOV     #4BC,W3
004B4:  ADD     W3,W0,W0
004B6:  TBLRDL.B[W0],W0L
004B8:  CLR.B   1
004BA:  RETURN  
004BC:  DATA    21,53,00
004BE:  DATA    20,31,00
004C0:  DATA    20,30,00
004C2:  DATA    5F,21,00
004C4:  DATA    53,20,00
004C6:  DATA    32,20,00
004C8:  DATA    30,0D,00
004CA:  DATA    00,00,00
004CC:  CLR     32
004CE:  MOV     #4D8,W3
004D0:  ADD     W3,W0,W0
004D2:  TBLRDL.B[W0],W0L
004D4:  CLR.B   1
004D6:  RETURN  
004D8:  DATA    5E,4D,00
004DA:  DATA    44,45,00
004DC:  DATA    43,20,00
004DE:  DATA    31,20,00
004E0:  DATA    36,30,00
004E2:  DATA    30,30,00
004E4:  DATA    5F,5E,00
004E6:  DATA    4D,44,00
004E8:  DATA    45,43,00
004EA:  DATA    20,32,00
004EC:  DATA    20,36,00
004EE:  DATA    30,30,00
004F0:  DATA    30,0D,00
004F2:  DATA    00,00,00
004F4:  CLR     32
004F6:  MOV     #500,W3
004F8:  ADD     W3,W0,W0
004FA:  TBLRDL.B[W0],W0L
004FC:  CLR.B   1
004FE:  RETURN  
00500:  DATA    21,53,00
00502:  DATA    20,31,00
00504:  DATA    20,25,00
00506:  DATA    75,5F,00
00508:  DATA    21,53,00
0050A:  DATA    20,32,00
0050C:  DATA    20,25,00
0050E:  DATA    75,0D,00
00510:  DATA    00,00,00
00512:  CLR     32
00514:  MOV     #51E,W3
00516:  ADD     W3,W0,W0
00518:  TBLRDL.B[W0],W0L
0051A:  CLR.B   1
0051C:  RETURN  
0051E:  DATA    21,45,00
00520:  DATA    58,20,00
00522:  DATA    0D,00,00
*
006A8:  MOV     W5,[W15++]
006AA:  MOV     #C,W5
006AC:  REPEAT  #3
006AE:  MOV     [W5++],[W15++]
006B0:  MUL.UU  W0,W2,W4
006B2:  BTSS    W3.F
006B4:  BRA     6BA
006B6:  MUL.SS  W0,W3,W6
006B8:  BRA     6BC
006BA:  MUL.UU  W0,W3,W6
006BC:  BCLR.B  42.0
006BE:  ADD     W6,W5,W5
006C0:  ADDC    W7,#0,W8
006C2:  BTSS    W1.F
006C4:  BRA     6CA
006C6:  MUL.SS  W1,W2,W6
006C8:  BRA     6CC
006CA:  MUL.UU  W1,W2,W6
006CC:  ADDC    W6,W5,W5
006CE:  ADDC    W7,W8,W8
006D0:  ADDC    #0,W9
006D2:  MUL.SS  W1,W3,W6
006D4:  ADDC    W6,W8,W8
006D6:  ADDC    W9,W7,W7
006D8:  MOV     W7,W3
006DA:  MOV     W8,W2
006DC:  MOV     W5,W1
006DE:  MOV     W4,W0
006E0:  MOV     #12,W5
006E2:  REPEAT  #3
006E4:  MOV     [--W15],[W5--]
006E6:  MOV     [--W15],W5
006E8:  RETURN  
*
00ADE:  MOV     W5,[W15++]
00AE0:  MOV     #C,W5
00AE2:  REPEAT  #3
00AE4:  MOV     [W5++],[W15++]
00AE6:  MOV     #0,W9
00AE8:  BTSC.B  43.0
00AEA:  MOV     #1,W9
00AEC:  MOV     W9,[W15++]
00AEE:  CLR     W4
00AF0:  CLR     W5
00AF2:  CLR     W6
00AF4:  CLR     W7
00AF6:  XOR     W2,W3,W8
00AF8:  BRA     Z,B1C
00AFA:  MOV     #20,W8
00AFC:  BCLR.B  42.0
00AFE:  RLC     W0,W0
00B00:  RLC     W1,W1
00B02:  RLC     W4,W4
00B04:  RLC     W5,W5
00B06:  CP      W5,W3
00B08:  BRA     NZ,B0C
00B0A:  CPB     W4,W2
00B0C:  BRA     NC,B14
00B0E:  SUB     W4,W2,W4
00B10:  SUBB    W5,W3,W5
00B12:  BSET.B  42.0
00B14:  RLC     W6,W6
00B16:  RLC     W7,W7
00B18:  DEC     W8,W8
00B1A:  BRA     NZ,AFC
00B1C:  MOV     W7,W1
00B1E:  MOV     W6,W0
00B20:  MOV     [--W15],W9
00B22:  CP0     W9
00B24:  BRA     Z,B28
00B26:  MOV.D   W4,W0
00B28:  MOV     #12,W5
00B2A:  REPEAT  #3
00B2C:  MOV     [--W15],[W5--]
00B2E:  MOV     [--W15],W5
00B30:  RETURN  
*
00C4A:  MOV     W8,[W15++]
00C4C:  MOV     #12,W8
00C4E:  REPEAT  #4
00C50:  MOV     [W8++],[W15++]
00C52:  CLR     W11
00C54:  MUL.UU  W12,#0,W12
00C56:  MOV     W3,W8
00C58:  MOV     W7,W9
00C5A:  MOV     #7FF,W10
00C5C:  BCLR.B  42.0
00C5E:  BCLR.B  42.1
00C60:  ASR     W8,#4,W8
00C62:  AND     W10,W8,W8
00C64:  CP0     W8
00C66:  BRA     Z,D4A
00C68:  BCLR.B  42.0
00C6A:  BCLR.B  42.1
00C6C:  ASR     W9,#4,W9
00C6E:  AND     W10,W9,W9
00C70:  CP0     W9
00C72:  BRA     Z,D4A
00C74:  ADD     W9,W8,W8
00C76:  BTSC    W9.B
00C78:  BRA     C82
00C7A:  SUB     #3FF,W8
00C7C:  BRA     Z,D4A
00C7E:  BRA     NC,D4A
00C80:  BRA     C88
00C82:  MOV     #401,W10
00C84:  ADD.B   W10L,W5L,W5L
00C86:  BRA     C,D4A
00C88:  XOR     W3,W7,W13
00C8A:  BCLR.B  42.0
00C8C:  BCLR.B  42.1
00C8E:  AND     #F,W3
00C90:  BSET    W3.4
00C92:  AND     #F,W7
00C94:  BSET    W7.4
00C96:  MOV     W8,[W15++]
00C98:  MUL.UU  W4,W1,W8
00C9A:  MUL.UU  W5,W0,W10
00C9C:  ADD     W8,W10,W10
00C9E:  ADDC    W9,W11,W11
00CA0:  ADDC    #0,W12
00CA2:  MUL.UU  W4,W2,W8
00CA4:  ADD     W8,W11,W11
00CA6:  ADDC    W9,W12,W12
00CA8:  MUL.UU  W5,W1,W8
00CAA:  CLR     W10
00CAC:  ADD     W8,W11,W11
00CAE:  ADDC    W9,W12,W12
00CB0:  ADDC    #0,W10
00CB2:  MUL.UU  W6,W0,W8
00CB4:  ADD     W8,W11,W11
00CB6:  ADDC    W9,W12,W12
00CB8:  ADDC    #0,W10
00CBA:  CLR     W11
00CBC:  MUL.UU  W4,W3,W8
00CBE:  ADD     W8,W12,W12
00CC0:  ADDC    W9,W10,W10
00CC2:  ADDC    #0,W11
00CC4:  MUL.UU  W5,W2,W8
00CC6:  ADD     W8,W12,W12
00CC8:  ADDC    W9,W10,W10
00CCA:  ADDC    #0,W11
00CCC:  MUL.UU  W6,W1,W8
00CCE:  ADD     W8,W12,W12
00CD0:  ADDC    W9,W10,W10
00CD2:  ADDC    #0,W11
00CD4:  MUL.UU  W7,W0,W8
00CD6:  ADD     W8,W12,W12
00CD8:  ADDC    W9,W10,W10
00CDA:  ADDC    #0,W11
00CDC:  MOV     W12,W0
00CDE:  CLR     W12
00CE0:  MUL.UU  W5,W3,W8
00CE2:  ADD     W8,W10,W10
00CE4:  ADDC    W9,W11,W11
00CE6:  ADDC    #0,W12
00CE8:  MUL.UU  W6,W2,W8
00CEA:  ADD     W8,W10,W10
00CEC:  ADDC    W9,W11,W11
00CEE:  ADDC    #0,W12
00CF0:  MUL.UU  W6,W3,W8
00CF2:  ADD     W8,W11,W11
00CF4:  ADDC    W9,W12,W12
00CF6:  MUL.UU  W7,W1,W8
00CF8:  ADD     W8,W10,W10
00CFA:  ADDC    W9,W11,W11
00CFC:  ADDC    #0,W12
00CFE:  MUL.UU  W7,W2,W8
00D00:  ADD     W8,W11,W11
00D02:  ADDC    W9,W12,W12
00D04:  MUL.UU  W7,W3,W8
00D06:  ADD     W8,W12,W12
00D08:  MOV     W10,W1
00D0A:  MOV     W11,W2
00D0C:  MOV     W12,W3
00D0E:  MOV     #5,W4
00D10:  BCLR.B  42.0
00D12:  RRC     W3,W3
00D14:  RRC     W2,W2
00D16:  RRC     W1,W1
00D18:  RRC     W0,W0
00D1A:  DEC     W4,W4
00D1C:  BRA     NZ,D10
00D1E:  MOV     [--W15],W8
00D20:  INC     W8,W8
00D22:  IOR      W0,  W1,W6
00D24:  BRA     Z,D28
00D26:  BRA     D2C
00D28:  IOR      W2,  W3,W6
00D2A:  BRA     Z,D3C
00D2C:  BTSC    W3.4
00D2E:  BRA     D3C
00D30:  BCLR.B  42.0
00D32:  RLC     W0,W0
00D34:  RLC     W1,W1
00D36:  RLC     W2,W2
00D38:  RLC     W3,W3
00D3A:  DEC     W8,W8
00D3C:  SL      W8,#4,W8
00D3E:  BCLR    W3.F
00D40:  BTSC    W13.F
00D42:  BSET    W3.F
00D44:  BCLR    W3.4
00D46:  XOR     W8,W3,W3
00D48:  BRA     D50
00D4A:  MUL.UU  W0,#0,W0
00D4C:  MUL.UU  W0,#0,W2
00D4E:  BRA     D50
00D50:  MOV     #1A,W8
00D52:  REPEAT  #4
00D54:  MOV     [--W15],[W8--]
00D56:  MOV     [--W15],W8
00D58:  RETURN  
00D5A:  MOV     W8,[W15++]
00D5C:  MOV     #12,W8
00D5E:  REPEAT  #4
00D60:  MOV     [W8++],[W15++]
00D62:  XOR     W3,W7,W13
00D64:  MOV     W3,W8
00D66:  MOV     W7,W9
00D68:  MOV     #7FF,W10
00D6A:  BCLR.B  42.0
00D6C:  BCLR.B  42.1
00D6E:  ASR     W8,#4,W8
00D70:  AND     W10,W8,W8
00D72:  CP0     W8
00D74:  BRA     Z,E4E
00D76:  BCLR.B  42.0
00D78:  BCLR.B  42.1
00D7A:  ASR     W9,#4,W9
00D7C:  AND     W10,W9,W9
00D7E:  CP0     W9
00D80:  BRA     Z,E4E
00D82:  CLR     W10
00D84:  SUB     W8,W9,W12
00D86:  BRA     NC,D8E
00D88:  ADD     #3FF,W12
00D8A:  BRA     C,E4E
00D8C:  BRA     D96
00D8E:  MOV     #401,W11
00D90:  SUB     W12,W11,W12
00D92:  BRA     NC,E4E
00D94:  BRA     Z,E4E
00D96:  CLR     W8
00D98:  CLR     W9
00D9A:  CLR     W10
00D9C:  CLR     W11
00D9E:  AND     #1F,W3
00DA0:  BSET    W3.4
00DA2:  AND     #1F,W7
00DA4:  BSET    W7.4
00DA6:  MOV     W12,[W15++]
00DA8:  MOV     #36,W12
00DAA:  SUB     W0,W4,W0
00DAC:  SUBB    W1,W5,W1
00DAE:  SUBB    W2,W6,W2
00DB0:  SUBB    W3,W7,W3
00DB2:  BRA     N,DB8
00DB4:  BRA     C,DC2
00DB6:  BRA     NZ,DC4
00DB8:  ADD     W0,W4,W0
00DBA:  ADDC    W1,W5,W1
00DBC:  ADDC    W2,W6,W2
00DBE:  ADDC    W3,W7,W3
00DC0:  BRA     DC4
00DC2:  BSET    W8.0
00DC4:  DEC     W12,W12
00DC6:  BRA     Z,DDE
00DC8:  BCLR.B  42.0
00DCA:  RLC     W0,W0
00DCC:  RLC     W1,W1
00DCE:  RLC     W2,W2
00DD0:  RLC     W3,W3
00DD2:  BCLR.B  42.0
00DD4:  RLC     W8,W8
00DD6:  RLC     W9,W9
00DD8:  RLC     W10,W10
00DDA:  RLC     W11,W11
00DDC:  BRA     DAA
00DDE:  MOV     [--W15],W12
00DE0:  BTSC    W11.5
00DE2:  BRA     DE6
00DE4:  BRA     DF2
00DE6:  BCLR.B  42.0
00DE8:  RRC     W11,W11
00DEA:  RRC     W10,W10
00DEC:  RRC     W9,W9
00DEE:  RRC     W8,W8
00DF0:  BRA     DF8
00DF2:  DEC     W12,W12
00DF4:  BCLR.B  42.0
00DF6:  BRA     Z,E4E
00DF8:  BTSC.B  42.0
00DFA:  BRA     E0E
00DFC:  RLC     W0,W0
00DFE:  RLC     W1,W1
00E00:  RLC     W2,W2
00E02:  RLC     W3,W3
00E04:  SUB     W0,W4,W4
00E06:  SUBB    W1,W5,W5
00E08:  SUBB    W2,W6,W6
00E0A:  SUBB    W3,W7,W7
00E0C:  BRA     NC,E38
00E0E:  INC     W8,W8
00E10:  BRA     NZ,E38
00E12:  INC     W9,W9
00E14:  BRA     NZ,E38
00E16:  INC     W10,W10
00E18:  BRA     NZ,E38
00E1A:  INC     W11,W11
00E1C:  BRA     NZ,E38
00E1E:  INC     W12,W12
00E20:  BRA     Z,E4E
00E22:  BRA     E38
00E24:  DEC     W12,W12
00E26:  BRA     Z,E4E
00E28:  BTSC    W11.4
00E2A:  BRA     E38
00E2C:  BCLR.B  42.0
00E2E:  RLC     W8,W8
00E30:  RLC     W9,W9
00E32:  RLC     W10,W10
00E34:  RLC     W11,W11
00E36:  BRA     E28
00E38:  SL      W12,#4,W12
00E3A:  BCLR.B  42.0
00E3C:  BCLR    W12.F
00E3E:  BTSC    W13.F
00E40:  BSET    W12.F
00E42:  BCLR    W11.4
00E44:  XOR     W12,W11,W3
00E46:  MOV     W10,W2
00E48:  MOV     W9,W1
00E4A:  MOV     W8,W0
00E4C:  BRA     E58
00E4E:  MOV     #0,W0
00E50:  MOV     #0,W1
00E52:  MOV     #0,W2
00E54:  MOV     #0,W3
00E56:  BRA     E58
00E58:  MOV     #1A,W8
00E5A:  REPEAT  #4
00E5C:  MOV     [--W15],[W8--]
00E5E:  MOV     [--W15],W8
00E60:  RETURN  
*
01A7A:  MOV     #F000,W1
01A7C:  ADD     W1,W3,W3
01A7E:  MOV     #7F,W1
01A80:  ADDC    W1,#0,W1
01A82:  MOV     W1,32
01A84:  BCLR    W5.0
01A86:  CP0     W5
01A88:  BRA     Z,1A90
01A8A:  TBLRDL  [W3++],[W4++]
01A8C:  DEC2    W5,W5
01A8E:  BRA     NZ,1A88
01A90:  RETURN  
*
01B2C:  MOV     W5,[W15++]
01B2E:  MOV     #C,W5
01B30:  REPEAT  #3
01B32:  MOV     [W5++],[W15++]
01B34:  MOV     W0,W4
01B36:  MOV     W1,W5
01B38:  MOV     W2,W6
01B3A:  MOV     W3,W7
01B3C:  CLR     W0
01B3E:  CLR     W1
01B40:  CLR     W2
01B42:  CLR     W3
01B44:  BCLR    W8.0
01B46:  BTSS    W7.F
01B48:  BRA     1B5A
01B4A:  BSET    W8.0
01B4C:  COM     W7,W7
01B4E:  COM     W6,W6
01B50:  COM     W5,W5
01B52:  NEG     W4,W4
01B54:  ADDC    W5,#0,W5
01B56:  ADDC    W6,#0,W6
01B58:  ADDC    W7,#0,W7
01B5A:  IOR      W4,  W5,W9
01B5C:  BRA     NZ,1B62
01B5E:  IOR      W6,  W7,W9
01B60:  BRA     Z,1B8C
01B62:  MOV     #473,W9
01B64:  BTSC    W3.4
01B66:  BRA     1B7E
01B68:  BCLR.B  42.0
01B6A:  RLC     W4,W4
01B6C:  RLC     W5,W5
01B6E:  RLC     W6,W6
01B70:  RLC     W7,W7
01B72:  RLC     W0,W0
01B74:  RLC     W1,W1
01B76:  RLC     W2,W2
01B78:  RLC     W3,W3
01B7A:  DEC     W9,W9
01B7C:  BRA     NZ,1B64
01B7E:  SL      W9,#4,W9
01B80:  BCLR.B  42.0
01B82:  BCLR    W9.F
01B84:  BCLR    W3.4
01B86:  XOR     W9,W3,W3
01B88:  BTSC    W8.0
01B8A:  BSET    W3.F
01B8C:  MOV     #12,W5
01B8E:  REPEAT  #3
01B90:  MOV     [--W15],[W5--]
01B92:  MOV     [--W15],W5
01B94:  RETURN  
*
01C40:  MOV     W8,[W15++]
01C42:  MOV     #12,W8
01C44:  REPEAT  #4
01C46:  MOV     [W8++],[W15++]
01C48:  MOV     #8000,W8
01C4A:  BTSC.B  43.0
01C4C:  XOR     W8,W7,W7
01C4E:  CP0     W0
01C50:  BRA     NZ,1C60
01C52:  CP0     W1
01C54:  BRA     NZ,1C60
01C56:  CP0     W2
01C58:  BRA     NZ,1C60
01C5A:  MOV     #7FFF,W10
01C5C:  AND     W3,W10,W10
01C5E:  BTSS.B  42.1
01C60:  MOV     W3,W10
01C62:  XOR     W7,W10,W11
01C64:  MOV     W3,W8
01C66:  MOV     W7,W9
01C68:  MOV     W7,W12
01C6A:  MOV     #7FF,W13
01C6C:  BCLR.B  42.1
01C6E:  BCLR.B  42.0
01C70:  ASR     W8,#4,W8
01C72:  AND     W13,W8,W8
01C74:  CP0     W8
01C76:  BRA     Z,1DF0
01C78:  BCLR.B  42.1
01C7A:  BCLR.B  42.0
01C7C:  ASR     W9,#4,W9
01C7E:  AND     W13,W9,W9
01C80:  CP0     W9
01C82:  BRA     Z,1E00
01C84:  CLR     W13
01C86:  BCLR.B  42.1
01C88:  BCLR.B  42.0
01C8A:  CP      W9,W8
01C8C:  BRA     Z,1E02
01C8E:  BRA     N,1E12
01C90:  BCLR    W13.0
01C92:  BSET    W13.1
01C94:  SUB     W9,W8,W8
01C96:  AND     #F,W3
01C98:  BSET    W3.4
01C9A:  AND     #F,W7
01C9C:  BSET    W7.4
01C9E:  SUB     #34,W8
01CA0:  BRA     NN,1CCE
01CA2:  ADD     #34,W8
01CA4:  BCLR.B  42.1
01CA6:  BCLR.B  42.0
01CA8:  RRC     W3,W3
01CAA:  RRC     W2,W2
01CAC:  RRC     W1,W1
01CAE:  RRC     W0,W0
01CB0:  DEC     W8,W8
01CB2:  BRA     NZ,1CA4
01CB4:  BRA     1CDE
01CB6:  SUB     #34,W8
01CB8:  BRA     NN,1CD8
01CBA:  ADD     #34,W8
01CBC:  BCLR.B  42.1
01CBE:  BCLR.B  42.0
01CC0:  RRC     W7,W7
01CC2:  RRC     W6,W6
01CC4:  RRC     W5,W5
01CC6:  RRC     W4,W4
01CC8:  DEC     W8,W8
01CCA:  BRA     NZ,1CBC
01CCC:  BRA     1D04
01CCE:  MOV     W4,W0
01CD0:  MOV     W5,W1
01CD2:  MOV     W6,W2
01CD4:  MOV     W7,W3
01CD6:  XOR     W11,W12,W12
01CD8:  BTSC    W12.F
01CDA:  BTG     W11.F
01CDC:  BRA     1DD0
01CDE:  BTSS    W11.F
01CE0:  BRA     1D20
01CE2:  BTSC    W13.4
01CE4:  MOV     W12,W11
01CE6:  COM     W0,W0
01CE8:  COM     W1,W1
01CEA:  COM     W2,W2
01CEC:  COM.B   W3L,W3L
01CEE:  AND.B   #1F,W3L
01CF0:  INC     W0,W0
01CF2:  BRA     NZ,1CFE
01CF4:  INC     W1,W1
01CF6:  BRA     NZ,1CFE
01CF8:  INC     W2,W2
01CFA:  BRA     NZ,1CFE
01CFC:  INC.B   W3L,W3L
01CFE:  BTSC    W13.4
01D00:  BRA     1D66
01D02:  BRA     1D20
01D04:  BTSS    W11.F
01D06:  BRA     1D20
01D08:  COM     W4,W4
01D0A:  COM     W5,W5
01D0C:  COM     W6,W6
01D0E:  COM.B   W7L,W7L
01D10:  AND.B   #1F,W7L
01D12:  INC     W4,W4
01D14:  BRA     NZ,1D20
01D16:  INC     W5,W5
01D18:  BRA     NZ,1D20
01D1A:  INC     W6,W6
01D1C:  BRA     NZ,1D20
01D1E:  INC.B   W7L,W7L
01D20:  BCLR.B  42.1
01D22:  BCLR.B  42.0
01D24:  ADD     W0,W4,W0
01D26:  ADDC    W1,W5,W1
01D28:  ADDC    W2,W6,W2
01D2A:  ADDC.B  W3L,W7L,W3L
01D2C:  BTSC    W3.5
01D2E:  BSET    W13.3
01D30:  BTSC    W13.0
01D32:  BRA     1D46
01D34:  BTSC    W13.1
01D36:  BRA     1D3A
01D38:  BRA     1D50
01D3A:  BTSC    W11.F
01D3C:  BRA     1D66
01D3E:  BTSC    W13.3
01D40:  BRA     1D94
01D42:  BSET    W13.6
01D44:  BRA     1D88
01D46:  BTSC    W11.F
01D48:  BRA     1D66
01D4A:  BTSC    W13.3
01D4C:  BRA     1D94
01D4E:  BRA     1D88
01D50:  BTSC    W11.F
01D52:  BRA     1D5C
01D54:  MOV     W10,W11
01D56:  BTSC    W13.3
01D58:  BRA     1D94
01D5A:  BRA     1DD0
01D5C:  BSET    W13.4
01D5E:  XOR.B   #10,W3L
01D60:  BTSC    W3.4
01D62:  BRA     1CE2
01D64:  MOV     W10,W11
01D66:  AND     #1F,W3
01D68:  IOR      W3,  W2,W8
01D6A:  BRA     NZ,1D70
01D6C:  IOR      W1,  W0,W8
01D6E:  BRA     Z,1D88
01D70:  BTSC    W3.4
01D72:  BRA     1D88
01D74:  BCLR.B  42.1
01D76:  BCLR.B  42.0
01D78:  RLC     W0,W0
01D7A:  RLC     W1,W1
01D7C:  RLC     W2,W2
01D7E:  RLC     W3,W3
01D80:  DEC     W9,W9
01D82:  BTSC.B  42.1
01D84:  BRA     1DEA
01D86:  BRA     1D70
01D88:  BTSC    W13.0
01D8A:  MOV     W10,W11
01D8C:  BTSC    W13.1
01D8E:  MOV     W12,W11
01D90:  BTSS    W13.5
01D92:  BRA     1DD0
01D94:  BCLR.B  42.0
01D96:  RRC.B   W3L,W3L
01D98:  RRC     W2,W2
01D9A:  RRC     W1,W1
01D9C:  RRC     W0,W0
01D9E:  BTSC.B  42.0
01DA0:  BSET    W13.5
01DA2:  INC     W9,W9
01DA4:  BTSC.B  42.1
01DA6:  BRA     1DEA
01DA8:  BTSS    W13.5
01DAA:  BRA     1DC8
01DAC:  INC     W0,W0
01DAE:  BRA     NZ,1DC8
01DB0:  INC     W1,W1
01DB2:  BRA     NZ,1DC8
01DB4:  INC     W2,W2
01DB6:  BRA     NZ,1DC8
01DB8:  INC     W3,W3
01DBA:  BRA     NZ,1DC8
01DBC:  RRC.B   W3L,W3L
01DBE:  RRC     W2,W2
01DC0:  RRC     W1,W1
01DC2:  RRC     W0,W0
01DC4:  INC     W9,W9
01DC6:  BRA     Z,1DEA
01DC8:  BTSC    W13.0
01DCA:  MOV     W10,W11
01DCC:  BTSC    W13.1
01DCE:  MOV     W12,W11
01DD0:  IOR      W0,  W1,W4
01DD2:  BRA     NZ,1DD8
01DD4:  IOR      W2,  W3,W4
01DD6:  BRA     Z,1E24
01DD8:  BCLR    W3.4
01DDA:  BCLR.B  42.1
01DDC:  BCLR.B  42.0
01DDE:  SL      W9,#4,W9
01DE0:  XOR     W9,W3,W3
01DE2:  BSET    W3.F
01DE4:  BTSS    W11.F
01DE6:  BCLR    W3.F
01DE8:  BRA     1E24
01DEA:  MUL.UU  W0,#0,W0
01DEC:  MUL.UU  W2,#0,W2
01DEE:  BRA     1E24
01DF0:  MOV     #8000,W8
01DF2:  BTSC    W10.F
01DF4:  XOR     W8,W7,W7
01DF6:  MOV     W5,W1
01DF8:  MOV     W4,W0
01DFA:  MOV     W6,W2
01DFC:  MOV     W7,W3
01DFE:  BRA     1E24
01E00:  BRA     1E24
01E02:  AND     #F,W7
01E04:  BSET    W7.4
01E06:  AND     #F,W3
01E08:  BSET    W3.4
01E0A:  BTSC    W11.F
01E0C:  BCLR    W7.4
01E0E:  BSET    W13.2
01E10:  BRA     1D04
01E12:  AND     #F,W3
01E14:  BSET    W3.4
01E16:  AND     #F,W7
01E18:  BSET    W7.4
01E1A:  SUB     W8,W9,W8
01E1C:  ADD     W8,W9,W9
01E1E:  BCLR    W13.1
01E20:  BSET    W13.0
01E22:  BRA     1CB6
01E24:  MOV     #1A,W8
01E26:  REPEAT  #4
01E28:  MOV     [--W15],[W8--]
01E2A:  MOV     [--W15],W8
01E2C:  RETURN  
01E2E:  MOV     W8,[W15++]
01E30:  MOV     W9,[W15++]
01E32:  MOV     W10,[W15++]
01E34:  XOR     W3,W7,W9
01E36:  BTSS    W9.F
01E38:  BRA     1E46
01E3A:  BCLR.B  42.0
01E3C:  BCLR.B  42.1
01E3E:  BTSS    W3.F
01E40:  BRA     1EAA
01E42:  BSET.B  42.0
01E44:  BRA     1EAA
01E46:  MOV     #7FF,W10
01E48:  MOV     W3,W8
01E4A:  MOV     W7,W9
01E4C:  ASR     W8,#4,W8
01E4E:  AND     W10,W8,W8
01E50:  ASR     W9,#4,W9
01E52:  AND     W10,W9,W9
01E54:  SUB     W9,W8,W10
01E56:  BRA     Z,1E62
01E58:  BTSS    W3.F
01E5A:  BRA     1EAA
01E5C:  MOV     #1,W0
01E5E:  XOR.B   42
01E60:  BRA     1EAA
01E62:  MOV     W3,W8
01E64:  MOV     W7,W9
01E66:  AND     #1F,W3
01E68:  AND     #1F,W7
01E6A:  BCLR    W3.4
01E6C:  BCLR    W7.4
01E6E:  SUB.B   W7L,W3L,W10L
01E70:  BRA     Z,1E7C
01E72:  BTSS    W8.F
01E74:  BRA     1EAA
01E76:  MOV     #1,W0
01E78:  XOR.B   42
01E7A:  BRA     1EAA
01E7C:  SUB     W6,W2,W10
01E7E:  BRA     Z,1E8A
01E80:  BTSS    W8.F
01E82:  BRA     1EAA
01E84:  MOV     #1,W0
01E86:  XOR.B   42
01E88:  BRA     1EAA
01E8A:  SUB     W5,W1,W10
01E8C:  BRA     Z,1E98
01E8E:  BTSS    W8.F
01E90:  BRA     1EAA
01E92:  MOV     #1,W0
01E94:  XOR.B   42
01E96:  BRA     1EAA
01E98:  SUB     W4,W0,W10
01E9A:  BRA     Z,1EA6
01E9C:  BTSS    W8.F
01E9E:  BRA     1EAA
01EA0:  MOV     #1,W0
01EA2:  XOR.B   42
01EA4:  BRA     1EAA
01EA6:  BCLR.B  42.0
01EA8:  BRA     1EAA
01EAA:  MOV     [--W15],W10
01EAC:  MOV     [--W15],W9
01EAE:  MOV     [--W15],W8
01EB0:  RETURN  
*
02230:  MOV     W5,[W15++]
02232:  MOV     #C,W5
02234:  REPEAT  #5
02236:  MOV     [W5++],[W15++]
02238:  MOV     W3,W8
0223A:  MOV     W2,W7
0223C:  MOV     W1,W6
0223E:  MOV     W0,W5
02240:  MOV     W3,W9
02242:  MOV     #473,W11
02244:  ASR     W3,#4,W3
02246:  MOV     #7FF,W10
02248:  AND     W10,W3,W3
0224A:  SUB     W11,W3,W11
0224C:  AND     #1F,W8
0224E:  BSET    W8.4
02250:  CLR     W0
02252:  CLR     W1
02254:  CLR     W2
02256:  CLR     W3
02258:  BCLR.B  42.0
0225A:  RRC     W8,W8
0225C:  RRC     W7,W7
0225E:  RRC     W6,W6
02260:  RRC     W5,W5
02262:  RRC     W3,W3
02264:  RRC     W2,W2
02266:  RRC     W1,W1
02268:  RRC     W0,W0
0226A:  DEC     W11,W11
0226C:  BRA     NZ,2258
0226E:  BTSS    W9.F
02270:  BRA     2284
02272:  COM     W0,W0
02274:  COM     W1,W1
02276:  COM     W2,W2
02278:  COM     W3,W3
0227A:  INC     W0,W0
0227C:  ADDC    #0,W1
0227E:  ADDC    #0,W2
02280:  ADDC    #0,W3
02282:  BRA     2284
02284:  MOV     #16,W5
02286:  REPEAT  #5
02288:  MOV     [--W15],[W5--]
0228A:  MOV     [--W15],W5
0228C:  RETURN  
*
02316:  MOV     W5,[W15++]
02318:  MOV     #C,W5
0231A:  REPEAT  #5
0231C:  MOV     [W5++],[W15++]
0231E:  MOV     W3,W8
02320:  MOV     W2,W7
02322:  MOV     W1,W6
02324:  MOV     W0,W5
02326:  MOV     W3,W9
02328:  MOV     #473,W11
0232A:  ASR     W3,#4,W3
0232C:  MOV     #7FF,W10
0232E:  AND     W10,W3,W3
02330:  SUB     W11,W3,W11
02332:  AND     #1F,W8
02334:  BSET    W8.4
02336:  CLR     W0
02338:  CLR     W1
0233A:  CLR     W2
0233C:  CLR     W3
0233E:  BCLR.B  42.0
02340:  RRC     W8,W8
02342:  RRC     W7,W7
02344:  RRC     W6,W6
02346:  RRC     W5,W5
02348:  RRC     W3,W3
0234A:  RRC     W2,W2
0234C:  RRC     W1,W1
0234E:  RRC     W0,W0
02350:  DEC     W11,W11
02352:  BRA     NZ,233E
02354:  BTSS    W9.F
02356:  BRA     236A
02358:  COM     W0,W0
0235A:  COM     W1,W1
0235C:  COM     W2,W2
0235E:  COM     W3,W3
02360:  INC     W0,W0
02362:  ADDC    #0,W1
02364:  ADDC    #0,W2
02366:  ADDC    #0,W3
02368:  BRA     236A
0236A:  MOV     #16,W5
0236C:  REPEAT  #5
0236E:  MOV     [--W15],[W5--]
02370:  MOV     [--W15],W5
02372:  RETURN  
02374:  MOV     W5,[W15++]
02376:  MOV     #C,W5
02378:  REPEAT  #3
0237A:  MOV     [W5++],[W15++]
0237C:  MOV     W0,W4
0237E:  MOV     W1,W5
02380:  MOV     W2,W6
02382:  MOV     W3,W7
02384:  CLR     W0
02386:  CLR     W1
02388:  CLR     W2
0238A:  CLR     W3
0238C:  BCLR    W8.0
0238E:  BTSS    W7.F
02390:  BRA     23A2
02392:  BSET    W8.0
02394:  COM     W7,W7
02396:  COM     W6,W6
02398:  COM     W5,W5
0239A:  NEG     W4,W4
0239C:  ADDC    W5,#0,W5
0239E:  ADDC    W6,#0,W6
023A0:  ADDC    W7,#0,W7
023A2:  IOR      W4,  W5,W9
023A4:  BRA     NZ,23AA
023A6:  IOR      W6,  W7,W9
023A8:  BRA     Z,23D4
023AA:  MOV     #473,W9
023AC:  BTSC    W3.4
023AE:  BRA     23C6
023B0:  BCLR.B  42.0
023B2:  RLC     W4,W4
023B4:  RLC     W5,W5
023B6:  RLC     W6,W6
023B8:  RLC     W7,W7
023BA:  RLC     W0,W0
023BC:  RLC     W1,W1
023BE:  RLC     W2,W2
023C0:  RLC     W3,W3
023C2:  DEC     W9,W9
023C4:  BRA     NZ,23AC
023C6:  SL      W9,#4,W9
023C8:  BCLR.B  42.0
023CA:  BCLR    W9.F
023CC:  BCLR    W3.4
023CE:  XOR     W9,W3,W3
023D0:  BTSC    W8.0
023D2:  BSET    W3.F
023D4:  MOV     #12,W5
023D6:  REPEAT  #3
023D8:  MOV     [--W15],[W5--]
023DA:  MOV     [--W15],W5
023DC:  RETURN  
*
0684C:  MOV     W5,[W15++]
0684E:  MOV     W6,[W15++]
06850:  MOV     W3,W4
06852:  MOV     W3,W6
06854:  BCLR.B  42.0
06856:  ASR     W4,#4,W4
06858:  MOV     #7FF,W5
0685A:  AND     W5,W4,W4
0685C:  BRA     NZ,6864
0685E:  MUL.UU  W0,#0,W0
06860:  CLR     W2
06862:  BRA     688A
06864:  SUB     #380,W4
06866:  AND     #F,W3
06868:  MOV     #3,W7
0686A:  BCLR.B  42.0
0686C:  RLC     W0,W0
0686E:  RLC     W1,W1
06870:  RLC     W2,W2
06872:  RLC     W3,W3
06874:  DEC     W7,W7
06876:  BRA     NZ,686A
06878:  MOV     W1,W0
0687A:  MOV     W2,W1
0687C:  BCLR    W3.7
0687E:  SWAP    W4
06880:  BCLR.B  42.0
06882:  RRC     W4,W4
06884:  BTSC    W6.F
06886:  BSET    W4.F
06888:  XOR     W4,W3,W2
0688A:  MOV     [--W15],W6
0688C:  MOV     [--W15],W5
0688E:  RETURN  
06890:  MOV     W5,[W15++]
06892:  MOV     W6,[W15++]
06894:  MOV     W7,[W15++]
06896:  XOR     W1,W3,W4
06898:  BTSS    W4.F
0689A:  BRA     68A8
0689C:  BCLR.B  42.0
0689E:  BCLR.B  42.1
068A0:  BTSS    W1.F
068A2:  BRA     68F0
068A4:  BSET.B  42.0
068A6:  BRA     68F0
068A8:  MOV     W1,W4
068AA:  MOV     W0,W5
068AC:  MOV     W3,W6
068AE:  MOV     W2,W7
068B0:  RLC     W1,W1
068B2:  SWAP    W1
068B4:  RLC     W3,W3
068B6:  SWAP    W3
068B8:  SUB.B   W3L,W1L,W1L
068BA:  BRA     Z,68C6
068BC:  BTSS    W4.F
068BE:  BRA     68F0
068C0:  MOV     #1,W0
068C2:  XOR.B   42
068C4:  BRA     68F0
068C6:  MOV.B   W4L,W1L
068C8:  MOV.B   W6L,W3L
068CA:  BCLR    W1.7
068CC:  BCLR    W3.7
068CE:  SUB.B   W3L,W1L,W1L
068D0:  BRA     Z,68DC
068D2:  BTSS    W4.F
068D4:  BRA     68F0
068D6:  MOV     #1,W0
068D8:  XOR.B   42
068DA:  BRA     68F0
068DC:  SUB     W7,W5,W1
068DE:  BRA     Z,68EA
068E0:  BTSS    W4.F
068E2:  BRA     68F0
068E4:  MOV     #1,W0
068E6:  XOR.B   42
068E8:  BRA     68F0
068EA:  BCLR.B  42.0
068EC:  BRA     68F0
068EE:  BRA     68F0
068F0:  MOV     [--W15],W7
068F2:  MOV     [--W15],W6
068F4:  MOV     [--W15],W5
068F6:  RETURN  
068F8:  MOV     W0,W2
068FA:  MOV     W1,W3
068FC:  MOV.B   W1L,W0L
068FE:  SWAP    W0
06900:  BSET    W0.F
06902:  RLC     W1,W1
06904:  SWAP    W1
06906:  ZE      W1,W1
06908:  MOV     #8E,W4
0690A:  SUB.B   W4L,W1L,W1L
0690C:  BRA     Z,691A
0690E:  CP0     W0
06910:  BRA     Z,691A
06912:  BCLR.B  42.0
06914:  RRC     W0,W0
06916:  DEC     W1,W1
06918:  BRA     NZ,690E
0691A:  BTSS    W3.F
0691C:  BRA     6922
0691E:  NEG     W0,W0
06920:  BRA     6922
06922:  RETURN  
06924:  MOV     W5,[W15++]
06926:  MOV     W6,[W15++]
06928:  MOV     #8E,W1
0692A:  CP0     W0
0692C:  BRA     Z,6952
0692E:  BTSC    W0.F
06930:  BRA     693A
06932:  BCLR.B  42.0
06934:  RLC     W0,W0
06936:  DEC     W1,W1
06938:  BRA     692E
0693A:  SWAP    W1
0693C:  BCLR.B  42.0
0693E:  RRC     W1,W1
06940:  BCLR    W0.F
06942:  SWAP    W0
06944:  XOR.B   W0L,W1L,W1L
06946:  AND.B   #0,W0L
06948:  BRA     6958
0694A:  MOV.B   W1L,W0L
0694C:  BSET    W1.7
0694E:  AND.B   #0,W1L
06950:  BRA     6958
06952:  CLR     W0
06954:  CLR     W1
06956:  BRA     6958
06958:  MOV     [--W15],W6
0695A:  MOV     [--W15],W5
0695C:  RETURN  
0695E:  MOV     W5,[W15++]
06960:  MOV     #C,W5
06962:  REPEAT  #4
06964:  MOV     [W5++],[W15++]
06966:  MOV     W0,W4
06968:  MOV     W1,W5
0696A:  MOV     W3,W7
0696C:  MOV     W2,W6
0696E:  BCLR.B  42.0
06970:  BCLR.B  42.1
06972:  RLC     W1,W1
06974:  SWAP    W1
06976:  AND     #FF,W1
06978:  CP0     W1
0697A:  BRA     Z,6A12
0697C:  BCLR.B  42.0
0697E:  BCLR.B  42.1
06980:  RLC     W3,W3
06982:  SWAP    W3
06984:  AND     #FF,W3
06986:  CP0     W3
06988:  BRA     Z,6A12
0698A:  ZE      W0,W0
0698C:  ADD.B   W3L,W1L,W0L
0698E:  BRA     C,6998
06990:  SUB     #7F,W0
06992:  BRA     Z,6A12
06994:  BRA     NC,6A12
06996:  BRA     699C
06998:  ADD.B   #81,W0L
0699A:  BRA     C,6A12
0699C:  XOR     W5,W7,W10
0699E:  BCLR.B  42.0
069A0:  BCLR.B  42.1
069A2:  AND     #FF,W5
069A4:  BSET    W5.7
069A6:  BCLR.B  42.0
069A8:  AND     #FF,W7
069AA:  BSET    W7.7
069AC:  MUL.UU  W4,W6,W2
069AE:  MUL.UU  W5,W6,W8
069B0:  ADDC    W8,W3,W3
069B2:  MOV     W9,W1
069B4:  BTSC.B  42.0
069B6:  INC     W1,W1
069B8:  BCLR.B  42.0
069BA:  MUL.UU  W7,W4,W8
069BC:  ADDC    W8,W3,W3
069BE:  ADDC    W9,W1,W1
069C0:  MUL.UU  W5,W7,W8
069C2:  ADDC    W8,W1,W1
069C4:  INC     W0,W0
069C6:  CP0     W1
069C8:  BTSC.B  42.1
069CA:  BRA     69CE
069CC:  BRA     69D4
069CE:  CP0     W3
069D0:  BTSC.B  42.1
069D2:  BRA     69DE
069D4:  BTSC    W1.F
069D6:  BRA     69DE
069D8:  RLC     W3,W3
069DA:  RLC     W1,W1
069DC:  DEC     W0,W0
069DE:  MOV     W1,W2
069E0:  BCLR.B  42.0
069E2:  BTSS    W3.7
069E4:  BRA     69F8
069E6:  MOV     #FF00,W7
069E8:  AND     W3,W7,W3
069EA:  ADD     #100,W3
069EC:  ADDC    W2,#0,W2
069EE:  CP0     W2
069F0:  BRA     NZ,69F8
069F2:  CP0     W3
069F4:  BRA     NZ,69F8
069F6:  INC     W0,W0
069F8:  SWAP    W0
069FA:  BCLR.B  42.0
069FC:  BCLR.B  42.1
069FE:  RRC     W0,W1
06A00:  BTSC    W10.F
06A02:  BSET    W1.F
06A04:  BCLR    W2.F
06A06:  SWAP    W2
06A08:  XOR.B   W2L,W1L,W1L
06A0A:  SWAP    W3
06A0C:  MOV.B   W3L,W2L
06A0E:  MOV     W2,W0
06A10:  BRA     6A18
06A12:  MOV     #0,W0
06A14:  MOV     #0,W1
06A16:  BRA     6A18
06A18:  MOV     #14,W5
06A1A:  REPEAT  #4
06A1C:  MOV     [--W15],[W5--]
06A1E:  MOV     [--W15],W5
06A20:  RETURN  
06A22:  MOV     W5,[W15++]
06A24:  MOV     #C,W5
06A26:  REPEAT  #3
06A28:  MOV     [W5++],[W15++]
06A2A:  CLR     W9
06A2C:  MOV     #8000,W8
06A2E:  BTSC.B  43.0
06A30:  XOR     W8,W3,W3
06A32:  CP0     W0
06A34:  BRA     NZ,6A3C
06A36:  MOV     #7FFF,W10
06A38:  AND     W1,W10,W10
06A3A:  BTSS.B  42.1
06A3C:  MOV     W1,W10
06A3E:  XOR     W3,W10,W11
06A40:  MOV     W1,W6
06A42:  MOV     W3,W7
06A44:  MOV     W3,W12
06A46:  BCLR.B  42.1
06A48:  BCLR.B  42.0
06A4A:  RLC     W6,W6
06A4C:  SWAP    W6
06A4E:  AND     #FF,W6
06A50:  CP0     W6
06A52:  BRA     Z,6B96
06A54:  BCLR.B  42.1
06A56:  BCLR.B  42.0
06A58:  RLC     W7,W7
06A5A:  SWAP    W7
06A5C:  AND     #FF,W7
06A5E:  CP0     W7
06A60:  BRA     Z,6BA0
06A62:  BCLR.B  42.1
06A64:  BCLR.B  42.0
06A66:  CP      W7,W6
06A68:  BRA     Z,6BA2
06A6A:  BRA     N,6BB2
06A6C:  BCLR    W9.0
06A6E:  BSET    W9.1
06A70:  SUB     W7,W6,W8
06A72:  MOV     W7,W6
06A74:  AND     #FF,W1
06A76:  BSET    W1.7
06A78:  AND     #FF,W3
06A7A:  BSET    W3.7
06A7C:  MOV     #28,W7
06A7E:  CP      W7,W8
06A80:  BRA     N,6AA4
06A82:  BCLR.B  42.1
06A84:  BCLR.B  42.0
06A86:  RRC     W1,W1
06A88:  RRC     W0,W0
06A8A:  DEC     W8,W8
06A8C:  BRA     NZ,6A82
06A8E:  BRA     6AAA
06A90:  MOV     #28,W7
06A92:  CP      W7,W8
06A94:  BRA     N,6AA8
06A96:  BCLR.B  42.1
06A98:  BCLR.B  42.0
06A9A:  RRC     W3,W3
06A9C:  RRC     W2,W2
06A9E:  DEC     W8,W8
06AA0:  BRA     NZ,6A96
06AA2:  BRA     6AC2
06AA4:  MOV     W2,W0
06AA6:  MOV     W3,W1
06AA8:  BRA     6B30
06AAA:  BTSS    W11.F
06AAC:  BRA     6AD0
06AAE:  BTSC    W9.4
06AB0:  MOV     W12,W11
06AB2:  NEG     W0,W0
06AB4:  BRA     Z,6ABA
06AB6:  COM.B   W1L,W1L
06AB8:  BRA     6ABC
06ABA:  NEG     W1,W1
06ABC:  BTSC    W9.4
06ABE:  BRA     6B16
06AC0:  BRA     6AD0
06AC2:  BTSS    W11.F
06AC4:  BRA     6AD0
06AC6:  NEG     W2,W2
06AC8:  BRA     Z,6ACE
06ACA:  COM.B   W3L,W3L
06ACC:  BRA     6AD0
06ACE:  NEG     W3,W3
06AD0:  AND     #FF,W5
06AD2:  BCLR.B  42.1
06AD4:  BCLR.B  42.0
06AD6:  ADD     W0,W2,W0
06AD8:  ADDC.B  W1L,W3L,W1L
06ADA:  BTSC.B  42.0
06ADC:  BSET    W9.3
06ADE:  BTSC    W9.0
06AE0:  BRA     6AF4
06AE2:  BTSC    W9.1
06AE4:  BRA     6AE8
06AE6:  BRA     6AFE
06AE8:  BTSC    W11.F
06AEA:  BRA     6B16
06AEC:  BTSC    W9.3
06AEE:  BRA     6B42
06AF0:  BSET    W9.6
06AF2:  BRA     6B30
06AF4:  BTSC    W11.F
06AF6:  BRA     6B16
06AF8:  BTSC    W9.3
06AFA:  BRA     6B42
06AFC:  BRA     6B30
06AFE:  BCLR    W9.2
06B00:  BTSC    W11.F
06B02:  BRA     6B0C
06B04:  MOV     W10,W11
06B06:  BTSC    W9.3
06B08:  BRA     6B42
06B0A:  BRA     6B78
06B0C:  BSET    W9.4
06B0E:  XOR.B   #80,W1L
06B10:  BTSC    W1.7
06B12:  BRA     6AAE
06B14:  MOV     W10,W11
06B16:  AND     #FF,W1
06B18:  IOR      W0,  W1,W7
06B1A:  BRA     Z,6B30
06B1C:  BTSC    W1.7
06B1E:  BRA     6B30
06B20:  BCLR.B  42.1
06B22:  BCLR.B  42.0
06B24:  RLC     W0,W0
06B26:  RLC     W1,W1
06B28:  DEC     W6,W6
06B2A:  BTSC.B  42.1
06B2C:  BRA     6B90
06B2E:  BRA     6B1C
06B30:  BTSC    W9.0
06B32:  MOV     W10,W11
06B34:  BTSC    W9.1
06B36:  MOV     W12,W11
06B38:  BTSS    W9.5
06B3A:  BRA     6B70
06B3C:  BTSC    W10.F
06B3E:  BSET    W0.8
06B40:  BRA     6B78
06B42:  BSET.B  42.0
06B44:  RRC.B   W1L,W1L
06B46:  RRC     W0,W0
06B48:  BTSC.B  42.0
06B4A:  BSET    W9.5
06B4C:  INC     W6,W6
06B4E:  BRA     Z,6B90
06B50:  BTSS    W9.5
06B52:  BRA     6B64
06B54:  INC     W0,W0
06B56:  BRA     NZ,6B64
06B58:  INC.B   W1L,W1L
06B5A:  BRA     NZ,6B64
06B5C:  RRC.B   W1L,W1L
06B5E:  RRC     W0,W0
06B60:  INC     W6,W6
06B62:  BRA     Z,6B90
06B64:  BTSC    W9.0
06B66:  MOV     W10,W11
06B68:  BTSC    W9.1
06B6A:  MOV     W12,W11
06B6C:  BTSC.B  42.1
06B6E:  BRA     6B90
06B70:  BTSC    W9.6
06B72:  MOV     W10,W11
06B74:  BTSC    W9.7
06B76:  MOV     W12,W11
06B78:  IOR      W0,  W1,W2
06B7A:  BRA     Z,6BC2
06B7C:  BCLR    W1.7
06B7E:  SWAP    W6
06B80:  BCLR.B  42.1
06B82:  BCLR.B  42.0
06B84:  RRC     W6,W6
06B86:  XOR     W6,W1,W1
06B88:  BSET    W1.F
06B8A:  BTSS    W11.F
06B8C:  BCLR    W1.F
06B8E:  BRA     6BC2
06B90:  MOV     #0,W0
06B92:  MOV     #0,W1
06B94:  BRA     6BC2
06B96:  BTSC    W10.F
06B98:  XOR     W8,W3,W3
06B9A:  MOV     W2,W0
06B9C:  MOV     W3,W1
06B9E:  BRA     6BC2
06BA0:  BRA     6BC2
06BA2:  AND     #FF,W3
06BA4:  BSET    W3.7
06BA6:  AND     #FF,W1
06BA8:  BSET    W1.7
06BAA:  BTSC    W11.F
06BAC:  BCLR    W3.7
06BAE:  BSET    W9.2
06BB0:  BRA     6AC2
06BB2:  SUB     W6,W7,W8
06BB4:  AND     #FF,W1
06BB6:  BSET    W1.7
06BB8:  AND     #FF,W3
06BBA:  BSET    W3.7
06BBC:  BCLR    W9.1
06BBE:  BSET    W9.0
06BC0:  BRA     6A90
06BC2:  MOV     #12,W5
06BC4:  REPEAT  #3
06BC6:  MOV     [--W15],[W5--]
06BC8:  MOV     [--W15],W5
06BCA:  RETURN  
*
06D5E:  MOV     W5,[W15++]
06D60:  MOV     W1,W5
06D62:  MOV     W0,W2
06D64:  MOV     #B6,W4
06D66:  RLC     W1,W1
06D68:  SWAP    W1
06D6A:  AND     #FF,W1
06D6C:  SUB.B   W4L,W1L,W4L
06D6E:  MOV.B   W5L,W3L
06D70:  BSET    W3.7
06D72:  AND     #FF,W3
06D74:  CLR     W0
06D76:  CLR     W1
06D78:  CP      W4,#18
06D7A:  BRA     N,6D9A
06D7C:  BCLR.B  42.0
06D7E:  RRC     W3,W3
06D80:  RRC     W2,W2
06D82:  RRC     W1,W1
06D84:  RRC     W0,W0
06D86:  DEC     W4,W4
06D88:  BRA     NZ,6D7C
06D8A:  BTSS    W5.F
06D8C:  BRA     6D9A
06D8E:  NEG     W0,W0
06D90:  BRA     Z,6D96
06D92:  COM     W1,W1
06D94:  BRA     6D9A
06D96:  NEG     W1,W1
06D98:  BRA     6D9A
06D9A:  MOV     [--W15],W5
06D9C:  RETURN  
*
06DFA:  MOV     W5,[W15++]
06DFC:  MOV     #C,W5
06DFE:  REPEAT  #3
06E00:  MOV     [W5++],[W15++]
06E02:  MOV     W0,W7
06E04:  MOV     W4,W9
06E06:  BCLR    W4.F
06E08:  CP0     W4
06E0A:  BRA     NZ,6E18
06E0C:  BTSC    W9.F
06E0E:  BRA     6E14
06E10:  MOV     #0,W5
06E12:  BRA     6E36
06E14:  MOV     #0,W5
06E16:  BRA     6E36
06E18:  SUB.B   W4L,#6,W5L
06E1A:  BRA     NC,6E34
06E1C:  MOV     #30,W0
06E1E:  BTSS    W9.F
06E20:  MOV     #20,W0
06E22:  MOV     W0,[W15++]
06E24:  BTSC.B  219.1
06E26:  BRA     6E24
06E28:  MOV     W0,21A
06E2A:  MOV     [--W15],W0
06E2C:  DEC     W5,W5
06E2E:  BRA     NN,6E22
06E30:  MOV     #5,W5
06E32:  BRA     6E36
06E34:  MOV     W4,W5
06E36:  MOV     #6,W4
06E38:  BSET    W5.E
06E3A:  BTSC    W9.F
06E3C:  BSET    W5.F
06E3E:  MOV     #2710,W8
06E40:  REPEAT  #11
06E42:  DIV.U   W7,W8
06E44:  CALL    6E78
06E48:  MOV     W1,W7
06E4A:  MOV     #3E8,W8
06E4C:  REPEAT  #11
06E4E:  DIV.U   W7,W8
06E50:  CALL    6E78
06E54:  MOV     W1,W7
06E56:  MOV     #64,W8
06E58:  REPEAT  #11
06E5A:  DIV.U   W7,W8
06E5C:  CALL    6E78
06E60:  MOV     W1,W7
06E62:  MOV     #A,W8
06E64:  REPEAT  #11
06E66:  DIV.U   W7,W8
06E68:  CALL    6E78
06E6C:  MOV     #30,W0
06E6E:  ADD.B   W1L,W0L,W0L
06E70:  BTSC.B  219.1
06E72:  BRA     6E70
06E74:  MOV     W0,21A
06E76:  BRA     6EA6
06E78:  MOV     #30,W6
06E7A:  CP0     W0
06E7C:  BRA     NZ,6E9A
06E7E:  BTSS    W5.E
06E80:  BRA     6E9C
06E82:  DEC     W4,W4
06E84:  CP.B    W4L,W5L
06E86:  BRA     Z,6E8C
06E88:  BTSC.B  42.0
06E8A:  RETURN  
06E8C:  CP0     W0
06E8E:  BRA     NZ,6E9A
06E90:  BTSS    W5.E
06E92:  BRA     6E9C
06E94:  BTSS    W5.F
06E96:  MOV     #20,W6
06E98:  BRA     6E9C
06E9A:  BCLR    W5.E
06E9C:  ADD.B   W6L,W0L,W0L
06E9E:  BTSC.B  219.1
06EA0:  BRA     6E9E
06EA2:  MOV     W0,21A
06EA4:  RETURN  
06EA6:  MOV     #12,W5
06EA8:  REPEAT  #3
06EAA:  MOV     [--W15],[W5--]
06EAC:  MOV     [--W15],W5
06EAE:  RETURN  
06EB0:  MOV     W6,[W15++]
06EB2:  MOV     W7,[W15++]
06EB4:  MOV     W8,[W15++]
06EB6:  MOV     W9,[W15++]
06EB8:  CLR     W4
06EBA:  CLR     W5
06EBC:  CLR     W6
06EBE:  CLR     W7
06EC0:  XOR     W2,W3,W8
06EC2:  BRA     Z,6EE6
06EC4:  MOV     #20,W8
06EC6:  BCLR.B  42.0
06EC8:  RLC     W0,W0
06ECA:  RLC     W1,W1
06ECC:  RLC     W4,W4
06ECE:  RLC     W5,W5
06ED0:  CP      W5,W3
06ED2:  BRA     NZ,6ED6
06ED4:  CPB     W4,W2
06ED6:  BRA     NC,6EDE
06ED8:  SUB     W4,W2,W4
06EDA:  SUBB    W5,W3,W5
06EDC:  BSET.B  42.0
06EDE:  RLC     W6,W6
06EE0:  RLC     W7,W7
06EE2:  DEC     W8,W8
06EE4:  BRA     NZ,6EC6
06EE6:  MOV     W7,W1
06EE8:  MOV     W6,W0
06EEA:  MOV     [--W15],W9
06EEC:  MOV     [--W15],W8
06EEE:  MOV     [--W15],W7
06EF0:  MOV     [--W15],W6
06EF2:  RETURN  
06EF4:  MOV     W5,[W15++]
06EF6:  MOV     #C,W5
06EF8:  REPEAT  #7
06EFA:  MOV     [W5++],[W15++]
06EFC:  BTSS    W1.F
06EFE:  BRA     6F0E
06F00:  NEG     W0,W0
06F02:  BRA     Z,6F06
06F04:  BRA     NZ,6F0A
06F06:  NEG     W1,W1
06F08:  BRA     6F0C
06F0A:  COM     W1,W1
06F0C:  BSET    W4.8
06F0E:  CLR     W5
06F10:  MOV     W0,W6
06F12:  MOV     W1,W7
06F14:  MOV     W4,W12
06F16:  BCLR    W4.F
06F18:  CP0.B   W4L
06F1A:  BRA     NZ,6F1E
06F1C:  BRA     6F52
06F1E:  SUB.B   W4L,#B,W5L
06F20:  BRA     NC,6F52
06F22:  SUB.B   W4L,W5L,W4L
06F24:  BTSS    W12.F
06F26:  BRA     6F3E
06F28:  BTSS    W4.8
06F2A:  BRA     6F3A
06F2C:  MOV     #2D,W0
06F2E:  BTSC.B  219.1
06F30:  BRA     6F2E
06F32:  MOV     W0,21A
06F34:  BCLR    W4.8
06F36:  DEC     W5,W5
06F38:  BRA     N,6F52
06F3A:  MOV     #30,W0
06F3C:  BRA     6F40
06F3E:  MOV     #20,W0
06F40:  MOV     W0,[W15++]
06F42:  BTSC.B  219.1
06F44:  BRA     6F42
06F46:  MOV     W0,21A
06F48:  MOV     [--W15],W0
06F4A:  DEC     W5,W5
06F4C:  BRA     NN,6F40
06F4E:  BTSC    W4.8
06F50:  DEC.B   W4L,W4L
06F52:  MOV     #E,W8
06F54:  MOV     #0,W9
06F56:  LNK     #10
06F58:  MOV     W12,[W14+W8]
06F5A:  DEC2    W8,W8
06F5C:  BRA     NN,6F58
06F5E:  MOV     W4,W5
06F60:  MOV     #A,W4
06F62:  BTSC    W5.8
06F64:  INC     W4,W4
06F66:  BSET    W5.E
06F68:  BTSC    W12.F
06F6A:  BSET    W5.F
06F6C:  CP0.B   W5L
06F6E:  BRA     Z,6F72
06F70:  DEC.B   W5L,W5L
06F72:  MOV     W4,[W14]
06F74:  MOV     W5,[W14+#2]
06F76:  MOV     W6,W0
06F78:  MOV     W7,W1
06F7A:  MOV     #CA00,W2
06F7C:  MOV     #3B9A,W3
06F7E:  MOV     #2710,W8
06F80:  BCLR    W13.F
06F82:  BCLR.B  43.0
06F84:  CALL    6EB0
06F88:  BTG     W13.F
06F8A:  BTSC    W13.F
06F8C:  BRA     6F9C
06F8E:  MOV     W0,[W14+#8]
06F90:  MOV     W1,[W14+#A]
06F92:  MOV     W0,W2
06F94:  MOV     W1,W3
06F96:  MOV     [W14+#4],W0
06F98:  MOV     [W14+#6],W1
06F9A:  BRA     6F82
06F9C:  MOV     W2,[W14+#8]
06F9E:  MOV     W3,[W14+#A]
06FA0:  MOV     W4,[W14+#4]
06FA2:  MOV     W5,[W14+#6]
06FA4:  MOV     [W14],W4
06FA6:  MOV     [W14+#2],W5
06FA8:  MOV     #30,W6
06FAA:  CP0     W0
06FAC:  BRA     NZ,6FD0
06FAE:  BTSS    W5.E
06FB0:  BRA     6FD4
06FB2:  DEC     W4,W4
06FB4:  MOV     W4,[W14]
06FB6:  CP0     W4
06FB8:  BRA     Z,6FD4
06FBA:  CP.B    W4L,W5L
06FBC:  BRA     Z,6FC2
06FBE:  BTSC.B  42.0
06FC0:  BRA     6FF2
06FC2:  BTSS    W5.F
06FC4:  BRA     6FCC
06FC6:  BTSS    W5.8
06FC8:  BRA     6FEA
06FCA:  BRA     6FDA
06FCC:  MOV     #20,W6
06FCE:  BRA     6FEA
06FD0:  BCLR    W5.E
06FD2:  MOV     W5,[W14+#2]
06FD4:  MOV     [W14+#2],W5
06FD6:  BTSS    W5.8
06FD8:  BRA     6FEA
06FDA:  BCLR    W5.8
06FDC:  MOV     W5,[W14+#2]
06FDE:  MOV     W0,W10
06FE0:  MOV     #2D,W0
06FE2:  BTSC.B  219.1
06FE4:  BRA     6FE2
06FE6:  MOV     W0,21A
06FE8:  MOV     W10,W0
06FEA:  ADD.B   W6L,W0L,W0L
06FEC:  BTSC.B  219.1
06FEE:  BRA     6FEC
06FF0:  MOV     W0,21A
06FF2:  MOV     [W14+#8],W0
06FF4:  MOV     [W14+#A],W1
06FF6:  MOV     #A,W2
06FF8:  CLR     W3
06FFA:  CP      W0,#1
06FFC:  BRA     Z,7000
06FFE:  BRA     6F82
07000:  ULNK    
07002:  MOV     #1A,W5
07004:  REPEAT  #7
07006:  MOV     [--W15],[W5--]
07008:  MOV     [--W15],W5
0700A:  RETURN  
*
0780C:  MOV     W5,[W15++]
0780E:  MOV     #C,W5
07810:  REPEAT  #3
07812:  MOV     [W5++],[W15++]
07814:  MOV     #0,W9
07816:  BTSC.B  43.0
07818:  MOV     #1,W9
0781A:  MOV     W9,[W15++]
0781C:  XOR     W1,W3,W9
0781E:  BTSS    W1.F
07820:  BRA     7828
07822:  COM     W1,W1
07824:  NEG     W0,W0
07826:  ADDC    W1,#0,W1
07828:  BTSS    W3.F
0782A:  BRA     7832
0782C:  COM     W3,W3
0782E:  NEG     W2,W2
07830:  ADDC    W3,#0,W3
07832:  XOR     W2,W3,W4
07834:  BRA     Z,7860
07836:  CLR     W4
07838:  CLR     W5
0783A:  CLR     W6
0783C:  CLR     W7
0783E:  MOV     #20,W8
07840:  BCLR.B  42.0
07842:  RLC     W0,W0
07844:  RLC     W1,W1
07846:  RLC     W4,W4
07848:  RLC     W5,W5
0784A:  CP      W5,W3
0784C:  BRA     NZ,7850
0784E:  CPB     W4,W2
07850:  BRA     NC,7858
07852:  SUB     W4,W2,W4
07854:  SUBB    W5,W3,W5
07856:  BSET.B  42.0
07858:  RLC     W6,W6
0785A:  RLC     W7,W7
0785C:  DEC     W8,W8
0785E:  BRA     NZ,7840
07860:  BTSS    W9.F
07862:  BRA     7872
07864:  NEG     W6,W0
07866:  BRA     Z,786A
07868:  BRA     NZ,786E
0786A:  NEG     W7,W1
0786C:  BRA     7878
0786E:  COM     W7,W1
07870:  BRA     7878
07872:  MOV     W7,W1
07874:  MOV     W6,W0
07876:  BRA     7878
07878:  MOV     [--W15],W9
0787A:  CP0     W9
0787C:  BRA     Z,7880
0787E:  MOV.D   W4,W0
07880:  MOV     #12,W5
07882:  REPEAT  #3
07884:  MOV     [--W15],[W5--]
07886:  MOV     [--W15],W5
07888:  RETURN  
*
082CA:  MOV     W5,[W15++]
082CC:  MOV     W6,[W15++]
082CE:  MOV     #8E,W1
082D0:  BCLR    W6.0
082D2:  BTSS    W0.F
082D4:  BRA     82DC
082D6:  BSET    W6.0
082D8:  NEG     W0,W0
082DA:  BRA     82DC
082DC:  CP0     W0
082DE:  BRA     Z,8308
082E0:  BTSC    W0.F
082E2:  BRA     82EC
082E4:  BCLR.B  42.0
082E6:  RLC     W0,W0
082E8:  DEC     W1,W1
082EA:  BRA     82E0
082EC:  SWAP    W1
082EE:  BCLR.B  42.0
082F0:  RRC     W1,W1
082F2:  BCLR    W0.F
082F4:  SWAP    W0
082F6:  XOR.B   W0L,W1L,W1L
082F8:  AND.B   #0,W0L
082FA:  BTSC    W6.0
082FC:  BSET    W1.F
082FE:  BRA     830E
08300:  MOV.B   W1L,W0L
08302:  BSET    W1.7
08304:  AND.B   #0,W1L
08306:  BRA     830E
08308:  CLR     W0
0830A:  CLR     W1
0830C:  BRA     830E
0830E:  MOV     [--W15],W6
08310:  MOV     [--W15],W5
08312:  RETURN  
08314:  MOV     W5,[W15++]
08316:  MOV     #C,W5
08318:  REPEAT  #4
0831A:  MOV     [W5++],[W15++]
0831C:  CLR     W9
0831E:  XOR     W1,W3,W9
08320:  MOV     W1,W6
08322:  MOV     W0,W5
08324:  MOV     W3,W8
08326:  MOV     W2,W7
08328:  RLC     W1,W1
0832A:  SWAP    W1
0832C:  ZE      W1,W1
0832E:  CP0     W1
08330:  BRA     Z,83CE
08332:  RLC     W3,W3
08334:  SWAP    W3
08336:  ZE      W3,W3
08338:  CP0     W3
0833A:  BRA     Z,83CE
0833C:  CLR     W0
0833E:  SUB.B   W1L,W3L,W0L
08340:  BRA     NC,8348
08342:  ADD.B   #7F,W0L
08344:  BRA     C,83CE
08346:  BRA     834E
08348:  SUB.B   #81,W0L
0834A:  BRA     NC,83CE
0834C:  BRA     Z,83CE
0834E:  MOV     W5,W1
08350:  MOV     W6,W2
08352:  BSET    W2.7
08354:  AND     #FF,W2
08356:  AND     #FF,W8
08358:  BSET    W8.7
0835A:  MOV     #19,W10
0835C:  CLR     W3
0835E:  CLR     W4
08360:  SUB     W1,W7,W1
08362:  SUBB    W2,W8,W2
08364:  BRA     N,836A
08366:  BRA     C,8370
08368:  BRA     NZ,8372
0836A:  ADD     W1,W7,W1
0836C:  ADDC    W2,W8,W2
0836E:  BRA     8372
08370:  BSET    W4.0
08372:  DEC     W10,W10
08374:  BRA     Z,8384
08376:  BCLR.B  42.0
08378:  RLC     W1,W1
0837A:  RLC     W2,W2
0837C:  BCLR.B  42.0
0837E:  RLC     W4,W4
08380:  RLC     W3,W3
08382:  BRA     8360
08384:  CLR     W10
08386:  BTSC    W3.8
08388:  BRA     838C
0838A:  BRA     8398
0838C:  BCLR.B  42.0
0838E:  RRC     W3,W3
08390:  BCLR    W3.7
08392:  RRC     W4,W4
08394:  RLC     W10,W10
08396:  BRA     839C
08398:  DEC     W0,W0
0839A:  BRA     Z,83CE
0839C:  BTSC    W10.F
0839E:  BRA     NC,83AA
083A0:  RLC     W1,W1
083A2:  RLC     W2,W2
083A4:  SUB     W1,W7,W1
083A6:  SUBB    W2,W8,W2
083A8:  BRA     NC,83BC
083AA:  INC     W4,W4
083AC:  BRA     NZ,83BC
083AE:  INC     W3,W3
083B0:  BRA     NZ,83BC
083B2:  INC     W0,W0
083B4:  BRA     Z,83CE
083B6:  BRA     83BC
083B8:  DEC     W0,W0
083BA:  BRA     Z,83CE
083BC:  SWAP    W0
083BE:  RRC     W0,W1
083C0:  BSET    W1.F
083C2:  BTSS    W9.F
083C4:  BCLR    W1.F
083C6:  BCLR    W3.7
083C8:  XOR.B   W3L,W1L,W1L
083CA:  MOV     W4,W0
083CC:  BRA     83D4
083CE:  MOV     #0,W0
083D0:  MOV     #0,W1
083D2:  BRA     83D4
083D4:  MOV     #14,W5
083D6:  REPEAT  #4
083D8:  MOV     [--W15],[W5--]
083DA:  MOV     [--W15],W5
083DC:  RETURN  
*
084BE:  MOV     W5,[W15++]
084C0:  MOV     W6,[W15++]
084C2:  MOV     W2,W3
084C4:  MOV     W2,W5
084C6:  BCLR.B  42.0
084C8:  RLC     W3,W3
084CA:  SWAP    W3
084CC:  AND     #FF,W3
084CE:  BRA     NZ,84D6
084D0:  MUL.UU  W0,#0,W0
084D2:  MUL.UU  W2,#0,W2
084D4:  BRA     8502
084D6:  ADD     #380,W3
084D8:  AND     #7F,W2
084DA:  MOV     #3,W6
084DC:  CLR     W4
084DE:  BCLR.B  42.0
084E0:  RRC     W2,W2
084E2:  RRC     W1,W1
084E4:  RRC     W0,W0
084E6:  BTSC.B  42.0
084E8:  INC     W4,W4
084EA:  DEC     W6,W6
084EC:  BRA     NZ,84DE
084EE:  BCLR    W2.7
084F0:  SL      W3,#4,W3
084F2:  BCLR    W3.F
084F4:  BTSC    W5.F
084F6:  BSET    W3.F
084F8:  XOR     W2,W3,W3
084FA:  MOV     W1,W2
084FC:  MOV     W0,W1
084FE:  ADD     W4,W1,W1
08500:  CLR     W0
08502:  MOV     [--W15],W6
08504:  MOV     [--W15],W5
08506:  RETURN  
08508:  MOV     W12,[W15++]
0850A:  MOV     W13,[W15++]
0850C:  CLR     W8
0850E:  CLR     W9
08510:  CLR     W10
08512:  CLR     W11
08514:  CLR     W12
08516:  CLR     W13
08518:  MOV     #E,W8
0851A:  MOV     #0,W9
0851C:  LNK     #10
0851E:  MOV     W12,[W14+W8]
08520:  DEC2    W8,W8
08522:  BRA     NN,851E
08524:  XOR     W4,W5,W8
08526:  BRA     NZ,852C
08528:  XOR     W6,W7,W8
0852A:  BRA     Z,858A
0852C:  CLR     W8
0852E:  MOV     #40,W13
08530:  MOV     #40,W13
08532:  BCLR.B  42.0
08534:  RLC     W0,W0
08536:  RLC     W1,W1
08538:  RLC     W2,W2
0853A:  RLC     W3,W3
0853C:  RLC     W8,W8
0853E:  RLC     W9,W9
08540:  RLC     W10,W10
08542:  RLC     W11,W11
08544:  CP      W11,W7
08546:  BRA     NZ,8552
08548:  CPB     W10,W6
0854A:  BRA     NZ,8552
0854C:  CPB     W9,W5
0854E:  BRA     NZ,8552
08550:  CPB     W8,W4
08552:  BRA     NC,855E
08554:  SUB     W8,W4,W8
08556:  SUBB    W9,W5,W9
08558:  SUBB    W10,W6,W10
0855A:  SUBB    W11,W7,W11
0855C:  BSET.B  42.0
0855E:  MOV     W8,[W14]
08560:  MOV     W9,[W14+#2]
08562:  MOV     W10,[W14+#4]
08564:  MOV     W11,[W14+#6]
08566:  MOV     [W14+#8],W8
08568:  MOV     [W14+#A],W9
0856A:  MOV     [W14+#C],W10
0856C:  MOV     [W14+#E],W11
0856E:  RLC     W8,W8
08570:  RLC     W9,W9
08572:  RLC     W10,W10
08574:  RLC     W11,W11
08576:  MOV     W8,[W14+#8]
08578:  MOV     W9,[W14+#A]
0857A:  MOV     W10,[W14+#C]
0857C:  MOV     W11,[W14+#E]
0857E:  MOV     [W14],W8
08580:  MOV     [W14+#2],W9
08582:  MOV     [W14+#4],W10
08584:  MOV     [W14+#6],W11
08586:  DEC     W13,W13
08588:  BRA     NZ,8532
0858A:  MOV     [W14+#8],W0
0858C:  MOV     [W14+#A],W1
0858E:  MOV     [W14+#C],W2
08590:  MOV     [W14+#E],W3
08592:  ULNK    
08594:  BRA     8596
08596:  MOV     [--W15],W13
08598:  MOV     [--W15],W12
0859A:  RETURN  
0859C:  MOV     W5,[W15++]
0859E:  MOV     #C,W5
085A0:  REPEAT  #5
085A2:  MOV     [W5++],[W15++]
085A4:  BTSS    W3.F
085A6:  BRA     85B8
085A8:  COM     W1,W1
085AA:  COM     W2,W2
085AC:  COM     W3,W3
085AE:  NEG     W0,W0
085B0:  ADDC    W1,#0,W1
085B2:  ADDC    W2,#0,W2
085B4:  ADDC    W3,#0,W3
085B6:  BSET    W4.8
085B8:  MOV     W0,W6
085BA:  MOV     W4,W12
085BC:  BCLR    W4.F
085BE:  CP0     W4
085C0:  BRA     NZ,85C4
085C2:  BRA     85F8
085C4:  SUB.B   W4L,#14,W5L
085C6:  BRA     NC,85F8
085C8:  SUB.B   W4L,W5L,W4L
085CA:  BTSS    W12.F
085CC:  BRA     85E4
085CE:  BTSS    W4.8
085D0:  BRA     85E0
085D2:  MOV     #2D,W0
085D4:  BTSC.B  219.1
085D6:  BRA     85D4
085D8:  MOV     W0,21A
085DA:  BCLR    W4.8
085DC:  DEC     W5,W5
085DE:  BRA     N,85F8
085E0:  MOV     #30,W0
085E2:  BRA     85E6
085E4:  MOV     #20,W0
085E6:  MOV     W0,[W15++]
085E8:  BTSC.B  219.1
085EA:  BRA     85E8
085EC:  MOV     W0,21A
085EE:  MOV     [--W15],W0
085F0:  DEC     W5,W5
085F2:  BRA     NN,85E6
085F4:  BTSC    W4.8
085F6:  DEC.B   W4L,W4L
085F8:  MOV     #E,W8
085FA:  MOV     #0,W9
085FC:  LNK     #16
085FE:  MOV     W12,[W14+W8]
08600:  DEC2    W8,W8
08602:  BRA     NN,85FE
08604:  MOV     W4,W5
08606:  MOV     #13,W4
08608:  BTSC    W5.8
0860A:  INC     W4,W4
0860C:  BSET    W5.E
0860E:  BTSC    W12.F
08610:  BSET    W5.F
08612:  CP0.B   W5L
08614:  BRA     Z,8618
08616:  DEC.B   W5L,W5L
08618:  MOV     W4,[W14]
0861A:  MOV     W5,[W14+#2]
0861C:  MOV     W6,W0
0861E:  CLR     W4
08620:  MOV     #A764,W5
08622:  MOV     #B6B3,W6
08624:  MOV     #DE0,W7
08626:  BCLR    W13.F
08628:  MOV     W13,[W14+#14]
0862A:  CALL    8508
0862E:  MOV     [W14+#14],W13
08630:  BTG     W13.F
08632:  MOV     W13,[W14+#14]
08634:  BTSC    W13.F
08636:  BRA     8652
08638:  MOV     W0,[W14+#C]
0863A:  MOV     W1,[W14+#E]
0863C:  MOV     W2,[W14+#10]
0863E:  MOV     W3,[W14+#12]
08640:  MOV     W0,W4
08642:  MOV     W1,W5
08644:  MOV     W2,W6
08646:  MOV     W3,W7
08648:  MOV     [W14+#4],W0
0864A:  MOV     [W14+#6],W1
0864C:  MOV     [W14+#8],W2
0864E:  MOV     [W14+#A],W3
08650:  BRA     862A
08652:  MOV     W4,[W14+#C]
08654:  MOV     W5,[W14+#E]
08656:  MOV     W6,[W14+#10]
08658:  MOV     W7,[W14+#12]
0865A:  MOV     W8,[W14+#4]
0865C:  MOV     W9,[W14+#6]
0865E:  MOV     W10,[W14+#8]
08660:  MOV     W11,[W14+#A]
08662:  MOV     [W14],W4
08664:  MOV     [W14+#2],W5
08666:  MOV     #30,W6
08668:  CP0     W0
0866A:  BRA     NZ,868E
0866C:  BTSS    W5.E
0866E:  BRA     8692
08670:  DEC     W4,W4
08672:  MOV     W4,[W14]
08674:  CP0     W4
08676:  BRA     Z,8692
08678:  CP.B    W4L,W5L
0867A:  BRA     Z,8680
0867C:  BTSC.B  42.0
0867E:  BRA     86AE
08680:  BTSS    W5.F
08682:  BRA     868A
08684:  BTSS    W5.8
08686:  BRA     86A6
08688:  BRA     8696
0868A:  MOV     #20,W6
0868C:  BRA     86A6
0868E:  BCLR    W5.E
08690:  MOV     W5,[W14+#2]
08692:  BTSS    W5.8
08694:  BRA     86A6
08696:  BCLR    W5.8
08698:  MOV     W5,[W14+#2]
0869A:  MOV     W0,W10
0869C:  MOV     #2D,W0
0869E:  BTSC.B  219.1
086A0:  BRA     869E
086A2:  MOV     W0,21A
086A4:  MOV     W10,W0
086A6:  ADD.B   W6L,W0L,W0L
086A8:  BTSC.B  219.1
086AA:  BRA     86A8
086AC:  MOV     W0,21A
086AE:  MOV     [W14+#C],W0
086B0:  MOV     [W14+#E],W1
086B2:  MOV     [W14+#10],W2
086B4:  MOV     [W14+#12],W3
086B6:  MOV     #A,W4
086B8:  CLR     W5
086BA:  MUL.UU  W6,#0,W6
086BC:  CP      W0,#1
086BE:  BRA     Z,86C2
086C0:  BRA     862A
086C2:  ULNK    
086C4:  MOV     #16,W5
086C6:  REPEAT  #5
086C8:  MOV     [--W15],[W5--]
086CA:  MOV     [--W15],W5
086CC:  RETURN  
*
0916A:  MOV     W5,[W15++]
0916C:  MOV     #C,W5
0916E:  REPEAT  #3
09170:  MOV     [W5++],[W15++]
09172:  BTSS    W0.F
09174:  BRA     918E
09176:  NEG     W0,W0
09178:  BSET    W4.8
0917A:  BTSS    W4.F
0917C:  BRA     918E
0917E:  MOV     W0,[W15++]
09180:  MOV     #2D,W0
09182:  BTSC.B  219.1
09184:  BRA     9182
09186:  MOV     W0,21A
09188:  MOV     [--W15],W0
0918A:  BCLR    W4.8
0918C:  DEC.B   0008
0918E:  CLR     W5
09190:  MOV     W0,W7
09192:  MOV     W4,W9
09194:  BCLR    W4.F
09196:  CP0.B   W4L
09198:  BRA     NZ,91A6
0919A:  BTSC    W9.F
0919C:  BRA     91A2
0919E:  MOV     #0,W5
091A0:  BRA     91CA
091A2:  MOV     #0,W5
091A4:  BRA     91CA
091A6:  BTSS    W9.8
091A8:  SUB.B   W4L,#6,W5L
091AA:  BTSC    W9.8
091AC:  SUB.B   W4L,#7,W5L
091AE:  BRA     NC,91C8
091B0:  MOV     #30,W0
091B2:  BTSS    W9.F
091B4:  MOV     #20,W0
091B6:  MOV     W0,[W15++]
091B8:  BTSC.B  219.1
091BA:  BRA     91B8
091BC:  MOV     W0,21A
091BE:  MOV     [--W15],W0
091C0:  DEC     W5,W5
091C2:  BRA     NN,91B6
091C4:  MOV     #5,W5
091C6:  BRA     91CA
091C8:  MOV     W4,W5
091CA:  MOV     #6,W4
091CC:  BTSC    W5.8
091CE:  INC     W4,W4
091D0:  BSET    W5.E
091D2:  BTSC    W9.F
091D4:  BSET    W5.F
091D6:  MOV     #2710,W8
091D8:  REPEAT  #11
091DA:  DIV.U   W7,W8
091DC:  CALL    9220
091E0:  MOV     W1,W7
091E2:  MOV     #3E8,W8
091E4:  REPEAT  #11
091E6:  DIV.U   W7,W8
091E8:  CALL    9220
091EC:  MOV     W1,W7
091EE:  MOV     #64,W8
091F0:  REPEAT  #11
091F2:  DIV.U   W7,W8
091F4:  CALL    9220
091F8:  MOV     W1,W7
091FA:  MOV     #A,W8
091FC:  REPEAT  #11
091FE:  DIV.U   W7,W8
09200:  CALL    9220
09204:  BTSS    W9.8
09206:  BRA     9212
09208:  MOV     #2D,W0
0920A:  BTSC.B  219.1
0920C:  BRA     920A
0920E:  MOV     W0,21A
09210:  BCLR    W9.8
09212:  MOV     #30,W0
09214:  ADD.B   W1L,W0L,W0L
09216:  MOV     W0,2A
09218:  BTSC.B  219.1
0921A:  BRA     9218
0921C:  MOV     W0,21A
0921E:  BRA     9260
09220:  MOV     #30,W6
09222:  CP0     W0
09224:  BRA     NZ,9242
09226:  BTSS    W5.E
09228:  BRA     9256
0922A:  DEC     W4,W4
0922C:  CP.B    W4L,W5L
0922E:  BRA     Z,9234
09230:  BTSC.B  42.0
09232:  RETURN  
09234:  CP0     W0
09236:  BRA     NZ,9242
09238:  BTSS    W5.E
0923A:  BRA     9256
0923C:  BTSS    W5.F
0923E:  MOV     #20,W6
09240:  BRA     9256
09242:  BCLR    W5.E
09244:  BTSS    W9.8
09246:  BRA     9256
09248:  MOV     W0,W10
0924A:  MOV     #2D,W0
0924C:  BTSC.B  219.1
0924E:  BRA     924C
09250:  MOV     W0,21A
09252:  BCLR    W9.8
09254:  MOV     W10,W0
09256:  ADD.B   W6L,W0L,W0L
09258:  BTSC.B  219.1
0925A:  BRA     9258
0925C:  MOV     W0,21A
0925E:  RETURN  
09260:  MOV     #12,W5
09262:  REPEAT  #3
09264:  MOV     [--W15],[W5--]
09266:  MOV     [--W15],W5
09268:  RETURN  
*
0A15A:  PUSH    42
0A15C:  MOV     W0,[W15++]
0A15E:  BCLR.B  81.7
0A160:  MOV     42,W4
0A162:  IOR     #E0,W4
0A164:  MOV     W4,42
0A166:  BSET.B  81.7
0A168:  MOV     W1,760
0A16A:  MOV     #55,W4
0A16C:  MOV     W4,766
0A16E:  MOV     #AA,W4
0A170:  MOV     W4,766
0A172:  BSET.B  761.7
0A174:  NOP     
0A176:  NOP     
0A178:  BTSC.B  761.7
0A17A:  BRA     A178
0A17C:  MOV     [--W15],W0
0A17E:  BCLR.B  81.7
0A180:  POP     42
0A182:  BSET.B  81.7
0A184:  RETURN  
0A186:  MOV     W1,[W15++]
0A188:  MOV     #F000,W1
0A18A:  ADD     W1,W0,W0
0A18C:  CLR     W1
0A18E:  MOV     #7F,W1
0A190:  ADDC    W1,#0,W1
0A192:  MOV     W1,32
0A194:  MOV     [--W15],W1
0A196:  BCLR    W2.0
0A198:  CP0     W2
0A19A:  BRA     Z,A1BE
0A19C:  TBLWTL  [W1],[W0]
0A19E:  MOV     W1,[W15++]
0A1A0:  MOV     #4044,W1
0A1A2:  CALL    A15A
0A1A6:  MOV     [--W15],W1
0A1A8:  TBLWTL  [W1++],[W0]
0A1AA:  INC2    W0,W0
0A1AC:  BRA     NZ,A1B0
0A1AE:  INC     0032
0A1B0:  MOV     W1,[W15++]
0A1B2:  MOV     #4004,W1
0A1B4:  CALL    A15A
0A1B8:  MOV     [--W15],W1
0A1BA:  DEC2    W2,W2
0A1BC:  BRA     NZ,A19C
0A1BE:  RETURN  
....................  
.................... #list 
....................  
.................... #include "DSPIC30F_registers.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... #word WREG0 = 0x000 
.................... #word WREG1 = 0x002 
.................... #word WREG2 = 0x004 
.................... #word WREG3 = 0x006 
.................... #word WREG4 = 0x008 
.................... #word WREG5 = 0x00A 
.................... #word WREG6 = 0x00C 
.................... #word WREG7 = 0x00E 
.................... #word WREG8 = 0x010 
.................... #word WREG9 = 0x012 
.................... #word WREG10 = 0x014 
.................... #word WREG11 = 0x016 
.................... #word WREG12 = 0x018 
.................... #word WREG13 = 0x01A 
.................... #word WREG14 = 0x01C 
.................... #word WREG15 = 0x01E 
.................... #word SPLIM = 0x020 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x022 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x024 
.................... #word ACCAU = 0x026 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x028 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x02A 
.................... #word ACCBU = 0x02C 
.................... #word PC = 0x02E 
.................... #word PCH = 0x02E 
.................... #word PC = 0x02E 
.................... #word PCH = 0x030 
.................... #word TBLPAG = 0x032 
.................... #word PSVPAG = 0x034 
.................... #word RCOUNT = 0x036 
.................... #word DCOUNT = 0x038 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03A 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03C 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x03E 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x040 
.................... #word SR = 0x042 
.................... #word CORCON = 0x044 
.................... #word MODCON = 0x046 
.................... #word XMODSRT = 0x048 
.................... #word XMODEND = 0x04A 
.................... #word YMODSRT = 0x04C 
.................... #word YMODEND = 0x04E 
.................... #word XBREV = 0x050 
.................... #word DISICNT = 0x052 
.................... #word INTCON1 = 0x080 
.................... #word INTCON2 = 0x082 
.................... #word IFS0 = 0x084 
.................... #word IFS1 = 0x086 
.................... #word IFS2 = 0x088 
.................... #word IEC0 = 0x08C 
.................... #word IEC1 = 0x08E 
.................... #word IEC2 = 0x090 
.................... #word IPC0 = 0x094 
.................... #word IPC1 = 0x096 
.................... #word IPC2 = 0x098 
.................... #word IPC3 = 0x09A 
.................... #word IPC4 = 0x09C 
.................... #word IPC5 = 0x09E 
.................... #word IPC6 = 0x0A0 
.................... #word IPC7 = 0x0A2 
.................... #word IPC8 = 0x0A4 
.................... #word IPC9 = 0x0A6 
.................... #word IPC10 = 0x0A8 
.................... #word INTREG = 0x0B0 
.................... #word CNEN1 = 0x0C0 
.................... #word CNEN2 = 0x0C2 
.................... #word CNPU1 = 0x0C4 
.................... #word CNPU2 = 0x0C6 
.................... #word TMR1 = 0x100 
.................... #word PR1 = 0x102 
.................... #word T1CON = 0x104 
.................... #word TMR2 = 0x106 
.................... #word TMR3HLD = 0x108 
.................... #word TMR3 = 0x10A 
.................... #word PR2 = 0x10C 
.................... #word PR3 = 0x10E 
.................... #word T2CON = 0x110 
.................... #word T3CON = 0x112 
.................... #word TMR4 = 0x114 
.................... #word TMR5HLD = 0x116 
.................... #word TMR5 = 0x118 
.................... #word PR4 = 0x11A 
.................... #word PR5 = 0x11C 
.................... #word T4CON = 0x11E 
.................... #word T5CON = 0x120 
.................... #word IC1BUF = 0x140 
.................... #word IC1CON = 0x142 
.................... #word IC2BUF = 0x144 
.................... #word IC2CON = 0x146 
.................... #word IC3BUF = 0x148 
.................... #word IC3CON = 0x14A 
.................... #word IC4BUF = 0x14C 
.................... #word IC4CON = 0x14E 
.................... #word IC5BUF = 0x150 
.................... #word IC5CON = 0x152 
.................... #word IC6BUF = 0x154 
.................... #word IC6CON = 0x156 
.................... #word IC7BUF = 0x158 
.................... #word IC7CON = 0x15A 
.................... #word IC8BUF = 0x15C 
.................... #word IC8CON = 0x15E 
.................... #word OC1RS = 0x180 
.................... #word OC1R = 0x182 
.................... #word OC1CON = 0x184 
.................... #word OC2RS = 0x186 
.................... #word OC2R = 0x188 
.................... #word OC2CON = 0x18A 
.................... #word OC3RS = 0x18C 
.................... #word OC3R = 0x18E 
.................... #word OC3CON = 0x190 
.................... #word OC4RS = 0x192 
.................... #word OC4R = 0x194 
.................... #word OC4CON = 0x196 
.................... #word OC5RS = 0x198 
.................... #word OC5R = 0x19A 
.................... #word OC5CON = 0x19C 
.................... #word OC6RS = 0x19E 
.................... #word OC6R = 0x1A0 
.................... #word OC6CON = 0x1A2 
.................... #word OC7RS = 0x1A4 
.................... #word OC7R = 0x1A6 
.................... #word OC7CON = 0x1A8 
.................... #word OC8RS = 0x1AA 
.................... #word OC8R = 0x1AC 
.................... #word OC8CON = 0x1AE 
.................... #word I2CRCV = 0x200 
.................... #word I2CTRN = 0x202 
.................... #word I2CBRG = 0x204 
.................... #word I2CCON = 0x206 
.................... #word I2CSTAT = 0x208 
.................... #word I2CADD = 0x20A 
.................... #word U1MODE = 0x20C 
.................... #word U1STA = 0x20E 
.................... #word U1TXREG = 0x210 
.................... #word U1RXREG = 0x212 
.................... #word U1BRG = 0x214 
.................... #word U2MODE = 0x216 
.................... #word U2STA = 0x218 
.................... #word U2TXREG = 0x21A 
.................... #word U2RXREG = 0x21C 
.................... #word U2BRG = 0x21E 
.................... #word SPI1STAT = 0x220 
.................... #word SPI1CON = 0x222 
.................... #word SPI1BUF = 0x224 
.................... #word SPI2STAT = 0x226 
.................... #word SPI2CON = 0x228 
.................... #word SPI2BUF = 0x22A 
.................... #word DCICON1 = 0x240 
.................... #word DCICON2 = 0x242 
.................... #word DCICON3 = 0x244 
.................... #word DCISTAT = 0x246 
.................... #word TSCON = 0x248 
.................... #word RSCON = 0x24C 
.................... #word RXBUF0 = 0x250 
.................... #word RXBUF1 = 0x252 
.................... #word RXBUF2 = 0x254 
.................... #word RXBUF3 = 0x256 
.................... #word TXBUF0 = 0x258 
.................... #word TXBUF1 = 0x25A 
.................... #word TXBUF2 = 0x25C 
.................... #word TXBUF3 = 0x25E 
.................... #word ADCBUF0 = 0x280 
.................... #word ADCBUF1 = 0x282 
.................... #word ADCBUF2 = 0x284 
.................... #word ADCBUF3 = 0x286 
.................... #word ADCBUF4 = 0x288 
.................... #word ADCBUF5 = 0x28A 
.................... #word ADCBUF6 = 0x28C 
.................... #word ADCBUF7 = 0x28E 
.................... #word ADCBUF8 = 0x290 
.................... #word ADCBUF9 = 0x292 
.................... #word ADCBUFA = 0x294 
.................... #word ADCBUFB = 0x296 
.................... #word ADCBUFC = 0x298 
.................... #word ADCBUFD = 0x29A 
.................... #word ADCBUFE = 0x29C 
.................... #word ADCBUFF = 0x29E 
.................... #word ADCON1 = 0x2A0 
.................... #word ADCON2 = 0x2A2 
.................... #word ADCON3 = 0x2A4 
.................... #word ADCHS = 0x2A6 
.................... #word ADPCFG = 0x2A8 
.................... #word ADCSSL = 0x2AA 
.................... #word TRISA = 0x2C0 
.................... #word PORTA = 0x2C2 
.................... #word LATA = 0x2C4 
.................... #word TRISB = 0x2C6 
.................... #word PORTB = 0x2C8 
.................... #word LATB = 0x2CA 
.................... #word TRISC = 0x2CC 
.................... #word PORTC = 0x2CE 
.................... #word LATC = 0x2D0 
.................... #word TRISD = 0x2D2 
.................... #word PORTD = 0x2D4 
.................... #word LATD = 0x2D6 
.................... #word TRISF = 0x2DE 
.................... #word PORTF = 0x2E0 
.................... #word LATF = 0x2E2 
.................... #word TRISG = 0x2E4 
.................... #word PORTG = 0x2E6 
.................... #word LATG = 0x2E8 
.................... #word C1RXF0SID = 0x300 
.................... #word C1RXF0EIDH = 0x302 
.................... #word C1RXF0EIDL = 0x304 
.................... #word C1RXF1SID = 0x308 
.................... #word C1RXF1EIDH = 0x30A 
.................... #word C1RXF1EIDL = 0x30C 
.................... #word C1RXF2SID = 0x310 
.................... #word C1RXF2EIDH = 0x312 
.................... #word C1RXF2EIDL = 0x314 
.................... #word C1RXF3SID = 0x318 
.................... #word C1RXF3EIDH = 0x31A 
.................... #word C1RXF3EIDL = 0x31C 
.................... #word C1RXF4SID = 0x320 
.................... #word C1RXF4EIDH = 0x322 
.................... #word C1RXF4EIDL = 0x324 
.................... #word C1RXF5SID = 0x328 
.................... #word C1RXF5EIDH = 0x32A 
.................... #word C1RXF5EIDL = 0x32C 
.................... #word C1RXM0SID = 0x330 
.................... #word C1RXM0EIDH = 0x332 
.................... #word C1RXM0EIDL = 0x334 
.................... #word C1RXM1SID = 0x338 
.................... #word C1RXM1EIDH = 0x33A 
.................... #word C1RXM1EIDL = 0x33C 
.................... #word C1TX2SID = 0x340 
.................... #word C1TX2EID = 0x342 
.................... #word C1TX2DLC = 0x344 
.................... #word C1TX2B1 = 0x346 
.................... #word C1TX2B2 = 0x348 
.................... #word C1TX2B3 = 0x34A 
.................... #word C1TX2B4 = 0x34C 
.................... #word C1TX2CON = 0x34E 
.................... #word C1TX1SID = 0x350 
.................... #word C1TX1EID = 0x352 
.................... #word C1TX1DLC = 0x354 
.................... #word C1TX1B1 = 0x356 
.................... #word C1TX1B2 = 0x358 
.................... #word C1TX1B3 = 0x35A 
.................... #word C1TX1B4 = 0x35C 
.................... #word C1TX1CON = 0x35E 
.................... #word C1TX0SID = 0x360 
.................... #word C1TX0EID = 0x362 
.................... #word C1TX0DLC = 0x364 
.................... #word C1TX0B1 = 0x366 
.................... #word C1TX0B2 = 0x368 
.................... #word C1TX0B3 = 0x36A 
.................... #word C1TX0B4 = 0x36C 
.................... #word C1TX0CON = 0x36E 
.................... #word C1RX1SID = 0x370 
.................... #word C1RX1EID = 0x372 
.................... #word C1RX1DLC = 0x374 
.................... #word C1RX1B1 = 0x376 
.................... #word C1RX1B2 = 0x378 
.................... #word C1RX1B3 = 0x37A 
.................... #word C1RX1B4 = 0x37C 
.................... #word C1RX1CON = 0x37E 
.................... #word C1RX0SID = 0x380 
.................... #word C1RX0EID = 0x382 
.................... #word C1RX0DLC = 0x384 
.................... #word C1RX0B1 = 0x386 
.................... #word C1RX0B2 = 0x388 
.................... #word C1RX0B3 = 0x38A 
.................... #word C1RX0B4 = 0x38C 
.................... #word C1RX0CON = 0x38E 
.................... #word C1CTRL = 0x390 
.................... #word C1CFG1 = 0x392 
.................... #word C1CFG2 = 0x394 
.................... #word C1INTF = 0x396 
.................... #word C1INTE = 0x398 
.................... #word C1EC = 0x39A 
.................... #word C2RXF0SID = 0x3C0 
.................... #word C2RXF0EIDH = 0x3C2 
.................... #word C2RXF0EIDL = 0x3C4 
.................... #word C2RXF1SID = 0x3C8 
.................... #word C2RXF1EIDH = 0x3CA 
.................... #word C2RXF1EIDL = 0x3CC 
.................... #word C2RXF2SID = 0x3D0 
.................... #word C2RXF2EIDH = 0x3D2 
.................... #word C2RXF2EIDL = 0x3D4 
.................... #word C2RXF3SID = 0x3D8 
.................... #word C2RXF3EIDH = 0x3DA 
.................... #word C2RXF3EIDL = 0x3DC 
.................... #word C2RXF4SID = 0x3E0 
.................... #word C2RXF4EIDH = 0x3E2 
.................... #word C2RXF4EIDL = 0x3E4 
.................... #word C2RXF5SID = 0x3E8 
.................... #word C2RXF5EIDH = 0x3EA 
.................... #word C2RXF5EIDL = 0x3EC 
.................... #word C2RXM0SID = 0x3F0 
.................... #word C2RXM0EIDH = 0x3F2 
.................... #word C2RXM0EIDL = 0x3F4 
.................... #word C2RXM1SID = 0x3F8 
.................... #word C2RXM1EIDH = 0x3FA 
.................... #word C2RXM1EIDL = 0x3FC 
.................... #word C2TX2SID = 0x400 
.................... #word C2TX2EID = 0x402 
.................... #word C2TX2DLC = 0x404 
.................... #word C2TX2B1 = 0x406 
.................... #word C2TX2B2 = 0x408 
.................... #word C2TX2B3 = 0x40A 
.................... #word C2TX2B4 = 0x40C 
.................... #word C2TX2CON = 0x40E 
.................... #word C2TX1SID = 0x410 
.................... #word C2TX1EID = 0x412 
.................... #word C2TX1DLC = 0x414 
.................... #word C2TX1B1 = 0x416 
.................... #word C2TX1B2 = 0x418 
.................... #word C2TX1B3 = 0x41A 
.................... #word C2TX1B4 = 0x41C 
.................... #word C2TX1CON = 0x41E 
.................... #word C2TX0SID = 0x420 
.................... #word C2TX0EID = 0x422 
.................... #word C2TX0DLC = 0x424 
.................... #word C2TX0B1 = 0x426 
.................... #word C2TX0B2 = 0x428 
.................... #word C2TX0B3 = 0x42A 
.................... #word C2TX0B4 = 0x42C 
.................... #word C2TX0CON = 0x42E 
.................... #word C2RX1SID = 0x430 
.................... #word C2RX1EID = 0x432 
.................... #word C2RX1DLC = 0x434 
.................... #word C2RX1B1 = 0x436 
.................... #word C2RX1B2 = 0x438 
.................... #word C2RX1B3 = 0x43A 
.................... #word C2RX1B4 = 0x43C 
.................... #word C2RX1CON = 0x43E 
.................... #word C2RX0SID = 0x440 
.................... #word C2RX0EID = 0x442 
.................... #word C2RX0DLC = 0x444 
.................... #word C2RX0B1 = 0x446 
.................... #word C2RX0B2 = 0x448 
.................... #word C2RX0B3 = 0x44A 
.................... #word C2RX0B4 = 0x44C 
.................... #word C2RX0CON = 0x44E 
.................... #word C2CTRL = 0x450 
.................... #word C2CFG1 = 0x452 
.................... #word C2CFG2 = 0x454 
.................... #word C2INTF = 0x456 
.................... #word C2INTE = 0x458 
.................... #word C2EC = 0x45A 
.................... #word RCON = 0x740 
.................... #word OSCCON = 0x742 
.................... #word OSCTUN = 0x744 
.................... #word NVMCON = 0x760 
.................... #word NVMADR = 0x762 
.................... #word NVMADRU = 0x764 
.................... #word NVMKEY = 0x766 
.................... #word PMD1 = 0x770 
.................... #word PMD2 = 0x772 
....................  
....................  
.................... // Fuses 
.................... #fuses NOWDT, HS2_PLL8, NOPUT, NOPROTECT, DEBUG, NOBROWNOUT, NOWRTÃÂ  
.................... #device ICD=TRUE 
.................... // DÃÂ©finit la vitesse du quartz (prendre en compte si PLL employÃÂ©e) 
.................... #use delay(clock=80000000) 
*
00F0E:  CP0     W0
00F10:  BTSC.B  42.1
00F12:  BRA     F20
00F14:  REPEAT  #E1B
00F16:  NOP     
00F18:  REPEAT  #3FFE
00F1A:  NOP     
00F1C:  DEC     W0,W0
00F1E:  BRA     NZ,F14
00F20:  RETURN  
.................... // Config IIC 
.................... #use i2c(master,force_hw,slow,I2C1) 
*
00E62:  MOV     #FFFF,W0
00E64:  BTSS.B  208.3
00E66:  BRA     E72
00E68:  BTSC.B  209.6
00E6A:  BRA     E68
00E6C:  MOV     W1,202
00E6E:  BTSC.B  209.6
00E70:  BRA     E6E
00E72:  MOV     #0,W0
00E74:  BTSC.B  209.7
00E76:  INC     W0,W0
00E78:  RETURN  
*
01308:  MOV     #FFFF,W0
0130A:  BTSS.B  208.3
0130C:  BRA     1330
0130E:  MOV     206,W2
01310:  AND     W2,#1F,W2
01312:  BRA     NZ,130E
01314:  BSET.B  206.3
01316:  BTSC    W1.0
01318:  BCLR.B  206.5
0131A:  BTSS    W1.0
0131C:  BSET.B  206.5
0131E:  MOV     206,W2
01320:  AND     W2,#1F,W2
01322:  BRA     NZ,131E
01324:  BSET.B  206.4
01326:  BTSS.B  208.1
01328:  BRA     1326
0132A:  MOV     200,W0
0132C:  BTSC.B  208.6
0132E:  BCLR.B  208.6
01330:  RETURN  
.................... #build(stack=2048) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,STREAM=ROBOTEQ) // Pour pouvoir utiliser le RS232/2 
....................  
....................  
.................... // Variables utiles (globales) 
.................... int1 flagGameEnd=0,flagTimeOut=0;	// DÃÂ©finit si le temps est dÃÂ©passÃÂ© 
.................... int1 flagBaliseCheck=0;				// DÃÂ©finit si adversaire dÃÂ©tectÃÂ© 
.................... int1 flagError=0; 					// Si une erreur doit ÃÂªtre affichÃÂ©e 
.................... //int1 HasBegun = 0;				// Permet de savoir si le jeu ÃÂ  dÃÂ©marrer 
.................... int1 ToDisplay=0; 
.................... int1 IsPassedTimeOut=0; 
.................... int1 flag_depl_ok = 0; 
.................... int1 flag_end = 0; 
.................... int1 _Detected = 0;  
.................... int1 balise_on = 0; 
.................... int1 flag_error = 0;  
.................... int1 Team=0; 
.................... signed int32 ActualPosition = 0; 
.................... unsigned int8 value_balise=0;	// Valeur de la balise en dÃÂ©tection 
.................... unsigned int32 RealTimeMS=0,BeginTimeMS=0,GameTimeMS=0; 
.................... unsigned int8 GameTimeS=0;	// Temps de jeu 
.................... unsigned int8 Time_detected = 0; 
.................... unsigned int8 TIME_tempo_dectected = 6; 
.................... unsigned int8 No_erreur = 0;  
.................... unsigned int8 Value_bal = 0;  
.................... unsigned int8 Tempo_bal = 0 ;  
....................  
....................  
.................... unsigned int8 NoObj = 1; 
.................... unsigned int8 NoPts = 1; 
.................... unsigned int32 last_obj = 0; 
....................  
.................... int1 Check = 1; 
.................... unsigned int8 points = 0; 
.................... unsigned int8 solution = 0; 
....................  
....................  
.................... // DÃÂ©finit les constantes ASCII, comme il n'a pas l'air de les prendre ... 
.................... enum{NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL,BS,TAB,LF,VT,FF,CR,SO,SI,DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB,CAN,EM,SUB,ESC,FS,GS,RS,US,SPACE}; 
.................... enum{Init, Choose_objectif, Check_ZI, Send_depl_action, Send_depl_action_ZI, Depl_action_process, Depl_action_process_ZI,Switch_end_obj,Wait_end} Etat_rob = Init; 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	#define BalSensitivity 4 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Inclusion des fichiers sources 
.................... #include "driver_moteur.c" 
.................... //========================================================================================== 
.................... //																							 
.................... //						EMVs - Fonctions pour DRIVER MOTEUR MAXON 											 
.................... //						--------------------------												 
.................... //																							 
.................... //========================================================================================= 
.................... //	Développé par:		: Carrupt Aurélien    												 
.................... //						: Duay Daniel    												 
.................... //  Date				: 15.03.2013															 
.................... //  Date de modif.		: 14.02.2017															 
.................... //  Nom de la lib	 	: driver_moteur.c													 
.................... //  Version 			: V2.1																 
.................... //========================================================================================= 
.................... // Description :																			 
.................... //=============																			 
.................... //	Ce code contient les fonctions qui permettent au master de communiquer avec le driver  	 
.................... //	de moteur V3.0																			 
.................... //   
.................... //======================================================================================== 
.................... //DIRECTIVES DE PRECOMPILATIONS 
.................... //======================================================================================== 
....................  
.................... #DEFINE DRV_MODE_COURANT 0		// !!!!!!  NON IMPLEMENTE !!!!!   régulation en mode courant  
.................... #DEFINE DRV_MODE_VITESSE 1		// régulation en mode vitesse  
.................... #DEFINE DRV_MODE_NON_REGUL 2	// mode régulation désactivée  
.................... #DEFINE DRV_STOP 0				// Arrêt du moteur et arrêt d'urgence 
.................... #DEFINE DRV_RESET 1				// Reset du driver 
....................  
.................... #DEFINE DRV_ARRET_COURANT 0					// Arret en courant  
.................... #DEFINE DRV_ARRET_POSITION_ABSOLUE 1		// Arret en position absoulue 
.................... #DEFINE DRV_ARRET_POSITION_RELATIVE 2		// Arret en position relative 
.................... #DEFINE DRV_ARRET_TEMPS 3					// Arret en position temps  
.................... 			 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: go_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer un ordre de déplacement au moteur		 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					direction :			sens de rotation du moteur (int8) -> 0 ou 1																			 
.................... //					mode_regulation : 	!!!!!!  NON IMPLEMENTE !!!!!  DRV_MODE_COURANT (int8) -> régulation en courant ->paramètre_1 = valeur du courant qu'on souhaite maintenir [mA] (int16) 
.................... //										DRV_MODE_VITESSE (int8) -> régulation en vitesse  ->paramètre_1 = valeur de vitesse qu'on souhaite maintenir [impulse/s] (int16) 
.................... //										DRV_MODE_NON_REGUL (int8) -> régulation désactivée ->paramètre_1 = valeur de la PWM 0-100 en %  (int16) 
.................... //					mode_d'arret 	: 	DRV_ARRET_POSITION_ABSOLUE (int8)	-> 	parametre_2 = position a atteindre [impulse] (int32)																			   
.................... //										DRV_ARRET_POSITION_RELATIVE (int8)	->	parametre_2 = nombre d'impulsion d'encodeur a effectuer [impulse] (int32) 
.................... //										DRV_ARRET_TEMPS (int8)				->	parametre_2 = temps du parcours [ms] (int32) 
.................... //										DRV_ARRET_COURANT (int8)			->	parametre_2 = valeur du courant d'arrêt souhaité [mA] (int32)								 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 go_driver_moteur(int8 adresse_driver, int8 direction, int8 mode_regulation, int16 parametre_1, int8 mode_arret, signed int32 parametre_2) 
*
0114E:  MOV     W5,[W15++]
01150:  MOV     W6,[W15++]
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
.................... 	int8 config; 
.................... 	 
.................... 	 
.................... 	config = ((mode_regulation & 0b00000111)<<5) + ((direction & 0b00000001)<<4) + (mode_arret & 0b00000111); 
01152:  MOV.B   1B3E,W0L
01154:  SE      W0,W0
01156:  AND     W0,#7,W5
01158:  SL      W5,#5,W5
0115A:  MOV.B   1B3D,W0L
0115C:  SE      W0,W0
0115E:  AND     W0,#1,W6
01160:  SL      W6,#4,W0
01162:  ADD     W0,W5,W5
01164:  MOV.B   1B3F,W0L
01166:  SE      W0,W0
01168:  AND     W0,#7,W0
0116A:  ADD     W0,W5,W0
0116C:  MOV.B   W0L,1B4C
.................... 	val1 = make8(parametre_1, 0); 
0116E:  MOV.B   1B40,W0L
01170:  MOV.B   W0L,1B46
.................... 	val2 = make8(parametre_1, 1); 
01172:  MOV.B   1B41,W0L
01174:  MOV.B   W0L,1B47
.................... 	val3 = make8(parametre_2, 0); 
01176:  MOV.B   1B42,W0L
01178:  MOV.B   W0L,1B48
.................... 	val4 = make8(parametre_2, 1); 
0117A:  MOV.B   1B43,W0L
0117C:  MOV.B   W0L,1B49
.................... 	val5 = make8(parametre_2, 2); 
0117E:  MOV.B   1B44,W0L
01180:  MOV.B   W0L,1B4A
.................... 	val6 = make8(parametre_2, 3); 
01182:  MOV.B   1B45,W0L
01184:  MOV.B   W0L,1B4B
.................... 	 
.................... 	i2c_start(); 
01186:  BTSS.B  208.3
01188:  BRA     1192
0118A:  BSET.B  206.1
0118C:  BTSC.B  206.1
0118E:  BRA     118C
01190:  BRA     1198
01192:  BSET.B  206.0
01194:  BTSC.B  206.0
01196:  BRA     1194
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
01198:  MOV.B   1B3C,W0L
0119A:  MOV.B   W0L,2
0119C:  CALL    E62
011A0:  CP0.B   W0L
011A2:  BRA     NZ,11E6
.................... 	{ 
.................... 		i2c_write(0x48);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
011A4:  MOV.B   #48,W1L
011A6:  CALL    E62
.................... 		i2c_write(config);					//configuration 
011AA:  MOV.B   1B4C,W0L
011AC:  MOV.B   W0L,2
011AE:  CALL    E62
.................... 		i2c_write(val1);					// parametre_1 
011B2:  MOV.B   1B46,W0L
011B4:  MOV.B   W0L,2
011B6:  CALL    E62
.................... 		i2c_write(val2); 
011BA:  MOV.B   1B47,W0L
011BC:  MOV.B   W0L,W1L
011BE:  CALL    E62
.................... 		i2c_write(val3);					// parametre_2 
011C2:  MOV.B   1B48,W0L
011C4:  MOV.B   W0L,2
011C6:  CALL    E62
.................... 		i2c_write(val4); 
011CA:  MOV.B   1B49,W0L
011CC:  MOV.B   W0L,W1L
011CE:  CALL    E62
.................... 		i2c_write(val5);					 
011D2:  MOV.B   1B4A,W0L
011D4:  MOV.B   W0L,2
011D6:  CALL    E62
.................... 		i2c_write(val6); 
011DA:  MOV.B   1B4B,W0L
011DC:  MOV.B   W0L,W1L
011DE:  CALL    E62
.................... 	} 
011E2:  GOTO    11F8
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
011E6:  MOV     #1F,W0
011E8:  AND     206,W0
011EA:  BRA     NZ,11E6
011EC:  BSET.B  206.2
011EE:  BTSC.B  206.2
011F0:  BRA     11EE
.................... 		return 2; 
011F2:  MOV.B   #2,W0L
011F4:  MOV.B   W0L,0
011F6:  BRA     1208
.................... 	} 
.................... 	i2c_stop();	 
011F8:  MOV     #1F,W0
011FA:  AND     206,W0
011FC:  BRA     NZ,11F8
011FE:  BSET.B  206.2
01200:  BTSC.B  206.2
01202:  BRA     1200
.................... 	return 1; 
01204:  MOV.B   #1,W0L
01206:  MOV.B   W0L,0
01208:  MOV     [--W15],W6
0120A:  MOV     [--W15],W5
0120C:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur_pid																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les valeurs du PID du régulateur driver moteur	 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					reg_P 			= Valeur P du régulateur (int16)  valeur en millième  ex: 1250 = 1.25 
.................... //					reg_I 			= Valeur I du régulateur (int16)			idem 
.................... //					reg_D 			= Valeur D du régulateur (int16)			idem 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur_pid(int8 adresse_driver, int16 reg_P, int16 reg_I, int16 reg_D) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
....................  
.................... 	val1 = make8(reg_P, 0); 
*
00E7A:  MOV.B   1B34,W0L
00E7C:  MOV.B   W0L,1B33
.................... 	val2 = make8(reg_P, 1); 
00E7E:  MOV.B   1B35,W0L
00E80:  MOV.B   W0L,1B3A
.................... 	val3 = make8(reg_I, 0); 
00E82:  MOV.B   1B36,W0L
00E84:  MOV.B   W0L,1B3B
.................... 	val4 = make8(reg_I, 1); 
00E86:  MOV.B   1B37,W0L
00E88:  MOV.B   W0L,1B3C
.................... 	val5 = make8(reg_D, 0); 
00E8A:  MOV.B   1B38,W0L
00E8C:  MOV.B   W0L,1B3D
.................... 	val6 = make8(reg_D, 1); 
00E8E:  MOV.B   1B39,W0L
00E90:  MOV.B   W0L,1B3E
....................  
.................... 	i2c_start(); 
00E92:  BTSS.B  208.3
00E94:  BRA     E9E
00E96:  BSET.B  206.1
00E98:  BTSC.B  206.1
00E9A:  BRA     E98
00E9C:  BRA     EA4
00E9E:  BSET.B  206.0
00EA0:  BTSC.B  206.0
00EA2:  BRA     EA0
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00EA4:  MOV.B   1B32,W0L
00EA6:  MOV.B   W0L,2
00EA8:  CALL    E62
00EAC:  CP0.B   W0L
00EAE:  BRA     NZ,EEA
.................... 	{ 
.................... 		i2c_write(0x37);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00EB0:  MOV.B   #37,W1L
00EB2:  CALL    E62
.................... 		i2c_write(val1);					// parametre P 
00EB6:  MOV.B   1B33,W0L
00EB8:  MOV.B   W0L,W1L
00EBA:  CALL    E62
.................... 		i2c_write(val2); 
00EBE:  MOV.B   1B3A,W0L
00EC0:  MOV.B   W0L,2
00EC2:  CALL    E62
.................... 		i2c_write(val3);					// parametre I 
00EC6:  MOV.B   1B3B,W0L
00EC8:  MOV.B   W0L,W1L
00ECA:  CALL    E62
.................... 		i2c_write(val4); 
00ECE:  MOV.B   1B3C,W0L
00ED0:  MOV.B   W0L,2
00ED2:  CALL    E62
.................... 		i2c_write(val5);					// parametre D					 
00ED6:  MOV.B   1B3D,W0L
00ED8:  MOV.B   W0L,W1L
00EDA:  CALL    E62
.................... 		i2c_write(val6); 
00EDE:  MOV.B   1B3E,W0L
00EE0:  MOV.B   W0L,2
00EE2:  CALL    E62
.................... 	} 
00EE6:  GOTO    EFC
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00EEA:  MOV     #1F,W0
00EEC:  AND     206,W0
00EEE:  BRA     NZ,EEA
00EF0:  BSET.B  206.2
00EF2:  BTSC.B  206.2
00EF4:  BRA     EF2
.................... 		return 2; 
00EF6:  MOV.B   #2,W0L
00EF8:  MOV.B   W0L,0
00EFA:  BRA     F0C
.................... 	} 
.................... 	i2c_stop();	 
00EFC:  MOV     #1F,W0
00EFE:  AND     206,W0
00F00:  BRA     NZ,EFC
00F02:  BSET.B  206.2
00F04:  BTSC.B  206.2
00F06:  BRA     F04
.................... 	return 1; 
00F08:  MOV.B   #1,W0L
00F0A:  MOV.B   W0L,0
00F0C:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 18.03.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les rampes d'accélération et de décélération ainsi que le courant max du moteur 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					acceleration 	= valeur d'accélération en imp./sec (int16) 
.................... //					deceleration 	= valeur de décélération en imp./sec (int16)  
.................... //					courant_max 	= Valeur du courant max en mA (int16) 
.................... //					impuls_tour		= Impulsion par tour de moteur après le réducteur -> encodeur * réducteur 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur(int8 adresse_driver, int16 acceleration, int16 deceleration, int16 courant_max, int16 impuls_tour) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6, val7, val8; 
....................  
.................... 	val1 = make8(acceleration, 0); 
*
00F22:  MOV.B   1B34,W0L
00F24:  MOV.B   W0L,1B33
.................... 	val2 = make8(acceleration, 1); 
00F26:  MOV.B   1B35,W0L
00F28:  MOV.B   W0L,1B3C
.................... 	val3 = make8(deceleration, 0); 
00F2A:  MOV.B   1B36,W0L
00F2C:  MOV.B   W0L,1B3D
.................... 	val4 = make8(deceleration, 1); 
00F2E:  MOV.B   1B37,W0L
00F30:  MOV.B   W0L,1B3E
.................... 	val5 = make8(courant_max, 0); 
00F32:  MOV.B   1B38,W0L
00F34:  MOV.B   W0L,1B3F
.................... 	val6 = make8(courant_max, 1); 
00F36:  MOV.B   1B39,W0L
00F38:  MOV.B   W0L,1B40
.................... 	val7 = make8(impuls_tour, 0); 
00F3A:  MOV.B   1B3A,W0L
00F3C:  MOV.B   W0L,1B41
.................... 	val8 = make8(impuls_tour, 1); 
00F3E:  MOV.B   1B3B,W0L
00F40:  MOV.B   W0L,1B42
....................  
.................... 	i2c_start(); 
00F42:  BTSS.B  208.3
00F44:  BRA     F4E
00F46:  BSET.B  206.1
00F48:  BTSC.B  206.1
00F4A:  BRA     F48
00F4C:  BRA     F54
00F4E:  BSET.B  206.0
00F50:  BTSC.B  206.0
00F52:  BRA     F50
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00F54:  MOV.B   1B32,W0L
00F56:  MOV.B   W0L,2
00F58:  CALL    E62
00F5C:  CP0.B   W0L
00F5E:  BRA     NZ,FAA
.................... 	{ 
.................... 		i2c_write(0x29);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00F60:  MOV.B   #29,W1L
00F62:  CALL    E62
.................... 		i2c_write(val1);					// accélération 
00F66:  MOV.B   1B33,W0L
00F68:  MOV.B   W0L,W1L
00F6A:  CALL    E62
.................... 		i2c_write(val2); 
00F6E:  MOV.B   1B3C,W0L
00F70:  MOV.B   W0L,2
00F72:  CALL    E62
.................... 		i2c_write(val3);					// décélération 
00F76:  MOV.B   1B3D,W0L
00F78:  MOV.B   W0L,W1L
00F7A:  CALL    E62
.................... 		i2c_write(val4); 
00F7E:  MOV.B   1B3E,W0L
00F80:  MOV.B   W0L,2
00F82:  CALL    E62
.................... 		i2c_write(val5);					// courant max					 
00F86:  MOV.B   1B3F,W0L
00F88:  MOV.B   W0L,W1L
00F8A:  CALL    E62
.................... 		i2c_write(val6); 
00F8E:  MOV.B   1B40,W0L
00F90:  MOV.B   W0L,2
00F92:  CALL    E62
.................... 		i2c_write(val7);					// impulsion par tour					 
00F96:  MOV.B   1B41,W0L
00F98:  MOV.B   W0L,W1L
00F9A:  CALL    E62
.................... 		i2c_write(val8); 
00F9E:  MOV.B   1B42,W0L
00FA0:  MOV.B   W0L,2
00FA2:  CALL    E62
.................... 	} 
00FA6:  GOTO    FBC
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00FAA:  MOV     #1F,W0
00FAC:  AND     206,W0
00FAE:  BRA     NZ,FAA
00FB0:  BSET.B  206.2
00FB2:  BTSC.B  206.2
00FB4:  BRA     FB2
.................... 		return 2; 
00FB6:  MOV.B   #2,W0L
00FB8:  MOV.B   W0L,0
00FBA:  BRA     FCC
.................... 	} 
.................... 	i2c_stop();	 
00FBC:  MOV     #1F,W0
00FBE:  AND     206,W0
00FC0:  BRA     NZ,FBC
00FC2:  BSET.B  206.2
00FC4:  BTSC.B  206.2
00FC6:  BRA     FC4
.................... 	return 1; 
00FC8:  MOV.B   #1,W0L
00FCA:  MOV.B   W0L,0
00FCC:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer des ordres courts direct comme d'arrêter le moteur même s'il n'a pas fini l'ordre précédent ou reset le driver 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver	(int8) 
.................... //					ordre		 	= ordre à effectuer (stop = 0, reset = 1) (int8) 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 driver_moteur(int8 adresse_driver, int8 ordre) 
*
0120E:  MOV     W5,[W15++]
.................... { 
.................... 	i2c_start(); 
01210:  BTSS.B  208.3
01212:  BRA     121C
01214:  BSET.B  206.1
01216:  BTSC.B  206.1
01218:  BRA     1216
0121A:  BRA     1222
0121C:  BSET.B  206.0
0121E:  BTSC.B  206.0
01220:  BRA     121E
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
01222:  MOV.B   1B3A,W0L
01224:  MOV.B   W0L,2
01226:  CALL    E62
0122A:  CP0.B   W0L
0122C:  BRA     NZ,1242
.................... 	{ 
.................... 		i2c_write(((ordre << 4) & 0b00010000) + 0x01);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
0122E:  MOV     1B3A,W5
01230:  LSR     W5,#8,W5
01232:  SL      W5,#4,W5
01234:  AND     W5,#10,W5
01236:  ADD     W5,#1,W5
01238:  MOV.B   W5L,W1L
0123A:  CALL    E62
.................... 	} 
0123E:  GOTO    1254
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
01242:  MOV     #1F,W0
01244:  AND     206,W0
01246:  BRA     NZ,1242
01248:  BSET.B  206.2
0124A:  BTSC.B  206.2
0124C:  BRA     124A
.................... 		return 2; 
0124E:  MOV.B   #2,W0L
01250:  MOV.B   W0L,0
01252:  BRA     1264
.................... 	} 
.................... 	i2c_stop();	 
01254:  MOV     #1F,W0
01256:  AND     206,W0
01258:  BRA     NZ,1254
0125A:  BSET.B  206.2
0125C:  BTSC.B  206.2
0125E:  BRA     125C
.................... 	return 1; 
01260:  MOV.B   #1,W0L
01262:  MOV.B   W0L,0
01264:  MOV     [--W15],W5
01266:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_driver_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  Permet de lire l'état du driver								      	 
.................... == paramètre 	:  Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  retourne le status du driver											 
.................... ==				   0-> Arret  (le driver a fini tout traitement et attend le prochain ordre)	 
.................... ==				   1-> Marche (le driver est entrain d'exécuter l'ordre)													 
.................... ==				   2-> Surcharge (le driver a dépassé la limite de courant max. défini par l'utilisateur)															 
.................... ==				   3-> Erreur PONT-H (Température IC trop élevée, courant trop élevé) 
.................... ==				   4-> BUSY (le slave est entrain de traiter la prochaine commande) 
.................... ==				   5-> not ready  (le slave ne répond pas)															 
.................... /*===================================================================================================================================================================================================*/ 
.................... unsigned int8 read_driver_moteur(int8 adresse_driver) 
*
01332:  MOV     W5,[W15++]
01334:  CLR.B   1B45
01336:  CLR.B   1B46
.................... { 
.................... 	int8 driver_etat=0; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
01338:  BTSS.B  208.3
0133A:  BRA     1344
0133C:  BSET.B  206.1
0133E:  BTSC.B  206.1
01340:  BRA     133E
01342:  BRA     134A
01344:  BSET.B  206.0
01346:  BTSC.B  206.0
01348:  BRA     1346
.................... 	ack = i2c_write(adresse_driver+1); 
0134A:  MOV.B   1B44,W0L
0134C:  SE      W0,W0
0134E:  ADD     W0,#1,W5
01350:  MOV.B   W5L,W1L
01352:  CALL    E62
01356:  MOV.B   W0L,1B46
.................... 	if(ack == 0) 
01358:  MOV.B   1B46,W0L
0135A:  SE      W0,W0
0135C:  CP0     W0
0135E:  BRA     NZ,136C
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
01360:  CLR.B   W1
01362:  CALL    1308
01366:  MOV.B   W0L,1B45
.................... 	} 
01368:  GOTO    1370
.................... 	else driver_etat = 5; 
0136C:  MOV.B   #5,W0L
0136E:  MOV.B   W0L,1B45
....................  
.................... 	i2c_stop(); 
01370:  MOV     #1F,W0
01372:  AND     206,W0
01374:  BRA     NZ,1370
01376:  BSET.B  206.2
01378:  BTSC.B  206.2
0137A:  BRA     1378
.................... 	return driver_etat; 
0137C:  MOV.B   1B45,W0L
0137E:  MOV     [--W15],W5
01380:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_pos_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  	Permet de lire la valeur du capteur incrémental du moteur 
.................... ==					Attention n'utiliser cette fonction seulement quand le moteur est à l'arrêt, sinon il y a un risque de faire planter la communication I2C						      	 
.................... == paramètre 	:  	Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  	signed 32bits -> la valeur actuel du capteur incrémental du moteur 
.................... ==					2147483647 -> interdiction de lire la position pendant un mouvement 
.................... ==					2147483648 -> not ready  (le slave ne répond pas)  
.................... ==				    
.................... /*===================================================================================================================================================================================================*/ 
.................... signed int32 read_pos_moteur(int8 adresse_driver) 
*
013D6:  MOV     W5,[W15++]
013D8:  CLR.B   1B3B
.................... { 
.................... 	int8 ack=0; 
.................... 	unsigned int8 buffer[4]; 
.................... 	signed int32 pos_value; 
....................  
.................... 	if (read_driver_moteur(adresse_driver) != 1) 
013DA:  MOV.B   1B3A,W0L
013DC:  MOV.B   W0L,1B44
013DE:  CALL    1332
013E2:  CP.B    W0L,#1
013E4:  BRA     Z,145E
.................... 		{ 
.................... 			i2c_start(); 
013E6:  BTSS.B  208.3
013E8:  BRA     13F2
013EA:  BSET.B  206.1
013EC:  BTSC.B  206.1
013EE:  BRA     13EC
013F0:  BRA     13F8
013F2:  BSET.B  206.0
013F4:  BTSC.B  206.0
013F6:  BRA     13F4
.................... 			ack = i2c_write(adresse_driver+1); 
013F8:  MOV.B   1B3A,W0L
013FA:  SE      W0,W0
013FC:  ADD     W0,#1,W5
013FE:  MOV.B   W5L,W1L
01400:  CALL    E62
01404:  MOV.B   W0L,1B3B
.................... 			if(ack == 0) 
01406:  MOV.B   1B3B,W0L
01408:  SE      W0,W0
0140A:  CP0     W0
0140C:  BRA     NZ,1448
.................... 			{ 
.................... 				i2c_read(1); 
0140E:  MOV.B   #1,W1L
01410:  CALL    1308
.................... 				buffer[0]=i2c_read(1); 
01414:  MOV.B   #1,W1L
01416:  CALL    1308
0141A:  MOV.B   W0L,1B3C
.................... 				buffer[1]=i2c_read(1); 
0141C:  MOV.B   #1,W1L
0141E:  CALL    1308
01422:  MOV.B   W0L,1B3D
.................... 				buffer[2]=i2c_read(1); 
01424:  MOV.B   #1,W1L
01426:  CALL    1308
0142A:  MOV.B   W0L,1B3E
.................... 				buffer[3]=i2c_read(0); 
0142C:  CLR.B   W1
0142E:  CALL    1308
01432:  MOV.B   W0L,1B3F
.................... 				pos_value = make32(buffer[3],buffer[2],buffer[1],buffer[0]); 
01434:  MOV.B   1B3F,W0L
01436:  MOV.B   W0L,1B43
01438:  MOV.B   1B3E,W0L
0143A:  MOV.B   W0L,1B42
0143C:  MOV.B   1B3D,W0L
0143E:  MOV.B   W0L,1B41
01440:  MOV.B   1B3C,W0L
01442:  MOV.B   W0L,1B40
.................... 			} 
01444:  GOTO    144E
.................... 			else pos_value = 2147483648; 
01448:  CLR     1B40
0144A:  MOV     #8000,W4
0144C:  MOV     W4,1B42
.................... 		 
.................... 			i2c_stop(); 
0144E:  MOV     #1F,W0
01450:  AND     206,W0
01452:  BRA     NZ,144E
01454:  BSET.B  206.2
01456:  BTSC.B  206.2
01458:  BRA     1456
.................... 		} 
0145A:  GOTO    1464
.................... 	else pos_value = 2147483647; 
0145E:  SETM    1B40
01460:  MOV     #7FFF,W4
01462:  MOV     W4,1B42
....................  
.................... 	return pos_value; 
01464:  MOV     1B40,W0
01466:  MOV     1B42,W1
01468:  MOV     [--W15],W5
0146A:  RETURN  
.................... }	 
.................... 	 
.................... //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... #include "Com_balises.c" 
.................... #ifndef Com_balises 
.................... #define Com_balises 
.................... 	 
.................... void Balise_config_plage(int8 no_plage, int8 deb_plage, int8 fin_plage) 
.................... {	 
.................... 	i2c_start(); 
*
01082:  BTSS.B  208.3
01084:  BRA     108E
01086:  BSET.B  206.1
01088:  BTSC.B  206.1
0108A:  BRA     1088
0108C:  BRA     1094
0108E:  BSET.B  206.0
01090:  BTSC.B  206.0
01092:  BRA     1090
.................... 	i2c_write(0x20);			// adresse de la balise 
01094:  MOV.B   #20,W1L
01096:  CALL    E62
.................... 	i2c_write(0x10);			// instruction de config 
0109A:  MOV.B   #10,W1L
0109C:  CALL    E62
.................... 	i2c_write(no_plage); 
010A0:  MOV.B   1B32,W0L
010A2:  MOV.B   W0L,2
010A4:  CALL    E62
.................... 	i2c_write(deb_plage); 
010A8:  MOV.B   1B33,W0L
010AA:  MOV.B   W0L,W1L
010AC:  CALL    E62
.................... 	i2c_write(fin_plage); 
010B0:  MOV.B   1B34,W0L
010B2:  MOV.B   W0L,2
010B4:  CALL    E62
.................... 	i2c_write('@');				// fin de la communication 
010B8:  MOV.B   #40,W1L
010BA:  CALL    E62
.................... 	i2c_stop(); 
010BE:  MOV     #1F,W0
010C0:  AND     206,W0
010C2:  BRA     NZ,10BE
010C4:  BSET.B  206.2
010C6:  BTSC.B  206.2
010C8:  BRA     10C6
010CA:  RETURN  
.................... } 
....................  
.................... void Balise_set_plage(int8 select_plage) 
.................... { 
.................... 	i2c_start(); 
*
07AB6:  BTSS.B  208.3
07AB8:  BRA     7AC2
07ABA:  BSET.B  206.1
07ABC:  BTSC.B  206.1
07ABE:  BRA     7ABC
07AC0:  BRA     7AC8
07AC2:  BSET.B  206.0
07AC4:  BTSC.B  206.0
07AC6:  BRA     7AC4
.................... 	i2c_write(0x20);			// adresse de la balise 
07AC8:  MOV.B   #20,W1L
07ACA:  CALL    E62
.................... 	i2c_write(0x80);			// instruction de set 
07ACE:  MOV.B   #80,W1L
07AD0:  CALL    E62
.................... 	i2c_write(select_plage); 
07AD4:  MOV.B   1B74,W0L
07AD6:  MOV.B   W0L,2
07AD8:  CALL    E62
.................... 	i2c_write('@');				// fin de la communication 
07ADC:  MOV.B   #40,W1L
07ADE:  CALL    E62
.................... 	i2c_stop();	 
07AE2:  MOV     #1F,W0
07AE4:  AND     206,W0
07AE6:  BRA     NZ,7AE2
07AE8:  BSET.B  206.2
07AEA:  BTSC.B  206.2
07AEC:  BRA     7AEA
07AEE:  RETURN  
.................... } 
....................  
.................... unsigned int8 Check_balise(void) 
.................... { 
.................... 	static unsigned int8 ack_balise=0; 
....................  
.................... 	i2c_start(); 
*
09D0A:  BTSS.B  208.3
09D0C:  BRA     9D16
09D0E:  BSET.B  206.1
09D10:  BTSC.B  206.1
09D12:  BRA     9D10
09D14:  BRA     9D1C
09D16:  BSET.B  206.0
09D18:  BTSC.B  206.0
09D1A:  BRA     9D18
.................... 	ack_balise=i2c_write(0x21);			// adresse de balise en lecture 
09D1C:  MOV.B   #21,W1L
09D1E:  CALL    E62
09D22:  MOV.B   W0L,87C
.................... 	if(ack_balise==0) 
09D24:  CP0.B   87C
09D26:  BRA     NZ,9D34
.................... 	{					// si elle est dÃ©tectÃ©e - demander sa lecture 
.................... 		delay_us(30); 
09D28:  REPEAT  #256
09D2A:  NOP     
.................... 		value_balise=i2c_read(0); 
09D2C:  CLR.B   W1
09D2E:  CALL    1308
09D32:  MOV.B   W0L,860
.................... 	} 
.................... 	i2c_stop(); 
09D34:  MOV     #1F,W0
09D36:  AND     206,W0
09D38:  BRA     NZ,9D34
09D3A:  BSET.B  206.2
09D3C:  BTSC.B  206.2
09D3E:  BRA     9D3C
....................  
.................... 	return value_balise; 
09D40:  MOV.B   860,W0L
09D42:  MOV.B   W0L,0
09D44:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Init.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 05.03.2015																== 
.................... ===  Nom du programme 	: InterfaceRoboteQuC.mcp													== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Fonctions d'initialisation du dsPIC30F6014A.				    								== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Init 
.................... #define ___Init 
....................  
.................... //**************************************************************************************************** 
.................... //*  Défintion des bits 
.................... //*  ! Utiliser LATx pour des sorties et PORTx pour des entrées lorsque commandes succintes rapides. ! 
.................... //**************************************************************************************************** 
.................... #bit _LED1 = LATC.1			//--| 
.................... #bit _LED2 = LATC.2			//	| 
.................... #bit _LED3 = LATC.3			//	|- LEDs 
.................... #bit _LED4 = LATC.4			//	| 
....................  
.................... #bit _DEMA = PORTA.10		//--| 
.................... #bit _TEAM = PORTA.12		//	| 
.................... #bit _Capdist = PORTA.13		//	|- Digital Inputs 
.................... #bit _Dig4 = PORTA.6		//	| 
.................... #bit _ZeroPoint = PORTA.7		//  | 
.................... #bit _Dig6 = PORTA.9		//	| 
....................  
.................... #bit _Out1 = LATD.0 		//--| 
.................... #bit _Out2 = LATD.1	    //	| 
.................... #bit _Out3 = LATD.2 	 	//	| 
.................... #bit _Out4 = LATD.3 		//	|- Outputs 
.................... #bit _SERV = LATD.4		//	| 
.................... #bit _LDT1 = LATD.5 		//	| 
.................... #bit _LDT2 = LATD.6		//  | 
.................... #bit _Out8 = LATD.7		//	| 
....................  
.................... #bit _Tim1On = T1CON.15 
.................... #bit _Tim2On = T2CON.15 
.................... #bit _Tim3On = T3CON.15 
....................  
.................... #bit _I2CEN = I2CCON.15 
.................... #bit _GCEN = I2CCON.7 
....................  
.................... #bit _En_Diz = PORTB.10 
.................... #bit _EN_Uni = PORTB.11 
....................  
....................  
.................... enum{STOP,CHARGE_OBJ,DRIVER_GO,OBJ_PERSO,DRIVER_DONE,OBJ_DONE,WAIT}State=STOP; 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    __Init_dsPIC 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    30.01.2015 
.................... //  Statut :    Fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Config. et initialisation du dsPIC30F6014A. 
.................... //	Paramètre(s): / 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Init_dsPIC(void) 
.................... { 
.................... 	//------------------------------------------------------------------------------ 
.................... 	// Configuration des I/O 
.................... 	TRISA = 0b0011011011000000;		// RA6,7,9,10,12,13 : Digital Input 
*
00FCE:  MOV     #36C0,W4
00FD0:  MOV     W4,2C0
.................... 	PORTA=0; 
00FD2:  CLR     2C2
.................... 	TRISB = 0b0000000000111100;		// RB2-5: Analog Input 
00FD4:  MOV     #3C,W4
00FD6:  MOV     W4,2C6
.................... 	PORTB=0; 
00FD8:  CLR     2C8
.................... 	TRISC = 0b0000000000000000;		// RC1-4: LEDs 
00FDA:  CLR     2CC
.................... 	PORTC=0; 
00FDC:  CLR     2CE
.................... 	TRISD = 0b0000000011110000;		// RD0-7: Outputs  // 2018 RD4 à RD7 utilisé en entrée 
00FDE:  MOV     #F0,W4
00FE0:  MOV     W4,2D2
.................... 	PORTD=0; 
00FE2:  CLR     2D4
.................... 	TRISF = 0b0000000000010100;		// RF2-5: Rx1, Tx1, Rx2, Tx2 
00FE4:  MOV     #14,W4
00FE6:  MOV     W4,2DE
.................... 	PORTF=0; 
00FE8:  CLR     2E0
.................... 	TRISG = 0b0000000000001100;		// RG2-3: SCL-SDA 
00FEA:  MOV     #C,W4
00FEC:  MOV     W4,2E4
.................... 	PORTG=0;  
00FEE:  CLR     2E6
....................  
....................  
.................... // configuration de l'I2C 
.................... 	I2CCON = 0x800f;//LAISSER, SINON L'I2C PLANTE 
00FF0:  MOV     #800F,W4
00FF2:  MOV     W4,206
.................... //	_GCEN=0; 
.................... //	_I2CEN=1; 
.................... 	 
.................... 	// Temps de jeu 
.................... 	// Set le timer1 à 1 [ms] 
.................... 	setup_timer1(TMR_INTERNAL,0x4E20);	 
00FF4:  CLR     104
00FF6:  MOV     #4E20,W4
00FF8:  MOV     W4,102
00FFA:  MOV     #8000,W4
00FFC:  MOV     W4,104
....................  
.................... 	// Capture balise 
.................... 	// Set le timer3 avec la fréquence interne, incrément chaque 64 instructions, jusque 31250 => 100 [ms] 
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, 31250); 
00FFE:  CLR     112
01000:  MOV     #7A12,W4
01002:  MOV     W4,10E
01004:  MOV     #8020,W4
01006:  MOV     W4,112
.................... 	 
.................... 	// Autorise le timer1 
.................... 	enable_interrupts(INT_TIMER1); 
01008:  BSET.B  8C.3
.................... 	// Autorise le timer3 
.................... 	enable_interrupts(INT_TIMER3); 
0100A:  BSET.B  8C.7
.................... 	// Interruptions RS232 
.................... 	enable_interrupts(INT_RDA2);	// Réception RS232/1 
0100C:  BSET.B  8F.0
.................... 	// Autorise les interruptions globalement 
.................... 	enable_interrupts(INTR_GLOBAL); 
0100E:  BCLR.B  81.7
01010:  CLR     42
01012:  BSET.B  81.7
.................... 	 
.................... 	config_driver_moteur_pid(0xC0, 200, 1, 0); 
01014:  MOV.B   #C0,W0L
01016:  MOV.B   W0L,1B32
01018:  MOV     #C8,W4
0101A:  MOV     W4,1B34
0101C:  MOV     #1,W4
0101E:  MOV     W4,1B36
01020:  CLR     1B38
01022:  CALL    E7A
.................... 	config_driver_moteur_pid(0xC2, 200, 1, 0); 
01026:  MOV.B   #C2,W0L
01028:  MOV.B   W0L,1B32
0102A:  MOV     #C8,W4
0102C:  MOV     W4,1B34
0102E:  MOV     #1,W4
01030:  MOV     W4,1B36
01032:  CLR     1B38
01034:  CALL    E7A
.................... 	delay_ms(10); 
01038:  MOV     #A,W0
0103A:  CALL    F0E
.................... 	 
.................... 	config_driver_moteur(0xC0, 5000, 5000, 2000,88064);//moteur cremaillere 
0103E:  MOV.B   #C0,W0L
01040:  MOV.B   W0L,1B32
01042:  MOV     #1388,W4
01044:  MOV     W4,1B34
01046:  MOV     #1388,W4
01048:  MOV     W4,1B36
0104A:  MOV     #7D0,W4
0104C:  MOV     W4,1B38
0104E:  MOV     #5800,W4
01050:  MOV     W4,1B3A
01052:  CALL    F22
.................... 	config_driver_moteur(0xC2, 5000, 5000, 2000,11776);//moteur couronne 
01056:  MOV.B   #C2,W0L
01058:  MOV.B   W0L,1B32
0105A:  MOV     #1388,W4
0105C:  MOV     W4,1B34
0105E:  MOV     #1388,W4
01060:  MOV     W4,1B36
01062:  MOV     #7D0,W4
01064:  MOV     W4,1B38
01066:  MOV     #2E00,W4
01068:  MOV     W4,1B3A
0106A:  CALL    F22
.................... 	delay_ms(10); 
0106E:  MOV     #A,W0
01070:  CALL    F0E
.................... 	 
.................... 	return; 
01074:  RETURN  
.................... 	 
.................... } 
.................... 	 
.................... #endif 
....................  
.................... #include "data/___data.h" 
.................... /* 
.................... * \file ___data.h 
.................... * \brief Data pour le robot. 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.03.2016 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___data_H 
.................... #define ___data_H 
....................  
.................... 	 
.................... 	int1 Depl_send = 0; 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	////////// Gestion erreurs 
.................... 	int1 Base = 0; 
.................... 	int16 TableWidth =3000; 
.................... 	unsigned int8 NbreZone_check = 0; 
.................... 	char RoboteQ_receiveBuffer[256]={};			// Buffer des donnÃ©es reÃ§ues 
.................... 	unsigned int8 TabSentRS232[256]={0}; 
....................  
....................  
.................... 	//Zones interdites 
.................... 	struct Coord 
.................... 	{ 
.................... 		double X; 
.................... 		double Y; 
.................... 	}; 
....................  
.................... 	 
.................... 	int intersection_found = 0; 
.................... 	 
.................... 	int path_found = 0; 
.................... 	int relay_point_number = 0; 
.................... 	int i_rel = 0; 
.................... 	int i_depl = 0; 
.................... 	int TabIntersection[10]; 
.................... 	struct Coord PtsRelai[10], start_point, end_point; 
....................  
.................... 	//Tableau contenant les zone interdites. Chaque zone contient {x1, y1, x4, y4} 
.................... 	//zones interdites écrites directement dans le code. !! Mettre en commentaire si on les lit depuis le PC !! 
.................... 	//long TabZones[10][4] = {{200,150,270,180}, {20,150,70,180}, {0,0,0,0}, {0,0,0,0},{80,70,180,100},{0,0,0,0},{0,0,0,0},{30,30,50,50},{0,0,0,0},{150,15,250,50}}; 
.................... 	long TabZones[10][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; 
.................... 	 
.................... 	unsigned int16 TIME_SURCHAUFFE_MS = 1000; 
.................... 	unsigned int8 Erreur_max_surchauffe = 10; 
.................... 	unsigned int32 Time_ejection = 0; 
.................... 	unsigned int32 Time_ejection_toDo = 0; 
.................... 	int1 Action_send = 0;	 
....................  
.................... 	signed int16 TabObjectifs[7][13][12] = {0}; 
....................  
.................... 	// Objectif en cours 
.................... 	signed int16 oXp=0,oYp=0,oType=0,oAvAr=0,oCoteTourn=0,oVitMax=0,Obj_Action = 0,Pt_commun = 0,Ponderation = 0,Obj_end = 0,Next_obj = 0,keep_obj = 0;	 
.................... 	 
.................... 	 
.................... 	////////// UART 
.................... 	unsigned int8 UART_WD_DELAY = 20;	// Délai du watchdog UART, en [ms]; par pas de 1 [ms] 
.................... 	unsigned int8 UART_NBR_REP_NAK = 5;	// Combien de fois maximum il faut répéter une commande si le récepteur n'a pas compris  
.................... 	// Adresse UART du driver 
.................... 	unsigned int32 UART_ADDR = 2; 
.................... 	 
.................... 	////////// IIC 
.................... 	// Combien de fois maximum il faut répéter une commande si le récepteur n'a pas compris 
.................... //	unsigned int8 IIC_NBR_REP_NAK = 5;	 
.................... 	// Combien de fois on rééssaie un envoie 
.................... //	unsigned int8 IIC_NBR_REP_ENV = 5; 
....................  	//Adresse IIC du driver 
.................... //	unsigned int8 DRIVER_IIC_ADR = 0x50; 
.................... //	unsigned int8 TabToSendIIC[60]={0}; 
....................  
.................... 	 
.................... 	////////// Balise ///////// 
.................... 	unsigned int8 MAX_VALUE_DETECT_BALISE = 3; // Valeur maximum pour la détection de l'adversaire (action trig si <=) 
.................... 	unsigned int16 TIME_TO_CHECK_BAL=200;	// Temps avant chaque check balise 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Mise en marche/arrêt 
.................... int1 flagMarche = 0; 
....................  
.................... // Pour le nombre d'objectifs déjà enregistrés 
.................... unsigned int16 NbreObjectifs = 0; 
.................... 	// Pour connaître le prochain objectif à atteindre 
.................... unsigned int16 NextObj = 0; 
....................  
.................... ////PC 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
06BCC:  MOV     W5,[W15++]
06BCE:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
06BD0:  BCLR.B  1B91.0
....................    y = x; 
06BD2:  PUSH    1B8C
06BD4:  POP     1B92
06BD6:  PUSH    1B8E
06BD8:  POP     1B94
....................  
....................    if (x < 0) 
06BDA:  MOV     1B8C,W0
06BDC:  MOV     1B8E,W1
06BDE:  MOV     #0,W2
06BE0:  MOV     #0,W3
06BE2:  CALL    6890
06BE6:  BRA     NC,6BF4
....................    { 
....................       s = 1; 
06BE8:  BSET.B  1B91.0
....................       y = -y; 
06BEA:  MOV     #1B92,W0
06BEC:  MOV     #1B92,W1
06BEE:  REPEAT  #3
06BF0:  MOV     [W0++],[W1++]
06BF2:  BTG.B   1B95.7
....................    } 
....................  
....................    if (y <= 32768.0) 
06BF4:  MOV     1B92,W0
06BF6:  MOV     1B94,W1
06BF8:  MOV     #0,W2
06BFA:  MOV     #4700,W3
06BFC:  CALL    6890
06C00:  BRA     C,6C04
06C02:  BRA     NZ,6C18
....................       res = (float32)(unsigned int16)y; 
06C04:  MOV     1B92,W0
06C06:  MOV     1B94,W1
06C08:  CALL    68F8
06C0C:  CALL    6924
06C10:  MOV     W0,1B96
06C12:  MOV     W1,1B98
06C14:  GOTO    6CAC
....................  
....................  else if (y < 10000000.0) 
06C18:  MOV     1B92,W0
06C1A:  MOV     1B94,W1
06C1C:  MOV     #9680,W2
06C1E:  MOV     #4B18,W3
06C20:  CALL    6890
06C24:  BRA     NC,6CA4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
06C26:  MOV     1B92,W0
06C28:  MOV     1B94,W1
06C2A:  MOV     #0,W2
06C2C:  MOV     #3800,W3
06C2E:  CALL    695E
06C32:  CALL    68F8
06C36:  MOV     W0,1B9A
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
06C38:  MOV     1B92,W0
06C3A:  MOV     1B94,W1
06C3C:  MOV     #0,W2
06C3E:  MOV     #3800,W3
06C40:  CALL    695E
06C44:  MOV     W0,W5
06C46:  MOV     W1,W6
06C48:  MOV     1B9A,W0
06C4A:  CALL    6924
06C4E:  BSET.B  43.0
06C50:  MOV     W0,W2
06C52:  MOV     W1,W3
06C54:  MOV     W5,W0
06C56:  MOV     W6,W1
06C58:  CALL    6A22
06C5C:  MOV     W0,W2
06C5E:  MOV     W1,W3
06C60:  MOV     #0,W0
06C62:  MOV     #4700,W1
06C64:  CALL    695E
06C68:  MOV     W0,1B92
06C6A:  MOV     W1,1B94
....................       res = 32768.0*(float32)l; 
06C6C:  MOV     1B9A,W0
06C6E:  CALL    6924
06C72:  MOV     W0,W2
06C74:  MOV     W1,W3
06C76:  MOV     #0,W0
06C78:  MOV     #4700,W1
06C7A:  CALL    695E
06C7E:  MOV     W0,1B96
06C80:  MOV     W1,1B98
....................       res += (float32)(unsigned int16)y; 
06C82:  MOV     1B92,W0
06C84:  MOV     1B94,W1
06C86:  CALL    68F8
06C8A:  CALL    6924
06C8E:  BCLR.B  43.0
06C90:  MOV     W0,W2
06C92:  MOV     W1,W3
06C94:  MOV     1B96,W0
06C96:  MOV     1B98,W1
06C98:  CALL    6A22
06C9C:  MOV     W0,1B96
06C9E:  MOV     W1,1B98
....................    } 
06CA0:  GOTO    6CAC
....................  
....................  else 
....................   res = y; 
06CA4:  PUSH    1B92
06CA6:  POP     1B96
06CA8:  PUSH    1B94
06CAA:  POP     1B98
....................  
....................  y = y - (float32)(unsigned int16)y; 
06CAC:  MOV     1B92,W0
06CAE:  MOV     1B94,W1
06CB0:  CALL    68F8
06CB4:  CALL    6924
06CB8:  BSET.B  43.0
06CBA:  MOV     W0,W2
06CBC:  MOV     W1,W3
06CBE:  MOV     1B92,W0
06CC0:  MOV     1B94,W1
06CC2:  CALL    6A22
06CC6:  MOV     W0,1B92
06CC8:  MOV     W1,1B94
....................  
....................  if (s) 
06CCA:  BTSS.B  1B91.0
06CCC:  BRA     6CD8
....................   res = -res; 
06CCE:  MOV     #1B96,W0
06CD0:  MOV     #1B96,W1
06CD2:  REPEAT  #3
06CD4:  MOV     [W0++],[W1++]
06CD6:  BTG.B   1B99.7
....................  
....................  if (y != 0) 
06CD8:  MOV     1B92,W0
06CDA:  MOV     1B94,W1
06CDC:  MOV     #0,W2
06CDE:  MOV     #0,W3
06CE0:  CALL    6890
06CE4:  BRA     Z,6D1C
....................  { 
....................   if (s == 1 && n == 0) 
06CE6:  BTSS.B  1B91.0
06CE8:  BRA     6D00
06CEA:  CP0.B   1B90
06CEC:  BRA     NZ,6D00
....................    res -= 1.0; 
06CEE:  BSET.B  43.0
06CF0:  MOV     1B96,W0
06CF2:  MOV     1B98,W1
06CF4:  MOV     #0,W2
06CF6:  MOV     #3F80,W3
06CF8:  CALL    6A22
06CFC:  MOV     W0,1B96
06CFE:  MOV     W1,1B98
....................  
....................   if (s == 0 && n == 1) 
06D00:  BTSC.B  1B91.0
06D02:  BRA     6D1C
06D04:  MOV     1B90,W4
06D06:  CP.B    W4L,#1
06D08:  BRA     NZ,6D1C
....................    res += 1.0; 
06D0A:  BCLR.B  43.0
06D0C:  MOV     1B96,W0
06D0E:  MOV     1B98,W1
06D10:  MOV     #0,W2
06D12:  MOV     #3F80,W3
06D14:  CALL    6A22
06D18:  MOV     W0,1B96
06D1A:  MOV     W1,1B98
....................  } 
....................  if (x == 0) 
06D1C:  MOV     1B8C,W0
06D1E:  MOV     1B8E,W1
06D20:  MOV     #0,W2
06D22:  MOV     #0,W3
06D24:  CALL    6890
06D28:  BRA     NZ,6D2E
....................     res = 0; 
06D2A:  CLR     1B96
06D2C:  CLR     1B98
....................  
....................  return (res); 
06D2E:  MOV     1B96,W0
06D30:  MOV     1B98,W1
06D32:  MOV     [--W15],W6
06D34:  MOV     [--W15],W5
06D36:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
*
023DE:  MOV     W5,[W15++]
023E0:  MOV     W6,[W15++]
023E2:  MOV     W7,[W15++]
023E4:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
023E6:  BCLR.B  1C07.0
....................    y = x; 
023E8:  PUSH    1BFE
023EA:  POP     1C08
023EC:  PUSH    1C00
023EE:  POP     1C0A
023F0:  PUSH    1C02
023F2:  POP     1C0C
023F4:  PUSH    1C04
023F6:  POP     1C0E
....................  
....................    if (x < 0) 
023F8:  MOV     1BFE,W0
023FA:  MOV     1C00,W1
023FC:  MOV     1C02,W2
023FE:  MOV     1C04,W3
02400:  MOV     #0,W4
02402:  MOV     #0,W5
02404:  MOV     #0,W6
02406:  MOV     #0,W7
02408:  CALL    1E2E
0240C:  BRA     NC,241A
....................    { 
....................       s = 1; 
0240E:  BSET.B  1C07.0
....................       y = -y; 
02410:  MOV     #1C08,W0
02412:  MOV     #1C08,W1
02414:  REPEAT  #7
02416:  MOV     [W0++],[W1++]
02418:  BTG.B   1C0F.7
....................    } 
....................  
....................    if (y <= 32768.0) 
0241A:  MOV     1C08,W0
0241C:  MOV     1C0A,W1
0241E:  MOV     1C0C,W2
02420:  MOV     1C0E,W3
02422:  MOV     #0,W4
02424:  MOV     #0,W5
02426:  MOV     #0,W6
02428:  MOV     #40E0,W7
0242A:  CALL    1E2E
0242E:  BRA     C,2432
02430:  BRA     NZ,2454
....................       res = (float64)(unsigned int16)y; 
02432:  MOV     1C08,W0
02434:  MOV     1C0A,W1
02436:  MOV     1C0C,W2
02438:  MOV     1C0E,W3
0243A:  CALL    2316
0243E:  MOV     #0,W1
02440:  MOV     #0,W2
02442:  MOV     #0,W3
02444:  CALL    2374
02448:  MOV     W0,1C10
0244A:  MOV     W1,1C12
0244C:  MOV     W2,1C14
0244E:  MOV     W3,1C16
02450:  GOTO    2568
....................    else if (y < 4503599627370496.0) 
02454:  MOV     1C08,W0
02456:  MOV     1C0A,W1
02458:  MOV     1C0C,W2
0245A:  MOV     1C0E,W3
0245C:  MOV     #0,W4
0245E:  MOV     #0,W5
02460:  MOV     #0,W6
02462:  MOV     #4330,W7
02464:  CALL    1E2E
02468:  BRA     NC,2550
....................    { 
....................       l = (int64)(y*0.000030517578125); 
0246A:  MOV     1C08,W0
0246C:  MOV     1C0A,W1
0246E:  MOV     1C0C,W2
02470:  MOV     1C0E,W3
02472:  MOV     #0,W4
02474:  MOV     #0,W5
02476:  MOV     #0,W6
02478:  MOV     #3F00,W7
0247A:  CALL    C4A
0247E:  CALL    2230
02482:  MOV     W0,1C18
02484:  MOV     W1,1C1A
02486:  MOV     W2,1C1C
02488:  MOV     W3,1C1E
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
0248A:  MOV     1C08,W0
0248C:  MOV     1C0A,W1
0248E:  MOV     1C0C,W2
02490:  MOV     1C0E,W3
02492:  MOV     #0,W4
02494:  MOV     #0,W5
02496:  MOV     #0,W6
02498:  MOV     #3F00,W7
0249A:  CALL    C4A
0249E:  MOV     W0,W5
024A0:  MOV     W1,W6
024A2:  MOV     W2,W7
024A4:  MOV     W3,W8
024A6:  MOV     1C18,W0
024A8:  MOV     1C1A,W1
024AA:  MOV     1C1C,W2
024AC:  MOV     1C1E,W3
024AE:  CALL    1B2C
024B2:  BSET.B  43.0
024B4:  MOV     W5,[W15++]
024B6:  MOV     W6,[W15++]
024B8:  MOV     W7,[W15++]
024BA:  MOV     W0,W4
024BC:  MOV     W5,W0
024BE:  MOV     W1,W5
024C0:  MOV     W6,W1
024C2:  MOV     W2,W6
024C4:  MOV     W7,W2
024C6:  MOV     W3,W7
024C8:  MOV     W8,W3
024CA:  CALL    1C40
024CE:  MOV     [--W15],W7
024D0:  MOV     [--W15],W6
024D2:  MOV     [--W15],W5
024D4:  MOV     W0,W4
024D6:  MOV     W1,W5
024D8:  MOV     W2,W6
024DA:  MOV     W3,W7
024DC:  MOV     #0,W0
024DE:  MOV     #0,W1
024E0:  MOV     #0,W2
024E2:  MOV     #40E0,W3
024E4:  CALL    C4A
024E8:  MOV     W0,1C08
024EA:  MOV     W1,1C0A
024EC:  MOV     W2,1C0C
024EE:  MOV     W3,1C0E
....................       res = 32768.0*(float64)l; 
024F0:  MOV     1C18,W0
024F2:  MOV     1C1A,W1
024F4:  MOV     1C1C,W2
024F6:  MOV     1C1E,W3
024F8:  CALL    1B2C
024FC:  MOV     W0,W4
024FE:  MOV     W1,W5
02500:  MOV     W2,W6
02502:  MOV     W3,W7
02504:  MOV     #0,W0
02506:  MOV     #0,W1
02508:  MOV     #0,W2
0250A:  MOV     #40E0,W3
0250C:  CALL    C4A
02510:  MOV     W0,1C10
02512:  MOV     W1,1C12
02514:  MOV     W2,1C14
02516:  MOV     W3,1C16
....................       res += (float64)(unsigned int16)y; 
02518:  MOV     1C08,W0
0251A:  MOV     1C0A,W1
0251C:  MOV     1C0C,W2
0251E:  MOV     1C0E,W3
02520:  CALL    2316
02524:  MOV     #0,W1
02526:  MOV     #0,W2
02528:  MOV     #0,W3
0252A:  CALL    2374
0252E:  BCLR.B  43.0
02530:  MOV     W0,W4
02532:  MOV     W1,W5
02534:  MOV     W2,W6
02536:  MOV     W3,W7
02538:  MOV     1C10,W0
0253A:  MOV     1C12,W1
0253C:  MOV     1C14,W2
0253E:  MOV     1C16,W3
02540:  CALL    1C40
02544:  MOV     W0,1C10
02546:  MOV     W1,1C12
02548:  MOV     W2,1C14
0254A:  MOV     W3,1C16
....................    } 
0254C:  GOTO    2568
....................    else 
....................    { 
....................       res = y; 
02550:  PUSH    1C08
02552:  POP     1C10
02554:  PUSH    1C0A
02556:  POP     1C12
02558:  PUSH    1C0C
0255A:  POP     1C14
0255C:  PUSH    1C0E
0255E:  POP     1C16
....................       y = 0.0; 
02560:  CLR     1C08
02562:  CLR     1C0A
02564:  CLR     1C0C
02566:  CLR     1C0E
....................    } 
....................     
....................    if(y != 0) 
02568:  MOV     1C08,W0
0256A:  MOV     1C0A,W1
0256C:  MOV     1C0C,W2
0256E:  MOV     1C0E,W3
02570:  MOV     #0,W4
02572:  MOV     #0,W5
02574:  MOV     #0,W6
02576:  MOV     #0,W7
02578:  CALL    1E2E
0257C:  BRA     Z,25B2
....................       y = y - (float64)(unsigned int16)y; 
0257E:  MOV     1C08,W0
02580:  MOV     1C0A,W1
02582:  MOV     1C0C,W2
02584:  MOV     1C0E,W3
02586:  CALL    2316
0258A:  MOV     #0,W1
0258C:  MOV     #0,W2
0258E:  MOV     #0,W3
02590:  CALL    2374
02594:  BSET.B  43.0
02596:  MOV     W0,W4
02598:  MOV     W1,W5
0259A:  MOV     W2,W6
0259C:  MOV     W3,W7
0259E:  MOV     1C08,W0
025A0:  MOV     1C0A,W1
025A2:  MOV     1C0C,W2
025A4:  MOV     1C0E,W3
025A6:  CALL    1C40
025AA:  MOV     W0,1C08
025AC:  MOV     W1,1C0A
025AE:  MOV     W2,1C0C
025B0:  MOV     W3,1C0E
....................  
....................    if (s) 
025B2:  BTSS.B  1C07.0
025B4:  BRA     25C0
....................       res = -res; 
025B6:  MOV     #1C10,W0
025B8:  MOV     #1C10,W1
025BA:  REPEAT  #7
025BC:  MOV     [W0++],[W1++]
025BE:  BTG.B   1C17.7
....................  
....................    if (y != 0) 
025C0:  MOV     1C08,W0
025C2:  MOV     1C0A,W1
025C4:  MOV     1C0C,W2
025C6:  MOV     1C0E,W3
025C8:  MOV     #0,W4
025CA:  MOV     #0,W5
025CC:  MOV     #0,W6
025CE:  MOV     #0,W7
025D0:  CALL    1E2E
025D4:  BRA     Z,2624
....................    { 
....................       if (s == 1 && n == 0) 
025D6:  BTSS.B  1C07.0
025D8:  BRA     25FC
025DA:  CP0.B   1C06
025DC:  BRA     NZ,25FC
....................          res -= 1.0; 
025DE:  BSET.B  43.0
025E0:  MOV     1C10,W0
025E2:  MOV     1C12,W1
025E4:  MOV     1C14,W2
025E6:  MOV     1C16,W3
025E8:  MOV     #0,W4
025EA:  MOV     #0,W5
025EC:  MOV     #0,W6
025EE:  MOV     #3FF0,W7
025F0:  CALL    1C40
025F4:  MOV     W0,1C10
025F6:  MOV     W1,1C12
025F8:  MOV     W2,1C14
025FA:  MOV     W3,1C16
....................  
....................       if (s == 0 && n == 1) 
025FC:  BTSC.B  1C07.0
025FE:  BRA     2624
02600:  MOV     1C06,W4
02602:  CP.B    W4L,#1
02604:  BRA     NZ,2624
....................          res += 1.0; 
02606:  BCLR.B  43.0
02608:  MOV     1C10,W0
0260A:  MOV     1C12,W1
0260C:  MOV     1C14,W2
0260E:  MOV     1C16,W3
02610:  MOV     #0,W4
02612:  MOV     #0,W5
02614:  MOV     #0,W6
02616:  MOV     #3FF0,W7
02618:  CALL    1C40
0261C:  MOV     W0,1C10
0261E:  MOV     W1,1C12
02620:  MOV     W2,1C14
02622:  MOV     W3,1C16
....................    } 
....................     
....................    if (x == 0) 
02624:  MOV     1BFE,W0
02626:  MOV     1C00,W1
02628:  MOV     1C02,W2
0262A:  MOV     1C04,W3
0262C:  MOV     #0,W4
0262E:  MOV     #0,W5
02630:  MOV     #0,W6
02632:  MOV     #0,W7
02634:  CALL    1E2E
02638:  BRA     NZ,2642
....................       res = 0; 
0263A:  CLR     1C10
0263C:  CLR     1C12
0263E:  CLR     1C14
02640:  CLR     1C16
....................  
....................    return (res); 
02642:  MOV     1C10,W0
02644:  MOV     1C12,W1
02646:  MOV     1C14,W2
02648:  MOV     1C16,W3
0264A:  MOV     [--W15],W8
0264C:  MOV     [--W15],W7
0264E:  MOV     [--W15],W6
02650:  MOV     [--W15],W5
02652:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
06D38:  CLR.B   1B90
06D3A:  PUSH    1B82
06D3C:  POP     1B8C
06D3E:  PUSH    1B84
06D40:  POP     1B8E
06D42:  CALL    6BCC
06D46:  MOV.D   W0,W0
06D48:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
*
0266E:  CLR.B   1C06
02670:  PUSH    1BEC
02672:  POP     1BFE
02674:  PUSH    1BEE
02676:  POP     1C00
02678:  PUSH    1BF0
0267A:  POP     1C02
0267C:  PUSH    1BF2
0267E:  POP     1C04
02680:  CALL    23DE
02684:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
06D4A:  MOV.B   #1,W0L
06D4C:  MOV.B   W0L,1B90
06D4E:  PUSH    1B82
06D50:  POP     1B8C
06D52:  PUSH    1B84
06D54:  POP     1B8E
06D56:  CALL    6BCC
06D5A:  MOV.D   W0,W0
06D5C:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
02654:  MOV.B   #1,W0L
02656:  MOV.B   W0L,1C06
02658:  PUSH    1BEC
0265A:  POP     1BFE
0265C:  PUSH    1BEE
0265E:  POP     1C00
02660:  PUSH    1BF0
02662:  POP     1C02
02664:  PUSH    1BF2
02666:  POP     1C04
02668:  CALL    23DE
0266C:  RETURN  
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
*
02686:  MOV     W5,[W15++]
02688:  MOV     W6,[W15++]
0268A:  MOV     W7,[W15++]
0268C:  MOV     W8,[W15++]
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
0268E:  MOV     1BD4,W0
02690:  MOV     1BD6,W1
02692:  MOV     1BD8,W2
02694:  MOV     1BDA,W3
02696:  MOV     #0,W4
02698:  MOV     #0,W5
0269A:  MOV     #0,W6
0269C:  MOV     #0,W7
0269E:  CALL    1E2E
026A2:  BRA     Z,276E
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
026A4:  MOV     1BCC,W0
026A6:  MOV     1BCE,W1
026A8:  MOV     1BD0,W2
026AA:  MOV     1BD2,W3
026AC:  MOV     1BD4,W4
026AE:  MOV     1BD6,W5
026B0:  MOV     1BD8,W6
026B2:  MOV     1BDA,W7
026B4:  CALL    D5A
026B8:  MOV     W0,W5
026BA:  MOV     W1,W6
026BC:  MOV     W2,W7
026BE:  MOV     W3,W8
026C0:  MOV     W5,[W15++]
026C2:  MOV     W6,[W15++]
026C4:  MOV     W7,[W15++]
026C6:  MOV     W5,W0
026C8:  MOV     W6,W1
026CA:  MOV     W7,W2
026CC:  MOV     W8,W3
026CE:  MOV     #0,W4
026D0:  MOV     #0,W5
026D2:  MOV     #0,W6
026D4:  MOV     #0,W7
026D6:  CALL    1E2E
026DA:  MOV     [--W15],W7
026DC:  MOV     [--W15],W6
026DE:  MOV     [--W15],W5
026E0:  BRA     NC,270E
026E2:  MOV     1BCC,W0
026E4:  MOV     1BCE,W1
026E6:  MOV     1BD0,W2
026E8:  MOV     1BD2,W3
026EA:  MOV     1BD4,W4
026EC:  MOV     1BD6,W5
026EE:  MOV     1BD8,W6
026F0:  MOV     1BDA,W7
026F2:  CALL    D5A
026F6:  MOV     W0,W5
026F8:  MOV     W1,W6
026FA:  MOV     W2,W7
026FC:  MOV     W3,W8
026FE:  MOV     W5,1BEC
02700:  MOV     W6,1BEE
02702:  MOV     W7,1BF0
02704:  MOV     W8,1BF2
02706:  CALL    2654
0270A:  GOTO    2736
0270E:  MOV     1BCC,W0
02710:  MOV     1BCE,W1
02712:  MOV     1BD0,W2
02714:  MOV     1BD2,W3
02716:  MOV     1BD4,W4
02718:  MOV     1BD6,W5
0271A:  MOV     1BD8,W6
0271C:  MOV     1BDA,W7
0271E:  CALL    D5A
02722:  MOV     W0,W5
02724:  MOV     W1,W6
02726:  MOV     W2,W7
02728:  MOV     W3,W8
0272A:  MOV     W5,1BEC
0272C:  MOV     W6,1BEE
0272E:  MOV     W7,1BF0
02730:  MOV     W8,1BF2
02732:  CALL    266E
02736:  MOV     W0,1BDC
02738:  MOV     W1,1BDE
0273A:  MOV     W2,1BE0
0273C:  MOV     W3,1BE2
....................       return(x-(i*y)); 
0273E:  MOV     1BDC,W0
02740:  MOV     1BDE,W1
02742:  MOV     1BE0,W2
02744:  MOV     1BE2,W3
02746:  MOV     1BD4,W4
02748:  MOV     1BD6,W5
0274A:  MOV     1BD8,W6
0274C:  MOV     1BDA,W7
0274E:  CALL    C4A
02752:  BSET.B  43.0
02754:  MOV     W0,W4
02756:  MOV     W1,W5
02758:  MOV     W2,W6
0275A:  MOV     W3,W7
0275C:  MOV     1BCC,W0
0275E:  MOV     1BCE,W1
02760:  MOV     1BD0,W2
02762:  MOV     1BD2,W3
02764:  CALL    1C40
02768:  BRA     276E
....................    } 
0276A:  GOTO    276E
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0276E:  MOV     [--W15],W8
02770:  MOV     [--W15],W7
02772:  MOV     [--W15],W6
02774:  MOV     [--W15],W5
02776:  RETURN  
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
*
02B30:  MOV     W5,[W15++]
02B32:  MOV     W6,[W15++]
02B34:  MOV     W7,[W15++]
02B36:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
02B38:  MOV     1BCC,W0
02B3A:  MOV     1BCE,W1
02B3C:  MOV     1BD0,W2
02B3E:  MOV     1BD2,W3
02B40:  MOV     #82FE,W4
02B42:  MOV     #652B,W5
02B44:  MOV     #1547,W6
02B46:  MOV     #3FF7,W7
02B48:  CALL    C4A
02B4C:  MOV     W0,1BD6
02B4E:  MOV     W1,1BD8
02B50:  MOV     W2,1BDA
02B52:  MOV     W3,1BDC
....................    n = (signed int16)y; 
02B54:  MOV     1BD6,W0
02B56:  MOV     1BD8,W1
02B58:  MOV     1BDA,W2
02B5A:  MOV     1BDC,W3
02B5C:  CALL    2230
02B60:  MOV     W0,1BF4
....................    s = 0; 
02B62:  BCLR.B  1BD4.0
....................    y = x; 
02B64:  PUSH    1BCC
02B66:  POP     1BD6
02B68:  PUSH    1BCE
02B6A:  POP     1BD8
02B6C:  PUSH    1BD0
02B6E:  POP     1BDA
02B70:  PUSH    1BD2
02B72:  POP     1BDC
....................  
....................    if (x < 0) 
02B74:  MOV     1BCC,W0
02B76:  MOV     1BCE,W1
02B78:  MOV     1BD0,W2
02B7A:  MOV     1BD2,W3
02B7C:  MOV     #0,W4
02B7E:  MOV     #0,W5
02B80:  MOV     #0,W6
02B82:  MOV     #0,W7
02B84:  CALL    1E2E
02B88:  BRA     NC,2B9E
....................    { 
....................       s = 1; 
02B8A:  BSET.B  1BD4.0
....................       n = -n; 
02B8C:  MOV     #0,W4
02B8E:  MOV     1BF4,W3
02B90:  SUB     W4,W3,W0
02B92:  MOV     W0,1BF4
....................       y = -y; 
02B94:  MOV     #1BD6,W0
02B96:  MOV     #1BD6,W1
02B98:  REPEAT  #7
02B9A:  MOV     [W0++],[W1++]
02B9C:  BTG.B   1BDD.7
....................    } 
....................  
....................    res = 0.0; 
02B9E:  CLR     1BDE
02BA0:  CLR     1BE0
02BA2:  CLR     1BE2
02BA4:  CLR     1BE4
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
02BA6:  MOV     #1BE4,W4
02BA8:  MOV     W4,1BF2
....................    data1 = *p; 
02BAA:  MOV     1BF2,W0
02BAC:  MOV     [W0],[W15++]
02BAE:  POP     1BEE
....................    data2 = *p;    
02BB0:  MOV     1BF2,W0
02BB2:  MOV     [W0],[W15++]
02BB4:  POP     1BF0
....................    data1 = n + 0x3FF; 
02BB6:  MOV     #3FF,W4
02BB8:  MOV     1BF4,W3
02BBA:  ADD     W3,W4,W0
02BBC:  MOV     W0,1BEE
....................    data1 = data1 <<4; 
02BBE:  MOV     1BEE,W0
02BC0:  SL      W0,#4,W0
02BC2:  MOV     W0,1BEE
....................    if(bit_test(data2,15)) 
02BC4:  BTSS.B  1BF1.7
02BC6:  BRA     2BCC
....................    bit_set(data1,15); 
02BC8:  MOV     #1BEE,W4
02BCA:  BSET    [W4].F
....................    data2 = data2 & 0x000F; 
02BCC:  MOV     1BF0,W0
02BCE:  AND     W0,#F,W0
02BD0:  MOV     W0,1BF0
....................    data1 ^= data2; 
02BD2:  MOV     1BF0,W0
02BD4:  XOR     1BEE
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
02BD6:  MOV     #1BE4,W5
02BD8:  MOV     1BEE,W4
02BDA:  MOV     W4,[W5+#0]
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
02BDC:  MOV     1BD6,W0
02BDE:  MOV     1BD8,W1
02BE0:  MOV     1BDA,W2
02BE2:  MOV     1BDC,W3
02BE4:  MOV     #82FE,W4
02BE6:  MOV     #652B,W5
02BE8:  MOV     #1547,W6
02BEA:  MOV     #3FF7,W7
02BEC:  CALL    C4A
02BF0:  MOV     W0,W5
02BF2:  MOV     W1,W6
02BF4:  MOV     W2,W7
02BF6:  MOV     W3,W8
02BF8:  MOV     1BF4,W0
02BFA:  CLR     W3
02BFC:  BTSC    W0.F
02BFE:  SETM    W3
02C00:  MOV     W3,W1
02C02:  MOV     W3,W2
02C04:  CALL    1B2C
02C08:  BSET.B  43.0
02C0A:  MOV     W5,[W15++]
02C0C:  MOV     W6,[W15++]
02C0E:  MOV     W7,[W15++]
02C10:  MOV     W0,W4
02C12:  MOV     W5,W0
02C14:  MOV     W1,W5
02C16:  MOV     W6,W1
02C18:  MOV     W2,W6
02C1A:  MOV     W7,W2
02C1C:  MOV     W3,W7
02C1E:  MOV     W8,W3
02C20:  CALL    1C40
02C24:  MOV     [--W15],W7
02C26:  MOV     [--W15],W6
02C28:  MOV     [--W15],W5
02C2A:  MOV     W0,1BD6
02C2C:  MOV     W1,1BD8
02C2E:  MOV     W2,1BDA
02C30:  MOV     W3,1BDC
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
02C32:  MOV     #8C0F,W0
02C34:  MOV     #A655,W1
02C36:  MOV     #9582,W2
02C38:  MOV     #3DD9,W3
02C3A:  MOV     1BD6,W4
02C3C:  MOV     1BD8,W5
02C3E:  MOV     1BDA,W6
02C40:  MOV     1BDC,W7
02C42:  CALL    C4A
02C46:  MOV     W0,W5
02C48:  MOV     W1,W6
02C4A:  MOV     W2,W7
02C4C:  MOV     W3,W8
02C4E:  BCLR.B  43.0
02C50:  MOV     W5,[W15++]
02C52:  MOV     W6,[W15++]
02C54:  MOV     W7,[W15++]
02C56:  MOV     W5,W0
02C58:  MOV     W6,W1
02C5A:  MOV     W7,W2
02C5C:  MOV     W8,W3
02C5E:  MOV     #D7E6,W4
02C60:  MOV     #E5FF,W5
02C62:  MOV     #90C9,W6
02C64:  MOV     #BDC7,W7
02C66:  CALL    1C40
02C6A:  MOV     [--W15],W7
02C6C:  MOV     [--W15],W6
02C6E:  MOV     [--W15],W5
02C70:  MOV     W0,1BE6
02C72:  MOV     W1,1BE8
02C74:  MOV     W2,1BEA
02C76:  MOV     W3,1BEC
....................    r = r*y + pe_64[2]; 
02C78:  MOV     1BE6,W0
02C7A:  MOV     1BE8,W1
02C7C:  MOV     1BEA,W2
02C7E:  MOV     1BEC,W3
02C80:  MOV     1BD6,W4
02C82:  MOV     1BD8,W5
02C84:  MOV     1BDA,W6
02C86:  MOV     1BDC,W7
02C88:  CALL    C4A
02C8C:  MOV     W0,W5
02C8E:  MOV     W1,W6
02C90:  MOV     W2,W7
02C92:  MOV     W3,W8
02C94:  BCLR.B  43.0
02C96:  MOV     W5,[W15++]
02C98:  MOV     W6,[W15++]
02C9A:  MOV     W7,[W15++]
02C9C:  MOV     W5,W0
02C9E:  MOV     W6,W1
02CA0:  MOV     W7,W2
02CA2:  MOV     W8,W3
02CA4:  MOV     #40CE,W4
02CA6:  MOV     #4712,W5
02CA8:  MOV     #B70C,W6
02CAA:  MOV     #3E42,W7
02CAC:  CALL    1C40
02CB0:  MOV     [--W15],W7
02CB2:  MOV     [--W15],W6
02CB4:  MOV     [--W15],W5
02CB6:  MOV     W0,1BE6
02CB8:  MOV     W1,1BE8
02CBA:  MOV     W2,1BEA
02CBC:  MOV     W3,1BEC
....................    r = r*y + pe_64[3]; 
02CBE:  MOV     1BE6,W0
02CC0:  MOV     1BE8,W1
02CC2:  MOV     1BEA,W2
02CC4:  MOV     1BEC,W3
02CC6:  MOV     1BD6,W4
02CC8:  MOV     1BD8,W5
02CCA:  MOV     1BDA,W6
02CCC:  MOV     1BDC,W7
02CCE:  CALL    C4A
02CD2:  MOV     W0,W5
02CD4:  MOV     W1,W6
02CD6:  MOV     W2,W7
02CD8:  MOV     W3,W8
02CDA:  BCLR.B  43.0
02CDC:  MOV     W5,[W15++]
02CDE:  MOV     W6,[W15++]
02CE0:  MOV     W7,[W15++]
02CE2:  MOV     W5,W0
02CE4:  MOV     W6,W1
02CE6:  MOV     W7,W2
02CE8:  MOV     W8,W3
02CEA:  MOV     #6D9F,W4
02CEC:  MOV     #C394,W5
02CEE:  MOV     #6D25,W6
02CF0:  MOV     #3E7A,W7
02CF2:  CALL    1C40
02CF6:  MOV     [--W15],W7
02CF8:  MOV     [--W15],W6
02CFA:  MOV     [--W15],W5
02CFC:  MOV     W0,1BE6
02CFE:  MOV     W1,1BE8
02D00:  MOV     W2,1BEA
02D02:  MOV     W3,1BEC
....................    r = r*y + pe_64[4]; 
02D04:  MOV     1BE6,W0
02D06:  MOV     1BE8,W1
02D08:  MOV     1BEA,W2
02D0A:  MOV     1BEC,W3
02D0C:  MOV     1BD6,W4
02D0E:  MOV     1BD8,W5
02D10:  MOV     1BDA,W6
02D12:  MOV     1BDC,W7
02D14:  CALL    C4A
02D18:  MOV     W0,W5
02D1A:  MOV     W1,W6
02D1C:  MOV     W2,W7
02D1E:  MOV     W3,W8
02D20:  BCLR.B  43.0
02D22:  MOV     W5,[W15++]
02D24:  MOV     W6,[W15++]
02D26:  MOV     W7,[W15++]
02D28:  MOV     W5,W0
02D2A:  MOV     W6,W1
02D2C:  MOV     W7,W2
02D2E:  MOV     W8,W3
02D30:  MOV     #32DA,W4
02D32:  MOV     #BE0E,W5
02D34:  MOV     #3E9F,W6
02D36:  MOV     #3EB6,W7
02D38:  CALL    1C40
02D3C:  MOV     [--W15],W7
02D3E:  MOV     [--W15],W6
02D40:  MOV     [--W15],W5
02D42:  MOV     W0,1BE6
02D44:  MOV     W1,1BE8
02D46:  MOV     W2,1BEA
02D48:  MOV     W3,1BEC
....................    r = r*y + pe_64[5]; 
02D4A:  MOV     1BE6,W0
02D4C:  MOV     1BE8,W1
02D4E:  MOV     1BEA,W2
02D50:  MOV     1BEC,W3
02D52:  MOV     1BD6,W4
02D54:  MOV     1BD8,W5
02D56:  MOV     1BDA,W6
02D58:  MOV     1BDC,W7
02D5A:  CALL    C4A
02D5E:  MOV     W0,W5
02D60:  MOV     W1,W6
02D62:  MOV     W2,W7
02D64:  MOV     W3,W8
02D66:  BCLR.B  43.0
02D68:  MOV     W5,[W15++]
02D6A:  MOV     W6,[W15++]
02D6C:  MOV     W7,[W15++]
02D6E:  MOV     W5,W0
02D70:  MOV     W6,W1
02D72:  MOV     W7,W2
02D74:  MOV     W8,W3
02D76:  MOV     #AA6D,W4
02D78:  MOV     #C228,W5
02D7A:  MOV     #FAB4,W6
02D7C:  MOV     #3EEF,W7
02D7E:  CALL    1C40
02D82:  MOV     [--W15],W7
02D84:  MOV     [--W15],W6
02D86:  MOV     [--W15],W5
02D88:  MOV     W0,1BE6
02D8A:  MOV     W1,1BE8
02D8C:  MOV     W2,1BEA
02D8E:  MOV     W3,1BEC
....................    r = r*y + pe_64[6]; 
02D90:  MOV     1BE6,W0
02D92:  MOV     1BE8,W1
02D94:  MOV     1BEA,W2
02D96:  MOV     1BEC,W3
02D98:  MOV     1BD6,W4
02D9A:  MOV     1BD8,W5
02D9C:  MOV     1BDA,W6
02D9E:  MOV     1BDC,W7
02DA0:  CALL    C4A
02DA4:  MOV     W0,W5
02DA6:  MOV     W1,W6
02DA8:  MOV     W2,W7
02DAA:  MOV     W3,W8
02DAC:  BCLR.B  43.0
02DAE:  MOV     W5,[W15++]
02DB0:  MOV     W6,[W15++]
02DB2:  MOV     W7,[W15++]
02DB4:  MOV     W5,W0
02DB6:  MOV     W6,W1
02DB8:  MOV     W7,W2
02DBA:  MOV     W8,W3
02DBC:  MOV     #E089,W4
02DBE:  MOV     #E529,W5
02DC0:  MOV     #30A4,W6
02DC2:  MOV     #3F24,W7
02DC4:  CALL    1C40
02DC8:  MOV     [--W15],W7
02DCA:  MOV     [--W15],W6
02DCC:  MOV     [--W15],W5
02DCE:  MOV     W0,1BE6
02DD0:  MOV     W1,1BE8
02DD2:  MOV     W2,1BEA
02DD4:  MOV     W3,1BEC
....................    r = r*y + pe_64[7]; 
02DD6:  MOV     1BE6,W0
02DD8:  MOV     1BE8,W1
02DDA:  MOV     1BEA,W2
02DDC:  MOV     1BEC,W3
02DDE:  MOV     1BD6,W4
02DE0:  MOV     1BD8,W5
02DE2:  MOV     1BDA,W6
02DE4:  MOV     1BDC,W7
02DE6:  CALL    C4A
02DEA:  MOV     W0,W5
02DEC:  MOV     W1,W6
02DEE:  MOV     W2,W7
02DF0:  MOV     W3,W8
02DF2:  BCLR.B  43.0
02DF4:  MOV     W5,[W15++]
02DF6:  MOV     W6,[W15++]
02DF8:  MOV     W7,[W15++]
02DFA:  MOV     W5,W0
02DFC:  MOV     W6,W1
02DFE:  MOV     W7,W2
02E00:  MOV     W8,W3
02E02:  MOV     #8EA3,W4
02E04:  MOV     #E3FA,W5
02E06:  MOV     #D87E,W6
02E08:  MOV     #3F55,W7
02E0A:  CALL    1C40
02E0E:  MOV     [--W15],W7
02E10:  MOV     [--W15],W6
02E12:  MOV     [--W15],W5
02E14:  MOV     W0,1BE6
02E16:  MOV     W1,1BE8
02E18:  MOV     W2,1BEA
02E1A:  MOV     W3,1BEC
....................    r = r*y + pe_64[8]; 
02E1C:  MOV     1BE6,W0
02E1E:  MOV     1BE8,W1
02E20:  MOV     1BEA,W2
02E22:  MOV     1BEC,W3
02E24:  MOV     1BD6,W4
02E26:  MOV     1BD8,W5
02E28:  MOV     1BDA,W6
02E2A:  MOV     1BDC,W7
02E2C:  CALL    C4A
02E30:  MOV     W0,W5
02E32:  MOV     W1,W6
02E34:  MOV     W2,W7
02E36:  MOV     W3,W8
02E38:  BCLR.B  43.0
02E3A:  MOV     W5,[W15++]
02E3C:  MOV     W6,[W15++]
02E3E:  MOV     W7,[W15++]
02E40:  MOV     W5,W0
02E42:  MOV     W6,W1
02E44:  MOV     W7,W2
02E46:  MOV     W8,W3
02E48:  MOV     #4C6,W4
02E4A:  MOV     #788A,W5
02E4C:  MOV     #B2AB,W6
02E4E:  MOV     #3F83,W7
02E50:  CALL    1C40
02E54:  MOV     [--W15],W7
02E56:  MOV     [--W15],W6
02E58:  MOV     [--W15],W5
02E5A:  MOV     W0,1BE6
02E5C:  MOV     W1,1BE8
02E5E:  MOV     W2,1BEA
02E60:  MOV     W3,1BEC
....................    r = r*y + pe_64[9]; 
02E62:  MOV     1BE6,W0
02E64:  MOV     1BE8,W1
02E66:  MOV     1BEA,W2
02E68:  MOV     1BEC,W3
02E6A:  MOV     1BD6,W4
02E6C:  MOV     1BD8,W5
02E6E:  MOV     1BDA,W6
02E70:  MOV     1BDC,W7
02E72:  CALL    C4A
02E76:  MOV     W0,W5
02E78:  MOV     W1,W6
02E7A:  MOV     W2,W7
02E7C:  MOV     W3,W8
02E7E:  BCLR.B  43.0
02E80:  MOV     W5,[W15++]
02E82:  MOV     W6,[W15++]
02E84:  MOV     W7,[W15++]
02E86:  MOV     W5,W0
02E88:  MOV     W6,W1
02E8A:  MOV     W7,W2
02E8C:  MOV     W8,W3
02E8E:  MOV     #EDCD,W4
02E90:  MOV     #D6A6,W5
02E92:  MOV     #6B08,W6
02E94:  MOV     #3FAC,W7
02E96:  CALL    1C40
02E9A:  MOV     [--W15],W7
02E9C:  MOV     [--W15],W6
02E9E:  MOV     [--W15],W5
02EA0:  MOV     W0,1BE6
02EA2:  MOV     W1,1BE8
02EA4:  MOV     W2,1BEA
02EA6:  MOV     W3,1BEC
....................    r = r*y + pe_64[10]; 
02EA8:  MOV     1BE6,W0
02EAA:  MOV     1BE8,W1
02EAC:  MOV     1BEA,W2
02EAE:  MOV     1BEC,W3
02EB0:  MOV     1BD6,W4
02EB2:  MOV     1BD8,W5
02EB4:  MOV     1BDA,W6
02EB6:  MOV     1BDC,W7
02EB8:  CALL    C4A
02EBC:  MOV     W0,W5
02EBE:  MOV     W1,W6
02EC0:  MOV     W2,W7
02EC2:  MOV     W3,W8
02EC4:  BCLR.B  43.0
02EC6:  MOV     W5,[W15++]
02EC8:  MOV     W6,[W15++]
02ECA:  MOV     W7,[W15++]
02ECC:  MOV     W5,W0
02ECE:  MOV     W6,W1
02ED0:  MOV     W7,W2
02ED2:  MOV     W8,W3
02ED4:  MOV     #D1FD,W4
02ED6:  MOV     #FF84,W5
02ED8:  MOV     #BFBD,W6
02EDA:  MOV     #3FCE,W7
02EDC:  CALL    1C40
02EE0:  MOV     [--W15],W7
02EE2:  MOV     [--W15],W6
02EE4:  MOV     [--W15],W5
02EE6:  MOV     W0,1BE6
02EE8:  MOV     W1,1BE8
02EEA:  MOV     W2,1BEA
02EEC:  MOV     W3,1BEC
....................    r = r*y + pe_64[11]; 
02EEE:  MOV     1BE6,W0
02EF0:  MOV     1BE8,W1
02EF2:  MOV     1BEA,W2
02EF4:  MOV     1BEC,W3
02EF6:  MOV     1BD6,W4
02EF8:  MOV     1BD8,W5
02EFA:  MOV     1BDA,W6
02EFC:  MOV     1BDC,W7
02EFE:  CALL    C4A
02F02:  MOV     W0,W5
02F04:  MOV     W1,W6
02F06:  MOV     W2,W7
02F08:  MOV     W3,W8
02F0A:  BCLR.B  43.0
02F0C:  MOV     W5,[W15++]
02F0E:  MOV     W6,[W15++]
02F10:  MOV     W7,[W15++]
02F12:  MOV     W5,W0
02F14:  MOV     W6,W1
02F16:  MOV     W7,W2
02F18:  MOV     W8,W3
02F1A:  MOV     #35A1,W4
02F1C:  MOV     #FEFA,W5
02F1E:  MOV     #2E42,W6
02F20:  MOV     #3FE6,W7
02F22:  CALL    1C40
02F26:  MOV     [--W15],W7
02F28:  MOV     [--W15],W6
02F2A:  MOV     [--W15],W5
02F2C:  MOV     W0,1BE6
02F2E:  MOV     W1,1BE8
02F30:  MOV     W2,1BEA
02F32:  MOV     W3,1BEC
....................     
....................    res = res*(1.0 + y*r); 
02F34:  MOV     1BD6,W0
02F36:  MOV     1BD8,W1
02F38:  MOV     1BDA,W2
02F3A:  MOV     1BDC,W3
02F3C:  MOV     1BE6,W4
02F3E:  MOV     1BE8,W5
02F40:  MOV     1BEA,W6
02F42:  MOV     1BEC,W7
02F44:  CALL    C4A
02F48:  BCLR.B  43.0
02F4A:  MOV     W0,W4
02F4C:  MOV     W1,W5
02F4E:  MOV     W2,W6
02F50:  MOV     W3,W7
02F52:  MOV     #0,W0
02F54:  MOV     #0,W1
02F56:  MOV     #0,W2
02F58:  MOV     #3FF0,W3
02F5A:  CALL    1C40
02F5E:  MOV     W0,W4
02F60:  MOV     W1,W5
02F62:  MOV     W2,W6
02F64:  MOV     W3,W7
02F66:  MOV     1BDE,W0
02F68:  MOV     1BE0,W1
02F6A:  MOV     1BE2,W2
02F6C:  MOV     1BE4,W3
02F6E:  CALL    C4A
02F72:  MOV     W0,1BDE
02F74:  MOV     W1,1BE0
02F76:  MOV     W2,1BE2
02F78:  MOV     W3,1BE4
....................  
....................    if (s) 
02F7A:  BTSS.B  1BD4.0
02F7C:  BRA     2F9A
....................       res = 1.0/res; 
02F7E:  MOV     #0,W0
02F80:  MOV     #0,W1
02F82:  MOV     #0,W2
02F84:  MOV     #3FF0,W3
02F86:  MOV     1BDE,W4
02F88:  MOV     1BE0,W5
02F8A:  MOV     1BE2,W6
02F8C:  MOV     1BE4,W7
02F8E:  CALL    D5A
02F92:  MOV     W0,1BDE
02F94:  MOV     W1,1BE0
02F96:  MOV     W2,1BE2
02F98:  MOV     W3,1BE4
....................    return(res); 
02F9A:  MOV     1BDE,W0
02F9C:  MOV     1BE0,W1
02F9E:  MOV     1BE2,W2
02FA0:  MOV     1BE4,W3
02FA2:  MOV     [--W15],W8
02FA4:  MOV     [--W15],W7
02FA6:  MOV     [--W15],W6
02FA8:  MOV     [--W15],W5
02FAA:  RETURN  
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
*
02778:  MOV     W5,[W15++]
0277A:  MOV     W6,[W15++]
0277C:  MOV     W7,[W15++]
0277E:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
02780:  PUSH    1BCC
02782:  POP     1BD4
02784:  PUSH    1BCE
02786:  POP     1BD6
02788:  PUSH    1BD0
0278A:  POP     1BD8
0278C:  PUSH    1BD2
0278E:  POP     1BDA
....................  
....................    if (y != 1.0) 
02790:  MOV     1BD4,W0
02792:  MOV     1BD6,W1
02794:  MOV     1BD8,W2
02796:  MOV     1BDA,W3
02798:  MOV     #0,W4
0279A:  MOV     #0,W5
0279C:  MOV     #0,W6
0279E:  MOV     #3FF0,W7
027A0:  CALL    1E2E
027A4:  BRA     Z,2B16
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
027A6:  MOV     #1BDA,W4
027A8:  MOV     W4,1BF8
....................       data1 = *p; 
027AA:  MOV     1BF8,W0
027AC:  MOV     [W0],[W15++]
027AE:  POP     1BF4
....................       data2 = *p; 
027B0:  MOV     1BF8,W0
027B2:  MOV     [W0],[W15++]
027B4:  POP     1BF6
....................       data1 = 0x3FE; 
027B6:  MOV     #3FE,W4
027B8:  MOV     W4,1BF4
....................       data1 = data1 <<4; 
027BA:  MOV     1BF4,W0
027BC:  SL      W0,#4,W0
027BE:  MOV     W0,1BF4
....................       if(bit_test (data2,15)) 
027C0:  BTSS.B  1BF7.7
027C2:  BRA     27C8
....................          bit_set(data1,15); 
027C4:  MOV     #1BF4,W4
027C6:  BSET    [W4].F
....................       data2 = data2 & 0x000F; 
027C8:  MOV     1BF6,W0
027CA:  AND     W0,#F,W0
027CC:  MOV     W0,1BF6
....................       data1 ^=data2; 
027CE:  MOV     1BF6,W0
027D0:  XOR     1BF4
....................  
....................       *p = data1; 
027D2:  MOV     1BF8,W5
027D4:  MOV     1BF4,W4
027D6:  MOV     W4,[W5+#0]
....................  
....................       y = (y - 1.0)/(y + 1.0); 
027D8:  BSET.B  43.0
027DA:  MOV     1BD4,W0
027DC:  MOV     1BD6,W1
027DE:  MOV     1BD8,W2
027E0:  MOV     1BDA,W3
027E2:  MOV     #0,W4
027E4:  MOV     #0,W5
027E6:  MOV     #0,W6
027E8:  MOV     #3FF0,W7
027EA:  CALL    1C40
027EE:  MOV     W0,W5
027F0:  MOV     W1,W6
027F2:  MOV     W2,W7
027F4:  MOV     W3,W8
027F6:  BCLR.B  43.0
027F8:  MOV     W5,[W15++]
027FA:  MOV     W6,[W15++]
027FC:  MOV     W7,[W15++]
027FE:  MOV     1BD4,W0
02800:  MOV     1BD6,W1
02802:  MOV     1BD8,W2
02804:  MOV     1BDA,W3
02806:  MOV     #0,W4
02808:  MOV     #0,W5
0280A:  MOV     #0,W6
0280C:  MOV     #3FF0,W7
0280E:  CALL    1C40
02812:  MOV     [--W15],W7
02814:  MOV     [--W15],W6
02816:  MOV     [--W15],W5
02818:  MOV     W5,[W15++]
0281A:  MOV     W6,[W15++]
0281C:  MOV     W7,[W15++]
0281E:  MOV     W0,W4
02820:  MOV     W5,W0
02822:  MOV     W1,W5
02824:  MOV     W6,W1
02826:  MOV     W2,W6
02828:  MOV     W7,W2
0282A:  MOV     W3,W7
0282C:  MOV     W8,W3
0282E:  CALL    D5A
02832:  MOV     [--W15],W7
02834:  MOV     [--W15],W6
02836:  MOV     [--W15],W5
02838:  MOV     W0,1BD4
0283A:  MOV     W1,1BD6
0283C:  MOV     W2,1BD8
0283E:  MOV     W3,1BDA
....................  
....................       y2=y*y; 
02840:  MOV     1BD4,W0
02842:  MOV     1BD6,W1
02844:  MOV     1BD8,W2
02846:  MOV     1BDA,W3
02848:  MOV     1BD4,W4
0284A:  MOV     1BD6,W5
0284C:  MOV     1BD8,W6
0284E:  MOV     1BDA,W7
02850:  CALL    C4A
02854:  MOV     W0,1BEC
02856:  MOV     W1,1BEE
02858:  MOV     W2,1BF0
0285A:  MOV     W3,1BF2
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
0285C:  MOV     #BD05,W0
0285E:  MOV     #4A9A,W1
02860:  MOV     #A61A,W2
02862:  MOV     #BFC2,W3
02864:  MOV     1BEC,W4
02866:  MOV     1BEE,W5
02868:  MOV     1BF0,W6
0286A:  MOV     1BF2,W7
0286C:  CALL    C4A
02870:  MOV     W0,W5
02872:  MOV     W1,W6
02874:  MOV     W2,W7
02876:  MOV     W3,W8
02878:  BCLR.B  43.0
0287A:  MOV     W5,[W15++]
0287C:  MOV     W6,[W15++]
0287E:  MOV     W7,[W15++]
02880:  MOV     W5,W0
02882:  MOV     W6,W1
02884:  MOV     W7,W2
02886:  MOV     W8,W3
02888:  MOV     #B9B4,W4
0288A:  MOV     #1D2A,W5
0288C:  MOV     #D907,W6
0288E:  MOV     #3FF5,W7
02890:  CALL    1C40
02894:  MOV     [--W15],W7
02896:  MOV     [--W15],W6
02898:  MOV     [--W15],W5
0289A:  MOV     W0,1BDC
0289C:  MOV     W1,1BDE
0289E:  MOV     W2,1BE0
028A0:  MOV     W3,1BE2
....................       res = res*y2 + pl_64[2]; 
028A2:  MOV     1BDC,W0
028A4:  MOV     1BDE,W1
028A6:  MOV     1BE0,W2
028A8:  MOV     1BE2,W3
028AA:  MOV     1BEC,W4
028AC:  MOV     1BEE,W5
028AE:  MOV     1BF0,W6
028B0:  MOV     1BF2,W7
028B2:  CALL    C4A
028B6:  MOV     W0,W5
028B8:  MOV     W1,W6
028BA:  MOV     W2,W7
028BC:  MOV     W3,W8
028BE:  BCLR.B  43.0
028C0:  MOV     W5,[W15++]
028C2:  MOV     W6,[W15++]
028C4:  MOV     W7,[W15++]
028C6:  MOV     W5,W0
028C8:  MOV     W6,W1
028CA:  MOV     W7,W2
028CC:  MOV     W8,W3
028CE:  MOV     #EB02,W4
028D0:  MOV     #6789,W5
028D2:  MOV     #F6DB,W6
028D4:  MOV     #C008,W7
028D6:  CALL    1C40
028DA:  MOV     [--W15],W7
028DC:  MOV     [--W15],W6
028DE:  MOV     [--W15],W5
028E0:  MOV     W0,1BDC
028E2:  MOV     W1,1BDE
028E4:  MOV     W2,1BE0
028E6:  MOV     W3,1BE2
....................       res = res*y2 + pl_64[3]; 
028E8:  MOV     1BDC,W0
028EA:  MOV     1BDE,W1
028EC:  MOV     1BE0,W2
028EE:  MOV     1BE2,W3
028F0:  MOV     1BEC,W4
028F2:  MOV     1BEE,W5
028F4:  MOV     1BF0,W6
028F6:  MOV     1BF2,W7
028F8:  CALL    C4A
028FC:  MOV     W0,W5
028FE:  MOV     W1,W6
02900:  MOV     W2,W7
02902:  MOV     W3,W8
02904:  BCLR.B  43.0
02906:  MOV     W5,[W15++]
02908:  MOV     W6,[W15++]
0290A:  MOV     W7,[W15++]
0290C:  MOV     W5,W0
0290E:  MOV     W6,W1
02910:  MOV     W7,W2
02912:  MOV     W8,W3
02914:  MOV     #0,W4
02916:  MOV     #0,W5
02918:  MOV     #0,W6
0291A:  MOV     #4000,W7
0291C:  CALL    1C40
02920:  MOV     [--W15],W7
02922:  MOV     [--W15],W6
02924:  MOV     [--W15],W5
02926:  MOV     W0,1BDC
02928:  MOV     W1,1BDE
0292A:  MOV     W2,1BE0
0292C:  MOV     W3,1BE2
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
0292E:  MOV     #F22B,W0
02930:  MOV     #8B93,W1
02932:  MOV     #C543,W2
02934:  MOV     #3F78,W3
02936:  MOV     1BEC,W4
02938:  MOV     1BEE,W5
0293A:  MOV     1BF0,W6
0293C:  MOV     1BF2,W7
0293E:  CALL    C4A
02942:  MOV     W0,W5
02944:  MOV     W1,W6
02946:  MOV     W2,W7
02948:  MOV     W3,W8
0294A:  BCLR.B  43.0
0294C:  MOV     W5,[W15++]
0294E:  MOV     W6,[W15++]
02950:  MOV     W7,[W15++]
02952:  MOV     W5,W0
02954:  MOV     W6,W1
02956:  MOV     W7,W2
02958:  MOV     W8,W3
0295A:  MOV     #E04F,W4
0295C:  MOV     #A25D,W5
0295E:  MOV     #A984,W6
02960:  MOV     #BFCA,W7
02962:  CALL    1C40
02966:  MOV     [--W15],W7
02968:  MOV     [--W15],W6
0296A:  MOV     [--W15],W5
0296C:  MOV     W0,1BE4
0296E:  MOV     W1,1BE6
02970:  MOV     W2,1BE8
02972:  MOV     W3,1BEA
....................       r = r*y2 + ql_64[2]; 
02974:  MOV     1BE4,W0
02976:  MOV     1BE6,W1
02978:  MOV     1BE8,W2
0297A:  MOV     1BEA,W3
0297C:  MOV     1BEC,W4
0297E:  MOV     1BEE,W5
02980:  MOV     1BF0,W6
02982:  MOV     1BF2,W7
02984:  CALL    C4A
02988:  MOV     W0,W5
0298A:  MOV     W1,W6
0298C:  MOV     W2,W7
0298E:  MOV     W3,W8
02990:  BCLR.B  43.0
02992:  MOV     W5,[W15++]
02994:  MOV     W6,[W15++]
02996:  MOV     W7,[W15++]
02998:  MOV     W5,W0
0299A:  MOV     W6,W1
0299C:  MOV     W7,W2
0299E:  MOV     W8,W3
029A0:  MOV     #8F38,W4
029A2:  MOV     #EFAC,W5
029A4:  MOV     #D2B5,W6
029A6:  MOV     #3FF1,W7
029A8:  CALL    1C40
029AC:  MOV     [--W15],W7
029AE:  MOV     [--W15],W6
029B0:  MOV     [--W15],W5
029B2:  MOV     W0,1BE4
029B4:  MOV     W1,1BE6
029B6:  MOV     W2,1BE8
029B8:  MOV     W3,1BEA
....................       r = r*y2 + ql_64[3]; 
029BA:  MOV     1BE4,W0
029BC:  MOV     1BE6,W1
029BE:  MOV     1BE8,W2
029C0:  MOV     1BEA,W3
029C2:  MOV     1BEC,W4
029C4:  MOV     1BEE,W5
029C6:  MOV     1BF0,W6
029C8:  MOV     1BF2,W7
029CA:  CALL    C4A
029CE:  MOV     W0,W5
029D0:  MOV     W1,W6
029D2:  MOV     W2,W7
029D4:  MOV     W3,W8
029D6:  BCLR.B  43.0
029D8:  MOV     W5,[W15++]
029DA:  MOV     W6,[W15++]
029DC:  MOV     W7,[W15++]
029DE:  MOV     W5,W0
029E0:  MOV     W6,W1
029E2:  MOV     W7,W2
029E4:  MOV     W8,W3
029E6:  MOV     #3FD8,W4
029E8:  MOV     #BCDF,W5
029EA:  MOV     #4C30,W6
029EC:  MOV     #BFFE,W7
029EE:  CALL    1C40
029F2:  MOV     [--W15],W7
029F4:  MOV     [--W15],W6
029F6:  MOV     [--W15],W5
029F8:  MOV     W0,1BE4
029FA:  MOV     W1,1BE6
029FC:  MOV     W2,1BE8
029FE:  MOV     W3,1BEA
....................       r = r*y2 + 1.0; 
02A00:  MOV     1BE4,W0
02A02:  MOV     1BE6,W1
02A04:  MOV     1BE8,W2
02A06:  MOV     1BEA,W3
02A08:  MOV     1BEC,W4
02A0A:  MOV     1BEE,W5
02A0C:  MOV     1BF0,W6
02A0E:  MOV     1BF2,W7
02A10:  CALL    C4A
02A14:  MOV     W0,W5
02A16:  MOV     W1,W6
02A18:  MOV     W2,W7
02A1A:  MOV     W3,W8
02A1C:  BCLR.B  43.0
02A1E:  MOV     W5,[W15++]
02A20:  MOV     W6,[W15++]
02A22:  MOV     W7,[W15++]
02A24:  MOV     W5,W0
02A26:  MOV     W6,W1
02A28:  MOV     W7,W2
02A2A:  MOV     W8,W3
02A2C:  MOV     #0,W4
02A2E:  MOV     #0,W5
02A30:  MOV     #0,W6
02A32:  MOV     #3FF0,W7
02A34:  CALL    1C40
02A38:  MOV     [--W15],W7
02A3A:  MOV     [--W15],W6
02A3C:  MOV     [--W15],W5
02A3E:  MOV     W0,1BE4
02A40:  MOV     W1,1BE6
02A42:  MOV     W2,1BE8
02A44:  MOV     W3,1BEA
....................  
....................       res = y*res/r; 
02A46:  MOV     1BD4,W0
02A48:  MOV     1BD6,W1
02A4A:  MOV     1BD8,W2
02A4C:  MOV     1BDA,W3
02A4E:  MOV     1BDC,W4
02A50:  MOV     1BDE,W5
02A52:  MOV     1BE0,W6
02A54:  MOV     1BE2,W7
02A56:  CALL    C4A
02A5A:  MOV     W0,W5
02A5C:  MOV     W1,W6
02A5E:  MOV     W2,W7
02A60:  MOV     W3,W8
02A62:  MOV     W5,[W15++]
02A64:  MOV     W6,[W15++]
02A66:  MOV     W7,[W15++]
02A68:  MOV     W5,W0
02A6A:  MOV     W6,W1
02A6C:  MOV     W7,W2
02A6E:  MOV     W8,W3
02A70:  MOV     1BE4,W4
02A72:  MOV     1BE6,W5
02A74:  MOV     1BE8,W6
02A76:  MOV     1BEA,W7
02A78:  CALL    D5A
02A7C:  MOV     [--W15],W7
02A7E:  MOV     [--W15],W6
02A80:  MOV     [--W15],W5
02A82:  MOV     W0,1BDC
02A84:  MOV     W1,1BDE
02A86:  MOV     W2,1BE0
02A88:  MOV     W3,1BE2
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
02A8A:  MOV     #1BD2,W4
02A8C:  MOV     W4,1BF8
....................       data1 = *p; 
02A8E:  MOV     1BF8,W0
02A90:  MOV     [W0],[W15++]
02A92:  POP     1BF4
....................       bit_clear(data1,15); 
02A94:  MOV     #1BF4,W4
02A96:  BCLR    [W4].F
....................       data1 = data1 >>4;     
02A98:  MOV     1BF4,W0
02A9A:  LSR     W0,#4,W0
02A9C:  MOV     W0,1BF4
....................       n = data1 - 0x3FE; 
02A9E:  MOV     1BF4,W4
02AA0:  SUB     #3FE,W4
02AA2:  MOV     W4,1BFA
....................  
....................  
....................       if (n<0) 
02AA4:  MOV     1BFA,W4
02AA6:  CP      W4,#0
02AA8:  BRA     GE,2AC8
....................          r = -(float64)-n; 
02AAA:  MOV     #0,W4
02AAC:  MOV     1BFA,W3
02AAE:  SUB     W4,W3,W0
02AB0:  MOV     #0,W1
02AB2:  MOV     #0,W2
02AB4:  MOV     #0,W3
02AB6:  CALL    1B2C
02ABA:  MOV     W0,1BE4
02ABC:  MOV     W1,1BE6
02ABE:  MOV     W2,1BE8
02AC0:  MOV     W3,1BEA
02AC2:  BTG.B   1BEB.7
02AC4:  GOTO    2AE0
....................       else 
....................          r = (float64)n; 
02AC8:  MOV     1BFA,W0
02ACA:  CLR     W3
02ACC:  BTSC    W0.F
02ACE:  SETM    W3
02AD0:  MOV     W3,W1
02AD2:  MOV     W3,W2
02AD4:  CALL    1B2C
02AD8:  MOV     W0,1BE4
02ADA:  MOV     W1,1BE6
02ADC:  MOV     W2,1BE8
02ADE:  MOV     W3,1BEA
....................  
....................       res += r*LN2; 
02AE0:  MOV     1BE4,W0
02AE2:  MOV     1BE6,W1
02AE4:  MOV     1BE8,W2
02AE6:  MOV     1BEA,W3
02AE8:  MOV     #39EE,W4
02AEA:  MOV     #FEFA,W5
02AEC:  MOV     #2E42,W6
02AEE:  MOV     #3FE6,W7
02AF0:  CALL    C4A
02AF4:  BCLR.B  43.0
02AF6:  MOV     W0,W4
02AF8:  MOV     W1,W5
02AFA:  MOV     W2,W6
02AFC:  MOV     W3,W7
02AFE:  MOV     1BDC,W0
02B00:  MOV     1BDE,W1
02B02:  MOV     1BE0,W2
02B04:  MOV     1BE2,W3
02B06:  CALL    1C40
02B0A:  MOV     W0,1BDC
02B0C:  MOV     W1,1BDE
02B0E:  MOV     W2,1BE0
02B10:  MOV     W3,1BE2
....................    } 
02B12:  GOTO    2B1E
....................  
....................    else 
....................       res = 0.0; 
02B16:  CLR     1BDC
02B18:  CLR     1BDE
02B1A:  CLR     1BE0
02B1C:  CLR     1BE2
....................  
....................    return(res); 
02B1E:  MOV     1BDC,W0
02B20:  MOV     1BDE,W1
02B22:  MOV     1BE0,W2
02B24:  MOV     1BE2,W3
02B26:  MOV     [--W15],W8
02B28:  MOV     [--W15],W7
02B2A:  MOV     [--W15],W6
02B2C:  MOV     [--W15],W5
02B2E:  RETURN  
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } else return 0; 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
*
02FAC:  MOV     W5,[W15++]
02FAE:  MOV     #C,W5
02FB0:  REPEAT  #6
02FB2:  MOV     [W5++],[W15++]
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
02FB4:  MOV     1BB2,W0
02FB6:  MOV     1BB4,W1
02FB8:  MOV     1BB6,W2
02FBA:  MOV     1BB8,W3
02FBC:  MOV     #0,W4
02FBE:  MOV     #0,W5
02FC0:  MOV     #0,W6
02FC2:  MOV     #0,W7
02FC4:  CALL    1E2E
02FC8:  BRA     NC,310C
02FCA:  PUSH    1BBA
02FCC:  POP     1BCC
02FCE:  PUSH    1BBC
02FD0:  POP     1BCE
02FD2:  PUSH    1BBE
02FD4:  POP     1BD0
02FD6:  PUSH    1BC0
02FD8:  POP     1BD2
02FDA:  CLR     1BD4
02FDC:  CLR     1BD6
02FDE:  CLR     1BD8
02FE0:  MOV     #3FF0,W4
02FE2:  MOV     W4,1BDA
02FE4:  CALL    2686
02FE8:  MOV     W0,W9
02FEA:  MOV     W1,W10
02FEC:  MOV     W2,W11
02FEE:  MOV     W3,W12
02FF0:  MOV     W5,[W15++]
02FF2:  MOV     W6,[W15++]
02FF4:  MOV     W7,[W15++]
02FF6:  MOV     W9,W0
02FF8:  MOV     W10,W1
02FFA:  MOV     W11,W2
02FFC:  MOV     W12,W3
02FFE:  MOV     #0,W4
03000:  MOV     #0,W5
03002:  MOV     #0,W6
03004:  MOV     #0,W7
03006:  CALL    1E2E
0300A:  MOV     [--W15],W7
0300C:  MOV     [--W15],W6
0300E:  MOV     [--W15],W5
03010:  BRA     NZ,310C
....................       if(fmod(y, 2) == 0) { 
03012:  PUSH    1BBA
03014:  POP     1BCC
03016:  PUSH    1BBC
03018:  POP     1BCE
0301A:  PUSH    1BBE
0301C:  POP     1BD0
0301E:  PUSH    1BC0
03020:  POP     1BD2
03022:  CLR     1BD4
03024:  CLR     1BD6
03026:  CLR     1BD8
03028:  MOV     #4000,W4
0302A:  MOV     W4,1BDA
0302C:  CALL    2686
03030:  MOV     W0,W9
03032:  MOV     W1,W10
03034:  MOV     W2,W11
03036:  MOV     W3,W12
03038:  MOV     W5,[W15++]
0303A:  MOV     W6,[W15++]
0303C:  MOV     W7,[W15++]
0303E:  MOV     W9,W0
03040:  MOV     W10,W1
03042:  MOV     W11,W2
03044:  MOV     W12,W3
03046:  MOV     #0,W4
03048:  MOV     #0,W5
0304A:  MOV     #0,W6
0304C:  MOV     #0,W7
0304E:  CALL    1E2E
03052:  MOV     [--W15],W7
03054:  MOV     [--W15],W6
03056:  MOV     [--W15],W5
03058:  BRA     NZ,30B2
....................          return (exp(log(-x) * y)); 
0305A:  MOV     1BB2,W5
0305C:  MOV     1BB4,W6
0305E:  MOV     1BB6,W7
03060:  MOV     1BB8,W8
03062:  BTG     W8.F
03064:  MOV     W5,1BCC
03066:  MOV     W6,1BCE
03068:  MOV     W7,1BD0
0306A:  MOV     W8,1BD2
0306C:  CALL    2778
03070:  MOV     W0,W5
03072:  MOV     W1,W6
03074:  MOV     W2,W7
03076:  MOV     W3,W8
03078:  MOV     W5,[W15++]
0307A:  MOV     W6,[W15++]
0307C:  MOV     W7,[W15++]
0307E:  MOV     W5,W0
03080:  MOV     W6,W1
03082:  MOV     W7,W2
03084:  MOV     W8,W3
03086:  MOV     1BBA,W4
03088:  MOV     1BBC,W5
0308A:  MOV     1BBE,W6
0308C:  MOV     1BC0,W7
0308E:  CALL    C4A
03092:  MOV     [--W15],W7
03094:  MOV     [--W15],W6
03096:  MOV     [--W15],W5
03098:  MOV     W0,W5
0309A:  MOV     W1,W6
0309C:  MOV     W2,W7
0309E:  MOV     W3,W8
030A0:  MOV     W5,1BCC
030A2:  MOV     W6,1BCE
030A4:  MOV     W7,1BD0
030A6:  MOV     W8,1BD2
030A8:  CALL    2B30
030AC:  BRA     3206
....................       } else { 
030AE:  GOTO    3108
....................          return (-exp(log(-x) * y)); 
030B2:  MOV     1BB2,W5
030B4:  MOV     1BB4,W6
030B6:  MOV     1BB6,W7
030B8:  MOV     1BB8,W8
030BA:  BTG     W8.F
030BC:  MOV     W5,1BCC
030BE:  MOV     W6,1BCE
030C0:  MOV     W7,1BD0
030C2:  MOV     W8,1BD2
030C4:  CALL    2778
030C8:  MOV     W0,W5
030CA:  MOV     W1,W6
030CC:  MOV     W2,W7
030CE:  MOV     W3,W8
030D0:  MOV     W5,[W15++]
030D2:  MOV     W6,[W15++]
030D4:  MOV     W7,[W15++]
030D6:  MOV     W5,W0
030D8:  MOV     W6,W1
030DA:  MOV     W7,W2
030DC:  MOV     W8,W3
030DE:  MOV     1BBA,W4
030E0:  MOV     1BBC,W5
030E2:  MOV     1BBE,W6
030E4:  MOV     1BC0,W7
030E6:  CALL    C4A
030EA:  MOV     [--W15],W7
030EC:  MOV     [--W15],W6
030EE:  MOV     [--W15],W5
030F0:  MOV     W0,W5
030F2:  MOV     W1,W6
030F4:  MOV     W2,W7
030F6:  MOV     W3,W8
030F8:  MOV     W5,1BCC
030FA:  MOV     W6,1BCE
030FC:  MOV     W7,1BD0
030FE:  MOV     W8,1BD2
03100:  CALL    2B30
03104:  BTG     W3.F
03106:  BRA     3206
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
03108:  GOTO    3206
0310C:  MOV     1BB2,W0
0310E:  MOV     1BB4,W1
03110:  MOV     1BB6,W2
03112:  MOV     1BB8,W3
03114:  MOV     #0,W4
03116:  MOV     #0,W5
03118:  MOV     #0,W6
0311A:  MOV     #0,W7
0311C:  CALL    1E2E
03120:  BRA     NC,3178
03122:  PUSH    1BBA
03124:  POP     1BCC
03126:  PUSH    1BBC
03128:  POP     1BCE
0312A:  PUSH    1BBE
0312C:  POP     1BD0
0312E:  PUSH    1BC0
03130:  POP     1BD2
03132:  CLR     1BD4
03134:  CLR     1BD6
03136:  CLR     1BD8
03138:  MOV     #3FF0,W4
0313A:  MOV     W4,1BDA
0313C:  CALL    2686
03140:  MOV     W0,W9
03142:  MOV     W1,W10
03144:  MOV     W2,W11
03146:  MOV     W3,W12
03148:  MOV     W5,[W15++]
0314A:  MOV     W6,[W15++]
0314C:  MOV     W7,[W15++]
0314E:  MOV     W9,W0
03150:  MOV     W10,W1
03152:  MOV     W11,W2
03154:  MOV     W12,W3
03156:  MOV     #0,W4
03158:  MOV     #0,W5
0315A:  MOV     #0,W6
0315C:  MOV     #0,W7
0315E:  CALL    1E2E
03162:  MOV     [--W15],W7
03164:  MOV     [--W15],W6
03166:  MOV     [--W15],W5
03168:  BRA     Z,3178
....................       return 0; 
0316A:  MOV     #0,W0
0316C:  MOV     #0,W1
0316E:  MOV     #0,W2
03170:  MOV     #0,W3
03172:  BRA     3206
....................    } else { 
03174:  GOTO    3206
....................       if(x != 0 || 0 >= y) { 
03178:  MOV     1BB2,W0
0317A:  MOV     1BB4,W1
0317C:  MOV     1BB6,W2
0317E:  MOV     1BB8,W3
03180:  MOV     #0,W4
03182:  MOV     #0,W5
03184:  MOV     #0,W6
03186:  MOV     #0,W7
03188:  CALL    1E2E
0318C:  BRA     NZ,31A6
0318E:  MOV     1BBA,W0
03190:  MOV     1BBC,W1
03192:  MOV     1BBE,W2
03194:  MOV     1BC0,W3
03196:  MOV     #0,W4
03198:  MOV     #0,W5
0319A:  MOV     #0,W6
0319C:  MOV     #0,W7
0319E:  CALL    1E2E
031A2:  BRA     C,31A6
031A4:  BRA     NZ,31FC
....................          return (exp(log(x) * y)); 
031A6:  PUSH    1BB2
031A8:  POP     1BCC
031AA:  PUSH    1BB4
031AC:  POP     1BCE
031AE:  PUSH    1BB6
031B0:  POP     1BD0
031B2:  PUSH    1BB8
031B4:  POP     1BD2
031B6:  CALL    2778
031BA:  MOV     W0,W5
031BC:  MOV     W1,W6
031BE:  MOV     W2,W7
031C0:  MOV     W3,W8
031C2:  MOV     W5,[W15++]
031C4:  MOV     W6,[W15++]
031C6:  MOV     W7,[W15++]
031C8:  MOV     W5,W0
031CA:  MOV     W6,W1
031CC:  MOV     W7,W2
031CE:  MOV     W8,W3
031D0:  MOV     1BBA,W4
031D2:  MOV     1BBC,W5
031D4:  MOV     1BBE,W6
031D6:  MOV     1BC0,W7
031D8:  CALL    C4A
031DC:  MOV     [--W15],W7
031DE:  MOV     [--W15],W6
031E0:  MOV     [--W15],W5
031E2:  MOV     W0,W5
031E4:  MOV     W1,W6
031E6:  MOV     W2,W7
031E8:  MOV     W3,W8
031EA:  MOV     W5,1BCC
031EC:  MOV     W6,1BCE
031EE:  MOV     W7,1BD0
031F0:  MOV     W8,1BD2
031F2:  CALL    2B30
031F6:  BRA     3206
....................       } else return 0; 
031F8:  GOTO    3206
031FC:  MOV     #0,W0
031FE:  MOV     #0,W1
03200:  MOV     #0,W2
03202:  MOV     #0,W3
03204:  BRA     3206
....................    } 
03206:  MOV     #18,W5
03208:  REPEAT  #6
0320A:  MOV     [--W15],[W5--]
0320C:  MOV     [--W15],W5
0320E:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
*
083DE:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
083E0:  MOV     1B54,W0
083E2:  MOV     1B56,W1
083E4:  MOV     #0,W2
083E6:  MOV     #0,W3
083E8:  CALL    6890
083EC:  BRA     C,83F0
083EE:  BRA     NZ,83F6
....................       return(0.0); 
083F0:  MOV     #0,W0
083F2:  MOV     #0,W1
083F4:  BRA     84BA
....................  
....................    y=x; 
083F6:  PUSH    1B54
083F8:  POP     1B58
083FA:  PUSH    1B56
083FC:  POP     1B5A
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
083FE:  MOV     #1B5B,W4
08400:  MOV     W4,1B64
....................     data1 = *(((unsigned int8 *)(&y))+3); 
08402:  MOV     #1B5B,W0
08404:  MOV     1B60,W4
08406:  MOV.B   [W0+#0],W4L
08408:  MOV     W4,1B60
0840A:  CLR.B   1B61
....................     data2 = *(((unsigned int8 *)(&y))+2); 
0840C:  MOV     #1B5A,W0
0840E:  MOV     1B62,W4
08410:  MOV.B   [W0+#0],W4L
08412:  MOV     W4,1B62
08414:  CLR.B   1B63
....................     rotate_left(&data1,1);     
08416:  MOV     #1B60,W1
08418:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
0841A:  BTSS.B  1B62.7
0841C:  BRA     8422
....................        bit_set(data1,0);     
0841E:  MOV     #1B60,W4
08420:  BSET    [W4].0
....................     data1 = ((data1+127) >>1); 
08422:  MOV     #7F,W4
08424:  MOV     1B60,W3
08426:  ADD     W3,W4,W5
08428:  MOV     W5,1B60
0842A:  LSR     1B60
....................     bit_clear(data2,7); 
0842C:  MOV     #1B62,W4
0842E:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
08430:  BTSS.B  1B60.0
08432:  BRA     8438
....................        bit_set(data2,7); 
08434:  MOV     #1B62,W4
08436:  BSET    [W4].7
....................     data1 = data1 >>1; 
08438:  LSR     1B60
....................     *(((unsigned int8 *)(&y))+3) = data1; 
0843A:  MOV     #1B5B,W5
0843C:  MOV     1B60,W0
0843E:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
08440:  MOV     #1B5A,W5
08442:  MOV     1B62,W0
08444:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
08446:  PUSH    1B58
08448:  POP     1B5C
0844A:  PUSH    1B5A
0844C:  POP     1B5E
....................       y+=(x/y); 
0844E:  MOV     1B54,W0
08450:  MOV     1B56,W1
08452:  MOV     1B58,W2
08454:  MOV     1B5A,W3
08456:  CALL    8314
0845A:  BCLR.B  43.0
0845C:  MOV     W0,W2
0845E:  MOV     W1,W3
08460:  MOV     1B58,W0
08462:  MOV     1B5A,W1
08464:  CALL    6A22
08468:  MOV     W0,1B58
0846A:  MOV     W1,1B5A
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
0846C:  MOV     #1B5B,W0
0846E:  MOV     1B60,W4
08470:  MOV.B   [W0+#0],W4L
08472:  MOV     W4,1B60
08474:  CLR.B   1B61
....................     data2 = *(((unsigned int8 *)(&y))+2); 
08476:  MOV     #1B5A,W0
08478:  MOV     1B62,W4
0847A:  MOV.B   [W0+#0],W4L
0847C:  MOV     W4,1B62
0847E:  CLR.B   1B63
....................     rotate_left(&data1,1); 
08480:  MOV     #1B60,W1
08482:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
08484:  BTSS.B  1B62.7
08486:  BRA     848C
....................        bit_set(data1,0);     
08488:  MOV     #1B60,W4
0848A:  BSET    [W4].0
....................     data1--; 
0848C:  DEC     1B60
....................     bit_clear(data2,7); 
0848E:  MOV     #1B62,W4
08490:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
08492:  BTSS.B  1B60.0
08494:  BRA     849A
....................        bit_set(data2,7); 
08496:  MOV     #1B62,W4
08498:  BSET    [W4].7
....................     data1 = data1 >>1; 
0849A:  LSR     1B60
....................     *(((unsigned int8 *)(&y))+3) = data1; 
0849C:  MOV     #1B5B,W5
0849E:  MOV     1B60,W0
084A0:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
084A2:  MOV     #1B5A,W5
084A4:  MOV     1B62,W0
084A6:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
084A8:  MOV     1B5C,W0
084AA:  MOV     1B5E,W1
084AC:  MOV     1B58,W2
084AE:  MOV     1B5A,W3
084B0:  CALL    6890
084B4:  BRA     NZ,8446
....................  
....................    return(res); 
084B6:  MOV     1B5C,W0
084B8:  MOV     1B5E,W1
084BA:  MOV     [--W15],W5
084BC:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
*
03210:  MOV     W5,[W15++]
03212:  MOV     W6,[W15++]
03214:  MOV     W7,[W15++]
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
03216:  MOV     1BCA,W0
03218:  MOV     1BCC,W1
0321A:  MOV     1BCE,W2
0321C:  MOV     1BD0,W3
0321E:  MOV     #0,W4
03220:  MOV     #0,W5
03222:  MOV     #0,W6
03224:  MOV     #0,W7
03226:  CALL    1E2E
0322A:  BRA     C,322E
0322C:  BRA     NZ,3238
....................       return(0.0); 
0322E:  MOV     #0,W0
03230:  MOV     #0,W1
03232:  MOV     #0,W2
03234:  MOV     #0,W3
03236:  BRA     3324
....................  
....................    y=x; 
03238:  PUSH    1BCA
0323A:  POP     1BD2
0323C:  PUSH    1BCC
0323E:  POP     1BD4
03240:  PUSH    1BCE
03242:  POP     1BD6
03244:  PUSH    1BD0
03246:  POP     1BD8
....................    p= (((unsigned int16 *)(&y))+3); 
03248:  MOV     #1BD8,W4
0324A:  MOV     W4,1BE2
....................    temp1 = *p; 
0324C:  MOV     1BE2,W0
0324E:  MOV     [W0],[W15++]
03250:  POP     1BE4
....................    temp2 = *p; 
03252:  MOV     1BE2,W0
03254:  MOV     [W0],[W15++]
03256:  POP     1BE6
....................    bit_clear(temp1,15); 
03258:  MOV     #1BE4,W4
0325A:  BCLR    [W4].F
....................    temp1 = (temp1>>4)+1023; 
0325C:  MOV     1BE4,W5
0325E:  LSR     W5,#4,W5
03260:  MOV     #3FF,W4
03262:  ADD     W5,W4,W0
03264:  MOV     W0,1BE4
....................    temp1 = temp1 >> 1; 
03266:  LSR     1BE4
....................    temp1 = (temp1<<4) & 0xFFF0; 
03268:  MOV     1BE4,W5
0326A:  SL      W5,#4,W5
0326C:  MOV     #FFF0,W0
0326E:  AND     W0,W5,W0
03270:  MOV     W0,1BE4
....................    if(bit_test(temp2,15)) 
03272:  BTSS.B  1BE7.7
03274:  BRA     327A
....................       bit_set(temp1,15); 
03276:  MOV     #1BE4,W4
03278:  BSET    [W4].F
....................    temp2 = temp2 & 0x000F; 
0327A:  MOV     1BE6,W0
0327C:  AND     W0,#F,W0
0327E:  MOV     W0,1BE6
....................    temp1 ^= temp2; 
03280:  MOV     1BE6,W0
03282:  XOR     1BE4
....................     
....................    (*p) = temp1; 
03284:  MOV     1BE2,W5
03286:  MOV     1BE4,W4
03288:  MOV     W4,[W5+#0]
....................     
....................    do { 
....................       res=y; 
0328A:  PUSH    1BD2
0328C:  POP     1BDA
0328E:  PUSH    1BD4
03290:  POP     1BDC
03292:  PUSH    1BD6
03294:  POP     1BDE
03296:  PUSH    1BD8
03298:  POP     1BE0
....................       y+=(x/y); 
0329A:  MOV     1BCA,W0
0329C:  MOV     1BCC,W1
0329E:  MOV     1BCE,W2
032A0:  MOV     1BD0,W3
032A2:  MOV     1BD2,W4
032A4:  MOV     1BD4,W5
032A6:  MOV     1BD6,W6
032A8:  MOV     1BD8,W7
032AA:  CALL    D5A
032AE:  BCLR.B  43.0
032B0:  MOV     W0,W4
032B2:  MOV     W1,W5
032B4:  MOV     W2,W6
032B6:  MOV     W3,W7
032B8:  MOV     1BD2,W0
032BA:  MOV     1BD4,W1
032BC:  MOV     1BD6,W2
032BE:  MOV     1BD8,W3
032C0:  CALL    1C40
032C4:  MOV     W0,1BD2
032C6:  MOV     W1,1BD4
032C8:  MOV     W2,1BD6
032CA:  MOV     W3,1BD8
....................      temp1 = *p; 
032CC:  MOV     1BE2,W0
032CE:  MOV     [W0],[W15++]
032D0:  POP     1BE4
....................      temp2 = *p; 
032D2:  MOV     1BE2,W0
032D4:  MOV     [W0],[W15++]
032D6:  POP     1BE6
....................      bit_clear(temp1,15); 
032D8:  MOV     #1BE4,W4
032DA:  BCLR    [W4].F
....................      temp1 = (temp1>>4); 
032DC:  MOV     1BE4,W0
032DE:  LSR     W0,#4,W0
032E0:  MOV     W0,1BE4
....................      temp1--; 
032E2:  DEC     1BE4
....................      temp1 = (temp1<<4) & 0xFFF0; 
032E4:  MOV     1BE4,W5
032E6:  SL      W5,#4,W5
032E8:  MOV     #FFF0,W0
032EA:  AND     W0,W5,W0
032EC:  MOV     W0,1BE4
....................      if(bit_test(temp2,15)) 
032EE:  BTSS.B  1BE7.7
032F0:  BRA     32F6
....................         bit_set(temp1,15); 
032F2:  MOV     #1BE4,W4
032F4:  BSET    [W4].F
....................      temp2 = temp2 & 0x000F; 
032F6:  MOV     1BE6,W0
032F8:  AND     W0,#F,W0
032FA:  MOV     W0,1BE6
....................      temp1 ^= temp2; 
032FC:  MOV     1BE6,W0
032FE:  XOR     1BE4
....................      (*p) = temp1; 
03300:  MOV     1BE2,W5
03302:  MOV     1BE4,W4
03304:  MOV     W4,[W5+#0]
....................  
....................    } while(res != y); 
03306:  MOV     1BDA,W0
03308:  MOV     1BDC,W1
0330A:  MOV     1BDE,W2
0330C:  MOV     1BE0,W3
0330E:  MOV     1BD2,W4
03310:  MOV     1BD4,W5
03312:  MOV     1BD6,W6
03314:  MOV     1BD8,W7
03316:  CALL    1E2E
0331A:  BRA     NZ,328A
....................  
....................    return(res); 
0331C:  MOV     1BDA,W0
0331E:  MOV     1BDC,W1
03320:  MOV     1BDE,W2
03322:  MOV     1BE0,W3
03324:  MOV     [--W15],W7
03326:  MOV     [--W15],W6
03328:  MOV     [--W15],W5
0332A:  RETURN  
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
*
0877E:  MOV     W5,[W15++]
08780:  MOV     W6,[W15++]
08782:  MOV     W7,[W15++]
08784:  MOV     W8,[W15++]
08786:  CLR     1B7C
08788:  CLR     1B7E
0878A:  CLR     1B80
0878C:  MOV     #3FF0,W4
0878E:  MOV     W4,1B82
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
08790:  MOV     #FF1F,W4
08792:  MOV     W4,1B8C
08794:  SETM    1B8E
08796:  SETM    1B90
08798:  MOV     #BFDF,W4
0879A:  MOV     W4,1B92
0879C:  MOV     #1C35,W4
0879E:  MOV     W4,1B94
087A0:  MOV     #5555,W4
087A2:  MOV     W4,1B96
087A4:  MOV     #5555,W4
087A6:  MOV     W4,1B98
087A8:  MOV     #3FA5,W4
087AA:  MOV     W4,1B9A
087AC:  MOV     #3F1C,W4
087AE:  MOV     W4,1B9C
087B0:  MOV     #16A7,W4
087B2:  MOV     W4,1B9E
087B4:  MOV     #C16C,W4
087B6:  MOV     W4,1BA0
087B8:  MOV     #BF56,W4
087BA:  MOV     W4,1BA2
087BC:  MOV     #F3E6,W4
087BE:  MOV     W4,1BA4
087C0:  MOV     #D65,W4
087C2:  MOV     W4,1BA6
087C4:  MOV     #1A0,W4
087C6:  MOV     W4,1BA8
087C8:  MOV     #3EFA,W4
087CA:  MOV     W4,1BAA
087CC:  MOV     #A3E,W4
087CE:  MOV     W4,1BAC
087D0:  MOV     #3931,W4
087D2:  MOV     W4,1BAE
087D4:  MOV     #7E4C,W4
087D6:  MOV     W4,1BB0
087D8:  MOV     #BE92,W4
087DA:  MOV     W4,1BB2
087DC:  MOV     #DDFB,W4
087DE:  MOV     W4,1BB4
087E0:  MOV     #2B77,W4
087E2:  MOV     W4,1BB6
087E4:  MOV     #EDB1,W4
087E6:  MOV     W4,1BB8
087E8:  MOV     #3E21,W4
087EA:  MOV     W4,1BBA
087EC:  MOV     #6FCC,W4
087EE:  MOV     W4,1BBC
087F0:  MOV     #8FF7,W4
087F2:  MOV     W4,1BBE
087F4:  MOV     #C610,W4
087F6:  MOV     W4,1BC0
087F8:  MOV     #BDA8,W4
087FA:  MOV     W4,1BC2
087FC:  MOV     #124C,W4
087FE:  MOV     W4,1BC4
08800:  MOV     #8E1C,W4
08802:  MOV     W4,1BC6
08804:  MOV     #3AF9,W4
08806:  MOV     W4,1BC8
08808:  MOV     #3CF3,W4
0880A:  MOV     W4,1BCA
0880C:  MOV     #7676,W4
0880E:  MOV     W4,1BCC
08810:  MOV     #350F,W4
08812:  MOV     W4,1BCE
08814:  MOV     #C0DE,W4
08816:  MOV     W4,1BD0
08818:  MOV     #3CF0,W4
0881A:  MOV     W4,1BD2
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0881C:  MOV     1B62,W0
0881E:  MOV     1B64,W1
08820:  MOV     1B66,W2
08822:  MOV     1B68,W3
08824:  MOV     #0,W4
08826:  MOV     #0,W5
08828:  MOV     #0,W6
0882A:  MOV     #0,W7
0882C:  CALL    1E2E
08830:  BRA     NC,883C
08832:  MOV     #1B62,W0
08834:  MOV     #1B62,W1
08836:  REPEAT  #7
08838:  MOV     [W0++],[W1++]
0883A:  BTG.B   1B69.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
0883C:  MOV     1B62,W0
0883E:  MOV     1B64,W1
08840:  MOV     1B66,W2
08842:  MOV     1B68,W3
08844:  MOV     #C884,W4
08846:  MOV     #6DC9,W5
08848:  MOV     #5F30,W6
0884A:  MOV     #3FE4,W7
0884C:  CALL    C4A
08850:  CALL    2316
08854:  MOV.B   W0L,1B6A
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
08856:  MOV     1B62,W0
08858:  MOV     1B64,W1
0885A:  MOV     1B66,W2
0885C:  MOV     1B68,W3
0885E:  MOV     #C884,W4
08860:  MOV     #6DC9,W5
08862:  MOV     #5F30,W6
08864:  MOV     #3FE4,W7
08866:  CALL    C4A
0886A:  MOV     W0,W5
0886C:  MOV     W1,W6
0886E:  MOV     W2,W7
08870:  MOV     W3,W8
08872:  MOV     #0,W1
08874:  MOV     #0,W2
08876:  MOV     #0,W3
08878:  MOV.B   1B6A,W0L
0887A:  CLR.B   1
0887C:  CALL    2374
08880:  BSET.B  43.0
08882:  MOV     W5,[W15++]
08884:  MOV     W6,[W15++]
08886:  MOV     W7,[W15++]
08888:  MOV     W0,W4
0888A:  MOV     W5,W0
0888C:  MOV     W1,W5
0888E:  MOV     W6,W1
08890:  MOV     W2,W6
08892:  MOV     W7,W2
08894:  MOV     W3,W7
08896:  MOV     W8,W3
08898:  CALL    1C40
0889C:  MOV     [--W15],W7
0889E:  MOV     [--W15],W6
088A0:  MOV     [--W15],W5
088A2:  MOV     W0,1B84
088A4:  MOV     W1,1B86
088A6:  MOV     W2,1B88
088A8:  MOV     W3,1B8A
....................    quad = quad % 4;                    // quadrant (0 to 3) 
088AA:  MOV.B   1B6A,W0L
088AC:  AND.B   W0L,#3,W0L
088AE:  MOV.B   W0L,1B6A
....................  
....................    if (quad == 0 || quad == 2) 
088B0:  CP0.B   1B6A
088B2:  BRA     Z,88BA
088B4:  MOV     1B6A,W4
088B6:  CP.B    W4L,#2
088B8:  BRA     NZ,88DA
....................       t = frac * PI_DIV_BY_TWO; 
088BA:  MOV     1B84,W0
088BC:  MOV     1B86,W1
088BE:  MOV     1B88,W2
088C0:  MOV     1B8A,W3
088C2:  MOV     #2D18,W4
088C4:  MOV     #5444,W5
088C6:  MOV     #21FB,W6
088C8:  MOV     #3FF9,W7
088CA:  CALL    C4A
088CE:  MOV     W0,1B74
088D0:  MOV     W1,1B76
088D2:  MOV     W2,1B78
088D4:  MOV     W3,1B7A
088D6:  GOTO    8970
....................    else if (quad == 1) 
088DA:  MOV     1B6A,W4
088DC:  CP.B    W4L,#1
088DE:  BRA     NZ,892A
....................       t = (1-frac) * PI_DIV_BY_TWO; 
088E0:  BSET.B  43.0
088E2:  MOV     #0,W0
088E4:  MOV     #0,W1
088E6:  MOV     #0,W2
088E8:  MOV     #3FF0,W3
088EA:  MOV     1B84,W4
088EC:  MOV     1B86,W5
088EE:  MOV     1B88,W6
088F0:  MOV     1B8A,W7
088F2:  CALL    1C40
088F6:  MOV     W0,W5
088F8:  MOV     W1,W6
088FA:  MOV     W2,W7
088FC:  MOV     W3,W8
088FE:  MOV     W5,[W15++]
08900:  MOV     W6,[W15++]
08902:  MOV     W7,[W15++]
08904:  MOV     W5,W0
08906:  MOV     W6,W1
08908:  MOV     W7,W2
0890A:  MOV     W8,W3
0890C:  MOV     #2D18,W4
0890E:  MOV     #5444,W5
08910:  MOV     #21FB,W6
08912:  MOV     #3FF9,W7
08914:  CALL    C4A
08918:  MOV     [--W15],W7
0891A:  MOV     [--W15],W6
0891C:  MOV     [--W15],W5
0891E:  MOV     W0,1B74
08920:  MOV     W1,1B76
08922:  MOV     W2,1B78
08924:  MOV     W3,1B7A
08926:  GOTO    8970
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0892A:  BSET.B  43.0
0892C:  MOV     1B84,W0
0892E:  MOV     1B86,W1
08930:  MOV     1B88,W2
08932:  MOV     1B8A,W3
08934:  MOV     #0,W4
08936:  MOV     #0,W5
08938:  MOV     #0,W6
0893A:  MOV     #3FF0,W7
0893C:  CALL    1C40
08940:  MOV     W0,W5
08942:  MOV     W1,W6
08944:  MOV     W2,W7
08946:  MOV     W3,W8
08948:  MOV     W5,[W15++]
0894A:  MOV     W6,[W15++]
0894C:  MOV     W7,[W15++]
0894E:  MOV     W5,W0
08950:  MOV     W6,W1
08952:  MOV     W7,W2
08954:  MOV     W8,W3
08956:  MOV     #2D18,W4
08958:  MOV     #5444,W5
0895A:  MOV     #21FB,W6
0895C:  MOV     #3FF9,W7
0895E:  CALL    C4A
08962:  MOV     [--W15],W7
08964:  MOV     [--W15],W6
08966:  MOV     [--W15],W5
08968:  MOV     W0,1B74
0896A:  MOV     W1,1B76
0896C:  MOV     W2,1B78
0896E:  MOV     W3,1B7A
....................  
....................    y = 1.0; 
08970:  CLR     1B6C
08972:  CLR     1B6E
08974:  CLR     1B70
08976:  MOV     #3FF0,W4
08978:  MOV     W4,1B72
....................    t = t * t; 
0897A:  MOV     1B74,W0
0897C:  MOV     1B76,W1
0897E:  MOV     1B78,W2
08980:  MOV     1B7A,W3
08982:  MOV     1B74,W4
08984:  MOV     1B76,W5
08986:  MOV     1B78,W6
08988:  MOV     1B7A,W7
0898A:  CALL    C4A
0898E:  MOV     W0,1B74
08990:  MOV     W1,1B76
08992:  MOV     W2,1B78
08994:  MOV     W3,1B7A
....................    for (i = 0; i <= 8; i++) 
08996:  CLR.B   1B6B
08998:  MOV     1B6A,W4
0899A:  LSR     W4,#8,W4
0899C:  CP.B    W4L,#8
0899E:  BRA     GTU,8A10
....................    { 
....................       t2 = t2 * t; 
089A0:  MOV     1B7C,W0
089A2:  MOV     1B7E,W1
089A4:  MOV     1B80,W2
089A6:  MOV     1B82,W3
089A8:  MOV     1B74,W4
089AA:  MOV     1B76,W5
089AC:  MOV     1B78,W6
089AE:  MOV     1B7A,W7
089B0:  CALL    C4A
089B4:  MOV     W0,1B7C
089B6:  MOV     W1,1B7E
089B8:  MOV     W2,1B80
089BA:  MOV     W3,1B82
....................       y = y + p_64[i] * t2; 
089BC:  MOV.B   1B6B,W0L
089BE:  CLR.B   1
089C0:  SL      W0,#3,W0
089C2:  MOV     #1B8C,W4
089C4:  ADD     W0,W4,W0
089C6:  MOV     #A,W4
089C8:  REPEAT  #3
089CA:  MOV     [W0++],[W4++]
089CC:  MOV     W5,[W15++]
089CE:  MOV     W6,[W15++]
089D0:  MOV     W7,[W15++]
089D2:  MOV     W5,W0
089D4:  MOV     W6,W1
089D6:  MOV     W7,W2
089D8:  MOV     W8,W3
089DA:  MOV     1B7C,W4
089DC:  MOV     1B7E,W5
089DE:  MOV     1B80,W6
089E0:  MOV     1B82,W7
089E2:  CALL    C4A
089E6:  MOV     [--W15],W7
089E8:  MOV     [--W15],W6
089EA:  MOV     [--W15],W5
089EC:  BCLR.B  43.0
089EE:  MOV     W0,W4
089F0:  MOV     W1,W5
089F2:  MOV     W2,W6
089F4:  MOV     W3,W7
089F6:  MOV     1B6C,W0
089F8:  MOV     1B6E,W1
089FA:  MOV     1B70,W2
089FC:  MOV     1B72,W3
089FE:  CALL    1C40
08A02:  MOV     W0,1B6C
08A04:  MOV     W1,1B6E
08A06:  MOV     W2,1B70
08A08:  MOV     W3,1B72
08A0A:  INC.B   1B6B
08A0C:  GOTO    8998
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
08A10:  MOV     1B6A,W4
08A12:  CP.B    W4L,#2
08A14:  BRA     Z,8A1C
08A16:  MOV     1B6A,W4
08A18:  CP.B    W4L,#1
08A1A:  BRA     NZ,8A26
....................       y = -y;  // correct sign 
08A1C:  MOV     #1B6C,W0
08A1E:  MOV     #1B6C,W1
08A20:  REPEAT  #7
08A22:  MOV     [W0++],[W1++]
08A24:  BTG.B   1B73.7
....................  
....................    return (y); 
08A26:  MOV     1B6C,W0
08A28:  MOV     1B6E,W1
08A2A:  MOV     1B70,W2
08A2C:  MOV     1B72,W3
08A2E:  MOV     [--W15],W8
08A30:  MOV     [--W15],W7
08A32:  MOV     [--W15],W6
08A34:  MOV     [--W15],W5
08A36:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
08A38:  MOV     W5,[W15++]
08A3A:  MOV     W6,[W15++]
08A3C:  MOV     W7,[W15++]
08A3E:  MOV     W8,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
08A40:  BSET.B  43.0
08A42:  MOV     1B50,W0
08A44:  MOV     1B52,W1
08A46:  MOV     1B54,W2
08A48:  MOV     1B56,W3
08A4A:  MOV     #2D18,W4
08A4C:  MOV     #5444,W5
08A4E:  MOV     #21FB,W6
08A50:  MOV     #3FF9,W7
08A52:  CALL    1C40
08A56:  MOV     W0,W5
08A58:  MOV     W1,W6
08A5A:  MOV     W2,W7
08A5C:  MOV     W3,W8
08A5E:  MOV     W5,1B62
08A60:  MOV     W6,1B64
08A62:  MOV     W7,1B66
08A64:  MOV     W8,1B68
08A66:  CALL    877E
08A6A:  MOV     [--W15],W8
08A6C:  MOV     [--W15],W7
08A6E:  MOV     [--W15],W6
08A70:  MOV     [--W15],W5
08A72:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
*
07350:  MOV     W5,[W15++]
07352:  MOV     W6,[W15++]
07354:  MOV     W7,[W15++]
07356:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
07358:  BCLR.B  1B9F.0
....................    y = x; 
0735A:  PUSH    1B96
0735C:  POP     1BA0
0735E:  PUSH    1B98
07360:  POP     1BA2
07362:  PUSH    1B9A
07364:  POP     1BA4
07366:  PUSH    1B9C
07368:  POP     1BA6
....................  
....................    if (x < 0) 
0736A:  MOV     1B96,W0
0736C:  MOV     1B98,W1
0736E:  MOV     1B9A,W2
07370:  MOV     1B9C,W3
07372:  MOV     #0,W4
07374:  MOV     #0,W5
07376:  MOV     #0,W6
07378:  MOV     #0,W7
0737A:  CALL    1E2E
0737E:  BRA     NC,738C
....................    { 
....................       s = 1; 
07380:  BSET.B  1B9F.0
....................       y = -y; 
07382:  MOV     #1BA0,W0
07384:  MOV     #1BA0,W1
07386:  REPEAT  #7
07388:  MOV     [W0++],[W1++]
0738A:  BTG.B   1BA7.7
....................    } 
....................  
....................    if (y > 0.5) 
0738C:  MOV     #0,W0
0738E:  MOV     #0,W1
07390:  MOV     #0,W2
07392:  MOV     #3FE0,W3
07394:  MOV     1BA0,W4
07396:  MOV     1BA2,W5
07398:  MOV     1BA4,W6
0739A:  MOV     1BA6,W7
0739C:  CALL    1E2E
073A0:  BRA     NC,7402
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
073A2:  BSET.B  43.0
073A4:  MOV     #0,W0
073A6:  MOV     #0,W1
073A8:  MOV     #0,W2
073AA:  MOV     #3FF0,W3
073AC:  MOV     1BA0,W4
073AE:  MOV     1BA2,W5
073B0:  MOV     1BA4,W6
073B2:  MOV     1BA6,W7
073B4:  CALL    1C40
073B8:  MOV     W0,W5
073BA:  MOV     W1,W6
073BC:  MOV     W2,W7
073BE:  MOV     W3,W8
073C0:  MOV     W5,[W15++]
073C2:  MOV     W6,[W15++]
073C4:  MOV     W7,[W15++]
073C6:  MOV     W5,W0
073C8:  MOV     W6,W1
073CA:  MOV     W7,W2
073CC:  MOV     W8,W3
073CE:  MOV     #0,W4
073D0:  MOV     #0,W5
073D2:  MOV     #0,W6
073D4:  MOV     #3FE0,W7
073D6:  CALL    C4A
073DA:  MOV     [--W15],W7
073DC:  MOV     [--W15],W6
073DE:  MOV     [--W15],W5
073E0:  MOV     W0,W5
073E2:  MOV     W1,W6
073E4:  MOV     W2,W7
073E6:  MOV     W3,W8
073E8:  MOV     W5,1BCA
073EA:  MOV     W6,1BCC
073EC:  MOV     W7,1BCE
073EE:  MOV     W8,1BD0
073F0:  CALL    3210
073F4:  MOV     W0,1BA0
073F6:  MOV     W1,1BA2
073F8:  MOV     W2,1BA4
073FA:  MOV     W3,1BA6
....................       n += 2; 
073FC:  MOV     1B9E,W4
073FE:  ADD.B   W4L,#2,W0L
07400:  MOV.B   W0L,1B9E
....................    } 
....................  
....................    y2=y*y; 
07402:  MOV     1BA0,W0
07404:  MOV     1BA2,W1
07406:  MOV     1BA4,W2
07408:  MOV     1BA6,W3
0740A:  MOV     1BA0,W4
0740C:  MOV     1BA2,W5
0740E:  MOV     1BA4,W6
07410:  MOV     1BA6,W7
07412:  CALL    C4A
07416:  MOV     W0,1BB8
07418:  MOV     W1,1BBA
0741A:  MOV     W2,1BBC
0741C:  MOV     W3,1BBE
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
0741E:  MOV     14D8,W0
07420:  MOV     14DA,W1
07422:  MOV     14DC,W2
07424:  MOV     14DE,W3
07426:  MOV     1BB8,W4
07428:  MOV     1BBA,W5
0742A:  MOV     1BBC,W6
0742C:  MOV     1BBE,W7
0742E:  CALL    C4A
07432:  MOV     W0,W5
07434:  MOV     W1,W6
07436:  MOV     W2,W7
07438:  MOV     W3,W8
0743A:  BCLR.B  43.0
0743C:  MOV     W5,[W15++]
0743E:  MOV     W6,[W15++]
07440:  MOV     W7,[W15++]
07442:  MOV     W5,W0
07444:  MOV     W6,W1
07446:  MOV     W7,W2
07448:  MOV     W8,W3
0744A:  MOV     14D0,W4
0744C:  MOV     14D2,W5
0744E:  MOV     14D4,W6
07450:  MOV     14D6,W7
07452:  CALL    1C40
07456:  MOV     [--W15],W7
07458:  MOV     [--W15],W6
0745A:  MOV     [--W15],W5
0745C:  MOV     W0,1BA8
0745E:  MOV     W1,1BAA
07460:  MOV     W2,1BAC
07462:  MOV     W3,1BAE
....................    res = res*y2 + pas_64[2]; 
07464:  MOV     1BA8,W0
07466:  MOV     1BAA,W1
07468:  MOV     1BAC,W2
0746A:  MOV     1BAE,W3
0746C:  MOV     1BB8,W4
0746E:  MOV     1BBA,W5
07470:  MOV     1BBC,W6
07472:  MOV     1BBE,W7
07474:  CALL    C4A
07478:  MOV     W0,W5
0747A:  MOV     W1,W6
0747C:  MOV     W2,W7
0747E:  MOV     W3,W8
07480:  BCLR.B  43.0
07482:  MOV     W5,[W15++]
07484:  MOV     W6,[W15++]
07486:  MOV     W7,[W15++]
07488:  MOV     W5,W0
0748A:  MOV     W6,W1
0748C:  MOV     W7,W2
0748E:  MOV     W8,W3
07490:  MOV     14C8,W4
07492:  MOV     14CA,W5
07494:  MOV     14CC,W6
07496:  MOV     14CE,W7
07498:  CALL    1C40
0749C:  MOV     [--W15],W7
0749E:  MOV     [--W15],W6
074A0:  MOV     [--W15],W5
074A2:  MOV     W0,1BA8
074A4:  MOV     W1,1BAA
074A6:  MOV     W2,1BAC
074A8:  MOV     W3,1BAE
....................    res = res*y2 + pas_64[1]; 
074AA:  MOV     1BA8,W0
074AC:  MOV     1BAA,W1
074AE:  MOV     1BAC,W2
074B0:  MOV     1BAE,W3
074B2:  MOV     1BB8,W4
074B4:  MOV     1BBA,W5
074B6:  MOV     1BBC,W6
074B8:  MOV     1BBE,W7
074BA:  CALL    C4A
074BE:  MOV     W0,W5
074C0:  MOV     W1,W6
074C2:  MOV     W2,W7
074C4:  MOV     W3,W8
074C6:  BCLR.B  43.0
074C8:  MOV     W5,[W15++]
074CA:  MOV     W6,[W15++]
074CC:  MOV     W7,[W15++]
074CE:  MOV     W5,W0
074D0:  MOV     W6,W1
074D2:  MOV     W7,W2
074D4:  MOV     W8,W3
074D6:  MOV     14C0,W4
074D8:  MOV     14C2,W5
074DA:  MOV     14C4,W6
074DC:  MOV     14C6,W7
074DE:  CALL    1C40
074E2:  MOV     [--W15],W7
074E4:  MOV     [--W15],W6
074E6:  MOV     [--W15],W5
074E8:  MOV     W0,1BA8
074EA:  MOV     W1,1BAA
074EC:  MOV     W2,1BAC
074EE:  MOV     W3,1BAE
....................    res = res*y2 + pas_64[0]; 
074F0:  MOV     1BA8,W0
074F2:  MOV     1BAA,W1
074F4:  MOV     1BAC,W2
074F6:  MOV     1BAE,W3
074F8:  MOV     1BB8,W4
074FA:  MOV     1BBA,W5
074FC:  MOV     1BBC,W6
074FE:  MOV     1BBE,W7
07500:  CALL    C4A
07504:  MOV     W0,W5
07506:  MOV     W1,W6
07508:  MOV     W2,W7
0750A:  MOV     W3,W8
0750C:  BCLR.B  43.0
0750E:  MOV     W5,[W15++]
07510:  MOV     W6,[W15++]
07512:  MOV     W7,[W15++]
07514:  MOV     W5,W0
07516:  MOV     W6,W1
07518:  MOV     W7,W2
0751A:  MOV     W8,W3
0751C:  MOV     14B8,W4
0751E:  MOV     14BA,W5
07520:  MOV     14BC,W6
07522:  MOV     14BE,W7
07524:  CALL    1C40
07528:  MOV     [--W15],W7
0752A:  MOV     [--W15],W6
0752C:  MOV     [--W15],W5
0752E:  MOV     W0,1BA8
07530:  MOV     W1,1BAA
07532:  MOV     W2,1BAC
07534:  MOV     W3,1BAE
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
07536:  MOV     1500,W0
07538:  MOV     1502,W1
0753A:  MOV     1504,W2
0753C:  MOV     1506,W3
0753E:  MOV     1BB8,W4
07540:  MOV     1BBA,W5
07542:  MOV     1BBC,W6
07544:  MOV     1BBE,W7
07546:  CALL    C4A
0754A:  MOV     W0,W5
0754C:  MOV     W1,W6
0754E:  MOV     W2,W7
07550:  MOV     W3,W8
07552:  BCLR.B  43.0
07554:  MOV     W5,[W15++]
07556:  MOV     W6,[W15++]
07558:  MOV     W7,[W15++]
0755A:  MOV     W5,W0
0755C:  MOV     W6,W1
0755E:  MOV     W7,W2
07560:  MOV     W8,W3
07562:  MOV     14F8,W4
07564:  MOV     14FA,W5
07566:  MOV     14FC,W6
07568:  MOV     14FE,W7
0756A:  CALL    1C40
0756E:  MOV     [--W15],W7
07570:  MOV     [--W15],W6
07572:  MOV     [--W15],W5
07574:  MOV     W0,1BB0
07576:  MOV     W1,1BB2
07578:  MOV     W2,1BB4
0757A:  MOV     W3,1BB6
....................    r = r*y2 + qas_64[2]; 
0757C:  MOV     1BB0,W0
0757E:  MOV     1BB2,W1
07580:  MOV     1BB4,W2
07582:  MOV     1BB6,W3
07584:  MOV     1BB8,W4
07586:  MOV     1BBA,W5
07588:  MOV     1BBC,W6
0758A:  MOV     1BBE,W7
0758C:  CALL    C4A
07590:  MOV     W0,W5
07592:  MOV     W1,W6
07594:  MOV     W2,W7
07596:  MOV     W3,W8
07598:  BCLR.B  43.0
0759A:  MOV     W5,[W15++]
0759C:  MOV     W6,[W15++]
0759E:  MOV     W7,[W15++]
075A0:  MOV     W5,W0
075A2:  MOV     W6,W1
075A4:  MOV     W7,W2
075A6:  MOV     W8,W3
075A8:  MOV     14F0,W4
075AA:  MOV     14F2,W5
075AC:  MOV     14F4,W6
075AE:  MOV     14F6,W7
075B0:  CALL    1C40
075B4:  MOV     [--W15],W7
075B6:  MOV     [--W15],W6
075B8:  MOV     [--W15],W5
075BA:  MOV     W0,1BB0
075BC:  MOV     W1,1BB2
075BE:  MOV     W2,1BB4
075C0:  MOV     W3,1BB6
....................    r = r*y2 + qas_64[1]; 
075C2:  MOV     1BB0,W0
075C4:  MOV     1BB2,W1
075C6:  MOV     1BB4,W2
075C8:  MOV     1BB6,W3
075CA:  MOV     1BB8,W4
075CC:  MOV     1BBA,W5
075CE:  MOV     1BBC,W6
075D0:  MOV     1BBE,W7
075D2:  CALL    C4A
075D6:  MOV     W0,W5
075D8:  MOV     W1,W6
075DA:  MOV     W2,W7
075DC:  MOV     W3,W8
075DE:  BCLR.B  43.0
075E0:  MOV     W5,[W15++]
075E2:  MOV     W6,[W15++]
075E4:  MOV     W7,[W15++]
075E6:  MOV     W5,W0
075E8:  MOV     W6,W1
075EA:  MOV     W7,W2
075EC:  MOV     W8,W3
075EE:  MOV     14E8,W4
075F0:  MOV     14EA,W5
075F2:  MOV     14EC,W6
075F4:  MOV     14EE,W7
075F6:  CALL    1C40
075FA:  MOV     [--W15],W7
075FC:  MOV     [--W15],W6
075FE:  MOV     [--W15],W5
07600:  MOV     W0,1BB0
07602:  MOV     W1,1BB2
07604:  MOV     W2,1BB4
07606:  MOV     W3,1BB6
....................    r = r*y2 + qas_64[0]; 
07608:  MOV     1BB0,W0
0760A:  MOV     1BB2,W1
0760C:  MOV     1BB4,W2
0760E:  MOV     1BB6,W3
07610:  MOV     1BB8,W4
07612:  MOV     1BBA,W5
07614:  MOV     1BBC,W6
07616:  MOV     1BBE,W7
07618:  CALL    C4A
0761C:  MOV     W0,W5
0761E:  MOV     W1,W6
07620:  MOV     W2,W7
07622:  MOV     W3,W8
07624:  BCLR.B  43.0
07626:  MOV     W5,[W15++]
07628:  MOV     W6,[W15++]
0762A:  MOV     W7,[W15++]
0762C:  MOV     W5,W0
0762E:  MOV     W6,W1
07630:  MOV     W7,W2
07632:  MOV     W8,W3
07634:  MOV     14E0,W4
07636:  MOV     14E2,W5
07638:  MOV     14E4,W6
0763A:  MOV     14E6,W7
0763C:  CALL    1C40
07640:  MOV     [--W15],W7
07642:  MOV     [--W15],W6
07644:  MOV     [--W15],W5
07646:  MOV     W0,1BB0
07648:  MOV     W1,1BB2
0764A:  MOV     W2,1BB4
0764C:  MOV     W3,1BB6
....................    r = r*y2 + 1.0; 
0764E:  MOV     1BB0,W0
07650:  MOV     1BB2,W1
07652:  MOV     1BB4,W2
07654:  MOV     1BB6,W3
07656:  MOV     1BB8,W4
07658:  MOV     1BBA,W5
0765A:  MOV     1BBC,W6
0765C:  MOV     1BBE,W7
0765E:  CALL    C4A
07662:  MOV     W0,W5
07664:  MOV     W1,W6
07666:  MOV     W2,W7
07668:  MOV     W3,W8
0766A:  BCLR.B  43.0
0766C:  MOV     W5,[W15++]
0766E:  MOV     W6,[W15++]
07670:  MOV     W7,[W15++]
07672:  MOV     W5,W0
07674:  MOV     W6,W1
07676:  MOV     W7,W2
07678:  MOV     W8,W3
0767A:  MOV     #0,W4
0767C:  MOV     #0,W5
0767E:  MOV     #0,W6
07680:  MOV     #3FF0,W7
07682:  CALL    1C40
07686:  MOV     [--W15],W7
07688:  MOV     [--W15],W6
0768A:  MOV     [--W15],W5
0768C:  MOV     W0,1BB0
0768E:  MOV     W1,1BB2
07690:  MOV     W2,1BB4
07692:  MOV     W3,1BB6
....................  
....................    res = y*res/r; 
07694:  MOV     1BA0,W0
07696:  MOV     1BA2,W1
07698:  MOV     1BA4,W2
0769A:  MOV     1BA6,W3
0769C:  MOV     1BA8,W4
0769E:  MOV     1BAA,W5
076A0:  MOV     1BAC,W6
076A2:  MOV     1BAE,W7
076A4:  CALL    C4A
076A8:  MOV     W0,W5
076AA:  MOV     W1,W6
076AC:  MOV     W2,W7
076AE:  MOV     W3,W8
076B0:  MOV     W5,[W15++]
076B2:  MOV     W6,[W15++]
076B4:  MOV     W7,[W15++]
076B6:  MOV     W5,W0
076B8:  MOV     W6,W1
076BA:  MOV     W7,W2
076BC:  MOV     W8,W3
076BE:  MOV     1BB0,W4
076C0:  MOV     1BB2,W5
076C2:  MOV     1BB4,W6
076C4:  MOV     1BB6,W7
076C6:  CALL    D5A
076CA:  MOV     [--W15],W7
076CC:  MOV     [--W15],W6
076CE:  MOV     [--W15],W5
076D0:  MOV     W0,1BA8
076D2:  MOV     W1,1BAA
076D4:  MOV     W2,1BAC
076D6:  MOV     W3,1BAE
....................  
....................    if (n & 2)     // |x| > 0.5 
076D8:  MOV.B   1B9E,W0L
076DA:  CLR.B   1
076DC:  AND     W0,#2,W0
076DE:  CP0     W0
076E0:  BRA     Z,7714
....................       res = PI_DIV_BY_TWO - 2.0*res; 
076E2:  MOV     #0,W0
076E4:  MOV     #0,W1
076E6:  MOV     #0,W2
076E8:  MOV     #4000,W3
076EA:  MOV     1BA8,W4
076EC:  MOV     1BAA,W5
076EE:  MOV     1BAC,W6
076F0:  MOV     1BAE,W7
076F2:  CALL    C4A
076F6:  BSET.B  43.0
076F8:  MOV     W0,W4
076FA:  MOV     W1,W5
076FC:  MOV     W2,W6
076FE:  MOV     W3,W7
07700:  MOV     #2D18,W0
07702:  MOV     #5444,W1
07704:  MOV     #21FB,W2
07706:  MOV     #3FF9,W3
07708:  CALL    1C40
0770C:  MOV     W0,1BA8
0770E:  MOV     W1,1BAA
07710:  MOV     W2,1BAC
07712:  MOV     W3,1BAE
....................    if (s) 
07714:  BTSS.B  1B9F.0
07716:  BRA     7722
....................       res = -res; 
07718:  MOV     #1BA8,W0
0771A:  MOV     #1BA8,W1
0771C:  REPEAT  #7
0771E:  MOV     [W0++],[W1++]
07720:  BTG.B   1BAF.7
....................    if (n & 1)           // take arccos 
07722:  MOV.B   1B9E,W0L
07724:  CLR.B   1
07726:  AND     W0,#1,W0
07728:  CP0     W0
0772A:  BRA     Z,774A
....................       res = PI_DIV_BY_TWO - res; 
0772C:  BSET.B  43.0
0772E:  MOV     #2D18,W0
07730:  MOV     #5444,W1
07732:  MOV     #21FB,W2
07734:  MOV     #3FF9,W3
07736:  MOV     1BA8,W4
07738:  MOV     1BAA,W5
0773A:  MOV     1BAC,W6
0773C:  MOV     1BAE,W7
0773E:  CALL    1C40
07742:  MOV     W0,1BA8
07744:  MOV     W1,1BAA
07746:  MOV     W2,1BAC
07748:  MOV     W3,1BAE
....................  
....................    return(res); 
0774A:  MOV     1BA8,W0
0774C:  MOV     1BAA,W1
0774E:  MOV     1BAC,W2
07750:  MOV     1BAE,W3
07752:  MOV     [--W15],W8
07754:  MOV     [--W15],W7
07756:  MOV     [--W15],W6
07758:  MOV     [--W15],W5
0775A:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
0775C:  CLR.B   1B9E
0775E:  PUSH    1B7E
07760:  POP     1B96
07762:  PUSH    1B80
07764:  POP     1B98
07766:  PUSH    1B82
07768:  POP     1B9A
0776A:  PUSH    1B84
0776C:  POP     1B9C
0776E:  CALL    7350
07772:  MOV     W0,1B86
07774:  MOV     W1,1B88
07776:  MOV     W2,1B8A
07778:  MOV     W3,1B8C
....................    return(r); 
0777A:  MOV     1B86,W0
0777C:  MOV     1B88,W1
0777E:  MOV     1B8A,W2
07780:  MOV     1B8C,W3
07782:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
07784:  MOV.B   #1,W0L
07786:  MOV.B   W0L,1B9E
07788:  PUSH    1B7E
0778A:  POP     1B96
0778C:  PUSH    1B80
0778E:  POP     1B98
07790:  PUSH    1B82
07792:  POP     1B9A
07794:  PUSH    1B84
07796:  POP     1B9C
07798:  CALL    7350
0779C:  MOV     W0,1B86
0779E:  MOV     W1,1B88
077A0:  MOV     W2,1B8A
077A2:  MOV     W3,1B8C
....................    return(r); 
077A4:  MOV     1B86,W0
077A6:  MOV     1B88,W1
077A8:  MOV     1B8A,W2
077AA:  MOV     1B8C,W3
077AC:  RETURN  
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
006EA:  MOV     W5,[W15++]
006EC:  MOV     W6,[W15++]
006EE:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
006F0:  CLR     1C96
....................    sign = 0; 
006F2:  CLR     1C92
....................    base = 10; 
006F4:  MOV     #A,W4
006F6:  MOV     W4,1C94
....................    result = 0; 
006F8:  CLR     1C8E
006FA:  CLR     1C90
....................  
....................    if (!s) 
006FC:  CP0     1C8A
006FE:  BRA     NZ,706
....................       return 0; 
00700:  MOV     #0,W0
00702:  MOV     #0,W1
00704:  BRA     8D6
....................    c = s[index++]; 
00706:  MOV     1C96,W0
00708:  INC     1C96
0070A:  MOV     W0,W5
0070C:  MOV     W5,W0
0070E:  ADD     1C8A,W0
00710:  MOV     1C8C,W4
00712:  MOV.B   [W0+#0],W4L
00714:  MOV     W4,1C8C
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
00716:  MOV     1C8C,W4
00718:  XOR.B   #2D,W4L
0071A:  BRA     NZ,734
....................    { 
....................       sign = 1;         // Set the sign to negative 
0071C:  MOV     #1,W4
0071E:  MOV     W4,1C92
....................       c = s[index++]; 
00720:  MOV     1C96,W0
00722:  INC     1C96
00724:  MOV     W0,W5
00726:  MOV     W5,W0
00728:  ADD     1C8A,W0
0072A:  MOV     1C8C,W4
0072C:  MOV.B   [W0+#0],W4L
0072E:  MOV     W4,1C8C
....................    } 
00730:  GOTO    74A
....................    else if (c == '+') 
00734:  MOV     1C8C,W4
00736:  XOR.B   #2B,W4L
00738:  BRA     NZ,74A
....................    { 
....................       c = s[index++]; 
0073A:  MOV     1C96,W0
0073C:  INC     1C96
0073E:  MOV     W0,W5
00740:  MOV     W5,W0
00742:  ADD     1C8A,W0
00744:  MOV     1C8C,W4
00746:  MOV.B   [W0+#0],W4L
00748:  MOV     W4,1C8C
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0074A:  MOV     1C8C,W4
0074C:  MOV     #30,W3
0074E:  CP.B    W3L,W4L
00750:  BRA     GT,8B6
00752:  MOV     1C8C,W4
00754:  MOV     #39,W3
00756:  CP.B    W3L,W4L
00758:  BRA     LT,8B6
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0075A:  MOV     1C8C,W4
0075C:  XOR.B   #30,W4L
0075E:  BRA     NZ,78A
00760:  MOV     1C96,W0
00762:  ADD     1C8A,W0
00764:  MOV.B   [W0],W4L
00766:  XOR.B   #78,W4L
00768:  BRA     Z,774
0076A:  MOV     1C96,W0
0076C:  ADD     1C8A,W0
0076E:  MOV.B   [W0],W4L
00770:  XOR.B   #58,W4L
00772:  BRA     NZ,78A
....................       { 
....................          base = 16; 
00774:  MOV     #10,W4
00776:  MOV     W4,1C94
....................          index++; 
00778:  INC     1C96
....................          c = s[index++]; 
0077A:  MOV     1C96,W0
0077C:  INC     1C96
0077E:  MOV     W0,W5
00780:  MOV     W5,W0
00782:  ADD     1C8A,W0
00784:  MOV     1C8C,W4
00786:  MOV.B   [W0+#0],W4L
00788:  MOV     W4,1C8C
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0078A:  MOV     1C94,W4
0078C:  CP      W4,#A
0078E:  BRA     NZ,7E0
....................       { 
....................          while (c >= '0' && c <= '9') 
00790:  MOV     1C8C,W4
00792:  MOV     #30,W3
00794:  CP.B    W3L,W4L
00796:  BRA     GT,7DC
00798:  MOV     1C8C,W4
0079A:  MOV     #39,W3
0079C:  CP.B    W3L,W4L
0079E:  BRA     LT,7DC
....................          { 
....................             result = 10*result + (c - '0'); 
007A0:  MOV     #A,W0
007A2:  MOV     #0,W1
007A4:  MOV     1C8E,W2
007A6:  MOV     1C90,W3
007A8:  CALL    6A8
007AC:  MOV     W0,W5
007AE:  MOV     W1,W6
007B0:  MOV     1C8C,W4
007B2:  SUB.B   #30,W4L
007B4:  MOV.B   W4L,W0L
007B6:  MOV.B   W0L,0
007B8:  SE      W0,W0
007BA:  CLR     W1
007BC:  BTSC    W0.F
007BE:  SETM    W1
007C0:  ADD     W0,W5,W0
007C2:  MOV     W0,1C8E
007C4:  ADDC    W1,W6,W0
007C6:  MOV     W0,1C90
....................             c = s[index++]; 
007C8:  MOV     1C96,W0
007CA:  INC     1C96
007CC:  MOV     W0,W5
007CE:  MOV     W5,W0
007D0:  ADD     1C8A,W0
007D2:  MOV     1C8C,W4
007D4:  MOV.B   [W0+#0],W4L
007D6:  MOV     W4,1C8C
007D8:  GOTO    790
....................          } 
....................       } 
007DC:  GOTO    8B6
....................       else if (base == 16)    // The number is a hexa number 
007E0:  MOV     1C94,W4
007E2:  CP      W4,#10
007E4:  BRA     NZ,8B6
....................       { 
....................          c = toupper(c); 
007E6:  MOV     1C8C,W4
007E8:  MOV     #61,W3
007EA:  CP.B    W3L,W4L
007EC:  BRA     GTU,7FC
007EE:  MOV     1C8C,W4
007F0:  MOV     #7A,W3
007F2:  CP.B    W3L,W4L
007F4:  BRA     NC,7FC
007F6:  MOV.B   1C8C,W0L
007F8:  AND.B   #DF,W0L
007FA:  BRA     7FE
007FC:  MOV.B   1C8C,W0L
007FE:  MOV.B   W0L,1C8C
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
00800:  MOV     1C8C,W4
00802:  MOV     #30,W3
00804:  CP.B    W3L,W4L
00806:  BRA     GT,812
00808:  MOV     1C8C,W4
0080A:  MOV     #39,W3
0080C:  CP.B    W3L,W4L
0080E:  BRA     LT,812
00810:  BRA     822
00812:  MOV     1C8C,W4
00814:  MOV     #41,W3
00816:  CP.B    W3L,W4L
00818:  BRA     GT,8B6
0081A:  MOV     1C8C,W4
0081C:  MOV     #46,W3
0081E:  CP.B    W3L,W4L
00820:  BRA     LT,8B6
....................          { 
....................             if (c >= '0' && c <= '9') 
00822:  MOV     1C8C,W4
00824:  MOV     #30,W3
00826:  CP.B    W3L,W4L
00828:  BRA     GT,860
0082A:  MOV     1C8C,W4
0082C:  MOV     #39,W3
0082E:  CP.B    W3L,W4L
00830:  BRA     LT,860
....................                result = (result << 4) + (c - '0'); 
00832:  MOV     #4,W4
00834:  MOV     1C8E,W5
00836:  MOV     1C90,W6
00838:  INC     W4,W4
0083A:  DEC     W4,W4
0083C:  BRA     Z,844
0083E:  SL      W5,W5
00840:  RLC     W6,W6
00842:  BRA     83A
00844:  MOV     1C8C,W4
00846:  SUB.B   #30,W4L
00848:  MOV.B   W4L,W0L
0084A:  MOV.B   W0L,0
0084C:  SE      W0,W0
0084E:  CLR     W1
00850:  BTSC    W0.F
00852:  SETM    W1
00854:  ADD     W0,W5,W0
00856:  MOV     W0,1C8E
00858:  ADDC    W1,W6,W0
0085A:  MOV     W0,1C90
0085C:  GOTO    888
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
00860:  MOV     #4,W4
00862:  MOV     1C8E,W5
00864:  MOV     1C90,W6
00866:  INC     W4,W4
00868:  DEC     W4,W4
0086A:  BRA     Z,872
0086C:  SL      W5,W5
0086E:  RLC     W6,W6
00870:  BRA     868
00872:  MOV     1C8C,W4
00874:  SUB.B   #41,W4L
00876:  MOV.B   W4L,W0L
00878:  MOV.B   W0L,0
0087A:  ZE      W0,W0
0087C:  ADD     W0,#A,W0
0087E:  ADD     W0,W5,W0
00880:  MOV     W0,1C8E
00882:  MOV     #0,W4
00884:  ADDC    W4,W6,W0
00886:  MOV     W0,1C90
....................  
....................             c = s[index++];c = toupper(c); 
00888:  MOV     1C96,W0
0088A:  INC     1C96
0088C:  MOV     W0,W5
0088E:  MOV     W5,W0
00890:  ADD     1C8A,W0
00892:  MOV     1C8C,W4
00894:  MOV.B   [W0+#0],W4L
00896:  MOV     W4,1C8C
00898:  MOV     1C8C,W4
0089A:  MOV     #61,W3
0089C:  CP.B    W3L,W4L
0089E:  BRA     GTU,8AE
008A0:  MOV     1C8C,W4
008A2:  MOV     #7A,W3
008A4:  CP.B    W3L,W4L
008A6:  BRA     NC,8AE
008A8:  MOV.B   1C8C,W0L
008AA:  AND.B   #DF,W0L
008AC:  BRA     8B0
008AE:  MOV.B   1C8C,W0L
008B0:  MOV.B   W0L,1C8C
008B2:  GOTO    800
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
008B6:  MOV     1C94,W4
008B8:  CP      W4,#A
008BA:  BRA     NZ,8D2
008BC:  MOV     1C92,W4
008BE:  CP      W4,#1
008C0:  BRA     NZ,8D2
....................       result = -result; 
008C2:  MOV     #0,W4
008C4:  MOV     1C8E,W3
008C6:  SUB     W4,W3,W0
008C8:  MOV     W0,1C8E
008CA:  MOV     #0,W4
008CC:  MOV     1C90,W3
008CE:  SUBB    W4,W3,W0
008D0:  MOV     W0,1C90
....................  
....................    return(result); 
008D2:  MOV     1C8E,W0
008D4:  MOV     1C90,W1
008D6:  MOV     [--W15],W7
008D8:  MOV     [--W15],W6
008DA:  MOV     [--W15],W5
008DC:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "servomoteur/servomoteur.h" 
.................... #ifndef _SERVOMOTEUR_H 
.................... #define _SERVOMOTEUR_H 
....................  
.................... // Nombre de servomoteurs (0 Ã  MAXSERVO-1) 
.................... #DEFINE MAXSERVO 1 
.................... // Valeurs min et max de l'impulsion en [100us] pour la protection des servomoteurs 
.................... #DEFINE MINSERVOPOSITION 9 
.................... #DEFINE MAXSERVOPOSITION 20 
.................... // Normalement 9 et 21 pour 900us et 2.1ms 
....................  
.................... // Structure pour la gestion des servomoteurs 
.................... struct T_Servo{ 
.................... 	int Position; 
.................... 	int Count; 
.................... 	int OpenValue; 
.................... 	int CloseValue; 
.................... }; 
....................  
.................... struct T_Servo ServoTab[MAXSERVO]; 
....................  
.................... void MoveServo(int number, int position); 
.................... void SetServo(int number, int state); 
.................... void OpenServo(int number); 
.................... void CloseServo(int number); 
.................... void CheckServo(); 
.................... void __Init_Servos(); 
....................  
.................... #include "servomoteur/servomoteur.c" 
.................... ///============================================================================================ 
.................... ///	void MoveServo(int number, int position) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de modifier la valeur de consigne (l'angle) d'un servomoteur 
.................... ///	Position défini la longueur de l'impulsion en [100us] 
.................... ///============================================================================================ 
.................... void MoveServo(int number, int position) 
*
09CD4:  MOV     W5,[W15++]
09CD6:  MOV     W6,[W15++]
.................... { 
.................... 	// Protection pour ne pas bloquer le servo en butée 
.................... 	if(position < MINSERVOPOSITION) 
09CD8:  MOV     1B34,W4
09CDA:  CP      W4,#9
09CDC:  BRA     GE,9CE2
.................... 		position = MINSERVOPOSITION; 
09CDE:  MOV     #9,W4
09CE0:  MOV     W4,1B34
.................... 	 
.................... 	if (position > MAXSERVOPOSITION) 
09CE2:  MOV     1B34,W4
09CE4:  CP      W4,#14
09CE6:  BRA     LE,9CEC
.................... 		position = MAXSERVOPOSITION; 
09CE8:  MOV     #14,W4
09CEA:  MOV     W4,1B34
.................... 	// Définition de position du servomoteur 
.................... 	ServoTab[number].Position = position; 
09CEC:  MOV     1B32,W4
09CEE:  MUL.UU  W4,#8,W0
09CF0:  MOV     W0,W5
09CF2:  MOV     #156E,W4
09CF4:  ADD     W5,W4,W6
09CF6:  MOV     1B34,W4
09CF8:  MOV     W4,[W6+#0]
.................... 	 
.................... 	enable_interrupts(INT_TIMER2); 
09CFA:  BSET.B  8C.6
.................... 	delay_ms(500); 
09CFC:  MOV     #1F4,W0
09CFE:  CALL    F0E
.................... 	disable_interrupts(INT_TIMER2); 
09D02:  BCLR.B  8C.6
09D04:  MOV     [--W15],W6
09D06:  MOV     [--W15],W5
09D08:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void SetServo(int number, int state) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de définir la sortie propre à chaque servomoteur 
.................... ///	output_bit() demande l'adresse du bit utilisé (par exemple avec un "#define PIN_A3 5651") 
.................... ///============================================================================================ 
.................... void SetServo(int number, int state) 
.................... { 
.................... 	switch (number) 
*
00524:  MOV     1C9C,W0
00526:  XOR     #0,W0
00528:  BRA     Z,52C
0052A:  BRA     53C
.................... 	{ 
.................... 		case 0:		// Pour le servomoteur droit 
.................... 			output_bit(PIN_D4,state);	 
0052C:  CP0     1C9E
0052E:  BRA     NZ,534
00530:  BCLR.B  2D6.4
00532:  BRA     536
00534:  BSET.B  2D6.4
00536:  BCLR.B  2D2.4
.................... 			break; 
00538:  GOTO    540
.................... 		default : 
.................... 			break; 
0053C:  GOTO    540
.................... 	} 
00540:  RETURN  
.................... 	 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void CheckServo() 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Gère la commande des servomoteurs 
.................... ///	Doit être appelé toutes les 100us 
.................... ///============================================================================================ 
.................... void CheckServo() 
00542:  MOV     W5,[W15++]
00544:  MOV     W6,[W15++]
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
00546:  CLR     1C9A
00548:  MOV     1C9A,W4
0054A:  CP      W4,#1
0054C:  BRA     GE,5D2
.................... 	{ 
.................... 		if(ServoTab[i].Count<ServoTab[i].Position) 
0054E:  MOV     1C9A,W4
00550:  MUL.UU  W4,#8,W0
00552:  MOV     W0,W5
00554:  ADD     W5,#2,W0
00556:  MOV     #156E,W4
00558:  ADD     W0,W4,W0
0055A:  MOV     [W0],W5
0055C:  MOV     1C9A,W4
0055E:  MUL.UU  W4,#8,W6
00560:  MOV     #156E,W4
00562:  ADD     W6,W4,W0
00564:  MOV     W0,W4
00566:  MOV     [W4],W0
00568:  CP      W5,W0
0056A:  BRA     GE,58A
.................... 		{ 
.................... 			// Ton 
.................... 			SetServo(i,1); 
0056C:  PUSH    1C9A
0056E:  POP     1C9C
00570:  MOV     #1,W4
00572:  MOV     W4,1C9E
00574:  CALL    524
.................... 			ServoTab[i].Count++; 
00578:  MOV     1C9A,W4
0057A:  MUL.UU  W4,#8,W0
0057C:  MOV     W0,W5
0057E:  ADD     W5,#2,W0
00580:  MOV     #156E,W4
00582:  ADD     W0,W4,W5
00584:  INC     [W5],[W5]
.................... 		}  
00586:  GOTO    5CC
.................... 		else  
.................... 		{ 
.................... 			if(ServoTab[i].Count<197)  
0058A:  MOV     1C9A,W4
0058C:  MUL.UU  W4,#8,W0
0058E:  MOV     W0,W5
00590:  ADD     W5,#2,W0
00592:  MOV     #156E,W4
00594:  ADD     W0,W4,W0
00596:  MOV     [W0],W5
00598:  MOV     #C5,W4
0059A:  CP      W4,W5
0059C:  BRA     LE,5BA
.................... 			{ 
.................... 				// Toff 
.................... 				SetServo(i,0); 
0059E:  PUSH    1C9A
005A0:  POP     1C9C
005A2:  CLR     1C9E
005A4:  CALL    524
.................... 				ServoTab[i].Count++; 
005A8:  MOV     1C9A,W4
005AA:  MUL.UU  W4,#8,W0
005AC:  MOV     W0,W5
005AE:  ADD     W5,#2,W0
005B0:  MOV     #156E,W4
005B2:  ADD     W0,W4,W5
005B4:  INC     [W5],[W5]
.................... 			}  
005B6:  GOTO    5CC
.................... 			else  
.................... 			{ 
.................... 				// Fin de la période 
.................... 				ServoTab[i].Count = 0; 
005BA:  MOV     1C9A,W4
005BC:  MUL.UU  W4,#8,W0
005BE:  MOV     W0,W5
005C0:  ADD     W5,#2,W0
005C2:  MOV     #156E,W4
005C4:  ADD     W0,W4,W5
005C6:  CLR.B   [W5]
005C8:  MOV.B   #0,W0L
005CA:  MOV.B   W0L,[W5+#1]
.................... 			} 
.................... 		} 
005CC:  INC     1C9A
005CE:  GOTO    548
.................... 	} 
005D2:  MOV     [--W15],W6
005D4:  MOV     [--W15],W5
005D6:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void OpenServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position ouverte définie avec ServoTab[x].OpenValue 
.................... ///============================================================================================ 
.................... void OpenServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].OpenValue); 
.................... } 
.................... ///============================================================================================ 
.................... /// void CloseServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position fermée définie avec ServoTab[x].CloseValue 
.................... ///============================================================================================ 
.................... void CloseServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].CloseValue); 
.................... } 
....................  
.................... ///	Initialisation de la structure des servomoteurs: 
.................... void __Init_Servos(void) 
.................... { 
.................... 	unsigned int8 i=0; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
.................... 	{ 
.................... 		ServoTab[i].Position = 0; 
.................... 		ServoTab[i].Count = 0; 
.................... 	} 
....................  
.................... 	///	Configuration du TIMER2 pour 100us: 
.................... ///-------------------------------------------------------------------- 
.................... 	setup_timer2(TMR_INTERNAL, 1973); 
.................... 	// 1/((80MHz)/4)*1*2000 = 100us 
.................... 	enable_interrupts(INT_TIMER2); 
.................... } 
....................  
.................... ///	Interruption TIMER2 
.................... ///-------------------------------------------------------------------- 
.................... 	#INT_TIMER2 HIGH 
.................... 	void timer2_isr() 
005D8:  PUSH    42
005DA:  PUSH    36
005DC:  PUSH    32
005DE:  MOV     W0,[W15++]
005E0:  MOV     #2,W0
005E2:  REPEAT  #C
005E4:  MOV     [W0++],[W15++]
.................... 	{ 
.................... 		set_timer2(0); 
005E6:  CLR     106
.................... 		CheckServo(); 
005E8:  CALL    542
.................... 	} 
....................  
....................  
.................... #endif 
....................  
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS - PRINCIPE 
.................... ///==================================================================== 
.................... /// 
.................... ///	Le but est de gÃ©nÃ©rer des sorties pour la commandes de servomoteurs. 
.................... ///	Les sorties sont mises Ã  jour chaque 100us grÃ¢ce au TIMER2. 
.................... ///	Les impulsions de commande sont envoyÃ©es en continu. 
.................... /// 
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS  - UTILISATION 
.................... ///==================================================================== 
.................... /// 
.................... ///	MAXSERVO permet de dÃ©finir le nombre de servomoteurs utilisÃ©s 
.................... ///	MINSERVOPOSITION et MAXSERVOPOSITION fixent les valeurs min et max 
.................... ///	des impulsions Ã  gÃ©nÃ©rer pour la commande des servomoteurs, en 
.................... ///	gÃ©nÃ©ral on se limite Ã  900us (9) et 2.1ms (21) 
.................... /// 
.................... ///	CheckServo(): gÃ¨re la commande des servomoteurs, Ã  appeler toutes 
.................... ///	toutes les 100us 
.................... /// 
.................... ///	MoveServo(number, position): permet de modifier la valeur de consigne 
.................... ///	d'un servomoteur 
.................... /// 
.................... ///	SetServo(numer, state): utilisÃ© par CheckServo(), le switch case 
.................... ///	permet de dÃ©finir les sorties propres Ã  chaque servomoteurs. 
....................  
.................... #include "LCD/___LCD.h" 
.................... /* 
.................... * \file ___LCD.h 
.................... * \brief Gère l'afficheur LCD I2C (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_H 
005EC:  BCLR.B  84.6
005EE:  MOV     #1A,W0
005F0:  REPEAT  #C
005F2:  MOV     [--W15],[W0--]
005F4:  MOV     [--W15],W0
005F6:  POP     32
005F8:  POP     36
005FA:  POP     42
005FC:  RETFIE  
.................... #define ___LCD_H 
....................  
.................... void __Init_LCD(void); // Init LCD 
.................... void __ClearLCD(void);	// Efface l'écran 
.................... void __WriteLCD(unsigned int8 _Command);	// Ecrit la commande  
.................... void __WriteCount(float64 _Value, int1 _Mode);	// Ecrit une valeur, int32 si mode = 0, float si mode = 1 
.................... void __SautLig(unsigned int8 _Lig);	// Saute d'une ligne sur l'écran 
....................  
.................... #include "LCD/___LCD.c" 
.................... /* 
.................... * \file ___LCD.c 
.................... * \brief Gère l'afficheur LCD I2C (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_C 
.................... #define ___LCD_C 
....................  
.................... void __Init_LCD(void) 
.................... { 
.................... 	// Config LCD IIC 
.................... 	i2c_start(); 
.................... 	i2c_write(0x50);	// Adresse du LCD 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x52);	// Contraste 
.................... 	i2c_write(0x24);	// 36 sur 50 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x53);	// Brightness backlight 
.................... 	i2c_write(6);		// 6 sur 8 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x51);	// Efface l'écran 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __ClearLCD 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __ClearLCD(void) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Clear le LCD 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x51); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteLCD 
.................... // Ecrit ou envoi une commande au LCD. 
.................... // Prend quoi écrire. 
.................... // Ne retourne rien. 
.................... void __WriteLCD(unsigned int8 _Command) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
.................... unsigned int8 ack=i2c_write(0x50); 
.................... 	// Se connecte au LCD 
.................... 	if(ack==0) 
.................... 	// Ecrit ou envoi la comande au LCD 
.................... 	i2c_write(_Command); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteCount 
.................... // Permet d'écrire la valeur de la roue folle. 
.................... // Prend la valeur à écrire et le mode (0 = écrit. int, 1 = écrit. float tronqué) 
.................... // Ne retourne rien. 
.................... void __WriteCount(float64 _Value, int1 _Mode) 
.................... { 
.................... 	// Index d'affichage 
.................... 	unsigned int8 IAff=0, TabValue[16]; 
.................... 	 
.................... 	// Selon mode d'affichage choisi 
.................... 	// Transforme le nombre en chaîne de caractère 
.................... 	if(_Mode == 0) 
.................... 	sprintf(TabValue,"%7Ld ",(int32)_Value); 
.................... 	else	 
.................... 	sprintf(TabValue,"%6.3f ",(float64)_Value); 
.................... 		 
.................... 	// Affiche les caractères à la suite 
.................... 	while(TabValue[IAff]!=0x00) 
.................... 	{ 
.................... 		__WriteLCD(TabValue[IAff]); 
.................... 		Iaff++; 
.................... 	}	 
....................  
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... }	 
....................  
.................... // __SautLig 
.................... // Saute à la seconde ligne 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __SautLig(unsigned int8 _Lig) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Saute à la seconde ligne 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x45); 
.................... 	i2c_write(_Lig); 
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Deplacement/___Depl.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl 
.................... #define ___Depl 
....................  
....................  
.................... /////////////////  Deplacement Progress  //////////////////////////////// 
.................... float64 amp_limit = 1.6;				 // limite de courant depl progress 
.................... unsigned int16 DIST_SECU_PROGRESS = 100; // distance de secu sur le deplacement progress en mm 
.................... 	 
.................... /////////////////  Localisation  //////////////////////////////// 
.................... signed int16 Dist_x,Dist_y=0; 
.................... signed int16 Pos_x = 0; //en mm 
.................... signed int16 Pos_y = 0;//en mm 
.................... signed int16 Orient_deg = 0; 
.................... float64 Dorient = 0;  
.................... float64 Orient = 0; 
.................... float64 DIAM_ENCO = 3.48139;	// Diamètre des encodeurs, en [cm] 
.................... float64 IMPULSES_ENCO = 5000;	// Nombre d'impulsions de l'encodeur (sans compter le x4 du QEI) 
.................... float64 ENTRAXE_ROUESFOLLES = 29.51922;//31.6006	// Entraxe entre les deux centres des roues folles, en [cm] 
....................  
.................... ///////////////// Calcul //////////////////////////////////////// 
.................... float64 COEFF_D	= (float64) (IMPULSES_ENCO*4)/(DIAM_ENCO*PI);	// Nbre de pas pour 1 [cm] 
.................... float64 CONV_DEG_RAD = (float64) (PI / 180); 
....................  
.................... ////////////////////// Gestion de la reception //////////////////////////////////// 
.................... unsigned int8 RoboteQ_receiveToProceed = 0;	// Position maximale pour la rÃ©ception 
.................... unsigned int8 RoboteQ_receiveLenght = 0;	// Longeur totale de la donnÃ©e 
.................... signed int32 Dist_Do = 0; 
....................  
.................... ///////////////////// Impulsions ////////////////////////////////////////////////// 
.................... signed int32 value_enco_g_start = 0;		//valeur enco debut deplacment 
.................... signed int32 value_enco_d_start = 0;		//valeur enco debut deplacement 
.................... signed int32 value_enco_g_end = 0;			//valeur enco fin deplacment 
.................... signed int32 value_enco_d_end = 0;			//valeur enco fin deplacement	 
....................  
....................  
.................... /////////////////  Prototype fct  //////////////////////////////// 
.................... void __DeplToDo(unsigned int8 _Command);	// 0--> turn, 1--> PaP, 2--> progress, 4-->nothing 
.................... void __Turn(signed int16 _Ang);				 
.................... void __PaP(int16 _X, int16 _Y); 
.................... void __Progress(int16 _X, int16 _Y); 
.................... void __Nothing(void); 
.................... float64 __Get_amp(int channel); 
.................... void __Init_pos(void); 
.................... void __LoadObj(unsigned int16 _Obj); // Charge les différents paramètres des objectifs selon lequel est sélectionné 
.................... float64 __Conv_Ang_4Quadr(float64 _Ang); // Convertit un angle selon le cadran de l'objectif. 
.................... void __Get_enco_value(int1 start_end); 
.................... #include "Deplacement/___Depl.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl_c 
.................... #define ___Depl_c 
....................  
.................... //********************************************************************************************************************* 
.................... // arrondi_float 
.................... // 
.................... // Cette fonction permet d'arrondir un nombre decimal en entier relatif 
.................... // 12.7863 => 13 
.................... // 14.45621 => 14  
.................... // 
.................... // Developpe par : Louis Mayencourt 
.................... // Date :          01.12.2010  
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : nombre a convertir  
.................... // return      : nombre converti 
.................... // 
.................... //********************************************************************************************************************* 
.................... signed int32 arrondi_float_signed(float nombre) 
.................... { 
.................... 	float chiffres_apres_virgule;		// contient les chiffres apres la virgule du float a convertir  
....................  
.................... // prend les chiffres apres la virgule 
.................... 	chiffres_apres_virgule = nombre-floor(nombre); 
*
06D9E:  PUSH    1B7A
06DA0:  POP     1B82
06DA2:  PUSH    1B7C
06DA4:  POP     1B84
06DA6:  CALL    6D38
06DAA:  BSET.B  43.0
06DAC:  MOV     W0,W2
06DAE:  MOV     W1,W3
06DB0:  MOV     1B7A,W0
06DB2:  MOV     1B7C,W1
06DB4:  CALL    6A22
06DB8:  MOV     W0,1B7E
06DBA:  MOV     W1,1B80
....................  
.................... // test si il faut arrondir vers le bas ou le haut 
.................... 	if(chiffres_apres_virgule>=0.5) return( (signed int32)(ceil(nombre))); 
06DBC:  MOV     #0,W0
06DBE:  MOV     #3F00,W1
06DC0:  MOV     1B7E,W2
06DC2:  MOV     1B80,W3
06DC4:  CALL    6890
06DC8:  BRA     C,6DCC
06DCA:  BRA     NZ,6DE4
06DCC:  PUSH    1B7A
06DCE:  POP     1B82
06DD0:  PUSH    1B7C
06DD2:  POP     1B84
06DD4:  CALL    6D4A
06DD8:  CALL    6D5E
06DDC:  MOV.D   W0,W0
06DDE:  BRA     6DF8
06DE0:  GOTO    6DF8
.................... 	else return( (signed int32)(floor(nombre))); 
06DE4:  PUSH    1B7A
06DE6:  POP     1B82
06DE8:  PUSH    1B7C
06DEA:  POP     1B84
06DEC:  CALL    6D38
06DF0:  CALL    6D5E
06DF4:  MOV.D   W0,W0
06DF6:  BRA     6DF8
06DF8:  RETURN  
.................... } 
....................  
.................... void __Affichage_Erreur(int8 nombre) 
.................... { 
.................... 	No_erreur = nombre;  
*
0107A:  MOV.B   1B3A,W0L
0107C:  MOV.B   W0L,870
.................... 	flag_error = 1;  
0107E:  BSET.B  85B.2
.................... 		// Quitte la fonction 
.................... 	return; 
01080:  RETURN  
.................... } 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Check_commande_atteint 
.................... //	Auteur :	BORREM 
.................... //	Date:	    18.2.15 
.................... //  Statut :    fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Check si la commande donnÃ© aux moteurs a Ã©tÃ© finie 
.................... void __Check_commande_atteint(void) 
*
077AE:  MOV     W5,[W15++]
077B0:  MOV     W6,[W15++]
077B2:  BCLR.B  1B74.1
.................... { 
.................... 	int1 comm_atteinte_m1,comm_atteinte_m2 = 0; 
.................... 	fprintf(ROBOTEQ,"?DR\r"); 
077B4:  MOV     #0,W1
077B6:  MOV     W1,W0
077B8:  CLR.B   1
077BA:  CALL    100
077BE:  INC     W1,W1
077C0:  BTSC.B  219.1
077C2:  BRA     77C0
077C4:  MOV     W0,21A
077C6:  MOV     #3,W0
077C8:  CPSGT   W1,W0
077CA:  BRA     77B6
.................... //il renvoie DR=x:x 
.................... 	delay_ms(20); 
077CC:  MOV     #14,W0
077CE:  CALL    F0E
.................... //on vÃ©rifie que le premier caractÃ¨re n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] != '!' && RoboteQ_receiveBuffer[0] != '?' && RoboteQ_receiveBuffer[0] != '~' && RoboteQ_receiveBuffer[0] != '^' && RoboteQ_receiveBuffer[0] != '#') 
077D2:  MOV     882,W4
077D4:  XOR.B   #21,W4L
077D6:  BRA     Z,77FC
077D8:  MOV     882,W4
077DA:  XOR.B   #3F,W4L
077DC:  BRA     Z,77FC
077DE:  MOV     882,W4
077E0:  XOR.B   #7E,W4L
077E2:  BRA     Z,77FC
077E4:  MOV     882,W4
077E6:  XOR.B   #5E,W4L
077E8:  BRA     Z,77FC
077EA:  MOV     882,W4
077EC:  XOR.B   #23,W4L
077EE:  BRA     Z,77FC
.................... 	{ 
.................... 		comm_atteinte_m1 = RoboteQ_receiveBuffer[3]; // affectation du premier x dans la variable 
077F0:  BCLR.B  1B74.0
077F2:  BTSC.B  885.0
077F4:  BSET.B  1B74.0
.................... 		comm_atteinte_m2 = RoboteQ_receiveBuffer[5]; // affectation du deuxiÃ¨me x dans la variable 
077F6:  BCLR.B  1B74.1
077F8:  BTSC.B  887.0
077FA:  BSET.B  1B74.1
.................... 	} 
.................... 	if(comm_atteinte_m1 == 1 && comm_atteinte_m2== 1) // si commande des deux moteurs dini  
077FC:  BTSS.B  1B74.0
077FE:  BRA     7806
07800:  BTSS.B  1B74.1
07802:  BRA     7806
.................... 	{ 
.................... 		flag_depl_ok =1 ; // on peut passer au dÃ©placement suivant 
07804:  BSET.B  85A.6
.................... 	} 
07806:  MOV     [--W15],W6
07808:  MOV     [--W15],W5
0780A:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_amp(int channel) 
.................... * \brief Recupere la valeur du courant dans les moteurs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] channel--> 1 moteur 1, 2  moteur 2  
.................... * \return Ne retourne rien 
.................... */ 
.................... float64 __Get_amp(int channel) 
*
086CE:  MOV     W5,[W15++]
086D0:  MOV     W6,[W15++]
086D2:  CLR     1B54
086D4:  MOV.B   #2,W0L
086D6:  MOV.B   W0L,1B52
.................... { 
.................... 	unsigned int16 ampere = 0; 
.................... 	unsigned int8 i = 2; 
.................... 	if(channel == 1) 
086D8:  MOV     1B50,W4
086DA:  CP      W4,#1
086DC:  BRA     NZ,86FA
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 1\r"); 
086DE:  MOV     #0,W1
086E0:  MOV     W1,W0
086E2:  CLR.B   1
086E4:  CALL    112
086E8:  INC     W1,W1
086EA:  BTSC.B  219.1
086EC:  BRA     86EA
086EE:  MOV     W0,21A
086F0:  MOV     #4,W0
086F2:  CPSGT   W1,W0
086F4:  BRA     86E0
.................... 	} 
086F6:  GOTO    8712
.................... 	else 
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 2\r"); 
086FA:  MOV     #0,W1
086FC:  MOV     W1,W0
086FE:  CLR.B   1
08700:  CALL    124
08704:  INC     W1,W1
08706:  BTSC.B  219.1
08708:  BRA     8706
0870A:  MOV     W0,21A
0870C:  MOV     #4,W0
0870E:  CPSGT   W1,W0
08710:  BRA     86FC
.................... 	}  
.................... 	//il renvoie DR=x:x 
.................... 	delay_ms(10); 
08712:  MOV     #A,W0
08714:  CALL    F0E
.................... 	//on verifie que le premier caractere n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] == 'A') 
08718:  MOV     882,W4
0871A:  XOR.B   #41,W4L
0871C:  BRA     NZ,876E
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= '\r') 
0871E:  MOV     1B52,W4
08720:  CLR.B   9
08722:  MOV     #882,W3
08724:  ADD     W4,W3,W0
08726:  MOV.B   [W0],W4L
08728:  CP.B    W4L,#D
0872A:  BRA     Z,875C
.................... 		{ 
.................... 			if(RoboteQ_receiveBuffer[i]!=0x2D) // 0x2D -> signe '-' en ascii, courant neg -> on prend en abs 
0872C:  MOV     1B52,W4
0872E:  CLR.B   9
08730:  MOV     #882,W3
08732:  ADD     W4,W3,W0
08734:  MOV.B   [W0],W5L
08736:  SE      W5,W5
08738:  MOV     #2D,W4
0873A:  CP      W4,W5
0873C:  BRA     Z,8756
.................... 			{ 
.................... 				ampere  *= 10; 
0873E:  MOV     1B54,W4
08740:  MUL.UU  W4,#A,W0
08742:  MOV     W0,1B54
.................... 				ampere  += RoboteQ_receiveBuffer[i]-0x30; 
08744:  MOV     1B52,W4
08746:  CLR.B   9
08748:  MOV     #882,W3
0874A:  ADD     W4,W3,W0
0874C:  MOV.B   [W0],W5L
0874E:  SE      W5,W5
08750:  MOV     #30,W4
08752:  SUB     W5,W4,W0
08754:  ADD     1B54
.................... 			} 
.................... 			i++;  
08756:  INC.B   1B52
08758:  GOTO    871E
.................... 		} 
.................... 		return(ampere); 
0875C:  MOV     1B54,W0
0875E:  MOV     #0,W1
08760:  MOV     #0,W2
08762:  MOV     #0,W3
08764:  CALL    2374
08768:  BRA     8778
.................... 	} 
0876A:  GOTO    8778
.................... 	else 
.................... 	{ 
.................... 		return(0); 
0876E:  MOV     #0,W0
08770:  MOV     #0,W1
08772:  MOV     #0,W2
08774:  MOV     #0,W3
08776:  BRA     8778
.................... 	} 
08778:  MOV     [--W15],W6
0877A:  MOV     [--W15],W5
0877C:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_enco_value(int1 start_end) 
.................... * \brief Recupere la valeur des encodeurs du robot 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] 1 -> enco au depart, 0 -> enco a la fin 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Get_enco_value(int1 start_end) 
*
0788A:  MOV     W5,[W15++]
0788C:  MOV     W6,[W15++]
0788E:  MOV.B   #2,W0L
07890:  MOV.B   W0L,1B75
07892:  BCLR.B  1B76.0
.................... { 
.................... 	unsigned int8 i = 2; 
.................... 	int1 flag_inverted = 0; 
.................... 	if(start_end) // si recuperation enco au depart --> on clear tout 
07894:  CP0.B   1B74
07896:  BRA     Z,78A8
.................... 	{ 
.................... 		value_enco_g_start = 0; 
07898:  CLR     15CA
0789A:  CLR     15CC
.................... 		value_enco_d_start = 0; 
0789C:  CLR     15CE
0789E:  CLR     15D0
.................... 		value_enco_g_end   = 0; 
078A0:  CLR     15D2
078A2:  CLR     15D4
.................... 		value_enco_d_end   = 0; 
078A4:  CLR     15D6
078A6:  CLR     15D8
.................... 	} 
....................  
.................... 	fprintf(ROBOTEQ,"?C\r"); // on demande la valeur des encodeurs 
078A8:  BTSC.B  219.1
078AA:  BRA     78A8
078AC:  MOV     #3F,W4
078AE:  MOV     W4,21A
078B0:  BTSC.B  219.1
078B2:  BRA     78B0
078B4:  MOV     #43,W4
078B6:  MOV     W4,21A
078B8:  BTSC.B  219.1
078BA:  BRA     78B8
078BC:  MOV     #D,W4
078BE:  MOV     W4,21A
.................... 	delay_ms(20); 
078C0:  MOV     #14,W0
078C2:  CALL    F0E
.................... 	 
.................... 	if(RoboteQ_receiveBuffer[0] == 'C') // si on reçoit C=xxxx:xxxx 
078C6:  MOV     882,W4
078C8:  XOR.B   #43,W4L
078CA:  BRA     NZ,7A7E
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= ':') 
078CC:  MOV     1B74,W4
078CE:  LSR     W4,#8,W4
078D0:  MOV     #882,W3
078D2:  ADD     W4,W3,W0
078D4:  MOV.B   [W0],W4L
078D6:  XOR.B   #3A,W4L
078D8:  BRA     Z,7974
.................... 		{ 
.................... 			if(start_end) 
078DA:  CP0.B   1B74
078DC:  BRA     Z,7928
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
078DE:  MOV     1B74,W4
078E0:  LSR     W4,#8,W4
078E2:  MOV     #882,W3
078E4:  ADD     W4,W3,W0
078E6:  MOV.B   [W0],W5L
078E8:  SE      W5,W5
078EA:  MOV     #2D,W4
078EC:  CP      W4,W5
078EE:  BRA     NZ,78F6
.................... 				{ 
.................... 					flag_inverted = 1; 
078F0:  BSET.B  1B76.0
.................... 				} 
078F2:  GOTO    7924
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_start *= 10; 
078F6:  MOV     15CA,W0
078F8:  MOV     15CC,W1
078FA:  MOV     #A,W2
078FC:  MOV     #0,W3
078FE:  CALL    6A8
07902:  MOV     W0,15CA
07904:  MOV     W1,15CC
.................... 					value_enco_g_start += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
07906:  MOV     1B74,W4
07908:  LSR     W4,#8,W4
0790A:  MOV     #882,W3
0790C:  ADD     W4,W3,W0
0790E:  MOV.B   [W0],W5L
07910:  SE      W5,W5
07912:  MOV     #30,W4
07914:  SUB     W5,W4,W0
07916:  CLR     W1
07918:  BTSC    W0.F
0791A:  SETM    W1
0791C:  ADD     15CA
0791E:  MOV     15CC,W4
07920:  ADDC    W1,W4,W0
07922:  MOV     W0,15CC
.................... 				}				 
.................... 			} 
07924:  GOTO    796E
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
07928:  MOV     1B74,W4
0792A:  LSR     W4,#8,W4
0792C:  MOV     #882,W3
0792E:  ADD     W4,W3,W0
07930:  MOV.B   [W0],W5L
07932:  SE      W5,W5
07934:  MOV     #2D,W4
07936:  CP      W4,W5
07938:  BRA     NZ,7940
.................... 				{ 
.................... 					flag_inverted = 1; 
0793A:  BSET.B  1B76.0
.................... 				} 
0793C:  GOTO    796E
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_end *= 10; 
07940:  MOV     15D2,W0
07942:  MOV     15D4,W1
07944:  MOV     #A,W2
07946:  MOV     #0,W3
07948:  CALL    6A8
0794C:  MOV     W0,15D2
0794E:  MOV     W1,15D4
.................... 					value_enco_g_end += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
07950:  MOV     1B74,W4
07952:  LSR     W4,#8,W4
07954:  MOV     #882,W3
07956:  ADD     W4,W3,W0
07958:  MOV.B   [W0],W5L
0795A:  SE      W5,W5
0795C:  MOV     #30,W4
0795E:  SUB     W5,W4,W0
07960:  CLR     W1
07962:  BTSC    W0.F
07964:  SETM    W1
07966:  ADD     15D2
07968:  MOV     15D4,W4
0796A:  ADDC    W1,W4,W0
0796C:  MOV     W0,15D4
.................... 				} 
.................... 			} 
.................... 			i++; 
0796E:  INC.B   1B75
07970:  GOTO    78CC
.................... 		} 
.................... 		if(flag_inverted) //si l'on a recu un nbre d'impulses negatifs 
07974:  BTSS.B  1B76.0
07976:  BRA     79A4
.................... 		{ 
.................... 			if(start_end)  
07978:  CP0.B   1B74
0797A:  BRA     Z,7992
.................... 			{ 
.................... 				value_enco_g_start = 0-value_enco_g_start; // on inverse tout 
0797C:  MOV     #0,W4
0797E:  MOV     15CA,W3
07980:  SUB     W4,W3,W0
07982:  MOV     W0,15CA
07984:  MOV     #0,W4
07986:  MOV     15CC,W3
07988:  SUBB    W4,W3,W0
0798A:  MOV     W0,15CC
.................... 				flag_inverted = 0; 
0798C:  BCLR.B  1B76.0
.................... 			} 
0798E:  GOTO    79A4
.................... 			else 
.................... 			{ 
.................... 				value_enco_g_end = 0-value_enco_g_end;	// on inverse tout 
07992:  MOV     #0,W4
07994:  MOV     15D2,W3
07996:  SUB     W4,W3,W0
07998:  MOV     W0,15D2
0799A:  MOV     #0,W4
0799C:  MOV     15D4,W3
0799E:  SUBB    W4,W3,W0
079A0:  MOV     W0,15D4
.................... 				flag_inverted = 0; 
079A2:  BCLR.B  1B76.0
.................... 			} 
.................... 		} 
.................... 		i++; 
079A4:  INC.B   1B75
.................... 		while(RoboteQ_receiveBuffer[i]!='\r')//tant que la transmission n'est pas fini 
079A6:  MOV     1B74,W4
079A8:  LSR     W4,#8,W4
079AA:  MOV     #882,W3
079AC:  ADD     W4,W3,W0
079AE:  MOV.B   [W0],W4L
079B0:  CP.B    W4L,#D
079B2:  BRA     Z,7A4E
.................... 		{ 
.................... 			if(start_end) 
079B4:  CP0.B   1B74
079B6:  BRA     Z,7A02
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
079B8:  MOV     1B74,W4
079BA:  LSR     W4,#8,W4
079BC:  MOV     #882,W3
079BE:  ADD     W4,W3,W0
079C0:  MOV.B   [W0],W5L
079C2:  SE      W5,W5
079C4:  MOV     #2D,W4
079C6:  CP      W4,W5
079C8:  BRA     NZ,79D0
.................... 				{ 
.................... 					flag_inverted = 1; 
079CA:  BSET.B  1B76.0
.................... 				} 
079CC:  GOTO    79FE
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_start *= 10; 
079D0:  MOV     15CE,W0
079D2:  MOV     15D0,W1
079D4:  MOV     #A,W2
079D6:  MOV     #0,W3
079D8:  CALL    6A8
079DC:  MOV     W0,15CE
079DE:  MOV     W1,15D0
.................... 					value_enco_d_start += RoboteQ_receiveBuffer[i]-0x30; 
079E0:  MOV     1B74,W4
079E2:  LSR     W4,#8,W4
079E4:  MOV     #882,W3
079E6:  ADD     W4,W3,W0
079E8:  MOV.B   [W0],W5L
079EA:  SE      W5,W5
079EC:  MOV     #30,W4
079EE:  SUB     W5,W4,W0
079F0:  CLR     W1
079F2:  BTSC    W0.F
079F4:  SETM    W1
079F6:  ADD     15CE
079F8:  MOV     15D0,W4
079FA:  ADDC    W1,W4,W0
079FC:  MOV     W0,15D0
.................... 				} 
.................... 			} 
079FE:  GOTO    7A48
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
07A02:  MOV     1B74,W4
07A04:  LSR     W4,#8,W4
07A06:  MOV     #882,W3
07A08:  ADD     W4,W3,W0
07A0A:  MOV.B   [W0],W5L
07A0C:  SE      W5,W5
07A0E:  MOV     #2D,W4
07A10:  CP      W4,W5
07A12:  BRA     NZ,7A1A
.................... 				{ 
.................... 					flag_inverted = 1; 
07A14:  BSET.B  1B76.0
.................... 				} 
07A16:  GOTO    7A48
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_end *= 10; 
07A1A:  MOV     15D6,W0
07A1C:  MOV     15D8,W1
07A1E:  MOV     #A,W2
07A20:  MOV     #0,W3
07A22:  CALL    6A8
07A26:  MOV     W0,15D6
07A28:  MOV     W1,15D8
.................... 					value_enco_d_end += RoboteQ_receiveBuffer[i]-0x30;			 
07A2A:  MOV     1B74,W4
07A2C:  LSR     W4,#8,W4
07A2E:  MOV     #882,W3
07A30:  ADD     W4,W3,W0
07A32:  MOV.B   [W0],W5L
07A34:  SE      W5,W5
07A36:  MOV     #30,W4
07A38:  SUB     W5,W4,W0
07A3A:  CLR     W1
07A3C:  BTSC    W0.F
07A3E:  SETM    W1
07A40:  ADD     15D6
07A42:  MOV     15D8,W4
07A44:  ADDC    W1,W4,W0
07A46:  MOV     W0,15D8
.................... 				} 
.................... 			} 
.................... 			i++;		 
07A48:  INC.B   1B75
07A4A:  GOTO    79A6
.................... 		} 
.................... 		if(flag_inverted)//si l'on a recu un nbre d'impulses negatifs 
07A4E:  BTSS.B  1B76.0
07A50:  BRA     7A7E
.................... 		{ 
.................... 			if(start_end) 
07A52:  CP0.B   1B74
07A54:  BRA     Z,7A6C
.................... 			{ 
.................... 				value_enco_d_start = 0-value_enco_d_start;// on inverse tout 
07A56:  MOV     #0,W4
07A58:  MOV     15CE,W3
07A5A:  SUB     W4,W3,W0
07A5C:  MOV     W0,15CE
07A5E:  MOV     #0,W4
07A60:  MOV     15D0,W3
07A62:  SUBB    W4,W3,W0
07A64:  MOV     W0,15D0
.................... 				flag_inverted = 0; 
07A66:  BCLR.B  1B76.0
.................... 			} 
07A68:  GOTO    7A7E
.................... 			else 
.................... 			{ 
.................... 				value_enco_d_end = 0-value_enco_d_end;// on inverse tout 
07A6C:  MOV     #0,W4
07A6E:  MOV     15D6,W3
07A70:  SUB     W4,W3,W0
07A72:  MOV     W0,15D6
07A74:  MOV     #0,W4
07A76:  MOV     15D8,W3
07A78:  SUBB    W4,W3,W0
07A7A:  MOV     W0,15D8
.................... 				flag_inverted = 0; 
07A7C:  BCLR.B  1B76.0
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	if(!start_end) 
07A7E:  CP0.B   1B74
07A80:  BRA     NZ,7AB0
.................... 	{ 
.................... 		Dist_Do = ((value_enco_g_end-value_enco_g_start)+(value_enco_d_end-value_enco_d_start))/2; // calcul distance parcourue 
07A82:  MOV     15D2,W4
07A84:  MOV     15CA,W3
07A86:  SUB     W4,W3,W5
07A88:  MOV     15D4,W4
07A8A:  MOV     15CC,W3
07A8C:  SUBB    W4,W3,W6
07A8E:  MOV     15D6,W4
07A90:  MOV     15CE,W3
07A92:  SUB     W4,W3,W0
07A94:  MOV     15D8,W4
07A96:  MOV     15D0,W3
07A98:  SUBB    W4,W3,W1
07A9A:  ADD     W0,W5,W5
07A9C:  ADDC    W1,W6,W6
07A9E:  BCLR.B  43.0
07AA0:  MOV     W5,W0
07AA2:  MOV     W6,W1
07AA4:  MOV     #2,W2
07AA6:  MOV     #0,W3
07AA8:  CALL    780C
07AAC:  MOV     W0,15C6
07AAE:  MOV     W1,15C8
.................... 	} 
07AB0:  MOV     [--W15],W6
07AB2:  MOV     [--W15],W5
07AB4:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Actual_pos(void) 
.................... * \brief Actualise la position xy du robot s'il doit switcher d'objectifs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] - 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __actual_pos(void) 
*
09D46:  MOV     W5,[W15++]
09D48:  MOV     W6,[W15++]
09D4A:  MOV     W7,[W15++]
09D4C:  MOV     W8,[W15++]
09D4E:  CLR     1B32
09D50:  CLR     1B34
09D52:  CLR     1B36
09D54:  CLR     1B38
09D56:  CLR     1B3A
09D58:  CLR     1B3C
.................... { 
.................... 	signed int32 Dist_Do_mm = 0; 
.................... 	signed int32 dx = 0; 
.................... 	signed int32 dy = 0; 
.................... 	__Get_enco_value(0); // recuperation delta x,y 
09D5A:  CLR.B   1B74
09D5C:  CALL    788A
.................... 							 
.................... 	Dist_Do_mm = (signed int32)(Dist_Do/(COEFF_D/10)); 
09D60:  MOV     15B4,W0
09D62:  MOV     15B6,W1
09D64:  MOV     15B8,W2
09D66:  MOV     15BA,W3
09D68:  MOV     #0,W4
09D6A:  MOV     #0,W5
09D6C:  MOV     #0,W6
09D6E:  MOV     #4024,W7
09D70:  CALL    D5A
09D74:  MOV     W0,W5
09D76:  MOV     W1,W6
09D78:  MOV     W2,W7
09D7A:  MOV     W3,W8
09D7C:  MOV     15C6,W0
09D7E:  MOV     15C8,W1
09D80:  CLR     W3
09D82:  BTSC    W1.F
09D84:  SETM    W3
09D86:  MOV     W3,W2
09D88:  CALL    1B2C
09D8C:  MOV     W5,[W15++]
09D8E:  MOV     W6,[W15++]
09D90:  MOV     W7,[W15++]
09D92:  MOV     W5,W4
09D94:  MOV     W6,W5
09D96:  MOV     W7,W6
09D98:  MOV     W8,W7
09D9A:  CALL    D5A
09D9E:  MOV     [--W15],W7
09DA0:  MOV     [--W15],W6
09DA2:  MOV     [--W15],W5
09DA4:  CALL    2230
09DA8:  MOV     W0,1B32
09DAA:  MOV     W1,1B34
.................... 	///////////////////////// Calcul dx,dy //////////////////////////// 
.................... 	if(0 <= Orient && Orient <= PI)//entre 0 et 180deg 
09DAC:  MOV     #0,W0
09DAE:  MOV     #0,W1
09DB0:  MOV     #0,W2
09DB2:  MOV     #0,W3
09DB4:  MOV     1594,W4
09DB6:  MOV     1596,W5
09DB8:  MOV     1598,W6
09DBA:  MOV     159A,W7
09DBC:  CALL    1E2E
09DC0:  BRA     C,9DC4
09DC2:  BRA     NZ,9E94
09DC4:  MOV     1594,W0
09DC6:  MOV     1596,W1
09DC8:  MOV     1598,W2
09DCA:  MOV     159A,W3
09DCC:  MOV     #2D18,W4
09DCE:  MOV     #5444,W5
09DD0:  MOV     #21FB,W6
09DD2:  MOV     #4009,W7
09DD4:  CALL    1E2E
09DD8:  BRA     C,9DDC
09DDA:  BRA     NZ,9E94
.................... 	{ 
.................... 		dx =  (signed int16)(cos(Orient) * Dist_Do_mm); 
09DDC:  PUSH    1594
09DDE:  POP     1B62
09DE0:  PUSH    1596
09DE2:  POP     1B64
09DE4:  PUSH    1598
09DE6:  POP     1B66
09DE8:  PUSH    159A
09DEA:  POP     1B68
09DEC:  CALL    877E
09DF0:  MOV     W0,W5
09DF2:  MOV     W1,W6
09DF4:  MOV     W2,W7
09DF6:  MOV     W3,W8
09DF8:  MOV     1B32,W0
09DFA:  MOV     1B34,W1
09DFC:  CLR     W3
09DFE:  BTSC    W1.F
09E00:  SETM    W3
09E02:  MOV     W3,W2
09E04:  CALL    1B2C
09E08:  MOV     W5,[W15++]
09E0A:  MOV     W6,[W15++]
09E0C:  MOV     W7,[W15++]
09E0E:  MOV     W0,W4
09E10:  MOV     W5,W0
09E12:  MOV     W1,W5
09E14:  MOV     W6,W1
09E16:  MOV     W2,W6
09E18:  MOV     W7,W2
09E1A:  MOV     W3,W7
09E1C:  MOV     W8,W3
09E1E:  CALL    C4A
09E22:  MOV     [--W15],W7
09E24:  MOV     [--W15],W6
09E26:  MOV     [--W15],W5
09E28:  CALL    2230
09E2C:  CLR     W1
09E2E:  BTSC    W0.F
09E30:  SETM    W1
09E32:  MOV     W0,1B36
09E34:  MOV     W1,1B38
.................... 		dy =  (signed int16)(sin(Orient) * Dist_Do_mm);	 
09E36:  PUSH    1594
09E38:  POP     1B50
09E3A:  PUSH    1596
09E3C:  POP     1B52
09E3E:  PUSH    1598
09E40:  POP     1B54
09E42:  PUSH    159A
09E44:  POP     1B56
09E46:  CALL    8A38
09E4A:  MOV     W0,W5
09E4C:  MOV     W1,W6
09E4E:  MOV     W2,W7
09E50:  MOV     W3,W8
09E52:  MOV     1B32,W0
09E54:  MOV     1B34,W1
09E56:  CLR     W3
09E58:  BTSC    W1.F
09E5A:  SETM    W3
09E5C:  MOV     W3,W2
09E5E:  CALL    1B2C
09E62:  MOV     W5,[W15++]
09E64:  MOV     W6,[W15++]
09E66:  MOV     W7,[W15++]
09E68:  MOV     W0,W4
09E6A:  MOV     W5,W0
09E6C:  MOV     W1,W5
09E6E:  MOV     W6,W1
09E70:  MOV     W2,W6
09E72:  MOV     W7,W2
09E74:  MOV     W3,W7
09E76:  MOV     W8,W3
09E78:  CALL    C4A
09E7C:  MOV     [--W15],W7
09E7E:  MOV     [--W15],W6
09E80:  MOV     [--W15],W5
09E82:  CALL    2230
09E86:  CLR     W1
09E88:  BTSC    W0.F
09E8A:  SETM    W1
09E8C:  MOV     W0,1B3A
09E8E:  MOV     W1,1B3C
.................... 	} 
09E90:  GOTO    A12C
.................... 	else if(( (Orient>PI) && ((3*PI)/2 >= Orient)) || (Orient <= (-PI/2) && Orient > -PI))//180 et 270deg 
09E94:  MOV     #2D18,W0
09E96:  MOV     #5444,W1
09E98:  MOV     #21FB,W2
09E9A:  MOV     #4009,W3
09E9C:  MOV     1594,W4
09E9E:  MOV     1596,W5
09EA0:  MOV     1598,W6
09EA2:  MOV     159A,W7
09EA4:  CALL    1E2E
09EA8:  BRA     NC,9EC2
09EAA:  MOV     1594,W0
09EAC:  MOV     1596,W1
09EAE:  MOV     1598,W2
09EB0:  MOV     159A,W3
09EB2:  MOV     #21D2,W4
09EB4:  MOV     #7F33,W5
09EB6:  MOV     #D97C,W6
09EB8:  MOV     #4012,W7
09EBA:  CALL    1E2E
09EBE:  BRA     C,9EF0
09EC0:  BRA     Z,9EF0
09EC2:  MOV     1594,W0
09EC4:  MOV     1596,W1
09EC6:  MOV     1598,W2
09EC8:  MOV     159A,W3
09ECA:  MOV     #2D18,W4
09ECC:  MOV     #5444,W5
09ECE:  MOV     #21FB,W6
09ED0:  MOV     #BFF9,W7
09ED2:  CALL    1E2E
09ED6:  BRA     C,9EDA
09ED8:  BRA     NZ,9FE4
09EDA:  MOV     #2D18,W0
09EDC:  MOV     #5444,W1
09EDE:  MOV     #21FB,W2
09EE0:  MOV     #C009,W3
09EE2:  MOV     1594,W4
09EE4:  MOV     1596,W5
09EE6:  MOV     1598,W6
09EE8:  MOV     159A,W7
09EEA:  CALL    1E2E
09EEE:  BRA     NC,9FE4
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm; 
09EF0:  MOV     #0,W4
09EF2:  MOV     1B32,W3
09EF4:  SUB     W4,W3,W0
09EF6:  MOV     W0,1B32
09EF8:  MOV     #0,W4
09EFA:  MOV     1B34,W3
09EFC:  SUBB    W4,W3,W0
09EFE:  MOV     W0,1B34
.................... 		dx = (signed int16)(sin(3*(PI/2)-Orient) * Dist_Do_mm); 
09F00:  BSET.B  43.0
09F02:  MOV     #21D2,W0
09F04:  MOV     #7F33,W1
09F06:  MOV     #D97C,W2
09F08:  MOV     #4012,W3
09F0A:  MOV     1594,W4
09F0C:  MOV     1596,W5
09F0E:  MOV     1598,W6
09F10:  MOV     159A,W7
09F12:  CALL    1C40
09F16:  MOV     W0,W5
09F18:  MOV     W1,W6
09F1A:  MOV     W2,W7
09F1C:  MOV     W3,W8
09F1E:  MOV     W5,1B50
09F20:  MOV     W6,1B52
09F22:  MOV     W7,1B54
09F24:  MOV     W8,1B56
09F26:  CALL    8A38
09F2A:  MOV     W0,W5
09F2C:  MOV     W1,W6
09F2E:  MOV     W2,W7
09F30:  MOV     W3,W8
09F32:  MOV     1B32,W0
09F34:  MOV     1B34,W1
09F36:  CLR     W3
09F38:  BTSC    W1.F
09F3A:  SETM    W3
09F3C:  MOV     W3,W2
09F3E:  CALL    1B2C
09F42:  MOV     W5,[W15++]
09F44:  MOV     W6,[W15++]
09F46:  MOV     W7,[W15++]
09F48:  MOV     W0,W4
09F4A:  MOV     W5,W0
09F4C:  MOV     W1,W5
09F4E:  MOV     W6,W1
09F50:  MOV     W2,W6
09F52:  MOV     W7,W2
09F54:  MOV     W3,W7
09F56:  MOV     W8,W3
09F58:  CALL    C4A
09F5C:  MOV     [--W15],W7
09F5E:  MOV     [--W15],W6
09F60:  MOV     [--W15],W5
09F62:  CALL    2230
09F66:  CLR     W1
09F68:  BTSC    W0.F
09F6A:  SETM    W1
09F6C:  MOV     W0,1B36
09F6E:  MOV     W1,1B38
.................... 		dy = (signed int16)(cos(3*(PI/2)-Orient) * Dist_Do_mm); 
09F70:  BSET.B  43.0
09F72:  MOV     #21D2,W0
09F74:  MOV     #7F33,W1
09F76:  MOV     #D97C,W2
09F78:  MOV     #4012,W3
09F7A:  MOV     1594,W4
09F7C:  MOV     1596,W5
09F7E:  MOV     1598,W6
09F80:  MOV     159A,W7
09F82:  CALL    1C40
09F86:  MOV     W0,W5
09F88:  MOV     W1,W6
09F8A:  MOV     W2,W7
09F8C:  MOV     W3,W8
09F8E:  MOV     W5,1B62
09F90:  MOV     W6,1B64
09F92:  MOV     W7,1B66
09F94:  MOV     W8,1B68
09F96:  CALL    877E
09F9A:  MOV     W0,W5
09F9C:  MOV     W1,W6
09F9E:  MOV     W2,W7
09FA0:  MOV     W3,W8
09FA2:  MOV     1B32,W0
09FA4:  MOV     1B34,W1
09FA6:  CLR     W3
09FA8:  BTSC    W1.F
09FAA:  SETM    W3
09FAC:  MOV     W3,W2
09FAE:  CALL    1B2C
09FB2:  MOV     W5,[W15++]
09FB4:  MOV     W6,[W15++]
09FB6:  MOV     W7,[W15++]
09FB8:  MOV     W0,W4
09FBA:  MOV     W5,W0
09FBC:  MOV     W1,W5
09FBE:  MOV     W6,W1
09FC0:  MOV     W2,W6
09FC2:  MOV     W7,W2
09FC4:  MOV     W3,W7
09FC6:  MOV     W8,W3
09FC8:  CALL    C4A
09FCC:  MOV     [--W15],W7
09FCE:  MOV     [--W15],W6
09FD0:  MOV     [--W15],W5
09FD2:  CALL    2230
09FD6:  CLR     W1
09FD8:  BTSC    W0.F
09FDA:  SETM    W1
09FDC:  MOV     W0,1B3A
09FDE:  MOV     W1,1B3C
.................... 	} 
09FE0:  GOTO    A12C
.................... 	else if(((Orient>(3*PI/2)) && (Orient < (2*PI))) || (Orient < 0 && Orient > (-PI/2)))//270deg et 360deg 
09FE4:  MOV     #21D2,W0
09FE6:  MOV     #7F33,W1
09FE8:  MOV     #D97C,W2
09FEA:  MOV     #4012,W3
09FEC:  MOV     1594,W4
09FEE:  MOV     1596,W5
09FF0:  MOV     1598,W6
09FF2:  MOV     159A,W7
09FF4:  CALL    1E2E
09FF8:  BRA     NC,A010
09FFA:  MOV     1594,W0
09FFC:  MOV     1596,W1
09FFE:  MOV     1598,W2
0A000:  MOV     159A,W3
0A002:  MOV     #2D18,W4
0A004:  MOV     #5444,W5
0A006:  MOV     #21FB,W6
0A008:  MOV     #4019,W7
0A00A:  CALL    1E2E
0A00E:  BRA     C,A03C
0A010:  MOV     1594,W0
0A012:  MOV     1596,W1
0A014:  MOV     1598,W2
0A016:  MOV     159A,W3
0A018:  MOV     #0,W4
0A01A:  MOV     #0,W5
0A01C:  MOV     #0,W6
0A01E:  MOV     #0,W7
0A020:  CALL    1E2E
0A024:  BRA     NC,A12C
0A026:  MOV     #2D18,W0
0A028:  MOV     #5444,W1
0A02A:  MOV     #21FB,W2
0A02C:  MOV     #BFF9,W3
0A02E:  MOV     1594,W4
0A030:  MOV     1596,W5
0A032:  MOV     1598,W6
0A034:  MOV     159A,W7
0A036:  CALL    1E2E
0A03A:  BRA     NC,A12C
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm;  
0A03C:  MOV     #0,W4
0A03E:  MOV     1B32,W3
0A040:  SUB     W4,W3,W0
0A042:  MOV     W0,1B32
0A044:  MOV     #0,W4
0A046:  MOV     1B34,W3
0A048:  SUBB    W4,W3,W0
0A04A:  MOV     W0,1B34
.................... 		dx = (signed int16)(sin(-(PI/2)-Orient) * Dist_Do_mm); 
0A04C:  BSET.B  43.0
0A04E:  MOV     #2D18,W0
0A050:  MOV     #5444,W1
0A052:  MOV     #21FB,W2
0A054:  MOV     #BFF9,W3
0A056:  MOV     1594,W4
0A058:  MOV     1596,W5
0A05A:  MOV     1598,W6
0A05C:  MOV     159A,W7
0A05E:  CALL    1C40
0A062:  MOV     W0,W5
0A064:  MOV     W1,W6
0A066:  MOV     W2,W7
0A068:  MOV     W3,W8
0A06A:  MOV     W5,1B50
0A06C:  MOV     W6,1B52
0A06E:  MOV     W7,1B54
0A070:  MOV     W8,1B56
0A072:  CALL    8A38
0A076:  MOV     W0,W5
0A078:  MOV     W1,W6
0A07A:  MOV     W2,W7
0A07C:  MOV     W3,W8
0A07E:  MOV     1B32,W0
0A080:  MOV     1B34,W1
0A082:  CLR     W3
0A084:  BTSC    W1.F
0A086:  SETM    W3
0A088:  MOV     W3,W2
0A08A:  CALL    1B2C
0A08E:  MOV     W5,[W15++]
0A090:  MOV     W6,[W15++]
0A092:  MOV     W7,[W15++]
0A094:  MOV     W0,W4
0A096:  MOV     W5,W0
0A098:  MOV     W1,W5
0A09A:  MOV     W6,W1
0A09C:  MOV     W2,W6
0A09E:  MOV     W7,W2
0A0A0:  MOV     W3,W7
0A0A2:  MOV     W8,W3
0A0A4:  CALL    C4A
0A0A8:  MOV     [--W15],W7
0A0AA:  MOV     [--W15],W6
0A0AC:  MOV     [--W15],W5
0A0AE:  CALL    2230
0A0B2:  CLR     W1
0A0B4:  BTSC    W0.F
0A0B6:  SETM    W1
0A0B8:  MOV     W0,1B36
0A0BA:  MOV     W1,1B38
.................... 		dy = (signed int16)(cos(-(PI/2)-Orient) * Dist_Do_mm); 
0A0BC:  BSET.B  43.0
0A0BE:  MOV     #2D18,W0
0A0C0:  MOV     #5444,W1
0A0C2:  MOV     #21FB,W2
0A0C4:  MOV     #BFF9,W3
0A0C6:  MOV     1594,W4
0A0C8:  MOV     1596,W5
0A0CA:  MOV     1598,W6
0A0CC:  MOV     159A,W7
0A0CE:  CALL    1C40
0A0D2:  MOV     W0,W5
0A0D4:  MOV     W1,W6
0A0D6:  MOV     W2,W7
0A0D8:  MOV     W3,W8
0A0DA:  MOV     W5,1B62
0A0DC:  MOV     W6,1B64
0A0DE:  MOV     W7,1B66
0A0E0:  MOV     W8,1B68
0A0E2:  CALL    877E
0A0E6:  MOV     W0,W5
0A0E8:  MOV     W1,W6
0A0EA:  MOV     W2,W7
0A0EC:  MOV     W3,W8
0A0EE:  MOV     1B32,W0
0A0F0:  MOV     1B34,W1
0A0F2:  CLR     W3
0A0F4:  BTSC    W1.F
0A0F6:  SETM    W3
0A0F8:  MOV     W3,W2
0A0FA:  CALL    1B2C
0A0FE:  MOV     W5,[W15++]
0A100:  MOV     W6,[W15++]
0A102:  MOV     W7,[W15++]
0A104:  MOV     W0,W4
0A106:  MOV     W5,W0
0A108:  MOV     W1,W5
0A10A:  MOV     W6,W1
0A10C:  MOV     W2,W6
0A10E:  MOV     W7,W2
0A110:  MOV     W3,W7
0A112:  MOV     W8,W3
0A114:  CALL    C4A
0A118:  MOV     [--W15],W7
0A11A:  MOV     [--W15],W6
0A11C:  MOV     [--W15],W5
0A11E:  CALL    2230
0A122:  CLR     W1
0A124:  BTSC    W0.F
0A126:  SETM    W1
0A128:  MOV     W0,1B3A
0A12A:  MOV     W1,1B3C
.................... 	} 
.................... 	Pos_x = (signed int16)(Pos_x + dx); //mise a jour pos x 
0A12C:  MOV     1586,W0
0A12E:  CLR     W1
0A130:  BTSC    W0.F
0A132:  SETM    W1
0A134:  MOV     1B36,W4
0A136:  ADD     W0,W4,W0
0A138:  MOV     1B38,W4
0A13A:  ADDC    W1,W4,W1
0A13C:  MOV     W0,1586
.................... 	Pos_y = (signed int16)(Pos_y + dy);	//mise a jour pos y 
0A13E:  MOV     1588,W0
0A140:  CLR     W1
0A142:  BTSC    W0.F
0A144:  SETM    W1
0A146:  MOV     1B3A,W4
0A148:  ADD     W0,W4,W0
0A14A:  MOV     1B3C,W4
0A14C:  ADDC    W1,W4,W1
0A14E:  MOV     W0,1588
0A150:  MOV     [--W15],W8
0A152:  MOV     [--W15],W7
0A154:  MOV     [--W15],W6
0A156:  MOV     [--W15],W5
0A158:  RETURN  
.................... } 
.................... /* 
.................... 	Borgeat Rémy 
....................  
.................... 	20.2.2017 
....................  
.................... 	Initialise la postion de départ du robot. 
.................... 	Gere le cote duquel se trouve le robot 
.................... */ 
.................... void __Init_pos(void) 
*
01B96:  MOV     W5,[W15++]
01B98:  MOV     W6,[W15++]
01B9A:  MOV     W7,[W15++]
01B9C:  MOV     W8,[W15++]
.................... { 
.................... 	Pos_x = read_eeprom(800); 
01B9E:  MOV     #320,W3
01BA0:  MOV     #0,W4
01BA2:  MOV     #2,W5
01BA4:  CALL    1A7A
01BA8:  MOV     W0,1586
.................... 	Pos_y = read_eeprom(802); 
01BAA:  MOV     #322,W3
01BAC:  MOV     #0,W4
01BAE:  MOV     #2,W5
01BB0:  CALL    1A7A
01BB4:  MOV     W0,1588
.................... 	Orient_deg = read_eeprom(804); 
01BB6:  MOV     #324,W3
01BB8:  MOV     #0,W4
01BBA:  MOV     #2,W5
01BBC:  CALL    1A7A
01BC0:  MOV     W0,158A
....................  
.................... 	//si on est de l'autre cote du terrain 
.................... 	if(TEAM) 
01BC2:  BTSS.B  85B.3
01BC4:  BRA     1BEA
.................... 	{ 
.................... 		Pos_x = TableWidth-Pos_x; 
01BC6:  MOV     87E,W4
01BC8:  MOV     1586,W3
01BCA:  SUB     W4,W3,W0
01BCC:  MOV     W0,1586
.................... 		if(Orient_deg<=180)Orient_deg=180-Orient_deg ; 
01BCE:  MOV     158A,W4
01BD0:  MOV     #B4,W3
01BD2:  CP      W3,W4
01BD4:  BRA     LT,1BE2
01BD6:  MOV     #B4,W4
01BD8:  MOV     158A,W3
01BDA:  SUB     W4,W3,W0
01BDC:  MOV     W0,158A
01BDE:  GOTO    1BEA
.................... 		else Orient_deg = 540 - Orient_deg ; 
01BE2:  MOV     #21C,W4
01BE4:  MOV     158A,W3
01BE6:  SUB     W4,W3,W0
01BE8:  MOV     W0,158A
.................... 	}		 
.................... 	Orient = (float64)(Orient_deg*PI/180); 
01BEA:  MOV     158A,W0
01BEC:  CLR     W3
01BEE:  BTSC    W0.F
01BF0:  SETM    W3
01BF2:  MOV     W3,W1
01BF4:  MOV     W3,W2
01BF6:  CALL    1B2C
01BFA:  MOV     #2D18,W4
01BFC:  MOV     #5444,W5
01BFE:  MOV     #21FB,W6
01C00:  MOV     #4009,W7
01C02:  CALL    C4A
01C06:  MOV     W0,W5
01C08:  MOV     W1,W6
01C0A:  MOV     W2,W7
01C0C:  MOV     W3,W8
01C0E:  MOV     W5,[W15++]
01C10:  MOV     W6,[W15++]
01C12:  MOV     W7,[W15++]
01C14:  MOV     W5,W0
01C16:  MOV     W6,W1
01C18:  MOV     W7,W2
01C1A:  MOV     W8,W3
01C1C:  MOV     #0,W4
01C1E:  MOV     #0,W5
01C20:  MOV     #8000,W6
01C22:  MOV     #4066,W7
01C24:  CALL    D5A
01C28:  MOV     [--W15],W7
01C2A:  MOV     [--W15],W6
01C2C:  MOV     [--W15],W5
01C2E:  MOV     W0,1594
01C30:  MOV     W1,1596
01C32:  MOV     W2,1598
01C34:  MOV     W3,159A
01C36:  MOV     [--W15],W8
01C38:  MOV     [--W15],W7
01C3A:  MOV     [--W15],W6
01C3C:  MOV     [--W15],W5
01C3E:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __Action_Writting(unsigned int8 _Command) 
.................... * \brief Demande d'Ã©criture, entre 0x00 et 0x79. 
.................... * 
.................... * \author Barman Corentin / rev. Amand Axel 
.................... * \version 2.0 
.................... * \date 19.11.2015 
.................... * 
.................... * \param[in] _Command Choisit la commande Ã  effectuer 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __DeplToDo(unsigned int8 _Command) 
.................... { 
.................... 	switch(_Command) 
*
08E08:  MOV.B   1B32,W0L
08E0A:  CLR.B   1
08E0C:  XOR     #0,W0
08E0E:  BRA     Z,8E1E
08E10:  XOR     #1,W0
08E12:  BRA     Z,8E2A
08E14:  XOR     #3,W0
08E16:  BRA     Z,8E3A
08E18:  XOR     #1,W0
08E1A:  BRA     Z,8E4A
08E1C:  BRA     8E52
.................... 	{ 
.................... 		// !!! En ajoutant des types de dÃ©placement, 
.................... 		//		pensez Ã  les gÃ©rer dans __LoadObj() tout en bas du fichier. 
.................... 		//		Comme le X est par exemple utiliser pour donner un angle, 
.................... 		//		si comme un dÃ©pl. PÃ P vous faÃ®tes TailleTable - X .... 
.................... 		//		Autant dire que le robot va faire n'importe quoi ^^ 
.................... 		case 0 : 
.................... 			__Turn((signed int16) oXp);			 
08E1E:  PUSH    1492
08E20:  POP     1B34
08E22:  CALL    700C
.................... 			break; 
08E26:  GOTO    8E5E
.................... 		case 1 : 
.................... 			__PaP(oXp, oYp); 
08E2A:  PUSH    1492
08E2C:  POP     1B38
08E2E:  PUSH    1494
08E30:  POP     1B3A
08E32:  CALL    7AF0
.................... 			break; 
08E36:  GOTO    8E5E
.................... 		case 2 : 
.................... 			__Progress(oXp, oYp); //se déplace d'une certaine distance, jusqu'a ce qu'on tape dans un bord, ou que l'ordre soit fini 
08E3A:  PUSH    1492
08E3C:  POP     1B34
08E3E:  PUSH    1494
08E40:  POP     1B36
08E42:  CALL    8A74
.................... 			break; 
08E46:  GOTO    8E5E
.................... 		case 3 : 
.................... 			__Nothing(); 
08E4A:  CALL    8E00
.................... 			break; 
08E4E:  GOTO    8E5E
.................... 		default: 
.................... 			__Affichage_erreur(4); 
08E52:  MOV.B   #4,W0L
08E54:  MOV.B   W0L,1B3A
08E56:  CALL    107A
.................... 			break; 
08E5A:  GOTO    8E5E
.................... 	} 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
08E5E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Turn(signed int16 _Ang) 
.................... * \brief Tourne sur place jusqu'a l'angle donne. 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] Angle d'arrive  
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Turn(signed int16 _Ang) 
*
0700C:  MOV     W5,[W15++]
0700E:  MOV     W6,[W15++]
07010:  MOV     W7,[W15++]
07012:  MOV     W8,[W15++]
07014:  CLR     1B36
07016:  CLR     1B38
07018:  CLR     1B3A
0701A:  CLR     1B3C
0701C:  CLR     1B3E
0701E:  CLR     1B40
07020:  CLR     1B42
07022:  CLR     1B44
07024:  CLR     1B46
07026:  CLR     1B48
07028:  CLR     1B4A
0702A:  CLR     1B4C
0702C:  CLR     1B4E
0702E:  CLR     1B50
.................... { 
.................... 	float64 AngToDo = 0;			 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer en nombre d'impulses 
.................... 	signed int32 impulse_g = 0; 	//impulse mot g 
.................... 	signed int32 impulse_d = 0;		//impulse mot d 
.................... 	float64 temporaire = 0; 
....................  
.................... 	// Convertit la valeur de l'angle en radian 
.................... 	AngToDo = (_Ang * CONV_DEG_RAD) - Orient ; 
07030:  MOV     1B34,W0
07032:  CLR     W3
07034:  BTSC    W0.F
07036:  SETM    W3
07038:  MOV     W3,W1
0703A:  MOV     W3,W2
0703C:  CALL    1B2C
07040:  MOV     15BC,W4
07042:  MOV     15BE,W5
07044:  MOV     15C0,W6
07046:  MOV     15C2,W7
07048:  CALL    C4A
0704C:  MOV     W0,W5
0704E:  MOV     W1,W6
07050:  MOV     W2,W7
07052:  MOV     W3,W8
07054:  BSET.B  43.0
07056:  MOV     W5,[W15++]
07058:  MOV     W6,[W15++]
0705A:  MOV     W7,[W15++]
0705C:  MOV     W5,W0
0705E:  MOV     W6,W1
07060:  MOV     W7,W2
07062:  MOV     W8,W3
07064:  MOV     1594,W4
07066:  MOV     1596,W5
07068:  MOV     1598,W6
0706A:  MOV     159A,W7
0706C:  CALL    1C40
07070:  MOV     [--W15],W7
07072:  MOV     [--W15],W6
07074:  MOV     [--W15],W5
07076:  MOV     W0,1B36
07078:  MOV     W1,1B38
0707A:  MOV     W2,1B3A
0707C:  MOV     W3,1B3C
....................  
.................... 	if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
0707E:  MOV     149A,W4
07080:  CP      W4,#2
07082:  BRA     NZ,70BC
07084:  MOV     #0,W0
07086:  MOV     #0,W1
07088:  MOV     #0,W2
0708A:  MOV     #0,W3
0708C:  MOV     1B36,W4
0708E:  MOV     1B38,W5
07090:  MOV     1B3A,W6
07092:  MOV     1B3C,W7
07094:  CALL    1E2E
07098:  BRA     NC,70BC
.................... 	{ 
.................... 		AngToDo += -2 * PI; //on tourne sur la gauche 
0709A:  BCLR.B  43.0
0709C:  MOV     1B36,W0
0709E:  MOV     1B38,W1
070A0:  MOV     1B3A,W2
070A2:  MOV     1B3C,W3
070A4:  MOV     #2D18,W4
070A6:  MOV     #5444,W5
070A8:  MOV     #21FB,W6
070AA:  MOV     #C019,W7
070AC:  CALL    1C40
070B0:  MOV     W0,1B36
070B2:  MOV     W1,1B38
070B4:  MOV     W2,1B3A
070B6:  MOV     W3,1B3C
.................... 	}	 
070B8:  GOTO    70F6
.................... 	else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
070BC:  MOV     149A,W4
070BE:  CP      W4,#1
070C0:  BRA     NZ,70F6
070C2:  MOV     1B36,W0
070C4:  MOV     1B38,W1
070C6:  MOV     1B3A,W2
070C8:  MOV     1B3C,W3
070CA:  MOV     #0,W4
070CC:  MOV     #0,W5
070CE:  MOV     #0,W6
070D0:  MOV     #0,W7
070D2:  CALL    1E2E
070D6:  BRA     NC,70F6
.................... 	{ 
.................... 		AngToDo += 2 * PI;//On tourne sur la droite	 
070D8:  BCLR.B  43.0
070DA:  MOV     1B36,W0
070DC:  MOV     1B38,W1
070DE:  MOV     1B3A,W2
070E0:  MOV     1B3C,W3
070E2:  MOV     #2D18,W4
070E4:  MOV     #5444,W5
070E6:  MOV     #21FB,W6
070E8:  MOV     #4019,W7
070EA:  CALL    1C40
070EE:  MOV     W0,1B36
070F0:  MOV     W1,1B38
070F2:  MOV     W2,1B3A
070F4:  MOV     W3,1B3C
.................... 	} 
.................... 	 
.................... 	if(AngToDo > PI && oCoteTourn==0) // on a plus de 180Â° 
070F6:  MOV     #2D18,W0
070F8:  MOV     #5444,W1
070FA:  MOV     #21FB,W2
070FC:  MOV     #4009,W3
070FE:  MOV     1B36,W4
07100:  MOV     1B38,W5
07102:  MOV     1B3A,W6
07104:  MOV     1B3C,W7
07106:  CALL    1E2E
0710A:  BRA     NC,7132
0710C:  CP0     149A
0710E:  BRA     NZ,7132
.................... 	{ 
.................... 		AngToDo -= 2*PI; // on tourne ds l'autre sens 
07110:  BSET.B  43.0
07112:  MOV     1B36,W0
07114:  MOV     1B38,W1
07116:  MOV     1B3A,W2
07118:  MOV     1B3C,W3
0711A:  MOV     #2D18,W4
0711C:  MOV     #5444,W5
0711E:  MOV     #21FB,W6
07120:  MOV     #4019,W7
07122:  CALL    1C40
07126:  MOV     W0,1B36
07128:  MOV     W1,1B38
0712A:  MOV     W2,1B3A
0712C:  MOV     W3,1B3C
.................... 	} 
0712E:  GOTO    716A
.................... 	else if(AngToDo < -PI  && oCoteTourn==0) // si on moins que -180Â°   
07132:  MOV     1B36,W0
07134:  MOV     1B38,W1
07136:  MOV     1B3A,W2
07138:  MOV     1B3C,W3
0713A:  MOV     #2D18,W4
0713C:  MOV     #5444,W5
0713E:  MOV     #21FB,W6
07140:  MOV     #C009,W7
07142:  CALL    1E2E
07146:  BRA     NC,716A
07148:  CP0     149A
0714A:  BRA     NZ,716A
.................... 	{ 
.................... 		AngToDo += 2 * PI; // on tourne ds l'autre sens 
0714C:  BCLR.B  43.0
0714E:  MOV     1B36,W0
07150:  MOV     1B38,W1
07152:  MOV     1B3A,W2
07154:  MOV     1B3C,W3
07156:  MOV     #2D18,W4
07158:  MOV     #5444,W5
0715A:  MOV     #21FB,W6
0715C:  MOV     #4019,W7
0715E:  CALL    1C40
07162:  MOV     W0,1B36
07164:  MOV     W1,1B38
07166:  MOV     W2,1B3A
07168:  MOV     W3,1B3C
.................... 	}	 
....................  
.................... 	if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
0716A:  MOV     #432D,W0
0716C:  MOV     #EB1C,W1
0716E:  MOV     #36E2,W2
07170:  MOV     #BF1A,W3
07172:  MOV     1B36,W4
07174:  MOV     1B38,W5
07176:  MOV     1B3A,W6
07178:  MOV     1B3C,W7
0717A:  CALL    1E2E
0717E:  BRA     NC,719E
07180:  MOV     1B36,W0
07182:  MOV     1B38,W1
07184:  MOV     1B3A,W2
07186:  MOV     1B3C,W3
07188:  MOV     #432D,W4
0718A:  MOV     #EB1C,W5
0718C:  MOV     #36E2,W6
0718E:  MOV     #3F1A,W7
07190:  CALL    1E2E
07194:  BRA     NC,719E
07196:  CLR     1B36
07198:  CLR     1B38
0719A:  CLR     1B3A
0719C:  CLR     1B3C
.................... 	temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
0719E:  MOV     15AC,W0
071A0:  MOV     15AE,W1
071A2:  MOV     15B0,W2
071A4:  MOV     15B2,W3
071A6:  MOV     159C,W4
071A8:  MOV     159E,W5
071AA:  MOV     15A0,W6
071AC:  MOV     15A2,W7
071AE:  CALL    D5A
071B2:  MOV     W0,W4
071B4:  MOV     W1,W5
071B6:  MOV     W2,W6
071B8:  MOV     W3,W7
071BA:  MOV     1B36,W0
071BC:  MOV     1B38,W1
071BE:  MOV     1B3A,W2
071C0:  MOV     1B3C,W3
071C2:  CALL    C4A
071C6:  MOV     W0,W5
071C8:  MOV     W1,W6
071CA:  MOV     W2,W7
071CC:  MOV     W3,W8
071CE:  MOV     W5,[W15++]
071D0:  MOV     W6,[W15++]
071D2:  MOV     W7,[W15++]
071D4:  MOV     W5,W0
071D6:  MOV     W6,W1
071D8:  MOV     W7,W2
071DA:  MOV     W8,W3
071DC:  MOV     15A4,W4
071DE:  MOV     15A6,W5
071E0:  MOV     15A8,W6
071E2:  MOV     15AA,W7
071E4:  CALL    C4A
071E8:  MOV     [--W15],W7
071EA:  MOV     [--W15],W6
071EC:  MOV     [--W15],W5
071EE:  MOV     W0,W5
071F0:  MOV     W1,W6
071F2:  MOV     W2,W7
071F4:  MOV     W3,W8
071F6:  MOV     W5,[W15++]
071F8:  MOV     W6,[W15++]
071FA:  MOV     W7,[W15++]
071FC:  MOV     W5,W0
071FE:  MOV     W6,W1
07200:  MOV     W7,W2
07202:  MOV     W8,W3
07204:  MOV     #0,W4
07206:  MOV     #0,W5
07208:  MOV     #0,W6
0720A:  MOV     #4000,W7
0720C:  CALL    C4A
07210:  MOV     [--W15],W7
07212:  MOV     [--W15],W6
07214:  MOV     [--W15],W5
07216:  MOV     W0,W5
07218:  MOV     W1,W6
0721A:  MOV     W2,W7
0721C:  MOV     W3,W8
0721E:  MOV     W5,[W15++]
07220:  MOV     W6,[W15++]
07222:  MOV     W7,[W15++]
07224:  MOV     W5,W0
07226:  MOV     W6,W1
07228:  MOV     W7,W2
0722A:  MOV     W8,W3
0722C:  MOV     #2D18,W4
0722E:  MOV     #5444,W5
07230:  MOV     #21FB,W6
07232:  MOV     #4009,W7
07234:  CALL    D5A
07238:  MOV     [--W15],W7
0723A:  MOV     [--W15],W6
0723C:  MOV     [--W15],W5
0723E:  MOV     W0,1B4A
07240:  MOV     W1,1B4C
07242:  MOV     W2,1B4E
07244:  MOV     W3,1B50
.................... 	AngToDo_int = (signed int32)(arrondi_float_signed(temporaire));	 
07246:  MOV     1B4A,W0
07248:  MOV     1B4C,W1
0724A:  MOV     1B4E,W2
0724C:  MOV     1B50,W3
0724E:  CALL    684C
07252:  MOV     W1,W5
07254:  MOV     W2,W6
07256:  MOV     W5,1B7A
07258:  MOV     W6,1B7C
0725A:  CALL    6D9E
0725E:  MOV     W0,1B3E
07260:  MOV     W1,1B40
.................... 	// on envoie les donnee au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
07262:  MOV     #0,W1
07264:  MOV     W1,W0
07266:  CLR.B   1
07268:  CALL    136
0726C:  INC     W1,W1
0726E:  BTSC.B  219.1
07270:  BRA     726E
07272:  MOV     W0,21A
07274:  MOV     #4,W0
07276:  CPSGT   W1,W0
07278:  BRA     7264
0727A:  MOV     149C,W0
0727C:  MOV     #8004,W4
0727E:  CALL    6DFA
07282:  MOV     #9,W1
07284:  MOV     W1,W0
07286:  CLR.B   1
07288:  CALL    136
0728C:  INC     W1,W1
0728E:  BTSC.B  219.1
07290:  BRA     728E
07292:  MOV     W0,21A
07294:  MOV     #E,W0
07296:  CPSGT   W1,W0
07298:  BRA     7284
0729A:  MOV     149C,W0
0729C:  MOV     #8004,W4
0729E:  CALL    6DFA
072A2:  BTSC.B  219.1
072A4:  BRA     72A2
072A6:  MOV     #20,W4
072A8:  MOV     W4,21A
072AA:  BTSC.B  219.1
072AC:  BRA     72AA
072AE:  MOV     #D,W4
072B0:  MOV     W4,21A
.................... 	 
.................... 	//balise  
.................... 	balise_on = 0; 
072B2:  BCLR.B  85B.1
.................... 	 
.................... 	impulse_g = AngToDo_int; 
072B4:  PUSH    1B3E
072B6:  POP     1B42
072B8:  PUSH    1B40
072BA:  POP     1B44
.................... 	impulse_d = 0-AngToDo_int; 
072BC:  MOV     #0,W4
072BE:  MOV     1B3E,W3
072C0:  SUB     W4,W3,W0
072C2:  MOV     W0,1B46
072C4:  MOV     #0,W4
072C6:  MOV     1B40,W3
072C8:  SUBB    W4,W3,W0
072CA:  MOV     W0,1B48
.................... 	fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
072CC:  MOV     #0,W1
072CE:  MOV     W1,W0
072D0:  CLR.B   1
072D2:  CALL    158
072D6:  INC     W1,W1
072D8:  BTSC.B  219.1
072DA:  BRA     72D8
072DC:  MOV     W0,21A
072DE:  MOV     #5,W0
072E0:  CPSGT   W1,W0
072E2:  BRA     72CE
072E4:  MOV     1B42,W0
072E6:  MOV     1B44,W1
072E8:  MOV     #0,W4
072EA:  CALL    6EF4
072EE:  MOV     #8,W1
072F0:  MOV     W1,W0
072F2:  CLR.B   1
072F4:  CALL    158
072F8:  INC     W1,W1
072FA:  BTSC.B  219.1
072FC:  BRA     72FA
072FE:  MOV     W0,21A
07300:  MOV     #E,W0
07302:  CPSGT   W1,W0
07304:  BRA     72F0
07306:  MOV     1B46,W0
07308:  MOV     1B48,W1
0730A:  MOV     #0,W4
0730C:  CALL    6EF4
07310:  BTSC.B  219.1
07312:  BRA     7310
07314:  MOV     #20,W4
07316:  MOV     W4,21A
07318:  BTSC.B  219.1
0731A:  BRA     7318
0731C:  MOV     #D,W4
0731E:  MOV     W4,21A
.................... 	 
.................... 	Depl_send = 1; 
07320:  BSET.B  85B.5
.................... 	Orient = (float64)(_Ang * CONV_DEG_RAD); // mise à jour de l'angle 
07322:  MOV     1B34,W0
07324:  CLR     W3
07326:  BTSC    W0.F
07328:  SETM    W3
0732A:  MOV     W3,W1
0732C:  MOV     W3,W2
0732E:  CALL    1B2C
07332:  MOV     15BC,W4
07334:  MOV     15BE,W5
07336:  MOV     15C0,W6
07338:  MOV     15C2,W7
0733A:  CALL    C4A
0733E:  MOV     W0,1594
07340:  MOV     W1,1596
07342:  MOV     W2,1598
07344:  MOV     W3,159A
07346:  MOV     [--W15],W8
07348:  MOV     [--W15],W7
0734A:  MOV     [--W15],W6
0734C:  MOV     [--W15],W5
0734E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __PaP(signed int16 _X, signed int16 _Y) 
.................... * \brief Depl Pap du robot. 
.................... *		Le deplacement se fait tel que : 
.................... *			- Rotation vers le point a  atteindre 
.................... *			- Deplacement ligne droite 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] coordonee x,y de la pos d'arrivee 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __PaP(signed int16 _X, signed int16 _Y) 
*
07AF0:  MOV     W5,[W15++]
07AF2:  MOV     #C,W5
07AF4:  REPEAT  #3
07AF6:  MOV     [W5++],[W15++]
07AF8:  CLR     1B4C
07AFA:  CLR     1B4E
07AFC:  CLR     1B50
07AFE:  CLR     1B52
07B00:  CLR     1B54
07B02:  CLR     1B56
07B04:  CLR     1B58
07B06:  CLR     1B5A
07B08:  CLR     1B5C
07B0A:  CLR     1B5E
07B0C:  CLR     1B60
07B0E:  CLR     1B62
07B10:  CLR     1B64
07B12:  CLR     1B66
07B14:  CLR     1B68
07B16:  CLR     1B6A
07B18:  CLR     1B6C
07B1A:  CLR     1B6E
07B1C:  CLR     1B70
07B1E:  CLR     1B72
.................... { 
....................  
.................... 	float64	dx,dy,distToDo = 0;	 
.................... 	signed int32 distToDo_int = 0;	//dist a effectuer 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer 
.................... 	signed int32 impulse_g = 0;	 	//impulse mot gauche 
.................... 	signed int32 impulse_d = 0;		//impulse mot droite 
.................... 	static int1 etat_deplacement = 0; 
.................... 	float64 AngToDo = 0; 
.................... 	float64 temporaire = 0; 
.................... 	 
.................... 	 
.................... 	dx = (_X - Pos_x) * (COEFF_D/10); //calcul deplacment en x et transformation en pas 
07B20:  MOV     1B38,W4
07B22:  MOV     1586,W3
07B24:  SUB     W4,W3,W5
07B26:  MOV     W5,[W15++]
07B28:  MOV     15B4,W0
07B2A:  MOV     15B6,W1
07B2C:  MOV     15B8,W2
07B2E:  MOV     15BA,W3
07B30:  MOV     #0,W4
07B32:  MOV     #0,W5
07B34:  MOV     #0,W6
07B36:  MOV     #4024,W7
07B38:  CALL    D5A
07B3C:  MOV     [--W15],W5
07B3E:  MOV     W0,W6
07B40:  MOV     W1,W7
07B42:  MOV     W2,W8
07B44:  MOV     W3,W9
07B46:  MOV     W5,W0
07B48:  CLR     W3
07B4A:  BTSC    W0.F
07B4C:  SETM    W3
07B4E:  MOV     W3,W1
07B50:  MOV     W3,W2
07B52:  CALL    1B2C
07B56:  MOV     W5,[W15++]
07B58:  MOV     W6,[W15++]
07B5A:  MOV     W7,[W15++]
07B5C:  MOV     W6,W4
07B5E:  MOV     W7,W5
07B60:  MOV     W8,W6
07B62:  MOV     W9,W7
07B64:  CALL    C4A
07B68:  MOV     [--W15],W7
07B6A:  MOV     [--W15],W6
07B6C:  MOV     [--W15],W5
07B6E:  MOV     W0,1B3C
07B70:  MOV     W1,1B3E
07B72:  MOV     W2,1B40
07B74:  MOV     W3,1B42
.................... 	dy = (_Y - Pos_Y) * (COEFF_D/10); //calcul deplacment en y et transformation en pas 
07B76:  MOV     1B3A,W4
07B78:  MOV     1588,W3
07B7A:  SUB     W4,W3,W5
07B7C:  MOV     W5,[W15++]
07B7E:  MOV     15B4,W0
07B80:  MOV     15B6,W1
07B82:  MOV     15B8,W2
07B84:  MOV     15BA,W3
07B86:  MOV     #0,W4
07B88:  MOV     #0,W5
07B8A:  MOV     #0,W6
07B8C:  MOV     #4024,W7
07B8E:  CALL    D5A
07B92:  MOV     [--W15],W5
07B94:  MOV     W0,W6
07B96:  MOV     W1,W7
07B98:  MOV     W2,W8
07B9A:  MOV     W3,W9
07B9C:  MOV     W5,W0
07B9E:  CLR     W3
07BA0:  BTSC    W0.F
07BA2:  SETM    W3
07BA4:  MOV     W3,W1
07BA6:  MOV     W3,W2
07BA8:  CALL    1B2C
07BAC:  MOV     W5,[W15++]
07BAE:  MOV     W6,[W15++]
07BB0:  MOV     W7,[W15++]
07BB2:  MOV     W6,W4
07BB4:  MOV     W7,W5
07BB6:  MOV     W8,W6
07BB8:  MOV     W9,W7
07BBA:  CALL    C4A
07BBE:  MOV     [--W15],W7
07BC0:  MOV     [--W15],W6
07BC2:  MOV     [--W15],W5
07BC4:  MOV     W0,1B44
07BC6:  MOV     W1,1B46
07BC8:  MOV     W2,1B48
07BCA:  MOV     W3,1B4A
.................... 	distToDo = sqrt((dx*dx)+(dy*dy)); //calcul de la distance 
07BCC:  MOV     1B3C,W0
07BCE:  MOV     1B3E,W1
07BD0:  MOV     1B40,W2
07BD2:  MOV     1B42,W3
07BD4:  MOV     1B3C,W4
07BD6:  MOV     1B3E,W5
07BD8:  MOV     1B40,W6
07BDA:  MOV     1B42,W7
07BDC:  CALL    C4A
07BE0:  MOV     W0,W5
07BE2:  MOV     W1,W6
07BE4:  MOV     W2,W7
07BE6:  MOV     W3,W8
07BE8:  MOV     W5,[W15++]
07BEA:  MOV     W6,[W15++]
07BEC:  MOV     W7,[W15++]
07BEE:  MOV     1B44,W0
07BF0:  MOV     1B46,W1
07BF2:  MOV     1B48,W2
07BF4:  MOV     1B4A,W3
07BF6:  MOV     1B44,W4
07BF8:  MOV     1B46,W5
07BFA:  MOV     1B48,W6
07BFC:  MOV     1B4A,W7
07BFE:  CALL    C4A
07C02:  MOV     [--W15],W7
07C04:  MOV     [--W15],W6
07C06:  MOV     [--W15],W5
07C08:  BCLR.B  43.0
07C0A:  MOV     W5,[W15++]
07C0C:  MOV     W6,[W15++]
07C0E:  MOV     W7,[W15++]
07C10:  MOV     W0,W4
07C12:  MOV     W5,W0
07C14:  MOV     W1,W5
07C16:  MOV     W6,W1
07C18:  MOV     W2,W6
07C1A:  MOV     W7,W2
07C1C:  MOV     W3,W7
07C1E:  MOV     W8,W3
07C20:  CALL    1C40
07C24:  MOV     [--W15],W7
07C26:  MOV     [--W15],W6
07C28:  MOV     [--W15],W5
07C2A:  MOV     W0,W5
07C2C:  MOV     W1,W6
07C2E:  MOV     W2,W7
07C30:  MOV     W3,W8
07C32:  MOV     W5,1BCA
07C34:  MOV     W6,1BCC
07C36:  MOV     W7,1BCE
07C38:  MOV     W8,1BD0
07C3A:  CALL    3210
07C3E:  MOV     W0,1B4C
07C40:  MOV     W1,1B4E
07C42:  MOV     W2,1B50
07C44:  MOV     W3,1B52
.................... 	distToDo_int = distToDo ; 
07C46:  MOV     1B4C,W0
07C48:  MOV     1B4E,W1
07C4A:  MOV     1B50,W2
07C4C:  MOV     1B52,W3
07C4E:  CALL    2230
07C52:  MOV     W0,1B54
07C54:  MOV     W1,1B56
....................  
.................... 	switch(etat_deplacement) 
07C56:  CLR     W0
07C58:  BTSC.B  14B1.1
07C5A:  INC     W0,W0
07C5C:  CLR.B   1
07C5E:  XOR     #0,W0
07C60:  BRA     Z,7C68
07C62:  XOR     #1,W0
07C64:  BRA     Z,8194
07C66:  BRA     82C0
.................... 	{ 
.................... 		case 0: // gestion de l'angle 
.................... 		 
.................... 			/////////////////////////////////////////////// 
.................... 			//////////Calcul de l'angle//////////////////// 
.................... 			/////////////////////////////////////////////// 
.................... 				if(dx >= 0) // 1er et 4eme quadrant 
07C68:  MOV     #0,W0
07C6A:  MOV     #0,W1
07C6C:  MOV     #0,W2
07C6E:  MOV     #0,W3
07C70:  MOV     1B3C,W4
07C72:  MOV     1B3E,W5
07C74:  MOV     1B40,W6
07C76:  MOV     1B42,W7
07C78:  CALL    1E2E
07C7C:  BRA     C,7C80
07C7E:  BRA     NZ,7CDE
.................... 				{ 
.................... 					AngToDo = asin(dy/distToDo) - Orient;	 
07C80:  MOV     1B44,W0
07C82:  MOV     1B46,W1
07C84:  MOV     1B48,W2
07C86:  MOV     1B4A,W3
07C88:  MOV     1B4C,W4
07C8A:  MOV     1B4E,W5
07C8C:  MOV     1B50,W6
07C8E:  MOV     1B52,W7
07C90:  CALL    D5A
07C94:  MOV     W0,W5
07C96:  MOV     W1,W6
07C98:  MOV     W2,W7
07C9A:  MOV     W3,W8
07C9C:  MOV     W5,1B7E
07C9E:  MOV     W6,1B80
07CA0:  MOV     W7,1B82
07CA2:  MOV     W8,1B84
07CA4:  CALL    775C
07CA8:  MOV     W0,W5
07CAA:  MOV     W1,W6
07CAC:  MOV     W2,W7
07CAE:  MOV     W3,W8
07CB0:  BSET.B  43.0
07CB2:  MOV     W5,[W15++]
07CB4:  MOV     W6,[W15++]
07CB6:  MOV     W7,[W15++]
07CB8:  MOV     W5,W0
07CBA:  MOV     W6,W1
07CBC:  MOV     W7,W2
07CBE:  MOV     W8,W3
07CC0:  MOV     1594,W4
07CC2:  MOV     1596,W5
07CC4:  MOV     1598,W6
07CC6:  MOV     159A,W7
07CC8:  CALL    1C40
07CCC:  MOV     [--W15],W7
07CCE:  MOV     [--W15],W6
07CD0:  MOV     [--W15],W5
07CD2:  MOV     W0,1B64
07CD4:  MOV     W1,1B66
07CD6:  MOV     W2,1B68
07CD8:  MOV     W3,1B6A
.................... 				} 
07CDA:  GOTO    7E3A
.................... 				 
.................... 				else if(dx <= 0 && dy > 0)//2eme quandrant 
07CDE:  MOV     1B3C,W0
07CE0:  MOV     1B3E,W1
07CE2:  MOV     1B40,W2
07CE4:  MOV     1B42,W3
07CE6:  MOV     #0,W4
07CE8:  MOV     #0,W5
07CEA:  MOV     #0,W6
07CEC:  MOV     #0,W7
07CEE:  CALL    1E2E
07CF2:  BRA     C,7CF6
07CF4:  BRA     NZ,7D6A
07CF6:  MOV     #0,W0
07CF8:  MOV     #0,W1
07CFA:  MOV     #0,W2
07CFC:  MOV     #0,W3
07CFE:  MOV     1B44,W4
07D00:  MOV     1B46,W5
07D02:  MOV     1B48,W6
07D04:  MOV     1B4A,W7
07D06:  CALL    1E2E
07D0A:  BRA     NC,7D6A
.................... 				{ 
.................... 					AngToDo = acos(dx/distToDo) - Orient; 
07D0C:  MOV     1B3C,W0
07D0E:  MOV     1B3E,W1
07D10:  MOV     1B40,W2
07D12:  MOV     1B42,W3
07D14:  MOV     1B4C,W4
07D16:  MOV     1B4E,W5
07D18:  MOV     1B50,W6
07D1A:  MOV     1B52,W7
07D1C:  CALL    D5A
07D20:  MOV     W0,W5
07D22:  MOV     W1,W6
07D24:  MOV     W2,W7
07D26:  MOV     W3,W8
07D28:  MOV     W5,1B7E
07D2A:  MOV     W6,1B80
07D2C:  MOV     W7,1B82
07D2E:  MOV     W8,1B84
07D30:  CALL    7784
07D34:  MOV     W0,W5
07D36:  MOV     W1,W6
07D38:  MOV     W2,W7
07D3A:  MOV     W3,W8
07D3C:  BSET.B  43.0
07D3E:  MOV     W5,[W15++]
07D40:  MOV     W6,[W15++]
07D42:  MOV     W7,[W15++]
07D44:  MOV     W5,W0
07D46:  MOV     W6,W1
07D48:  MOV     W7,W2
07D4A:  MOV     W8,W3
07D4C:  MOV     1594,W4
07D4E:  MOV     1596,W5
07D50:  MOV     1598,W6
07D52:  MOV     159A,W7
07D54:  CALL    1C40
07D58:  MOV     [--W15],W7
07D5A:  MOV     [--W15],W6
07D5C:  MOV     [--W15],W5
07D5E:  MOV     W0,1B64
07D60:  MOV     W1,1B66
07D62:  MOV     W2,1B68
07D64:  MOV     W3,1B6A
.................... 				} 
07D66:  GOTO    7E3A
.................... 				 
.................... 				else if(dx < 0 && dy <= 0)//3eme quadrant 
07D6A:  MOV     1B3C,W0
07D6C:  MOV     1B3E,W1
07D6E:  MOV     1B40,W2
07D70:  MOV     1B42,W3
07D72:  MOV     #0,W4
07D74:  MOV     #0,W5
07D76:  MOV     #0,W6
07D78:  MOV     #0,W7
07D7A:  CALL    1E2E
07D7E:  BRA     NC,7E3A
07D80:  MOV     1B44,W0
07D82:  MOV     1B46,W1
07D84:  MOV     1B48,W2
07D86:  MOV     1B4A,W3
07D88:  MOV     #0,W4
07D8A:  MOV     #0,W5
07D8C:  MOV     #0,W6
07D8E:  MOV     #0,W7
07D90:  CALL    1E2E
07D94:  BRA     C,7D98
07D96:  BRA     NZ,7E3A
.................... 				{ 
.................... 					AngToDo = asin(abs(dy)/distToDo) + PI - Orient;	 
07D98:  MOV     1B44,W0
07D9A:  MOV     1B46,W1
07D9C:  MOV     1B48,W2
07D9E:  MOV     1B4A,W3
07DA0:  BCLR    W3.F
07DA2:  MOV     W0,W5
07DA4:  MOV     W1,W6
07DA6:  MOV     W2,W7
07DA8:  MOV     W3,W8
07DAA:  MOV     W5,[W15++]
07DAC:  MOV     W6,[W15++]
07DAE:  MOV     W7,[W15++]
07DB0:  MOV     W5,W0
07DB2:  MOV     W6,W1
07DB4:  MOV     W7,W2
07DB6:  MOV     W8,W3
07DB8:  MOV     1B4C,W4
07DBA:  MOV     1B4E,W5
07DBC:  MOV     1B50,W6
07DBE:  MOV     1B52,W7
07DC0:  CALL    D5A
07DC4:  MOV     [--W15],W7
07DC6:  MOV     [--W15],W6
07DC8:  MOV     [--W15],W5
07DCA:  MOV     W0,W5
07DCC:  MOV     W1,W6
07DCE:  MOV     W2,W7
07DD0:  MOV     W3,W8
07DD2:  MOV     W5,1B7E
07DD4:  MOV     W6,1B80
07DD6:  MOV     W7,1B82
07DD8:  MOV     W8,1B84
07DDA:  CALL    775C
07DDE:  MOV     W0,W5
07DE0:  MOV     W1,W6
07DE2:  MOV     W2,W7
07DE4:  MOV     W3,W8
07DE6:  BCLR.B  43.0
07DE8:  MOV     W5,[W15++]
07DEA:  MOV     W6,[W15++]
07DEC:  MOV     W7,[W15++]
07DEE:  MOV     W5,W0
07DF0:  MOV     W6,W1
07DF2:  MOV     W7,W2
07DF4:  MOV     W8,W3
07DF6:  MOV     #2D18,W4
07DF8:  MOV     #5444,W5
07DFA:  MOV     #21FB,W6
07DFC:  MOV     #4009,W7
07DFE:  CALL    1C40
07E02:  MOV     [--W15],W7
07E04:  MOV     [--W15],W6
07E06:  MOV     [--W15],W5
07E08:  MOV     W0,W5
07E0A:  MOV     W1,W6
07E0C:  MOV     W2,W7
07E0E:  MOV     W3,W8
07E10:  BSET.B  43.0
07E12:  MOV     W5,[W15++]
07E14:  MOV     W6,[W15++]
07E16:  MOV     W7,[W15++]
07E18:  MOV     W5,W0
07E1A:  MOV     W6,W1
07E1C:  MOV     W7,W2
07E1E:  MOV     W8,W3
07E20:  MOV     1594,W4
07E22:  MOV     1596,W5
07E24:  MOV     1598,W6
07E26:  MOV     159A,W7
07E28:  CALL    1C40
07E2C:  MOV     [--W15],W7
07E2E:  MOV     [--W15],W6
07E30:  MOV     [--W15],W5
07E32:  MOV     W0,1B64
07E34:  MOV     W1,1B66
07E36:  MOV     W2,1B68
07E38:  MOV     W3,1B6A
.................... 				} 
.................... 				 
.................... 			//////////////////////////////////////////////// 
.................... 			////////////Gestion de l'angle////////////////// 
.................... 			//////////////////////////////////////////////// 
.................... 				if(oAvAr) 
07E3A:  CP0     1498
07E3C:  BRA     Z,7EC8
.................... 				{ 
.................... 					AngToDo += PI;	 
07E3E:  BCLR.B  43.0
07E40:  MOV     1B64,W0
07E42:  MOV     1B66,W1
07E44:  MOV     1B68,W2
07E46:  MOV     1B6A,W3
07E48:  MOV     #2D18,W4
07E4A:  MOV     #5444,W5
07E4C:  MOV     #21FB,W6
07E4E:  MOV     #4009,W7
07E50:  CALL    1C40
07E54:  MOV     W0,1B64
07E56:  MOV     W1,1B66
07E58:  MOV     W2,1B68
07E5A:  MOV     W3,1B6A
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
07E5C:  MOV     #2D18,W0
07E5E:  MOV     #5444,W1
07E60:  MOV     #21FB,W2
07E62:  MOV     #4009,W3
07E64:  MOV     1B64,W4
07E66:  MOV     1B66,W5
07E68:  MOV     1B68,W6
07E6A:  MOV     1B6A,W7
07E6C:  CALL    1E2E
07E70:  BRA     NC,7E94
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
07E72:  BSET.B  43.0
07E74:  MOV     1B64,W0
07E76:  MOV     1B66,W1
07E78:  MOV     1B68,W2
07E7A:  MOV     1B6A,W3
07E7C:  MOV     #2D18,W4
07E7E:  MOV     #5444,W5
07E80:  MOV     #21FB,W6
07E82:  MOV     #4019,W7
07E84:  CALL    1C40
07E88:  MOV     W0,1B64
07E8A:  MOV     W1,1B66
07E8C:  MOV     W2,1B68
07E8E:  MOV     W3,1B6A
.................... 					} 
07E90:  GOTO    7EC8
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
07E94:  MOV     1B64,W0
07E96:  MOV     1B66,W1
07E98:  MOV     1B68,W2
07E9A:  MOV     1B6A,W3
07E9C:  MOV     #2D18,W4
07E9E:  MOV     #5444,W5
07EA0:  MOV     #21FB,W6
07EA2:  MOV     #C009,W7
07EA4:  CALL    1E2E
07EA8:  BRA     NC,7EC8
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07EAA:  BCLR.B  43.0
07EAC:  MOV     1B64,W0
07EAE:  MOV     1B66,W1
07EB0:  MOV     1B68,W2
07EB2:  MOV     1B6A,W3
07EB4:  MOV     #2D18,W4
07EB6:  MOV     #5444,W5
07EB8:  MOV     #21FB,W6
07EBA:  MOV     #4019,W7
07EBC:  CALL    1C40
07EC0:  MOV     W0,1B64
07EC2:  MOV     W1,1B66
07EC4:  MOV     W2,1B68
07EC6:  MOV     W3,1B6A
.................... 					} 
.................... 				}					 
.................... 				if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
07EC8:  MOV     149A,W4
07ECA:  CP      W4,#2
07ECC:  BRA     NZ,7F06
07ECE:  MOV     #0,W0
07ED0:  MOV     #0,W1
07ED2:  MOV     #0,W2
07ED4:  MOV     #0,W3
07ED6:  MOV     1B64,W4
07ED8:  MOV     1B66,W5
07EDA:  MOV     1B68,W6
07EDC:  MOV     1B6A,W7
07EDE:  CALL    1E2E
07EE2:  BRA     NC,7F06
.................... 				{ 
.................... 					AngToDo += -2 * PI; //on tourne sur la gauche 
07EE4:  BCLR.B  43.0
07EE6:  MOV     1B64,W0
07EE8:  MOV     1B66,W1
07EEA:  MOV     1B68,W2
07EEC:  MOV     1B6A,W3
07EEE:  MOV     #2D18,W4
07EF0:  MOV     #5444,W5
07EF2:  MOV     #21FB,W6
07EF4:  MOV     #C019,W7
07EF6:  CALL    1C40
07EFA:  MOV     W0,1B64
07EFC:  MOV     W1,1B66
07EFE:  MOV     W2,1B68
07F00:  MOV     W3,1B6A
.................... 				}	 
07F02:  GOTO    7FB4
.................... 				 
.................... 				else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
07F06:  MOV     149A,W4
07F08:  CP      W4,#1
07F0A:  BRA     NZ,7F44
07F0C:  MOV     1B64,W0
07F0E:  MOV     1B66,W1
07F10:  MOV     1B68,W2
07F12:  MOV     1B6A,W3
07F14:  MOV     #0,W4
07F16:  MOV     #0,W5
07F18:  MOV     #0,W6
07F1A:  MOV     #0,W7
07F1C:  CALL    1E2E
07F20:  BRA     NC,7F44
.................... 				{ 
.................... 					AngToDo += 2 * PI;//On tourne sur la droite	 
07F22:  BCLR.B  43.0
07F24:  MOV     1B64,W0
07F26:  MOV     1B66,W1
07F28:  MOV     1B68,W2
07F2A:  MOV     1B6A,W3
07F2C:  MOV     #2D18,W4
07F2E:  MOV     #5444,W5
07F30:  MOV     #21FB,W6
07F32:  MOV     #4019,W7
07F34:  CALL    1C40
07F38:  MOV     W0,1B64
07F3A:  MOV     W1,1B66
07F3C:  MOV     W2,1B68
07F3E:  MOV     W3,1B6A
.................... 				}				 
07F40:  GOTO    7FB4
.................... 				 
.................... 				else if(oCoteTourn==0) 
07F44:  CP0     149A
07F46:  BRA     NZ,7FB4
.................... 				{ 
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
07F48:  MOV     #2D18,W0
07F4A:  MOV     #5444,W1
07F4C:  MOV     #21FB,W2
07F4E:  MOV     #4009,W3
07F50:  MOV     1B64,W4
07F52:  MOV     1B66,W5
07F54:  MOV     1B68,W6
07F56:  MOV     1B6A,W7
07F58:  CALL    1E2E
07F5C:  BRA     NC,7F80
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
07F5E:  BSET.B  43.0
07F60:  MOV     1B64,W0
07F62:  MOV     1B66,W1
07F64:  MOV     1B68,W2
07F66:  MOV     1B6A,W3
07F68:  MOV     #2D18,W4
07F6A:  MOV     #5444,W5
07F6C:  MOV     #21FB,W6
07F6E:  MOV     #4019,W7
07F70:  CALL    1C40
07F74:  MOV     W0,1B64
07F76:  MOV     W1,1B66
07F78:  MOV     W2,1B68
07F7A:  MOV     W3,1B6A
.................... 					} 
07F7C:  GOTO    7FB4
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
07F80:  MOV     1B64,W0
07F82:  MOV     1B66,W1
07F84:  MOV     1B68,W2
07F86:  MOV     1B6A,W3
07F88:  MOV     #2D18,W4
07F8A:  MOV     #5444,W5
07F8C:  MOV     #21FB,W6
07F8E:  MOV     #C009,W7
07F90:  CALL    1E2E
07F94:  BRA     NC,7FB4
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07F96:  BCLR.B  43.0
07F98:  MOV     1B64,W0
07F9A:  MOV     1B66,W1
07F9C:  MOV     1B68,W2
07F9E:  MOV     1B6A,W3
07FA0:  MOV     #2D18,W4
07FA2:  MOV     #5444,W5
07FA4:  MOV     #21FB,W6
07FA6:  MOV     #4019,W7
07FA8:  CALL    1C40
07FAC:  MOV     W0,1B64
07FAE:  MOV     W1,1B66
07FB0:  MOV     W2,1B68
07FB2:  MOV     W3,1B6A
.................... 					}	 
.................... 				} 
.................... 			if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
07FB4:  MOV     #432D,W0
07FB6:  MOV     #EB1C,W1
07FB8:  MOV     #36E2,W2
07FBA:  MOV     #BF1A,W3
07FBC:  MOV     1B64,W4
07FBE:  MOV     1B66,W5
07FC0:  MOV     1B68,W6
07FC2:  MOV     1B6A,W7
07FC4:  CALL    1E2E
07FC8:  BRA     NC,7FE8
07FCA:  MOV     1B64,W0
07FCC:  MOV     1B66,W1
07FCE:  MOV     1B68,W2
07FD0:  MOV     1B6A,W3
07FD2:  MOV     #432D,W4
07FD4:  MOV     #EB1C,W5
07FD6:  MOV     #36E2,W6
07FD8:  MOV     #3F1A,W7
07FDA:  CALL    1E2E
07FDE:  BRA     NC,7FE8
07FE0:  CLR     1B64
07FE2:  CLR     1B66
07FE4:  CLR     1B68
07FE6:  CLR     1B6A
.................... 			temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
07FE8:  MOV     15AC,W0
07FEA:  MOV     15AE,W1
07FEC:  MOV     15B0,W2
07FEE:  MOV     15B2,W3
07FF0:  MOV     159C,W4
07FF2:  MOV     159E,W5
07FF4:  MOV     15A0,W6
07FF6:  MOV     15A2,W7
07FF8:  CALL    D5A
07FFC:  MOV     W0,W4
07FFE:  MOV     W1,W5
08000:  MOV     W2,W6
08002:  MOV     W3,W7
08004:  MOV     1B64,W0
08006:  MOV     1B66,W1
08008:  MOV     1B68,W2
0800A:  MOV     1B6A,W3
0800C:  CALL    C4A
08010:  MOV     W0,W5
08012:  MOV     W1,W6
08014:  MOV     W2,W7
08016:  MOV     W3,W8
08018:  MOV     W5,[W15++]
0801A:  MOV     W6,[W15++]
0801C:  MOV     W7,[W15++]
0801E:  MOV     W5,W0
08020:  MOV     W6,W1
08022:  MOV     W7,W2
08024:  MOV     W8,W3
08026:  MOV     15A4,W4
08028:  MOV     15A6,W5
0802A:  MOV     15A8,W6
0802C:  MOV     15AA,W7
0802E:  CALL    C4A
08032:  MOV     [--W15],W7
08034:  MOV     [--W15],W6
08036:  MOV     [--W15],W5
08038:  MOV     W0,W5
0803A:  MOV     W1,W6
0803C:  MOV     W2,W7
0803E:  MOV     W3,W8
08040:  MOV     W5,[W15++]
08042:  MOV     W6,[W15++]
08044:  MOV     W7,[W15++]
08046:  MOV     W5,W0
08048:  MOV     W6,W1
0804A:  MOV     W7,W2
0804C:  MOV     W8,W3
0804E:  MOV     #0,W4
08050:  MOV     #0,W5
08052:  MOV     #0,W6
08054:  MOV     #4000,W7
08056:  CALL    C4A
0805A:  MOV     [--W15],W7
0805C:  MOV     [--W15],W6
0805E:  MOV     [--W15],W5
08060:  MOV     W0,W5
08062:  MOV     W1,W6
08064:  MOV     W2,W7
08066:  MOV     W3,W8
08068:  MOV     W5,[W15++]
0806A:  MOV     W6,[W15++]
0806C:  MOV     W7,[W15++]
0806E:  MOV     W5,W0
08070:  MOV     W6,W1
08072:  MOV     W7,W2
08074:  MOV     W8,W3
08076:  MOV     #2D18,W4
08078:  MOV     #5444,W5
0807A:  MOV     #21FB,W6
0807C:  MOV     #4009,W7
0807E:  CALL    D5A
08082:  MOV     [--W15],W7
08084:  MOV     [--W15],W6
08086:  MOV     [--W15],W5
08088:  MOV     W0,1B6C
0808A:  MOV     W1,1B6E
0808C:  MOV     W2,1B70
0808E:  MOV     W3,1B72
.................... 			AngToDo_int = (signed int32)(arrondi_float_signed(temporaire)); 
08090:  MOV     1B6C,W0
08092:  MOV     1B6E,W1
08094:  MOV     1B70,W2
08096:  MOV     1B72,W3
08098:  CALL    684C
0809C:  MOV     W1,W5
0809E:  MOV     W2,W6
080A0:  MOV     W5,1B7A
080A2:  MOV     W6,1B7C
080A4:  CALL    6D9E
080A8:  MOV     W0,1B58
080AA:  MOV     W1,1B5A
.................... 			/////////////////////////////////////////////////// 
.................... 			/////////////////Envoi de l'angle au Roboteq/////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			if(AngToDo_int != 0) 
080AC:  CP0     1B58
080AE:  BRA     NZ,80B4
080B0:  CP0     1B5A
080B2:  BRA     Z,8158
.................... 			{ 
.................... 				//balise 
.................... 				balise_on = 0; //desactive la balise sur une rotation 
080B4:  BCLR.B  85B.1
.................... 				 
.................... 				fprintf(ROBOTEQ,"!S 1 100_!S 2 100\r"); 
080B6:  MOV     #0,W1
080B8:  MOV     W1,W0
080BA:  CLR.B   1
080BC:  CALL    178
080C0:  INC     W1,W1
080C2:  BTSC.B  219.1
080C4:  BRA     80C2
080C6:  MOV     W0,21A
080C8:  MOV     #11,W0
080CA:  CPSGT   W1,W0
080CC:  BRA     80B8
.................... 				// on envoie les donnee au ROBOTEQ 
.................... 							 
.................... 				impulse_g = AngToDo_int; 
080CE:  PUSH    1B58
080D0:  POP     1B5C
080D2:  PUSH    1B5A
080D4:  POP     1B5E
.................... 				impulse_d = 0-AngToDo_int; 
080D6:  MOV     #0,W4
080D8:  MOV     1B58,W3
080DA:  SUB     W4,W3,W0
080DC:  MOV     W0,1B60
080DE:  MOV     #0,W4
080E0:  MOV     1B5A,W3
080E2:  SUBB    W4,W3,W0
080E4:  MOV     W0,1B62
.................... 				fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",-impulse_g,-impulse_d); 
080E6:  MOV     #0,W4
080E8:  MOV     1B5C,W3
080EA:  SUB     W4,W3,W5
080EC:  MOV     #0,W4
080EE:  MOV     1B5E,W3
080F0:  SUBB    W4,W3,W6
080F2:  MOV     #0,W4
080F4:  MOV     1B60,W3
080F6:  SUB     W4,W3,W7
080F8:  MOV     #0,W4
080FA:  MOV     1B62,W3
080FC:  SUBB    W4,W3,W8
080FE:  MOV     #0,W1
08100:  MOV     W1,W0
08102:  CLR.B   1
08104:  CALL    158
08108:  INC     W1,W1
0810A:  BTSC.B  219.1
0810C:  BRA     810A
0810E:  MOV     W0,21A
08110:  MOV     #5,W0
08112:  CPSGT   W1,W0
08114:  BRA     8100
08116:  MOV     W5,W0
08118:  MOV     W6,W1
0811A:  MOV     #0,W4
0811C:  CALL    6EF4
08120:  MOV     #8,W1
08122:  MOV     W1,W0
08124:  CLR.B   1
08126:  CALL    158
0812A:  INC     W1,W1
0812C:  BTSC.B  219.1
0812E:  BRA     812C
08130:  MOV     W0,21A
08132:  MOV     #E,W0
08134:  CPSGT   W1,W0
08136:  BRA     8122
08138:  MOV     W7,W0
0813A:  MOV     W8,W1
0813C:  MOV     #0,W4
0813E:  CALL    6EF4
08142:  BTSC.B  219.1
08144:  BRA     8142
08146:  MOV     #20,W4
08148:  MOV     W4,21A
0814A:  BTSC.B  219.1
0814C:  BRA     814A
0814E:  MOV     #D,W4
08150:  MOV     W4,21A
.................... 				 
.................... 				etat_deplacement  = 1;	 
08152:  BSET.B  14B1.1
.................... 			}					 
08154:  GOTO    8172
.................... 			else 
.................... 			{			 
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r"); 
08158:  MOV     #0,W1
0815A:  MOV     W1,W0
0815C:  CLR.B   1
0815E:  CALL    198
08162:  INC     W1,W1
08164:  BTSC.B  219.1
08166:  BRA     8164
08168:  MOV     W0,21A
0816A:  MOV     #F,W0
0816C:  CPSGT   W1,W0
0816E:  BRA     815A
.................... 				etat_deplacement = 1; 
08170:  BSET.B  14B1.1
.................... 			}	 
.................... 			Orient = (float64)(Orient + AngToDo);	 
08172:  BCLR.B  43.0
08174:  MOV     1594,W0
08176:  MOV     1596,W1
08178:  MOV     1598,W2
0817A:  MOV     159A,W3
0817C:  MOV     1B64,W4
0817E:  MOV     1B66,W5
08180:  MOV     1B68,W6
08182:  MOV     1B6A,W7
08184:  CALL    1C40
08188:  MOV     W0,1594
0818A:  MOV     W1,1596
0818C:  MOV     W2,1598
0818E:  MOV     W3,159A
.................... 			break; 
08190:  GOTO    82C0
.................... 		case 1 : // gestion de la distance 
.................... 		 
.................... 			if(distToDo!=0)//si on doit faire avancer le robot 
08194:  MOV     1B4C,W0
08196:  MOV     1B4E,W1
08198:  MOV     1B50,W2
0819A:  MOV     1B52,W3
0819C:  MOV     #0,W4
0819E:  MOV     #0,W5
081A0:  MOV     #0,W6
081A2:  MOV     #0,W7
081A4:  CALL    1E2E
081A8:  BRA     Z,82B8
.................... 			{		 
.................... 				__Check_commande_atteint();  
081AA:  CALL    77AE
.................... 				__Get_enco_value(1);	//recupere la valeur des encos du pt de depart 
081AE:  MOV.B   #1,W0L
081B0:  MOV.B   W0L,1B74
081B2:  CALL    788A
.................... 				 
.................... 				if(flag_depl_ok == 1)//On attend que le deplacment precedent soit fini(angle) 
081B6:  BTSS.B  85A.6
081B8:  BRA     82B4
.................... 				{ 
.................... 					fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
081BA:  MOV     #0,W1
081BC:  MOV     W1,W0
081BE:  CLR.B   1
081C0:  CALL    136
081C4:  INC     W1,W1
081C6:  BTSC.B  219.1
081C8:  BRA     81C6
081CA:  MOV     W0,21A
081CC:  MOV     #4,W0
081CE:  CPSGT   W1,W0
081D0:  BRA     81BC
081D2:  MOV     149C,W0
081D4:  MOV     #8004,W4
081D6:  CALL    6DFA
081DA:  MOV     #9,W1
081DC:  MOV     W1,W0
081DE:  CLR.B   1
081E0:  CALL    136
081E4:  INC     W1,W1
081E6:  BTSC.B  219.1
081E8:  BRA     81E6
081EA:  MOV     W0,21A
081EC:  MOV     #E,W0
081EE:  CPSGT   W1,W0
081F0:  BRA     81DC
081F2:  MOV     149C,W0
081F4:  MOV     #8004,W4
081F6:  CALL    6DFA
081FA:  BTSC.B  219.1
081FC:  BRA     81FA
081FE:  MOV     #20,W4
08200:  MOV     W4,21A
08202:  BTSC.B  219.1
08204:  BRA     8202
08206:  MOV     #D,W4
08208:  MOV     W4,21A
.................... 					 
.................... 					flag_depl_ok = 0; 
0820A:  BCLR.B  85A.6
.................... 					 
.................... 					if(oAvAr)//si on recule 
0820C:  CP0     1498
0820E:  BRA     Z,822C
.................... 					{		 
.................... 						Balise_set_plage(1);//plage à l'arriere du robot						 
08210:  MOV.B   #1,W0L
08212:  MOV.B   W0L,1B74
08214:  CALL    7AB6
.................... 						distToDo_int = 0 - distToDo_int; //impulse negative --> recule 
08218:  MOV     #0,W4
0821A:  MOV     1B54,W3
0821C:  SUB     W4,W3,W0
0821E:  MOV     W0,1B54
08220:  MOV     #0,W4
08222:  MOV     1B56,W3
08224:  SUBB    W4,W3,W0
08226:  MOV     W0,1B56
.................... 					} 
08228:  GOTO    8232
.................... 					else  
.................... 					{ 
.................... 						Balise_set_plage(0);//plage à l'avant du robot 
0822C:  CLR.B   1B74
0822E:  CALL    7AB6
.................... 					} 
.................... 					//balise	 
.................... 					balise_on = 1; // active la balise sur un depl 
08232:  BSET.B  85B.1
.................... 					//////////////////////////////////////////////////// 
.................... 					////////////envoie au Roobreq/////////////////////// 
.................... 					/////////////////////////////////////////////////// 
.................... 	 
.................... 					fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-distToDo_int,-distToDo_int);						 
08234:  MOV     #0,W4
08236:  MOV     1B54,W3
08238:  SUB     W4,W3,W5
0823A:  MOV     #0,W4
0823C:  MOV     1B56,W3
0823E:  SUBB    W4,W3,W6
08240:  MOV     #0,W4
08242:  MOV     1B54,W3
08244:  SUB     W4,W3,W7
08246:  MOV     #0,W4
08248:  MOV     1B56,W3
0824A:  SUBB    W4,W3,W8
0824C:  MOV     #0,W1
0824E:  MOV     W1,W0
08250:  CLR.B   1
08252:  CALL    1B6
08256:  INC     W1,W1
08258:  BTSC.B  219.1
0825A:  BRA     8258
0825C:  MOV     W0,21A
0825E:  MOV     #5,W0
08260:  CPSGT   W1,W0
08262:  BRA     824E
08264:  MOV     W5,W0
08266:  MOV     W6,W1
08268:  MOV     #8007,W4
0826A:  CALL    6EF4
0826E:  MOV     #A,W1
08270:  MOV     W1,W0
08272:  CLR.B   1
08274:  CALL    1B6
08278:  INC     W1,W1
0827A:  BTSC.B  219.1
0827C:  BRA     827A
0827E:  MOV     W0,21A
08280:  MOV     #10,W0
08282:  CPSGT   W1,W0
08284:  BRA     8270
08286:  MOV     W7,W0
08288:  MOV     W8,W1
0828A:  MOV     #8007,W4
0828C:  CALL    6EF4
08290:  BTSC.B  219.1
08292:  BRA     8290
08294:  MOV     #20,W4
08296:  MOV     W4,21A
08298:  BTSC.B  219.1
0829A:  BRA     8298
0829C:  MOV     #D,W4
0829E:  MOV     W4,21A
.................... 					Depl_send = 1;							//indique que l'on a fini d'envoyer les ordres du dÃ©placment 
082A0:  BSET.B  85B.5
.................... 					etat_deplacement = 0; 
082A2:  BCLR.B  14B1.1
.................... 					Dist_x = (signed int16)(_X - Pos_x);	//mise a jour pos x 
082A4:  MOV     1B38,W4
082A6:  MOV     1586,W3
082A8:  SUB     W4,W3,W0
082AA:  MOV     W0,1582
.................... 					Dist_y = (signed int16)(_Y - Pos_y); 	//mise a jour pos y 
082AC:  MOV     1B3A,W4
082AE:  MOV     1588,W3
082B0:  SUB     W4,W3,W0
082B2:  MOV     W0,1584
.................... 				}	 
.................... 			} 
082B4:  GOTO    82BC
.................... 			else 
.................... 			{				 
.................... 				Depl_send = 1; 
082B8:  BSET.B  85B.5
.................... 				etat_deplacement = 0; 
082BA:  BCLR.B  14B1.1
.................... 			} 
.................... 		break; 
082BC:  GOTO    82C0
.................... 	} 
.................... 	// Quitte la fonction 
.................... 	return; 
082C0:  MOV     #12,W5
082C2:  REPEAT  #3
082C4:  MOV     [--W15],[W5--]
082C6:  MOV     [--W15],W5
082C8:  RETURN  
.................... } 
.................... /* 
.................... 	/** 
.................... * \fn void __Progress(int16 _X, int16 _Y) 
.................... * \brief Fonction utile pour s'etalonner dans un bord  
.................... * \		 s'arrete en detectant une limite de courant  
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 23.2.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Progress(int16 _X, int16 _Y) 
*
08A74:  MOV     W5,[W15++]
08A76:  MOV     #C,W5
08A78:  REPEAT  #6
08A7A:  MOV     [W5++],[W15++]
08A7C:  CLR     1B38
08A7E:  CLR     1B3A
08A80:  CLR     1B3C
08A82:  CLR     1B3E
08A84:  CLR     1B40
08A86:  CLR     1B42
08A88:  CLR     1B44
08A8A:  CLR     1B46
08A8C:  CLR     1B48
08A8E:  CLR     1B4A
08A90:  CLR     1B4C
08A92:  CLR     1B4E
.................... { 
.................... 	static unsigned int8 etat_depl; 
.................... 	float64 amp = 0;				//courant dans le moteur 1 
.................... 	float64 amp2 = 0;				//courant dans le moteur 2  
.................... 	static int1 m1_stop,m2_stop;	//arret moteur 1 et arret moteur 2 
....................  
.................... 	float64 Dist = 0;  
....................  
.................... 	switch(etat_depl) 
08A94:  MOV.B   15DA,W0L
08A96:  CLR.B   1
08A98:  XOR     #0,W0
08A9A:  BRA     Z,8AA2
08A9C:  XOR     #1,W0
08A9E:  BRA     Z,8C32
08AA0:  BRA     8DF6
.................... 	{ 
.................... 		case 0: 
.................... 		 	Dist = sqrt(((_X - Pos_x) * (_X - Pos_x)) + ((_Y - Pos_y) * (_Y - Pos_y))) + DIST_SECU_PROGRESS; // calcul distance de depl  
08AA2:  MOV     1B34,W4
08AA4:  MOV     1586,W3
08AA6:  SUB     W4,W3,W5
08AA8:  MOV     1B34,W4
08AAA:  MOV     1586,W3
08AAC:  SUB     W4,W3,W0
08AAE:  MUL.SS  W5,W0,W0
08AB0:  MOV     W0,W5
08AB2:  MOV     1B36,W4
08AB4:  MOV     1588,W3
08AB6:  SUB     W4,W3,W6
08AB8:  MOV     1B36,W4
08ABA:  MOV     1588,W3
08ABC:  SUB     W4,W3,W0
08ABE:  MUL.SS  W6,W0,W0
08AC0:  ADD     W0,W5,W0
08AC2:  CALL    82CA
08AC6:  MOV     W0,W5
08AC8:  MOV     W1,W6
08ACA:  MOV     W5,1B54
08ACC:  MOV     W6,1B56
08ACE:  CALL    83DE
08AD2:  MOV     W0,W5
08AD4:  MOV     W1,W6
08AD6:  MOV     1580,W0
08AD8:  CALL    6924
08ADC:  BCLR.B  43.0
08ADE:  MOV     W0,W2
08AE0:  MOV     W1,W3
08AE2:  MOV     W5,W0
08AE4:  MOV     W6,W1
08AE6:  CALL    6A22
08AEA:  MOV     W1,W2
08AEC:  MOV     W0,W1
08AEE:  MOV     #0,W0
08AF0:  CALL    84BE
08AF4:  MOV     W0,1B48
08AF6:  MOV     W1,1B4A
08AF8:  MOV     W2,1B4C
08AFA:  MOV     W3,1B4E
.................... 		 	Dist *= (COEFF_D/10);	//conversion mm en pas 
08AFC:  MOV     15B4,W0
08AFE:  MOV     15B6,W1
08B00:  MOV     15B8,W2
08B02:  MOV     15BA,W3
08B04:  MOV     #0,W4
08B06:  MOV     #0,W5
08B08:  MOV     #0,W6
08B0A:  MOV     #4024,W7
08B0C:  CALL    D5A
08B10:  MOV     W0,W4
08B12:  MOV     W1,W5
08B14:  MOV     W2,W6
08B16:  MOV     W3,W7
08B18:  MOV     1B48,W0
08B1A:  MOV     1B4A,W1
08B1C:  MOV     1B4C,W2
08B1E:  MOV     1B4E,W3
08B20:  CALL    C4A
08B24:  MOV     W0,1B48
08B26:  MOV     W1,1B4A
08B28:  MOV     W2,1B4C
08B2A:  MOV     W3,1B4E
.................... 			flag_depl_ok = 0; 
08B2C:  BCLR.B  85A.6
.................... 			 
.................... 			//balise	 
.................... 			balise_on = 1; // active la balise sur un depl				 
08B2E:  BSET.B  85B.1
.................... 			 
.................... 			if(oAvAr)//si on recule 
08B30:  CP0     1498
08B32:  BRA     Z,8B5E
.................... 			{	 
.................... 				Balise_set_plage(1);//plage à l'arriere du robot					 
08B34:  MOV.B   #1,W0L
08B36:  MOV.B   W0L,1B74
08B38:  CALL    7AB6
.................... 				Dist = 0 - Dist; 	// on inverse la distance 
08B3C:  BSET.B  43.0
08B3E:  MOV     #0,W0
08B40:  MOV     #0,W1
08B42:  MOV     #0,W2
08B44:  MOV     #0,W3
08B46:  MOV     1B48,W4
08B48:  MOV     1B4A,W5
08B4A:  MOV     1B4C,W6
08B4C:  MOV     1B4E,W7
08B4E:  CALL    1C40
08B52:  MOV     W0,1B48
08B54:  MOV     W1,1B4A
08B56:  MOV     W2,1B4C
08B58:  MOV     W3,1B4E
.................... 			} 
08B5A:  GOTO    8B64
.................... 			else  
.................... 			{ 
.................... 				Balise_set_plage(0);//plage à l'avant du robot 
08B5E:  CLR.B   1B74
08B60:  CALL    7AB6
.................... 			} 
.................... 			//////////////////////////////////////////////////// 
.................... 			////////////envoie au Roobreq/////////////////////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			//__Get_enco_value(1); 
.................... 			 
.................... 			fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax);	 
08B64:  MOV     #0,W1
08B66:  MOV     W1,W0
08B68:  CLR.B   1
08B6A:  CALL    136
08B6E:  INC     W1,W1
08B70:  BTSC.B  219.1
08B72:  BRA     8B70
08B74:  MOV     W0,21A
08B76:  MOV     #4,W0
08B78:  CPSGT   W1,W0
08B7A:  BRA     8B66
08B7C:  MOV     149C,W0
08B7E:  MOV     #8004,W4
08B80:  CALL    6DFA
08B84:  MOV     #9,W1
08B86:  MOV     W1,W0
08B88:  CLR.B   1
08B8A:  CALL    136
08B8E:  INC     W1,W1
08B90:  BTSC.B  219.1
08B92:  BRA     8B90
08B94:  MOV     W0,21A
08B96:  MOV     #E,W0
08B98:  CPSGT   W1,W0
08B9A:  BRA     8B86
08B9C:  MOV     149C,W0
08B9E:  MOV     #8004,W4
08BA0:  CALL    6DFA
08BA4:  BTSC.B  219.1
08BA6:  BRA     8BA4
08BA8:  MOV     #20,W4
08BAA:  MOV     W4,21A
08BAC:  BTSC.B  219.1
08BAE:  BRA     8BAC
08BB0:  MOV     #D,W4
08BB2:  MOV     W4,21A
.................... 			fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",-Dist,-Dist);		 
08BB4:  MOV     1B48,W5
08BB6:  MOV     1B4A,W6
08BB8:  MOV     1B4C,W7
08BBA:  MOV     1B4E,W8
08BBC:  BTG     W8.F
08BBE:  MOV     1B48,W9
08BC0:  MOV     1B4A,W10
08BC2:  MOV     1B4C,W11
08BC4:  MOV     1B4E,W12
08BC6:  BTG     W12.F
08BC8:  MOV     #0,W1
08BCA:  MOV     W1,W0
08BCC:  CLR.B   1
08BCE:  CALL    158
08BD2:  INC     W1,W1
08BD4:  BTSC.B  219.1
08BD6:  BRA     8BD4
08BD8:  MOV     W0,21A
08BDA:  MOV     #5,W0
08BDC:  CPSGT   W1,W0
08BDE:  BRA     8BCA
08BE0:  MOV     W5,W0
08BE2:  MOV     W6,W1
08BE4:  MOV     W7,W2
08BE6:  MOV     W8,W3
08BE8:  MOV     #0,W4
08BEA:  CALL    859C
08BEE:  MOV     #8,W1
08BF0:  MOV     W1,W0
08BF2:  CLR.B   1
08BF4:  CALL    158
08BF8:  INC     W1,W1
08BFA:  BTSC.B  219.1
08BFC:  BRA     8BFA
08BFE:  MOV     W0,21A
08C00:  MOV     #E,W0
08C02:  CPSGT   W1,W0
08C04:  BRA     8BF0
08C06:  MOV     W9,W0
08C08:  MOV     W10,W1
08C0A:  MOV     W11,W2
08C0C:  MOV     W12,W3
08C0E:  MOV     #0,W4
08C10:  CALL    859C
08C14:  BTSC.B  219.1
08C16:  BRA     8C14
08C18:  MOV     #20,W4
08C1A:  MOV     W4,21A
08C1C:  BTSC.B  219.1
08C1E:  BRA     8C1C
08C20:  MOV     #D,W4
08C22:  MOV     W4,21A
.................... 			 
.................... 			etat_depl = 1; 
08C24:  MOV.B   #1,W0L
08C26:  MOV.B   W0L,15DA
.................... 			delay_ms(20); 
08C28:  MOV     #14,W0
08C2A:  CALL    F0E
.................... 			 
.................... 			break; 
08C2E:  GOTO    8DF6
.................... 		case 1:  
.................... 			amp = (float64)(__Get_amp(1));	//recup du courant du mot 1 
08C32:  MOV     #1,W4
08C34:  MOV     W4,1B50
08C36:  CALL    86CE
08C3A:  MOV     W0,1B38
08C3C:  MOV     W1,1B3A
08C3E:  MOV     W2,1B3C
08C40:  MOV     W3,1B3E
.................... 			amp2 =(float64)(__Get_amp(2));	//recup du courant du mot 2 
08C42:  MOV     #2,W4
08C44:  MOV     W4,1B50
08C46:  CALL    86CE
08C4A:  MOV     W0,1B40
08C4C:  MOV     W1,1B42
08C4E:  MOV     W2,1B44
08C50:  MOV     W3,1B46
.................... 			amp /= 10;					  	// roboteq envoie 15A pour 1,5A --> /10 
08C52:  MOV     1B38,W0
08C54:  MOV     1B3A,W1
08C56:  MOV     1B3C,W2
08C58:  MOV     1B3E,W3
08C5A:  MOV     #0,W4
08C5C:  MOV     #0,W5
08C5E:  MOV     #0,W6
08C60:  MOV     #4024,W7
08C62:  CALL    D5A
08C66:  MOV     W0,1B38
08C68:  MOV     W1,1B3A
08C6A:  MOV     W2,1B3C
08C6C:  MOV     W3,1B3E
.................... 			amp2 /= 10;					 	// roboteq envoie 15A pour 1,5A --> /10 
08C6E:  MOV     1B40,W0
08C70:  MOV     1B42,W1
08C72:  MOV     1B44,W2
08C74:  MOV     1B46,W3
08C76:  MOV     #0,W4
08C78:  MOV     #0,W5
08C7A:  MOV     #0,W6
08C7C:  MOV     #4024,W7
08C7E:  CALL    D5A
08C82:  MOV     W0,1B40
08C84:  MOV     W1,1B42
08C86:  MOV     W2,1B44
08C88:  MOV     W3,1B46
.................... 			if(amp >= amp_limit)		 	//Seuil courant ds mot 1 detecte  
08C8A:  MOV     1578,W0
08C8C:  MOV     157A,W1
08C8E:  MOV     157C,W2
08C90:  MOV     157E,W3
08C92:  MOV     1B38,W4
08C94:  MOV     1B3A,W5
08C96:  MOV     1B3C,W6
08C98:  MOV     1B3E,W7
08C9A:  CALL    1E2E
08C9E:  BRA     C,8CA2
08CA0:  BRA     NZ,8CBC
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 1\r");	//Stop le mot 1  
08CA2:  MOV     #0,W1
08CA4:  MOV     W1,W0
08CA6:  CLR.B   1
08CA8:  CALL    1DA
08CAC:  INC     W1,W1
08CAE:  BTSC.B  219.1
08CB0:  BRA     8CAE
08CB2:  MOV     W0,21A
08CB4:  MOV     #5,W0
08CB6:  CPSGT   W1,W0
08CB8:  BRA     8CA4
.................... 				m1_stop = 1; 
08CBA:  BSET.B  14B1.2
.................... 			} 
.................... 			if(amp2 >= amp_limit)			//Seuil courant ds mot 2 detecte 
08CBC:  MOV     1578,W0
08CBE:  MOV     157A,W1
08CC0:  MOV     157C,W2
08CC2:  MOV     157E,W3
08CC4:  MOV     1B40,W4
08CC6:  MOV     1B42,W5
08CC8:  MOV     1B44,W6
08CCA:  MOV     1B46,W7
08CCC:  CALL    1E2E
08CD0:  BRA     C,8CD4
08CD2:  BRA     NZ,8CEE
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 2\r");	//Stop le mot 2 
08CD4:  MOV     #0,W1
08CD6:  MOV     W1,W0
08CD8:  CLR.B   1
08CDA:  CALL    1EE
08CDE:  INC     W1,W1
08CE0:  BTSC.B  219.1
08CE2:  BRA     8CE0
08CE4:  MOV     W0,21A
08CE6:  MOV     #5,W0
08CE8:  CPSGT   W1,W0
08CEA:  BRA     8CD6
.................... 				m2_stop = 1; 
08CEC:  BSET.B  14B1.3
.................... 			}	 
.................... 			if(m1_stop==1 && m2_stop==1)	//les 2 moteurs stopes 
08CEE:  BTSS.B  14B1.2
08CF0:  BRA     8D5C
08CF2:  BTSS.B  14B1.3
08CF4:  BRA     8D5C
.................... 			{ 
....................  
.................... 				fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); 	//passage en open loop speed 
08CF6:  MOV     #0,W1
08CF8:  MOV     W1,W0
08CFA:  CLR.B   1
08CFC:  CALL    202
08D00:  INC     W1,W1
08D02:  BTSC.B  219.1
08D04:  BRA     8D02
08D06:  MOV     W0,21A
08D08:  MOV     #13,W0
08D0A:  CPSGT   W1,W0
08D0C:  BRA     8CF8
.................... 				delay_ms(10); 
08D0E:  MOV     #A,W0
08D10:  CALL    F0E
.................... 				fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); 	//passage en closed loop count postion 
08D14:  MOV     #0,W1
08D16:  MOV     W1,W0
08D18:  CLR.B   1
08D1A:  CALL    224
08D1E:  INC     W1,W1
08D20:  BTSC.B  219.1
08D22:  BRA     8D20
08D24:  MOV     W0,21A
08D26:  MOV     #13,W0
08D28:  CPSGT   W1,W0
08D2A:  BRA     8D16
.................... 								 
.................... 				Depl_send = 1; 							  	//fin du déplacment 
08D2C:  BSET.B  85B.5
.................... 				etat_depl = 0; 
08D2E:  CLR.B   15DA
....................  
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r");	   
08D30:  MOV     #0,W1
08D32:  MOV     W1,W0
08D34:  CLR.B   1
08D36:  CALL    198
08D3A:  INC     W1,W1
08D3C:  BTSC.B  219.1
08D3E:  BRA     8D3C
08D40:  MOV     W0,21A
08D42:  MOV     #F,W0
08D44:  CPSGT   W1,W0
08D46:  BRA     8D32
.................... 				 
.................... 				Dist_x = (signed int16)(_X-Pos_x);			//mise a jour pos x 
08D48:  MOV     1B34,W4
08D4A:  MOV     1586,W3
08D4C:  SUB     W4,W3,W0
08D4E:  MOV     W0,1582
.................... 				Dist_y = (signed int16)(_Y-Pos_y);			//mise a jour pos y 
08D50:  MOV     1B36,W4
08D52:  MOV     1588,W3
08D54:  SUB     W4,W3,W0
08D56:  MOV     W0,1584
.................... 			} 
08D58:  GOTO    8DF2
.................... 			else // si pos atteinte 
.................... 			{					 
.................... 				__Check_commande_atteint();  
08D5C:  CALL    77AE
.................... 				if(flag_depl_ok == 1) //On attend que le deplacment precedent soit fini(angle) 
08D60:  BTSS.B  85A.6
08D62:  BRA     8DF2
.................... 				{ 
.................... 					Dist_x =  cos(Orient) * Dist;			//mise a jour pos x 
08D64:  PUSH    1594
08D66:  POP     1B62
08D68:  PUSH    1596
08D6A:  POP     1B64
08D6C:  PUSH    1598
08D6E:  POP     1B66
08D70:  PUSH    159A
08D72:  POP     1B68
08D74:  CALL    877E
08D78:  MOV     W0,W5
08D7A:  MOV     W1,W6
08D7C:  MOV     W2,W7
08D7E:  MOV     W3,W8
08D80:  MOV     W5,[W15++]
08D82:  MOV     W6,[W15++]
08D84:  MOV     W7,[W15++]
08D86:  MOV     W5,W0
08D88:  MOV     W6,W1
08D8A:  MOV     W7,W2
08D8C:  MOV     W8,W3
08D8E:  MOV     1B48,W4
08D90:  MOV     1B4A,W5
08D92:  MOV     1B4C,W6
08D94:  MOV     1B4E,W7
08D96:  CALL    C4A
08D9A:  MOV     [--W15],W7
08D9C:  MOV     [--W15],W6
08D9E:  MOV     [--W15],W5
08DA0:  CALL    2230
08DA4:  MOV     W0,1582
.................... 					Dist_y =  sin(Orient) * Dist;			//mise a jour pos y 
08DA6:  PUSH    1594
08DA8:  POP     1B50
08DAA:  PUSH    1596
08DAC:  POP     1B52
08DAE:  PUSH    1598
08DB0:  POP     1B54
08DB2:  PUSH    159A
08DB4:  POP     1B56
08DB6:  CALL    8A38
08DBA:  MOV     W0,W5
08DBC:  MOV     W1,W6
08DBE:  MOV     W2,W7
08DC0:  MOV     W3,W8
08DC2:  MOV     W5,[W15++]
08DC4:  MOV     W6,[W15++]
08DC6:  MOV     W7,[W15++]
08DC8:  MOV     W5,W0
08DCA:  MOV     W6,W1
08DCC:  MOV     W7,W2
08DCE:  MOV     W8,W3
08DD0:  MOV     1B48,W4
08DD2:  MOV     1B4A,W5
08DD4:  MOV     1B4C,W6
08DD6:  MOV     1B4E,W7
08DD8:  CALL    C4A
08DDC:  MOV     [--W15],W7
08DDE:  MOV     [--W15],W6
08DE0:  MOV     [--W15],W5
08DE2:  CALL    2230
08DE6:  MOV     W0,1584
....................  
.................... 					//remise a zero des varaibles 
.................... 					flag_depl_ok = 0; 
08DE8:  BCLR.B  85A.6
.................... 					Depl_send = 1; 
08DEA:  BSET.B  85B.5
.................... 					m1_stop = 0; 
08DEC:  BCLR.B  14B1.2
.................... 					m2_stop = 0;								 
08DEE:  BCLR.B  14B1.3
.................... 					etat_depl = 0;			 
08DF0:  CLR.B   15DA
.................... 				} 
.................... 			} 
.................... 			break; 
08DF2:  GOTO    8DF6
.................... 	} 
08DF6:  MOV     #18,W5
08DF8:  REPEAT  #6
08DFA:  MOV     [--W15],[W5--]
08DFC:  MOV     [--W15],W5
08DFE:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Nothing(void) 
.................... * \brief Passe l'objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
....................  
.................... void __Nothing(void) 
.................... { 
.................... 	flag_depl_ok = 1;  
08E00:  BSET.B  85A.6
.................... 	Depl_send=1; 
08E02:  BSET.B  85B.5
.................... 	balise_on = 0; 
08E04:  BCLR.B  85B.1
.................... 	// Quitte la fonction 
.................... 	return; 
08E06:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __LoadObj(unsigned int8 _Obj) 
.................... * \brief Charge le prochain objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 2.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param [in] _Obj Numero de l'objectif desire 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __LoadObj(unsigned int16 _Obj,unsigned int16 pts) 
*
018F8:  MOV     W5,[W15++]
.................... {	 
.................... 	// Enregistre Xp, en [mm] 
.................... 	oXp=TabObjectifs[_Obj][pts][0]; 
018FA:  MOV     1B34,W4
018FC:  MOV     #138,W3
018FE:  MUL.UU  W4,W3,W0
01900:  MOV     W0,W5
01902:  MOV     1B36,W4
01904:  MUL.UU  W4,#18,W0
01906:  ADD     W0,W5,W5
01908:  MOV     #C0A,W4
0190A:  ADD     W5,W4,W0
0190C:  MOV     [W0],[W15++]
0190E:  POP     1492
....................  
.................... 	// Enregistre Yp, en [mm] 
.................... 	oYp=TabObjectifs[_Obj][pts][1]; 
01910:  MOV     1B34,W4
01912:  MOV     #138,W3
01914:  MUL.UU  W4,W3,W0
01916:  MOV     W0,W5
01918:  MOV     1B36,W4
0191A:  MUL.UU  W4,#18,W0
0191C:  ADD     W0,W5,W5
0191E:  ADD     W5,#2,W0
01920:  MOV     #C0A,W4
01922:  ADD     W0,W4,W0
01924:  MOV     [W0],[W15++]
01926:  POP     1494
....................  
.................... 	// Enregistre le type de deplacement, en [nbre] 
.................... 	oType=TabObjectifs[_Obj][pts][2]; 
01928:  MOV     1B34,W4
0192A:  MOV     #138,W3
0192C:  MUL.UU  W4,W3,W0
0192E:  MOV     W0,W5
01930:  MOV     1B36,W4
01932:  MUL.UU  W4,#18,W0
01934:  ADD     W0,W5,W5
01936:  ADD     W5,#4,W0
01938:  MOV     #C0A,W4
0193A:  ADD     W0,W4,W0
0193C:  MOV     [W0],[W15++]
0193E:  POP     1496
....................  
.................... 	// Enregistre si avance ou recule 
.................... 	oAvAr=TabObjectifs[_Obj][pts][3]; 
01940:  MOV     1B34,W4
01942:  MOV     #138,W3
01944:  MUL.UU  W4,W3,W0
01946:  MOV     W0,W5
01948:  MOV     1B36,W4
0194A:  MUL.UU  W4,#18,W0
0194C:  ADD     W0,W5,W5
0194E:  ADD     W5,#6,W0
01950:  MOV     #C0A,W4
01952:  ADD     W0,W4,W0
01954:  MOV     [W0],[W15++]
01956:  POP     1498
....................  
.................... 	// Enregistre le cote duquel tourner 
.................... 	oCoteTourn=TabObjectifs[_Obj][pts][4]; 
01958:  MOV     1B34,W4
0195A:  MOV     #138,W3
0195C:  MUL.UU  W4,W3,W0
0195E:  MOV     W0,W5
01960:  MOV     1B36,W4
01962:  MUL.UU  W4,#18,W0
01964:  ADD     W0,W5,W5
01966:  ADD     W5,#8,W0
01968:  MOV     #C0A,W4
0196A:  ADD     W0,W4,W0
0196C:  MOV     [W0],[W15++]
0196E:  POP     149A
....................  
.................... 	// Enregistre la vitesse maximum, en [mm/s] (en [0/000] pour RoboteQ) 
.................... 	oVitMax=TabObjectifs[_Obj][pts][5]; 
01970:  MOV     1B34,W4
01972:  MOV     #138,W3
01974:  MUL.UU  W4,W3,W0
01976:  MOV     W0,W5
01978:  MOV     1B36,W4
0197A:  MUL.UU  W4,#18,W0
0197C:  ADD     W0,W5,W5
0197E:  ADD     W5,#A,W0
01980:  MOV     #C0A,W4
01982:  ADD     W0,W4,W0
01984:  MOV     [W0],[W15++]
01986:  POP     149C
....................  
.................... 	//Enregistre l'action a faire 
.................... 	Obj_Action = TabObjectifs[_Obj][pts][6]; 
01988:  MOV     1B34,W4
0198A:  MOV     #138,W3
0198C:  MUL.UU  W4,W3,W0
0198E:  MOV     W0,W5
01990:  MOV     1B36,W4
01992:  MUL.UU  W4,#18,W0
01994:  ADD     W0,W5,W5
01996:  ADD     W5,#C,W0
01998:  MOV     #C0A,W4
0199A:  ADD     W0,W4,W0
0199C:  MOV     [W0],[W15++]
0199E:  POP     149E
.................... 	 
.................... 	//Enregistre si le pt est symetrique ou non 
.................... 	Pt_commun = TabObjectifs[_Obj][pts][7]; 
019A0:  MOV     1B34,W4
019A2:  MOV     #138,W3
019A4:  MUL.UU  W4,W3,W0
019A6:  MOV     W0,W5
019A8:  MOV     1B36,W4
019AA:  MUL.UU  W4,#18,W0
019AC:  ADD     W0,W5,W5
019AE:  ADD     W5,#E,W0
019B0:  MOV     #C0A,W4
019B2:  ADD     W0,W4,W0
019B4:  MOV     [W0],[W15++]
019B6:  POP     14A0
.................... 	 
.................... 	//ponderation objectifs 
.................... 	Ponderation = TabObjectifs[_Obj][pts][8];	 
019B8:  MOV     1B34,W4
019BA:  MOV     #138,W3
019BC:  MUL.UU  W4,W3,W0
019BE:  MOV     W0,W5
019C0:  MOV     1B36,W4
019C2:  MUL.UU  W4,#18,W0
019C4:  ADD     W0,W5,W5
019C6:  ADD     W5,#10,W0
019C8:  MOV     #C0A,W4
019CA:  ADD     W0,W4,W0
019CC:  MOV     [W0],[W15++]
019CE:  POP     14A2
.................... 	 
.................... 	//Objectifs fini ou non 
.................... 	Obj_end	= TabObjectifs[_Obj][pts][9];  
019D0:  MOV     1B34,W4
019D2:  MOV     #138,W3
019D4:  MUL.UU  W4,W3,W0
019D6:  MOV     W0,W5
019D8:  MOV     1B36,W4
019DA:  MUL.UU  W4,#18,W0
019DC:  ADD     W0,W5,W5
019DE:  ADD     W5,#12,W0
019E0:  MOV     #C0A,W4
019E2:  ADD     W0,W4,W0
019E4:  MOV     [W0],[W15++]
019E6:  POP     14A4
.................... 	 
.................... 	//prochain objectifs 
.................... 	Next_obj = TabObjectifs[_Obj][pts][10]; 
019E8:  MOV     1B34,W4
019EA:  MOV     #138,W3
019EC:  MUL.UU  W4,W3,W0
019EE:  MOV     W0,W5
019F0:  MOV     1B36,W4
019F2:  MUL.UU  W4,#18,W0
019F4:  ADD     W0,W5,W5
019F6:  ADD     W5,#14,W0
019F8:  MOV     #C0A,W4
019FA:  ADD     W0,W4,W0
019FC:  MOV     [W0],[W15++]
019FE:  POP     14A6
.................... 	 
.................... 	keep_obj = TabObjectifs[_Obj][pts][11]; 
01A00:  MOV     1B34,W4
01A02:  MOV     #138,W3
01A04:  MUL.UU  W4,W3,W0
01A06:  MOV     W0,W5
01A08:  MOV     1B36,W4
01A0A:  MUL.UU  W4,#18,W0
01A0C:  ADD     W0,W5,W5
01A0E:  ADD     W5,#16,W0
01A10:  MOV     #C0A,W4
01A12:  ADD     W0,W4,W0
01A14:  MOV     [W0],[W15++]
01A16:  POP     14A8
....................  
.................... 	// Switch les donnees selon la base choisie et le mode 
.................... 	if(TEAM) 
01A18:  BTSS.B  85B.3
01A1A:  BRA     1A76
.................... 	{ 
.................... 		switch(oType) 
01A1C:  MOV     1496,W0
01A1E:  XOR     #0,W0
01A20:  BRA     Z,1A28
01A22:  XOR     #1,W0
01A24:  BRA     Z,1A48
01A26:  BRA     1A72
.................... 		{ 
.................... 			case 0 : 
.................... 				if(oXp<=180)oXp=180-oXp; //gestion angle 
01A28:  MOV     1492,W4
01A2A:  MOV     #B4,W3
01A2C:  CP      W3,W4
01A2E:  BRA     LT,1A3C
01A30:  MOV     #B4,W4
01A32:  MOV     1492,W3
01A34:  SUB     W4,W3,W0
01A36:  MOV     W0,1492
01A38:  GOTO    1A44
.................... 				else oXp = 540 - oXp; 
01A3C:  MOV     #21C,W4
01A3E:  MOV     1492,W3
01A40:  SUB     W4,W3,W0
01A42:  MOV     W0,1492
.................... 				break; 
01A44:  GOTO    1A76
.................... 			case 1 : 
.................... 				// PaP ou retient sur place, calcul automatique de l'angle, inversion oX et oCoteTourn 
.................... 				// Enregistre Xp, en [mm] 
.................... 				oXp = TableWidth - oXp; 
01A48:  MOV     87E,W4
01A4A:  MOV     1492,W3
01A4C:  SUB     W4,W3,W0
01A4E:  MOV     W0,1492
.................... 				// Enregistre le cote duquel tourner 
.................... 				if(oCoteTourn==1)oCoteTourn=2; 
01A50:  MOV     149A,W4
01A52:  CP      W4,#1
01A54:  BRA     NZ,1A5E
01A56:  MOV     #2,W4
01A58:  MOV     W4,149A
01A5A:  GOTO    1A6E
.................... 				else if(oCoteTourn==2)oCoteTourn=1; 
01A5E:  MOV     149A,W4
01A60:  CP      W4,#2
01A62:  BRA     NZ,1A6C
01A64:  MOV     #1,W4
01A66:  MOV     W4,149A
01A68:  GOTO    1A6E
.................... 				else oCoteTourn=0; 
01A6C:  CLR     149A
.................... 	 
.................... 				break; 
01A6E:  GOTO    1A76
.................... 			default : 
.................... 				break; 
01A72:  GOTO    1A76
.................... 		}		 
.................... 	}						 
01A76:  MOV     [--W15],W5
01A78:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    RDA_isr 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    27.03.2015 
.................... //  Statut :    OK 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Interruption pour la rÃÂ©ception RS232.  
.................... #INT_RDA2 
.................... void RDA2_isr(void) 
*
005FE:  PUSH    42
00600:  PUSH    36
00602:  PUSH    32
00604:  MOV     W0,[W15++]
00606:  MOV     #2,W0
00608:  REPEAT  #C
0060A:  MOV     [W0++],[W15++]
.................... { 
.................... 	// Pour la lecture du caractÃÂ¨re reÃÂ§u 
.................... 	char myChar; 
.................... 	// RÃÂ©ception 
.................... 	myChar = fgetc(ROBOTEQ); 
0060C:  BTSS.B  218.0
0060E:  BRA     60C
00610:  MOV     21C,W0
00612:  MOV.B   W0L,1C74
.................... 	// Ajout au buffer et incrÃÂ©mentation de la longeur du buffer 
.................... 	RoboteQ_receiveBuffer[RoboteQ_receiveLenght] = myChar; 
00614:  MOV     15C4,W4
00616:  LSR     W4,#8,W4
00618:  MOV     #882,W3
0061A:  ADD     W4,W3,W5
0061C:  MOV     1C74,W0
0061E:  MOV.B   W0L,[W5+#0]
.................... 	RoboteQ_receiveLenght++; 
00620:  INC.B   15C5
.................... 	 
.................... 	// Si on trouve la fin de la commande 
.................... 	if(myChar == '\r') 
00622:  MOV     1C74,W4
00624:  CP.B    W4L,#D
00626:  BRA     NZ,62E
.................... 	{ 
.................... 		// On dit qu'on peut lire le buffer de rÃÂ©ception 
.................... 		RoboteQ_receiveToProceed = RoboteQ_receiveLenght; 
00628:  MOV.B   15C5,W0L
0062A:  MOV.B   W0L,15C4
.................... 		RoboteQ_receiveLenght=0; 
0062C:  CLR.B   15C5
.................... 	} 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: TestCartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === ContrÃ´le du robor secondaire.																	== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_h 
0062E:  BCLR.B  87.0
00630:  MOV     #1A,W0
00632:  REPEAT  #C
00634:  MOV     [--W15],[W0--]
00636:  MOV     [--W15],W0
00638:  POP     32
0063A:  POP     36
0063C:  POP     42
0063E:  RETFIE  
.................... #define ___Functions_h 
....................  
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0); 
.................... int1 Eject(void); 
....................  
.................... //unsigned int16 soll_vit_rot  = 1450; 
.................... unsigned int16 soll_vit_rot_zero = 2000;  
.................... unsigned int16 soll_vit_mov = 1200; 
....................  
.................... int1 Sens_rot_Couronne = 0; 
....................  
.................... signed int32 Endposition = 0; //position qui doit etre atteinte a la fin du depl 
.................... unsigned int8 Etat_ejection = 0; 
.................... int1 bras_out = 0; 
.................... //int1 bras_in  = 0; 
.................... //int1 flag_module_fond = 0; 
.................... void __ReadObjectifs(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
.................... void __resetEEPROM(void); 
.................... void __reset_roboteq(void); 
.................... void __GetRoboteqPID(unsigned int8 valeur); 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2); 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr); 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend); 
.................... void __Gestion_surcharge(unsigned int8 Adresse_driver); 
.................... void __Action_Writting(unsigned int8 ActionToDo); 
.................... void __ReadZones_Interdites(void); 
....................  
.................... unsigned int8 driver_Pompes(unsigned int8 Adresse_driver, unsigned int8 pompe_A, unsigned int8 pompe_B, unsigned int8 pompe_C, unsigned int8 pompe_D, unsigned int8 pompe_E); 
.................... unsigned int8 read_driver_pompes(int8 adresse_driver); 
.................... int1 Panneau_Domotique(void); 
.................... int1 Ramassage(unsigned int8 cote); 
.................... int1 Empilage(void); 
.................... int1 GoToZero_Cremaillere(void); 
.................... int1 reinitialisation(void); 
.................... int1 __GoToZero(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
....................  
.................... #include "Functions.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel 
.................... 						: Borgeat Rémy     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Function.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient des fonctions pour le robot																== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_c 
.................... #define ___Functions_c 
....................  
.................... //TEMP//////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_roboteq 300///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_cour 200///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_crem 200///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE impulse -10672///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE distance 52000//////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE START 30 
.................... //unsigned int8 points = 0;////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Afficheur 7 segments 
.................... //	Auteur :	BORR 
.................... //	Date:	    6.1.16 
.................... //  Statut :    Fonctionnel 
.................... //  Futur :     n.a. 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Gère 2 afficheur 7 segments 
.................... //	Paramètre(s): int8 nombre -> nombre<=99 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0) 
.................... { 
.................... 	_EN_Uni = _En_Diz = 1; 
*
01382:  BSET.B  2C9.2
01384:  BSET.B  2C9.3
.................... 	 
.................... 	if(ToBlank) 
01386:  CP0.B   1B3B
01388:  BRA     Z,139A
.................... 	{ 
.................... 		PORTB |= 0b1111<<12; 
0138A:  MOV     #F000,W0
0138C:  IOR     2C8
.................... 		// charge sur les latchs 
.................... 		_EN_Uni = _En_Diz = 0; 
0138E:  BCLR.B  2C9.2
01390:  BCLR.B  2C9.3
.................... 		_EN_Uni = _En_Diz = 1; 
01392:  BSET.B  2C9.2
01394:  BSET.B  2C9.3
.................... 	} 
01396:  GOTO    13D4
.................... 	else 
.................... 	{		 
.................... 		static unsigned int16 dizaine = 0; // variable qui va récupérer le chiffre des dizaine  
.................... 		static unsigned int16 unite = 0; // variable qui va récupérer le chiffre des unité 
.................... 	 
.................... 		dizaine = nombre/10; //récupération du nombre des dizaine 
0139A:  MOV.B   1B3A,W0L
0139C:  SE      W0,W0
0139E:  MOV     W0,W4
013A0:  MOV     #A,W3
013A2:  REPEAT  #11
013A4:  DIV.S   W4,W3
013A6:  MOV     W0,15E4
.................... 		unite   = nombre%10; //récupération du nombre des unités 
013A8:  MOV.B   1B3A,W0L
013AA:  SE      W0,W0
013AC:  MOV     W0,W4
013AE:  MOV     #A,W3
013B0:  REPEAT  #11
013B2:  DIV.S   W4,W3
013B4:  MOV     W1,W0
013B6:  MOV     W0,15E6
.................... 	 
.................... 		dizaine = dizaine * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
013B8:  MOV     15E4,W0
013BA:  SL      W0,#C,W0
013BC:  MOV     W0,15E4
.................... 		unite = unite * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
013BE:  MOV     15E6,W0
013C0:  SL      W0,#C,W0
013C2:  MOV     W0,15E6
.................... 		 
.................... 		_En_Diz = 0; // possibilité d'afficher sur l'afficheur des dizaine	 
013C4:  BCLR.B  2C9.2
.................... 		PORTB = dizaine; //affichage de la valeur sur l'afficheur 
013C6:  PUSH    15E4
013C8:  POP     2C8
.................... 		_En_Diz = 1; // Afficheur dizaine allumé, mais on ne peux plus changer la valeur 
013CA:  BSET.B  2C9.2
.................... 	 
.................... 		_EN_Uni = 0; // possibilité d'afficher sur afficheur unité  
013CC:  BCLR.B  2C9.3
.................... 		PORTB = unite; // affichage des unité sur l'afficheur des unité  
013CE:  PUSH    15E6
013D0:  POP     2C8
.................... 		_EN_Uni = 1; // Afficheur unité allumé, mais on ne peux plus changer la valeur 
013D2:  BSET.B  2C9.3
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
013D4:  RETURN  
.................... } 
....................  
.................... /* 
.................... 	Fct qui reset une partie de l'eeprom en 
.................... 	remettant les valeurs à 0xffff 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 9.2.2017 
.................... */ 
.................... void __resetEEPROM(void) 
*
0A5AC:  MOV     W5,[W15++]
0A5AE:  CLR     1B3E
.................... { 
.................... 	unsigned int16 adresse = 0; 
.................... 	for(adresse = 0; adresse <= 820; adresse +=  2) 
0A5B0:  CLR     1B3E
0A5B2:  MOV     1B3E,W4
0A5B4:  MOV     #334,W3
0A5B6:  CP      W3,W4
0A5B8:  BRA     NC,A5D0
.................... 	{ 
.................... 		write_eeprom(adresse, 0xFFFF);//on écrase l'eeprom 
0A5BA:  MOV     #FFFF,W5
0A5BC:  MOV     1B3E,W0
0A5BE:  MOV     #A,W1
0A5C0:  MOV     #2,W2
0A5C2:  CALL    A186
0A5C6:  MOV     1B3E,W4
0A5C8:  ADD     W4,#2,W0
0A5CA:  MOV     W0,1B3E
0A5CC:  GOTO    A5B2
.................... 	} 
0A5D0:  MOV     [--W15],W5
0A5D2:  RETURN  
.................... } 
.................... void __reset_roboteq(void) 
.................... { 
.................... 	fputc('%',ROBOTEQ); 
*
0A588:  MOV.B   #25,W0L
0A58A:  BTSC.B  219.1
0A58C:  BRA     A58A
0A58E:  MOV.B   W0L,21A
0A590:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"RESET 321654987 \r"); 
0A592:  MOV     #0,W1
0A594:  MOV     W1,W0
0A596:  CLR.B   1
0A598:  CALL    246
0A59C:  INC     W1,W1
0A59E:  BTSC.B  219.1
0A5A0:  BRA     A59E
0A5A2:  MOV     W0,21A
0A5A4:  MOV     #10,W0
0A5A6:  CPSGT   W1,W0
0A5A8:  BRA     A594
0A5AA:  RETURN  
.................... } 
.................... /*======================================================================================= 
.................... 	Fct qui va recuperer les pid du roboteq et les mettre dans un tableau 
.................... =========================================================================================	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date : 16.2.2017 
.................... =========================================================================================	 
.................... 	! on doit faire passer 6x dans la fct. 
.................... 	On doit mettre une boucle exeterieur, car avec dans la fct, 
.................... 	on resete la dedans, et donc on ne peut pas recuperer des caractere 
.................... 	 
.................... 	Trame envoyer : Tab{2,0,:,10,...\r) 
.................... 					Tab{kp1 : ki1 : ...) 
.................... 	Les : separe les donnes, le \r annonce la fin du tableau 
.................... 	 
.................... 	!on peut pas chainer les commande, car il ecrase a chaque fois la reponse de l'ordre precdent 
.................... ==========================================================================================*/ 
.................... void __GetRoboteqPID(unsigned int8 valeur) 
*
0A1C0:  MOV     W5,[W15++]
0A1C2:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 i = 3; // car on recoit KP=110 -> on veut que la valeur --> on saute les 3 premiers caractere 
.................... 	static int8 y = 0; 
.................... 	 
.................... 	switch(valeur) // on demande au roboteq es valeur 
0A1C4:  MOV.B   1B3E,W0L
0A1C6:  CLR.B   1
0A1C8:  XOR     #0,W0
0A1CA:  BRA     Z,A1F2
0A1CC:  XOR     #1,W0
0A1CE:  BRA     Z,A214
0A1D0:  XOR     #3,W0
0A1D2:  BRA     Z,A236
0A1D4:  XOR     #1,W0
0A1D6:  BRA     Z,A258
0A1D8:  XOR     #7,W0
0A1DA:  BRA     Z,A27A
0A1DC:  XOR     #1,W0
0A1DE:  BRA     Z,A29C
0A1E0:  XOR     #3,W0
0A1E2:  BRA     Z,A2BE
0A1E4:  XOR     #1,W0
0A1E6:  BRA     Z,A2E4
0A1E8:  XOR     #F,W0
0A1EA:  BRA     Z,A30A
0A1EC:  XOR     #1,W0
0A1EE:  BRA     Z,A330
0A1F0:  BRA     A356
.................... 	{ 
.................... 		case 0: 
.................... 			fprintf(ROBOTEQ,"~KP 1 \r");			 
0A1F2:  MOV     #0,W1
0A1F4:  MOV     W1,W0
0A1F6:  CLR.B   1
0A1F8:  CALL    264
0A1FC:  INC     W1,W1
0A1FE:  BTSC.B  219.1
0A200:  BRA     A1FE
0A202:  MOV     W0,21A
0A204:  MOV     #6,W0
0A206:  CPSGT   W1,W0
0A208:  BRA     A1F4
.................... 			delay_ms(10);			 
0A20A:  MOV     #A,W0
0A20C:  CALL    F0E
.................... 			break; 
0A210:  GOTO    A356
.................... 		case 1: 
.................... 			fprintf(ROBOTEQ,"~KI 1 \r"); 
0A214:  MOV     #0,W1
0A216:  MOV     W1,W0
0A218:  CLR.B   1
0A21A:  CALL    278
0A21E:  INC     W1,W1
0A220:  BTSC.B  219.1
0A222:  BRA     A220
0A224:  MOV     W0,21A
0A226:  MOV     #6,W0
0A228:  CPSGT   W1,W0
0A22A:  BRA     A216
.................... 			delay_ms(10); 
0A22C:  MOV     #A,W0
0A22E:  CALL    F0E
.................... 			break; 
0A232:  GOTO    A356
.................... 		case 2: 
.................... 			fprintf(ROBOTEQ,"~KD 1 \r"); 
0A236:  MOV     #0,W1
0A238:  MOV     W1,W0
0A23A:  CLR.B   1
0A23C:  CALL    28C
0A240:  INC     W1,W1
0A242:  BTSC.B  219.1
0A244:  BRA     A242
0A246:  MOV     W0,21A
0A248:  MOV     #6,W0
0A24A:  CPSGT   W1,W0
0A24C:  BRA     A238
.................... 			delay_ms(10); 
0A24E:  MOV     #A,W0
0A250:  CALL    F0E
.................... 			break; 
0A254:  GOTO    A356
.................... 		case 3: 
.................... 			fprintf(ROBOTEQ,"~KP 2 \r"); 
0A258:  MOV     #0,W1
0A25A:  MOV     W1,W0
0A25C:  CLR.B   1
0A25E:  CALL    2A0
0A262:  INC     W1,W1
0A264:  BTSC.B  219.1
0A266:  BRA     A264
0A268:  MOV     W0,21A
0A26A:  MOV     #6,W0
0A26C:  CPSGT   W1,W0
0A26E:  BRA     A25A
.................... 			delay_ms(10); 
0A270:  MOV     #A,W0
0A272:  CALL    F0E
.................... 			break; 
0A276:  GOTO    A356
.................... 		case 4: 
.................... 			fprintf(ROBOTEQ,"~KI 2 \r"); 
0A27A:  MOV     #0,W1
0A27C:  MOV     W1,W0
0A27E:  CLR.B   1
0A280:  CALL    2B4
0A284:  INC     W1,W1
0A286:  BTSC.B  219.1
0A288:  BRA     A286
0A28A:  MOV     W0,21A
0A28C:  MOV     #6,W0
0A28E:  CPSGT   W1,W0
0A290:  BRA     A27C
.................... 			delay_ms(10); 
0A292:  MOV     #A,W0
0A294:  CALL    F0E
.................... 			break; 
0A298:  GOTO    A356
.................... 		case 5: 
.................... 			fprintf(ROBOTEQ,"~KD 2 \r"); 
0A29C:  MOV     #0,W1
0A29E:  MOV     W1,W0
0A2A0:  CLR.B   1
0A2A2:  CALL    2C8
0A2A6:  INC     W1,W1
0A2A8:  BTSC.B  219.1
0A2AA:  BRA     A2A8
0A2AC:  MOV     W0,21A
0A2AE:  MOV     #6,W0
0A2B0:  CPSGT   W1,W0
0A2B2:  BRA     A29E
.................... 			delay_ms(10); 
0A2B4:  MOV     #A,W0
0A2B6:  CALL    F0E
.................... 			break;	 
0A2BA:  GOTO    A356
.................... 		case 6: 
.................... 			fprintf(ROBOTEQ,"~MAC 1 \r"); 
0A2BE:  MOV     #0,W1
0A2C0:  MOV     W1,W0
0A2C2:  CLR.B   1
0A2C4:  CALL    2DC
0A2C8:  INC     W1,W1
0A2CA:  BTSC.B  219.1
0A2CC:  BRA     A2CA
0A2CE:  MOV     W0,21A
0A2D0:  MOV     #7,W0
0A2D2:  CPSGT   W1,W0
0A2D4:  BRA     A2C0
.................... 			delay_ms(10); 
0A2D6:  MOV     #A,W0
0A2D8:  CALL    F0E
.................... 			i = 4; 
0A2DC:  MOV.B   #4,W0L
0A2DE:  MOV.B   W0L,15E8
.................... 			break;	 
0A2E0:  GOTO    A356
.................... 		case 7: 
.................... 			fprintf(ROBOTEQ,"~MDEC 1 \r"); 
0A2E4:  MOV     #0,W1
0A2E6:  MOV     W1,W0
0A2E8:  CLR.B   1
0A2EA:  CALL    2F2
0A2EE:  INC     W1,W1
0A2F0:  BTSC.B  219.1
0A2F2:  BRA     A2F0
0A2F4:  MOV     W0,21A
0A2F6:  MOV     #8,W0
0A2F8:  CPSGT   W1,W0
0A2FA:  BRA     A2E6
.................... 			delay_ms(10); 
0A2FC:  MOV     #A,W0
0A2FE:  CALL    F0E
.................... 			i = 5; 
0A302:  MOV.B   #5,W0L
0A304:  MOV.B   W0L,15E8
.................... 			break;	 
0A306:  GOTO    A356
.................... 		case 8: 
.................... 			fprintf(ROBOTEQ,"~MAC 2 \r"); 
0A30A:  MOV     #0,W1
0A30C:  MOV     W1,W0
0A30E:  CLR.B   1
0A310:  CALL    308
0A314:  INC     W1,W1
0A316:  BTSC.B  219.1
0A318:  BRA     A316
0A31A:  MOV     W0,21A
0A31C:  MOV     #7,W0
0A31E:  CPSGT   W1,W0
0A320:  BRA     A30C
.................... 			delay_ms(10); 
0A322:  MOV     #A,W0
0A324:  CALL    F0E
.................... 			i = 4; 
0A328:  MOV.B   #4,W0L
0A32A:  MOV.B   W0L,15E8
.................... 			break;	 
0A32C:  GOTO    A356
.................... 		case 9: 
.................... 			fprintf(ROBOTEQ,"~MDEC 2 \r"); 
0A330:  MOV     #0,W1
0A332:  MOV     W1,W0
0A334:  CLR.B   1
0A336:  CALL    31E
0A33A:  INC     W1,W1
0A33C:  BTSC.B  219.1
0A33E:  BRA     A33C
0A340:  MOV     W0,21A
0A342:  MOV     #8,W0
0A344:  CPSGT   W1,W0
0A346:  BRA     A332
.................... 			delay_ms(10); 
0A348:  MOV     #A,W0
0A34A:  CALL    F0E
.................... 			i = 5; 
0A34E:  MOV.B   #5,W0L
0A350:  MOV.B   W0L,15E8
.................... 			break;	 
0A352:  GOTO    A356
.................... 	}	 
....................  
.................... 	if(RoboteQ_receiveBuffer[0] == 'K' || RoboteQ_receiveBuffer[0] == 'M') 
0A356:  MOV     882,W4
0A358:  XOR.B   #4B,W4L
0A35A:  BRA     Z,A362
0A35C:  MOV     882,W4
0A35E:  XOR.B   #4D,W4L
0A360:  BRA     NZ,A3B6
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i] != 0x0D) // On commence du [2] pour sauter le 'C='. Le +3 est pour le C,= et : (C=xxx:xxx). 
0A362:  MOV.B   15E8,W0L
0A364:  SE      W0,W0
0A366:  MOV     #882,W4
0A368:  ADD     W0,W4,W0
0A36A:  MOV.B   [W0],W5L
0A36C:  SE      W5,W5
0A36E:  CP      W5,#D
0A370:  BRA     Z,A38C
.................... 		{  
.................... 			TabSentRS232[y] = RoboteQ_receiveBuffer[i];				 
0A372:  MOV.B   15E9,W0L
0A374:  SE      W0,W0
0A376:  MOV     #982,W4
0A378:  ADD     W0,W4,W5
0A37A:  MOV.B   15E8,W0L
0A37C:  SE      W0,W0
0A37E:  MOV     #882,W4
0A380:  ADD     W0,W4,W0
0A382:  MOV.B   [W0],[W5]
.................... 			i++; 
0A384:  INC.B   15E8
.................... 			y++; 
0A386:  INC.B   15E9
0A388:  GOTO    A362
.................... 		} 
.................... 		if(valeur<9) 
0A38C:  MOV     1B3E,W4
0A38E:  CP.B    W4L,#9
0A390:  BRA     C,A3A4
.................... 		{	 
.................... 			TabSentRS232[y] = ':';//seperation des valeur	 
0A392:  MOV.B   15E9,W0L
0A394:  SE      W0,W0
0A396:  MOV     #982,W4
0A398:  ADD     W0,W4,W5
0A39A:  MOV.B   #3A,W0L
0A39C:  MOV.B   W0L,[W5]
.................... 			y++; 
0A39E:  INC.B   15E9
.................... 		} 
0A3A0:  GOTO    A3B2
.................... 		else 
.................... 		{ 
.................... 			TabSentRS232[y] = '\r'; // fin de transmssion 
0A3A4:  MOV.B   15E9,W0L
0A3A6:  SE      W0,W0
0A3A8:  MOV     #982,W4
0A3AA:  ADD     W0,W4,W5
0A3AC:  MOV.B   #D,W0L
0A3AE:  MOV.B   W0L,[W5]
.................... 			y = 0 ;	 
0A3B0:  CLR.B   15E9
.................... 		} 
.................... 		i = 3; 
0A3B2:  MOV.B   #3,W0L
0A3B4:  MOV.B   W0L,15E8
.................... 	}	 
0A3B6:  MOV     [--W15],W6
0A3B8:  MOV     [--W15],W5
0A3BA:  RETURN  
....................  
.................... } 
.................... /* 
.................... 	Fct qui va changer les paramètre PID du roboteq. 
.................... 	Les parametre ont ete recu du pc et ont les save en 
.................... 	dans l'eeprom du roboteq 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 16.2.2017 
.................... */ 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2) 
0A3BC:  MOV     W5,[W15++]
.................... { 
.................... 	//envoi des paramètres PID au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"^KP 1 %u_^KI 1 %u_^KD 1 %u_^KP 2 %u_^KI 2 %u_^KD 2 %u \r",P1,I1,D1,P2,I2,D2); 
0A3BE:  MOV     #0,W1
0A3C0:  MOV     W1,W0
0A3C2:  CLR.B   1
0A3C4:  CALL    334
0A3C8:  INC     W1,W1
0A3CA:  BTSC.B  219.1
0A3CC:  BRA     A3CA
0A3CE:  MOV     W0,21A
0A3D0:  MOV     #5,W0
0A3D2:  CPSGT   W1,W0
0A3D4:  BRA     A3C0
0A3D6:  MOV.B   1B54,W0L
0A3D8:  CLR.B   1
0A3DA:  MOV     #0,W4
0A3DC:  CALL    6DFA
0A3E0:  MOV     #8,W1
0A3E2:  MOV     W1,W0
0A3E4:  CLR.B   1
0A3E6:  CALL    334
0A3EA:  INC     W1,W1
0A3EC:  BTSC.B  219.1
0A3EE:  BRA     A3EC
0A3F0:  MOV     W0,21A
0A3F2:  MOV     #E,W0
0A3F4:  CPSGT   W1,W0
0A3F6:  BRA     A3E2
0A3F8:  MOV     1B56,W0
0A3FA:  MOV     #0,W4
0A3FC:  CALL    6DFA
0A400:  MOV     #11,W1
0A402:  MOV     W1,W0
0A404:  CLR.B   1
0A406:  CALL    334
0A40A:  INC     W1,W1
0A40C:  BTSC.B  219.1
0A40E:  BRA     A40C
0A410:  MOV     W0,21A
0A412:  MOV     #17,W0
0A414:  CPSGT   W1,W0
0A416:  BRA     A402
0A418:  MOV     1B58,W0
0A41A:  MOV     #0,W4
0A41C:  CALL    6DFA
0A420:  MOV     #1A,W1
0A422:  MOV     W1,W0
0A424:  CLR.B   1
0A426:  CALL    334
0A42A:  INC     W1,W1
0A42C:  BTSC.B  219.1
0A42E:  BRA     A42C
0A430:  MOV     W0,21A
0A432:  MOV     #20,W0
0A434:  CPSGT   W1,W0
0A436:  BRA     A422
0A438:  MOV     1B5A,W0
0A43A:  MOV     #0,W4
0A43C:  CALL    6DFA
0A440:  MOV     #23,W1
0A442:  MOV     W1,W0
0A444:  CLR.B   1
0A446:  CALL    334
0A44A:  INC     W1,W1
0A44C:  BTSC.B  219.1
0A44E:  BRA     A44C
0A450:  MOV     W0,21A
0A452:  MOV     #29,W0
0A454:  CPSGT   W1,W0
0A456:  BRA     A442
0A458:  MOV     1B5C,W0
0A45A:  MOV     #0,W4
0A45C:  CALL    6DFA
0A460:  MOV     #2C,W1
0A462:  MOV     W1,W0
0A464:  CLR.B   1
0A466:  CALL    334
0A46A:  INC     W1,W1
0A46C:  BTSC.B  219.1
0A46E:  BRA     A46C
0A470:  MOV     W0,21A
0A472:  MOV     #32,W0
0A474:  CPSGT   W1,W0
0A476:  BRA     A462
0A478:  MOV     1B5E,W0
0A47A:  MOV     #0,W4
0A47C:  CALL    6DFA
0A480:  BTSC.B  219.1
0A482:  BRA     A480
0A484:  MOV     #20,W4
0A486:  MOV     W4,21A
0A488:  BTSC.B  219.1
0A48A:  BRA     A488
0A48C:  MOV     #D,W4
0A48E:  MOV     W4,21A
.................... 	fprintf(ROBOTEQ,"^MAC 1 %u_^MDEC 1 %u_^MAC 2 %u_^MDEC 2 %u \r",ac1,dc1,ac2,dc2);// envoie au Roboteq 
0A490:  MOV     #0,W1
0A492:  MOV     W1,W0
0A494:  CLR.B   1
0A496:  CALL    376
0A49A:  INC     W1,W1
0A49C:  BTSC.B  219.1
0A49E:  BRA     A49C
0A4A0:  MOV     W0,21A
0A4A2:  MOV     #6,W0
0A4A4:  CPSGT   W1,W0
0A4A6:  BRA     A492
0A4A8:  MOV     1B60,W0
0A4AA:  MOV     #0,W4
0A4AC:  CALL    6DFA
0A4B0:  MOV     #9,W1
0A4B2:  MOV     W1,W0
0A4B4:  CLR.B   1
0A4B6:  CALL    376
0A4BA:  INC     W1,W1
0A4BC:  BTSC.B  219.1
0A4BE:  BRA     A4BC
0A4C0:  MOV     W0,21A
0A4C2:  MOV     #11,W0
0A4C4:  CPSGT   W1,W0
0A4C6:  BRA     A4B2
0A4C8:  MOV     1B62,W0
0A4CA:  MOV     #0,W4
0A4CC:  CALL    6DFA
0A4D0:  MOV     #14,W1
0A4D2:  MOV     W1,W0
0A4D4:  CLR.B   1
0A4D6:  CALL    376
0A4DA:  INC     W1,W1
0A4DC:  BTSC.B  219.1
0A4DE:  BRA     A4DC
0A4E0:  MOV     W0,21A
0A4E2:  MOV     #1B,W0
0A4E4:  CPSGT   W1,W0
0A4E6:  BRA     A4D2
0A4E8:  MOV     1B64,W0
0A4EA:  MOV     #0,W4
0A4EC:  CALL    6DFA
0A4F0:  MOV     #1E,W1
0A4F2:  MOV     W1,W0
0A4F4:  CLR.B   1
0A4F6:  CALL    376
0A4FA:  INC     W1,W1
0A4FC:  BTSC.B  219.1
0A4FE:  BRA     A4FC
0A500:  MOV     W0,21A
0A502:  MOV     #26,W0
0A504:  CPSGT   W1,W0
0A506:  BRA     A4F2
0A508:  MOV     1B66,W0
0A50A:  MOV     #0,W4
0A50C:  CALL    6DFA
0A510:  BTSC.B  219.1
0A512:  BRA     A510
0A514:  MOV     #20,W4
0A516:  MOV     W4,21A
0A518:  BTSC.B  219.1
0A51A:  BRA     A518
0A51C:  MOV     #D,W4
0A51E:  MOV     W4,21A
....................  
.................... 	write_eeprom(300,P1); 
0A520:  MOV.B   1B54,W0L
0A522:  MOV.B   W0L,A
0A524:  CLR.B   B
0A526:  MOV     #12C,W0
0A528:  MOV     #A,W1
0A52A:  MOV     #2,W2
0A52C:  CALL    A186
.................... 	write_eeprom(302,I1); 
0A530:  MOV     #12E,W0
0A532:  MOV     #1B56,W1
0A534:  MOV     #2,W2
0A536:  CALL    A186
.................... 	write_eeprom(304,D1); 
0A53A:  MOV     #130,W0
0A53C:  MOV     #1B58,W1
0A53E:  MOV     #2,W2
0A540:  CALL    A186
.................... 	write_eeprom(306,P2); 
0A544:  MOV     #132,W0
0A546:  MOV     #1B5A,W1
0A548:  MOV     #2,W2
0A54A:  CALL    A186
.................... 	write_eeprom(308,I2); 
0A54E:  MOV     #134,W0
0A550:  MOV     #1B5C,W1
0A552:  MOV     #2,W2
0A554:  CALL    A186
.................... 	write_eeprom(310,D2); 
0A558:  MOV     #136,W0
0A55A:  MOV     #1B5E,W1
0A55C:  MOV     #2,W2
0A55E:  CALL    A186
.................... 	 
.................... 	//Sauvegarde en eeprom 
.................... 	fputc('%',ROBOTEQ);//pas le choix de faire un putc, car le % est un caractère réservé pour le pritnf 
0A562:  MOV.B   #25,W0L
0A564:  BTSC.B  219.1
0A566:  BRA     A564
0A568:  MOV.B   W0L,21A
0A56A:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"EESAV \r");//envoie du reste de la commande 
0A56C:  MOV     #0,W1
0A56E:  MOV     W1,W0
0A570:  CLR.B   1
0A572:  CALL    3B0
0A576:  INC     W1,W1
0A578:  BTSC.B  219.1
0A57A:  BRA     A578
0A57C:  MOV     W0,21A
0A57E:  MOV     #6,W0
0A580:  CPSGT   W1,W0
0A582:  BRA     A56E
0A584:  MOV     [--W15],W5
0A586:  RETURN  
....................  
.................... } 
....................  
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadObjectifs(void) 
*
01A92:  MOV     W5,[W15++]
01A94:  MOV     W6,[W15++]
01A96:  CLR     1B3E
01A98:  CLR     1B40
01A9A:  CLR     1B42
01A9C:  CLR     1B44
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset; 
.................... 	unsigned int16 NumObj = 0; 
.................... 	unsigned int16 Obj = 0; 
....................  
.................... 	while(y==0) 
01A9E:  CP0     1B40
01AA0:  BRA     NZ,1B26
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
01AA2:  MOV     15EA,W3
01AA4:  MOV     #0,W4
01AA6:  MOV     #2,W5
01AA8:  CALL    1A7A
01AAC:  MOV     W0,1B44
.................... 		NumObj = read_eeprom(offset+2); 
01AAE:  MOV     15EA,W4
01AB0:  ADD     W4,#2,W5
01AB2:  MOV     W5,[W15++]
01AB4:  MOV     W5,W3
01AB6:  MOV     #0,W4
01AB8:  MOV     #2,W5
01ABA:  CALL    1A7A
01ABE:  MOV     [--W15],W5
01AC0:  MOV     W0,1B42
.................... 		if(Obj!=0xFFFF)//Si il en reste 
01AC2:  MOV     1B44,W4
01AC4:  MOV     #FFFF,W3
01AC6:  CP      W3,W4
01AC8:  BRA     Z,1B1E
.................... 		{ 
.................... 			for( i = 0 ; i < 24; i += 2) 
01ACA:  CLR     1B3E
01ACC:  MOV     1B3E,W4
01ACE:  CP      W4,#18
01AD0:  BRA     C,1B10
.................... 			{			 
.................... 				TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
01AD2:  MOV     1B44,W4
01AD4:  MOV     #138,W3
01AD6:  MUL.UU  W4,W3,W0
01AD8:  MOV     W0,W5
01ADA:  MOV     1B42,W4
01ADC:  MUL.UU  W4,#18,W0
01ADE:  ADD     W0,W5,W5
01AE0:  MOV     1B3E,W6
01AE2:  LSR     W6,#1,W6
01AE4:  SL      W6,#1,W0
01AE6:  ADD     W0,W5,W0
01AE8:  MOV     #C0A,W4
01AEA:  ADD     W0,W4,W5
01AEC:  MOV     1B3E,W4
01AEE:  ADD     W4,#4,W6
01AF0:  MOV     W6,W0
01AF2:  ADD     15EA,W0
01AF4:  MOV     W0,W6
01AF6:  MOV     W5,[W15++]
01AF8:  MOV     W6,W3
01AFA:  MOV     #0,W4
01AFC:  MOV     #2,W5
01AFE:  CALL    1A7A
01B02:  MOV     [--W15],W5
01B04:  MOV     W0,[W5]
01B06:  MOV     1B3E,W4
01B08:  ADD     W4,#2,W0
01B0A:  MOV     W0,1B3E
01B0C:  GOTO    1ACC
.................... 			}	 
.................... 			offset += 28;// offset de +24,afin de lire les objectifs suivant	 
01B10:  MOV     15EA,W4
01B12:  ADD     W4,#1C,W0
01B14:  MOV     W0,15EA
.................... 			NbreObjectifs=Obj;	 
01B16:  PUSH    1B44
01B18:  POP     14B4
.................... 		} 
01B1A:  GOTO    1B22
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
01B1E:  MOV     #1,W4
01B20:  MOV     W4,1B40
.................... 		} 
01B22:  GOTO    1A9E
.................... 	} 
01B26:  MOV     [--W15],W6
01B28:  MOV     [--W15],W5
01B2A:  RETURN  
....................  
.................... } 
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadZones_Interdites(void) 
*
0A5D4:  MOV     W5,[W15++]
0A5D6:  MOV     W6,[W15++]
0A5D8:  CLR     1B3E
0A5DA:  CLR     1B40
0A5DC:  CLR     1B42
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset = 200; 
.................... 	unsigned int16 NumZone = 0; 
....................  
.................... 	while(y==0) 
0A5DE:  CP0     1B40
0A5E0:  BRA     NZ,A64E
.................... 	{ 
.................... 		NumZone = read_eeprom(offset);//on check si il reste des objectifs 
0A5E2:  MOV     15EC,W3
0A5E4:  MOV     #0,W4
0A5E6:  MOV     #2,W5
0A5E8:  CALL    1A7A
0A5EC:  MOV     W0,1B42
.................... 		if(NumZone!=0xFFFF)//Si il en reste 
0A5EE:  MOV     1B42,W4
0A5F0:  MOV     #FFFF,W3
0A5F2:  CP      W3,W4
0A5F4:  BRA     Z,A646
.................... 		{ 
.................... 			for( i = 0 ; i < 16; i += 2) 
0A5F6:  CLR     1B3E
0A5F8:  MOV     1B3E,W4
0A5FA:  CP      W4,#10
0A5FC:  BRA     C,A63A
.................... 			{ 
.................... 				TabZones[NumZone][(i/2)] = read_eeprom(i+2+offset);//remplir le tableau avec les objectifs 
0A5FE:  MOV     1B42,W5
0A600:  SL      W5,#4,W5
0A602:  MOV     1B3E,W6
0A604:  LSR     W6,#1,W6
0A606:  SL      W6,#2,W0
0A608:  ADD     W0,W5,W0
0A60A:  MOV     #B60,W4
0A60C:  ADD     W0,W4,W5
0A60E:  MOV     1B3E,W4
0A610:  ADD     W4,#2,W6
0A612:  MOV     W6,W0
0A614:  ADD     15EC,W0
0A616:  MOV     W0,W6
0A618:  MOV     W5,[W15++]
0A61A:  MOV     W6,W3
0A61C:  MOV     #0,W4
0A61E:  MOV     #2,W5
0A620:  CALL    1A7A
0A624:  MOV     [--W15],W5
0A626:  MOV     W0,[W5]
0A628:  MOV.B   #0,W4L
0A62A:  MOV.B   W4L,[W5+#2]
0A62C:  MOV.B   #0,W3L
0A62E:  MOV.B   W3L,[W5+#3]
0A630:  MOV     1B3E,W4
0A632:  ADD     W4,#2,W0
0A634:  MOV     W0,1B3E
0A636:  GOTO    A5F8
.................... 			}	 
.................... 			offset += 18;// offset de +24,afin de lire les objectifs suivant	 
0A63A:  MOV     15EC,W4
0A63C:  ADD     W4,#12,W0
0A63E:  MOV     W0,15EC
.................... 			NbreZone_check++; 
0A640:  INC.B   0880
.................... 		} 
0A642:  GOTO    A64A
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
0A646:  MOV     #1,W4
0A648:  MOV     W4,1B40
.................... 		} 
0A64A:  GOTO    A5DE
.................... 			 
.................... 	} 
0A64E:  MOV     [--W15],W6
0A650:  MOV     [--W15],W5
0A652:  RETURN  
.................... //	NbreZone = read_eeprom(512);	 
.................... } 
....................  
.................... // Actions à effectuer 
.................... void __Action_Writting(unsigned int8 ActionToDo) 
.................... { 
.................... //	unsigned int8 StateDriver = 0; 
.................... 	switch(ActionToDo) 
*
09C48:  MOV.B   1B32,W0L
09C4A:  CLR.B   1
09C4C:  XOR     #0,W0
09C4E:  BRA     Z,9C72
09C50:  XOR     #1,W0
09C52:  BRA     Z,9C78
09C54:  XOR     #3,W0
09C56:  BRA     Z,9C82
09C58:  XOR     #1,W0
09C5A:  BRA     Z,9C8E
09C5C:  XOR     #7,W0
09C5E:  BRA     Z,9C9A
09C60:  XOR     #1,W0
09C62:  BRA     Z,9CA6
09C64:  XOR     #2,W0
09C66:  BRA     Z,9CAE
09C68:  XOR     #F,W0
09C6A:  BRA     Z,9CB6
09C6C:  XOR     #1,W0
09C6E:  BRA     Z,9CBE
09C70:  BRA     9CC6
.................... 	{ 
.................... 		// Ne fait rien 
.................... 		case 0 : 
.................... 			Action_send=1; 
09C72:  BSET.B  85B.7
.................... 			break;		 
09C74:  GOTO    9CD2
.................... 		case 1 : 
.................... 			Ramassage(0); 
09C78:  CLR.B   1B34
09C7A:  CALL    8EAE
.................... 			break;	 
09C7E:  GOTO    9CD2
.................... 		case 2 :  
.................... 			Ramassage(1); 
09C82:  MOV.B   #1,W0L
09C84:  MOV.B   W0L,1B34
09C86:  CALL    8EAE
.................... 			break; 
09C8A:  GOTO    9CD2
.................... 		case 3 :  
.................... 			Ramassage(2); 
09C8E:  MOV.B   #2,W0L
09C90:  MOV.B   W0L,1B34
09C92:  CALL    8EAE
.................... 			break; 
09C96:  GOTO    9CD2
.................... 		case 4 :  
.................... 			Ramassage(3); 
09C9A:  MOV.B   #3,W0L
09C9C:  MOV.B   W0L,1B34
09C9E:  CALL    8EAE
.................... 			break; 
09CA2:  GOTO    9CD2
.................... 		case 5 :  
.................... 			Empilage(); 
09CA6:  CALL    926A
.................... 			break; 
09CAA:  GOTO    9CD2
.................... 		case 7 : 
.................... 			Panneau_Domotique(); 
09CAE:  CALL    9A94
.................... 			break; 
09CB2:  GOTO    9CD2
.................... 		case 8 :  
.................... 			GoToZero_Cremaillere(); 
09CB6:  CALL    1858
.................... 			break; 
09CBA:  GOTO    9CD2
.................... 		case 9 :  
.................... 			reinitialisation(); 
09CBE:  CALL    9C1E
.................... 			break; 
09CC2:  GOTO    9CD2
.................... 		default : 
.................... 			__Affichage_erreur(5); 
09CC6:  MOV.B   #5,W0L
09CC8:  MOV.B   W0L,1B3A
09CCA:  CALL    107A
.................... 			break; 
09CCE:  GOTO    9CD2
.................... 	} 
09CD2:  RETURN  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour afficher le code de la carte afficheur 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 Affichage_Score(unsigned int8 adresse_driver, unsigned int8 Total) 
.................... { 
.................... 	i2c_start(); 
.................... 	if(i2c_write(adresse_driver) == 0)			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(Total); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 0; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour enclencher ou déclencher les pompes 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 driver_Pompes(unsigned int8 adresse_driver, unsigned int8 pompe_A, unsigned int8 pompe_B, unsigned int8 pompe_C, unsigned int8 pompe_D, unsigned int8 pompe_E) 
*
010CC:  MOV     W5,[W15++]
.................... { 
.................... 	delay_ms(2000); 
010CE:  MOV     #7D0,W0
010D0:  CALL    F0E
.................... 	unsigned int8 ordre = 0; 
010D4:  CLR.B   1B44
.................... 	ordre = pompe_A*16 + pompe_B*8 + pompe_C*4 + pompe_D*2 + pompe_E; 
010D6:  MOV.B   1B3F,W0L
010D8:  CLR.B   1
010DA:  SL      W0,#4,W5
010DC:  MOV.B   1B40,W0L
010DE:  CLR.B   1
010E0:  SL      W0,#3,W0
010E2:  ADD     W0,W5,W5
010E4:  MOV.B   1B41,W0L
010E6:  CLR.B   1
010E8:  SL      W0,#2,W0
010EA:  ADD     W0,W5,W5
010EC:  MOV.B   1B42,W0L
010EE:  CLR.B   1
010F0:  SL      W0,#1,W0
010F2:  ADD     W0,W5,W5
010F4:  MOV     W5,W0
010F6:  ADD.B   1B43,W0L
010F8:  MOV.B   W0L,1B44
....................  
.................... 	i2c_start(); 
010FA:  BTSS.B  208.3
010FC:  BRA     1106
010FE:  BSET.B  206.1
01100:  BTSC.B  206.1
01102:  BRA     1100
01104:  BRA     110C
01106:  BSET.B  206.0
01108:  BTSC.B  206.0
0110A:  BRA     1108
.................... 	if(i2c_write(adresse_driver) == 0)			//ADRESSE 
0110C:  MOV.B   1B3E,W0L
0110E:  MOV.B   W0L,2
01110:  CALL    E62
01114:  CP0.B   W0L
01116:  BRA     NZ,1124
.................... 	{ 
.................... 		i2c_write(ordre); 
01118:  MOV.B   1B44,W0L
0111A:  MOV.B   W0L,2
0111C:  CALL    E62
.................... 	} 
01120:  GOTO    1134
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
01124:  MOV     #1F,W0
01126:  AND     206,W0
01128:  BRA     NZ,1124
0112A:  BSET.B  206.2
0112C:  BTSC.B  206.2
0112E:  BRA     112C
.................... 		return 0; 
01130:  CLR.B   0
01132:  BRA     114A
.................... 	} 
.................... 	i2c_stop();	 
01134:  MOV     #1F,W0
01136:  AND     206,W0
01138:  BRA     NZ,1134
0113A:  BSET.B  206.2
0113C:  BTSC.B  206.2
0113E:  BRA     113C
.................... 	delay_ms(2000); 
01140:  MOV     #7D0,W0
01142:  CALL    F0E
.................... 	return 1; 
01146:  MOV.B   #1,W0L
01148:  MOV.B   W0L,0
0114A:  MOV     [--W15],W5
0114C:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour lire l'état des pompes 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 read_driver_pompes(int8 adresse_driver) 
*
08E60:  MOV     W5,[W15++]
08E62:  CLR.B   1B38
.................... { 
.................... 	int8 driver_etat; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
08E64:  BTSS.B  208.3
08E66:  BRA     8E70
08E68:  BSET.B  206.1
08E6A:  BTSC.B  206.1
08E6C:  BRA     8E6A
08E6E:  BRA     8E76
08E70:  BSET.B  206.0
08E72:  BTSC.B  206.0
08E74:  BRA     8E72
.................... 	ack = i2c_write(adresse_driver+1); 
08E76:  MOV.B   1B36,W0L
08E78:  SE      W0,W0
08E7A:  ADD     W0,#1,W5
08E7C:  MOV.B   W5L,W1L
08E7E:  CALL    E62
08E82:  MOV.B   W0L,1B38
.................... 	if(ack == 0) 
08E84:  MOV.B   1B38,W0L
08E86:  SE      W0,W0
08E88:  CP0     W0
08E8A:  BRA     NZ,8E98
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
08E8C:  CLR.B   W1
08E8E:  CALL    1308
08E92:  MOV.B   W0L,1B37
.................... 	} 
08E94:  GOTO    8E9C
.................... 	else driver_etat = 0b1000000; 
08E98:  MOV.B   #40,W0L
08E9A:  MOV.B   W0L,1B37
....................  
.................... 	i2c_stop(); 
08E9C:  MOV     #1F,W0
08E9E:  AND     206,W0
08EA0:  BRA     NZ,8E9C
08EA2:  BSET.B  206.2
08EA4:  BTSC.B  206.2
08EA6:  BRA     8EA4
.................... 	return driver_etat; 
08EA8:  MOV.B   1B37,W0L
08EAA:  MOV     [--W15],W5
08EAC:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour allumer le panneau domotique 
.................... //============================================================================================================================ 
....................  
.................... int1 Panneau_Domotique(void) 
*
09A94:  MOV     W5,[W15++]
.................... { 
.................... 	static int8 action; 
.................... 	static int8 etat; 
.................... 	static int8 etat_cremaillere; 
....................  
.................... 	switch(action) 
09A96:  MOV.B   15EE,W0L
09A98:  SE      W0,W0
09A9A:  XOR     #0,W0
09A9C:  BRA     Z,9AAC
09A9E:  XOR     #1,W0
09AA0:  BRA     Z,9AFE
09AA2:  XOR     #3,W0
09AA4:  BRA     Z,9BB8
09AA6:  XOR     #1,W0
09AA8:  BRA     Z,9C0C
09AAA:  BRA     9C1A
.................... 	{ 
.................... 		case 0 : 
....................  
.................... 				if(Etat!=1)  
09AAC:  MOV.B   15EF,W0L
09AAE:  SE      W0,W0
09AB0:  CP      W0,#1
09AB2:  BRA     Z,9ADC
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,25500); 
09AB4:  MOV.B   #C0,W0L
09AB6:  MOV.B   W0L,1B3C
09AB8:  MOV.B   #1,W0L
09ABA:  MOV.B   W0L,1B3D
09ABC:  MOV.B   #1,W0L
09ABE:  MOV.B   W0L,1B3E
09AC0:  MOV.B   #2,W0L
09AC2:  MOV.B   W0L,1B3F
09AC4:  MOV     #1388,W4
09AC6:  MOV     W4,1B40
09AC8:  MOV     #639C,W4
09ACA:  MOV     W4,1B42
09ACC:  CLR     1B44
09ACE:  CALL    114E
09AD2:  MOV.B   W0L,15EF
.................... 					return(0); 
09AD4:  CLR.B   0
09AD6:  BRA     9C1A
.................... 				} 
09AD8:  GOTO    9AFA
.................... 				else  
.................... 				{ 
.................... 					driver_Pompes(0xA0,0,0,0,0,0);	 
09ADC:  MOV.B   #A0,W0L
09ADE:  MOV.B   W0L,1B3E
09AE0:  CLR.B   1B3F
09AE2:  CLR.B   1B40
09AE4:  CLR.B   1B41
09AE6:  CLR.B   1B42
09AE8:  CLR.B   1B43
09AEA:  CALL    10CC
.................... 					Etat = 0 ; 
09AEE:  CLR.B   15EF
.................... 					action = 1; 
09AF0:  MOV.B   #1,W0L
09AF2:  MOV.B   W0L,15EE
.................... 					return(1); 
09AF4:  MOV.B   #1,W0L
09AF6:  MOV.B   W0L,0
09AF8:  BRA     9C1A
.................... 				}			 
....................  
.................... 		break; 
09AFA:  GOTO    9C1A
....................  
.................... 		case 1 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
09AFE:  MOV.B   #C0,W0L
09B00:  MOV.B   W0L,1B36
09B02:  CALL    146C
09B06:  MOV.B   W0L,15F0
....................  
.................... 			if(etat_cremaillere==1) 
09B08:  MOV.B   15F0,W0L
09B0A:  SE      W0,W0
09B0C:  CP      W0,#1
09B0E:  BRA     NZ,9BB4
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",50,50); 
09B10:  MOV     #0,W1
09B12:  MOV     W1,W0
09B14:  CLR.B   1
09B16:  CALL    3C4
09B1A:  INC     W1,W1
09B1C:  BTSC.B  219.1
09B1E:  BRA     9B1C
09B20:  MOV     W0,21A
09B22:  MOV     #4,W0
09B24:  CPSGT   W1,W0
09B26:  BRA     9B12
09B28:  MOV     #32,W0
09B2A:  MOV     #8007,W4
09B2C:  CALL    916A
09B30:  MOV     #9,W1
09B32:  MOV     W1,W0
09B34:  CLR.B   1
09B36:  CALL    3C4
09B3A:  INC     W1,W1
09B3C:  BTSC.B  219.1
09B3E:  BRA     9B3C
09B40:  MOV     W0,21A
09B42:  MOV     #E,W0
09B44:  CPSGT   W1,W0
09B46:  BRA     9B32
09B48:  MOV     #32,W0
09B4A:  MOV     #8007,W4
09B4C:  CALL    916A
09B50:  BTSC.B  219.1
09B52:  BRA     9B50
09B54:  MOV     #20,W4
09B56:  MOV     W4,21A
09B58:  BTSC.B  219.1
09B5A:  BRA     9B58
09B5C:  MOV     #D,W4
09B5E:  MOV     W4,21A
.................... 				fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-25000,-25000); 
09B60:  MOV     #0,W1
09B62:  MOV     W1,W0
09B64:  CLR.B   1
09B66:  CALL    1B6
09B6A:  INC     W1,W1
09B6C:  BTSC.B  219.1
09B6E:  BRA     9B6C
09B70:  MOV     W0,21A
09B72:  MOV     #5,W0
09B74:  CPSGT   W1,W0
09B76:  BRA     9B62
09B78:  MOV     #9E58,W0
09B7A:  MOV     #8007,W4
09B7C:  CALL    916A
09B80:  MOV     #A,W1
09B82:  MOV     W1,W0
09B84:  CLR.B   1
09B86:  CALL    1B6
09B8A:  INC     W1,W1
09B8C:  BTSC.B  219.1
09B8E:  BRA     9B8C
09B90:  MOV     W0,21A
09B92:  MOV     #10,W0
09B94:  CPSGT   W1,W0
09B96:  BRA     9B82
09B98:  MOV     #9E58,W0
09B9A:  MOV     #8007,W4
09B9C:  CALL    916A
09BA0:  BTSC.B  219.1
09BA2:  BRA     9BA0
09BA4:  MOV     #20,W4
09BA6:  MOV     W4,21A
09BA8:  BTSC.B  219.1
09BAA:  BRA     9BA8
09BAC:  MOV     #D,W4
09BAE:  MOV     W4,21A
....................  
.................... 				action = 2; 
09BB0:  MOV.B   #2,W0L
09BB2:  MOV.B   W0L,15EE
.................... 			} 
....................  
.................... 		break; 
09BB4:  GOTO    9C1A
....................  
.................... 		case 2 : 
.................... 		/* 
.................... 			delay_ms(5000); 
.................... 			//__Check_commande_atteint();  
....................             if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
....................             {	 
.................... 				fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",50,50); 
.................... 				fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",25000,25000); 
....................  
.................... 				action = 3; 
.................... 				points = points + 25; 
....................             } 
....................           */ 
....................            
....................           if(_Capdist==0) 
09BB8:  BTSC.B  2C3.5
09BBA:  BRA     9C08
....................           { 
.................... 	          fprintf(ROBOTEQ,"!MS 1_!MS 2\r");                    
09BBC:  MOV     #0,W1
09BBE:  MOV     W1,W0
09BC0:  CLR.B   1
09BC2:  CALL    3E6
09BC6:  INC     W1,W1
09BC8:  BTSC.B  219.1
09BCA:  BRA     9BC8
09BCC:  MOV     W0,21A
09BCE:  MOV     #B,W0
09BD0:  CPSGT   W1,W0
09BD2:  BRA     9BBE
.................... 	          fprintf(ROBOTEQ,"^mmod 1 0_^mmod 2 0\r"); 
09BD4:  MOV     #0,W1
09BD6:  MOV     W1,W0
09BD8:  CLR.B   1
09BDA:  CALL    400
09BDE:  INC     W1,W1
09BE0:  BTSC.B  219.1
09BE2:  BRA     9BE0
09BE4:  MOV     W0,21A
09BE6:  MOV     #13,W0
09BE8:  CPSGT   W1,W0
09BEA:  BRA     9BD6
.................... 	          fprintf(ROBOTEQ,"^mmod 1 3_^mmod 2 3\r");  
09BEC:  MOV     #0,W1
09BEE:  MOV     W1,W0
09BF0:  CLR.B   1
09BF2:  CALL    422
09BF6:  INC     W1,W1
09BF8:  BTSC.B  219.1
09BFA:  BRA     9BF8
09BFC:  MOV     W0,21A
09BFE:  MOV     #13,W0
09C00:  CPSGT   W1,W0
09C02:  BRA     9BEE
.................... 	           
.................... 	          action = 3;    
09C04:  MOV.B   #3,W0L
09C06:  MOV.B   W0L,15EE
.................... 	      }   
....................  
....................         break; 
09C08:  GOTO    9C1A
....................  
.................... 		case 3 : 
.................... 			 
.................... 			//delay_ms(5000); 
.................... 			//__Check_commande_atteint(); 
....................             if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
....................             { 
....................             	Action_send = 1; 
09C0C:  BSET.B  85B.7
....................             	Check=1; 
09C0E:  BSET.B  85B.4
.................... 			   	action = 0; 
09C10:  CLR.B   15EE
.................... 				etat = 0; 
09C12:  CLR.B   15EF
.................... 				etat_cremaillere = 0;   
09C14:  CLR.B   15F0
.................... 			} 
....................  
.................... 		break;       				 
09C16:  GOTO    9C1A
.................... 	} 
09C1A:  MOV     [--W15],W5
09C1C:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction qui permet de ramasser les cubes (doit fournir un paramètre pour savoir de quelle côté de la croix on arrive) 
.................... //============================================================================================================================ 
....................  
.................... int1 Ramassage(unsigned int8 cote) 
*
08EAE:  MOV     W5,[W15++]
08EB0:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 action; 
.................... 	static int8 Etat; 
.................... 	static int8 etat_cremaillere; 
.................... 	static int8 etat_couronne; 
.................... 	static signed int32 impulse_couronne; 
.................... 	static int1 sens; 
....................  
.................... 	static int8 etat_pompes; 
.................... 	static int8 i; 
....................  
.................... 	switch(action) 
08EB2:  MOV.B   15F1,W0L
08EB4:  SE      W0,W0
08EB6:  XOR     #0,W0
08EB8:  BRA     Z,8EDC
08EBA:  XOR     #1,W0
08EBC:  BRA     Z,8F34
08EBE:  XOR     #3,W0
08EC0:  BRA     Z,8F74
08EC2:  XOR     #1,W0
08EC4:  BRA     Z,8FC4
08EC6:  XOR     #7,W0
08EC8:  BRA     Z,901A
08ECA:  XOR     #1,W0
08ECC:  BRA     Z,905C
08ECE:  XOR     #1B,W0
08ED0:  BRA     Z,90B0
08ED2:  XOR     #18,W0
08ED4:  BRA     Z,90FC
08ED6:  XOR     #1,W0
08ED8:  BRA     Z,9140
08EDA:  BRA     9164
.................... 	{ 
.................... 		case 0 : 
....................  
.................... 			switch(cote) 
08EDC:  MOV.B   1B34,W0L
08EDE:  CLR.B   1
08EE0:  XOR     #0,W0
08EE2:  BRA     Z,8EF2
08EE4:  XOR     #1,W0
08EE6:  BRA     Z,8F00
08EE8:  XOR     #3,W0
08EEA:  BRA     Z,8F10
08EEC:  XOR     #1,W0
08EEE:  BRA     Z,8F20
08EF0:  BRA     8F30
.................... 			{ 
.................... 				case 0 : 
....................  
.................... 					impulse_couronne = 0; 
08EF2:  CLR     15F6
08EF4:  CLR     15F8
.................... 					sens = 1; 
08EF6:  BSET.B  14B1.6
.................... 					action = 2; 
08EF8:  MOV.B   #2,W0L
08EFA:  MOV.B   W0L,15F1
....................  
.................... 				break; 
08EFC:  GOTO    8F30
....................  
.................... 				case 1 : 
....................  
.................... 					impulse_couronne = 16192; 
08F00:  MOV     #3F40,W4
08F02:  MOV     W4,15F6
08F04:  CLR     15F8
.................... 					sens = 0; 
08F06:  BCLR.B  14B1.6
.................... 					action = 1; 
08F08:  MOV.B   #1,W0L
08F0A:  MOV.B   W0L,15F1
....................  
.................... 				break; 
08F0C:  GOTO    8F30
....................  
.................... 				case 2 : 
....................  
.................... 					impulse_couronne = -32384; 
08F10:  MOV     #8180,W4
08F12:  MOV     W4,15F6
08F14:  SETM    15F8
.................... 					sens = 1; 
08F16:  BSET.B  14B1.6
.................... 					action = 1; 
08F18:  MOV.B   #1,W0L
08F1A:  MOV.B   W0L,15F1
....................  
.................... 				break; 
08F1C:  GOTO    8F30
....................  
.................... 				case 3 : 
....................  
.................... 					impulse_couronne = -16192; 
08F20:  MOV     #C0C0,W4
08F22:  MOV     W4,15F6
08F24:  SETM    15F8
.................... 					sens = 0; 
08F26:  BCLR.B  14B1.6
.................... 					action = 1; 
08F28:  MOV.B   #1,W0L
08F2A:  MOV.B   W0L,15F1
....................  
.................... 				break; 
08F2C:  GOTO    8F30
.................... 			} 
....................  
.................... 		break; 
08F30:  GOTO    9164
....................  
.................... 		case 1 : 
....................  
.................... 				if(Etat!=1)  
08F34:  MOV.B   15F2,W0L
08F36:  SE      W0,W0
08F38:  CP      W0,#1
08F3A:  BRA     Z,8F64
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,impulse_couronne); 
08F3C:  MOV.B   #C2,W0L
08F3E:  MOV.B   W0L,1B3C
08F40:  CLR.B   1B3D
08F42:  MOV.B   #1,W0L
08F44:  MOV.B   W0L,1B3E
08F46:  MOV.B   #2,W0L
08F48:  MOV.B   W0L,1B3F
08F4A:  MOV     #1388,W4
08F4C:  MOV     W4,1B40
08F4E:  PUSH    15F6
08F50:  POP     1B42
08F52:  PUSH    15F8
08F54:  POP     1B44
08F56:  CALL    114E
08F5A:  MOV.B   W0L,15F2
.................... 					return(0); 
08F5C:  CLR.B   0
08F5E:  BRA     9164
.................... 				} 
08F60:  GOTO    8F70
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
08F64:  CLR.B   15F2
.................... 					action = 2; 
08F66:  MOV.B   #2,W0L
08F68:  MOV.B   W0L,15F1
.................... 					return(1); 
08F6A:  MOV.B   #1,W0L
08F6C:  MOV.B   W0L,0
08F6E:  BRA     9164
.................... 				}			 
....................  
.................... 		break; 
08F70:  GOTO    9164
....................  
.................... 		case 2 : 
.................... 		 
.................... 			etat_couronne = __Check_action_end(0xC2); 
08F74:  MOV.B   #C2,W0L
08F76:  MOV.B   W0L,1B36
08F78:  CALL    146C
08F7C:  MOV.B   W0L,15F4
....................  
.................... 			if(etat_couronne==1) 
08F7E:  MOV.B   15F4,W0L
08F80:  SE      W0,W0
08F82:  CP      W0,#1
08F84:  BRA     NZ,8FC0
.................... 			{	 
.................... 				//if(impulse_couronne!=0) 
.................... 				//{ 
.................... 				//	etat_couronne = __Check_action_end(0xC2); 
.................... 				//} 
.................... 				//else 
.................... 				//{ 
.................... 				//	etat_couronne=1; 
.................... 				//}		 
.................... 	 
.................... 				//if(etat_couronne==1) 
.................... 				//{		 
.................... 					if(Etat!=1)  
08F86:  MOV.B   15F2,W0L
08F88:  SE      W0,W0
08F8A:  CP      W0,#1
08F8C:  BRA     Z,8FB4
.................... 					{				 
.................... 						Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,-22000);//go_driver_moteur(0xC0,0,DRV_MODE_NON_REGUL,100,DRV_ARRET_COURANT,500); 
08F8E:  MOV.B   #C0,W0L
08F90:  MOV.B   W0L,1B3C
08F92:  CLR.B   1B3D
08F94:  MOV.B   #1,W0L
08F96:  MOV.B   W0L,1B3E
08F98:  MOV.B   #2,W0L
08F9A:  MOV.B   W0L,1B3F
08F9C:  MOV     #1388,W4
08F9E:  MOV     W4,1B40
08FA0:  MOV     #AA10,W4
08FA2:  MOV     W4,1B42
08FA4:  SETM    1B44
08FA6:  CALL    114E
08FAA:  MOV.B   W0L,15F2
.................... 						return(0);			 
08FAC:  CLR.B   0
08FAE:  BRA     9164
.................... 					} 
08FB0:  GOTO    8FC0
.................... 					else  
.................... 					{	 
.................... 						Etat = 0 ; 
08FB4:  CLR.B   15F2
.................... 						action = 3; 
08FB6:  MOV.B   #3,W0L
08FB8:  MOV.B   W0L,15F1
.................... 						return(1); 
08FBA:  MOV.B   #1,W0L
08FBC:  MOV.B   W0L,0
08FBE:  BRA     9164
.................... 					} 
.................... 				//} 
.................... 			} 
....................  
.................... 		break; 
08FC0:  GOTO    9164
....................  
.................... 		case 3 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
08FC4:  MOV.B   #C0,W0L
08FC6:  MOV.B   W0L,1B36
08FC8:  CALL    146C
08FCC:  MOV.B   W0L,15F3
....................  
.................... 			if(etat_cremaillere==1) 
08FCE:  MOV.B   15F3,W0L
08FD0:  SE      W0,W0
08FD2:  CP      W0,#1
08FD4:  BRA     NZ,9016
.................... 			{ 
.................... 				if(Etat!=1)  
08FD6:  MOV.B   15F2,W0L
08FD8:  SE      W0,W0
08FDA:  CP      W0,#1
08FDC:  BRA     Z,9004
.................... 				{				 
.................... 					Etat = driver_Pompes(0xA0, 1, 1, 1, 1, 1); 
08FDE:  MOV.B   #A0,W0L
08FE0:  MOV.B   W0L,1B3E
08FE2:  MOV.B   #1,W0L
08FE4:  MOV.B   W0L,1B3F
08FE6:  MOV.B   #1,W0L
08FE8:  MOV.B   W0L,1B40
08FEA:  MOV.B   #1,W0L
08FEC:  MOV.B   W0L,1B41
08FEE:  MOV.B   #1,W0L
08FF0:  MOV.B   W0L,1B42
08FF2:  MOV.B   #1,W0L
08FF4:  MOV.B   W0L,1B43
08FF6:  CALL    10CC
08FFA:  MOV.B   W0L,15F2
.................... 					return(0);			 
08FFC:  CLR.B   0
08FFE:  BRA     9164
.................... 				} 
09000:  GOTO    9016
.................... 				else  
.................... 				{	 
.................... 					delay_ms(1000); 
09004:  MOV     #3E8,W0
09006:  CALL    F0E
.................... 					Etat = 0; 
0900A:  CLR.B   15F2
.................... 					action = 4; 
0900C:  MOV.B   #4,W0L
0900E:  MOV.B   W0L,15F1
.................... 					return(1); 
09010:  MOV.B   #1,W0L
09012:  MOV.B   W0L,0
09014:  BRA     9164
.................... 				} 
.................... 			} 
....................  
.................... 		break; 
09016:  GOTO    9164
....................  
.................... 		case 4 : 
....................  
.................... 			if(Etat!=1)  
0901A:  MOV.B   15F2,W0L
0901C:  SE      W0,W0
0901E:  CP      W0,#1
09020:  BRA     Z,9048
.................... 			{				 
.................... 				Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,22000); 
09022:  MOV.B   #C0,W0L
09024:  MOV.B   W0L,1B3C
09026:  CLR.B   1B3D
09028:  MOV.B   #1,W0L
0902A:  MOV.B   W0L,1B3E
0902C:  MOV.B   #2,W0L
0902E:  MOV.B   W0L,1B3F
09030:  MOV     #1388,W4
09032:  MOV     W4,1B40
09034:  MOV     #55F0,W4
09036:  MOV     W4,1B42
09038:  CLR     1B44
0903A:  CALL    114E
0903E:  MOV.B   W0L,15F2
.................... 				return(0);			 
09040:  CLR.B   0
09042:  BRA     9164
.................... 			} 
09044:  GOTO    9054
.................... 			else  
.................... 			{	 
.................... 				Etat = 0 ; 
09048:  CLR.B   15F2
.................... 				action = 5; 
0904A:  MOV.B   #5,W0L
0904C:  MOV.B   W0L,15F1
.................... 				return(1); 
0904E:  MOV.B   #1,W0L
09050:  MOV.B   W0L,0
09052:  BRA     9164
.................... 			} 
....................  
.................... 		break; 
09054:  GOTO    9164
....................  
.................... 		break; 
09058:  GOTO    9164
....................  
.................... 		case 5 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
0905C:  MOV.B   #C0,W0L
0905E:  MOV.B   W0L,1B36
09060:  CALL    146C
09064:  MOV.B   W0L,15F3
....................  
.................... 			if(etat_cremaillere==1) 
09066:  MOV.B   15F3,W0L
09068:  SE      W0,W0
0906A:  CP      W0,#1
0906C:  BRA     NZ,90AC
.................... 			{ 
.................... 				etat_pompes = read_driver_pompes(0xA0); 
0906E:  MOV.B   #A0,W0L
09070:  MOV.B   W0L,1B36
09072:  CALL    8E60
09076:  MOV.B   W0L,15F5
.................... 				if(etat_pompes==0b00011111 || i==1) 
09078:  MOV.B   15F5,W0L
0907A:  SE      W0,W0
0907C:  CP      W0,#1F
0907E:  BRA     Z,9088
09080:  MOV.B   15FA,W0L
09082:  SE      W0,W0
09084:  CP      W0,#1
09086:  BRA     NZ,9092
.................... 				{ 
.................... 					action = 6; 
09088:  MOV.B   #6,W0L
0908A:  MOV.B   W0L,15F1
.................... 					i = 0; 
0908C:  CLR.B   15FA
.................... 				} 
0908E:  GOTO    90AC
.................... 				else 
.................... 				{ 
.................... 					if(etat_pompes==0) 
09092:  MOV.B   15F5,W0L
09094:  SE      W0,W0
09096:  CP0     W0
09098:  BRA     NZ,90A6
.................... 					{ 
.................... 						action = 7; 
0909A:  MOV.B   #7,W0L
0909C:  MOV.B   W0L,15F1
.................... 						Obj_end=1; 
0909E:  MOV     #1,W4
090A0:  MOV     W4,14A4
.................... 					} 
090A2:  GOTO    90AC
.................... 					else 
.................... 					{ 
.................... 						action = 2; 
090A6:  MOV.B   #2,W0L
090A8:  MOV.B   W0L,15F1
.................... 						i++; 
090AA:  INC.B   15FA
.................... 					} 
.................... 				} 
.................... 			}	 
....................  
.................... 		break; 
090AC:  GOTO    9164
....................  
.................... 		case START : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
090B0:  MOV.B   #C0,W0L
090B2:  MOV.B   W0L,1B36
090B4:  CALL    146C
090B8:  MOV.B   W0L,15F3
....................  
.................... 			if(etat_cremaillere==1) 
090BA:  MOV.B   15F3,W0L
090BC:  SE      W0,W0
090BE:  CP      W0,#1
090C0:  BRA     NZ,90FC
.................... 			{ 
.................... 				if(Etat!=1)  
090C2:  MOV.B   15F2,W0L
090C4:  SE      W0,W0
090C6:  CP      W0,#1
090C8:  BRA     Z,90F0
.................... 				{				 
.................... 					Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,20000); 
090CA:  MOV.B   #C0,W0L
090CC:  MOV.B   W0L,1B3C
090CE:  CLR.B   1B3D
090D0:  MOV.B   #1,W0L
090D2:  MOV.B   W0L,1B3E
090D4:  MOV.B   #2,W0L
090D6:  MOV.B   W0L,1B3F
090D8:  MOV     #1388,W4
090DA:  MOV     W4,1B40
090DC:  MOV     #4E20,W4
090DE:  MOV     W4,1B42
090E0:  CLR     1B44
090E2:  CALL    114E
090E6:  MOV.B   W0L,15F2
.................... 					return(0);			 
090E8:  CLR.B   0
090EA:  BRA     9164
.................... 				} 
090EC:  GOTO    90FC
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
090F0:  CLR.B   15F2
.................... 					action = 6; 
090F2:  MOV.B   #6,W0L
090F4:  MOV.B   W0L,15F1
.................... 					return(1); 
090F6:  MOV.B   #1,W0L
090F8:  MOV.B   W0L,0
090FA:  BRA     9164
.................... 				} 
.................... 			} 
.................... 			 
.................... 		case 6 : 
....................  
.................... 				if(Etat!=1)  
090FC:  MOV.B   15F2,W0L
090FE:  SE      W0,W0
09100:  CP      W0,#1
09102:  BRA     Z,9134
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,-impulse_couronne); 
09104:  MOV     #0,W4
09106:  MOV     15F6,W3
09108:  SUB     W4,W3,W5
0910A:  MOV     #0,W4
0910C:  MOV     15F8,W3
0910E:  SUBB    W4,W3,W6
09110:  MOV.B   #C2,W0L
09112:  MOV.B   W0L,1B3C
09114:  CLR.B   1B3D
09116:  MOV.B   #1,W0L
09118:  MOV.B   W0L,1B3E
0911A:  MOV.B   #2,W0L
0911C:  MOV.B   W0L,1B3F
0911E:  MOV     #1388,W4
09120:  MOV     W4,1B40
09122:  MOV     W5,1B42
09124:  MOV     W6,1B44
09126:  CALL    114E
0912A:  MOV.B   W0L,15F2
.................... 					return(0); 
0912C:  CLR.B   0
0912E:  BRA     9164
.................... 				} 
09130:  GOTO    9140
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
09134:  CLR.B   15F2
.................... 					action = 7; 
09136:  MOV.B   #7,W0L
09138:  MOV.B   W0L,15F1
.................... 					return(1); 
0913A:  MOV.B   #1,W0L
0913C:  MOV.B   W0L,0
0913E:  BRA     9164
.................... 				}		 
....................  
.................... 		case 7 : 
....................  
.................... 			etat_couronne = __Check_action_end(0xC2); 
09140:  MOV.B   #C2,W0L
09142:  MOV.B   W0L,1B36
09144:  CALL    146C
09148:  MOV.B   W0L,15F4
....................  
.................... 			if(etat_couronne==1) 
0914A:  MOV.B   15F4,W0L
0914C:  SE      W0,W0
0914E:  CP      W0,#1
09150:  BRA     NZ,9160
.................... 			{ 
.................... 				Action_send = 1; 
09152:  BSET.B  85B.7
.................... 				action = 0; 
09154:  CLR.B   15F1
.................... 				Etat = 0; 
09156:  CLR.B   15F2
.................... 				etat_cremaillere = 0; 
09158:  CLR.B   15F3
.................... 				etat_pompes = 0; 
0915A:  CLR.B   15F5
.................... 				i = 0;	 
0915C:  CLR.B   15FA
.................... 				Check=1; 
0915E:  BSET.B  85B.4
.................... 			}		 
....................  
.................... 		break; 
09160:  GOTO    9164
....................  
.................... 	} 
09164:  MOV     [--W15],W6
09166:  MOV     [--W15],W5
09168:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour empiler la tour de 5 étages. La solution (sensé être transmis par le raspberry à la carte principale) 
.................... //	est enregistré dans une variable.La fonction permet de monter les tours pour les différentes solution et pour les 2 côtés. 
.................... //	Avant de poser les cubes, on vérifie grâce à une autre fonction si on a un cube. Le comptage des points est aussi intégré 
.................... //	pour toutes les possibilités. 
.................... //============================================================================================================================ 
....................  
.................... int1 Empilage(void) 
*
0926A:  MOV     W5,[W15++]
0926C:  MOV     #C,W5
0926E:  REPEAT  #3
09270:  MOV     [W5++],[W15++]
.................... { 
.................... 	static int8 action; 
.................... 	static int8 Etat; 
.................... 	static int8 etat_cremaillere; 
.................... 	static int8 etat_couronne; 
.................... 	static int8 etat_pompes; 
.................... 	static int1 etat_pompe_A; 
.................... 	static int1 etat_pompe_B; 
.................... 	static int1 etat_pompe_C; 
.................... 	static int1 etat_pompe_D; 
.................... 	static int1 etat_pompe_E; 
.................... 	//int8 solution = 0; 
....................  
.................... 	static int1 combinaison; 
.................... 	static int8 etage;	 
.................... 	static int8 i;	 
.................... 	//static int8 points;// Surement à mettre en global 
.................... 	 
.................... 	//solution = 1;//(PORTA&0b11110000)/16; 
....................  
.................... 	if(Team==1) 
09272:  BTSS.B  85B.3
09274:  BRA     9A8A
.................... 	{ 
.................... 		switch(solution) 
09276:  MOV.B   87A,W0L
09278:  CLR.B   1
0927A:  XOR     #1,W0
0927C:  BRA     Z,9280
0927E:  BRA     9A8A
.................... 		{ 
.................... 			case 0b0001 : 
.................... 	 
.................... 				switch(action) 
09280:  MOV.B   15FB,W0L
09282:  SE      W0,W0
09284:  XOR     #0,W0
09286:  BRA     Z,92DA
09288:  XOR     #1E,W0
0928A:  BRA     Z,93E8
0928C:  XOR     #1F,W0
0928E:  BRA     Z,942E
09290:  XOR     #3,W0
09292:  BRA     Z,94CA
09294:  XOR     #1,W0
09296:  BRA     Z,94E0
09298:  XOR     #7,W0
0929A:  BRA     Z,9520
0929C:  XOR     #1,W0
0929E:  BRA     Z,95DA
092A0:  XOR     #3,W0
092A2:  BRA     Z,966C
092A4:  XOR     #1,W0
092A6:  BRA     Z,9682
092A8:  XOR     #F,W0
092AA:  BRA     Z,96C2
092AC:  XOR     #1,W0
092AE:  BRA     Z,9714
092B0:  XOR     #3,W0
092B2:  BRA     Z,97B2
092B4:  XOR     #1,W0
092B6:  BRA     Z,97C8
092B8:  XOR     #7,W0
092BA:  BRA     Z,9808
092BC:  XOR     #1,W0
092BE:  BRA     Z,985A
092C0:  XOR     #3,W0
092C2:  BRA     Z,9904
092C4:  XOR     #1,W0
092C6:  BRA     Z,991A
092C8:  XOR     #1F,W0
092CA:  BRA     Z,995A
092CC:  XOR     #1,W0
092CE:  BRA     Z,99AC
092D0:  XOR     #3,W0
092D2:  BRA     Z,9A48
092D4:  XOR     #1,W0
092D6:  BRA     Z,9A5E
092D8:  BRA     9A86
.................... 				{ 
.................... 					case 0 : 
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
092DA:  MOV.B   #A0,W0L
092DC:  MOV.B   W0L,1B36
092DE:  CALL    8E60
092E2:  MOV.B   W0L,15FF
.................... 						etat_pompe_A = (etat_pompes&0b00010000)/16; 
092E4:  MOV.B   15FF,W0L
092E6:  SE      W0,W0
092E8:  AND     W0,#10,W5
092EA:  MOV     W5,W4
092EC:  MOV     #10,W3
092EE:  REPEAT  #11
092F0:  DIV.S   W4,W3
092F2:  BCLR.B  14B1.7
092F4:  BTSC.B  0.0
092F6:  BSET.B  14B1.7
.................... 						etat_pompe_B = (etat_pompes&0b00001000)/8; 
092F8:  MOV.B   15FF,W0L
092FA:  SE      W0,W0
092FC:  AND     W0,#8,W5
092FE:  MOV     W5,W4
09300:  MOV     #8,W3
09302:  REPEAT  #11
09304:  DIV.S   W4,W3
09306:  BCLR.B  1600.0
09308:  BTSC.B  0.0
0930A:  BSET.B  1600.0
.................... 						etat_pompe_C = (etat_pompes&0b00000100)/4; 
0930C:  MOV.B   15FF,W0L
0930E:  SE      W0,W0
09310:  AND     W0,#4,W5
09312:  MOV     W5,W4
09314:  MOV     #4,W3
09316:  REPEAT  #11
09318:  DIV.S   W4,W3
0931A:  BCLR.B  1600.1
0931C:  BTSC.B  0.0
0931E:  BSET.B  1600.1
.................... 						etat_pompe_D = (etat_pompes&0b00000010)/2; 
09320:  MOV.B   15FF,W0L
09322:  SE      W0,W0
09324:  AND     W0,#2,W5
09326:  MOV     W5,W4
09328:  MOV     #2,W3
0932A:  REPEAT  #11
0932C:  DIV.S   W4,W3
0932E:  BCLR.B  1600.2
09330:  BTSC.B  0.0
09332:  BSET.B  1600.2
.................... 						etat_pompe_E = (etat_pompes&0b00000001); 
09334:  MOV.B   15FF,W0L
09336:  SE      W0,W0
09338:  AND     W0,#1,W0
0933A:  BCLR.B  1600.3
0933C:  BTSC.B  0.0
0933E:  BSET.B  1600.3
.................... 	 
.................... 	 
.................... 						fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",vitesse_roboteq,vitesse_roboteq); 
09340:  MOV     #0,W1
09342:  MOV     W1,W0
09344:  CLR.B   1
09346:  CALL    3C4
0934A:  INC     W1,W1
0934C:  BTSC.B  219.1
0934E:  BRA     934C
09350:  MOV     W0,21A
09352:  MOV     #4,W0
09354:  CPSGT   W1,W0
09356:  BRA     9342
09358:  MOV     #12C,W0
0935A:  MOV     #8007,W4
0935C:  CALL    916A
09360:  MOV     #9,W1
09362:  MOV     W1,W0
09364:  CLR.B   1
09366:  CALL    3C4
0936A:  INC     W1,W1
0936C:  BTSC.B  219.1
0936E:  BRA     936C
09370:  MOV     W0,21A
09372:  MOV     #E,W0
09374:  CPSGT   W1,W0
09376:  BRA     9362
09378:  MOV     #12C,W0
0937A:  MOV     #8007,W4
0937C:  CALL    916A
09380:  BTSC.B  219.1
09382:  BRA     9380
09384:  MOV     #20,W4
09386:  MOV     W4,21A
09388:  BTSC.B  219.1
0938A:  BRA     9388
0938C:  MOV     #D,W4
0938E:  MOV     W4,21A
.................... 						fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",impulse,impulse); 
09390:  MOV     #0,W1
09392:  MOV     W1,W0
09394:  CLR.B   1
09396:  CALL    1B6
0939A:  INC     W1,W1
0939C:  BTSC.B  219.1
0939E:  BRA     939C
093A0:  MOV     W0,21A
093A2:  MOV     #5,W0
093A4:  CPSGT   W1,W0
093A6:  BRA     9392
093A8:  MOV     #D650,W0
093AA:  MOV     #8007,W4
093AC:  CALL    916A
093B0:  MOV     #A,W1
093B2:  MOV     W1,W0
093B4:  CLR.B   1
093B6:  CALL    1B6
093BA:  INC     W1,W1
093BC:  BTSC.B  219.1
093BE:  BRA     93BC
093C0:  MOV     W0,21A
093C2:  MOV     #10,W0
093C4:  CPSGT   W1,W0
093C6:  BRA     93B2
093C8:  MOV     #D650,W0
093CA:  MOV     #8007,W4
093CC:  CALL    916A
093D0:  BTSC.B  219.1
093D2:  BRA     93D0
093D4:  MOV     #20,W4
093D6:  MOV     W4,21A
093D8:  BTSC.B  219.1
093DA:  BRA     93D8
093DC:  MOV     #D,W4
093DE:  MOV     W4,21A
.................... 	 
.................... 						action = START; 
093E0:  MOV.B   #1E,W0L
093E2:  MOV.B   W0L,15FB
.................... 	 
.................... 					break; 
093E4:  GOTO    9A86
.................... 	 
.................... 					case START : 
.................... 	 
.................... 						delay_ms(1000); 
093E8:  MOV     #3E8,W0
093EA:  CALL    F0E
.................... 						//__Check_commande_atteint(); 
.................... 	                  	if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
.................... 	                  	{   
.................... 							if(Etat!=1)  
093EE:  MOV.B   15FC,W0L
093F0:  SE      W0,W0
093F2:  CP      W0,#1
093F4:  BRA     Z,941E
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,-20000); 
093F6:  MOV.B   #C0,W0L
093F8:  MOV.B   W0L,1B3C
093FA:  MOV.B   #1,W0L
093FC:  MOV.B   W0L,1B3D
093FE:  MOV.B   #1,W0L
09400:  MOV.B   W0L,1B3E
09402:  MOV.B   #2,W0L
09404:  MOV.B   W0L,1B3F
09406:  MOV     #C8,W4
09408:  MOV     W4,1B40
0940A:  MOV     #B1E0,W4
0940C:  MOV     W4,1B42
0940E:  SETM    1B44
09410:  CALL    114E
09414:  MOV.B   W0L,15FC
.................... 								return(0); 
09416:  CLR.B   0
09418:  BRA     9A8A
.................... 							} 
0941A:  GOTO    942A
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
0941E:  CLR.B   15FC
.................... 								action = 1; 
09420:  MOV.B   #1,W0L
09422:  MOV.B   W0L,15FB
.................... 								return(1); 
09424:  MOV.B   #1,W0L
09426:  MOV.B   W0L,0
09428:  BRA     9A8A
.................... 							} 
.................... 	                  	}    
.................... 	 
.................... 					break; 
0942A:  GOTO    9A86
.................... 	 
.................... 					case 1 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
0942E:  MOV.B   #C0,W0L
09430:  MOV.B   W0L,1B36
09432:  CALL    146C
09436:  MOV.B   W0L,15FD
.................... 	 
.................... 						if(etat_cremaillere==1) 
09438:  MOV.B   15FD,W0L
0943A:  SE      W0,W0
0943C:  CP      W0,#1
0943E:  BRA     NZ,94C6
.................... 						{   
.................... 	                  		if(bit_test(etat_pompes, 2) == 1) 
09440:  BTSS.B  15FF.2
09442:  BRA     94C2
.................... 	                  		{  
.................... 								if(Etat!=1)  
09444:  MOV.B   15FC,W0L
09446:  SE      W0,W0
09448:  CP      W0,#1
0944A:  BRA     Z,94AA
.................... 								{	 
.................... 									etat_pompe_C = 0;			 
0944C:  BCLR.B  1600.1
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
0944E:  CLR     W0
09450:  BTSC.B  14B1.7
09452:  INC     W0,W0
09454:  MOV.B   W0L,W5L
09456:  CLR     W0
09458:  BTSC.B  1600.0
0945A:  INC     W0,W0
0945C:  MOV.B   W0L,W6L
0945E:  CLR     W0
09460:  BTSC.B  1600.1
09462:  INC     W0,W0
09464:  MOV.B   W0L,W7L
09466:  CLR     W0
09468:  BTSC.B  1600.2
0946A:  INC     W0,W0
0946C:  MOV.B   W0L,W8L
0946E:  CLR     W0
09470:  BTSC.B  1600.3
09472:  INC     W0,W0
09474:  MOV.B   W0L,W9L
09476:  MOV     W0,[W15++]
09478:  MOV.B   #A0,W0L
0947A:  MOV.B   W0L,1B3E
0947C:  MOV     [--W15],W0
0947E:  PUSH    1B3E
09480:  MOV.B   W5L,[W15-#1]
09482:  POP     1B3E
09484:  PUSH    1B40
09486:  MOV.B   W6L,[W15-#2]
09488:  POP     1B40
0948A:  PUSH    1B40
0948C:  MOV.B   W7L,[W15-#1]
0948E:  POP     1B40
09490:  PUSH    1B42
09492:  MOV.B   W8L,[W15-#2]
09494:  POP     1B42
09496:  PUSH    1B42
09498:  MOV.B   W9L,[W15-#1]
0949A:  POP     1B42
0949C:  CALL    10CC
094A0:  MOV.B   W0L,15FC
.................... 									return(0);			 
094A2:  CLR.B   0
094A4:  BRA     9A8A
.................... 								} 
094A6:  GOTO    94BE
.................... 								else  
.................... 								{	 
.................... 									etage++; 
094AA:  INC.B   1601
.................... 									points = points + etage; 
094AC:  MOV.B   875,W0L
094AE:  ADD.B   1601,W0L
094B0:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
094B2:  CLR.B   15FC
.................... 									action = 3; 
094B4:  MOV.B   #3,W0L
094B6:  MOV.B   W0L,15FB
.................... 									return(1); 
094B8:  MOV.B   #1,W0L
094BA:  MOV.B   W0L,0
094BC:  BRA     9A8A
.................... 								} 
.................... 							} 
094BE:  GOTO    94C6
.................... 							else 
.................... 							{ 
.................... 								action = 4; 
094C2:  MOV.B   #4,W0L
094C4:  MOV.B   W0L,15FB
.................... 							} 
.................... 	                  	}    
.................... 	 
.................... 					break; 
094C6:  GOTO    9A86
.................... 	 
.................... 					case 2 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
094CA:  MOV.B   #A0,W0L
094CC:  MOV.B   W0L,1B36
094CE:  CALL    8E60
094D2:  MOV.B   W0L,15FF
.................... 						if(bit_test(etat_pompes, 2) == 0) 
094D4:  BTSC.B  15FF.2
094D6:  BRA     94DC
.................... 						{ 
.................... 							action = 3; 
094D8:  MOV.B   #3,W0L
094DA:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
094DC:  GOTO    9A86
.................... 	 
.................... 					case 3 : 
.................... 	   
.................... 						if(Etat!=1)  
094E0:  MOV.B   15FC,W0L
094E2:  SE      W0,W0
094E4:  CP      W0,#1
094E6:  BRA     Z,9510
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,(distance)); 
094E8:  MOV.B   #C0,W0L
094EA:  MOV.B   W0L,1B3C
094EC:  MOV.B   #1,W0L
094EE:  MOV.B   W0L,1B3D
094F0:  MOV.B   #1,W0L
094F2:  MOV.B   W0L,1B3E
094F4:  MOV.B   #2,W0L
094F6:  MOV.B   W0L,1B3F
094F8:  MOV     #C8,W4
094FA:  MOV     W4,1B40
094FC:  MOV     #CB20,W4
094FE:  MOV     W4,1B42
09500:  CLR     1B44
09502:  CALL    114E
09506:  MOV.B   W0L,15FC
.................... 							return(0); 
09508:  CLR.B   0
0950A:  BRA     9A8A
.................... 						} 
0950C:  GOTO    951C
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
09510:  CLR.B   15FC
.................... 							action = 4; 
09512:  MOV.B   #4,W0L
09514:  MOV.B   W0L,15FB
.................... 							return(1); 
09516:  MOV.B   #1,W0L
09518:  MOV.B   W0L,0
0951A:  BRA     9A8A
.................... 						}	 
.................... 	 
.................... 					break; 
0951C:  GOTO    9A86
.................... 	 
.................... 					case 4 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09520:  MOV.B   #C0,W0L
09522:  MOV.B   W0L,1B36
09524:  CALL    146C
09528:  MOV.B   W0L,15FD
.................... 	 
.................... 						if(etat_cremaillere==1) 
0952A:  MOV.B   15FD,W0L
0952C:  SE      W0,W0
0952E:  CP      W0,#1
09530:  BRA     NZ,95D6
.................... 						{ 
.................... 							fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",vitesse_roboteq,vitesse_roboteq); 
09532:  MOV     #0,W1
09534:  MOV     W1,W0
09536:  CLR.B   1
09538:  CALL    3C4
0953C:  INC     W1,W1
0953E:  BTSC.B  219.1
09540:  BRA     953E
09542:  MOV     W0,21A
09544:  MOV     #4,W0
09546:  CPSGT   W1,W0
09548:  BRA     9534
0954A:  MOV     #12C,W0
0954C:  MOV     #8007,W4
0954E:  CALL    916A
09552:  MOV     #9,W1
09554:  MOV     W1,W0
09556:  CLR.B   1
09558:  CALL    3C4
0955C:  INC     W1,W1
0955E:  BTSC.B  219.1
09560:  BRA     955E
09562:  MOV     W0,21A
09564:  MOV     #E,W0
09566:  CPSGT   W1,W0
09568:  BRA     9554
0956A:  MOV     #12C,W0
0956C:  MOV     #8007,W4
0956E:  CALL    916A
09572:  BTSC.B  219.1
09574:  BRA     9572
09576:  MOV     #20,W4
09578:  MOV     W4,21A
0957A:  BTSC.B  219.1
0957C:  BRA     957A
0957E:  MOV     #D,W4
09580:  MOV     W4,21A
.................... 							fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-impulse,-impulse); 
09582:  MOV     #0,W1
09584:  MOV     W1,W0
09586:  CLR.B   1
09588:  CALL    1B6
0958C:  INC     W1,W1
0958E:  BTSC.B  219.1
09590:  BRA     958E
09592:  MOV     W0,21A
09594:  MOV     #5,W0
09596:  CPSGT   W1,W0
09598:  BRA     9584
0959A:  MOV     #29B0,W0
0959C:  MOV     #8007,W4
0959E:  CALL    916A
095A2:  MOV     #A,W1
095A4:  MOV     W1,W0
095A6:  CLR.B   1
095A8:  CALL    1B6
095AC:  INC     W1,W1
095AE:  BTSC.B  219.1
095B0:  BRA     95AE
095B2:  MOV     W0,21A
095B4:  MOV     #10,W0
095B6:  CPSGT   W1,W0
095B8:  BRA     95A4
095BA:  MOV     #29B0,W0
095BC:  MOV     #8007,W4
095BE:  CALL    916A
095C2:  BTSC.B  219.1
095C4:  BRA     95C2
095C6:  MOV     #20,W4
095C8:  MOV     W4,21A
095CA:  BTSC.B  219.1
095CC:  BRA     95CA
095CE:  MOV     #D,W4
095D0:  MOV     W4,21A
.................... 	 
.................... 							action = 5;	 
095D2:  MOV.B   #5,W0L
095D4:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
095D6:  GOTO    9A86
.................... 	 
.................... 					case 5 : 
.................... 	 
.................... 						delay_ms(1000); 
095DA:  MOV     #3E8,W0
095DC:  CALL    F0E
.................... 						//__Check_commande_atteint(); 
.................... 	                  	if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
.................... 	                  	{    
.................... 	                  		if(bit_test(etat_pompes, 4) == 1) 
095E0:  BTSS.B  15FF.4
095E2:  BRA     9662
.................... 	                  		{  
.................... 								if(Etat!=1)  
095E4:  MOV.B   15FC,W0L
095E6:  SE      W0,W0
095E8:  CP      W0,#1
095EA:  BRA     Z,964A
.................... 								{	 
.................... 									etat_pompe_A = 0;			 
095EC:  BCLR.B  14B1.7
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
095EE:  CLR     W0
095F0:  BTSC.B  14B1.7
095F2:  INC     W0,W0
095F4:  MOV.B   W0L,W5L
095F6:  CLR     W0
095F8:  BTSC.B  1600.0
095FA:  INC     W0,W0
095FC:  MOV.B   W0L,W6L
095FE:  CLR     W0
09600:  BTSC.B  1600.1
09602:  INC     W0,W0
09604:  MOV.B   W0L,W7L
09606:  CLR     W0
09608:  BTSC.B  1600.2
0960A:  INC     W0,W0
0960C:  MOV.B   W0L,W8L
0960E:  CLR     W0
09610:  BTSC.B  1600.3
09612:  INC     W0,W0
09614:  MOV.B   W0L,W9L
09616:  MOV     W0,[W15++]
09618:  MOV.B   #A0,W0L
0961A:  MOV.B   W0L,1B3E
0961C:  MOV     [--W15],W0
0961E:  PUSH    1B3E
09620:  MOV.B   W5L,[W15-#1]
09622:  POP     1B3E
09624:  PUSH    1B40
09626:  MOV.B   W6L,[W15-#2]
09628:  POP     1B40
0962A:  PUSH    1B40
0962C:  MOV.B   W7L,[W15-#1]
0962E:  POP     1B40
09630:  PUSH    1B42
09632:  MOV.B   W8L,[W15-#2]
09634:  POP     1B42
09636:  PUSH    1B42
09638:  MOV.B   W9L,[W15-#1]
0963A:  POP     1B42
0963C:  CALL    10CC
09640:  MOV.B   W0L,15FC
.................... 									return(0);			 
09642:  CLR.B   0
09644:  BRA     9A8A
.................... 								} 
09646:  GOTO    965E
.................... 								else  
.................... 								{ 
.................... 									etage++; 
0964A:  INC.B   1601
.................... 									points = points + etage;	 
0964C:  MOV.B   875,W0L
0964E:  ADD.B   1601,W0L
09650:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09652:  CLR.B   15FC
.................... 									action = 7; 
09654:  MOV.B   #7,W0L
09656:  MOV.B   W0L,15FB
.................... 									return(1); 
09658:  MOV.B   #1,W0L
0965A:  MOV.B   W0L,0
0965C:  BRA     9A8A
.................... 								} 
.................... 							} 
0965E:  GOTO    9668
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
09662:  BSET.B  1600.4
.................... 								action = 8; 
09664:  MOV.B   #8,W0L
09666:  MOV.B   W0L,15FB
.................... 							} 
.................... 	                  	} 
.................... 	 
.................... 					break; 
09668:  GOTO    9A86
.................... 	 
.................... 					case 6 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
0966C:  MOV.B   #A0,W0L
0966E:  MOV.B   W0L,1B36
09670:  CALL    8E60
09674:  MOV.B   W0L,15FF
.................... 						if(bit_test(etat_pompes,4) == 0) 
09676:  BTSC.B  15FF.4
09678:  BRA     967E
.................... 						{ 
.................... 							action = 7; 
0967A:  MOV.B   #7,W0L
0967C:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
0967E:  GOTO    9A86
.................... 	 
.................... 					case 7 : 
.................... 	 
.................... 						if(Etat!=1)  
09682:  MOV.B   15FC,W0L
09684:  SE      W0,W0
09686:  CP      W0,#1
09688:  BRA     Z,96B2
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
0968A:  MOV.B   #C0,W0L
0968C:  MOV.B   W0L,1B3C
0968E:  MOV.B   #1,W0L
09690:  MOV.B   W0L,1B3D
09692:  MOV.B   #1,W0L
09694:  MOV.B   W0L,1B3E
09696:  MOV.B   #2,W0L
09698:  MOV.B   W0L,1B3F
0969A:  MOV     #C8,W4
0969C:  MOV     W4,1B40
0969E:  MOV     #CB20,W4
096A0:  MOV     W4,1B42
096A2:  CLR     1B44
096A4:  CALL    114E
096A8:  MOV.B   W0L,15FC
.................... 							return(0); 
096AA:  CLR.B   0
096AC:  BRA     9A8A
.................... 						} 
096AE:  GOTO    96BE
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
096B2:  CLR.B   15FC
.................... 							action = 8; 
096B4:  MOV.B   #8,W0L
096B6:  MOV.B   W0L,15FB
.................... 							return(1); 
096B8:  MOV.B   #1,W0L
096BA:  MOV.B   W0L,0
096BC:  BRA     9A8A
.................... 						} 
.................... 	 
.................... 					break; 
096BE:  GOTO    9A86
.................... 	 
.................... 					case 8 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
096C2:  MOV.B   #C0,W0L
096C4:  MOV.B   W0L,1B36
096C6:  CALL    146C
096CA:  MOV.B   W0L,15FD
.................... 	 
.................... 						if(etat_cremaillere==1) 
096CC:  MOV.B   15FD,W0L
096CE:  SE      W0,W0
096D0:  CP      W0,#1
096D2:  BRA     NZ,9710
.................... 						{ 
.................... 							if(Etat!=1)  
096D4:  MOV.B   15FC,W0L
096D6:  SE      W0,W0
096D8:  CP      W0,#1
096DA:  BRA     Z,9704
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,16192); 
096DC:  MOV.B   #C2,W0L
096DE:  MOV.B   W0L,1B3C
096E0:  MOV.B   #1,W0L
096E2:  MOV.B   W0L,1B3D
096E4:  MOV.B   #1,W0L
096E6:  MOV.B   W0L,1B3E
096E8:  MOV.B   #2,W0L
096EA:  MOV.B   W0L,1B3F
096EC:  MOV     #C8,W4
096EE:  MOV     W4,1B40
096F0:  MOV     #3F40,W4
096F2:  MOV     W4,1B42
096F4:  CLR     1B44
096F6:  CALL    114E
096FA:  MOV.B   W0L,15FC
.................... 								return(0); 
096FC:  CLR.B   0
096FE:  BRA     9A8A
.................... 							} 
09700:  GOTO    9710
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
09704:  CLR.B   15FC
.................... 								action = 9; 
09706:  MOV.B   #9,W0L
09708:  MOV.B   W0L,15FB
.................... 								return(1); 
0970A:  MOV.B   #1,W0L
0970C:  MOV.B   W0L,0
0970E:  BRA     9A8A
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09710:  GOTO    9A86
.................... 	 
.................... 					case 9 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
09714:  MOV.B   #C2,W0L
09716:  MOV.B   W0L,1B36
09718:  CALL    146C
0971C:  MOV.B   W0L,15FE
.................... 	 
.................... 						if(etat_couronne==1) 
0971E:  MOV.B   15FE,W0L
09720:  SE      W0,W0
09722:  CP      W0,#1
09724:  BRA     NZ,97AE
.................... 	                  	{    
.................... 	                  		if(bit_test(etat_pompes, 3) == 1) 
09726:  BTSS.B  15FF.3
09728:  BRA     97A8
.................... 	                  		{ 
.................... 								if(Etat!=1)  
0972A:  MOV.B   15FC,W0L
0972C:  SE      W0,W0
0972E:  CP      W0,#1
09730:  BRA     Z,9790
.................... 								{	 
.................... 									etat_pompe_B = 0;			 
09732:  BCLR.B  1600.0
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
09734:  CLR     W0
09736:  BTSC.B  14B1.7
09738:  INC     W0,W0
0973A:  MOV.B   W0L,W5L
0973C:  CLR     W0
0973E:  BTSC.B  1600.0
09740:  INC     W0,W0
09742:  MOV.B   W0L,W6L
09744:  CLR     W0
09746:  BTSC.B  1600.1
09748:  INC     W0,W0
0974A:  MOV.B   W0L,W7L
0974C:  CLR     W0
0974E:  BTSC.B  1600.2
09750:  INC     W0,W0
09752:  MOV.B   W0L,W8L
09754:  CLR     W0
09756:  BTSC.B  1600.3
09758:  INC     W0,W0
0975A:  MOV.B   W0L,W9L
0975C:  MOV     W0,[W15++]
0975E:  MOV.B   #A0,W0L
09760:  MOV.B   W0L,1B3E
09762:  MOV     [--W15],W0
09764:  PUSH    1B3E
09766:  MOV.B   W5L,[W15-#1]
09768:  POP     1B3E
0976A:  PUSH    1B40
0976C:  MOV.B   W6L,[W15-#2]
0976E:  POP     1B40
09770:  PUSH    1B40
09772:  MOV.B   W7L,[W15-#1]
09774:  POP     1B40
09776:  PUSH    1B42
09778:  MOV.B   W8L,[W15-#2]
0977A:  POP     1B42
0977C:  PUSH    1B42
0977E:  MOV.B   W9L,[W15-#1]
09780:  POP     1B42
09782:  CALL    10CC
09786:  MOV.B   W0L,15FC
.................... 									return(0);			 
09788:  CLR.B   0
0978A:  BRA     9A8A
.................... 								} 
0978C:  GOTO    97A4
.................... 								else  
.................... 								{	 
.................... 									etage++; 
09790:  INC.B   1601
.................... 									points = points + etage; 
09792:  MOV.B   875,W0L
09794:  ADD.B   1601,W0L
09796:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09798:  CLR.B   15FC
.................... 									action = 11; 
0979A:  MOV.B   #B,W0L
0979C:  MOV.B   W0L,15FB
.................... 									return(1); 
0979E:  MOV.B   #1,W0L
097A0:  MOV.B   W0L,0
097A2:  BRA     9A8A
.................... 								} 
.................... 							} 
097A4:  GOTO    97AE
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
097A8:  BSET.B  1600.4
.................... 								action = 12; 
097AA:  MOV.B   #C,W0L
097AC:  MOV.B   W0L,15FB
.................... 							} 
.................... 	                  	} 
.................... 	 
.................... 					break; 
097AE:  GOTO    9A86
.................... 	 
.................... 					case 10 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
097B2:  MOV.B   #A0,W0L
097B4:  MOV.B   W0L,1B36
097B6:  CALL    8E60
097BA:  MOV.B   W0L,15FF
.................... 						if(bit_test(etat_pompes,3) == 0) 
097BC:  BTSC.B  15FF.3
097BE:  BRA     97C4
.................... 						{ 
.................... 							action = 11; 
097C0:  MOV.B   #B,W0L
097C2:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
097C4:  GOTO    9A86
.................... 	 
.................... 					case 11 : 
.................... 	 
.................... 						if(Etat!=1)  
097C8:  MOV.B   15FC,W0L
097CA:  SE      W0,W0
097CC:  CP      W0,#1
097CE:  BRA     Z,97F8
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
097D0:  MOV.B   #C0,W0L
097D2:  MOV.B   W0L,1B3C
097D4:  MOV.B   #1,W0L
097D6:  MOV.B   W0L,1B3D
097D8:  MOV.B   #1,W0L
097DA:  MOV.B   W0L,1B3E
097DC:  MOV.B   #2,W0L
097DE:  MOV.B   W0L,1B3F
097E0:  MOV     #C8,W4
097E2:  MOV     W4,1B40
097E4:  MOV     #CB20,W4
097E6:  MOV     W4,1B42
097E8:  CLR     1B44
097EA:  CALL    114E
097EE:  MOV.B   W0L,15FC
.................... 							return(0); 
097F0:  CLR.B   0
097F2:  BRA     9A8A
.................... 						} 
097F4:  GOTO    9804
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
097F8:  CLR.B   15FC
.................... 							action = 12; 
097FA:  MOV.B   #C,W0L
097FC:  MOV.B   W0L,15FB
.................... 							return(1); 
097FE:  MOV.B   #1,W0L
09800:  MOV.B   W0L,0
09802:  BRA     9A8A
.................... 						} 
.................... 	 
.................... 					break; 
09804:  GOTO    9A86
.................... 	 
.................... 					case 12 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09808:  MOV.B   #C0,W0L
0980A:  MOV.B   W0L,1B36
0980C:  CALL    146C
09810:  MOV.B   W0L,15FD
.................... 	 
.................... 						if(etat_cremaillere==1) 
09812:  MOV.B   15FD,W0L
09814:  SE      W0,W0
09816:  CP      W0,#1
09818:  BRA     NZ,9856
.................... 	                  	{  
.................... 							if(Etat!=1)  
0981A:  MOV.B   15FC,W0L
0981C:  SE      W0,W0
0981E:  CP      W0,#1
09820:  BRA     Z,984A
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,16192); 
09822:  MOV.B   #C2,W0L
09824:  MOV.B   W0L,1B3C
09826:  MOV.B   #1,W0L
09828:  MOV.B   W0L,1B3D
0982A:  MOV.B   #1,W0L
0982C:  MOV.B   W0L,1B3E
0982E:  MOV.B   #2,W0L
09830:  MOV.B   W0L,1B3F
09832:  MOV     #C8,W4
09834:  MOV     W4,1B40
09836:  MOV     #3F40,W4
09838:  MOV     W4,1B42
0983A:  CLR     1B44
0983C:  CALL    114E
09840:  MOV.B   W0L,15FC
.................... 								return(0); 
09842:  CLR.B   0
09844:  BRA     9A8A
.................... 							} 
09846:  GOTO    9856
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
0984A:  CLR.B   15FC
.................... 								action = 13; 
0984C:  MOV.B   #D,W0L
0984E:  MOV.B   W0L,15FB
.................... 								return(1); 
09850:  MOV.B   #1,W0L
09852:  MOV.B   W0L,0
09854:  BRA     9A8A
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09856:  GOTO    9A86
.................... 	 
.................... 					case 13 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
0985A:  MOV.B   #C2,W0L
0985C:  MOV.B   W0L,1B36
0985E:  CALL    146C
09862:  MOV.B   W0L,15FE
.................... 	 
.................... 						if(etat_couronne==1) 
09864:  MOV.B   15FE,W0L
09866:  SE      W0,W0
09868:  CP      W0,#1
0986A:  BRA     NZ,9900
.................... 	                  	{  
.................... 	                  		if(bit_test(etat_pompes, 0) == 1) 
0986C:  BTSS.B  15FF.0
0986E:  BRA     98FA
.................... 	                  		{ 
.................... 								if(Etat!=1)  
09870:  MOV.B   15FC,W0L
09872:  SE      W0,W0
09874:  CP      W0,#1
09876:  BRA     Z,98D6
.................... 								{	 
.................... 									etat_pompe_E = 0;			 
09878:  BCLR.B  1600.3
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
0987A:  CLR     W0
0987C:  BTSC.B  14B1.7
0987E:  INC     W0,W0
09880:  MOV.B   W0L,W5L
09882:  CLR     W0
09884:  BTSC.B  1600.0
09886:  INC     W0,W0
09888:  MOV.B   W0L,W6L
0988A:  CLR     W0
0988C:  BTSC.B  1600.1
0988E:  INC     W0,W0
09890:  MOV.B   W0L,W7L
09892:  CLR     W0
09894:  BTSC.B  1600.2
09896:  INC     W0,W0
09898:  MOV.B   W0L,W8L
0989A:  CLR     W0
0989C:  BTSC.B  1600.3
0989E:  INC     W0,W0
098A0:  MOV.B   W0L,W9L
098A2:  MOV     W0,[W15++]
098A4:  MOV.B   #A0,W0L
098A6:  MOV.B   W0L,1B3E
098A8:  MOV     [--W15],W0
098AA:  PUSH    1B3E
098AC:  MOV.B   W5L,[W15-#1]
098AE:  POP     1B3E
098B0:  PUSH    1B40
098B2:  MOV.B   W6L,[W15-#2]
098B4:  POP     1B40
098B6:  PUSH    1B40
098B8:  MOV.B   W7L,[W15-#1]
098BA:  POP     1B40
098BC:  PUSH    1B42
098BE:  MOV.B   W8L,[W15-#2]
098C0:  POP     1B42
098C2:  PUSH    1B42
098C4:  MOV.B   W9L,[W15-#1]
098C6:  POP     1B42
098C8:  CALL    10CC
098CC:  MOV.B   W0L,15FC
.................... 									return(0);			 
098CE:  CLR.B   0
098D0:  BRA     9A8A
.................... 								} 
098D2:  GOTO    98F6
.................... 								else  
.................... 								{ 
.................... 									etage++; 
098D6:  INC.B   1601
.................... 									points = points + etage;	 
098D8:  MOV.B   875,W0L
098DA:  ADD.B   1601,W0L
098DC:  MOV.B   W0L,875
.................... 									if(combinaison == 0) 
098DE:  BTSC.B  1600.4
098E0:  BRA     98EA
.................... 									{ 
.................... 										points = points + 30; 
098E2:  MOV     874,W4
098E4:  LSR     W4,#8,W4
098E6:  ADD.B   W4L,#1E,W0L
098E8:  MOV.B   W0L,875
.................... 									} 
.................... 									Etat = 0 ; 
098EA:  CLR.B   15FC
.................... 									action = 15; 
098EC:  MOV.B   #F,W0L
098EE:  MOV.B   W0L,15FB
.................... 									return(1); 
098F0:  MOV.B   #1,W0L
098F2:  MOV.B   W0L,0
098F4:  BRA     9A8A
.................... 								} 
.................... 							} 
098F6:  GOTO    9900
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
098FA:  BSET.B  1600.4
.................... 								action = 16; 
098FC:  MOV.B   #10,W0L
098FE:  MOV.B   W0L,15FB
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09900:  GOTO    9A86
.................... 	 
.................... 					case 14 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09904:  MOV.B   #A0,W0L
09906:  MOV.B   W0L,1B36
09908:  CALL    8E60
0990C:  MOV.B   W0L,15FF
.................... 						if(bit_test(etat_pompes,0) == 0) 
0990E:  BTSC.B  15FF.0
09910:  BRA     9916
.................... 						{ 
.................... 							action = 15; 
09912:  MOV.B   #F,W0L
09914:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
09916:  GOTO    9A86
.................... 	 
.................... 					case 15 : 
.................... 	 
.................... 						if(Etat!=1)  
0991A:  MOV.B   15FC,W0L
0991C:  SE      W0,W0
0991E:  CP      W0,#1
09920:  BRA     Z,994A
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
09922:  MOV.B   #C0,W0L
09924:  MOV.B   W0L,1B3C
09926:  MOV.B   #1,W0L
09928:  MOV.B   W0L,1B3D
0992A:  MOV.B   #1,W0L
0992C:  MOV.B   W0L,1B3E
0992E:  MOV.B   #2,W0L
09930:  MOV.B   W0L,1B3F
09932:  MOV     #C8,W4
09934:  MOV     W4,1B40
09936:  MOV     #CB20,W4
09938:  MOV     W4,1B42
0993A:  CLR     1B44
0993C:  CALL    114E
09940:  MOV.B   W0L,15FC
.................... 							return(0); 
09942:  CLR.B   0
09944:  BRA     9A8A
.................... 						} 
09946:  GOTO    9956
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
0994A:  CLR.B   15FC
.................... 							action = 16; 
0994C:  MOV.B   #10,W0L
0994E:  MOV.B   W0L,15FB
.................... 							return(1); 
09950:  MOV.B   #1,W0L
09952:  MOV.B   W0L,0
09954:  BRA     9A8A
.................... 						} 
.................... 	 
.................... 					break; 
09956:  GOTO    9A86
.................... 	 
.................... 					case 16 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
0995A:  MOV.B   #C0,W0L
0995C:  MOV.B   W0L,1B36
0995E:  CALL    146C
09962:  MOV.B   W0L,15FD
.................... 	 
.................... 						if(etat_cremaillere==1) 
09964:  MOV.B   15FD,W0L
09966:  SE      W0,W0
09968:  CP      W0,#1
0996A:  BRA     NZ,99A8
.................... 						{ 
.................... 							if(Etat!=1)  
0996C:  MOV.B   15FC,W0L
0996E:  SE      W0,W0
09970:  CP      W0,#1
09972:  BRA     Z,999C
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,-48576); 
09974:  MOV.B   #C2,W0L
09976:  MOV.B   W0L,1B3C
09978:  MOV.B   #1,W0L
0997A:  MOV.B   W0L,1B3D
0997C:  MOV.B   #1,W0L
0997E:  MOV.B   W0L,1B3E
09980:  MOV.B   #2,W0L
09982:  MOV.B   W0L,1B3F
09984:  MOV     #C8,W4
09986:  MOV     W4,1B40
09988:  MOV     #4240,W4
0998A:  MOV     W4,1B42
0998C:  SETM    1B44
0998E:  CALL    114E
09992:  MOV.B   W0L,15FC
.................... 								return(0); 
09994:  CLR.B   0
09996:  BRA     9A8A
.................... 							} 
09998:  GOTO    99A8
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
0999C:  CLR.B   15FC
.................... 								action = 17; 
0999E:  MOV.B   #11,W0L
099A0:  MOV.B   W0L,15FB
.................... 								return(1); 
099A2:  MOV.B   #1,W0L
099A4:  MOV.B   W0L,0
099A6:  BRA     9A8A
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
099A8:  GOTO    9A86
.................... 	 
.................... 					case 17 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
099AC:  MOV.B   #C2,W0L
099AE:  MOV.B   W0L,1B36
099B0:  CALL    146C
099B4:  MOV.B   W0L,15FE
.................... 	 
.................... 						if(etat_couronne==1) 
099B6:  MOV.B   15FE,W0L
099B8:  SE      W0,W0
099BA:  CP      W0,#1
099BC:  BRA     NZ,9A44
.................... 	                  	{ 
.................... 	                  		if(bit_test(etat_pompes, 1) == 1) 
099BE:  BTSS.B  15FF.1
099C0:  BRA     9A40
.................... 	                  		{ 
.................... 								if(Etat!=1)  
099C2:  MOV.B   15FC,W0L
099C4:  SE      W0,W0
099C6:  CP      W0,#1
099C8:  BRA     Z,9A28
.................... 								{	 
.................... 									etat_pompe_D = 0;			 
099CA:  BCLR.B  1600.2
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
099CC:  CLR     W0
099CE:  BTSC.B  14B1.7
099D0:  INC     W0,W0
099D2:  MOV.B   W0L,W5L
099D4:  CLR     W0
099D6:  BTSC.B  1600.0
099D8:  INC     W0,W0
099DA:  MOV.B   W0L,W6L
099DC:  CLR     W0
099DE:  BTSC.B  1600.1
099E0:  INC     W0,W0
099E2:  MOV.B   W0L,W7L
099E4:  CLR     W0
099E6:  BTSC.B  1600.2
099E8:  INC     W0,W0
099EA:  MOV.B   W0L,W8L
099EC:  CLR     W0
099EE:  BTSC.B  1600.3
099F0:  INC     W0,W0
099F2:  MOV.B   W0L,W9L
099F4:  MOV     W0,[W15++]
099F6:  MOV.B   #A0,W0L
099F8:  MOV.B   W0L,1B3E
099FA:  MOV     [--W15],W0
099FC:  PUSH    1B3E
099FE:  MOV.B   W5L,[W15-#1]
09A00:  POP     1B3E
09A02:  PUSH    1B40
09A04:  MOV.B   W6L,[W15-#2]
09A06:  POP     1B40
09A08:  PUSH    1B40
09A0A:  MOV.B   W7L,[W15-#1]
09A0C:  POP     1B40
09A0E:  PUSH    1B42
09A10:  MOV.B   W8L,[W15-#2]
09A12:  POP     1B42
09A14:  PUSH    1B42
09A16:  MOV.B   W9L,[W15-#1]
09A18:  POP     1B42
09A1A:  CALL    10CC
09A1E:  MOV.B   W0L,15FC
.................... 									return(0);			 
09A20:  CLR.B   0
09A22:  BRA     9A8A
.................... 								} 
09A24:  GOTO    9A3C
.................... 								else  
.................... 								{	 
.................... 									etage++; 
09A28:  INC.B   1601
.................... 									points = points + etage; 
09A2A:  MOV.B   875,W0L
09A2C:  ADD.B   1601,W0L
09A2E:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09A30:  CLR.B   15FC
.................... 									action = 19; 
09A32:  MOV.B   #13,W0L
09A34:  MOV.B   W0L,15FB
.................... 									return(1); 
09A36:  MOV.B   #1,W0L
09A38:  MOV.B   W0L,0
09A3A:  BRA     9A8A
.................... 								} 
.................... 							} 
09A3C:  GOTO    9A44
.................... 							else 
.................... 							{ 
.................... 								action = 19; 
09A40:  MOV.B   #13,W0L
09A42:  MOV.B   W0L,15FB
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09A44:  GOTO    9A86
.................... 	 
.................... 					case 18 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09A48:  MOV.B   #A0,W0L
09A4A:  MOV.B   W0L,1B36
09A4C:  CALL    8E60
09A50:  MOV.B   W0L,15FF
.................... 						if(bit_test(etat_pompes,1) == 0) 
09A52:  BTSC.B  15FF.1
09A54:  BRA     9A5A
.................... 						{ 
.................... 							action = 19; 
09A56:  MOV.B   #13,W0L
09A58:  MOV.B   W0L,15FB
.................... 						} 
.................... 	 
.................... 					break; 
09A5A:  GOTO    9A86
.................... 	 
.................... 					case 19 : 
.................... 	 
.................... 						Etat = driver_Pompes(0xA0,0,0,0,0,0); 
09A5E:  MOV.B   #A0,W0L
09A60:  MOV.B   W0L,1B3E
09A62:  CLR.B   1B3F
09A64:  CLR.B   1B40
09A66:  CLR.B   1B41
09A68:  CLR.B   1B42
09A6A:  CLR.B   1B43
09A6C:  CALL    10CC
09A70:  MOV.B   W0L,15FC
.................... 						Check=1; 
09A72:  BSET.B  85B.4
.................... 						Action_send = 1; 
09A74:  BSET.B  85B.7
.................... 						action = 0; 
09A76:  CLR.B   15FB
.................... 						etat = 0; 
09A78:  CLR.B   15FC
.................... 						Sens_rot_Couronne = 0; 
09A7A:  BCLR.B  14B1.4
.................... 						combinaison = 0; 
09A7C:  BCLR.B  1600.4
.................... 						etage = 0;	 
09A7E:  CLR.B   1601
.................... 						i = 0; 
09A80:  CLR.B   1602
.................... 	 
.................... 					break; 
09A82:  GOTO    9A86
.................... 	 
.................... 				} 
.................... 	 
.................... 			break; 
09A86:  GOTO    9A8A
.................... 	 
.................... 			 
.................... 	 
.................... 		}		 
.................... 	}	 
09A8A:  MOV     #12,W5
09A8C:  REPEAT  #3
09A8E:  MOV     [--W15],[W5--]
09A90:  MOV     [--W15],W5
09A92:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction qui va réinitialiser la crémaillère en position 0, puis la remonter à 30000 impulse 
.................... //============================================================================================================================ 
.................... 	 
.................... 	int1 GoToZero_Cremaillere(void) 
.................... 	{ 
.................... 		static int8 action; 
.................... 		static int8 Etat; 
.................... 		static int8 etat_cremaillere; 
.................... 	 
.................... 		switch(action) 
*
01858:  MOV.B   1603,W0L
0185A:  SE      W0,W0
0185C:  XOR     #0,W0
0185E:  BRA     Z,1866
01860:  XOR     #1,W0
01862:  BRA     Z,18A6
01864:  BRA     18F6
.................... 		{ 
.................... 			case 0 : 
.................... 	 
.................... 				if(Etat!=1)  
01866:  MOV.B   1604,W0L
01868:  SE      W0,W0
0186A:  CP      W0,#1
0186C:  BRA     Z,1892
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC0,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,750); 
0186E:  MOV.B   #C0,W0L
01870:  MOV.B   W0L,1B3C
01872:  CLR.B   1B3D
01874:  MOV.B   #2,W0L
01876:  MOV.B   W0L,1B3E
01878:  CLR.B   1B3F
0187A:  MOV     #64,W4
0187C:  MOV     W4,1B40
0187E:  MOV     #2EE,W4
01880:  MOV     W4,1B42
01882:  CLR     1B44
01884:  CALL    114E
01888:  MOV.B   W0L,1604
.................... 					return(0); 
0188A:  CLR.B   0
0188C:  BRA     18F6
.................... 				} 
0188E:  GOTO    18A2
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
01892:  CLR.B   1604
.................... 					action = 1; 
01894:  MOV.B   #1,W0L
01896:  MOV.B   W0L,1603
.................... 					delay_ms(100); 
01898:  MOV     #64,W0
0189A:  CALL    F0E
.................... 					return(0); 
0189E:  CLR.B   0
018A0:  BRA     18F6
.................... 				} 
.................... 	 
.................... 			break; 
018A2:  GOTO    18F6
.................... 	 
.................... 			case 1 : 
.................... 	 
.................... 				etat_cremaillere = __Check_action_end(0xC0); 
018A6:  MOV.B   #C0,W0L
018A8:  MOV.B   W0L,1B36
018AA:  CALL    146C
018AE:  MOV.B   W0L,1605
.................... 		 
.................... 				if(etat_cremaillere==1) 
018B0:  MOV.B   1605,W0L
018B2:  SE      W0,W0
018B4:  CP      W0,#1
018B6:  BRA     NZ,18F2
.................... 				{ 
.................... 					if(Etat!=1)  
018B8:  MOV.B   1604,W0L
018BA:  SE      W0,W0
018BC:  CP      W0,#1
018BE:  BRA     Z,18E8
.................... 					{				 
.................... 						Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,30000); 
018C0:  MOV.B   #C0,W0L
018C2:  MOV.B   W0L,1B3C
018C4:  MOV.B   #1,W0L
018C6:  MOV.B   W0L,1B3D
018C8:  MOV.B   #1,W0L
018CA:  MOV.B   W0L,1B3E
018CC:  MOV.B   #2,W0L
018CE:  MOV.B   W0L,1B3F
018D0:  MOV     #1388,W4
018D2:  MOV     W4,1B40
018D4:  MOV     #7530,W4
018D6:  MOV     W4,1B42
018D8:  CLR     1B44
018DA:  CALL    114E
018DE:  MOV.B   W0L,1604
.................... 						return(0);			 
018E0:  CLR.B   0
018E2:  BRA     18F6
.................... 					} 
018E4:  GOTO    18F2
.................... 					else  
.................... 					{	 
.................... 						Etat = 0 ; 
018E8:  CLR.B   1604
.................... 						action = 0; 
018EA:  CLR.B   1603
.................... 						return(1); 
018EC:  MOV.B   #1,W0L
018EE:  MOV.B   W0L,0
018F0:  BRA     18F6
.................... 					} 
.................... 				}	 
.................... 			break; 
018F2:  GOTO    18F6
.................... 		} 
018F6:  RETURN  
.................... 	}	 
.................... 	 
.................... //============================================================================================================================ 
.................... //	Fonction qui va réinitialiser la couronne et la crémaillère 
.................... //============================================================================================================================ 
....................  
.................... int1 reinitialisation(void) 
*
09C1E:  MOV     W5,[W15++]
09C20:  MOV     W6,[W15++]
.................... { 
.................... 	static int1 Zero_Couronne; 
.................... 	static int1 Zero_Cremaillere; 
....................  
.................... 	if(Zero_Cremaillere != 1) 
09C22:  BTSC.B  1600.6
09C24:  BRA     9C30
.................... 	{ 
.................... 		Zero_Cremaillere = GoToZero_Cremaillere(); 
09C26:  CALL    1858
09C2A:  BCLR.B  1600.6
09C2C:  BTSC.B  0.0
09C2E:  BSET.B  1600.6
.................... 	} 
.................... 	 
.................... 	//if(Zero_Couronne != 1)			// Ne fonctionner pas toujours (surement pas à cause du code) donc enlever 
.................... 	//{ 
.................... 	//	Zero_Couronne = __GoToZero();	 
.................... 	//} 
.................... 	Zero_Couronne = 1; 
09C30:  BSET.B  1600.5
.................... 	if(Zero_Cremaillere == 1 && Zero_Couronne == 1) 
09C32:  BTSS.B  1600.6
09C34:  BRA     9C42
09C36:  BTSS.B  1600.5
09C38:  BRA     9C42
.................... 	{ 
.................... 		Action_send = 1; 
09C3A:  BSET.B  85B.7
.................... 		Check=1; 
09C3C:  BSET.B  85B.4
.................... 		Zero_Couronne = 0; 
09C3E:  BCLR.B  1600.5
.................... 		Zero_Cremaillere = 0; 
09C40:  BCLR.B  1600.6
.................... 	} 
09C42:  MOV     [--W15],W6
09C44:  MOV     [--W15],W5
09C46:  RETURN  
.................... } 
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: GoToZero																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Rémy     												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 17.3.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui place le barillet à son point zéro 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne le status du driver											 
.................... //					0-> non utilisé																 
.................... //					1-> OK : ordre transmis et terminé													 
.................... //					2-> not ready  (le slave ne répond pas)															 
.................... //					3-> Le barillet n'a pas trouvé le point zéro															 
.................... //=================================================================================================================================================================================================== 
.................... int1 __GoToZero(void) 
*
01268:  MOV     W5,[W15++]
.................... { 
.................... 	static signed int32 ActualPosition = 0; 
.................... 	static signed int32 Position; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	 
.................... 	if(Sens_rot_Couronne==0) 
0126A:  BTSC.B  14B1.4
0126C:  BRA     1278
.................... 	{ 
.................... 		Position = 48576; 
0126E:  MOV     #BDC0,W4
01270:  MOV     W4,160A
01272:  CLR     160C
.................... 	} 
01274:  GOTO    127E
.................... 	else 
.................... 	{ 
.................... 		Position = -48576; 
01278:  MOV     #4240,W4
0127A:  MOV     W4,160A
0127C:  SETM    160C
.................... 	}		 
....................  
.................... 	if(_ZeroPoint == 0 && Etat == 0) return(1); 
0127E:  BTSC.B  2C2.7
01280:  BRA     1294
01282:  MOV.B   160E,W0L
01284:  SE      W0,W0
01286:  CP0     W0
01288:  BRA     NZ,1294
0128A:  MOV.B   #1,W0L
0128C:  MOV.B   W0L,0
0128E:  BRA     1304
01290:  GOTO    1304
.................... 	else 
.................... 	{	 
.................... 		if(Etat!=1) 
01294:  MOV.B   160E,W0L
01296:  SE      W0,W0
01298:  CP      W0,#1
0129A:  BRA     Z,12D6
.................... 		{ 
.................... 			if(!read) 
0129C:  BTSC.B  1600.7
0129E:  BRA     12A8
.................... 			{ 
.................... 				//ActualPosition = read_pos_moteur(0xC2); // on prend la pos du moteur 
.................... 				delay_ms(20); 
012A0:  MOV     #14,W0
012A2:  CALL    F0E
.................... 				read = 1; 
012A6:  BSET.B  1600.7
.................... 			}		 
.................... 			Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE,100,DRV_ARRET_POSITION_RELATIVE,Position);//ABSOLUE,(64768 + ActualPosition));	 
012A8:  MOV.B   #C2,W0L
012AA:  MOV.B   W0L,1B3C
012AC:  CLR.B   1B3D
012AE:  MOV.B   #1,W0L
012B0:  MOV.B   W0L,1B3E
012B2:  MOV.B   #2,W0L
012B4:  MOV.B   W0L,1B3F
012B6:  MOV     #64,W4
012B8:  MOV     W4,1B40
012BA:  PUSH    160A
012BC:  POP     1B42
012BE:  PUSH    160C
012C0:  POP     1B44
012C2:  CALL    114E
012C6:  MOV.B   W0L,160E
.................... 			delay_ms(20); 
012C8:  MOV     #14,W0
012CA:  CALL    F0E
.................... 			return(0); 
012CE:  CLR.B   0
012D0:  BRA     1304
.................... 		} 
012D2:  GOTO    1304
.................... 		else 
.................... 		{ 
.................... 			if(!_ZeroPoint) 
012D6:  BTSC.B  2C2.7
012D8:  BRA     1300
.................... 			{ 
.................... 				Etat = 0; 
012DA:  CLR.B   160E
.................... 				read = 0; 
012DC:  BCLR.B  1600.7
.................... 				driver_moteur(0xC2,0); //arrêt du driver 
012DE:  MOV.B   #C2,W0L
012E0:  MOV.B   W0L,1B3A
012E2:  CLR.B   1B3B
012E4:  CALL    120E
.................... 				if(obj_Action==8)Action_send = 0; 
012E8:  MOV     149E,W4
012EA:  CP      W4,#8
012EC:  BRA     NZ,12F4
012EE:  BCLR.B  85B.7
012F0:  GOTO    12F6
.................... 				else Action_send=1; 
012F4:  BSET.B  85B.7
.................... 				return(1); 
012F6:  MOV.B   #1,W0L
012F8:  MOV.B   W0L,0
012FA:  BRA     1304
.................... 			} 
012FC:  GOTO    1304
.................... 			else return(0); 
01300:  CLR.B   0
01302:  BRA     1304
.................... 		} 
.................... 	} 
01304:  MOV     [--W15],W5
01306:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: __Check_action_end																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Borgeat Remy   
.................... //						:   												 
.................... //  Date				: 28.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui check l'etat du driver moteur 
.................... // 				: 	En cas de surcharge ou driver pas connecte --> on affiche l'erreur 
.................... //				: 	En cas de surchauffe --> on attend 1s pour renvoyer l'ordre 
.................... // paramètres 	:	Addresse du driver 
.................... // retourne 	:	1 -> ordre fini, 0 -> ordre en cours ou erreur	 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Check_action_end(unsigned int8 driver_address) 
*
0146C:  MOV     W5,[W15++]
0146E:  MOV     W6,[W15++]
01470:  CLR     1B38
.................... { 
.................... 	static unsigned int32 Time_ms = 0; 
.................... 	static signed int16 impulses_toDo = 0; 
.................... 	signed int16 ActualPosition = 0; 
.................... 	static unsigned int8 passage_erreur = 0; 
.................... 	static unsigned int8 Etat_d = 1; 
.................... 	static unsigned int1 ok = 0; 
.................... 	static unsigned int8 Etat = 0; 
.................... 	static unsigned int1 read = 0; 
.................... 	static unsigned int8 Etat_driver = 0; 
.................... 	Etat_d = read_driver_moteur(driver_address); 
01472:  MOV.B   1B36,W0L
01474:  MOV.B   W0L,1B44
01476:  CALL    1332
0147A:  MOV.B   W0L,1616
.................... 	delay_ms(20); 
0147C:  MOV     #14,W0
0147E:  CALL    F0E
....................  
.................... 	switch(Etat_d) 
01482:  MOV.B   1616,W0L
01484:  CLR.B   1
01486:  XOR     #0,W0
01488:  BRA     Z,14A0
0148A:  XOR     #1,W0
0148C:  BRA     Z,14B0
0148E:  XOR     #3,W0
01490:  BRA     Z,14F0
01492:  XOR     #1,W0
01494:  BRA     Z,15FA
01496:  XOR     #7,W0
01498:  BRA     Z,17D4
0149A:  XOR     #1,W0
0149C:  BRA     Z,1814
0149E:  BRA     1852
.................... 	{ 
.................... 		case 0:  
.................... 			Erreur_max_surchauffe = 0; 
014A0:  CLR.B   881
.................... 			Time_ms = 0; 
014A2:  CLR     1610
014A4:  CLR     1612
.................... 			return(1); //driver arreter --> ordre fini  
014A6:  MOV.B   #1,W0L
014A8:  MOV.B   W0L,0
014AA:  BRA     1852
.................... 			break;	 
014AC:  GOTO    1852
.................... 			 
.................... 		case 1:	//en cours 
.................... 			 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(10); 
014B0:  MOV     1B36,W4
014B2:  XOR.B   #C0,W4L
014B4:  BRA     NZ,14C4
014B6:  MOV.B   #A,W0L
014B8:  MOV.B   W0L,1B3A
014BA:  CLR.B   1B3B
014BC:  CALL    1382
014C0:  GOTO    14E8
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(11); 
014C4:  MOV     1B36,W4
014C6:  XOR.B   #C2,W4L
014C8:  BRA     NZ,14D8
014CA:  MOV.B   #B,W0L
014CC:  MOV.B   W0L,1B3A
014CE:  CLR.B   1B3B
014D0:  CALL    1382
014D4:  GOTO    14E8
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(12); 
014D8:  MOV     1B36,W4
014DA:  XOR.B   #C4,W4L
014DC:  BRA     NZ,14E8
014DE:  MOV.B   #C,W0L
014E0:  MOV.B   W0L,1B3A
014E2:  CLR.B   1B3B
014E4:  CALL    1382
....................  
.................... 			return(0);//driver en mouvement, ou en erreur --> on renvoie 0	 
014E8:  CLR.B   0
014EA:  BRA     1852
.................... 			break; 
014EC:  GOTO    1852
.................... 					 
.................... 		case 2: // surcharge on tire plus de courant que le maximum configure 
.................... 	 
.................... 			if(driver_address==0xC0) 
014F0:  MOV     1B36,W4
014F2:  XOR.B   #C0,W4L
014F4:  BRA     NZ,15D0
.................... 			{ 
.................... 				while(!ok) 
014F6:  BTSC.B  1617.0
014F8:  BRA     15CC
.................... 				{ 
.................... 					switch(Etat) 
014FA:  MOV.B   1618,W0L
014FC:  CLR.B   1
014FE:  XOR     #0,W0
01500:  BRA     Z,1508
01502:  XOR     #1,W0
01504:  BRA     Z,1562
01506:  BRA     15C8
.................... 					{ 
.................... 						case 0: 
.................... 							if(!read) 
01508:  BTSC.B  1617.1
0150A:  BRA     1522
.................... 							{ 
.................... 								driver_moteur(0xC0,0); 
0150C:  MOV.B   #C0,W0L
0150E:  MOV.B   W0L,1B3A
01510:  CLR.B   1B3B
01512:  CALL    120E
.................... 								ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
01516:  MOV.B   #C0,W0L
01518:  MOV.B   W0L,1B3A
0151A:  CALL    13D6
0151E:  MOV     W0,1B38
.................... 								read = 1; 
01520:  BSET.B  1617.1
.................... 							} 
.................... 							if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
01522:  MOV     1618,W4
01524:  LSR     W4,#8,W4
01526:  CP.B    W4L,#1
01528:  BRA     Z,1558
.................... 							{ 
.................... 								Etat_driver = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition-250)); 
0152A:  MOV     1B38,W4
0152C:  SUB     #FA,W4
0152E:  MOV     W4,W5
01530:  MOV.B   #C0,W0L
01532:  MOV.B   W0L,1B3C
01534:  MOV.B   #1,W0L
01536:  MOV.B   W0L,1B3D
01538:  MOV.B   #1,W0L
0153A:  MOV.B   W0L,1B3E
0153C:  MOV.B   #1,W0L
0153E:  MOV.B   W0L,1B3F
01540:  PUSH    15DE
01542:  POP     1B40
01544:  MOV     W5,1B42
01546:  CLR     W4
01548:  BTSC.B  1B43.7
0154A:  SETM    W4
0154C:  MOV     W4,1B44
0154E:  CALL    114E
01552:  MOV.B   W0L,1619
.................... 							} 
01554:  GOTO    155E
.................... 							else 
.................... 							{ 
.................... 								Etat_driver = 0; 
01558:  CLR.B   1619
.................... 								Etat++; // passe au depl suivant 
0155A:  INC.B   1618
.................... 								read = 0; 
0155C:  BCLR.B  1617.1
.................... 							} 
.................... 							break; 
0155E:  GOTO    15C8
.................... 						case 1://retourne a la postion  
.................... 							Etat_d = read_driver_moteur(0xC0); 
01562:  MOV.B   #C0,W0L
01564:  MOV.B   W0L,1B44
01566:  CALL    1332
0156A:  MOV.B   W0L,1616
.................... 							if(Etat_d == 0) 
0156C:  CP0.B   1616
0156E:  BRA     NZ,15C4
.................... 							{ 
.................... 								if(!read) 
01570:  BTSC.B  1617.1
01572:  BRA     158E
.................... 								{ 
.................... 									ActualPosition = ActualPosition - 250; 
01574:  MOV     1B38,W4
01576:  SUB     #FA,W4
01578:  MOV     W4,1B38
.................... 									impulses_toDo = EndPosition - ActualPosition ; 
0157A:  MOV     1B38,W0
0157C:  CLR     W1
0157E:  BTSC    W0.F
01580:  SETM    W1
01582:  MOV     15E0,W4
01584:  SUB     W4,W0,W0
01586:  MOV     15E2,W4
01588:  SUBB    W4,W1,W1
0158A:  MOV     W0,1614
.................... 									read = 1;   
0158C:  BSET.B  1617.1
.................... 								} 
.................... 								if(Etat_driver!=1) 
0158E:  MOV     1618,W4
01590:  LSR     W4,#8,W4
01592:  CP.B    W4L,#1
01594:  BRA     Z,15C2
.................... 								{ 
.................... 									Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition + impulses_toDo)); 
01596:  MOV     1B38,W0
01598:  ADD     1614,W0
0159A:  MOV     W0,W5
0159C:  MOV.B   #C0,W0L
0159E:  MOV.B   W0L,1B3C
015A0:  CLR.B   1B3D
015A2:  MOV.B   #1,W0L
015A4:  MOV.B   W0L,1B3E
015A6:  MOV.B   #1,W0L
015A8:  MOV.B   W0L,1B3F
015AA:  PUSH    15DE
015AC:  POP     1B40
015AE:  MOV     W5,1B42
015B0:  CLR     W4
015B2:  BTSC.B  1B43.7
015B4:  SETM    W4
015B6:  MOV     W4,1B44
015B8:  CALL    114E
015BC:  MOV.B   W0L,1619
.................... 									 
.................... 								} 
015BE:  GOTO    15C4
.................... 								else 
.................... 								{ 
.................... 									ok = 1;  
015C2:  BSET.B  1617.0
.................... 								} 
.................... 							}								 
.................... 							break; 
015C4:  GOTO    15C8
.................... 					} 
015C8:  GOTO    14F6
.................... 					} 
.................... 			} 
015CC:  GOTO    15F0
.................... 			else if(driver_address==0xC2) __Affichage_erreur(11); // surcharge ejection 
015D0:  MOV     1B36,W4
015D2:  XOR.B   #C2,W4L
015D4:  BRA     NZ,15E2
015D6:  MOV.B   #B,W0L
015D8:  MOV.B   W0L,1B3A
015DA:  CALL    107A
015DE:  GOTO    15F0
.................... 			else if(driver_address==0xC4) __Affichage_erreur(12); // surcharge cremaillere		 
015E2:  MOV     1B36,W4
015E4:  XOR.B   #C4,W4L
015E6:  BRA     NZ,15F0
015E8:  MOV.B   #C,W0L
015EA:  MOV.B   W0L,1B3A
015EC:  CALL    107A
.................... 			ok = 0; 
015F0:  BCLR.B  1617.0
.................... 			return(0); 
015F2:  CLR.B   0
015F4:  BRA     1852
.................... 			break; 
015F6:  GOTO    1852
.................... 			 
.................... 		case 3: // surchauffe pont-h 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(16); 
015FA:  MOV     1B36,W4
015FC:  XOR.B   #C0,W4L
015FE:  BRA     NZ,160E
01600:  MOV.B   #10,W0L
01602:  MOV.B   W0L,1B3A
01604:  CLR.B   1B3B
01606:  CALL    1382
0160A:  GOTO    1632
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(17); 
0160E:  MOV     1B36,W4
01610:  XOR.B   #C2,W4L
01612:  BRA     NZ,1622
01614:  MOV.B   #11,W0L
01616:  MOV.B   W0L,1B3A
01618:  CLR.B   1B3B
0161A:  CALL    1382
0161E:  GOTO    1632
.................... 			else if(driver_address==0xC4) __Afficheur_7segments(18); 
01622:  MOV     1B36,W4
01624:  XOR.B   #C4,W4L
01626:  BRA     NZ,1632
01628:  MOV.B   #12,W0L
0162A:  MOV.B   W0L,1B3A
0162C:  CLR.B   1B3B
0162E:  CALL    1382
.................... 			 
.................... 			if(Time_ms==0)Time_ms = GameTimeMS; 
01632:  CP0     1610
01634:  BRA     NZ,1646
01636:  CP0     1612
01638:  BRA     NZ,1646
0163A:  PUSH    86A
0163C:  POP     1610
0163E:  PUSH    86C
01640:  POP     1612
01642:  GOTO    17CC
.................... 			else if(GameTimeMS - Time_ms >= TIME_SURCHAUFFE_MS)//on attend 1s 
01646:  MOV     86A,W4
01648:  MOV     1610,W3
0164A:  SUB     W4,W3,W5
0164C:  MOV     86C,W4
0164E:  MOV     1612,W3
01650:  SUBB    W4,W3,W6
01652:  CP      W6,#0
01654:  BRA     NC,17CC
01656:  BRA     GTU,165E
01658:  MOV     C00,W4
0165A:  CP      W4,W5
0165C:  BRA     GTU,17CC
.................... 			{ 
.................... 				Time_ms = 0; 
0165E:  CLR     1610
01660:  CLR     1612
.................... 				 
.................... 				if(driver_address == 0xC0)//moteur barillet 
01662:  MOV     1B36,W4
01664:  XOR.B   #C0,W4L
01666:  BRA     NZ,16C2
.................... 				{ 
.................... 					ActualPosition = read_pos_moteur(0xC0); //on reprend l'ordre 
01668:  MOV.B   #C0,W0L
0166A:  MOV.B   W0L,1B3A
0166C:  CALL    13D6
01670:  MOV     W0,1B38
.................... 					if((ActualPosition-EndPosition)!= 0) 
01672:  MOV     1B38,W0
01674:  CLR     W1
01676:  BTSC    W0.F
01678:  SETM    W1
0167A:  MOV     15E0,W4
0167C:  SUB     W0,W4,W5
0167E:  MOV     15E2,W4
01680:  SUBB    W1,W4,W6
01682:  CP0     W5
01684:  BRA     NZ,168A
01686:  CP0     W6
01688:  BRA     Z,16BE
.................... 					{ 
.................... 						impulses_toDo = EndPosition - ActualPosition ;  
0168A:  MOV     1B38,W0
0168C:  CLR     W1
0168E:  BTSC    W0.F
01690:  SETM    W1
01692:  MOV     15E0,W4
01694:  SUB     W4,W0,W0
01696:  MOV     15E2,W4
01698:  SUBB    W4,W1,W1
0169A:  MOV     W0,1614
.................... 						go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,impulses_toDo); 
0169C:  MOV.B   #C0,W0L
0169E:  MOV.B   W0L,1B3C
016A0:  CLR.B   1B3D
016A2:  MOV.B   #1,W0L
016A4:  MOV.B   W0L,1B3E
016A6:  MOV.B   #1,W0L
016A8:  MOV.B   W0L,1B3F
016AA:  PUSH    15DE
016AC:  POP     1B40
016AE:  PUSH    1614
016B0:  POP     1B42
016B2:  CLR     W4
016B4:  BTSC.B  1B43.7
016B6:  SETM    W4
016B8:  MOV     W4,1B44
016BA:  CALL    114E
.................... 					} 
.................... 				} 
016BE:  GOTO    178E
.................... 				else if(driver_address == 0xC2)//moteur qui couche les modules 
016C2:  MOV     1B36,W4
016C4:  XOR.B   #C2,W4L
016C6:  BRA     NZ,174A
.................... 				{ 
.................... 					if((GameTimeMS-Time_ejection)<Time_ejection_toDo) 
016C8:  MOV     86A,W4
016CA:  MOV     C02,W3
016CC:  SUB     W4,W3,W5
016CE:  MOV     86C,W4
016D0:  MOV     C04,W3
016D2:  SUBB    W4,W3,W6
016D4:  MOV     C08,W4
016D6:  CP      W4,W6
016D8:  BRA     NC,1746
016DA:  BRA     GTU,16E2
016DC:  MOV     C06,W4
016DE:  CP      W4,W5
016E0:  BRA     LEU,1746
.................... 					{ 
.................... 						Time_ejection_toDo = Time_ejection_toDo - (GameTimeMS-Time_ejection); //calcul du temps qu'il reste a faire 
016E2:  MOV     86A,W4
016E4:  MOV     C02,W3
016E6:  SUB     W4,W3,W0
016E8:  MOV     86C,W4
016EA:  MOV     C04,W3
016EC:  SUBB    W4,W3,W1
016EE:  MOV     C06,W4
016F0:  SUB     W4,W0,W0
016F2:  MOV     W0,C06
016F4:  MOV     C08,W4
016F6:  SUBB    W4,W1,W0
016F8:  MOV     W0,C08
.................... 						//renvoi de la suite de l'ordre 
.................... 						if(Etat_ejection == 1) go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,100,DRV_ARRET_TEMPS, Time_ejection_toDo);						 
016FA:  MOV     15DA,W4
016FC:  LSR     W4,#8,W4
016FE:  CP.B    W4L,#1
01700:  BRA     NZ,1726
01702:  MOV.B   #C2,W0L
01704:  MOV.B   W0L,1B3C
01706:  MOV.B   #1,W0L
01708:  MOV.B   W0L,1B3D
0170A:  MOV.B   #2,W0L
0170C:  MOV.B   W0L,1B3E
0170E:  MOV.B   #3,W0L
01710:  MOV.B   W0L,1B3F
01712:  MOV     #64,W4
01714:  MOV     W4,1B40
01716:  PUSH    C06
01718:  POP     1B42
0171A:  PUSH    C08
0171C:  POP     1B44
0171E:  CALL    114E
01722:  GOTO    1746
.................... 						else go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,25,DRV_ARRET_TEMPS,Time_ejection_toDo); 
01726:  MOV.B   #C2,W0L
01728:  MOV.B   W0L,1B3C
0172A:  MOV.B   #1,W0L
0172C:  MOV.B   W0L,1B3D
0172E:  MOV.B   #2,W0L
01730:  MOV.B   W0L,1B3E
01732:  MOV.B   #3,W0L
01734:  MOV.B   W0L,1B3F
01736:  MOV     #19,W4
01738:  MOV     W4,1B40
0173A:  PUSH    C06
0173C:  POP     1B42
0173E:  PUSH    C08
01740:  POP     1B44
01742:  CALL    114E
.................... 					}	 
.................... 				} 
01746:  GOTO    178E
.................... 				else if(driver_address == 0xC4) 
0174A:  MOV     1B36,W4
0174C:  XOR.B   #C4,W4L
0174E:  BRA     NZ,178E
.................... 				{ 
.................... 					if(bras_out)go_driver_moteur(0xC4,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200); // rentre le bras 
01750:  BTSS.B  14B1.5
01752:  BRA     1772
01754:  MOV.B   #C4,W0L
01756:  MOV.B   W0L,1B3C
01758:  CLR.B   1B3D
0175A:  MOV.B   #2,W0L
0175C:  MOV.B   W0L,1B3E
0175E:  CLR.B   1B3F
01760:  MOV     #64,W4
01762:  MOV     W4,1B40
01764:  MOV     #C8,W4
01766:  MOV     W4,1B42
01768:  CLR     1B44
0176A:  CALL    114E
0176E:  GOTO    178E
.................... 					else go_driver_moteur(0xC4,1,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200);	   // sort le bras		 
01772:  MOV.B   #C4,W0L
01774:  MOV.B   W0L,1B3C
01776:  MOV.B   #1,W0L
01778:  MOV.B   W0L,1B3D
0177A:  MOV.B   #2,W0L
0177C:  MOV.B   W0L,1B3E
0177E:  CLR.B   1B3F
01780:  MOV     #64,W4
01782:  MOV     W4,1B40
01784:  MOV     #C8,W4
01786:  MOV     W4,1B42
01788:  CLR     1B44
0178A:  CALL    114E
.................... 				} 
.................... 				passage_erreur++; 
0178E:  INC.B   160F
.................... 				if(passage_erreur > Erreur_max_surchauffe)// si on a 10 erreurs a la suite de surchauffe 
01790:  MOV.B   881,W0L
01792:  MOV     160E,W4
01794:  LSR     W4,#8,W4
01796:  CP.B    W4L,W0L
01798:  BRA     LEU,17CC
.................... 				{ 
.................... 					if(driver_address == 0xC0)    __Affichage_erreur(13); //surcahuffe driver barrilet 
0179A:  MOV     1B36,W4
0179C:  XOR.B   #C0,W4L
0179E:  BRA     NZ,17AC
017A0:  MOV.B   #D,W0L
017A2:  MOV.B   W0L,1B3A
017A4:  CALL    107A
017A8:  GOTO    17CC
.................... 					else if(driver_address==0xC2) __Affichage_erreur(14); //surchauffe driver ejection 
017AC:  MOV     1B36,W4
017AE:  XOR.B   #C2,W4L
017B0:  BRA     NZ,17BE
017B2:  MOV.B   #E,W0L
017B4:  MOV.B   W0L,1B3A
017B6:  CALL    107A
017BA:  GOTO    17CC
.................... 					else if(driver_address==0xC4) __Affichage_erreur(15); //surchauffe driver cremaillere	 
017BE:  MOV     1B36,W4
017C0:  XOR.B   #C4,W4L
017C2:  BRA     NZ,17CC
017C4:  MOV.B   #F,W0L
017C6:  MOV.B   W0L,1B3A
017C8:  CALL    107A
.................... 				} 
.................... 				 
.................... 			} 	 
.................... 			return(0);						 
017CC:  CLR.B   0
017CE:  BRA     1852
.................... 			break; 
017D0:  GOTO    1852
.................... 		case 4://processing 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(13); 
017D4:  MOV     1B36,W4
017D6:  XOR.B   #C0,W4L
017D8:  BRA     NZ,17E8
017DA:  MOV.B   #D,W0L
017DC:  MOV.B   W0L,1B3A
017DE:  CLR.B   1B3B
017E0:  CALL    1382
017E4:  GOTO    180C
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(14); 
017E8:  MOV     1B36,W4
017EA:  XOR.B   #C2,W4L
017EC:  BRA     NZ,17FC
017EE:  MOV.B   #E,W0L
017F0:  MOV.B   W0L,1B3A
017F2:  CLR.B   1B3B
017F4:  CALL    1382
017F8:  GOTO    180C
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(15); 
017FC:  MOV     1B36,W4
017FE:  XOR.B   #C4,W4L
01800:  BRA     NZ,180C
01802:  MOV.B   #F,W0L
01804:  MOV.B   W0L,1B3A
01806:  CLR.B   1B3B
01808:  CALL    1382
.................... 			return(0);  
0180C:  CLR.B   0
0180E:  BRA     1852
.................... 			break;  
01810:  GOTO    1852
.................... 		case 5://slave ne repond pas 
.................... 			if(driver_address == 0xC0)    __Affichage_erreur(16); //driver barillet ne repond pas 
01814:  MOV     1B36,W4
01816:  XOR.B   #C0,W4L
01818:  BRA     NZ,1826
0181A:  MOV.B   #10,W0L
0181C:  MOV.B   W0L,1B3A
0181E:  CALL    107A
01822:  GOTO    184A
.................... 			else if(driver_address==0xC2) __Affichage_erreur(17); //driver ejection ne repond pas 
01826:  MOV     1B36,W4
01828:  XOR.B   #C2,W4L
0182A:  BRA     NZ,1838
0182C:  MOV.B   #11,W0L
0182E:  MOV.B   W0L,1B3A
01830:  CALL    107A
01834:  GOTO    184A
.................... 			else if(driver_address==0xC4) __Affichage_erreur(18); //driver cremaillere ne repond pas			 
01838:  MOV     1B36,W4
0183A:  XOR.B   #C4,W4L
0183C:  BRA     NZ,184A
0183E:  MOV.B   #12,W0L
01840:  MOV.B   W0L,1B3A
01842:  CALL    107A
01846:  GOTO    184A
.................... 			else ;//__Affichage_erreur();	 
.................... 			return(0);			 
0184A:  CLR.B   0
0184C:  BRA     1852
.................... 			break; 
0184E:  GOTO    1852
.................... 	} 
01852:  MOV     [--W15],W6
01854:  MOV     [--W15],W5
01856:  RETURN  
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "PC/___PC.h" 
.................... /* 
.................... * \file ___PC.h 
.................... * \brief Gère la communication PC (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_H 
.................... #define ___PC_H 
....................  
....................  
....................  
.................... // Config RS232 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=RS232) 
.................... // Config UART 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,stream=UARTi) 
....................  
.................... // Définit quand un tableau est à décoder 
.................... int1 PCh_flagUARTReadyToDecode = 0; 
.................... // Watchdog pour éviter un blocage UART 
.................... int1 PCh_flagUARTWatchdog = 0; 
....................  
....................  
.................... void __Init_UART(void);	// Initialise 
.................... void __UART_Decode(unsigned int32* _Tab);	// Décode une trame 
.................... void __SendBackUART(void); // Renvoi la dernière commande envoyée 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec); // Décode un tableau 
.................... #include "PC/___PC.c" 
.................... /* 
.................... * \file ___PC.c 
.................... * \brief Gère la communication PC (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_C 
.................... #define ___PC_C 
....................  
.................... // Bits & define 
.................... 	// Contient la trame à décoder 
.................... unsigned int8 TabToDecode[256]={0}; 
.................... unsigned int8 PosTabToDecode = 0; 
.................... unsigned int8 ToDoUART = 0; 
.................... 	// Contient les valeurs décodées 
.................... unsigned int32 TabDecoded[256]={0}; 
.................... 	// Attend une réponse 
.................... int1 UARTWaitResp=0; 
.................... 	// Nombre de fois à renvoyer 
.................... unsigned int8 UARTToSendBack=0; 
.................... 	 
....................  
.................... /** 
.................... * \fn void __Init_UART(void) 
.................... * \brief Initie l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Init_UART(void) 
.................... { 
.................... 	// Réception 
.................... 	enable_interrupts(INT_RDA); 
*
01076:  BSET.B  8D.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
01078:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void RDA_isr(void) 
.................... * \brief Interruption RDA, récupère les caractères du RS232. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... */ 
.................... #INT_RDA 
.................... void RDA_isr(void) 
*
0095A:  PUSH    42
0095C:  PUSH    36
0095E:  PUSH    32
00960:  MOV     W0,[W15++]
00962:  MOV     #2,W0
00964:  REPEAT  #C
00966:  MOV     [W0++],[W15++]
.................... {	 
.................... 	// Checksum UART 
.................... 	static unsigned int8 HashR1, HashR2, HashC1, HashC2; 
.................... 	if(PCh_flagUARTReadyToDecode==0) 
00968:  BTSC.B  1617.2
0096A:  BRA     ACC
.................... 	{ 
.................... 		// Active le watchdog UART 
.................... 		PCh_flagUARTWatchdog = 1; 
0096C:  BSET.B  1617.3
.................... 		// Traite la réception 
.................... 		while(kbhit(RS232)) 
0096E:  BTSS.B  20E.0
00970:  BRA     ACC
.................... 		{ 
.................... 			// Récupération donnée 
.................... 			unsigned int8 Dataa = fgetc(RS232); 
00972:  BTSS.B  20E.0
00974:  BRA     972
00976:  MOV     212,W0
00978:  MOV.B   W0L,1C74
.................... 			 
.................... 			// Si c'est une réponse à un envoi, on remet à 0 l'attente de réponse et la fausse erreur 
.................... 			if(UARTWaitResp && Dataa==ACK)  
0097A:  BTSS.B  1617.4
0097C:  BRA     98C
0097E:  MOV     1C74,W4
00980:  CP.B    W4L,#6
00982:  BRA     NZ,98C
.................... 			{ 
.................... 				UARTWaitResp=0; 
00984:  BCLR.B  1617.4
.................... 				UARTToSendBack=0; 
00986:  CLR.B   1B1C
.................... 				 
.................... 			}	 
00988:  GOTO    AC8
.................... 			// Si ce n'est pas OK, renvoie un certain nombre de fois 
.................... 			else if(UARTWaitResp && Dataa==NAK) 
0098C:  BTSS.B  1617.4
0098E:  BRA     9B2
00990:  MOV     1C74,W4
00992:  CP.B    W4L,#15
00994:  BRA     NZ,9B2
.................... 			{ 
.................... 				if(UARTToSendBack<UART_NBR_REP_NAK) {__SendBackUART();UARTToSendBack++;} 
00996:  MOV.B   1B1C,W0L
00998:  MOV     14AA,W4
0099A:  LSR     W4,#8,W4
0099C:  CP.B    W4L,W0L
0099E:  BRA     LEU,9AA
009A0:  CALL    640
009A4:  INC.B   1B1C
009A6:  GOTO    9AE
.................... 				else {UARTWaitResp=0;UARTToSendBack=0;} 
009AA:  BCLR.B  1617.4
009AC:  CLR.B   1B1C
.................... 			} 
009AE:  GOTO    AC8
.................... 			// Réception 
.................... 			else 
.................... 			{	 
.................... 				// Début de transmission 
.................... 				if(Dataa == STX&&ToDoUART==0) 
009B2:  MOV     1C74,W4
009B4:  CP.B    W4L,#2
009B6:  BRA     NZ,9CC
009B8:  CP0.B   171B
009BA:  BRA     NZ,9CC
.................... 				{ 
.................... 					HashC1 = HashC2 = 0; 
009BC:  CLR.B   1B20
009BE:  MOV.B   1B20,W0L
009C0:  MOV.B   W0L,1B1F
.................... 					ToDoUART=1;  
009C2:  MOV.B   #1,W0L
009C4:  MOV.B   W0L,171B
.................... 					PosTabToDecode=0; 
009C6:  CLR.B   171A
.................... 				} 
009C8:  GOTO    AC8
.................... 				// Fin de transmission 
.................... 				else if(Dataa == ETX&&ToDoUART==5)		 
009CC:  MOV     1C74,W4
009CE:  CP.B    W4L,#3
009D0:  BRA     NZ,A52
009D2:  MOV     171A,W4
009D4:  LSR     W4,#8,W4
009D6:  CP.B    W4L,#5
009D8:  BRA     NZ,A52
.................... 				{		 
.................... 					if(HashC1==ETX||HashC1==CR)HashC1++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
009DA:  MOV     1B1E,W4
009DC:  LSR     W4,#8,W4
009DE:  CP.B    W4L,#3
009E0:  BRA     Z,9EA
009E2:  MOV     1B1E,W4
009E4:  LSR     W4,#8,W4
009E6:  CP.B    W4L,#D
009E8:  BRA     NZ,9EC
009EA:  INC.B   1B1F
.................... 					if(HashC2==ETX||HashC2==CR)HashC2++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
009EC:  MOV     1B20,W4
009EE:  CP.B    W4L,#3
009F0:  BRA     Z,9F8
009F2:  MOV     1B20,W4
009F4:  CP.B    W4L,#D
009F6:  BRA     NZ,9FA
009F8:  INC.B   1B20
.................... 					// Si trame OK 
.................... 					if(HashC1==HashR1 && HashC2==HashR2) 
009FA:  MOV.B   1B1F,W0L
009FC:  CP.B    1B1D
009FE:  BRA     NZ,A3C
00A00:  MOV.B   1B20,W0L
00A02:  CP.B    1B1E
00A04:  BRA     NZ,A3C
.................... 					{ 
.................... 						TabToDecode[PosTabToDecode] = ETX; 
00A06:  MOV     171A,W4
00A08:  CLR.B   9
00A0A:  MOV     #161A,W3
00A0C:  ADD     W4,W3,W5
00A0E:  MOV.B   #3,W0L
00A10:  MOV.B   W0L,[W5]
.................... 						// Décode le tableau 
.................... 						__CommDecode(TabToDecode,TabDecoded); 
00A12:  MOV     #161A,W4
00A14:  MOV     W4,1C76
00A16:  MOV     #171C,W4
00A18:  MOV     W4,1C78
00A1A:  CALL    8DE
.................... 						if(TabDecoded[0]==UART_ADDR) 
00A1E:  MOV     171C,W0
00A20:  CP      14AC
00A22:  BRA     NZ,A38
00A24:  MOV     171E,W0
00A26:  CP      14AE
00A28:  BRA     NZ,A38
.................... 						{	 
.................... 							// Dit qu'on est prêts à recevoir 
.................... 							PCh_flagUARTReadyToDecode=1; 
00A2A:  BSET.B  1617.2
.................... 							// Renvoie un simple OK 
.................... 							fputc(ACK,RS232); 
00A2C:  MOV.B   #6,W0L
00A2E:  BTSC.B  20F.1
00A30:  BRA     A2E
00A32:  MOV.B   W0L,210
00A34:  CLR.B   211
.................... 							// Dit qu'on attend une réponse 
.................... 							UARTWaitResp=1; 
00A36:  BSET.B  1617.4
.................... 						}	 
.................... 					} 
00A38:  GOTO    A46
.................... 					else fputc(NAK,RS232); // Erreur de réception, envoi un pas ok 
00A3C:  MOV.B   #15,W0L
00A3E:  BTSC.B  20F.1
00A40:  BRA     A3E
00A42:  MOV.B   W0L,210
00A44:  CLR.B   211
.................... 					ToDoUART = 0; 
00A46:  CLR.B   171B
.................... 					PosTabToDecode=0; 
00A48:  CLR.B   171A
.................... 					UARTToSendBack=0; 
00A4A:  CLR.B   1B1C
.................... 					// Désactive le watchdog UART 
.................... 					PCh_flagUARTWatchdog = 0; 
00A4C:  BCLR.B  1617.3
.................... 				} 
00A4E:  GOTO    AC8
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==1)ToDoUART=2; 
00A52:  MOV     171A,W4
00A54:  LSR     W4,#8,W4
00A56:  CP.B    W4L,#1
00A58:  BRA     NZ,A62
00A5A:  MOV.B   #2,W0L
00A5C:  MOV.B   W0L,171B
00A5E:  GOTO    AC8
.................... 				// Enregistre le premier Hash 
.................... 				else if(ToDoUART==2) 
00A62:  MOV     171A,W4
00A64:  LSR     W4,#8,W4
00A66:  CP.B    W4L,#2
00A68:  BRA     NZ,A76
.................... 				{ 
.................... 					HashR1 = Dataa; 
00A6A:  MOV.B   1C74,W0L
00A6C:  MOV.B   W0L,1B1D
.................... 					ToDoUART=3;	 
00A6E:  MOV.B   #3,W0L
00A70:  MOV.B   W0L,171B
.................... 				}	 
00A72:  GOTO    AC8
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==3)ToDoUART=4; 
00A76:  MOV     171A,W4
00A78:  LSR     W4,#8,W4
00A7A:  CP.B    W4L,#3
00A7C:  BRA     NZ,A86
00A7E:  MOV.B   #4,W0L
00A80:  MOV.B   W0L,171B
00A82:  GOTO    AC8
.................... 				// Enregistre le second Hash 
.................... 				else if(ToDoUART==4) 
00A86:  MOV     171A,W4
00A88:  LSR     W4,#8,W4
00A8A:  CP.B    W4L,#4
00A8C:  BRA     NZ,A9A
.................... 				{ 
.................... 					HashR2 = Dataa; 
00A8E:  MOV.B   1C74,W0L
00A90:  MOV.B   W0L,1B1E
.................... 					ToDoUART=5; 
00A92:  MOV.B   #5,W0L
00A94:  MOV.B   W0L,171B
.................... 				} 
00A96:  GOTO    AC8
.................... 				// Capture la trame 
.................... 				else if(ToDoUART == 5)  
00A9A:  MOV     171A,W4
00A9C:  LSR     W4,#8,W4
00A9E:  CP.B    W4L,#5
00AA0:  BRA     NZ,AC8
.................... 				{ 
.................... 					// Hash les valeurs reçues 
.................... 					HashC1 += Dataa; 
00AA2:  MOV.B   1B1F,W0L
00AA4:  ADD.B   1C74,W0L
00AA6:  MOV.B   W0L,1B1F
.................... 					HashC2 = (HashC2+Dataa)*(PosTabToDecode+1);	 
00AA8:  MOV.B   1B20,W0L
00AAA:  ADD.B   1C74,W0L
00AAC:  MOV.B   W0L,A
00AAE:  MOV     171A,W4
00AB0:  CLR.B   9
00AB2:  ADD     W4,#1,W0
00AB4:  CLR.B   B
00AB6:  MUL.UU  W5,W0,W0
00AB8:  MOV.B   W0L,1B20
.................... 					// Retire l'incrément ASCII et enregistre 
.................... 					TabToDecode[PosTabToDecode] = Dataa; 
00ABA:  MOV     171A,W4
00ABC:  CLR.B   9
00ABE:  MOV     #161A,W3
00AC0:  ADD     W4,W3,W5
00AC2:  MOV     1C74,W0
00AC4:  MOV.B   W0L,[W5+#0]
.................... 					 
.................... 					PosTabToDecode++; 
00AC6:  INC.B   171A
.................... 				} 
.................... 			}			 
00AC8:  GOTO    96E
.................... 		}	 
.................... 	}		 
.................... 	// Quitte l'interruption 
.................... 	return; 
00ACC:  BCLR.B  85.1
00ACE:  MOV     #1A,W0
00AD0:  REPEAT  #C
00AD2:  MOV     [--W15],[W0--]
00AD4:  MOV     [--W15],W0
00AD6:  POP     32
00AD8:  POP     36
00ADA:  POP     42
00ADC:  RETFIE  
.................... } 
....................  
.................... /** 
.................... * \fn void __UART_Decode(char* Tab) 
.................... * \brief Décode la trame de l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \param[in] (*)_Tab Tableau avec lequel travailler 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __UART_Decode(unsigned int32* _Tab) 
*
0A654:  MOV     W5,[W15++]
0A656:  MOV     #C,W5
0A658:  REPEAT  #7
0A65A:  MOV     [W5++],[W15++]
0A65C:  CLR     1B34
0A65E:  CLR     1B38
0A660:  CLR     1B3A
0A662:  CLR     1B3C
.................... { 
.................... 	unsigned int16 index = 0; 
.................... 	unsigned int16 Xo,Yo = 0; 
.................... 	signed int16 phi = 0;	 
.................... 	static int16 memo; 
.................... 	static int16 Memorise; 
.................... 	unsigned int16 Adresse = 0; 
.................... 	// Regarde quoi faire 
.................... 	switch(*(_Tab+1)) // On saute la première adresse mémoire qui contient l'adresse du driver 
0A664:  MOV     1B32,W4
0A666:  ADD     W4,#4,W0
0A668:  MOV     W0,W5
0A66A:  MOV     #0,W3
0A66C:  MOV     [W5++],[W3++]
0A66E:  MOV     [W5++],[W3++]
0A670:  CP0     W0
0A672:  BRA     NZ,A678
0A674:  CP0     W1
0A676:  BRA     Z,A704
0A678:  CP      W0,#1
0A67A:  BRA     NZ,A680
0A67C:  CP0     W1
0A67E:  BRA     Z,A710
0A680:  CP      W0,#2
0A682:  BRA     NZ,A688
0A684:  CP0     W1
0A686:  BRA     Z,A71E
0A688:  CP      W0,#3
0A68A:  BRA     NZ,A690
0A68C:  CP0     W1
0A68E:  BRA     Z,A724
0A690:  CP      W0,#4
0A692:  BRA     NZ,A698
0A694:  CP0     W1
0A696:  BRA     Z,A728
0A698:  CP      W0,#A
0A69A:  BRA     NZ,A6A0
0A69C:  CP0     W1
0A69E:  BRA     Z,A72C
0A6A0:  CP      W0,#B
0A6A2:  BRA     NZ,A6A8
0A6A4:  CP0     W1
0A6A6:  BRA     Z,A748
0A6A8:  CP      W0,#C
0A6AA:  BRA     NZ,A6B0
0A6AC:  CP0     W1
0A6AE:  BRA     Z,A74C
0A6B0:  CP      W0,#14
0A6B2:  BRA     NZ,A6B8
0A6B4:  CP0     W1
0A6B6:  BRA     Z,A790
0A6B8:  CP      W0,#15
0A6BA:  BRA     NZ,A6C0
0A6BC:  CP0     W1
0A6BE:  BRA     Z,A794
0A6C0:  CP      W0,#16
0A6C2:  BRA     NZ,A6C8
0A6C4:  CP0     W1
0A6C6:  BRA     Z,A7E2
0A6C8:  CP      W0,#17
0A6CA:  BRA     NZ,A6D0
0A6CC:  CP0     W1
0A6CE:  BRA     Z,A7F4
0A6D0:  CP      W0,#18
0A6D2:  BRA     NZ,A6D8
0A6D4:  CP0     W1
0A6D6:  BRA     Z,A83C
0A6D8:  CP      W0,#19
0A6DA:  BRA     NZ,A6E0
0A6DC:  CP0     W1
0A6DE:  BRA     Z,A8B0
0A6E0:  CP      W0,#1E
0A6E2:  BRA     NZ,A6E8
0A6E4:  CP0     W1
0A6E6:  BRA     Z,A8BE
0A6E8:  CP      W0,#1F
0A6EA:  BRA     NZ,A6F0
0A6EC:  CP0     W1
0A6EE:  BRA     Z,A8C2
0A6F0:  CP      W0,#13
0A6F2:  BRA     NZ,A6F8
0A6F4:  CP0     W1
0A6F6:  BRA     Z,A8C6
0A6F8:  MOV     #32,W4
0A6FA:  CP      W0,W4
0A6FC:  BRA     NZ,A702
0A6FE:  CP0     W1
0A700:  BRA     Z,A920
0A702:  BRA     A924
.................... 	{ 
.................... 		// Test Comm - LED Blink 
.................... 		case 0 : 
.................... 			_LED1=_LED2=_LED3=_LED4=1; 
0A704:  BSET.B  2D0.4
0A706:  BSET.B  2D0.3
0A708:  BSET.B  2D0.2
0A70A:  BSET.B  2D0.1
.................... 			break; 
0A70C:  GOTO    A940
.................... 		// Demande si est connecté	 
.................... 		case 1 : 
.................... 			fputc(0x31,RS232); 
0A710:  MOV.B   #31,W0L
0A712:  BTSC.B  20F.1
0A714:  BRA     A712
0A716:  MOV.B   W0L,210
0A718:  CLR.B   211
.................... 			break; 
0A71A:  GOTO    A940
.................... 		// Reset la plaque 
.................... 		case 2 : 
.................... 			reset_cpu(); 
0A71E:  RESET   
.................... 			break; 
0A720:  GOTO    A940
.................... 		// Demande si RoboteQ connecté 
.................... 		case 3 : 
.................... 			// ? 
.................... 			break; 
0A724:  GOTO    A940
.................... 		// Configuration du robot 
.................... 		case 4 :			 
.................... 			break; 
0A728:  GOTO    A940
.................... 		// Change d'objectif 
.................... 		case 10 : 
.................... 			flagMarche = (int1)(*(_Tab+2)); 
0A72C:  MOV     1B32,W4
0A72E:  ADD     W4,#8,W0
0A730:  MOV     W0,[W15++]
0A732:  MOV.B   [W0],W0L
0A734:  MOV.B   W0L,FEF
0A736:  MOV     [--W15],W0
0A738:  CLR     W0
0A73A:  BTSC.B  FEF.0
0A73C:  INC     W0,W0
0A73E:  BCLR.B  14B1.0
0A740:  BTSC.B  0.0
0A742:  BSET.B  14B1.0
.................... 			break; 
0A744:  GOTO    A940
.................... 		//	Arrêt d'urgence 
.................... 		case 11 : 
.................... 			 
.................... 			break; 
0A748:  GOTO    A940
.................... 		// Set la position de départ 
.................... 		case 12 : 
.................... 			Xo = *(_Tab+2); 
0A74C:  MOV     1B32,W4
0A74E:  ADD     W4,#8,W0
0A750:  MOV     [W0],[W15++]
0A752:  POP     1B36
.................... 			Yo = *(_Tab+3); 
0A754:  MOV     1B32,W4
0A756:  ADD     W4,#C,W0
0A758:  MOV     [W0],[W15++]
0A75A:  POP     1B38
.................... 			phi = *(_Tab+4); 
0A75C:  MOV     1B32,W4
0A75E:  ADD     W4,#10,W0
0A760:  MOV     W0,W4
0A762:  MOV     #0,W3
0A764:  MOV     [W4++],[W3++]
0A766:  MOV     [W4++],[W3++]
0A768:  MOV     W0,1B3A
.................... 			 
.................... 			write_eeprom(800,Xo); 
0A76A:  MOV     #320,W0
0A76C:  MOV     #1B36,W1
0A76E:  MOV     #2,W2
0A770:  CALL    A186
.................... 			write_eeprom(802,Yo); 
0A774:  MOV     #322,W0
0A776:  MOV     #1B38,W1
0A778:  MOV     #2,W2
0A77A:  CALL    A186
.................... 			write_eeprom(804,phi); 
0A77E:  MOV     #324,W0
0A780:  MOV     #1B3A,W1
0A782:  MOV     #2,W2
0A784:  CALL    A186
.................... 			 
.................... 			__Init_pos();	 
0A788:  CALL    1B96
.................... 			break; 
0A78C:  GOTO    A940
.................... 		 
.................... 		// Enregistre le nombre d'objectifs 
.................... 		case 20 : 
.................... 			break; 
0A790:  GOTO    A940
.................... 		// Sauvegarde un objectif en EEPROM 
.................... 		case 21 : 
.................... 			for(index = memo; index <  (memo + 28); index += 2) 
0A794:  PUSH    1B22
0A796:  POP     1B34
0A798:  MOV     1B22,W4
0A79A:  ADD     W4,#1C,W0
0A79C:  MOV     1B34,W4
0A79E:  CP      W4,W0
0A7A0:  BRA     GE,A7D6
.................... 			{ 
.................... 				write_eeprom(index, *( _Tab +((index - memo)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0A7A2:  MOV     1B34,W4
0A7A4:  MOV     1B22,W3
0A7A6:  SUB     W4,W3,W5
0A7A8:  MOV     W5,W4
0A7AA:  MOV     #2,W3
0A7AC:  REPEAT  #11
0A7AE:  DIV.S   W4,W3
0A7B0:  MOV     W0,W5
0A7B2:  MOV     W5,W4
0A7B4:  MUL.UU  W4,#4,W0
0A7B6:  MOV     1B32,W4
0A7B8:  ADD     W0,W4,W5
0A7BA:  ADD     W5,#C,W0
0A7BC:  MOV     #A,W4
0A7BE:  MOV     [W0++],[W4++]
0A7C0:  MOV     [W0++],[W4++]
0A7C2:  MOV     1B34,W0
0A7C4:  MOV     #A,W1
0A7C6:  MOV     #2,W2
0A7C8:  CALL    A186
0A7CC:  MOV     1B34,W4
0A7CE:  ADD     W4,#2,W0
0A7D0:  MOV     W0,1B34
0A7D2:  GOTO    A798
.................... 			} 
.................... 			memo = index; //offset afin d'aler écrie plus loin dans l'eeprom 
0A7D6:  PUSH    1B34
0A7D8:  POP     1B22
.................... 			__ReadObjectifs(); 
0A7DA:  CALL    1A92
.................... 		break; 
0A7DE:  GOTO    A940
.................... 		// Définit le prochain objectif à charger 
.................... 		case 22 : 
.................... 			NextObj=(unsigned int16)*(_Tab+2); 
0A7E2:  MOV     1B32,W4
0A7E4:  ADD     W4,#8,W0
0A7E6:  MOV     W0,W4
0A7E8:  MOV     #0,W3
0A7EA:  MOV     [W4++],[W3++]
0A7EC:  MOV     [W4++],[W3++]
0A7EE:  MOV     W0,14B6
.................... 			break; 
0A7F0:  GOTO    A940
.................... 		// Set les PIDs de roboteQ 
.................... 		case 23 : 
.................... 			while(index<250)//reset le tableau 
0A7F4:  MOV     1B34,W4
0A7F6:  MOV     #FA,W3
0A7F8:  CP      W3,W4
0A7FA:  BRA     LEU,A80C
.................... 			{ 
.................... 				 TabSentRS232[index] = '\r'; 
0A7FC:  MOV     #982,W4
0A7FE:  MOV     1B34,W3
0A800:  ADD     W3,W4,W5
0A802:  MOV.B   #D,W0L
0A804:  MOV.B   W0L,[W5]
.................... 				 index++; 
0A806:  INC     1B34
0A808:  GOTO    A7F4
.................... 			} 
.................... 			index = 0; 
0A80C:  CLR     1B34
.................... 			index = 0; 
0A80E:  CLR     1B34
.................... 			while(index<10) // on recupere les donnees 
0A810:  MOV     1B34,W4
0A812:  CP      W4,#A
0A814:  BRA     C,A824
.................... 			{ 
.................... 				 __GetRoboteqPID(index); 
0A816:  MOV.B   1B34,W0L
0A818:  MOV.B   W0L,1B3E
0A81A:  CALL    A1C0
.................... 				 index++; 
0A81E:  INC     1B34
0A820:  GOTO    A810
0A824:  PUSH    42
0A826:  BCLR.B  81.7
0A828:  SETM.B  42
0A82A:  BSET.B  81.7
.................... 			} 
.................... 			__SendBackUART(); // on envoie a la plaque 
0A82C:  CALL    640
0A830:  BCLR.B  81.7
0A832:  POP     42
0A834:  BSET.B  81.7
.................... 			index = 0; 
0A836:  CLR     1B34
.................... 			break; 
0A838:  GOTO    A940
.................... 		case 24 : 
.................... 			__SetRoboteqPID(*(_Tab+2),*(_Tab+3),*(_Tab+4),*(_Tab+5),*(_Tab+6),*(_Tab+7),*(_Tab+8),*(_Tab+9),*(_Tab+10),*(_Tab+11)); 
0A83C:  MOV     1B32,W4
0A83E:  ADD     W4,#8,W0
0A840:  MOV     #A,W4
0A842:  MOV     [W0++],[W4++]
0A844:  MOV     [W0++],[W4++]
0A846:  MOV     1B32,W4
0A848:  ADD     W4,#C,W0
0A84A:  MOV     [W0],W7
0A84C:  MOV     1B32,W4
0A84E:  ADD     W4,#10,W0
0A850:  MOV     [W0],W8
0A852:  MOV     1B32,W4
0A854:  ADD     W4,#14,W0
0A856:  MOV     [W0],W9
0A858:  MOV     1B32,W4
0A85A:  ADD     W4,#18,W0
0A85C:  MOV     [W0],W10
0A85E:  MOV     1B32,W4
0A860:  ADD     W4,#1C,W0
0A862:  MOV     [W0],W11
0A864:  MOV     #20,W4
0A866:  MOV     1B32,W3
0A868:  ADD     W3,W4,W0
0A86A:  MOV     [W0],W12
0A86C:  MOV     #24,W4
0A86E:  MOV     1B32,W3
0A870:  ADD     W3,W4,W0
0A872:  MOV     [W0],W13
0A874:  MOV     #28,W4
0A876:  MOV     1B32,W3
0A878:  ADD     W3,W4,W0
0A87A:  MOV     [W0],[W15++]
0A87C:  POP     1B3E
0A87E:  MOV     #2C,W4
0A880:  MOV     1B32,W3
0A882:  ADD     W3,W4,W0
0A884:  MOV     [W0],[W15++]
0A886:  POP     1B40
0A888:  PUSH    1B54
0A88A:  MOV.B   W5L,[W15-#2]
0A88C:  POP     1B54
0A88E:  MOV     W7,1B56
0A890:  MOV     W8,1B58
0A892:  MOV     W9,1B5A
0A894:  MOV     W10,1B5C
0A896:  MOV     W11,1B5E
0A898:  MOV     W12,1B60
0A89A:  MOV     W13,1B62
0A89C:  PUSH    1B3E
0A89E:  POP     1B64
0A8A0:  PUSH    1B40
0A8A2:  POP     1B66
0A8A4:  CALL    A3BC
.................... 			__reset_Roboteq(); 
0A8A8:  CALL    A588
.................... 			break; 
0A8AC:  GOTO    A940
.................... 		 
.................... 		//erase eeprom 
.................... 		case 25 : 
.................... 			__resetEEPROM(); 
0A8B0:  CALL    A5AC
.................... 			reset_cpu();     
0A8B4:  RESET   
.................... 			break;		 
0A8B6:  GOTO    A940
.................... 		 
.................... 			break; 
0A8BA:  GOTO    A940
.................... 		// Ouvre ou ferme l'étau 
.................... 		case 30 : 
.................... 			break; 
0A8BE:  GOTO    A940
.................... 		// Position hold ou release du servo 
.................... 		case 31 : 
.................... 			break;			 
0A8C2:  GOTO    A940
.................... 		case 19 : 
.................... 			for(Adresse = Memorise ; Adresse <= 16 + Memorise ; Adresse += 2) 
0A8C6:  PUSH    1B24
0A8C8:  POP     1B3C
0A8CA:  MOV     #10,W0
0A8CC:  ADD     1B24,W0
0A8CE:  MOV     1B3C,W4
0A8D0:  CP      W4,W0
0A8D2:  BRA     GT,A914
.................... 			{ 
.................... 				write_eeprom(Adresse + 200 , *( _Tab +((Adresse - Memorise)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0A8D4:  MOV     #C8,W4
0A8D6:  MOV     1B3C,W3
0A8D8:  ADD     W3,W4,W5
0A8DA:  MOV     1B3C,W4
0A8DC:  MOV     1B24,W3
0A8DE:  SUB     W4,W3,W6
0A8E0:  MOV     W6,W4
0A8E2:  MOV     #2,W3
0A8E4:  REPEAT  #11
0A8E6:  DIV.S   W4,W3
0A8E8:  MOV     W0,W6
0A8EA:  MOV     W6,W4
0A8EC:  MUL.UU  W4,#4,W0
0A8EE:  MOV     1B32,W4
0A8F0:  ADD     W0,W4,W6
0A8F2:  ADD     W6,#C,W0
0A8F4:  MOV     #C,W4
0A8F6:  MOV     [W0++],[W4++]
0A8F8:  MOV     [W0++],[W4++]
0A8FA:  MOV     W5,W0
0A8FC:  MOV     #C,W1
0A8FE:  MOV     #2,W2
0A900:  CALL    A186
.................... 				delay_ms(5); 
0A904:  MOV     #5,W0
0A906:  CALL    F0E
0A90A:  MOV     1B3C,W4
0A90C:  ADD     W4,#2,W0
0A90E:  MOV     W0,1B3C
0A910:  GOTO    A8CA
.................... 			} 
.................... 			Memorise = Adresse; //offset afin d'aler écrie plus loin dans l'eeprom 
0A914:  PUSH    1B3C
0A916:  POP     1B24
.................... 			__ReadZones_Interdites();		 
0A918:  CALL    A5D4
.................... 			break; 
0A91C:  GOTO    A940
.................... 		// Ne lit plus les objectifs en ROM avant une nouvelle écriture	 
.................... 		case 50 :			 
.................... 			break;	 
0A920:  GOTO    A940
.................... 			 
.................... 			// Avertit le PC d'une action inconnue 
.................... 		default : 
.................... 			fprintf(RS232,"Carte Principale : Commande Inconnue\r"); 
0A924:  MOV     #0,W1
0A926:  MOV     W1,W0
0A928:  CLR.B   1
0A92A:  CALL    444
0A92E:  INC     W1,W1
0A930:  BTSC.B  20F.1
0A932:  BRA     A930
0A934:  MOV     W0,210
0A936:  MOV     #24,W0
0A938:  CPSGT   W1,W0
0A93A:  BRA     A926
.................... 			break; 
0A93C:  GOTO    A940
.................... 	} 
.................... 	 
.................... 	// Permet de recevoir à nouveau 
.................... 	PCh_flagUARTReadyToDecode = 0; 
0A940:  BCLR.B  1617.2
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
0A942:  MOV     #1A,W5
0A944:  REPEAT  #7
0A946:  MOV     [--W15],[W5--]
0A948:  MOV     [--W15],W5
0A94A:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __SendBackUART(void) 
.................... * \brief Envoi des commandes en UART 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.01.2016 
.................... * 
.................... * \return Ne retourne rien 
....................  
.................... */ 
.................... void __SendBackUART(void) 
*
00640:  MOV     W5,[W15++]
00642:  MOV     #982,W4
00644:  MOV     W4,1C78
00646:  CLR.B   1C76
.................... { 
.................... 	char* ptrBuffy = TabSentRS232; 
.................... 	// Envoi commande 
.................... 	unsigned int8 ToEndSend=0; 
.................... 	while(*(ptrBuffy+ToEndSend)!='\r' && *(ptrBuffy+ToEndSend)!=ETX) // Attend de voir la fin de tableau 
00648:  MOV     1C76,W4
0064A:  CLR.B   9
0064C:  MOV     1C78,W3
0064E:  ADD     W3,W4,W0
00650:  MOV.B   [W0],W4L
00652:  CP.B    W4L,#D
00654:  BRA     Z,67E
00656:  MOV     1C76,W4
00658:  CLR.B   9
0065A:  MOV     1C78,W3
0065C:  ADD     W3,W4,W0
0065E:  MOV.B   [W0],W4L
00660:  CP.B    W4L,#3
00662:  BRA     Z,67E
.................... 	{ 
.................... 		fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi la commande 
00664:  MOV     1C76,W4
00666:  CLR.B   9
00668:  MOV     1C78,W3
0066A:  ADD     W3,W4,W0
0066C:  MOV.B   [W0],W5L
0066E:  MOV.B   W5L,W0L
00670:  BTSC.B  20F.1
00672:  BRA     670
00674:  MOV.B   W0L,210
00676:  CLR.B   211
.................... 		ToEndSend++; 
00678:  INC.B   1C76
0067A:  GOTO    648
.................... 	}	 
.................... 	fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi le caractère de fin de commande 
0067E:  MOV     1C76,W4
00680:  CLR.B   9
00682:  MOV     1C78,W3
00684:  ADD     W3,W4,W0
00686:  MOV.B   [W0],W5L
00688:  MOV.B   W5L,W0L
0068A:  BTSC.B  20F.1
0068C:  BRA     68A
0068E:  MOV.B   W0L,210
00690:  CLR.B   211
.................... 	TabSentRS232[ToEndSend]=*(ptrBuffy+ToEndSend); 
00692:  MOV     1C76,W4
00694:  CLR.B   9
00696:  MOV     #982,W3
00698:  ADD     W4,W3,W5
0069A:  MOV     1C76,W4
0069C:  CLR.B   9
0069E:  MOV     1C78,W3
006A0:  ADD     W3,W4,W0
006A2:  MOV.B   [W0],[W5]
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
006A4:  MOV     [--W15],W5
006A6:  RETURN  
.................... }	 
....................  
.................... // Décode un tableau 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec) 
*
008DE:  MOV     W5,[W15++]
008E0:  MOV.B   #1,W0L
008E2:  MOV.B   W0L,1C7A
008E4:  CLR.B   1C7B
008E6:  CLR.B   1C7C
.................... { 
.................... 	// Permet de se balader dans le tableau 
.................... 	unsigned int8 i=1,j=0,ki=0; 
.................... 	char TempTab[11]={0}; // Taille max d'un int32 + NULL 
008E8:  CLR     1C7E
008EA:  CLR     1C80
008EC:  CLR     1C82
008EE:  CLR     1C84
008F0:  CLR     1C86
008F2:  CLR.B   1C88
.................... 	// On décode tout 
.................... 	while(_TabToDec[i]!=ETX) 
008F4:  MOV     1C7A,W4
008F6:  CLR.B   9
008F8:  MOV     W4,W0
008FA:  ADD     1C76,W0
008FC:  MOV.B   [W0],W4L
008FE:  CP.B    W4L,#3
00900:  BRA     Z,956
.................... 	{ 
.................... 		// On cherche la fin d'un nombre 
.................... 		while(_TabToDec[i]!=SPACE) 
00902:  MOV     1C7A,W4
00904:  CLR.B   9
00906:  MOV     W4,W0
00908:  ADD     1C76,W0
0090A:  MOV.B   [W0],W4L
0090C:  XOR.B   #20,W4L
0090E:  BRA     Z,92A
.................... 		{ 
.................... 			TempTab[j]=(char)(_TabToDec[i]); 
00910:  MOV     1C7A,W4
00912:  LSR     W4,#8,W4
00914:  MOV     #1C7E,W3
00916:  ADD     W4,W3,W5
00918:  MOV     1C7A,W4
0091A:  CLR.B   9
0091C:  MOV     W4,W0
0091E:  ADD     1C76,W0
00920:  MOV.B   [W0],[W5]
.................... 			i++;j++; 
00922:  INC.B   1C7A
00924:  INC.B   1C7B
00926:  GOTO    902
.................... 		}	 
.................... 		TempTab[j]=NUL; 
0092A:  MOV     1C7A,W4
0092C:  LSR     W4,#8,W4
0092E:  MOV     #1C7E,W3
00930:  ADD     W4,W3,W5
00932:  CLR.B   [W5]
.................... 		i++;j=0; 
00934:  INC.B   1C7A
00936:  CLR.B   1C7B
.................... 		// On enregistre le nombres 
.................... 		_TabDec[ki]=(unsigned int32)atoi32(TempTab); 
00938:  MOV.B   1C7C,W0L
0093A:  CLR.B   1
0093C:  SL      W0,#2,W0
0093E:  MOV     1C78,W4
00940:  ADD     W0,W4,W5
00942:  MOV     #1C7E,W4
00944:  MOV     W4,1C8A
00946:  CALL    6EA
0094A:  MOV     #0,W4
0094C:  MOV     [W4++],[W5++]
0094E:  MOV     [W4++],[W5++]
.................... 		ki++; 
00950:  INC.B   1C7C
00952:  GOTO    8F4
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
00956:  MOV     [--W15],W5
00958:  RETURN  
.................... }	 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_h 
.................... #define ___Zones_interdites_h 
....................  
....................  
....................  
.................... enum{x1, y1, x4, y4}; 
....................  
.................... int x3 = 0; 
.................... int y3 = 3; 
.................... int x2 = 2; 
.................... int y2 = 1; 
....................  
.................... int checkPath(); 
....................  
.................... void findPath(); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... double getDist(double x1, double y1, double x2, double y2); 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y); 
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int xStart, int yStart, int xEnd, int yEnd, int i_zone); 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.c" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_c 
.................... #define ___Zones_interdites_c 
....................  
....................  
.................... int checkPath() 
.................... { 
.................... 	path_found = 0; 
*
02174:  CLR     A84
.................... 		 
....................     start_point.X = Pos_x; 
02176:  MOV     1586,W0
02178:  CLR     W3
0217A:  BTSC    W0.F
0217C:  SETM    W3
0217E:  MOV     W3,W1
02180:  MOV     W3,W2
02182:  CALL    1B2C
02186:  MOV     W0,B40
02188:  MOV     W1,B42
0218A:  MOV     W2,B44
0218C:  MOV     W3,B46
....................     start_point.Y = Pos_y; 
0218E:  MOV     1588,W0
02190:  CLR     W3
02192:  BTSC    W0.F
02194:  SETM    W3
02196:  MOV     W3,W1
02198:  MOV     W3,W2
0219A:  CALL    1B2C
0219E:  MOV     W0,B48
021A0:  MOV     W1,B4A
021A2:  MOV     W2,B4C
021A4:  MOV     W3,B4E
....................  
....................     end_point.X = oXp; 
021A6:  MOV     1492,W0
021A8:  CLR     W3
021AA:  BTSC    W0.F
021AC:  SETM    W3
021AE:  MOV     W3,W1
021B0:  MOV     W3,W2
021B2:  CALL    1B2C
021B6:  MOV     W0,B50
021B8:  MOV     W1,B52
021BA:  MOV     W2,B54
021BC:  MOV     W3,B56
....................     end_point.Y = oYp; 
021BE:  MOV     1494,W0
021C0:  CLR     W3
021C2:  BTSC    W0.F
021C4:  SETM    W3
021C6:  MOV     W3,W1
021C8:  MOV     W3,W2
021CA:  CALL    1B2C
021CE:  MOV     W0,B58
021D0:  MOV     W1,B5A
021D2:  MOV     W2,B5C
021D4:  MOV     W3,B5E
....................  
....................     checkIntersection(start_point.X, start_point.Y, end_point.X, end_point.Y); 
021D6:  PUSH    B40
021D8:  POP     1B46
021DA:  PUSH    B42
021DC:  POP     1B48
021DE:  PUSH    B44
021E0:  POP     1B4A
021E2:  PUSH    B46
021E4:  POP     1B4C
021E6:  PUSH    B48
021E8:  POP     1B4E
021EA:  PUSH    B4A
021EC:  POP     1B50
021EE:  PUSH    B4C
021F0:  POP     1B52
021F2:  PUSH    B4E
021F4:  POP     1B54
021F6:  PUSH    B50
021F8:  POP     1B56
021FA:  PUSH    B52
021FC:  POP     1B58
021FE:  PUSH    B54
02200:  POP     1B5A
02202:  PUSH    B56
02204:  POP     1B5C
02206:  PUSH    B58
02208:  POP     1B5E
0220A:  PUSH    B5A
0220C:  POP     1B60
0220E:  PUSH    B5C
02210:  POP     1B62
02212:  PUSH    B5E
02214:  POP     1B64
02216:  CALL    1EB2
.................... 		 
.................... 	if (intersection_found > 0) 
0221A:  MOV     A82,W4
0221C:  CP      W4,#0
0221E:  BRA     LE,2226
.................... 	{ 
.................... 			path_found = 0; 
02220:  CLR     A84
.................... 	} 
02222:  GOTO    222A
.................... 	else 
.................... 	{ 
.................... 			path_found = 1; 
02226:  MOV     #1,W4
02228:  MOV     W4,A84
.................... 	} 
....................  
.................... 	return path_found; 
0222A:  PUSH    A84
0222C:  POP     0
0222E:  RETURN  
....................    
.................... } 
....................  
.................... void findPath() 
*
066C2:  MOV     W5,[W15++]
066C4:  MOV     #C,W5
066C6:  REPEAT  #7
066C8:  MOV     [W5++],[W15++]
.................... { 
....................     i_rel = 0; 
066CA:  CLR     A88
....................  
....................     //On trouve le premier point relai 
....................     findRel(start_point.X, start_point.Y, end_point.X, end_point.Y, 0); 
066CC:  MOV     B40,W0
066CE:  MOV     B42,W1
066D0:  MOV     B44,W2
066D2:  MOV     B46,W3
066D4:  CALL    2230
066D8:  MOV     W0,W5
066DA:  MOV     B48,W0
066DC:  MOV     B4A,W1
066DE:  MOV     B4C,W2
066E0:  MOV     B4E,W3
066E2:  CALL    2230
066E6:  MOV     W0,W6
066E8:  MOV     B50,W0
066EA:  MOV     B52,W1
066EC:  MOV     B54,W2
066EE:  MOV     B56,W3
066F0:  CALL    2230
066F4:  MOV     W0,W7
066F6:  MOV     B58,W0
066F8:  MOV     B5A,W1
066FA:  MOV     B5C,W2
066FC:  MOV     B5E,W3
066FE:  CALL    2230
06702:  MOV     W0,W8
06704:  MOV     W5,1B3E
06706:  MOV     W6,1B40
06708:  MOV     W7,1B42
0670A:  MOV     W8,1B44
0670C:  CLR     1B46
0670E:  CALL    33F0
....................  
....................     //On vÃ©rifie si depuis le premier point relai on intercepte encore une zone 
....................     checkIntersection(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end_point.X, end_point.Y); 
06712:  MOV     A88,W4
06714:  SUB     W4,#1,W5
06716:  MOV     W5,W4
06718:  MUL.UU  W4,#10,W0
0671A:  MOV     W0,W5
0671C:  MOV     #AA0,W4
0671E:  ADD     W5,W4,W0
06720:  MOV     #C,W4
06722:  REPEAT  #3
06724:  MOV     [W0++],[W4++]
06726:  MOV     A88,W4
06728:  SUB     W4,#1,W10
0672A:  MOV     W10,W4
0672C:  MUL.UU  W4,#10,W10
0672E:  ADD     W10,#8,W0
06730:  MOV     #AA0,W4
06732:  ADD     W0,W4,W0
06734:  MOV     #14,W4
06736:  REPEAT  #3
06738:  MOV     [W0++],[W4++]
0673A:  MOV     W6,1B46
0673C:  MOV     W7,1B48
0673E:  MOV     W8,1B4A
06740:  MOV     W9,1B4C
06742:  MOV     W10,1B4E
06744:  MOV     W11,1B50
06746:  MOV     W12,1B52
06748:  MOV     W13,1B54
0674A:  PUSH    B50
0674C:  POP     1B56
0674E:  PUSH    B52
06750:  POP     1B58
06752:  PUSH    B54
06754:  POP     1B5A
06756:  PUSH    B56
06758:  POP     1B5C
0675A:  PUSH    B58
0675C:  POP     1B5E
0675E:  PUSH    B5A
06760:  POP     1B60
06762:  PUSH    B5C
06764:  POP     1B62
06766:  PUSH    B5E
06768:  POP     1B64
0676A:  CALL    1EB2
....................  
....................     if(path_found < 1) 
0676E:  MOV     A84,W4
06770:  CP      W4,#1
06772:  BRA     GE,6842
....................     { 
....................     	int i = 0; 
06774:  CLR     1B32
.................... 	    //Si on intecepte encore une zone alors intersection_found sera >1 
.................... 	    while(intersection_found > 0) 
06776:  MOV     A82,W4
06778:  CP      W4,#0
0677A:  BRA     LE,6842
.................... 	    { 
.................... 	        //Tant qu'on intercepte une zone depuis le point relai on continue Ã  en chercher un autre 
.................... 	        i++; 
0677C:  INC     1B32
.................... 	        findRel(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end_point.X, end_point.Y, 0); 
0677E:  MOV     A88,W4
06780:  SUB     W4,#1,W5
06782:  MOV     W5,W4
06784:  MUL.UU  W4,#10,W0
06786:  MOV     W0,W5
06788:  MOV     #AA0,W4
0678A:  ADD     W5,W4,W0
0678C:  MOV     W0,W4
0678E:  MOV     #0,W3
06790:  REPEAT  #3
06792:  MOV     [W4++],[W3++]
06794:  CALL    2230
06798:  MOV     W0,W6
0679A:  MOV     A88,W4
0679C:  SUB     W4,#1,W7
0679E:  MOV     W7,W4
067A0:  MUL.UU  W4,#10,W0
067A2:  MOV     W0,W7
067A4:  ADD     W7,#8,W0
067A6:  MOV     #AA0,W4
067A8:  ADD     W0,W4,W0
067AA:  MOV     W0,W4
067AC:  MOV     #0,W3
067AE:  REPEAT  #3
067B0:  MOV     [W4++],[W3++]
067B2:  CALL    2230
067B6:  MOV     W0,W7
067B8:  MOV     B50,W0
067BA:  MOV     B52,W1
067BC:  MOV     B54,W2
067BE:  MOV     B56,W3
067C0:  CALL    2230
067C4:  MOV     W0,W8
067C6:  MOV     B58,W0
067C8:  MOV     B5A,W1
067CA:  MOV     B5C,W2
067CC:  MOV     B5E,W3
067CE:  CALL    2230
067D2:  MOV     W0,W9
067D4:  MOV     W6,1B3E
067D6:  MOV     W7,1B40
067D8:  MOV     W8,1B42
067DA:  MOV     W9,1B44
067DC:  CLR     1B46
067DE:  CALL    33F0
.................... 	        checkIntersection(PtsRelai[i_rel - 1].X, PtsRelai[i_rel - 1].Y, end_point.X, end_point.Y); 
067E2:  MOV     A88,W4
067E4:  SUB     W4,#1,W5
067E6:  MOV     W5,W4
067E8:  MUL.UU  W4,#10,W0
067EA:  MOV     W0,W5
067EC:  MOV     #AA0,W4
067EE:  ADD     W5,W4,W0
067F0:  MOV     #C,W4
067F2:  REPEAT  #3
067F4:  MOV     [W0++],[W4++]
067F6:  MOV     A88,W4
067F8:  SUB     W4,#1,W10
067FA:  MOV     W10,W4
067FC:  MUL.UU  W4,#10,W10
067FE:  ADD     W10,#8,W0
06800:  MOV     #AA0,W4
06802:  ADD     W0,W4,W0
06804:  MOV     #14,W4
06806:  REPEAT  #3
06808:  MOV     [W0++],[W4++]
0680A:  MOV     W6,1B46
0680C:  MOV     W7,1B48
0680E:  MOV     W8,1B4A
06810:  MOV     W9,1B4C
06812:  MOV     W10,1B4E
06814:  MOV     W11,1B50
06816:  MOV     W12,1B52
06818:  MOV     W13,1B54
0681A:  PUSH    B50
0681C:  POP     1B56
0681E:  PUSH    B52
06820:  POP     1B58
06822:  PUSH    B54
06824:  POP     1B5A
06826:  PUSH    B56
06828:  POP     1B5C
0682A:  PUSH    B58
0682C:  POP     1B5E
0682E:  PUSH    B5A
06830:  POP     1B60
06832:  PUSH    B5C
06834:  POP     1B62
06836:  PUSH    B5E
06838:  POP     1B64
0683A:  CALL    1EB2
0683E:  GOTO    6776
.................... 	    } 
....................     } 
06842:  MOV     #1A,W5
06844:  REPEAT  #7
06846:  MOV     [--W15],[W5--]
06848:  MOV     [--W15],W5
0684A:  RETURN  
....................      
....................  
....................  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getDist 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... double getDist(double x1, double y1, double x2, double y2) 
*
0332C:  MOV     W5,[W15++]
0332E:  MOV     #C,W5
03330:  REPEAT  #6
03332:  MOV     [W5++],[W15++]
.................... { 
....................     return (sqrt(pow((x2-x1),2)) + (pow((y2-y1),2))); 
03334:  BSET.B  43.0
03336:  MOV     1B92,W0
03338:  MOV     1B94,W1
0333A:  MOV     1B96,W2
0333C:  MOV     1B98,W3
0333E:  MOV     1B82,W4
03340:  MOV     1B84,W5
03342:  MOV     1B86,W6
03344:  MOV     1B88,W7
03346:  CALL    1C40
0334A:  MOV     W0,W5
0334C:  MOV     W1,W6
0334E:  MOV     W2,W7
03350:  MOV     W3,W8
03352:  MOV     W5,1BB2
03354:  MOV     W6,1BB4
03356:  MOV     W7,1BB6
03358:  MOV     W8,1BB8
0335A:  CLR     1BBA
0335C:  CLR     1BBC
0335E:  CLR     1BBE
03360:  MOV     #4000,W4
03362:  MOV     W4,1BC0
03364:  CALL    2FAC
03368:  MOV     W0,W5
0336A:  MOV     W1,W6
0336C:  MOV     W2,W7
0336E:  MOV     W3,W8
03370:  MOV     W5,1BCA
03372:  MOV     W6,1BCC
03374:  MOV     W7,1BCE
03376:  MOV     W8,1BD0
03378:  CALL    3210
0337C:  MOV     W0,W5
0337E:  MOV     W1,W6
03380:  MOV     W2,W7
03382:  MOV     W3,W8
03384:  BSET.B  43.0
03386:  MOV     W5,[W15++]
03388:  MOV     W6,[W15++]
0338A:  MOV     W7,[W15++]
0338C:  MOV     1B9A,W0
0338E:  MOV     1B9C,W1
03390:  MOV     1B9E,W2
03392:  MOV     1BA0,W3
03394:  MOV     1B8A,W4
03396:  MOV     1B8C,W5
03398:  MOV     1B8E,W6
0339A:  MOV     1B90,W7
0339C:  CALL    1C40
033A0:  MOV     [--W15],W7
033A2:  MOV     [--W15],W6
033A4:  MOV     [--W15],W5
033A6:  MOV     W0,W9
033A8:  MOV     W1,W10
033AA:  MOV     W2,W11
033AC:  MOV     W3,W12
033AE:  MOV     W9,1BB2
033B0:  MOV     W10,1BB4
033B2:  MOV     W11,1BB6
033B4:  MOV     W12,1BB8
033B6:  CLR     1BBA
033B8:  CLR     1BBC
033BA:  CLR     1BBE
033BC:  MOV     #4000,W4
033BE:  MOV     W4,1BC0
033C0:  CALL    2FAC
033C4:  BCLR.B  43.0
033C6:  MOV     W5,[W15++]
033C8:  MOV     W6,[W15++]
033CA:  MOV     W7,[W15++]
033CC:  MOV     W0,W4
033CE:  MOV     W5,W0
033D0:  MOV     W1,W5
033D2:  MOV     W6,W1
033D4:  MOV     W2,W6
033D6:  MOV     W7,W2
033D8:  MOV     W3,W7
033DA:  MOV     W8,W3
033DC:  CALL    1C40
033E0:  MOV     [--W15],W7
033E2:  MOV     [--W15],W6
033E4:  MOV     [--W15],W5
033E6:  MOV     #18,W5
033E8:  REPEAT  #6
033EA:  MOV     [--W15],[W5--]
033EC:  MOV     [--W15],W5
033EE:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y) 
*
01EB2:  MOV     W5,[W15++]
01EB4:  MOV     #C,W5
01EB6:  REPEAT  #4
01EB8:  MOV     [W5++],[W15++]
01EBA:  CLR     1B76
.................... { 
.................... 	struct Coord spot; 
....................  
....................     int zoneToCheck = 0; 
....................  
....................     intersection_found = 0; 
01EBC:  CLR     A82
....................  
....................     int j; 
....................     for ( j= 0; j < 10; j++) 
01EBE:  CLR     1B78
01EC0:  MOV     1B78,W4
01EC2:  CP      W4,#A
01EC4:  BRA     GE,1EDA
....................     { 
....................         TabIntersection[j] = 0; 
01EC6:  MOV     1B78,W4
01EC8:  MUL.UU  W4,#2,W0
01ECA:  MOV     #A8C,W4
01ECC:  ADD     W0,W4,W5
01ECE:  CLR.B   [W5]
01ED0:  MOV.B   #0,W0L
01ED2:  MOV.B   W0L,[W5+#1]
01ED4:  INC     1B78
01ED6:  GOTO    1EC0
....................     } 
....................      
....................  
....................     double dX = pt2X-pt1X; 
....................     double dY = pt2Y-pt1Y; 
....................  
....................     int i = 0; 
01EDA:  BSET.B  43.0
01EDC:  MOV     1B56,W0
01EDE:  MOV     1B58,W1
01EE0:  MOV     1B5A,W2
01EE2:  MOV     1B5C,W3
01EE4:  MOV     1B46,W4
01EE6:  MOV     1B48,W5
01EE8:  MOV     1B4A,W6
01EEA:  MOV     1B4C,W7
01EEC:  CALL    1C40
01EF0:  MOV     W0,1B7A
01EF2:  MOV     W1,1B7C
01EF4:  MOV     W2,1B7E
01EF6:  MOV     W3,1B80
01EF8:  BSET.B  43.0
01EFA:  MOV     1B5E,W0
01EFC:  MOV     1B60,W1
01EFE:  MOV     1B62,W2
01F00:  MOV     1B64,W3
01F02:  MOV     1B4E,W4
01F04:  MOV     1B50,W5
01F06:  MOV     1B52,W6
01F08:  MOV     1B54,W7
01F0A:  CALL    1C40
01F0E:  MOV     W0,1B82
01F10:  MOV     W1,1B84
01F12:  MOV     W2,1B86
01F14:  MOV     W3,1B88
01F16:  CLR     1B8A
....................  
....................     do 
....................     { 
....................         i++; 
01F18:  INC     1B8A
....................  
....................         //On calcule des points le long du trajet 
....................         spot.X = (dX*i)/100; 
01F1A:  MOV     1B8A,W0
01F1C:  CLR     W3
01F1E:  BTSC    W0.F
01F20:  SETM    W3
01F22:  MOV     W3,W1
01F24:  MOV     W3,W2
01F26:  CALL    1B2C
01F2A:  MOV     W0,W4
01F2C:  MOV     W1,W5
01F2E:  MOV     W2,W6
01F30:  MOV     W3,W7
01F32:  MOV     1B7A,W0
01F34:  MOV     1B7C,W1
01F36:  MOV     1B7E,W2
01F38:  MOV     1B80,W3
01F3A:  CALL    C4A
01F3E:  MOV     W0,W5
01F40:  MOV     W1,W6
01F42:  MOV     W2,W7
01F44:  MOV     W3,W8
01F46:  MOV     W5,[W15++]
01F48:  MOV     W6,[W15++]
01F4A:  MOV     W7,[W15++]
01F4C:  MOV     W5,W0
01F4E:  MOV     W6,W1
01F50:  MOV     W7,W2
01F52:  MOV     W8,W3
01F54:  MOV     #0,W4
01F56:  MOV     #0,W5
01F58:  MOV     #0,W6
01F5A:  MOV     #4059,W7
01F5C:  CALL    D5A
01F60:  MOV     [--W15],W7
01F62:  MOV     [--W15],W6
01F64:  MOV     [--W15],W5
01F66:  MOV     W0,1B66
01F68:  MOV     W1,1B68
01F6A:  MOV     W2,1B6A
01F6C:  MOV     W3,1B6C
....................         spot.Y = (dY*i)/100; 
01F6E:  MOV     1B8A,W0
01F70:  CLR     W3
01F72:  BTSC    W0.F
01F74:  SETM    W3
01F76:  MOV     W3,W1
01F78:  MOV     W3,W2
01F7A:  CALL    1B2C
01F7E:  MOV     W0,W4
01F80:  MOV     W1,W5
01F82:  MOV     W2,W6
01F84:  MOV     W3,W7
01F86:  MOV     1B82,W0
01F88:  MOV     1B84,W1
01F8A:  MOV     1B86,W2
01F8C:  MOV     1B88,W3
01F8E:  CALL    C4A
01F92:  MOV     W0,W5
01F94:  MOV     W1,W6
01F96:  MOV     W2,W7
01F98:  MOV     W3,W8
01F9A:  MOV     W5,[W15++]
01F9C:  MOV     W6,[W15++]
01F9E:  MOV     W7,[W15++]
01FA0:  MOV     W5,W0
01FA2:  MOV     W6,W1
01FA4:  MOV     W7,W2
01FA6:  MOV     W8,W3
01FA8:  MOV     #0,W4
01FAA:  MOV     #0,W5
01FAC:  MOV     #0,W6
01FAE:  MOV     #4059,W7
01FB0:  CALL    D5A
01FB4:  MOV     [--W15],W7
01FB6:  MOV     [--W15],W6
01FB8:  MOV     [--W15],W5
01FBA:  MOV     W0,1B6E
01FBC:  MOV     W1,1B70
01FBE:  MOV     W2,1B72
01FC0:  MOV     W3,1B74
....................  
....................  
....................         //Pour chaque point du trajet on vÃ©rifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < 10; zoneToCheck++) 
01FC2:  CLR     1B76
01FC4:  MOV     1B76,W4
01FC6:  CP      W4,#A
01FC8:  BRA     GE,214E
....................         { 
....................             //On vÃ©rifie si le point se trouve dans la zone interdite 
.................... 	        if ((spot.X+pt1X) >= TabZones[zoneToCheck][0] && (spot.X+pt1X) <= TabZones[zoneToCheck][2]) 
01FCA:  BCLR.B  43.0
01FCC:  MOV     1B66,W0
01FCE:  MOV     1B68,W1
01FD0:  MOV     1B6A,W2
01FD2:  MOV     1B6C,W3
01FD4:  MOV     1B46,W4
01FD6:  MOV     1B48,W5
01FD8:  MOV     1B4A,W6
01FDA:  MOV     1B4C,W7
01FDC:  CALL    1C40
01FE0:  MOV     W0,W5
01FE2:  MOV     W1,W6
01FE4:  MOV     W2,W7
01FE6:  MOV     W3,W8
01FE8:  MOV     1B76,W4
01FEA:  MUL.UU  W4,#10,W0
01FEC:  MOV     W0,W9
01FEE:  MOV     #B60,W4
01FF0:  ADD     W9,W4,W0
01FF2:  MOV     W0,W4
01FF4:  MOV     #0,W3
01FF6:  MOV     [W4++],[W3++]
01FF8:  MOV     [W4++],[W3++]
01FFA:  MOV     #0,W2
01FFC:  MOV     #0,W3
01FFE:  CALL    1B2C
02002:  MOV     W5,[W15++]
02004:  MOV     W6,[W15++]
02006:  MOV     W7,[W15++]
02008:  MOV     W5,W4
0200A:  MOV     W6,W5
0200C:  MOV     W7,W6
0200E:  MOV     W8,W7
02010:  CALL    1E2E
02014:  MOV     [--W15],W7
02016:  MOV     [--W15],W6
02018:  MOV     [--W15],W5
0201A:  BRA     C,201E
0201C:  BRA     NZ,2148
0201E:  BCLR.B  43.0
02020:  MOV     W5,[W15++]
02022:  MOV     W6,[W15++]
02024:  MOV     W7,[W15++]
02026:  MOV     1B66,W0
02028:  MOV     1B68,W1
0202A:  MOV     1B6A,W2
0202C:  MOV     1B6C,W3
0202E:  MOV     1B46,W4
02030:  MOV     1B48,W5
02032:  MOV     1B4A,W6
02034:  MOV     1B4C,W7
02036:  CALL    1C40
0203A:  MOV     [--W15],W7
0203C:  MOV     [--W15],W6
0203E:  MOV     [--W15],W5
02040:  MOV     W0,W5
02042:  MOV     W1,W6
02044:  MOV     W2,W7
02046:  MOV     W3,W8
02048:  MOV     1B76,W4
0204A:  MUL.UU  W4,#10,W10
0204C:  ADD     W10,#8,W0
0204E:  MOV     #B60,W4
02050:  ADD     W0,W4,W0
02052:  MOV     W0,W4
02054:  MOV     #0,W3
02056:  MOV     [W4++],[W3++]
02058:  MOV     [W4++],[W3++]
0205A:  MOV     #0,W2
0205C:  MOV     #0,W3
0205E:  CALL    1B2C
02062:  MOV     W5,[W15++]
02064:  MOV     W6,[W15++]
02066:  MOV     W7,[W15++]
02068:  MOV     W0,W4
0206A:  MOV     W5,W0
0206C:  MOV     W1,W5
0206E:  MOV     W6,W1
02070:  MOV     W2,W6
02072:  MOV     W7,W2
02074:  MOV     W3,W7
02076:  MOV     W8,W3
02078:  CALL    1E2E
0207C:  MOV     [--W15],W7
0207E:  MOV     [--W15],W6
02080:  MOV     [--W15],W5
02082:  BRA     C,2086
02084:  BRA     NZ,2148
.................... 	        { 
.................... 		        if ((spot.Y+pt1Y) >= TabZones[zoneToCheck][1] && (spot.Y+pt1Y) <= TabZones[zoneToCheck][3]) 
02086:  BCLR.B  43.0
02088:  MOV     1B6E,W0
0208A:  MOV     1B70,W1
0208C:  MOV     1B72,W2
0208E:  MOV     1B74,W3
02090:  MOV     1B4E,W4
02092:  MOV     1B50,W5
02094:  MOV     1B52,W6
02096:  MOV     1B54,W7
02098:  CALL    1C40
0209C:  MOV     W0,W5
0209E:  MOV     W1,W6
020A0:  MOV     W2,W7
020A2:  MOV     W3,W8
020A4:  MOV     1B76,W4
020A6:  MUL.UU  W4,#10,W0
020A8:  MOV     W0,W9
020AA:  ADD     W9,#4,W0
020AC:  MOV     #B60,W4
020AE:  ADD     W0,W4,W0
020B0:  MOV     W0,W4
020B2:  MOV     #0,W3
020B4:  MOV     [W4++],[W3++]
020B6:  MOV     [W4++],[W3++]
020B8:  MOV     #0,W2
020BA:  MOV     #0,W3
020BC:  CALL    1B2C
020C0:  MOV     W5,[W15++]
020C2:  MOV     W6,[W15++]
020C4:  MOV     W7,[W15++]
020C6:  MOV     W5,W4
020C8:  MOV     W6,W5
020CA:  MOV     W7,W6
020CC:  MOV     W8,W7
020CE:  CALL    1E2E
020D2:  MOV     [--W15],W7
020D4:  MOV     [--W15],W6
020D6:  MOV     [--W15],W5
020D8:  BRA     C,20DC
020DA:  BRA     NZ,2148
020DC:  BCLR.B  43.0
020DE:  MOV     1B6E,W0
020E0:  MOV     1B70,W1
020E2:  MOV     1B72,W2
020E4:  MOV     1B74,W3
020E6:  MOV     1B4E,W4
020E8:  MOV     1B50,W5
020EA:  MOV     1B52,W6
020EC:  MOV     1B54,W7
020EE:  CALL    1C40
020F2:  MOV     W0,W5
020F4:  MOV     W1,W6
020F6:  MOV     W2,W7
020F8:  MOV     W3,W8
020FA:  MOV     1B76,W4
020FC:  MUL.UU  W4,#10,W0
020FE:  MOV     W0,W9
02100:  ADD     W9,#C,W0
02102:  MOV     #B60,W4
02104:  ADD     W0,W4,W0
02106:  MOV     W0,W4
02108:  MOV     #0,W3
0210A:  MOV     [W4++],[W3++]
0210C:  MOV     [W4++],[W3++]
0210E:  MOV     #0,W2
02110:  MOV     #0,W3
02112:  CALL    1B2C
02116:  MOV     W5,[W15++]
02118:  MOV     W6,[W15++]
0211A:  MOV     W7,[W15++]
0211C:  MOV     W0,W4
0211E:  MOV     W5,W0
02120:  MOV     W1,W5
02122:  MOV     W6,W1
02124:  MOV     W2,W6
02126:  MOV     W7,W2
02128:  MOV     W3,W7
0212A:  MOV     W8,W3
0212C:  CALL    1E2E
02130:  MOV     [--W15],W7
02132:  MOV     [--W15],W6
02134:  MOV     [--W15],W5
02136:  BRA     C,213A
02138:  BRA     NZ,2148
.................... 		        { 
.................... 			        
....................                     TabIntersection[intersection_found] = zoneToCheck; 
0213A:  MOV     A82,W4
0213C:  MUL.UU  W4,#2,W0
0213E:  MOV     #A8C,W4
02140:  ADD     W0,W4,W5
02142:  MOV     1B76,W4
02144:  MOV     W4,[W5+#0]
....................                     intersection_found++; 
02146:  INC     0A82
.................... 			 
.................... 		        } 
.................... 			 
.................... 			 
.................... 	        } 
02148:  INC     1B76
0214A:  GOTO    1FC4
....................         } 
.................... 	 
....................     }while (i < 100 && intersection_found == 0); 
0214E:  MOV     1B8A,W4
02150:  MOV     #64,W3
02152:  CP      W3,W4
02154:  BRA     LE,215A
02156:  CP0     A82
02158:  BRA     Z,1F18
....................  
....................     if(intersection_found > 0) 
0215A:  MOV     A82,W4
0215C:  CP      W4,#0
0215E:  BRA     LE,2166
....................     { 
....................     	path_found = 0; 
02160:  CLR     A84
....................     } 
02162:  GOTO    216A
....................     else 
....................     { 
....................     	path_found = 1; 
02166:  MOV     #1,W4
02168:  MOV     W4,A84
....................     } 
0216A:  MOV     #14,W5
0216C:  REPEAT  #4
0216E:  MOV     [--W15],[W5--]
02170:  MOV     [--W15],W5
02172:  RETURN  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
*
0228E:  MOV     1B64,W0
02290:  MOV     1B5C,W4
02292:  CP      W4,W0
02294:  BRA     LE,22BE
....................     { 
....................         if (py > ry4) 
02296:  MOV     1B66,W0
02298:  MOV     1B5E,W4
0229A:  CP      W4,W0
0229C:  BRA     LE,22A6
....................         { 
....................             pos = 4; //Le point se trouve en bas Ã  droite de la zone 
0229E:  MOV     #4,W4
022A0:  MOV     W4,1B68
....................         } 
022A2:  GOTO    22BA
....................         else if (py > ry1) 
022A6:  MOV     1B62,W0
022A8:  MOV     1B5E,W4
022AA:  CP      W4,W0
022AC:  BRA     LE,22B6
....................         { 
....................             pos = 3; //Le point se trouve Ã  droite de la zone 
022AE:  MOV     #3,W4
022B0:  MOV     W4,1B68
....................         } 
022B2:  GOTO    22BA
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut Ã  droite de la zone 
022B6:  MOV     #2,W4
022B8:  MOV     W4,1B68
....................         } 
....................     } 
022BA:  GOTO    2310
....................     else if (px > rx1) 
022BE:  MOV     1B60,W0
022C0:  MOV     1B5C,W4
022C2:  CP      W4,W0
022C4:  BRA     LE,22EE
....................     { 
....................         if (py > ry4) 
022C6:  MOV     1B66,W0
022C8:  MOV     1B5E,W4
022CA:  CP      W4,W0
022CC:  BRA     LE,22D6
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
022CE:  MOV     #5,W4
022D0:  MOV     W4,1B68
....................         } 
022D2:  GOTO    22EA
....................         else if (py > ry1) 
022D6:  MOV     1B62,W0
022D8:  MOV     1B5E,W4
022DA:  CP      W4,W0
022DC:  BRA     LE,22E6
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
022DE:  MOV     #8,W4
022E0:  MOV     W4,1B68
....................         } 
022E2:  GOTO    22EA
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
022E6:  MOV     #1,W4
022E8:  MOV     W4,1B68
....................         } 
....................     } 
022EA:  GOTO    2310
....................     else 
....................     { 
....................         if (py > ry4) 
022EE:  MOV     1B66,W0
022F0:  MOV     1B5E,W4
022F2:  CP      W4,W0
022F4:  BRA     LE,22FE
....................         { 
....................             pos = 6; //Le point se trouve en bas Ã  gauche de la zone 
022F6:  MOV     #6,W4
022F8:  MOV     W4,1B68
....................         } 
022FA:  GOTO    2310
....................         else if (py > ry1) 
022FE:  MOV     1B62,W0
02300:  MOV     1B5E,W4
02302:  CP      W4,W0
02304:  BRA     LE,230E
....................         { 
....................             pos = 7; //Le point se trouve Ã  gauche de la zone 
02306:  MOV     #7,W4
02308:  MOV     W4,1B68
....................         } 
0230A:  GOTO    2310
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut Ã  gauche de la zone 
0230E:  CLR     1B68
....................         } 
....................     } 
....................  
....................     return pos; 
02310:  PUSH    1B68
02312:  POP     0
02314:  RETURN  
....................          
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int xStart, int yStart, int xEnd, int yEnd, int i_zone) 
*
033F0:  MOV     W5,[W15++]
033F2:  MOV     #C,W5
033F4:  REPEAT  #7
033F6:  MOV     [W5++],[W15++]
033F8:  MOV     1B46,W4
033FA:  MUL.UU  W4,#2,W0
033FC:  MOV     #A8C,W4
033FE:  ADD     W0,W4,W0
03400:  MOV     [W0],W5
03402:  MOV     W5,W4
03404:  MUL.UU  W4,#10,W0
03406:  MOV     W0,W5
03408:  MOV     #B60,W4
0340A:  ADD     W5,W4,W0
0340C:  MOV     [W0],W6
0340E:  MOV     1B46,W4
03410:  MUL.UU  W4,#2,W0
03412:  MOV     #A8C,W4
03414:  ADD     W0,W4,W0
03416:  MOV     [W0],W7
03418:  MOV     W7,W4
0341A:  MUL.UU  W4,#10,W0
0341C:  MOV     W0,W7
0341E:  ADD     W7,#4,W0
03420:  MOV     #B60,W4
03422:  ADD     W0,W4,W0
03424:  MOV     [W0],W7
03426:  MOV     1B46,W4
03428:  MUL.UU  W4,#2,W0
0342A:  MOV     #A8C,W4
0342C:  ADD     W0,W4,W0
0342E:  MOV     [W0],W8
03430:  MOV     W8,W4
03432:  MUL.UU  W4,#10,W8
03434:  ADD     W8,#8,W0
03436:  MOV     #B60,W4
03438:  ADD     W0,W4,W0
0343A:  MOV     [W0],W8
0343C:  MOV     1B46,W4
0343E:  MUL.UU  W4,#2,W0
03440:  MOV     #A8C,W4
03442:  ADD     W0,W4,W0
03444:  MOV     [W0],W9
03446:  MOV     W9,W4
03448:  MUL.UU  W4,#10,W0
0344A:  MOV     W0,W9
0344C:  ADD     W9,#C,W0
0344E:  MOV     #B60,W4
03450:  ADD     W0,W4,W0
03452:  MOV     [W0],W9
03454:  PUSH    1B3E
03456:  POP     1B5C
03458:  PUSH    1B40
0345A:  POP     1B5E
0345C:  MOV     W6,1B60
0345E:  MOV     W7,1B62
03460:  MOV     W8,1B64
03462:  MOV     W9,1B66
03464:  CALL    228E
03468:  MOV     W0,1B48
0346A:  MOV     1B46,W4
0346C:  MUL.UU  W4,#2,W0
0346E:  MOV     #A8C,W4
03470:  ADD     W0,W4,W0
03472:  MOV     [W0],W6
03474:  MOV     W6,W4
03476:  MUL.UU  W4,#10,W6
03478:  MOV     #B60,W4
0347A:  ADD     W6,W4,W0
0347C:  MOV     [W0],W7
0347E:  MOV     1B46,W4
03480:  MUL.UU  W4,#2,W0
03482:  MOV     #A8C,W4
03484:  ADD     W0,W4,W0
03486:  MOV     [W0],W8
03488:  MOV     W8,W4
0348A:  MUL.UU  W4,#10,W8
0348C:  ADD     W8,#4,W0
0348E:  MOV     #B60,W4
03490:  ADD     W0,W4,W0
03492:  MOV     [W0],W8
03494:  MOV     1B46,W4
03496:  MUL.UU  W4,#2,W0
03498:  MOV     #A8C,W4
0349A:  ADD     W0,W4,W0
0349C:  MOV     [W0],W9
0349E:  MOV     W9,W4
034A0:  MUL.UU  W4,#10,W0
034A2:  MOV     W0,W9
034A4:  ADD     W9,#8,W0
034A6:  MOV     #B60,W4
034A8:  ADD     W0,W4,W0
034AA:  MOV     [W0],W9
034AC:  MOV     1B46,W4
034AE:  MUL.UU  W4,#2,W0
034B0:  MOV     #A8C,W4
034B2:  ADD     W0,W4,W0
034B4:  MOV     [W0],W10
034B6:  MOV     W10,W4
034B8:  MUL.UU  W4,#10,W10
034BA:  ADD     W10,#C,W0
034BC:  MOV     #B60,W4
034BE:  ADD     W0,W4,W0
034C0:  MOV     [W0],W10
034C2:  PUSH    1B42
034C4:  POP     1B5C
034C6:  PUSH    1B44
034C8:  POP     1B5E
034CA:  MOV     W7,1B60
034CC:  MOV     W8,1B62
034CE:  MOV     W9,1B64
034D0:  MOV     W10,1B66
034D2:  CALL    228E
034D6:  MOV     W0,1B4A
034D8:  CLR     1B4C
.................... { 
.................... 	//On rÃ©cupÃ¨re la position des deux points par rapport Ã  la zone 
....................     int posStart = getPos(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................     int posEnd = getPos(xEnd, yEnd, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................  
....................     int relay_point_number = 0; 
....................  
....................     if(posStart == 8 || posEnd == 8) 
034DA:  MOV     1B48,W4
034DC:  CP      W4,#8
034DE:  BRA     Z,34E6
034E0:  MOV     1B4A,W4
034E2:  CP      W4,#8
034E4:  BRA     NZ,34EC
....................     { 
....................     	path_found = 0; 
034E6:  CLR     A84
....................     }	 
034E8:  GOTO    66B8
....................     else 
....................     { 
.................... 	    switch (posStart) 
034EC:  MOV     1B48,W0
034EE:  XOR     #0,W0
034F0:  BRA     Z,3514
034F2:  XOR     #1,W0
034F4:  BRA     Z,3AD0
034F6:  XOR     #3,W0
034F8:  BRA     Z,418A
034FA:  XOR     #1,W0
034FC:  BRA     Z,4726
034FE:  XOR     #7,W0
03500:  BRA     Z,4DDA
03502:  XOR     #1,W0
03504:  BRA     Z,539C
03506:  XOR     #3,W0
03508:  BRA     Z,5A50
0350A:  XOR     #1,W0
0350C:  BRA     Z,5FEC
0350E:  XOR     #F,W0
03510:  BRA     Z,66A6
03512:  BRA     66AC
.................... 	    { 
.................... 	        case 0: 
.................... 	            if (posEnd == 3) 
03514:  MOV     1B4A,W4
03516:  CP      W4,#3
03518:  BRA     NZ,359A
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0351A:  MOV     A88,W4
0351C:  MUL.UU  W4,#10,W0
0351E:  MOV     W0,W5
03520:  MOV     #AA0,W4
03522:  ADD     W5,W4,W6
03524:  MOV     1B46,W4
03526:  MUL.UU  W4,#2,W0
03528:  MOV     #A8C,W4
0352A:  ADD     W0,W4,W0
0352C:  MOV     [W0],W7
0352E:  MOV     W7,W4
03530:  MUL.UU  W4,#10,W0
03532:  MOV     W0,W7
03534:  MOV     1B2A,W4
03536:  MUL.UU  W4,#4,W0
03538:  ADD     W0,W7,W0
0353A:  MOV     #B60,W4
0353C:  ADD     W0,W4,W0
0353E:  MOV     W0,W4
03540:  MOV     #0,W3
03542:  MOV     [W4++],[W3++]
03544:  MOV     [W4++],[W3++]
03546:  MOV     #0,W2
03548:  MOV     #0,W3
0354A:  CALL    1B2C
0354E:  MOV     #0,W4
03550:  REPEAT  #3
03552:  MOV     [W4++],[W6++]
03554:  MOV     A88,W4
03556:  MUL.UU  W4,#10,W0
03558:  MOV     W0,W5
0355A:  ADD     W5,#8,W0
0355C:  MOV     #AA0,W4
0355E:  ADD     W0,W4,W5
03560:  MOV     1B46,W4
03562:  MUL.UU  W4,#2,W0
03564:  MOV     #A8C,W4
03566:  ADD     W0,W4,W0
03568:  MOV     [W0],W6
0356A:  MOV     W6,W4
0356C:  MUL.UU  W4,#10,W6
0356E:  MOV     1B2C,W4
03570:  MUL.UU  W4,#4,W0
03572:  ADD     W0,W6,W0
03574:  MOV     #B60,W4
03576:  ADD     W0,W4,W0
03578:  MOV     W0,W4
0357A:  MOV     #0,W3
0357C:  MOV     [W4++],[W3++]
0357E:  MOV     [W4++],[W3++]
03580:  MOV     #0,W2
03582:  MOV     #0,W3
03584:  CALL    1B2C
03588:  MOV     #0,W4
0358A:  REPEAT  #3
0358C:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0358E:  MOV     #1,W4
03590:  MOV     W4,1B4C
.................... 	                path_found = true; 
03592:  MOV     #1,W4
03594:  MOV     W4,A84
.................... 	            } 
03596:  GOTO    3ACC
.................... 	            else if (posEnd == 4) 
0359A:  MOV     1B4A,W4
0359C:  CP      W4,#4
0359E:  BRA     NZ,3A4A
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
035A0:  MOV     1B3E,W0
035A2:  CLR     W3
035A4:  BTSC    W0.F
035A6:  SETM    W3
035A8:  MOV     W3,W1
035AA:  MOV     W3,W2
035AC:  CALL    1B2C
035B0:  MOV     W0,W5
035B2:  MOV     W1,W6
035B4:  MOV     W2,W7
035B6:  MOV     W3,W8
035B8:  MOV     1B40,W0
035BA:  CLR     W3
035BC:  BTSC    W0.F
035BE:  SETM    W3
035C0:  MOV     W3,W1
035C2:  MOV     W3,W2
035C4:  CALL    1B2C
035C8:  MOV     W0,W9
035CA:  MOV     W1,W10
035CC:  MOV     W2,W11
035CE:  MOV     W3,W12
035D0:  MOV     1B46,W4
035D2:  MUL.UU  W4,#2,W0
035D4:  MOV     #A8C,W4
035D6:  ADD     W0,W4,W0
035D8:  MOV     [W0],W13
035DA:  MOV     W13,W4
035DC:  MUL.UU  W4,#10,W0
035DE:  MOV     W0,W13
035E0:  MOV     1B26,W4
035E2:  MUL.UU  W4,#4,W0
035E4:  ADD     W0,W13,W0
035E6:  MOV     #B60,W4
035E8:  ADD     W0,W4,W0
035EA:  MOV     W0,W4
035EC:  MOV     #0,W3
035EE:  MOV     [W4++],[W3++]
035F0:  MOV     [W4++],[W3++]
035F2:  MOV     #0,W2
035F4:  MOV     #0,W3
035F6:  CALL    1B2C
035FA:  MOV     W0,W13
035FC:  MOV     W1,W14
035FE:  MOV     W2,W15
03600:  MOV     W3,[W0]
03602:  MOV     1B46,W4
03604:  MUL.UU  W4,#2,W0
03606:  MOV     #A8C,W4
03608:  ADD     W0,W4,W0
0360A:  MOV     [W0],[W15++]
0360C:  POP     1B54
0360E:  MOV     1B54,W4
03610:  MUL.UU  W4,#10,W0
03612:  MOV     W0,1B54
03614:  MOV     1B28,W4
03616:  MUL.UU  W4,#4,W0
03618:  MOV     1B54,W4
0361A:  ADD     W0,W4,W0
0361C:  MOV     #B60,W4
0361E:  ADD     W0,W4,W0
03620:  MOV     W0,W4
03622:  MOV     #0,W3
03624:  MOV     [W4++],[W3++]
03626:  MOV     [W4++],[W3++]
03628:  MOV     #0,W2
0362A:  MOV     #0,W3
0362C:  CALL    1B2C
03630:  MOV     W0,1B54
03632:  MOV     W1,1B56
03634:  MOV     W2,1B58
03636:  MOV     W3,1B5A
03638:  MOV     W5,1B82
0363A:  MOV     W6,1B84
0363C:  MOV     W7,1B86
0363E:  MOV     W8,1B88
03640:  MOV     W9,1B8A
03642:  MOV     W10,1B8C
03644:  MOV     W11,1B8E
03646:  MOV     W12,1B90
03648:  MOV     W13,1B92
0364A:  MOV     W14,1B94
0364C:  MOV     W15,1B96
0364E:  MOV     [W0],[W15++]
03650:  POP     1B98
03652:  PUSH    1B54
03654:  POP     1B9A
03656:  PUSH    1B56
03658:  POP     1B9C
0365A:  PUSH    1B58
0365C:  POP     1B9E
0365E:  PUSH    1B5A
03660:  POP     1BA0
03662:  CALL    332C
03666:  MOV     W0,W5
03668:  MOV     W1,W6
0366A:  MOV     W2,W7
0366C:  MOV     W3,W8
0366E:  MOV     1B46,W4
03670:  MUL.UU  W4,#2,W0
03672:  MOV     #A8C,W4
03674:  ADD     W0,W4,W0
03676:  MOV     [W0],W9
03678:  MOV     W9,W4
0367A:  MUL.UU  W4,#10,W0
0367C:  MOV     W0,W9
0367E:  MOV     1B26,W4
03680:  MUL.UU  W4,#4,W0
03682:  ADD     W0,W9,W0
03684:  MOV     #B60,W4
03686:  ADD     W0,W4,W0
03688:  MOV     W0,W4
0368A:  MOV     #0,W3
0368C:  MOV     [W4++],[W3++]
0368E:  MOV     [W4++],[W3++]
03690:  MOV     #0,W2
03692:  MOV     #0,W3
03694:  CALL    1B2C
03698:  MOV     W0,W9
0369A:  MOV     W1,W10
0369C:  MOV     W2,W11
0369E:  MOV     W3,W12
036A0:  MOV     1B46,W4
036A2:  MUL.UU  W4,#2,W0
036A4:  MOV     #A8C,W4
036A6:  ADD     W0,W4,W0
036A8:  MOV     [W0],W13
036AA:  MOV     W13,W4
036AC:  MUL.UU  W4,#10,W0
036AE:  MOV     W0,W13
036B0:  MOV     1B28,W4
036B2:  MUL.UU  W4,#4,W0
036B4:  ADD     W0,W13,W0
036B6:  MOV     #B60,W4
036B8:  ADD     W0,W4,W0
036BA:  MOV     W0,W4
036BC:  MOV     #0,W3
036BE:  MOV     [W4++],[W3++]
036C0:  MOV     [W4++],[W3++]
036C2:  MOV     #0,W2
036C4:  MOV     #0,W3
036C6:  CALL    1B2C
036CA:  MOV     W0,W13
036CC:  MOV     W1,W14
036CE:  MOV     W2,W15
036D0:  MOV     W3,[W0]
036D2:  MOV     1B42,W0
036D4:  CLR     W3
036D6:  BTSC    W0.F
036D8:  SETM    W3
036DA:  MOV     W3,W1
036DC:  MOV     W3,W2
036DE:  CALL    1B2C
036E2:  MOV     W0,1B54
036E4:  MOV     W1,1B56
036E6:  MOV     W2,1B58
036E8:  MOV     W3,1B5A
036EA:  MOV     1B44,W0
036EC:  CLR     W3
036EE:  BTSC    W0.F
036F0:  SETM    W3
036F2:  MOV     W3,W1
036F4:  MOV     W3,W2
036F6:  CALL    1B2C
036FA:  MOV     W0,1B5C
036FC:  MOV     W1,1B5E
036FE:  MOV     W2,1B60
03700:  MOV     W3,1B62
03702:  MOV     W9,1B82
03704:  MOV     W10,1B84
03706:  MOV     W11,1B86
03708:  MOV     W12,1B88
0370A:  MOV     W13,1B8A
0370C:  MOV     W14,1B8C
0370E:  MOV     W15,1B8E
03710:  MOV     [W0],[W15++]
03712:  POP     1B90
03714:  PUSH    1B54
03716:  POP     1B92
03718:  PUSH    1B56
0371A:  POP     1B94
0371C:  PUSH    1B58
0371E:  POP     1B96
03720:  PUSH    1B5A
03722:  POP     1B98
03724:  PUSH    1B5C
03726:  POP     1B9A
03728:  PUSH    1B5E
0372A:  POP     1B9C
0372C:  PUSH    1B60
0372E:  POP     1B9E
03730:  PUSH    1B62
03732:  POP     1BA0
03734:  CALL    332C
03738:  BCLR.B  43.0
0373A:  MOV     W5,[W15++]
0373C:  MOV     W6,[W15++]
0373E:  MOV     W7,[W15++]
03740:  MOV     W0,W4
03742:  MOV     W5,W0
03744:  MOV     W1,W5
03746:  MOV     W6,W1
03748:  MOV     W2,W6
0374A:  MOV     W7,W2
0374C:  MOV     W3,W7
0374E:  MOV     W8,W3
03750:  CALL    1C40
03754:  MOV     [--W15],W7
03756:  MOV     [--W15],W6
03758:  MOV     [--W15],W5
0375A:  MOV     W0,W5
0375C:  MOV     W1,W6
0375E:  MOV     W2,W7
03760:  MOV     W3,W8
03762:  MOV     1B3E,W0
03764:  CLR     W3
03766:  BTSC    W0.F
03768:  SETM    W3
0376A:  MOV     W3,W1
0376C:  MOV     W3,W2
0376E:  CALL    1B2C
03772:  MOV     W0,W9
03774:  MOV     W1,W10
03776:  MOV     W2,W11
03778:  MOV     W3,W12
0377A:  MOV     1B40,W0
0377C:  CLR     W3
0377E:  BTSC    W0.F
03780:  SETM    W3
03782:  MOV     W3,W1
03784:  MOV     W3,W2
03786:  CALL    1B2C
0378A:  MOV     W0,W13
0378C:  MOV     W1,W14
0378E:  MOV     W2,W15
03790:  MOV     W3,[W0]
03792:  MOV     1B46,W4
03794:  MUL.UU  W4,#2,W0
03796:  MOV     #A8C,W4
03798:  ADD     W0,W4,W0
0379A:  MOV     [W0],[W15++]
0379C:  POP     1B54
0379E:  MOV     1B54,W4
037A0:  MUL.UU  W4,#10,W0
037A2:  MOV     W0,1B54
037A4:  MOV     1B2A,W4
037A6:  MUL.UU  W4,#4,W0
037A8:  MOV     1B54,W4
037AA:  ADD     W0,W4,W0
037AC:  MOV     #B60,W4
037AE:  ADD     W0,W4,W0
037B0:  MOV     W0,W4
037B2:  MOV     #0,W3
037B4:  MOV     [W4++],[W3++]
037B6:  MOV     [W4++],[W3++]
037B8:  MOV     #0,W2
037BA:  MOV     #0,W3
037BC:  CALL    1B2C
037C0:  MOV     W0,1B54
037C2:  MOV     W1,1B56
037C4:  MOV     W2,1B58
037C6:  MOV     W3,1B5A
037C8:  MOV     1B46,W4
037CA:  MUL.UU  W4,#2,W0
037CC:  MOV     #A8C,W4
037CE:  ADD     W0,W4,W0
037D0:  MOV     [W0],[W15++]
037D2:  POP     1B5C
037D4:  MOV     1B5C,W4
037D6:  MUL.UU  W4,#10,W0
037D8:  MOV     W0,1B5C
037DA:  MOV     1B2C,W4
037DC:  MUL.UU  W4,#4,W0
037DE:  MOV     1B5C,W4
037E0:  ADD     W0,W4,W0
037E2:  MOV     #B60,W4
037E4:  ADD     W0,W4,W0
037E6:  MOV     W0,W4
037E8:  MOV     #0,W3
037EA:  MOV     [W4++],[W3++]
037EC:  MOV     [W4++],[W3++]
037EE:  MOV     #0,W2
037F0:  MOV     #0,W3
037F2:  CALL    1B2C
037F6:  MOV     W0,1B5C
037F8:  MOV     W1,1B5E
037FA:  MOV     W2,1B60
037FC:  MOV     W3,1B62
037FE:  MOV     W9,1B82
03800:  MOV     W10,1B84
03802:  MOV     W11,1B86
03804:  MOV     W12,1B88
03806:  MOV     W13,1B8A
03808:  MOV     W14,1B8C
0380A:  MOV     W15,1B8E
0380C:  MOV     [W0],[W15++]
0380E:  POP     1B90
03810:  PUSH    1B54
03812:  POP     1B92
03814:  PUSH    1B56
03816:  POP     1B94
03818:  PUSH    1B58
0381A:  POP     1B96
0381C:  PUSH    1B5A
0381E:  POP     1B98
03820:  PUSH    1B5C
03822:  POP     1B9A
03824:  PUSH    1B5E
03826:  POP     1B9C
03828:  PUSH    1B60
0382A:  POP     1B9E
0382C:  PUSH    1B62
0382E:  POP     1BA0
03830:  CALL    332C
03834:  MOV     W0,W9
03836:  MOV     W1,W10
03838:  MOV     W2,W11
0383A:  MOV     W3,W12
0383C:  MOV     1B46,W4
0383E:  MUL.UU  W4,#2,W0
03840:  MOV     #A8C,W4
03842:  ADD     W0,W4,W0
03844:  MOV     [W0],W13
03846:  MOV     W13,W4
03848:  MUL.UU  W4,#10,W0
0384A:  MOV     W0,W13
0384C:  MOV     1B2A,W4
0384E:  MUL.UU  W4,#4,W0
03850:  ADD     W0,W13,W0
03852:  MOV     #B60,W4
03854:  ADD     W0,W4,W0
03856:  MOV     W0,W4
03858:  MOV     #0,W3
0385A:  MOV     [W4++],[W3++]
0385C:  MOV     [W4++],[W3++]
0385E:  MOV     #0,W2
03860:  MOV     #0,W3
03862:  CALL    1B2C
03866:  MOV     W0,W13
03868:  MOV     W1,W14
0386A:  MOV     W2,W15
0386C:  MOV     W3,[W0]
0386E:  MOV     1B46,W4
03870:  MUL.UU  W4,#2,W0
03872:  MOV     #A8C,W4
03874:  ADD     W0,W4,W0
03876:  MOV     [W0],[W15++]
03878:  POP     1B54
0387A:  MOV     1B54,W4
0387C:  MUL.UU  W4,#10,W0
0387E:  MOV     W0,1B54
03880:  MOV     1B2C,W4
03882:  MUL.UU  W4,#4,W0
03884:  MOV     1B54,W4
03886:  ADD     W0,W4,W0
03888:  MOV     #B60,W4
0388A:  ADD     W0,W4,W0
0388C:  MOV     W0,W4
0388E:  MOV     #0,W3
03890:  MOV     [W4++],[W3++]
03892:  MOV     [W4++],[W3++]
03894:  MOV     #0,W2
03896:  MOV     #0,W3
03898:  CALL    1B2C
0389C:  MOV     W0,1B54
0389E:  MOV     W1,1B56
038A0:  MOV     W2,1B58
038A2:  MOV     W3,1B5A
038A4:  MOV     1B42,W0
038A6:  CLR     W3
038A8:  BTSC    W0.F
038AA:  SETM    W3
038AC:  MOV     W3,W1
038AE:  MOV     W3,W2
038B0:  CALL    1B2C
038B4:  MOV     W0,1B5C
038B6:  MOV     W1,1B5E
038B8:  MOV     W2,1B60
038BA:  MOV     W3,1B62
038BC:  MOV     1B44,W0
038BE:  CLR     W3
038C0:  BTSC    W0.F
038C2:  SETM    W3
038C4:  MOV     W3,W1
038C6:  MOV     W3,W2
038C8:  CALL    1B2C
038CC:  MOV     W0,1B64
038CE:  MOV     W1,1B66
038D0:  MOV     W2,1B68
038D2:  MOV     W3,1B6A
038D4:  MOV     W13,1B82
038D6:  MOV     W14,1B84
038D8:  MOV     W15,1B86
038DA:  MOV     [W0],[W15++]
038DC:  POP     1B88
038DE:  PUSH    1B54
038E0:  POP     1B8A
038E2:  PUSH    1B56
038E4:  POP     1B8C
038E6:  PUSH    1B58
038E8:  POP     1B8E
038EA:  PUSH    1B5A
038EC:  POP     1B90
038EE:  PUSH    1B5C
038F0:  POP     1B92
038F2:  PUSH    1B5E
038F4:  POP     1B94
038F6:  PUSH    1B60
038F8:  POP     1B96
038FA:  PUSH    1B62
038FC:  POP     1B98
038FE:  PUSH    1B64
03900:  POP     1B9A
03902:  PUSH    1B66
03904:  POP     1B9C
03906:  PUSH    1B68
03908:  POP     1B9E
0390A:  PUSH    1B6A
0390C:  POP     1BA0
0390E:  CALL    332C
03912:  BCLR.B  43.0
03914:  MOV     W5,[W15++]
03916:  MOV     W6,[W15++]
03918:  MOV     W7,[W15++]
0391A:  MOV     W0,W4
0391C:  MOV     W1,W5
0391E:  MOV     W2,W6
03920:  MOV     W3,W7
03922:  MOV     W9,W0
03924:  MOV     W10,W1
03926:  MOV     W11,W2
03928:  MOV     W12,W3
0392A:  CALL    1C40
0392E:  MOV     [--W15],W7
03930:  MOV     [--W15],W6
03932:  MOV     [--W15],W5
03934:  MOV     W5,[W15++]
03936:  MOV     W6,[W15++]
03938:  MOV     W7,[W15++]
0393A:  MOV     W5,W4
0393C:  MOV     W6,W5
0393E:  MOV     W7,W6
03940:  MOV     W8,W7
03942:  CALL    1E2E
03946:  MOV     [--W15],W7
03948:  MOV     [--W15],W6
0394A:  MOV     [--W15],W5
0394C:  BRA     NC,39CA
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0394E:  MOV     A88,W4
03950:  MUL.UU  W4,#10,W0
03952:  MOV     W0,W5
03954:  MOV     #AA0,W4
03956:  ADD     W5,W4,W6
03958:  MOV     1B46,W4
0395A:  MUL.UU  W4,#2,W0
0395C:  MOV     #A8C,W4
0395E:  ADD     W0,W4,W0
03960:  MOV     [W0],W7
03962:  MOV     W7,W4
03964:  MUL.UU  W4,#10,W0
03966:  MOV     W0,W7
03968:  MOV     1B2A,W4
0396A:  MUL.UU  W4,#4,W0
0396C:  ADD     W0,W7,W0
0396E:  MOV     #B60,W4
03970:  ADD     W0,W4,W0
03972:  MOV     W0,W4
03974:  MOV     #0,W3
03976:  MOV     [W4++],[W3++]
03978:  MOV     [W4++],[W3++]
0397A:  MOV     #0,W2
0397C:  MOV     #0,W3
0397E:  CALL    1B2C
03982:  MOV     #0,W4
03984:  REPEAT  #3
03986:  MOV     [W4++],[W6++]
03988:  MOV     A88,W4
0398A:  MUL.UU  W4,#10,W0
0398C:  MOV     W0,W5
0398E:  ADD     W5,#8,W0
03990:  MOV     #AA0,W4
03992:  ADD     W0,W4,W5
03994:  MOV     1B46,W4
03996:  MUL.UU  W4,#2,W0
03998:  MOV     #A8C,W4
0399A:  ADD     W0,W4,W0
0399C:  MOV     [W0],W6
0399E:  MOV     W6,W4
039A0:  MUL.UU  W4,#10,W6
039A2:  MOV     1B2C,W4
039A4:  MUL.UU  W4,#4,W0
039A6:  ADD     W0,W6,W0
039A8:  MOV     #B60,W4
039AA:  ADD     W0,W4,W0
039AC:  MOV     W0,W4
039AE:  MOV     #0,W3
039B0:  MOV     [W4++],[W3++]
039B2:  MOV     [W4++],[W3++]
039B4:  MOV     #0,W2
039B6:  MOV     #0,W3
039B8:  CALL    1B2C
039BC:  MOV     #0,W4
039BE:  REPEAT  #3
039C0:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
039C2:  MOV     #1,W4
039C4:  MOV     W4,1B4C
.................... 	                } 
039C6:  GOTO    3A42
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
039CA:  MOV     A88,W4
039CC:  MUL.UU  W4,#10,W0
039CE:  MOV     W0,W5
039D0:  MOV     #AA0,W4
039D2:  ADD     W5,W4,W6
039D4:  MOV     1B46,W4
039D6:  MUL.UU  W4,#2,W0
039D8:  MOV     #A8C,W4
039DA:  ADD     W0,W4,W0
039DC:  MOV     [W0],W7
039DE:  MOV     W7,W4
039E0:  MUL.UU  W4,#10,W0
039E2:  MOV     W0,W7
039E4:  MOV     1B26,W4
039E6:  MUL.UU  W4,#4,W0
039E8:  ADD     W0,W7,W0
039EA:  MOV     #B60,W4
039EC:  ADD     W0,W4,W0
039EE:  MOV     W0,W4
039F0:  MOV     #0,W3
039F2:  MOV     [W4++],[W3++]
039F4:  MOV     [W4++],[W3++]
039F6:  MOV     #0,W2
039F8:  MOV     #0,W3
039FA:  CALL    1B2C
039FE:  MOV     #0,W4
03A00:  REPEAT  #3
03A02:  MOV     [W4++],[W6++]
03A04:  MOV     A88,W4
03A06:  MUL.UU  W4,#10,W0
03A08:  MOV     W0,W5
03A0A:  ADD     W5,#8,W0
03A0C:  MOV     #AA0,W4
03A0E:  ADD     W0,W4,W5
03A10:  MOV     1B46,W4
03A12:  MUL.UU  W4,#2,W0
03A14:  MOV     #A8C,W4
03A16:  ADD     W0,W4,W0
03A18:  MOV     [W0],W6
03A1A:  MOV     W6,W4
03A1C:  MUL.UU  W4,#10,W6
03A1E:  MOV     1B28,W4
03A20:  MUL.UU  W4,#4,W0
03A22:  ADD     W0,W6,W0
03A24:  MOV     #B60,W4
03A26:  ADD     W0,W4,W0
03A28:  MOV     W0,W4
03A2A:  MOV     #0,W3
03A2C:  MOV     [W4++],[W3++]
03A2E:  MOV     [W4++],[W3++]
03A30:  MOV     #0,W2
03A32:  MOV     #0,W3
03A34:  CALL    1B2C
03A38:  MOV     #0,W4
03A3A:  REPEAT  #3
03A3C:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
03A3E:  MOV     #1,W4
03A40:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
03A42:  MOV     #1,W4
03A44:  MOV     W4,A84
.................... 	            } 
03A46:  GOTO    3ACC
.................... 	            else if (posEnd == 5) 
03A4A:  MOV     1B4A,W4
03A4C:  CP      W4,#5
03A4E:  BRA     NZ,3ACC
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
03A50:  MOV     A88,W4
03A52:  MUL.UU  W4,#10,W0
03A54:  MOV     W0,W5
03A56:  MOV     #AA0,W4
03A58:  ADD     W5,W4,W6
03A5A:  MOV     1B46,W4
03A5C:  MUL.UU  W4,#2,W0
03A5E:  MOV     #A8C,W4
03A60:  ADD     W0,W4,W0
03A62:  MOV     [W0],W7
03A64:  MOV     W7,W4
03A66:  MUL.UU  W4,#10,W0
03A68:  MOV     W0,W7
03A6A:  MOV     1B26,W4
03A6C:  MUL.UU  W4,#4,W0
03A6E:  ADD     W0,W7,W0
03A70:  MOV     #B60,W4
03A72:  ADD     W0,W4,W0
03A74:  MOV     W0,W4
03A76:  MOV     #0,W3
03A78:  MOV     [W4++],[W3++]
03A7A:  MOV     [W4++],[W3++]
03A7C:  MOV     #0,W2
03A7E:  MOV     #0,W3
03A80:  CALL    1B2C
03A84:  MOV     #0,W4
03A86:  REPEAT  #3
03A88:  MOV     [W4++],[W6++]
03A8A:  MOV     A88,W4
03A8C:  MUL.UU  W4,#10,W0
03A8E:  MOV     W0,W5
03A90:  ADD     W5,#8,W0
03A92:  MOV     #AA0,W4
03A94:  ADD     W0,W4,W5
03A96:  MOV     1B46,W4
03A98:  MUL.UU  W4,#2,W0
03A9A:  MOV     #A8C,W4
03A9C:  ADD     W0,W4,W0
03A9E:  MOV     [W0],W6
03AA0:  MOV     W6,W4
03AA2:  MUL.UU  W4,#10,W6
03AA4:  MOV     1B28,W4
03AA6:  MUL.UU  W4,#4,W0
03AA8:  ADD     W0,W6,W0
03AAA:  MOV     #B60,W4
03AAC:  ADD     W0,W4,W0
03AAE:  MOV     W0,W4
03AB0:  MOV     #0,W3
03AB2:  MOV     [W4++],[W3++]
03AB4:  MOV     [W4++],[W3++]
03AB6:  MOV     #0,W2
03AB8:  MOV     #0,W3
03ABA:  CALL    1B2C
03ABE:  MOV     #0,W4
03AC0:  REPEAT  #3
03AC2:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
03AC4:  MOV     #1,W4
03AC6:  MOV     W4,1B4C
.................... 	                path_found = true; 
03AC8:  MOV     #1,W4
03ACA:  MOV     W4,A84
.................... 	            } 
.................... 	            break; 
03ACC:  GOTO    66B2
....................  
.................... 	        case 1: 
.................... 	            if (posEnd == 3 || posEnd == 4) 
03AD0:  MOV     1B4A,W4
03AD2:  CP      W4,#3
03AD4:  BRA     Z,3ADC
03AD6:  MOV     1B4A,W4
03AD8:  CP      W4,#4
03ADA:  BRA     NZ,3B5C
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
03ADC:  MOV     A88,W4
03ADE:  MUL.UU  W4,#10,W0
03AE0:  MOV     W0,W5
03AE2:  MOV     #AA0,W4
03AE4:  ADD     W5,W4,W6
03AE6:  MOV     1B46,W4
03AE8:  MUL.UU  W4,#2,W0
03AEA:  MOV     #A8C,W4
03AEC:  ADD     W0,W4,W0
03AEE:  MOV     [W0],W7
03AF0:  MOV     W7,W4
03AF2:  MUL.UU  W4,#10,W0
03AF4:  MOV     W0,W7
03AF6:  MOV     1B2A,W4
03AF8:  MUL.UU  W4,#4,W0
03AFA:  ADD     W0,W7,W0
03AFC:  MOV     #B60,W4
03AFE:  ADD     W0,W4,W0
03B00:  MOV     W0,W4
03B02:  MOV     #0,W3
03B04:  MOV     [W4++],[W3++]
03B06:  MOV     [W4++],[W3++]
03B08:  MOV     #0,W2
03B0A:  MOV     #0,W3
03B0C:  CALL    1B2C
03B10:  MOV     #0,W4
03B12:  REPEAT  #3
03B14:  MOV     [W4++],[W6++]
03B16:  MOV     A88,W4
03B18:  MUL.UU  W4,#10,W0
03B1A:  MOV     W0,W5
03B1C:  ADD     W5,#8,W0
03B1E:  MOV     #AA0,W4
03B20:  ADD     W0,W4,W5
03B22:  MOV     1B46,W4
03B24:  MUL.UU  W4,#2,W0
03B26:  MOV     #A8C,W4
03B28:  ADD     W0,W4,W0
03B2A:  MOV     [W0],W6
03B2C:  MOV     W6,W4
03B2E:  MUL.UU  W4,#10,W6
03B30:  MOV     1B2C,W4
03B32:  MUL.UU  W4,#4,W0
03B34:  ADD     W0,W6,W0
03B36:  MOV     #B60,W4
03B38:  ADD     W0,W4,W0
03B3A:  MOV     W0,W4
03B3C:  MOV     #0,W3
03B3E:  MOV     [W4++],[W3++]
03B40:  MOV     [W4++],[W3++]
03B42:  MOV     #0,W2
03B44:  MOV     #0,W3
03B46:  CALL    1B2C
03B4A:  MOV     #0,W4
03B4C:  REPEAT  #3
03B4E:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
03B50:  MOV     #1,W4
03B52:  MOV     W4,1B4C
.................... 	                path_found = true; 
03B54:  MOV     #1,W4
03B56:  MOV     W4,A84
.................... 	            } 
03B58:  GOTO    4186
.................... 	            else if (posEnd == 5) 
03B5C:  MOV     1B4A,W4
03B5E:  CP      W4,#5
03B60:  BRA     NZ,4108
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
03B62:  MOV     1B3E,W0
03B64:  CLR     W3
03B66:  BTSC    W0.F
03B68:  SETM    W3
03B6A:  MOV     W3,W1
03B6C:  MOV     W3,W2
03B6E:  CALL    1B2C
03B72:  MOV     W0,W5
03B74:  MOV     W1,W6
03B76:  MOV     W2,W7
03B78:  MOV     W3,W8
03B7A:  MOV     1B40,W0
03B7C:  CLR     W3
03B7E:  BTSC    W0.F
03B80:  SETM    W3
03B82:  MOV     W3,W1
03B84:  MOV     W3,W2
03B86:  CALL    1B2C
03B8A:  MOV     W0,W9
03B8C:  MOV     W1,W10
03B8E:  MOV     W2,W11
03B90:  MOV     W3,W12
03B92:  MOV     1B46,W4
03B94:  MUL.UU  W4,#2,W0
03B96:  MOV     #A8C,W4
03B98:  ADD     W0,W4,W0
03B9A:  MOV     [W0],W13
03B9C:  MOV     W13,W4
03B9E:  MUL.UU  W4,#10,W0
03BA0:  MOV     W0,W13
03BA2:  MOV     #B60,W4
03BA4:  ADD     W13,W4,W0
03BA6:  MOV     W0,W4
03BA8:  MOV     #0,W3
03BAA:  MOV     [W4++],[W3++]
03BAC:  MOV     [W4++],[W3++]
03BAE:  MOV     #0,W2
03BB0:  MOV     #0,W3
03BB2:  CALL    1B2C
03BB6:  MOV     W0,1B4E
03BB8:  MOV     W1,1B50
03BBA:  MOV     W2,1B52
03BBC:  MOV     W3,1B54
03BBE:  MOV     1B46,W4
03BC0:  MUL.UU  W4,#2,W0
03BC2:  MOV     #A8C,W4
03BC4:  ADD     W0,W4,W0
03BC6:  MOV     [W0],[W15++]
03BC8:  POP     1B56
03BCA:  MOV     1B56,W4
03BCC:  MUL.UU  W4,#10,W0
03BCE:  MOV     W0,1B56
03BD0:  MOV     1B56,W4
03BD2:  ADD     W4,#4,W0
03BD4:  MOV     #B60,W4
03BD6:  ADD     W0,W4,W0
03BD8:  MOV     W0,W4
03BDA:  MOV     #0,W3
03BDC:  MOV     [W4++],[W3++]
03BDE:  MOV     [W4++],[W3++]
03BE0:  MOV     #0,W2
03BE2:  MOV     #0,W3
03BE4:  CALL    1B2C
03BE8:  MOV     W0,1B56
03BEA:  MOV     W1,1B58
03BEC:  MOV     W2,1B5A
03BEE:  MOV     W3,1B5C
03BF0:  MOV     W5,1B82
03BF2:  MOV     W6,1B84
03BF4:  MOV     W7,1B86
03BF6:  MOV     W8,1B88
03BF8:  MOV     W9,1B8A
03BFA:  MOV     W10,1B8C
03BFC:  MOV     W11,1B8E
03BFE:  MOV     W12,1B90
03C00:  PUSH    1B4E
03C02:  POP     1B92
03C04:  PUSH    1B50
03C06:  POP     1B94
03C08:  PUSH    1B52
03C0A:  POP     1B96
03C0C:  PUSH    1B54
03C0E:  POP     1B98
03C10:  PUSH    1B56
03C12:  POP     1B9A
03C14:  PUSH    1B58
03C16:  POP     1B9C
03C18:  PUSH    1B5A
03C1A:  POP     1B9E
03C1C:  PUSH    1B5C
03C1E:  POP     1BA0
03C20:  CALL    332C
03C24:  MOV     W0,W5
03C26:  MOV     W1,W6
03C28:  MOV     W2,W7
03C2A:  MOV     W3,W8
03C2C:  MOV     1B46,W4
03C2E:  MUL.UU  W4,#2,W0
03C30:  MOV     #A8C,W4
03C32:  ADD     W0,W4,W0
03C34:  MOV     [W0],W9
03C36:  MOV     W9,W4
03C38:  MUL.UU  W4,#10,W0
03C3A:  MOV     W0,W9
03C3C:  MOV     1B26,W4
03C3E:  MUL.UU  W4,#4,W0
03C40:  ADD     W0,W9,W0
03C42:  MOV     #B60,W4
03C44:  ADD     W0,W4,W0
03C46:  MOV     W0,W4
03C48:  MOV     #0,W3
03C4A:  MOV     [W4++],[W3++]
03C4C:  MOV     [W4++],[W3++]
03C4E:  MOV     #0,W2
03C50:  MOV     #0,W3
03C52:  CALL    1B2C
03C56:  MOV     W0,W9
03C58:  MOV     W1,W10
03C5A:  MOV     W2,W11
03C5C:  MOV     W3,W12
03C5E:  MOV     1B46,W4
03C60:  MUL.UU  W4,#2,W0
03C62:  MOV     #A8C,W4
03C64:  ADD     W0,W4,W0
03C66:  MOV     [W0],[W15++]
03C68:  POP     1B4E
03C6A:  MOV     1B4E,W4
03C6C:  MUL.UU  W4,#10,W0
03C6E:  MOV     W0,1B4E
03C70:  MOV     1B28,W4
03C72:  MUL.UU  W4,#4,W0
03C74:  MOV     1B4E,W4
03C76:  ADD     W0,W4,W0
03C78:  MOV     #B60,W4
03C7A:  ADD     W0,W4,W0
03C7C:  MOV     W0,W4
03C7E:  MOV     #0,W3
03C80:  MOV     [W4++],[W3++]
03C82:  MOV     [W4++],[W3++]
03C84:  MOV     #0,W2
03C86:  MOV     #0,W3
03C88:  CALL    1B2C
03C8C:  MOV     W0,1B4E
03C8E:  MOV     W1,1B50
03C90:  MOV     W2,1B52
03C92:  MOV     W3,1B54
03C94:  MOV     1B42,W0
03C96:  CLR     W3
03C98:  BTSC    W0.F
03C9A:  SETM    W3
03C9C:  MOV     W3,W1
03C9E:  MOV     W3,W2
03CA0:  CALL    1B2C
03CA4:  MOV     W0,1B56
03CA6:  MOV     W1,1B58
03CA8:  MOV     W2,1B5A
03CAA:  MOV     W3,1B5C
03CAC:  MOV     1B44,W0
03CAE:  CLR     W3
03CB0:  BTSC    W0.F
03CB2:  SETM    W3
03CB4:  MOV     W3,W1
03CB6:  MOV     W3,W2
03CB8:  CALL    1B2C
03CBC:  MOV     W0,1B5E
03CBE:  MOV     W1,1B60
03CC0:  MOV     W2,1B62
03CC2:  MOV     W3,1B64
03CC4:  MOV     W9,1B82
03CC6:  MOV     W10,1B84
03CC8:  MOV     W11,1B86
03CCA:  MOV     W12,1B88
03CCC:  PUSH    1B4E
03CCE:  POP     1B8A
03CD0:  PUSH    1B50
03CD2:  POP     1B8C
03CD4:  PUSH    1B52
03CD6:  POP     1B8E
03CD8:  PUSH    1B54
03CDA:  POP     1B90
03CDC:  PUSH    1B56
03CDE:  POP     1B92
03CE0:  PUSH    1B58
03CE2:  POP     1B94
03CE4:  PUSH    1B5A
03CE6:  POP     1B96
03CE8:  PUSH    1B5C
03CEA:  POP     1B98
03CEC:  PUSH    1B5E
03CEE:  POP     1B9A
03CF0:  PUSH    1B60
03CF2:  POP     1B9C
03CF4:  PUSH    1B62
03CF6:  POP     1B9E
03CF8:  PUSH    1B64
03CFA:  POP     1BA0
03CFC:  CALL    332C
03D00:  BCLR.B  43.0
03D02:  MOV     W5,[W15++]
03D04:  MOV     W6,[W15++]
03D06:  MOV     W7,[W15++]
03D08:  MOV     W0,W4
03D0A:  MOV     W5,W0
03D0C:  MOV     W1,W5
03D0E:  MOV     W6,W1
03D10:  MOV     W2,W6
03D12:  MOV     W7,W2
03D14:  MOV     W3,W7
03D16:  MOV     W8,W3
03D18:  CALL    1C40
03D1C:  MOV     [--W15],W7
03D1E:  MOV     [--W15],W6
03D20:  MOV     [--W15],W5
03D22:  MOV     W0,W5
03D24:  MOV     W1,W6
03D26:  MOV     W2,W7
03D28:  MOV     W3,W8
03D2A:  MOV     1B3E,W0
03D2C:  CLR     W3
03D2E:  BTSC    W0.F
03D30:  SETM    W3
03D32:  MOV     W3,W1
03D34:  MOV     W3,W2
03D36:  CALL    1B2C
03D3A:  MOV     W0,W9
03D3C:  MOV     W1,W10
03D3E:  MOV     W2,W11
03D40:  MOV     W3,W12
03D42:  MOV     1B40,W0
03D44:  CLR     W3
03D46:  BTSC    W0.F
03D48:  SETM    W3
03D4A:  MOV     W3,W1
03D4C:  MOV     W3,W2
03D4E:  CALL    1B2C
03D52:  MOV     W0,1B4E
03D54:  MOV     W1,1B50
03D56:  MOV     W2,1B52
03D58:  MOV     W3,1B54
03D5A:  MOV     1B46,W4
03D5C:  MUL.UU  W4,#2,W0
03D5E:  MOV     #A8C,W4
03D60:  ADD     W0,W4,W0
03D62:  MOV     [W0],[W15++]
03D64:  POP     1B56
03D66:  MOV     1B56,W4
03D68:  MUL.UU  W4,#10,W0
03D6A:  MOV     W0,1B56
03D6C:  MOV     1B2A,W4
03D6E:  MUL.UU  W4,#4,W0
03D70:  MOV     1B56,W4
03D72:  ADD     W0,W4,W0
03D74:  MOV     #B60,W4
03D76:  ADD     W0,W4,W0
03D78:  MOV     W0,W4
03D7A:  MOV     #0,W3
03D7C:  MOV     [W4++],[W3++]
03D7E:  MOV     [W4++],[W3++]
03D80:  MOV     #0,W2
03D82:  MOV     #0,W3
03D84:  CALL    1B2C
03D88:  MOV     W0,1B56
03D8A:  MOV     W1,1B58
03D8C:  MOV     W2,1B5A
03D8E:  MOV     W3,1B5C
03D90:  MOV     1B46,W4
03D92:  MUL.UU  W4,#2,W0
03D94:  MOV     #A8C,W4
03D96:  ADD     W0,W4,W0
03D98:  MOV     [W0],[W15++]
03D9A:  POP     1B5E
03D9C:  MOV     1B5E,W4
03D9E:  MUL.UU  W4,#10,W0
03DA0:  MOV     W0,1B5E
03DA2:  MOV     1B2C,W4
03DA4:  MUL.UU  W4,#4,W0
03DA6:  MOV     1B5E,W4
03DA8:  ADD     W0,W4,W0
03DAA:  MOV     #B60,W4
03DAC:  ADD     W0,W4,W0
03DAE:  MOV     W0,W4
03DB0:  MOV     #0,W3
03DB2:  MOV     [W4++],[W3++]
03DB4:  MOV     [W4++],[W3++]
03DB6:  MOV     #0,W2
03DB8:  MOV     #0,W3
03DBA:  CALL    1B2C
03DBE:  MOV     W0,1B5E
03DC0:  MOV     W1,1B60
03DC2:  MOV     W2,1B62
03DC4:  MOV     W3,1B64
03DC6:  MOV     W9,1B82
03DC8:  MOV     W10,1B84
03DCA:  MOV     W11,1B86
03DCC:  MOV     W12,1B88
03DCE:  PUSH    1B4E
03DD0:  POP     1B8A
03DD2:  PUSH    1B50
03DD4:  POP     1B8C
03DD6:  PUSH    1B52
03DD8:  POP     1B8E
03DDA:  PUSH    1B54
03DDC:  POP     1B90
03DDE:  PUSH    1B56
03DE0:  POP     1B92
03DE2:  PUSH    1B58
03DE4:  POP     1B94
03DE6:  PUSH    1B5A
03DE8:  POP     1B96
03DEA:  PUSH    1B5C
03DEC:  POP     1B98
03DEE:  PUSH    1B5E
03DF0:  POP     1B9A
03DF2:  PUSH    1B60
03DF4:  POP     1B9C
03DF6:  PUSH    1B62
03DF8:  POP     1B9E
03DFA:  PUSH    1B64
03DFC:  POP     1BA0
03DFE:  CALL    332C
03E02:  MOV     W0,W9
03E04:  MOV     W1,W10
03E06:  MOV     W2,W11
03E08:  MOV     W3,W12
03E0A:  MOV     1B46,W4
03E0C:  MUL.UU  W4,#2,W0
03E0E:  MOV     #A8C,W4
03E10:  ADD     W0,W4,W0
03E12:  MOV     [W0],[W15++]
03E14:  POP     1B4E
03E16:  MOV     1B4E,W4
03E18:  MUL.UU  W4,#10,W0
03E1A:  MOV     W0,1B4E
03E1C:  MOV     1B4E,W4
03E1E:  ADD     W4,#8,W0
03E20:  MOV     #B60,W4
03E22:  ADD     W0,W4,W0
03E24:  MOV     W0,W4
03E26:  MOV     #0,W3
03E28:  MOV     [W4++],[W3++]
03E2A:  MOV     [W4++],[W3++]
03E2C:  MOV     #0,W2
03E2E:  MOV     #0,W3
03E30:  CALL    1B2C
03E34:  MOV     W0,1B4E
03E36:  MOV     W1,1B50
03E38:  MOV     W2,1B52
03E3A:  MOV     W3,1B54
03E3C:  MOV     1B46,W4
03E3E:  MUL.UU  W4,#2,W0
03E40:  MOV     #A8C,W4
03E42:  ADD     W0,W4,W0
03E44:  MOV     [W0],[W15++]
03E46:  POP     1B56
03E48:  MOV     1B56,W4
03E4A:  MUL.UU  W4,#10,W0
03E4C:  MOV     W0,1B56
03E4E:  MOV     1B56,W4
03E50:  ADD     W4,#C,W0
03E52:  MOV     #B60,W4
03E54:  ADD     W0,W4,W0
03E56:  MOV     W0,W4
03E58:  MOV     #0,W3
03E5A:  MOV     [W4++],[W3++]
03E5C:  MOV     [W4++],[W3++]
03E5E:  MOV     #0,W2
03E60:  MOV     #0,W3
03E62:  CALL    1B2C
03E66:  MOV     W0,1B56
03E68:  MOV     W1,1B58
03E6A:  MOV     W2,1B5A
03E6C:  MOV     W3,1B5C
03E6E:  MOV     1B42,W0
03E70:  CLR     W3
03E72:  BTSC    W0.F
03E74:  SETM    W3
03E76:  MOV     W3,W1
03E78:  MOV     W3,W2
03E7A:  CALL    1B2C
03E7E:  MOV     W0,1B5E
03E80:  MOV     W1,1B60
03E82:  MOV     W2,1B62
03E84:  MOV     W3,1B64
03E86:  MOV     1B44,W0
03E88:  CLR     W3
03E8A:  BTSC    W0.F
03E8C:  SETM    W3
03E8E:  MOV     W3,W1
03E90:  MOV     W3,W2
03E92:  CALL    1B2C
03E96:  MOV     W0,1B66
03E98:  MOV     W1,1B68
03E9A:  MOV     W2,1B6A
03E9C:  MOV     W3,1B6C
03E9E:  PUSH    1B4E
03EA0:  POP     1B82
03EA2:  PUSH    1B50
03EA4:  POP     1B84
03EA6:  PUSH    1B52
03EA8:  POP     1B86
03EAA:  PUSH    1B54
03EAC:  POP     1B88
03EAE:  PUSH    1B56
03EB0:  POP     1B8A
03EB2:  PUSH    1B58
03EB4:  POP     1B8C
03EB6:  PUSH    1B5A
03EB8:  POP     1B8E
03EBA:  PUSH    1B5C
03EBC:  POP     1B90
03EBE:  PUSH    1B5E
03EC0:  POP     1B92
03EC2:  PUSH    1B60
03EC4:  POP     1B94
03EC6:  PUSH    1B62
03EC8:  POP     1B96
03ECA:  PUSH    1B64
03ECC:  POP     1B98
03ECE:  PUSH    1B66
03ED0:  POP     1B9A
03ED2:  PUSH    1B68
03ED4:  POP     1B9C
03ED6:  PUSH    1B6A
03ED8:  POP     1B9E
03EDA:  PUSH    1B6C
03EDC:  POP     1BA0
03EDE:  CALL    332C
03EE2:  BCLR.B  43.0
03EE4:  MOV     W5,[W15++]
03EE6:  MOV     W6,[W15++]
03EE8:  MOV     W7,[W15++]
03EEA:  MOV     W0,W4
03EEC:  MOV     W1,W5
03EEE:  MOV     W2,W6
03EF0:  MOV     W3,W7
03EF2:  MOV     W9,W0
03EF4:  MOV     W10,W1
03EF6:  MOV     W11,W2
03EF8:  MOV     W12,W3
03EFA:  CALL    1C40
03EFE:  MOV     [--W15],W7
03F00:  MOV     [--W15],W6
03F02:  MOV     [--W15],W5
03F04:  MOV     W5,[W15++]
03F06:  MOV     W6,[W15++]
03F08:  MOV     W7,[W15++]
03F0A:  MOV     W0,W4
03F0C:  MOV     W5,W0
03F0E:  MOV     W1,W5
03F10:  MOV     W6,W1
03F12:  MOV     W2,W6
03F14:  MOV     W7,W2
03F16:  MOV     W3,W7
03F18:  MOV     W8,W3
03F1A:  CALL    1E2E
03F1E:  MOV     [--W15],W7
03F20:  MOV     [--W15],W6
03F22:  MOV     [--W15],W5
03F24:  BRA     NC,4014
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
03F26:  MOV     A88,W4
03F28:  MUL.UU  W4,#10,W0
03F2A:  MOV     W0,W5
03F2C:  MOV     #AA0,W4
03F2E:  ADD     W5,W4,W6
03F30:  MOV     1B46,W4
03F32:  MUL.UU  W4,#2,W0
03F34:  MOV     #A8C,W4
03F36:  ADD     W0,W4,W0
03F38:  MOV     [W0],W7
03F3A:  MOV     W7,W4
03F3C:  MUL.UU  W4,#10,W0
03F3E:  MOV     W0,W7
03F40:  MOV     #B60,W4
03F42:  ADD     W7,W4,W0
03F44:  MOV     W0,W4
03F46:  MOV     #0,W3
03F48:  MOV     [W4++],[W3++]
03F4A:  MOV     [W4++],[W3++]
03F4C:  MOV     #0,W2
03F4E:  MOV     #0,W3
03F50:  CALL    1B2C
03F54:  MOV     #0,W4
03F56:  REPEAT  #3
03F58:  MOV     [W4++],[W6++]
03F5A:  MOV     A88,W4
03F5C:  MUL.UU  W4,#10,W0
03F5E:  MOV     W0,W5
03F60:  ADD     W5,#8,W0
03F62:  MOV     #AA0,W4
03F64:  ADD     W0,W4,W5
03F66:  MOV     1B46,W4
03F68:  MUL.UU  W4,#2,W0
03F6A:  MOV     #A8C,W4
03F6C:  ADD     W0,W4,W0
03F6E:  MOV     [W0],W6
03F70:  MOV     W6,W4
03F72:  MUL.UU  W4,#10,W6
03F74:  ADD     W6,#4,W0
03F76:  MOV     #B60,W4
03F78:  ADD     W0,W4,W0
03F7A:  MOV     W0,W4
03F7C:  MOV     #0,W3
03F7E:  MOV     [W4++],[W3++]
03F80:  MOV     [W4++],[W3++]
03F82:  MOV     #0,W2
03F84:  MOV     #0,W3
03F86:  CALL    1B2C
03F8A:  MOV     #0,W4
03F8C:  REPEAT  #3
03F8E:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel+1].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1].Y = TabZones[TabIntersection[i_zone]][y3]; 
03F90:  MOV     A88,W4
03F92:  ADD     W4,#1,W5
03F94:  MOV     W5,W4
03F96:  MUL.UU  W4,#10,W0
03F98:  MOV     W0,W5
03F9A:  MOV     #AA0,W4
03F9C:  ADD     W5,W4,W6
03F9E:  MOV     1B46,W4
03FA0:  MUL.UU  W4,#2,W0
03FA2:  MOV     #A8C,W4
03FA4:  ADD     W0,W4,W0
03FA6:  MOV     [W0],W7
03FA8:  MOV     W7,W4
03FAA:  MUL.UU  W4,#10,W0
03FAC:  MOV     W0,W7
03FAE:  MOV     1B26,W4
03FB0:  MUL.UU  W4,#4,W0
03FB2:  ADD     W0,W7,W0
03FB4:  MOV     #B60,W4
03FB6:  ADD     W0,W4,W0
03FB8:  MOV     W0,W4
03FBA:  MOV     #0,W3
03FBC:  MOV     [W4++],[W3++]
03FBE:  MOV     [W4++],[W3++]
03FC0:  MOV     #0,W2
03FC2:  MOV     #0,W3
03FC4:  CALL    1B2C
03FC8:  MOV     #0,W4
03FCA:  REPEAT  #3
03FCC:  MOV     [W4++],[W6++]
03FCE:  MOV     A88,W4
03FD0:  ADD     W4,#1,W5
03FD2:  MOV     W5,W4
03FD4:  MUL.UU  W4,#10,W0
03FD6:  MOV     W0,W5
03FD8:  ADD     W5,#8,W0
03FDA:  MOV     #AA0,W4
03FDC:  ADD     W0,W4,W5
03FDE:  MOV     1B46,W4
03FE0:  MUL.UU  W4,#2,W0
03FE2:  MOV     #A8C,W4
03FE4:  ADD     W0,W4,W0
03FE6:  MOV     [W0],W6
03FE8:  MOV     W6,W4
03FEA:  MUL.UU  W4,#10,W6
03FEC:  MOV     1B28,W4
03FEE:  MUL.UU  W4,#4,W0
03FF0:  ADD     W0,W6,W0
03FF2:  MOV     #B60,W4
03FF4:  ADD     W0,W4,W0
03FF6:  MOV     W0,W4
03FF8:  MOV     #0,W3
03FFA:  MOV     [W4++],[W3++]
03FFC:  MOV     [W4++],[W3++]
03FFE:  MOV     #0,W2
04000:  MOV     #0,W3
04002:  CALL    1B2C
04006:  MOV     #0,W4
04008:  REPEAT  #3
0400A:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
0400C:  MOV     #2,W4
0400E:  MOV     W4,1B4C
.................... 	                } 
04010:  GOTO    4100
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
04014:  MOV     A88,W4
04016:  MUL.UU  W4,#10,W0
04018:  MOV     W0,W5
0401A:  MOV     #AA0,W4
0401C:  ADD     W5,W4,W6
0401E:  MOV     1B46,W4
04020:  MUL.UU  W4,#2,W0
04022:  MOV     #A8C,W4
04024:  ADD     W0,W4,W0
04026:  MOV     [W0],W7
04028:  MOV     W7,W4
0402A:  MUL.UU  W4,#10,W0
0402C:  MOV     W0,W7
0402E:  MOV     1B2A,W4
04030:  MUL.UU  W4,#4,W0
04032:  ADD     W0,W7,W0
04034:  MOV     #B60,W4
04036:  ADD     W0,W4,W0
04038:  MOV     W0,W4
0403A:  MOV     #0,W3
0403C:  MOV     [W4++],[W3++]
0403E:  MOV     [W4++],[W3++]
04040:  MOV     #0,W2
04042:  MOV     #0,W3
04044:  CALL    1B2C
04048:  MOV     #0,W4
0404A:  REPEAT  #3
0404C:  MOV     [W4++],[W6++]
0404E:  MOV     A88,W4
04050:  MUL.UU  W4,#10,W0
04052:  MOV     W0,W5
04054:  ADD     W5,#8,W0
04056:  MOV     #AA0,W4
04058:  ADD     W0,W4,W5
0405A:  MOV     1B46,W4
0405C:  MUL.UU  W4,#2,W0
0405E:  MOV     #A8C,W4
04060:  ADD     W0,W4,W0
04062:  MOV     [W0],W6
04064:  MOV     W6,W4
04066:  MUL.UU  W4,#10,W6
04068:  MOV     1B2C,W4
0406A:  MUL.UU  W4,#4,W0
0406C:  ADD     W0,W6,W0
0406E:  MOV     #B60,W4
04070:  ADD     W0,W4,W0
04072:  MOV     W0,W4
04074:  MOV     #0,W3
04076:  MOV     [W4++],[W3++]
04078:  MOV     [W4++],[W3++]
0407A:  MOV     #0,W2
0407C:  MOV     #0,W3
0407E:  CALL    1B2C
04082:  MOV     #0,W4
04084:  REPEAT  #3
04086:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel+1].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1].Y = TabZones[TabIntersection[i_zone]][y4]; 
04088:  MOV     A88,W4
0408A:  ADD     W4,#1,W5
0408C:  MOV     W5,W4
0408E:  MUL.UU  W4,#10,W0
04090:  MOV     W0,W5
04092:  MOV     #AA0,W4
04094:  ADD     W5,W4,W6
04096:  MOV     1B46,W4
04098:  MUL.UU  W4,#2,W0
0409A:  MOV     #A8C,W4
0409C:  ADD     W0,W4,W0
0409E:  MOV     [W0],W7
040A0:  MOV     W7,W4
040A2:  MUL.UU  W4,#10,W0
040A4:  MOV     W0,W7
040A6:  ADD     W7,#8,W0
040A8:  MOV     #B60,W4
040AA:  ADD     W0,W4,W0
040AC:  MOV     W0,W4
040AE:  MOV     #0,W3
040B0:  MOV     [W4++],[W3++]
040B2:  MOV     [W4++],[W3++]
040B4:  MOV     #0,W2
040B6:  MOV     #0,W3
040B8:  CALL    1B2C
040BC:  MOV     #0,W4
040BE:  REPEAT  #3
040C0:  MOV     [W4++],[W6++]
040C2:  MOV     A88,W4
040C4:  ADD     W4,#1,W5
040C6:  MOV     W5,W4
040C8:  MUL.UU  W4,#10,W0
040CA:  MOV     W0,W5
040CC:  ADD     W5,#8,W0
040CE:  MOV     #AA0,W4
040D0:  ADD     W0,W4,W5
040D2:  MOV     1B46,W4
040D4:  MUL.UU  W4,#2,W0
040D6:  MOV     #A8C,W4
040D8:  ADD     W0,W4,W0
040DA:  MOV     [W0],W6
040DC:  MOV     W6,W4
040DE:  MUL.UU  W4,#10,W6
040E0:  ADD     W6,#C,W0
040E2:  MOV     #B60,W4
040E4:  ADD     W0,W4,W0
040E6:  MOV     W0,W4
040E8:  MOV     #0,W3
040EA:  MOV     [W4++],[W3++]
040EC:  MOV     [W4++],[W3++]
040EE:  MOV     #0,W2
040F0:  MOV     #0,W3
040F2:  CALL    1B2C
040F6:  MOV     #0,W4
040F8:  REPEAT  #3
040FA:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
040FC:  MOV     #2,W4
040FE:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
04100:  MOV     #1,W4
04102:  MOV     W4,A84
.................... 	            } 
04104:  GOTO    4186
.................... 	            else if (posEnd == 6 || posEnd == 7) 
04108:  MOV     1B4A,W4
0410A:  CP      W4,#6
0410C:  BRA     Z,4114
0410E:  MOV     1B4A,W4
04110:  CP      W4,#7
04112:  BRA     NZ,4186
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
04114:  MOV     A88,W4
04116:  MUL.UU  W4,#10,W0
04118:  MOV     W0,W5
0411A:  MOV     #AA0,W4
0411C:  ADD     W5,W4,W6
0411E:  MOV     1B46,W4
04120:  MUL.UU  W4,#2,W0
04122:  MOV     #A8C,W4
04124:  ADD     W0,W4,W0
04126:  MOV     [W0],W7
04128:  MOV     W7,W4
0412A:  MUL.UU  W4,#10,W0
0412C:  MOV     W0,W7
0412E:  MOV     #B60,W4
04130:  ADD     W7,W4,W0
04132:  MOV     W0,W4
04134:  MOV     #0,W3
04136:  MOV     [W4++],[W3++]
04138:  MOV     [W4++],[W3++]
0413A:  MOV     #0,W2
0413C:  MOV     #0,W3
0413E:  CALL    1B2C
04142:  MOV     #0,W4
04144:  REPEAT  #3
04146:  MOV     [W4++],[W6++]
04148:  MOV     A88,W4
0414A:  MUL.UU  W4,#10,W0
0414C:  MOV     W0,W5
0414E:  ADD     W5,#8,W0
04150:  MOV     #AA0,W4
04152:  ADD     W0,W4,W5
04154:  MOV     1B46,W4
04156:  MUL.UU  W4,#2,W0
04158:  MOV     #A8C,W4
0415A:  ADD     W0,W4,W0
0415C:  MOV     [W0],W6
0415E:  MOV     W6,W4
04160:  MUL.UU  W4,#10,W6
04162:  ADD     W6,#4,W0
04164:  MOV     #B60,W4
04166:  ADD     W0,W4,W0
04168:  MOV     W0,W4
0416A:  MOV     #0,W3
0416C:  MOV     [W4++],[W3++]
0416E:  MOV     [W4++],[W3++]
04170:  MOV     #0,W2
04172:  MOV     #0,W3
04174:  CALL    1B2C
04178:  MOV     #0,W4
0417A:  REPEAT  #3
0417C:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0417E:  MOV     #1,W4
04180:  MOV     W4,1B4C
.................... 	                path_found = true; 
04182:  MOV     #1,W4
04184:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
04186:  GOTO    66B2
....................  
.................... 	        case 2: 
.................... 	            if (posEnd == 5) 
0418A:  MOV     1B4A,W4
0418C:  CP      W4,#5
0418E:  BRA     NZ,4208
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04190:  MOV     A88,W4
04192:  MUL.UU  W4,#10,W0
04194:  MOV     W0,W5
04196:  MOV     #AA0,W4
04198:  ADD     W5,W4,W6
0419A:  MOV     1B46,W4
0419C:  MUL.UU  W4,#2,W0
0419E:  MOV     #A8C,W4
041A0:  ADD     W0,W4,W0
041A2:  MOV     [W0],W7
041A4:  MOV     W7,W4
041A6:  MUL.UU  W4,#10,W0
041A8:  MOV     W0,W7
041AA:  ADD     W7,#8,W0
041AC:  MOV     #B60,W4
041AE:  ADD     W0,W4,W0
041B0:  MOV     W0,W4
041B2:  MOV     #0,W3
041B4:  MOV     [W4++],[W3++]
041B6:  MOV     [W4++],[W3++]
041B8:  MOV     #0,W2
041BA:  MOV     #0,W3
041BC:  CALL    1B2C
041C0:  MOV     #0,W4
041C2:  REPEAT  #3
041C4:  MOV     [W4++],[W6++]
041C6:  MOV     A88,W4
041C8:  MUL.UU  W4,#10,W0
041CA:  MOV     W0,W5
041CC:  ADD     W5,#8,W0
041CE:  MOV     #AA0,W4
041D0:  ADD     W0,W4,W5
041D2:  MOV     1B46,W4
041D4:  MUL.UU  W4,#2,W0
041D6:  MOV     #A8C,W4
041D8:  ADD     W0,W4,W0
041DA:  MOV     [W0],W6
041DC:  MOV     W6,W4
041DE:  MUL.UU  W4,#10,W6
041E0:  ADD     W6,#C,W0
041E2:  MOV     #B60,W4
041E4:  ADD     W0,W4,W0
041E6:  MOV     W0,W4
041E8:  MOV     #0,W3
041EA:  MOV     [W4++],[W3++]
041EC:  MOV     [W4++],[W3++]
041EE:  MOV     #0,W2
041F0:  MOV     #0,W3
041F2:  CALL    1B2C
041F6:  MOV     #0,W4
041F8:  REPEAT  #3
041FA:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
041FC:  MOV     #1,W4
041FE:  MOV     W4,1B4C
.................... 	                path_found = true; 
04200:  MOV     #1,W4
04202:  MOV     W4,A84
.................... 	            } 
04204:  GOTO    4722
.................... 	            else if (posEnd == 6) 
04208:  MOV     1B4A,W4
0420A:  CP      W4,#6
0420C:  BRA     NZ,46AA
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
0420E:  MOV     1B3E,W0
04210:  CLR     W3
04212:  BTSC    W0.F
04214:  SETM    W3
04216:  MOV     W3,W1
04218:  MOV     W3,W2
0421A:  CALL    1B2C
0421E:  MOV     W0,W5
04220:  MOV     W1,W6
04222:  MOV     W2,W7
04224:  MOV     W3,W8
04226:  MOV     1B40,W0
04228:  CLR     W3
0422A:  BTSC    W0.F
0422C:  SETM    W3
0422E:  MOV     W3,W1
04230:  MOV     W3,W2
04232:  CALL    1B2C
04236:  MOV     W0,W9
04238:  MOV     W1,W10
0423A:  MOV     W2,W11
0423C:  MOV     W3,W12
0423E:  MOV     1B46,W4
04240:  MUL.UU  W4,#2,W0
04242:  MOV     #A8C,W4
04244:  ADD     W0,W4,W0
04246:  MOV     [W0],W13
04248:  MOV     W13,W4
0424A:  MUL.UU  W4,#10,W0
0424C:  MOV     W0,W13
0424E:  MOV     #B60,W4
04250:  ADD     W13,W4,W0
04252:  MOV     W0,W4
04254:  MOV     #0,W3
04256:  MOV     [W4++],[W3++]
04258:  MOV     [W4++],[W3++]
0425A:  MOV     #0,W2
0425C:  MOV     #0,W3
0425E:  CALL    1B2C
04262:  MOV     W0,1B4E
04264:  MOV     W1,1B50
04266:  MOV     W2,1B52
04268:  MOV     W3,1B54
0426A:  MOV     1B46,W4
0426C:  MUL.UU  W4,#2,W0
0426E:  MOV     #A8C,W4
04270:  ADD     W0,W4,W0
04272:  MOV     [W0],[W15++]
04274:  POP     1B56
04276:  MOV     1B56,W4
04278:  MUL.UU  W4,#10,W0
0427A:  MOV     W0,1B56
0427C:  MOV     1B56,W4
0427E:  ADD     W4,#4,W0
04280:  MOV     #B60,W4
04282:  ADD     W0,W4,W0
04284:  MOV     W0,W4
04286:  MOV     #0,W3
04288:  MOV     [W4++],[W3++]
0428A:  MOV     [W4++],[W3++]
0428C:  MOV     #0,W2
0428E:  MOV     #0,W3
04290:  CALL    1B2C
04294:  MOV     W0,1B56
04296:  MOV     W1,1B58
04298:  MOV     W2,1B5A
0429A:  MOV     W3,1B5C
0429C:  MOV     W5,1B82
0429E:  MOV     W6,1B84
042A0:  MOV     W7,1B86
042A2:  MOV     W8,1B88
042A4:  MOV     W9,1B8A
042A6:  MOV     W10,1B8C
042A8:  MOV     W11,1B8E
042AA:  MOV     W12,1B90
042AC:  PUSH    1B4E
042AE:  POP     1B92
042B0:  PUSH    1B50
042B2:  POP     1B94
042B4:  PUSH    1B52
042B6:  POP     1B96
042B8:  PUSH    1B54
042BA:  POP     1B98
042BC:  PUSH    1B56
042BE:  POP     1B9A
042C0:  PUSH    1B58
042C2:  POP     1B9C
042C4:  PUSH    1B5A
042C6:  POP     1B9E
042C8:  PUSH    1B5C
042CA:  POP     1BA0
042CC:  CALL    332C
042D0:  MOV     W0,W5
042D2:  MOV     W1,W6
042D4:  MOV     W2,W7
042D6:  MOV     W3,W8
042D8:  MOV     1B46,W4
042DA:  MUL.UU  W4,#2,W0
042DC:  MOV     #A8C,W4
042DE:  ADD     W0,W4,W0
042E0:  MOV     [W0],W9
042E2:  MOV     W9,W4
042E4:  MUL.UU  W4,#10,W0
042E6:  MOV     W0,W9
042E8:  MOV     #B60,W4
042EA:  ADD     W9,W4,W0
042EC:  MOV     W0,W4
042EE:  MOV     #0,W3
042F0:  MOV     [W4++],[W3++]
042F2:  MOV     [W4++],[W3++]
042F4:  MOV     #0,W2
042F6:  MOV     #0,W3
042F8:  CALL    1B2C
042FC:  MOV     W0,W10
042FE:  MOV     W1,W11
04300:  MOV     W2,W12
04302:  MOV     W3,W13
04304:  MOV     1B46,W4
04306:  MUL.UU  W4,#2,W0
04308:  MOV     #A8C,W4
0430A:  ADD     W0,W4,W0
0430C:  MOV     [W0],[W15++]
0430E:  POP     1B4E
04310:  MOV     1B4E,W4
04312:  MUL.UU  W4,#10,W0
04314:  MOV     W0,1B4E
04316:  MOV     1B4E,W4
04318:  ADD     W4,#4,W0
0431A:  MOV     #B60,W4
0431C:  ADD     W0,W4,W0
0431E:  MOV     W0,W4
04320:  MOV     #0,W3
04322:  MOV     [W4++],[W3++]
04324:  MOV     [W4++],[W3++]
04326:  MOV     #0,W2
04328:  MOV     #0,W3
0432A:  CALL    1B2C
0432E:  MOV     W0,1B4E
04330:  MOV     W1,1B50
04332:  MOV     W2,1B52
04334:  MOV     W3,1B54
04336:  MOV     1B42,W0
04338:  CLR     W3
0433A:  BTSC    W0.F
0433C:  SETM    W3
0433E:  MOV     W3,W1
04340:  MOV     W3,W2
04342:  CALL    1B2C
04346:  MOV     W0,1B56
04348:  MOV     W1,1B58
0434A:  MOV     W2,1B5A
0434C:  MOV     W3,1B5C
0434E:  MOV     1B44,W0
04350:  CLR     W3
04352:  BTSC    W0.F
04354:  SETM    W3
04356:  MOV     W3,W1
04358:  MOV     W3,W2
0435A:  CALL    1B2C
0435E:  MOV     W0,1B5E
04360:  MOV     W1,1B60
04362:  MOV     W2,1B62
04364:  MOV     W3,1B64
04366:  MOV     W10,1B82
04368:  MOV     W11,1B84
0436A:  MOV     W12,1B86
0436C:  MOV     W13,1B88
0436E:  PUSH    1B4E
04370:  POP     1B8A
04372:  PUSH    1B50
04374:  POP     1B8C
04376:  PUSH    1B52
04378:  POP     1B8E
0437A:  PUSH    1B54
0437C:  POP     1B90
0437E:  PUSH    1B56
04380:  POP     1B92
04382:  PUSH    1B58
04384:  POP     1B94
04386:  PUSH    1B5A
04388:  POP     1B96
0438A:  PUSH    1B5C
0438C:  POP     1B98
0438E:  PUSH    1B5E
04390:  POP     1B9A
04392:  PUSH    1B60
04394:  POP     1B9C
04396:  PUSH    1B62
04398:  POP     1B9E
0439A:  PUSH    1B64
0439C:  POP     1BA0
0439E:  CALL    332C
043A2:  BCLR.B  43.0
043A4:  MOV     W5,[W15++]
043A6:  MOV     W6,[W15++]
043A8:  MOV     W7,[W15++]
043AA:  MOV     W0,W4
043AC:  MOV     W5,W0
043AE:  MOV     W1,W5
043B0:  MOV     W6,W1
043B2:  MOV     W2,W6
043B4:  MOV     W7,W2
043B6:  MOV     W3,W7
043B8:  MOV     W8,W3
043BA:  CALL    1C40
043BE:  MOV     [--W15],W7
043C0:  MOV     [--W15],W6
043C2:  MOV     [--W15],W5
043C4:  MOV     W0,W5
043C6:  MOV     W1,W6
043C8:  MOV     W2,W7
043CA:  MOV     W3,W8
043CC:  MOV     1B3E,W0
043CE:  CLR     W3
043D0:  BTSC    W0.F
043D2:  SETM    W3
043D4:  MOV     W3,W1
043D6:  MOV     W3,W2
043D8:  CALL    1B2C
043DC:  MOV     W0,W10
043DE:  MOV     W1,W11
043E0:  MOV     W2,W12
043E2:  MOV     W3,W13
043E4:  MOV     1B40,W0
043E6:  CLR     W3
043E8:  BTSC    W0.F
043EA:  SETM    W3
043EC:  MOV     W3,W1
043EE:  MOV     W3,W2
043F0:  CALL    1B2C
043F4:  MOV     W0,1B4E
043F6:  MOV     W1,1B50
043F8:  MOV     W2,1B52
043FA:  MOV     W3,1B54
043FC:  MOV     1B46,W4
043FE:  MUL.UU  W4,#2,W0
04400:  MOV     #A8C,W4
04402:  ADD     W0,W4,W0
04404:  MOV     [W0],[W15++]
04406:  POP     1B56
04408:  MOV     1B56,W4
0440A:  MUL.UU  W4,#10,W0
0440C:  MOV     W0,1B56
0440E:  MOV     1B56,W4
04410:  ADD     W4,#8,W0
04412:  MOV     #B60,W4
04414:  ADD     W0,W4,W0
04416:  MOV     W0,W4
04418:  MOV     #0,W3
0441A:  MOV     [W4++],[W3++]
0441C:  MOV     [W4++],[W3++]
0441E:  MOV     #0,W2
04420:  MOV     #0,W3
04422:  CALL    1B2C
04426:  MOV     W0,1B56
04428:  MOV     W1,1B58
0442A:  MOV     W2,1B5A
0442C:  MOV     W3,1B5C
0442E:  MOV     1B46,W4
04430:  MUL.UU  W4,#2,W0
04432:  MOV     #A8C,W4
04434:  ADD     W0,W4,W0
04436:  MOV     [W0],[W15++]
04438:  POP     1B5E
0443A:  MOV     1B5E,W4
0443C:  MUL.UU  W4,#10,W0
0443E:  MOV     W0,1B5E
04440:  MOV     1B5E,W4
04442:  ADD     W4,#C,W0
04444:  MOV     #B60,W4
04446:  ADD     W0,W4,W0
04448:  MOV     W0,W4
0444A:  MOV     #0,W3
0444C:  MOV     [W4++],[W3++]
0444E:  MOV     [W4++],[W3++]
04450:  MOV     #0,W2
04452:  MOV     #0,W3
04454:  CALL    1B2C
04458:  MOV     W0,1B5E
0445A:  MOV     W1,1B60
0445C:  MOV     W2,1B62
0445E:  MOV     W3,1B64
04460:  MOV     W10,1B82
04462:  MOV     W11,1B84
04464:  MOV     W12,1B86
04466:  MOV     W13,1B88
04468:  PUSH    1B4E
0446A:  POP     1B8A
0446C:  PUSH    1B50
0446E:  POP     1B8C
04470:  PUSH    1B52
04472:  POP     1B8E
04474:  PUSH    1B54
04476:  POP     1B90
04478:  PUSH    1B56
0447A:  POP     1B92
0447C:  PUSH    1B58
0447E:  POP     1B94
04480:  PUSH    1B5A
04482:  POP     1B96
04484:  PUSH    1B5C
04486:  POP     1B98
04488:  PUSH    1B5E
0448A:  POP     1B9A
0448C:  PUSH    1B60
0448E:  POP     1B9C
04490:  PUSH    1B62
04492:  POP     1B9E
04494:  PUSH    1B64
04496:  POP     1BA0
04498:  CALL    332C
0449C:  MOV     W0,W10
0449E:  MOV     W1,W11
044A0:  MOV     W2,W12
044A2:  MOV     W3,W13
044A4:  MOV     1B46,W4
044A6:  MUL.UU  W4,#2,W0
044A8:  MOV     #A8C,W4
044AA:  ADD     W0,W4,W0
044AC:  MOV     [W0],[W15++]
044AE:  POP     1B4E
044B0:  MOV     1B4E,W4
044B2:  MUL.UU  W4,#10,W0
044B4:  MOV     W0,1B4E
044B6:  MOV     1B4E,W4
044B8:  ADD     W4,#8,W0
044BA:  MOV     #B60,W4
044BC:  ADD     W0,W4,W0
044BE:  MOV     W0,W4
044C0:  MOV     #0,W3
044C2:  MOV     [W4++],[W3++]
044C4:  MOV     [W4++],[W3++]
044C6:  MOV     #0,W2
044C8:  MOV     #0,W3
044CA:  CALL    1B2C
044CE:  MOV     W0,1B4E
044D0:  MOV     W1,1B50
044D2:  MOV     W2,1B52
044D4:  MOV     W3,1B54
044D6:  MOV     1B46,W4
044D8:  MUL.UU  W4,#2,W0
044DA:  MOV     #A8C,W4
044DC:  ADD     W0,W4,W0
044DE:  MOV     [W0],[W15++]
044E0:  POP     1B56
044E2:  MOV     1B56,W4
044E4:  MUL.UU  W4,#10,W0
044E6:  MOV     W0,1B56
044E8:  MOV     1B56,W4
044EA:  ADD     W4,#C,W0
044EC:  MOV     #B60,W4
044EE:  ADD     W0,W4,W0
044F0:  MOV     W0,W4
044F2:  MOV     #0,W3
044F4:  MOV     [W4++],[W3++]
044F6:  MOV     [W4++],[W3++]
044F8:  MOV     #0,W2
044FA:  MOV     #0,W3
044FC:  CALL    1B2C
04500:  MOV     W0,1B56
04502:  MOV     W1,1B58
04504:  MOV     W2,1B5A
04506:  MOV     W3,1B5C
04508:  MOV     1B42,W0
0450A:  CLR     W3
0450C:  BTSC    W0.F
0450E:  SETM    W3
04510:  MOV     W3,W1
04512:  MOV     W3,W2
04514:  CALL    1B2C
04518:  MOV     W0,1B5E
0451A:  MOV     W1,1B60
0451C:  MOV     W2,1B62
0451E:  MOV     W3,1B64
04520:  MOV     1B44,W0
04522:  CLR     W3
04524:  BTSC    W0.F
04526:  SETM    W3
04528:  MOV     W3,W1
0452A:  MOV     W3,W2
0452C:  CALL    1B2C
04530:  MOV     W0,1B66
04532:  MOV     W1,1B68
04534:  MOV     W2,1B6A
04536:  MOV     W3,1B6C
04538:  PUSH    1B4E
0453A:  POP     1B82
0453C:  PUSH    1B50
0453E:  POP     1B84
04540:  PUSH    1B52
04542:  POP     1B86
04544:  PUSH    1B54
04546:  POP     1B88
04548:  PUSH    1B56
0454A:  POP     1B8A
0454C:  PUSH    1B58
0454E:  POP     1B8C
04550:  PUSH    1B5A
04552:  POP     1B8E
04554:  PUSH    1B5C
04556:  POP     1B90
04558:  PUSH    1B5E
0455A:  POP     1B92
0455C:  PUSH    1B60
0455E:  POP     1B94
04560:  PUSH    1B62
04562:  POP     1B96
04564:  PUSH    1B64
04566:  POP     1B98
04568:  PUSH    1B66
0456A:  POP     1B9A
0456C:  PUSH    1B68
0456E:  POP     1B9C
04570:  PUSH    1B6A
04572:  POP     1B9E
04574:  PUSH    1B6C
04576:  POP     1BA0
04578:  CALL    332C
0457C:  BCLR.B  43.0
0457E:  MOV     W5,[W15++]
04580:  MOV     W6,[W15++]
04582:  MOV     W7,[W15++]
04584:  MOV     W0,W4
04586:  MOV     W1,W5
04588:  MOV     W2,W6
0458A:  MOV     W3,W7
0458C:  MOV     W10,W0
0458E:  MOV     W11,W1
04590:  MOV     W12,W2
04592:  MOV     W13,W3
04594:  CALL    1C40
04598:  MOV     [--W15],W7
0459A:  MOV     [--W15],W6
0459C:  MOV     [--W15],W5
0459E:  MOV     W5,[W15++]
045A0:  MOV     W6,[W15++]
045A2:  MOV     W7,[W15++]
045A4:  MOV     W0,W4
045A6:  MOV     W5,W0
045A8:  MOV     W1,W5
045AA:  MOV     W6,W1
045AC:  MOV     W2,W6
045AE:  MOV     W7,W2
045B0:  MOV     W3,W7
045B2:  MOV     W8,W3
045B4:  CALL    1E2E
045B8:  MOV     [--W15],W7
045BA:  MOV     [--W15],W6
045BC:  MOV     [--W15],W5
045BE:  BRA     NC,4632
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
045C0:  MOV     A88,W4
045C2:  MUL.UU  W4,#10,W0
045C4:  MOV     W0,W5
045C6:  MOV     #AA0,W4
045C8:  ADD     W5,W4,W6
045CA:  MOV     1B46,W4
045CC:  MUL.UU  W4,#2,W0
045CE:  MOV     #A8C,W4
045D0:  ADD     W0,W4,W0
045D2:  MOV     [W0],W7
045D4:  MOV     W7,W4
045D6:  MUL.UU  W4,#10,W0
045D8:  MOV     W0,W7
045DA:  MOV     #B60,W4
045DC:  ADD     W7,W4,W0
045DE:  MOV     W0,W4
045E0:  MOV     #0,W3
045E2:  MOV     [W4++],[W3++]
045E4:  MOV     [W4++],[W3++]
045E6:  MOV     #0,W2
045E8:  MOV     #0,W3
045EA:  CALL    1B2C
045EE:  MOV     #0,W4
045F0:  REPEAT  #3
045F2:  MOV     [W4++],[W6++]
045F4:  MOV     A88,W4
045F6:  MUL.UU  W4,#10,W0
045F8:  MOV     W0,W5
045FA:  ADD     W5,#8,W0
045FC:  MOV     #AA0,W4
045FE:  ADD     W0,W4,W5
04600:  MOV     1B46,W4
04602:  MUL.UU  W4,#2,W0
04604:  MOV     #A8C,W4
04606:  ADD     W0,W4,W0
04608:  MOV     [W0],W6
0460A:  MOV     W6,W4
0460C:  MUL.UU  W4,#10,W6
0460E:  ADD     W6,#4,W0
04610:  MOV     #B60,W4
04612:  ADD     W0,W4,W0
04614:  MOV     W0,W4
04616:  MOV     #0,W3
04618:  MOV     [W4++],[W3++]
0461A:  MOV     [W4++],[W3++]
0461C:  MOV     #0,W2
0461E:  MOV     #0,W3
04620:  CALL    1B2C
04624:  MOV     #0,W4
04626:  REPEAT  #3
04628:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
0462A:  MOV     #1,W4
0462C:  MOV     W4,1B4C
.................... 	                } 
0462E:  GOTO    46A2
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04632:  MOV     A88,W4
04634:  MUL.UU  W4,#10,W0
04636:  MOV     W0,W5
04638:  MOV     #AA0,W4
0463A:  ADD     W5,W4,W6
0463C:  MOV     1B46,W4
0463E:  MUL.UU  W4,#2,W0
04640:  MOV     #A8C,W4
04642:  ADD     W0,W4,W0
04644:  MOV     [W0],W7
04646:  MOV     W7,W4
04648:  MUL.UU  W4,#10,W0
0464A:  MOV     W0,W7
0464C:  ADD     W7,#8,W0
0464E:  MOV     #B60,W4
04650:  ADD     W0,W4,W0
04652:  MOV     W0,W4
04654:  MOV     #0,W3
04656:  MOV     [W4++],[W3++]
04658:  MOV     [W4++],[W3++]
0465A:  MOV     #0,W2
0465C:  MOV     #0,W3
0465E:  CALL    1B2C
04662:  MOV     #0,W4
04664:  REPEAT  #3
04666:  MOV     [W4++],[W6++]
04668:  MOV     A88,W4
0466A:  MUL.UU  W4,#10,W0
0466C:  MOV     W0,W5
0466E:  ADD     W5,#8,W0
04670:  MOV     #AA0,W4
04672:  ADD     W0,W4,W5
04674:  MOV     1B46,W4
04676:  MUL.UU  W4,#2,W0
04678:  MOV     #A8C,W4
0467A:  ADD     W0,W4,W0
0467C:  MOV     [W0],W6
0467E:  MOV     W6,W4
04680:  MUL.UU  W4,#10,W6
04682:  ADD     W6,#C,W0
04684:  MOV     #B60,W4
04686:  ADD     W0,W4,W0
04688:  MOV     W0,W4
0468A:  MOV     #0,W3
0468C:  MOV     [W4++],[W3++]
0468E:  MOV     [W4++],[W3++]
04690:  MOV     #0,W2
04692:  MOV     #0,W3
04694:  CALL    1B2C
04698:  MOV     #0,W4
0469A:  REPEAT  #3
0469C:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
0469E:  MOV     #1,W4
046A0:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
046A2:  MOV     #1,W4
046A4:  MOV     W4,A84
.................... 	            } 
046A6:  GOTO    4722
.................... 	            else if (posEnd == 7) 
046AA:  MOV     1B4A,W4
046AC:  CP      W4,#7
046AE:  BRA     NZ,4722
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
046B0:  MOV     A88,W4
046B2:  MUL.UU  W4,#10,W0
046B4:  MOV     W0,W5
046B6:  MOV     #AA0,W4
046B8:  ADD     W5,W4,W6
046BA:  MOV     1B46,W4
046BC:  MUL.UU  W4,#2,W0
046BE:  MOV     #A8C,W4
046C0:  ADD     W0,W4,W0
046C2:  MOV     [W0],W7
046C4:  MOV     W7,W4
046C6:  MUL.UU  W4,#10,W0
046C8:  MOV     W0,W7
046CA:  MOV     #B60,W4
046CC:  ADD     W7,W4,W0
046CE:  MOV     W0,W4
046D0:  MOV     #0,W3
046D2:  MOV     [W4++],[W3++]
046D4:  MOV     [W4++],[W3++]
046D6:  MOV     #0,W2
046D8:  MOV     #0,W3
046DA:  CALL    1B2C
046DE:  MOV     #0,W4
046E0:  REPEAT  #3
046E2:  MOV     [W4++],[W6++]
046E4:  MOV     A88,W4
046E6:  MUL.UU  W4,#10,W0
046E8:  MOV     W0,W5
046EA:  ADD     W5,#8,W0
046EC:  MOV     #AA0,W4
046EE:  ADD     W0,W4,W5
046F0:  MOV     1B46,W4
046F2:  MUL.UU  W4,#2,W0
046F4:  MOV     #A8C,W4
046F6:  ADD     W0,W4,W0
046F8:  MOV     [W0],W6
046FA:  MOV     W6,W4
046FC:  MUL.UU  W4,#10,W6
046FE:  ADD     W6,#4,W0
04700:  MOV     #B60,W4
04702:  ADD     W0,W4,W0
04704:  MOV     W0,W4
04706:  MOV     #0,W3
04708:  MOV     [W4++],[W3++]
0470A:  MOV     [W4++],[W3++]
0470C:  MOV     #0,W2
0470E:  MOV     #0,W3
04710:  CALL    1B2C
04714:  MOV     #0,W4
04716:  REPEAT  #3
04718:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0471A:  MOV     #1,W4
0471C:  MOV     W4,1B4C
.................... 	                path_found = true; 
0471E:  MOV     #1,W4
04720:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
04722:  GOTO    66B2
....................  
.................... 	        case 3: 
.................... 	            if (posEnd == 5 || posEnd == 6) 
04726:  MOV     1B4A,W4
04728:  CP      W4,#5
0472A:  BRA     Z,4732
0472C:  MOV     1B4A,W4
0472E:  CP      W4,#6
04730:  BRA     NZ,47AA
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04732:  MOV     A88,W4
04734:  MUL.UU  W4,#10,W0
04736:  MOV     W0,W5
04738:  MOV     #AA0,W4
0473A:  ADD     W5,W4,W6
0473C:  MOV     1B46,W4
0473E:  MUL.UU  W4,#2,W0
04740:  MOV     #A8C,W4
04742:  ADD     W0,W4,W0
04744:  MOV     [W0],W7
04746:  MOV     W7,W4
04748:  MUL.UU  W4,#10,W0
0474A:  MOV     W0,W7
0474C:  ADD     W7,#8,W0
0474E:  MOV     #B60,W4
04750:  ADD     W0,W4,W0
04752:  MOV     W0,W4
04754:  MOV     #0,W3
04756:  MOV     [W4++],[W3++]
04758:  MOV     [W4++],[W3++]
0475A:  MOV     #0,W2
0475C:  MOV     #0,W3
0475E:  CALL    1B2C
04762:  MOV     #0,W4
04764:  REPEAT  #3
04766:  MOV     [W4++],[W6++]
04768:  MOV     A88,W4
0476A:  MUL.UU  W4,#10,W0
0476C:  MOV     W0,W5
0476E:  ADD     W5,#8,W0
04770:  MOV     #AA0,W4
04772:  ADD     W0,W4,W5
04774:  MOV     1B46,W4
04776:  MUL.UU  W4,#2,W0
04778:  MOV     #A8C,W4
0477A:  ADD     W0,W4,W0
0477C:  MOV     [W0],W6
0477E:  MOV     W6,W4
04780:  MUL.UU  W4,#10,W6
04782:  ADD     W6,#C,W0
04784:  MOV     #B60,W4
04786:  ADD     W0,W4,W0
04788:  MOV     W0,W4
0478A:  MOV     #0,W3
0478C:  MOV     [W4++],[W3++]
0478E:  MOV     [W4++],[W3++]
04790:  MOV     #0,W2
04792:  MOV     #0,W3
04794:  CALL    1B2C
04798:  MOV     #0,W4
0479A:  REPEAT  #3
0479C:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0479E:  MOV     #1,W4
047A0:  MOV     W4,1B4C
.................... 	                path_found = true; 
047A2:  MOV     #1,W4
047A4:  MOV     W4,A84
.................... 	            } 
047A6:  GOTO    4DD6
.................... 	            else if (posEnd == 7) 
047AA:  MOV     1B4A,W4
047AC:  CP      W4,#7
047AE:  BRA     NZ,4D50
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
047B0:  MOV     1B3E,W0
047B2:  CLR     W3
047B4:  BTSC    W0.F
047B6:  SETM    W3
047B8:  MOV     W3,W1
047BA:  MOV     W3,W2
047BC:  CALL    1B2C
047C0:  MOV     W0,W5
047C2:  MOV     W1,W6
047C4:  MOV     W2,W7
047C6:  MOV     W3,W8
047C8:  MOV     1B40,W0
047CA:  CLR     W3
047CC:  BTSC    W0.F
047CE:  SETM    W3
047D0:  MOV     W3,W1
047D2:  MOV     W3,W2
047D4:  CALL    1B2C
047D8:  MOV     W0,W9
047DA:  MOV     W1,W10
047DC:  MOV     W2,W11
047DE:  MOV     W3,W12
047E0:  MOV     1B46,W4
047E2:  MUL.UU  W4,#2,W0
047E4:  MOV     #A8C,W4
047E6:  ADD     W0,W4,W0
047E8:  MOV     [W0],W13
047EA:  MOV     W13,W4
047EC:  MUL.UU  W4,#10,W0
047EE:  MOV     W0,W13
047F0:  MOV     1B2A,W4
047F2:  MUL.UU  W4,#4,W0
047F4:  ADD     W0,W13,W0
047F6:  MOV     #B60,W4
047F8:  ADD     W0,W4,W0
047FA:  MOV     W0,W4
047FC:  MOV     #0,W3
047FE:  MOV     [W4++],[W3++]
04800:  MOV     [W4++],[W3++]
04802:  MOV     #0,W2
04804:  MOV     #0,W3
04806:  CALL    1B2C
0480A:  MOV     W0,W13
0480C:  MOV     W1,W14
0480E:  MOV     W2,W15
04810:  MOV     W3,[W0]
04812:  MOV     1B46,W4
04814:  MUL.UU  W4,#2,W0
04816:  MOV     #A8C,W4
04818:  ADD     W0,W4,W0
0481A:  MOV     [W0],[W15++]
0481C:  POP     1B54
0481E:  MOV     1B54,W4
04820:  MUL.UU  W4,#10,W0
04822:  MOV     W0,1B54
04824:  MOV     1B2C,W4
04826:  MUL.UU  W4,#4,W0
04828:  MOV     1B54,W4
0482A:  ADD     W0,W4,W0
0482C:  MOV     #B60,W4
0482E:  ADD     W0,W4,W0
04830:  MOV     W0,W4
04832:  MOV     #0,W3
04834:  MOV     [W4++],[W3++]
04836:  MOV     [W4++],[W3++]
04838:  MOV     #0,W2
0483A:  MOV     #0,W3
0483C:  CALL    1B2C
04840:  MOV     W0,1B54
04842:  MOV     W1,1B56
04844:  MOV     W2,1B58
04846:  MOV     W3,1B5A
04848:  MOV     W5,1B82
0484A:  MOV     W6,1B84
0484C:  MOV     W7,1B86
0484E:  MOV     W8,1B88
04850:  MOV     W9,1B8A
04852:  MOV     W10,1B8C
04854:  MOV     W11,1B8E
04856:  MOV     W12,1B90
04858:  MOV     W13,1B92
0485A:  MOV     W14,1B94
0485C:  MOV     W15,1B96
0485E:  MOV     [W0],[W15++]
04860:  POP     1B98
04862:  PUSH    1B54
04864:  POP     1B9A
04866:  PUSH    1B56
04868:  POP     1B9C
0486A:  PUSH    1B58
0486C:  POP     1B9E
0486E:  PUSH    1B5A
04870:  POP     1BA0
04872:  CALL    332C
04876:  MOV     W0,W5
04878:  MOV     W1,W6
0487A:  MOV     W2,W7
0487C:  MOV     W3,W8
0487E:  MOV     1B46,W4
04880:  MUL.UU  W4,#2,W0
04882:  MOV     #A8C,W4
04884:  ADD     W0,W4,W0
04886:  MOV     [W0],W9
04888:  MOV     W9,W4
0488A:  MUL.UU  W4,#10,W0
0488C:  MOV     W0,W9
0488E:  MOV     #B60,W4
04890:  ADD     W9,W4,W0
04892:  MOV     W0,W4
04894:  MOV     #0,W3
04896:  MOV     [W4++],[W3++]
04898:  MOV     [W4++],[W3++]
0489A:  MOV     #0,W2
0489C:  MOV     #0,W3
0489E:  CALL    1B2C
048A2:  MOV     W0,W10
048A4:  MOV     W1,W11
048A6:  MOV     W2,W12
048A8:  MOV     W3,W13
048AA:  MOV     1B46,W4
048AC:  MUL.UU  W4,#2,W0
048AE:  MOV     #A8C,W4
048B0:  ADD     W0,W4,W0
048B2:  MOV     [W0],[W15++]
048B4:  POP     1B4E
048B6:  MOV     1B4E,W4
048B8:  MUL.UU  W4,#10,W0
048BA:  MOV     W0,1B4E
048BC:  MOV     1B4E,W4
048BE:  ADD     W4,#4,W0
048C0:  MOV     #B60,W4
048C2:  ADD     W0,W4,W0
048C4:  MOV     W0,W4
048C6:  MOV     #0,W3
048C8:  MOV     [W4++],[W3++]
048CA:  MOV     [W4++],[W3++]
048CC:  MOV     #0,W2
048CE:  MOV     #0,W3
048D0:  CALL    1B2C
048D4:  MOV     W0,1B4E
048D6:  MOV     W1,1B50
048D8:  MOV     W2,1B52
048DA:  MOV     W3,1B54
048DC:  MOV     1B42,W0
048DE:  CLR     W3
048E0:  BTSC    W0.F
048E2:  SETM    W3
048E4:  MOV     W3,W1
048E6:  MOV     W3,W2
048E8:  CALL    1B2C
048EC:  MOV     W0,1B56
048EE:  MOV     W1,1B58
048F0:  MOV     W2,1B5A
048F2:  MOV     W3,1B5C
048F4:  MOV     1B44,W0
048F6:  CLR     W3
048F8:  BTSC    W0.F
048FA:  SETM    W3
048FC:  MOV     W3,W1
048FE:  MOV     W3,W2
04900:  CALL    1B2C
04904:  MOV     W0,1B5E
04906:  MOV     W1,1B60
04908:  MOV     W2,1B62
0490A:  MOV     W3,1B64
0490C:  MOV     W10,1B82
0490E:  MOV     W11,1B84
04910:  MOV     W12,1B86
04912:  MOV     W13,1B88
04914:  PUSH    1B4E
04916:  POP     1B8A
04918:  PUSH    1B50
0491A:  POP     1B8C
0491C:  PUSH    1B52
0491E:  POP     1B8E
04920:  PUSH    1B54
04922:  POP     1B90
04924:  PUSH    1B56
04926:  POP     1B92
04928:  PUSH    1B58
0492A:  POP     1B94
0492C:  PUSH    1B5A
0492E:  POP     1B96
04930:  PUSH    1B5C
04932:  POP     1B98
04934:  PUSH    1B5E
04936:  POP     1B9A
04938:  PUSH    1B60
0493A:  POP     1B9C
0493C:  PUSH    1B62
0493E:  POP     1B9E
04940:  PUSH    1B64
04942:  POP     1BA0
04944:  CALL    332C
04948:  BCLR.B  43.0
0494A:  MOV     W5,[W15++]
0494C:  MOV     W6,[W15++]
0494E:  MOV     W7,[W15++]
04950:  MOV     W0,W4
04952:  MOV     W5,W0
04954:  MOV     W1,W5
04956:  MOV     W6,W1
04958:  MOV     W2,W6
0495A:  MOV     W7,W2
0495C:  MOV     W3,W7
0495E:  MOV     W8,W3
04960:  CALL    1C40
04964:  MOV     [--W15],W7
04966:  MOV     [--W15],W6
04968:  MOV     [--W15],W5
0496A:  MOV     W0,W5
0496C:  MOV     W1,W6
0496E:  MOV     W2,W7
04970:  MOV     W3,W8
04972:  MOV     1B3E,W0
04974:  CLR     W3
04976:  BTSC    W0.F
04978:  SETM    W3
0497A:  MOV     W3,W1
0497C:  MOV     W3,W2
0497E:  CALL    1B2C
04982:  MOV     W0,W10
04984:  MOV     W1,W11
04986:  MOV     W2,W12
04988:  MOV     W3,W13
0498A:  MOV     1B40,W0
0498C:  CLR     W3
0498E:  BTSC    W0.F
04990:  SETM    W3
04992:  MOV     W3,W1
04994:  MOV     W3,W2
04996:  CALL    1B2C
0499A:  MOV     W0,1B4E
0499C:  MOV     W1,1B50
0499E:  MOV     W2,1B52
049A0:  MOV     W3,1B54
049A2:  MOV     1B46,W4
049A4:  MUL.UU  W4,#2,W0
049A6:  MOV     #A8C,W4
049A8:  ADD     W0,W4,W0
049AA:  MOV     [W0],[W15++]
049AC:  POP     1B56
049AE:  MOV     1B56,W4
049B0:  MUL.UU  W4,#10,W0
049B2:  MOV     W0,1B56
049B4:  MOV     1B56,W4
049B6:  ADD     W4,#8,W0
049B8:  MOV     #B60,W4
049BA:  ADD     W0,W4,W0
049BC:  MOV     W0,W4
049BE:  MOV     #0,W3
049C0:  MOV     [W4++],[W3++]
049C2:  MOV     [W4++],[W3++]
049C4:  MOV     #0,W2
049C6:  MOV     #0,W3
049C8:  CALL    1B2C
049CC:  MOV     W0,1B56
049CE:  MOV     W1,1B58
049D0:  MOV     W2,1B5A
049D2:  MOV     W3,1B5C
049D4:  MOV     1B46,W4
049D6:  MUL.UU  W4,#2,W0
049D8:  MOV     #A8C,W4
049DA:  ADD     W0,W4,W0
049DC:  MOV     [W0],[W15++]
049DE:  POP     1B5E
049E0:  MOV     1B5E,W4
049E2:  MUL.UU  W4,#10,W0
049E4:  MOV     W0,1B5E
049E6:  MOV     1B5E,W4
049E8:  ADD     W4,#C,W0
049EA:  MOV     #B60,W4
049EC:  ADD     W0,W4,W0
049EE:  MOV     W0,W4
049F0:  MOV     #0,W3
049F2:  MOV     [W4++],[W3++]
049F4:  MOV     [W4++],[W3++]
049F6:  MOV     #0,W2
049F8:  MOV     #0,W3
049FA:  CALL    1B2C
049FE:  MOV     W0,1B5E
04A00:  MOV     W1,1B60
04A02:  MOV     W2,1B62
04A04:  MOV     W3,1B64
04A06:  MOV     W10,1B82
04A08:  MOV     W11,1B84
04A0A:  MOV     W12,1B86
04A0C:  MOV     W13,1B88
04A0E:  PUSH    1B4E
04A10:  POP     1B8A
04A12:  PUSH    1B50
04A14:  POP     1B8C
04A16:  PUSH    1B52
04A18:  POP     1B8E
04A1A:  PUSH    1B54
04A1C:  POP     1B90
04A1E:  PUSH    1B56
04A20:  POP     1B92
04A22:  PUSH    1B58
04A24:  POP     1B94
04A26:  PUSH    1B5A
04A28:  POP     1B96
04A2A:  PUSH    1B5C
04A2C:  POP     1B98
04A2E:  PUSH    1B5E
04A30:  POP     1B9A
04A32:  PUSH    1B60
04A34:  POP     1B9C
04A36:  PUSH    1B62
04A38:  POP     1B9E
04A3A:  PUSH    1B64
04A3C:  POP     1BA0
04A3E:  CALL    332C
04A42:  MOV     W0,W10
04A44:  MOV     W1,W11
04A46:  MOV     W2,W12
04A48:  MOV     W3,W13
04A4A:  MOV     1B46,W4
04A4C:  MUL.UU  W4,#2,W0
04A4E:  MOV     #A8C,W4
04A50:  ADD     W0,W4,W0
04A52:  MOV     [W0],[W15++]
04A54:  POP     1B4E
04A56:  MOV     1B4E,W4
04A58:  MUL.UU  W4,#10,W0
04A5A:  MOV     W0,1B4E
04A5C:  MOV     1B26,W4
04A5E:  MUL.UU  W4,#4,W0
04A60:  MOV     1B4E,W4
04A62:  ADD     W0,W4,W0
04A64:  MOV     #B60,W4
04A66:  ADD     W0,W4,W0
04A68:  MOV     W0,W4
04A6A:  MOV     #0,W3
04A6C:  MOV     [W4++],[W3++]
04A6E:  MOV     [W4++],[W3++]
04A70:  MOV     #0,W2
04A72:  MOV     #0,W3
04A74:  CALL    1B2C
04A78:  MOV     W0,1B4E
04A7A:  MOV     W1,1B50
04A7C:  MOV     W2,1B52
04A7E:  MOV     W3,1B54
04A80:  MOV     1B46,W4
04A82:  MUL.UU  W4,#2,W0
04A84:  MOV     #A8C,W4
04A86:  ADD     W0,W4,W0
04A88:  MOV     [W0],[W15++]
04A8A:  POP     1B56
04A8C:  MOV     1B56,W4
04A8E:  MUL.UU  W4,#10,W0
04A90:  MOV     W0,1B56
04A92:  MOV     1B28,W4
04A94:  MUL.UU  W4,#4,W0
04A96:  MOV     1B56,W4
04A98:  ADD     W0,W4,W0
04A9A:  MOV     #B60,W4
04A9C:  ADD     W0,W4,W0
04A9E:  MOV     W0,W4
04AA0:  MOV     #0,W3
04AA2:  MOV     [W4++],[W3++]
04AA4:  MOV     [W4++],[W3++]
04AA6:  MOV     #0,W2
04AA8:  MOV     #0,W3
04AAA:  CALL    1B2C
04AAE:  MOV     W0,1B56
04AB0:  MOV     W1,1B58
04AB2:  MOV     W2,1B5A
04AB4:  MOV     W3,1B5C
04AB6:  MOV     1B42,W0
04AB8:  CLR     W3
04ABA:  BTSC    W0.F
04ABC:  SETM    W3
04ABE:  MOV     W3,W1
04AC0:  MOV     W3,W2
04AC2:  CALL    1B2C
04AC6:  MOV     W0,1B5E
04AC8:  MOV     W1,1B60
04ACA:  MOV     W2,1B62
04ACC:  MOV     W3,1B64
04ACE:  MOV     1B44,W0
04AD0:  CLR     W3
04AD2:  BTSC    W0.F
04AD4:  SETM    W3
04AD6:  MOV     W3,W1
04AD8:  MOV     W3,W2
04ADA:  CALL    1B2C
04ADE:  MOV     W0,1B66
04AE0:  MOV     W1,1B68
04AE2:  MOV     W2,1B6A
04AE4:  MOV     W3,1B6C
04AE6:  PUSH    1B4E
04AE8:  POP     1B82
04AEA:  PUSH    1B50
04AEC:  POP     1B84
04AEE:  PUSH    1B52
04AF0:  POP     1B86
04AF2:  PUSH    1B54
04AF4:  POP     1B88
04AF6:  PUSH    1B56
04AF8:  POP     1B8A
04AFA:  PUSH    1B58
04AFC:  POP     1B8C
04AFE:  PUSH    1B5A
04B00:  POP     1B8E
04B02:  PUSH    1B5C
04B04:  POP     1B90
04B06:  PUSH    1B5E
04B08:  POP     1B92
04B0A:  PUSH    1B60
04B0C:  POP     1B94
04B0E:  PUSH    1B62
04B10:  POP     1B96
04B12:  PUSH    1B64
04B14:  POP     1B98
04B16:  PUSH    1B66
04B18:  POP     1B9A
04B1A:  PUSH    1B68
04B1C:  POP     1B9C
04B1E:  PUSH    1B6A
04B20:  POP     1B9E
04B22:  PUSH    1B6C
04B24:  POP     1BA0
04B26:  CALL    332C
04B2A:  BCLR.B  43.0
04B2C:  MOV     W5,[W15++]
04B2E:  MOV     W6,[W15++]
04B30:  MOV     W7,[W15++]
04B32:  MOV     W0,W4
04B34:  MOV     W1,W5
04B36:  MOV     W2,W6
04B38:  MOV     W3,W7
04B3A:  MOV     W10,W0
04B3C:  MOV     W11,W1
04B3E:  MOV     W12,W2
04B40:  MOV     W13,W3
04B42:  CALL    1C40
04B46:  MOV     [--W15],W7
04B48:  MOV     [--W15],W6
04B4A:  MOV     [--W15],W5
04B4C:  MOV     W5,[W15++]
04B4E:  MOV     W6,[W15++]
04B50:  MOV     W7,[W15++]
04B52:  MOV     W0,W4
04B54:  MOV     W5,W0
04B56:  MOV     W1,W5
04B58:  MOV     W6,W1
04B5A:  MOV     W2,W6
04B5C:  MOV     W7,W2
04B5E:  MOV     W3,W7
04B60:  MOV     W8,W3
04B62:  CALL    1E2E
04B66:  MOV     [--W15],W7
04B68:  MOV     [--W15],W6
04B6A:  MOV     [--W15],W5
04B6C:  BRA     NC,4C5C
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
04B6E:  MOV     A88,W4
04B70:  MUL.UU  W4,#10,W0
04B72:  MOV     W0,W5
04B74:  MOV     #AA0,W4
04B76:  ADD     W5,W4,W6
04B78:  MOV     1B46,W4
04B7A:  MUL.UU  W4,#2,W0
04B7C:  MOV     #A8C,W4
04B7E:  ADD     W0,W4,W0
04B80:  MOV     [W0],W7
04B82:  MOV     W7,W4
04B84:  MUL.UU  W4,#10,W0
04B86:  MOV     W0,W7
04B88:  MOV     1B2A,W4
04B8A:  MUL.UU  W4,#4,W0
04B8C:  ADD     W0,W7,W0
04B8E:  MOV     #B60,W4
04B90:  ADD     W0,W4,W0
04B92:  MOV     W0,W4
04B94:  MOV     #0,W3
04B96:  MOV     [W4++],[W3++]
04B98:  MOV     [W4++],[W3++]
04B9A:  MOV     #0,W2
04B9C:  MOV     #0,W3
04B9E:  CALL    1B2C
04BA2:  MOV     #0,W4
04BA4:  REPEAT  #3
04BA6:  MOV     [W4++],[W6++]
04BA8:  MOV     A88,W4
04BAA:  MUL.UU  W4,#10,W0
04BAC:  MOV     W0,W5
04BAE:  ADD     W5,#8,W0
04BB0:  MOV     #AA0,W4
04BB2:  ADD     W0,W4,W5
04BB4:  MOV     1B46,W4
04BB6:  MUL.UU  W4,#2,W0
04BB8:  MOV     #A8C,W4
04BBA:  ADD     W0,W4,W0
04BBC:  MOV     [W0],W6
04BBE:  MOV     W6,W4
04BC0:  MUL.UU  W4,#10,W6
04BC2:  MOV     1B2C,W4
04BC4:  MUL.UU  W4,#4,W0
04BC6:  ADD     W0,W6,W0
04BC8:  MOV     #B60,W4
04BCA:  ADD     W0,W4,W0
04BCC:  MOV     W0,W4
04BCE:  MOV     #0,W3
04BD0:  MOV     [W4++],[W3++]
04BD2:  MOV     [W4++],[W3++]
04BD4:  MOV     #0,W2
04BD6:  MOV     #0,W3
04BD8:  CALL    1B2C
04BDC:  MOV     #0,W4
04BDE:  REPEAT  #3
04BE0:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y1]; 
04BE2:  MOV     A88,W4
04BE4:  ADD     W4,#1,W5
04BE6:  MOV     W5,W4
04BE8:  MUL.UU  W4,#10,W0
04BEA:  MOV     W0,W5
04BEC:  MOV     #AA0,W4
04BEE:  ADD     W5,W4,W6
04BF0:  MOV     1B46,W4
04BF2:  MUL.UU  W4,#2,W0
04BF4:  MOV     #A8C,W4
04BF6:  ADD     W0,W4,W0
04BF8:  MOV     [W0],W7
04BFA:  MOV     W7,W4
04BFC:  MUL.UU  W4,#10,W0
04BFE:  MOV     W0,W7
04C00:  MOV     #B60,W4
04C02:  ADD     W7,W4,W0
04C04:  MOV     W0,W4
04C06:  MOV     #0,W3
04C08:  MOV     [W4++],[W3++]
04C0A:  MOV     [W4++],[W3++]
04C0C:  MOV     #0,W2
04C0E:  MOV     #0,W3
04C10:  CALL    1B2C
04C14:  MOV     #0,W4
04C16:  REPEAT  #3
04C18:  MOV     [W4++],[W6++]
04C1A:  MOV     A88,W4
04C1C:  ADD     W4,#1,W5
04C1E:  MOV     W5,W4
04C20:  MUL.UU  W4,#10,W0
04C22:  MOV     W0,W5
04C24:  ADD     W5,#8,W0
04C26:  MOV     #AA0,W4
04C28:  ADD     W0,W4,W5
04C2A:  MOV     1B46,W4
04C2C:  MUL.UU  W4,#2,W0
04C2E:  MOV     #A8C,W4
04C30:  ADD     W0,W4,W0
04C32:  MOV     [W0],W6
04C34:  MOV     W6,W4
04C36:  MUL.UU  W4,#10,W6
04C38:  ADD     W6,#4,W0
04C3A:  MOV     #B60,W4
04C3C:  ADD     W0,W4,W0
04C3E:  MOV     W0,W4
04C40:  MOV     #0,W3
04C42:  MOV     [W4++],[W3++]
04C44:  MOV     [W4++],[W3++]
04C46:  MOV     #0,W2
04C48:  MOV     #0,W3
04C4A:  CALL    1B2C
04C4E:  MOV     #0,W4
04C50:  REPEAT  #3
04C52:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
04C54:  MOV     #2,W4
04C56:  MOV     W4,1B4C
.................... 	                } 
04C58:  GOTO    4D48
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
04C5C:  MOV     A88,W4
04C5E:  MUL.UU  W4,#10,W0
04C60:  MOV     W0,W5
04C62:  MOV     #AA0,W4
04C64:  ADD     W5,W4,W6
04C66:  MOV     1B46,W4
04C68:  MUL.UU  W4,#2,W0
04C6A:  MOV     #A8C,W4
04C6C:  ADD     W0,W4,W0
04C6E:  MOV     [W0],W7
04C70:  MOV     W7,W4
04C72:  MUL.UU  W4,#10,W0
04C74:  MOV     W0,W7
04C76:  ADD     W7,#8,W0
04C78:  MOV     #B60,W4
04C7A:  ADD     W0,W4,W0
04C7C:  MOV     W0,W4
04C7E:  MOV     #0,W3
04C80:  MOV     [W4++],[W3++]
04C82:  MOV     [W4++],[W3++]
04C84:  MOV     #0,W2
04C86:  MOV     #0,W3
04C88:  CALL    1B2C
04C8C:  MOV     #0,W4
04C8E:  REPEAT  #3
04C90:  MOV     [W4++],[W6++]
04C92:  MOV     A88,W4
04C94:  MUL.UU  W4,#10,W0
04C96:  MOV     W0,W5
04C98:  ADD     W5,#8,W0
04C9A:  MOV     #AA0,W4
04C9C:  ADD     W0,W4,W5
04C9E:  MOV     1B46,W4
04CA0:  MUL.UU  W4,#2,W0
04CA2:  MOV     #A8C,W4
04CA4:  ADD     W0,W4,W0
04CA6:  MOV     [W0],W6
04CA8:  MOV     W6,W4
04CAA:  MUL.UU  W4,#10,W6
04CAC:  ADD     W6,#C,W0
04CAE:  MOV     #B60,W4
04CB0:  ADD     W0,W4,W0
04CB2:  MOV     W0,W4
04CB4:  MOV     #0,W3
04CB6:  MOV     [W4++],[W3++]
04CB8:  MOV     [W4++],[W3++]
04CBA:  MOV     #0,W2
04CBC:  MOV     #0,W3
04CBE:  CALL    1B2C
04CC2:  MOV     #0,W4
04CC4:  REPEAT  #3
04CC6:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3]; 
04CC8:  MOV     A88,W4
04CCA:  ADD     W4,#1,W5
04CCC:  MOV     W5,W4
04CCE:  MUL.UU  W4,#10,W0
04CD0:  MOV     W0,W5
04CD2:  MOV     #AA0,W4
04CD4:  ADD     W5,W4,W6
04CD6:  MOV     1B46,W4
04CD8:  MUL.UU  W4,#2,W0
04CDA:  MOV     #A8C,W4
04CDC:  ADD     W0,W4,W0
04CDE:  MOV     [W0],W7
04CE0:  MOV     W7,W4
04CE2:  MUL.UU  W4,#10,W0
04CE4:  MOV     W0,W7
04CE6:  MOV     1B26,W4
04CE8:  MUL.UU  W4,#4,W0
04CEA:  ADD     W0,W7,W0
04CEC:  MOV     #B60,W4
04CEE:  ADD     W0,W4,W0
04CF0:  MOV     W0,W4
04CF2:  MOV     #0,W3
04CF4:  MOV     [W4++],[W3++]
04CF6:  MOV     [W4++],[W3++]
04CF8:  MOV     #0,W2
04CFA:  MOV     #0,W3
04CFC:  CALL    1B2C
04D00:  MOV     #0,W4
04D02:  REPEAT  #3
04D04:  MOV     [W4++],[W6++]
04D06:  MOV     A88,W4
04D08:  ADD     W4,#1,W5
04D0A:  MOV     W5,W4
04D0C:  MUL.UU  W4,#10,W0
04D0E:  MOV     W0,W5
04D10:  ADD     W5,#8,W0
04D12:  MOV     #AA0,W4
04D14:  ADD     W0,W4,W5
04D16:  MOV     1B46,W4
04D18:  MUL.UU  W4,#2,W0
04D1A:  MOV     #A8C,W4
04D1C:  ADD     W0,W4,W0
04D1E:  MOV     [W0],W6
04D20:  MOV     W6,W4
04D22:  MUL.UU  W4,#10,W6
04D24:  MOV     1B28,W4
04D26:  MUL.UU  W4,#4,W0
04D28:  ADD     W0,W6,W0
04D2A:  MOV     #B60,W4
04D2C:  ADD     W0,W4,W0
04D2E:  MOV     W0,W4
04D30:  MOV     #0,W3
04D32:  MOV     [W4++],[W3++]
04D34:  MOV     [W4++],[W3++]
04D36:  MOV     #0,W2
04D38:  MOV     #0,W3
04D3A:  CALL    1B2C
04D3E:  MOV     #0,W4
04D40:  REPEAT  #3
04D42:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
04D44:  MOV     #2,W4
04D46:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
04D48:  MOV     #1,W4
04D4A:  MOV     W4,A84
.................... 	            } 
04D4C:  GOTO    4DD6
.................... 	            else if (posEnd == 0 || posEnd == 1) 
04D50:  CP0     1B4A
04D52:  BRA     Z,4D5A
04D54:  MOV     1B4A,W4
04D56:  CP      W4,#1
04D58:  BRA     NZ,4DD6
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
04D5A:  MOV     A88,W4
04D5C:  MUL.UU  W4,#10,W0
04D5E:  MOV     W0,W5
04D60:  MOV     #AA0,W4
04D62:  ADD     W5,W4,W6
04D64:  MOV     1B46,W4
04D66:  MUL.UU  W4,#2,W0
04D68:  MOV     #A8C,W4
04D6A:  ADD     W0,W4,W0
04D6C:  MOV     [W0],W7
04D6E:  MOV     W7,W4
04D70:  MUL.UU  W4,#10,W0
04D72:  MOV     W0,W7
04D74:  MOV     1B2A,W4
04D76:  MUL.UU  W4,#4,W0
04D78:  ADD     W0,W7,W0
04D7A:  MOV     #B60,W4
04D7C:  ADD     W0,W4,W0
04D7E:  MOV     W0,W4
04D80:  MOV     #0,W3
04D82:  MOV     [W4++],[W3++]
04D84:  MOV     [W4++],[W3++]
04D86:  MOV     #0,W2
04D88:  MOV     #0,W3
04D8A:  CALL    1B2C
04D8E:  MOV     #0,W4
04D90:  REPEAT  #3
04D92:  MOV     [W4++],[W6++]
04D94:  MOV     A88,W4
04D96:  MUL.UU  W4,#10,W0
04D98:  MOV     W0,W5
04D9A:  ADD     W5,#8,W0
04D9C:  MOV     #AA0,W4
04D9E:  ADD     W0,W4,W5
04DA0:  MOV     1B46,W4
04DA2:  MUL.UU  W4,#2,W0
04DA4:  MOV     #A8C,W4
04DA6:  ADD     W0,W4,W0
04DA8:  MOV     [W0],W6
04DAA:  MOV     W6,W4
04DAC:  MUL.UU  W4,#10,W6
04DAE:  MOV     1B2C,W4
04DB0:  MUL.UU  W4,#4,W0
04DB2:  ADD     W0,W6,W0
04DB4:  MOV     #B60,W4
04DB6:  ADD     W0,W4,W0
04DB8:  MOV     W0,W4
04DBA:  MOV     #0,W3
04DBC:  MOV     [W4++],[W3++]
04DBE:  MOV     [W4++],[W3++]
04DC0:  MOV     #0,W2
04DC2:  MOV     #0,W3
04DC4:  CALL    1B2C
04DC8:  MOV     #0,W4
04DCA:  REPEAT  #3
04DCC:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
04DCE:  MOV     #1,W4
04DD0:  MOV     W4,1B4C
.................... 	                path_found = true; 
04DD2:  MOV     #1,W4
04DD4:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
04DD6:  GOTO    66B2
....................  
.................... 	        case 4: 
.................... 	            if (posEnd == 7) 
04DDA:  MOV     1B4A,W4
04DDC:  CP      W4,#7
04DDE:  BRA     NZ,4E60
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
04DE0:  MOV     A88,W4
04DE2:  MUL.UU  W4,#10,W0
04DE4:  MOV     W0,W5
04DE6:  MOV     #AA0,W4
04DE8:  ADD     W5,W4,W6
04DEA:  MOV     1B46,W4
04DEC:  MUL.UU  W4,#2,W0
04DEE:  MOV     #A8C,W4
04DF0:  ADD     W0,W4,W0
04DF2:  MOV     [W0],W7
04DF4:  MOV     W7,W4
04DF6:  MUL.UU  W4,#10,W0
04DF8:  MOV     W0,W7
04DFA:  MOV     1B26,W4
04DFC:  MUL.UU  W4,#4,W0
04DFE:  ADD     W0,W7,W0
04E00:  MOV     #B60,W4
04E02:  ADD     W0,W4,W0
04E04:  MOV     W0,W4
04E06:  MOV     #0,W3
04E08:  MOV     [W4++],[W3++]
04E0A:  MOV     [W4++],[W3++]
04E0C:  MOV     #0,W2
04E0E:  MOV     #0,W3
04E10:  CALL    1B2C
04E14:  MOV     #0,W4
04E16:  REPEAT  #3
04E18:  MOV     [W4++],[W6++]
04E1A:  MOV     A88,W4
04E1C:  MUL.UU  W4,#10,W0
04E1E:  MOV     W0,W5
04E20:  ADD     W5,#8,W0
04E22:  MOV     #AA0,W4
04E24:  ADD     W0,W4,W5
04E26:  MOV     1B46,W4
04E28:  MUL.UU  W4,#2,W0
04E2A:  MOV     #A8C,W4
04E2C:  ADD     W0,W4,W0
04E2E:  MOV     [W0],W6
04E30:  MOV     W6,W4
04E32:  MUL.UU  W4,#10,W6
04E34:  MOV     1B28,W4
04E36:  MUL.UU  W4,#4,W0
04E38:  ADD     W0,W6,W0
04E3A:  MOV     #B60,W4
04E3C:  ADD     W0,W4,W0
04E3E:  MOV     W0,W4
04E40:  MOV     #0,W3
04E42:  MOV     [W4++],[W3++]
04E44:  MOV     [W4++],[W3++]
04E46:  MOV     #0,W2
04E48:  MOV     #0,W3
04E4A:  CALL    1B2C
04E4E:  MOV     #0,W4
04E50:  REPEAT  #3
04E52:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
04E54:  MOV     #1,W4
04E56:  MOV     W4,1B4C
.................... 	                path_found = true; 
04E58:  MOV     #1,W4
04E5A:  MOV     W4,A84
.................... 	            } 
04E5C:  GOTO    5398
.................... 	            else if (posEnd == 0) 
04E60:  CP0     1B4A
04E62:  BRA     NZ,5316
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
04E64:  MOV     1B3E,W0
04E66:  CLR     W3
04E68:  BTSC    W0.F
04E6A:  SETM    W3
04E6C:  MOV     W3,W1
04E6E:  MOV     W3,W2
04E70:  CALL    1B2C
04E74:  MOV     W0,W5
04E76:  MOV     W1,W6
04E78:  MOV     W2,W7
04E7A:  MOV     W3,W8
04E7C:  MOV     1B40,W0
04E7E:  CLR     W3
04E80:  BTSC    W0.F
04E82:  SETM    W3
04E84:  MOV     W3,W1
04E86:  MOV     W3,W2
04E88:  CALL    1B2C
04E8C:  MOV     W0,W9
04E8E:  MOV     W1,W10
04E90:  MOV     W2,W11
04E92:  MOV     W3,W12
04E94:  MOV     1B46,W4
04E96:  MUL.UU  W4,#2,W0
04E98:  MOV     #A8C,W4
04E9A:  ADD     W0,W4,W0
04E9C:  MOV     [W0],W13
04E9E:  MOV     W13,W4
04EA0:  MUL.UU  W4,#10,W0
04EA2:  MOV     W0,W13
04EA4:  MOV     1B2A,W4
04EA6:  MUL.UU  W4,#4,W0
04EA8:  ADD     W0,W13,W0
04EAA:  MOV     #B60,W4
04EAC:  ADD     W0,W4,W0
04EAE:  MOV     W0,W4
04EB0:  MOV     #0,W3
04EB2:  MOV     [W4++],[W3++]
04EB4:  MOV     [W4++],[W3++]
04EB6:  MOV     #0,W2
04EB8:  MOV     #0,W3
04EBA:  CALL    1B2C
04EBE:  MOV     W0,W13
04EC0:  MOV     W1,W14
04EC2:  MOV     W2,W15
04EC4:  MOV     W3,[W0]
04EC6:  MOV     1B46,W4
04EC8:  MUL.UU  W4,#2,W0
04ECA:  MOV     #A8C,W4
04ECC:  ADD     W0,W4,W0
04ECE:  MOV     [W0],[W15++]
04ED0:  POP     1B54
04ED2:  MOV     1B54,W4
04ED4:  MUL.UU  W4,#10,W0
04ED6:  MOV     W0,1B54
04ED8:  MOV     1B2C,W4
04EDA:  MUL.UU  W4,#4,W0
04EDC:  MOV     1B54,W4
04EDE:  ADD     W0,W4,W0
04EE0:  MOV     #B60,W4
04EE2:  ADD     W0,W4,W0
04EE4:  MOV     W0,W4
04EE6:  MOV     #0,W3
04EE8:  MOV     [W4++],[W3++]
04EEA:  MOV     [W4++],[W3++]
04EEC:  MOV     #0,W2
04EEE:  MOV     #0,W3
04EF0:  CALL    1B2C
04EF4:  MOV     W0,1B54
04EF6:  MOV     W1,1B56
04EF8:  MOV     W2,1B58
04EFA:  MOV     W3,1B5A
04EFC:  MOV     W5,1B82
04EFE:  MOV     W6,1B84
04F00:  MOV     W7,1B86
04F02:  MOV     W8,1B88
04F04:  MOV     W9,1B8A
04F06:  MOV     W10,1B8C
04F08:  MOV     W11,1B8E
04F0A:  MOV     W12,1B90
04F0C:  MOV     W13,1B92
04F0E:  MOV     W14,1B94
04F10:  MOV     W15,1B96
04F12:  MOV     [W0],[W15++]
04F14:  POP     1B98
04F16:  PUSH    1B54
04F18:  POP     1B9A
04F1A:  PUSH    1B56
04F1C:  POP     1B9C
04F1E:  PUSH    1B58
04F20:  POP     1B9E
04F22:  PUSH    1B5A
04F24:  POP     1BA0
04F26:  CALL    332C
04F2A:  MOV     W0,W5
04F2C:  MOV     W1,W6
04F2E:  MOV     W2,W7
04F30:  MOV     W3,W8
04F32:  MOV     1B46,W4
04F34:  MUL.UU  W4,#2,W0
04F36:  MOV     #A8C,W4
04F38:  ADD     W0,W4,W0
04F3A:  MOV     [W0],W9
04F3C:  MOV     W9,W4
04F3E:  MUL.UU  W4,#10,W0
04F40:  MOV     W0,W9
04F42:  MOV     1B2A,W4
04F44:  MUL.UU  W4,#4,W0
04F46:  ADD     W0,W9,W0
04F48:  MOV     #B60,W4
04F4A:  ADD     W0,W4,W0
04F4C:  MOV     W0,W4
04F4E:  MOV     #0,W3
04F50:  MOV     [W4++],[W3++]
04F52:  MOV     [W4++],[W3++]
04F54:  MOV     #0,W2
04F56:  MOV     #0,W3
04F58:  CALL    1B2C
04F5C:  MOV     W0,W9
04F5E:  MOV     W1,W10
04F60:  MOV     W2,W11
04F62:  MOV     W3,W12
04F64:  MOV     1B46,W4
04F66:  MUL.UU  W4,#2,W0
04F68:  MOV     #A8C,W4
04F6A:  ADD     W0,W4,W0
04F6C:  MOV     [W0],W13
04F6E:  MOV     W13,W4
04F70:  MUL.UU  W4,#10,W0
04F72:  MOV     W0,W13
04F74:  MOV     1B2C,W4
04F76:  MUL.UU  W4,#4,W0
04F78:  ADD     W0,W13,W0
04F7A:  MOV     #B60,W4
04F7C:  ADD     W0,W4,W0
04F7E:  MOV     W0,W4
04F80:  MOV     #0,W3
04F82:  MOV     [W4++],[W3++]
04F84:  MOV     [W4++],[W3++]
04F86:  MOV     #0,W2
04F88:  MOV     #0,W3
04F8A:  CALL    1B2C
04F8E:  MOV     W0,W13
04F90:  MOV     W1,W14
04F92:  MOV     W2,W15
04F94:  MOV     W3,[W0]
04F96:  MOV     1B42,W0
04F98:  CLR     W3
04F9A:  BTSC    W0.F
04F9C:  SETM    W3
04F9E:  MOV     W3,W1
04FA0:  MOV     W3,W2
04FA2:  CALL    1B2C
04FA6:  MOV     W0,1B54
04FA8:  MOV     W1,1B56
04FAA:  MOV     W2,1B58
04FAC:  MOV     W3,1B5A
04FAE:  MOV     1B44,W0
04FB0:  CLR     W3
04FB2:  BTSC    W0.F
04FB4:  SETM    W3
04FB6:  MOV     W3,W1
04FB8:  MOV     W3,W2
04FBA:  CALL    1B2C
04FBE:  MOV     W0,1B5C
04FC0:  MOV     W1,1B5E
04FC2:  MOV     W2,1B60
04FC4:  MOV     W3,1B62
04FC6:  MOV     W9,1B82
04FC8:  MOV     W10,1B84
04FCA:  MOV     W11,1B86
04FCC:  MOV     W12,1B88
04FCE:  MOV     W13,1B8A
04FD0:  MOV     W14,1B8C
04FD2:  MOV     W15,1B8E
04FD4:  MOV     [W0],[W15++]
04FD6:  POP     1B90
04FD8:  PUSH    1B54
04FDA:  POP     1B92
04FDC:  PUSH    1B56
04FDE:  POP     1B94
04FE0:  PUSH    1B58
04FE2:  POP     1B96
04FE4:  PUSH    1B5A
04FE6:  POP     1B98
04FE8:  PUSH    1B5C
04FEA:  POP     1B9A
04FEC:  PUSH    1B5E
04FEE:  POP     1B9C
04FF0:  PUSH    1B60
04FF2:  POP     1B9E
04FF4:  PUSH    1B62
04FF6:  POP     1BA0
04FF8:  CALL    332C
04FFC:  BCLR.B  43.0
04FFE:  MOV     W5,[W15++]
05000:  MOV     W6,[W15++]
05002:  MOV     W7,[W15++]
05004:  MOV     W0,W4
05006:  MOV     W5,W0
05008:  MOV     W1,W5
0500A:  MOV     W6,W1
0500C:  MOV     W2,W6
0500E:  MOV     W7,W2
05010:  MOV     W3,W7
05012:  MOV     W8,W3
05014:  CALL    1C40
05018:  MOV     [--W15],W7
0501A:  MOV     [--W15],W6
0501C:  MOV     [--W15],W5
0501E:  MOV     W0,W5
05020:  MOV     W1,W6
05022:  MOV     W2,W7
05024:  MOV     W3,W8
05026:  MOV     1B3E,W0
05028:  CLR     W3
0502A:  BTSC    W0.F
0502C:  SETM    W3
0502E:  MOV     W3,W1
05030:  MOV     W3,W2
05032:  CALL    1B2C
05036:  MOV     W0,W9
05038:  MOV     W1,W10
0503A:  MOV     W2,W11
0503C:  MOV     W3,W12
0503E:  MOV     1B40,W0
05040:  CLR     W3
05042:  BTSC    W0.F
05044:  SETM    W3
05046:  MOV     W3,W1
05048:  MOV     W3,W2
0504A:  CALL    1B2C
0504E:  MOV     W0,W13
05050:  MOV     W1,W14
05052:  MOV     W2,W15
05054:  MOV     W3,[W0]
05056:  MOV     1B46,W4
05058:  MUL.UU  W4,#2,W0
0505A:  MOV     #A8C,W4
0505C:  ADD     W0,W4,W0
0505E:  MOV     [W0],[W15++]
05060:  POP     1B54
05062:  MOV     1B54,W4
05064:  MUL.UU  W4,#10,W0
05066:  MOV     W0,1B54
05068:  MOV     1B26,W4
0506A:  MUL.UU  W4,#4,W0
0506C:  MOV     1B54,W4
0506E:  ADD     W0,W4,W0
05070:  MOV     #B60,W4
05072:  ADD     W0,W4,W0
05074:  MOV     W0,W4
05076:  MOV     #0,W3
05078:  MOV     [W4++],[W3++]
0507A:  MOV     [W4++],[W3++]
0507C:  MOV     #0,W2
0507E:  MOV     #0,W3
05080:  CALL    1B2C
05084:  MOV     W0,1B54
05086:  MOV     W1,1B56
05088:  MOV     W2,1B58
0508A:  MOV     W3,1B5A
0508C:  MOV     1B46,W4
0508E:  MUL.UU  W4,#2,W0
05090:  MOV     #A8C,W4
05092:  ADD     W0,W4,W0
05094:  MOV     [W0],[W15++]
05096:  POP     1B5C
05098:  MOV     1B5C,W4
0509A:  MUL.UU  W4,#10,W0
0509C:  MOV     W0,1B5C
0509E:  MOV     1B28,W4
050A0:  MUL.UU  W4,#4,W0
050A2:  MOV     1B5C,W4
050A4:  ADD     W0,W4,W0
050A6:  MOV     #B60,W4
050A8:  ADD     W0,W4,W0
050AA:  MOV     W0,W4
050AC:  MOV     #0,W3
050AE:  MOV     [W4++],[W3++]
050B0:  MOV     [W4++],[W3++]
050B2:  MOV     #0,W2
050B4:  MOV     #0,W3
050B6:  CALL    1B2C
050BA:  MOV     W0,1B5C
050BC:  MOV     W1,1B5E
050BE:  MOV     W2,1B60
050C0:  MOV     W3,1B62
050C2:  MOV     W9,1B82
050C4:  MOV     W10,1B84
050C6:  MOV     W11,1B86
050C8:  MOV     W12,1B88
050CA:  MOV     W13,1B8A
050CC:  MOV     W14,1B8C
050CE:  MOV     W15,1B8E
050D0:  MOV     [W0],[W15++]
050D2:  POP     1B90
050D4:  PUSH    1B54
050D6:  POP     1B92
050D8:  PUSH    1B56
050DA:  POP     1B94
050DC:  PUSH    1B58
050DE:  POP     1B96
050E0:  PUSH    1B5A
050E2:  POP     1B98
050E4:  PUSH    1B5C
050E6:  POP     1B9A
050E8:  PUSH    1B5E
050EA:  POP     1B9C
050EC:  PUSH    1B60
050EE:  POP     1B9E
050F0:  PUSH    1B62
050F2:  POP     1BA0
050F4:  CALL    332C
050F8:  MOV     W0,W9
050FA:  MOV     W1,W10
050FC:  MOV     W2,W11
050FE:  MOV     W3,W12
05100:  MOV     1B46,W4
05102:  MUL.UU  W4,#2,W0
05104:  MOV     #A8C,W4
05106:  ADD     W0,W4,W0
05108:  MOV     [W0],W13
0510A:  MOV     W13,W4
0510C:  MUL.UU  W4,#10,W0
0510E:  MOV     W0,W13
05110:  MOV     1B26,W4
05112:  MUL.UU  W4,#4,W0
05114:  ADD     W0,W13,W0
05116:  MOV     #B60,W4
05118:  ADD     W0,W4,W0
0511A:  MOV     W0,W4
0511C:  MOV     #0,W3
0511E:  MOV     [W4++],[W3++]
05120:  MOV     [W4++],[W3++]
05122:  MOV     #0,W2
05124:  MOV     #0,W3
05126:  CALL    1B2C
0512A:  MOV     W0,W13
0512C:  MOV     W1,W14
0512E:  MOV     W2,W15
05130:  MOV     W3,[W0]
05132:  MOV     1B46,W4
05134:  MUL.UU  W4,#2,W0
05136:  MOV     #A8C,W4
05138:  ADD     W0,W4,W0
0513A:  MOV     [W0],[W15++]
0513C:  POP     1B54
0513E:  MOV     1B54,W4
05140:  MUL.UU  W4,#10,W0
05142:  MOV     W0,1B54
05144:  MOV     1B28,W4
05146:  MUL.UU  W4,#4,W0
05148:  MOV     1B54,W4
0514A:  ADD     W0,W4,W0
0514C:  MOV     #B60,W4
0514E:  ADD     W0,W4,W0
05150:  MOV     W0,W4
05152:  MOV     #0,W3
05154:  MOV     [W4++],[W3++]
05156:  MOV     [W4++],[W3++]
05158:  MOV     #0,W2
0515A:  MOV     #0,W3
0515C:  CALL    1B2C
05160:  MOV     W0,1B54
05162:  MOV     W1,1B56
05164:  MOV     W2,1B58
05166:  MOV     W3,1B5A
05168:  MOV     1B42,W0
0516A:  CLR     W3
0516C:  BTSC    W0.F
0516E:  SETM    W3
05170:  MOV     W3,W1
05172:  MOV     W3,W2
05174:  CALL    1B2C
05178:  MOV     W0,1B5C
0517A:  MOV     W1,1B5E
0517C:  MOV     W2,1B60
0517E:  MOV     W3,1B62
05180:  MOV     1B44,W0
05182:  CLR     W3
05184:  BTSC    W0.F
05186:  SETM    W3
05188:  MOV     W3,W1
0518A:  MOV     W3,W2
0518C:  CALL    1B2C
05190:  MOV     W0,1B64
05192:  MOV     W1,1B66
05194:  MOV     W2,1B68
05196:  MOV     W3,1B6A
05198:  MOV     W13,1B82
0519A:  MOV     W14,1B84
0519C:  MOV     W15,1B86
0519E:  MOV     [W0],[W15++]
051A0:  POP     1B88
051A2:  PUSH    1B54
051A4:  POP     1B8A
051A6:  PUSH    1B56
051A8:  POP     1B8C
051AA:  PUSH    1B58
051AC:  POP     1B8E
051AE:  PUSH    1B5A
051B0:  POP     1B90
051B2:  PUSH    1B5C
051B4:  POP     1B92
051B6:  PUSH    1B5E
051B8:  POP     1B94
051BA:  PUSH    1B60
051BC:  POP     1B96
051BE:  PUSH    1B62
051C0:  POP     1B98
051C2:  PUSH    1B64
051C4:  POP     1B9A
051C6:  PUSH    1B66
051C8:  POP     1B9C
051CA:  PUSH    1B68
051CC:  POP     1B9E
051CE:  PUSH    1B6A
051D0:  POP     1BA0
051D2:  CALL    332C
051D6:  BCLR.B  43.0
051D8:  MOV     W5,[W15++]
051DA:  MOV     W6,[W15++]
051DC:  MOV     W7,[W15++]
051DE:  MOV     W0,W4
051E0:  MOV     W1,W5
051E2:  MOV     W2,W6
051E4:  MOV     W3,W7
051E6:  MOV     W9,W0
051E8:  MOV     W10,W1
051EA:  MOV     W11,W2
051EC:  MOV     W12,W3
051EE:  CALL    1C40
051F2:  MOV     [--W15],W7
051F4:  MOV     [--W15],W6
051F6:  MOV     [--W15],W5
051F8:  MOV     W5,[W15++]
051FA:  MOV     W6,[W15++]
051FC:  MOV     W7,[W15++]
051FE:  MOV     W0,W4
05200:  MOV     W5,W0
05202:  MOV     W1,W5
05204:  MOV     W6,W1
05206:  MOV     W2,W6
05208:  MOV     W7,W2
0520A:  MOV     W3,W7
0520C:  MOV     W8,W3
0520E:  CALL    1E2E
05212:  MOV     [--W15],W7
05214:  MOV     [--W15],W6
05216:  MOV     [--W15],W5
05218:  BRA     NC,5296
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0521A:  MOV     A88,W4
0521C:  MUL.UU  W4,#10,W0
0521E:  MOV     W0,W5
05220:  MOV     #AA0,W4
05222:  ADD     W5,W4,W6
05224:  MOV     1B46,W4
05226:  MUL.UU  W4,#2,W0
05228:  MOV     #A8C,W4
0522A:  ADD     W0,W4,W0
0522C:  MOV     [W0],W7
0522E:  MOV     W7,W4
05230:  MUL.UU  W4,#10,W0
05232:  MOV     W0,W7
05234:  MOV     1B2A,W4
05236:  MUL.UU  W4,#4,W0
05238:  ADD     W0,W7,W0
0523A:  MOV     #B60,W4
0523C:  ADD     W0,W4,W0
0523E:  MOV     W0,W4
05240:  MOV     #0,W3
05242:  MOV     [W4++],[W3++]
05244:  MOV     [W4++],[W3++]
05246:  MOV     #0,W2
05248:  MOV     #0,W3
0524A:  CALL    1B2C
0524E:  MOV     #0,W4
05250:  REPEAT  #3
05252:  MOV     [W4++],[W6++]
05254:  MOV     A88,W4
05256:  MUL.UU  W4,#10,W0
05258:  MOV     W0,W5
0525A:  ADD     W5,#8,W0
0525C:  MOV     #AA0,W4
0525E:  ADD     W0,W4,W5
05260:  MOV     1B46,W4
05262:  MUL.UU  W4,#2,W0
05264:  MOV     #A8C,W4
05266:  ADD     W0,W4,W0
05268:  MOV     [W0],W6
0526A:  MOV     W6,W4
0526C:  MUL.UU  W4,#10,W6
0526E:  MOV     1B2C,W4
05270:  MUL.UU  W4,#4,W0
05272:  ADD     W0,W6,W0
05274:  MOV     #B60,W4
05276:  ADD     W0,W4,W0
05278:  MOV     W0,W4
0527A:  MOV     #0,W3
0527C:  MOV     [W4++],[W3++]
0527E:  MOV     [W4++],[W3++]
05280:  MOV     #0,W2
05282:  MOV     #0,W3
05284:  CALL    1B2C
05288:  MOV     #0,W4
0528A:  REPEAT  #3
0528C:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
0528E:  MOV     #1,W4
05290:  MOV     W4,1B4C
.................... 	                } 
05292:  GOTO    530E
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
05296:  MOV     A88,W4
05298:  MUL.UU  W4,#10,W0
0529A:  MOV     W0,W5
0529C:  MOV     #AA0,W4
0529E:  ADD     W5,W4,W6
052A0:  MOV     1B46,W4
052A2:  MUL.UU  W4,#2,W0
052A4:  MOV     #A8C,W4
052A6:  ADD     W0,W4,W0
052A8:  MOV     [W0],W7
052AA:  MOV     W7,W4
052AC:  MUL.UU  W4,#10,W0
052AE:  MOV     W0,W7
052B0:  MOV     1B26,W4
052B2:  MUL.UU  W4,#4,W0
052B4:  ADD     W0,W7,W0
052B6:  MOV     #B60,W4
052B8:  ADD     W0,W4,W0
052BA:  MOV     W0,W4
052BC:  MOV     #0,W3
052BE:  MOV     [W4++],[W3++]
052C0:  MOV     [W4++],[W3++]
052C2:  MOV     #0,W2
052C4:  MOV     #0,W3
052C6:  CALL    1B2C
052CA:  MOV     #0,W4
052CC:  REPEAT  #3
052CE:  MOV     [W4++],[W6++]
052D0:  MOV     A88,W4
052D2:  MUL.UU  W4,#10,W0
052D4:  MOV     W0,W5
052D6:  ADD     W5,#8,W0
052D8:  MOV     #AA0,W4
052DA:  ADD     W0,W4,W5
052DC:  MOV     1B46,W4
052DE:  MUL.UU  W4,#2,W0
052E0:  MOV     #A8C,W4
052E2:  ADD     W0,W4,W0
052E4:  MOV     [W0],W6
052E6:  MOV     W6,W4
052E8:  MUL.UU  W4,#10,W6
052EA:  MOV     1B28,W4
052EC:  MUL.UU  W4,#4,W0
052EE:  ADD     W0,W6,W0
052F0:  MOV     #B60,W4
052F2:  ADD     W0,W4,W0
052F4:  MOV     W0,W4
052F6:  MOV     #0,W3
052F8:  MOV     [W4++],[W3++]
052FA:  MOV     [W4++],[W3++]
052FC:  MOV     #0,W2
052FE:  MOV     #0,W3
05300:  CALL    1B2C
05304:  MOV     #0,W4
05306:  REPEAT  #3
05308:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
0530A:  MOV     #1,W4
0530C:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
0530E:  MOV     #1,W4
05310:  MOV     W4,A84
.................... 	            } 
05312:  GOTO    5398
.................... 	            else if (posEnd == 1) 
05316:  MOV     1B4A,W4
05318:  CP      W4,#1
0531A:  BRA     NZ,5398
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
0531C:  MOV     A88,W4
0531E:  MUL.UU  W4,#10,W0
05320:  MOV     W0,W5
05322:  MOV     #AA0,W4
05324:  ADD     W5,W4,W6
05326:  MOV     1B46,W4
05328:  MUL.UU  W4,#2,W0
0532A:  MOV     #A8C,W4
0532C:  ADD     W0,W4,W0
0532E:  MOV     [W0],W7
05330:  MOV     W7,W4
05332:  MUL.UU  W4,#10,W0
05334:  MOV     W0,W7
05336:  MOV     1B2A,W4
05338:  MUL.UU  W4,#4,W0
0533A:  ADD     W0,W7,W0
0533C:  MOV     #B60,W4
0533E:  ADD     W0,W4,W0
05340:  MOV     W0,W4
05342:  MOV     #0,W3
05344:  MOV     [W4++],[W3++]
05346:  MOV     [W4++],[W3++]
05348:  MOV     #0,W2
0534A:  MOV     #0,W3
0534C:  CALL    1B2C
05350:  MOV     #0,W4
05352:  REPEAT  #3
05354:  MOV     [W4++],[W6++]
05356:  MOV     A88,W4
05358:  MUL.UU  W4,#10,W0
0535A:  MOV     W0,W5
0535C:  ADD     W5,#8,W0
0535E:  MOV     #AA0,W4
05360:  ADD     W0,W4,W5
05362:  MOV     1B46,W4
05364:  MUL.UU  W4,#2,W0
05366:  MOV     #A8C,W4
05368:  ADD     W0,W4,W0
0536A:  MOV     [W0],W6
0536C:  MOV     W6,W4
0536E:  MUL.UU  W4,#10,W6
05370:  MOV     1B2C,W4
05372:  MUL.UU  W4,#4,W0
05374:  ADD     W0,W6,W0
05376:  MOV     #B60,W4
05378:  ADD     W0,W4,W0
0537A:  MOV     W0,W4
0537C:  MOV     #0,W3
0537E:  MOV     [W4++],[W3++]
05380:  MOV     [W4++],[W3++]
05382:  MOV     #0,W2
05384:  MOV     #0,W3
05386:  CALL    1B2C
0538A:  MOV     #0,W4
0538C:  REPEAT  #3
0538E:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05390:  MOV     #1,W4
05392:  MOV     W4,1B4C
.................... 	                path_found = true; 
05394:  MOV     #1,W4
05396:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
05398:  GOTO    66B2
....................  
.................... 	        case 5: 
.................... 	            if (posEnd == 2 || posEnd == 3) 
0539C:  MOV     1B4A,W4
0539E:  CP      W4,#2
053A0:  BRA     Z,53A8
053A2:  MOV     1B4A,W4
053A4:  CP      W4,#3
053A6:  BRA     NZ,5420
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
053A8:  MOV     A88,W4
053AA:  MUL.UU  W4,#10,W0
053AC:  MOV     W0,W5
053AE:  MOV     #AA0,W4
053B0:  ADD     W5,W4,W6
053B2:  MOV     1B46,W4
053B4:  MUL.UU  W4,#2,W0
053B6:  MOV     #A8C,W4
053B8:  ADD     W0,W4,W0
053BA:  MOV     [W0],W7
053BC:  MOV     W7,W4
053BE:  MUL.UU  W4,#10,W0
053C0:  MOV     W0,W7
053C2:  ADD     W7,#8,W0
053C4:  MOV     #B60,W4
053C6:  ADD     W0,W4,W0
053C8:  MOV     W0,W4
053CA:  MOV     #0,W3
053CC:  MOV     [W4++],[W3++]
053CE:  MOV     [W4++],[W3++]
053D0:  MOV     #0,W2
053D2:  MOV     #0,W3
053D4:  CALL    1B2C
053D8:  MOV     #0,W4
053DA:  REPEAT  #3
053DC:  MOV     [W4++],[W6++]
053DE:  MOV     A88,W4
053E0:  MUL.UU  W4,#10,W0
053E2:  MOV     W0,W5
053E4:  ADD     W5,#8,W0
053E6:  MOV     #AA0,W4
053E8:  ADD     W0,W4,W5
053EA:  MOV     1B46,W4
053EC:  MUL.UU  W4,#2,W0
053EE:  MOV     #A8C,W4
053F0:  ADD     W0,W4,W0
053F2:  MOV     [W0],W6
053F4:  MOV     W6,W4
053F6:  MUL.UU  W4,#10,W6
053F8:  ADD     W6,#C,W0
053FA:  MOV     #B60,W4
053FC:  ADD     W0,W4,W0
053FE:  MOV     W0,W4
05400:  MOV     #0,W3
05402:  MOV     [W4++],[W3++]
05404:  MOV     [W4++],[W3++]
05406:  MOV     #0,W2
05408:  MOV     #0,W3
0540A:  CALL    1B2C
0540E:  MOV     #0,W4
05410:  REPEAT  #3
05412:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05414:  MOV     #1,W4
05416:  MOV     W4,1B4C
.................... 	                path_found = true; 
05418:  MOV     #1,W4
0541A:  MOV     W4,A84
.................... 	            } 
0541C:  GOTO    5A4C
.................... 	            else if (posEnd == 1) 
05420:  MOV     1B4A,W4
05422:  CP      W4,#1
05424:  BRA     NZ,59C6
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
05426:  MOV     1B3E,W0
05428:  CLR     W3
0542A:  BTSC    W0.F
0542C:  SETM    W3
0542E:  MOV     W3,W1
05430:  MOV     W3,W2
05432:  CALL    1B2C
05436:  MOV     W0,W5
05438:  MOV     W1,W6
0543A:  MOV     W2,W7
0543C:  MOV     W3,W8
0543E:  MOV     1B40,W0
05440:  CLR     W3
05442:  BTSC    W0.F
05444:  SETM    W3
05446:  MOV     W3,W1
05448:  MOV     W3,W2
0544A:  CALL    1B2C
0544E:  MOV     W0,W9
05450:  MOV     W1,W10
05452:  MOV     W2,W11
05454:  MOV     W3,W12
05456:  MOV     1B46,W4
05458:  MUL.UU  W4,#2,W0
0545A:  MOV     #A8C,W4
0545C:  ADD     W0,W4,W0
0545E:  MOV     [W0],W13
05460:  MOV     W13,W4
05462:  MUL.UU  W4,#10,W0
05464:  MOV     W0,W13
05466:  MOV     1B26,W4
05468:  MUL.UU  W4,#4,W0
0546A:  ADD     W0,W13,W0
0546C:  MOV     #B60,W4
0546E:  ADD     W0,W4,W0
05470:  MOV     W0,W4
05472:  MOV     #0,W3
05474:  MOV     [W4++],[W3++]
05476:  MOV     [W4++],[W3++]
05478:  MOV     #0,W2
0547A:  MOV     #0,W3
0547C:  CALL    1B2C
05480:  MOV     W0,W13
05482:  MOV     W1,W14
05484:  MOV     W2,W15
05486:  MOV     W3,[W0]
05488:  MOV     1B46,W4
0548A:  MUL.UU  W4,#2,W0
0548C:  MOV     #A8C,W4
0548E:  ADD     W0,W4,W0
05490:  MOV     [W0],[W15++]
05492:  POP     1B54
05494:  MOV     1B54,W4
05496:  MUL.UU  W4,#10,W0
05498:  MOV     W0,1B54
0549A:  MOV     1B28,W4
0549C:  MUL.UU  W4,#4,W0
0549E:  MOV     1B54,W4
054A0:  ADD     W0,W4,W0
054A2:  MOV     #B60,W4
054A4:  ADD     W0,W4,W0
054A6:  MOV     W0,W4
054A8:  MOV     #0,W3
054AA:  MOV     [W4++],[W3++]
054AC:  MOV     [W4++],[W3++]
054AE:  MOV     #0,W2
054B0:  MOV     #0,W3
054B2:  CALL    1B2C
054B6:  MOV     W0,1B54
054B8:  MOV     W1,1B56
054BA:  MOV     W2,1B58
054BC:  MOV     W3,1B5A
054BE:  MOV     W5,1B82
054C0:  MOV     W6,1B84
054C2:  MOV     W7,1B86
054C4:  MOV     W8,1B88
054C6:  MOV     W9,1B8A
054C8:  MOV     W10,1B8C
054CA:  MOV     W11,1B8E
054CC:  MOV     W12,1B90
054CE:  MOV     W13,1B92
054D0:  MOV     W14,1B94
054D2:  MOV     W15,1B96
054D4:  MOV     [W0],[W15++]
054D6:  POP     1B98
054D8:  PUSH    1B54
054DA:  POP     1B9A
054DC:  PUSH    1B56
054DE:  POP     1B9C
054E0:  PUSH    1B58
054E2:  POP     1B9E
054E4:  PUSH    1B5A
054E6:  POP     1BA0
054E8:  CALL    332C
054EC:  MOV     W0,W5
054EE:  MOV     W1,W6
054F0:  MOV     W2,W7
054F2:  MOV     W3,W8
054F4:  MOV     1B46,W4
054F6:  MUL.UU  W4,#2,W0
054F8:  MOV     #A8C,W4
054FA:  ADD     W0,W4,W0
054FC:  MOV     [W0],W9
054FE:  MOV     W9,W4
05500:  MUL.UU  W4,#10,W0
05502:  MOV     W0,W9
05504:  MOV     #B60,W4
05506:  ADD     W9,W4,W0
05508:  MOV     W0,W4
0550A:  MOV     #0,W3
0550C:  MOV     [W4++],[W3++]
0550E:  MOV     [W4++],[W3++]
05510:  MOV     #0,W2
05512:  MOV     #0,W3
05514:  CALL    1B2C
05518:  MOV     W0,W10
0551A:  MOV     W1,W11
0551C:  MOV     W2,W12
0551E:  MOV     W3,W13
05520:  MOV     1B46,W4
05522:  MUL.UU  W4,#2,W0
05524:  MOV     #A8C,W4
05526:  ADD     W0,W4,W0
05528:  MOV     [W0],[W15++]
0552A:  POP     1B4E
0552C:  MOV     1B4E,W4
0552E:  MUL.UU  W4,#10,W0
05530:  MOV     W0,1B4E
05532:  MOV     1B4E,W4
05534:  ADD     W4,#4,W0
05536:  MOV     #B60,W4
05538:  ADD     W0,W4,W0
0553A:  MOV     W0,W4
0553C:  MOV     #0,W3
0553E:  MOV     [W4++],[W3++]
05540:  MOV     [W4++],[W3++]
05542:  MOV     #0,W2
05544:  MOV     #0,W3
05546:  CALL    1B2C
0554A:  MOV     W0,1B4E
0554C:  MOV     W1,1B50
0554E:  MOV     W2,1B52
05550:  MOV     W3,1B54
05552:  MOV     1B42,W0
05554:  CLR     W3
05556:  BTSC    W0.F
05558:  SETM    W3
0555A:  MOV     W3,W1
0555C:  MOV     W3,W2
0555E:  CALL    1B2C
05562:  MOV     W0,1B56
05564:  MOV     W1,1B58
05566:  MOV     W2,1B5A
05568:  MOV     W3,1B5C
0556A:  MOV     1B44,W0
0556C:  CLR     W3
0556E:  BTSC    W0.F
05570:  SETM    W3
05572:  MOV     W3,W1
05574:  MOV     W3,W2
05576:  CALL    1B2C
0557A:  MOV     W0,1B5E
0557C:  MOV     W1,1B60
0557E:  MOV     W2,1B62
05580:  MOV     W3,1B64
05582:  MOV     W10,1B82
05584:  MOV     W11,1B84
05586:  MOV     W12,1B86
05588:  MOV     W13,1B88
0558A:  PUSH    1B4E
0558C:  POP     1B8A
0558E:  PUSH    1B50
05590:  POP     1B8C
05592:  PUSH    1B52
05594:  POP     1B8E
05596:  PUSH    1B54
05598:  POP     1B90
0559A:  PUSH    1B56
0559C:  POP     1B92
0559E:  PUSH    1B58
055A0:  POP     1B94
055A2:  PUSH    1B5A
055A4:  POP     1B96
055A6:  PUSH    1B5C
055A8:  POP     1B98
055AA:  PUSH    1B5E
055AC:  POP     1B9A
055AE:  PUSH    1B60
055B0:  POP     1B9C
055B2:  PUSH    1B62
055B4:  POP     1B9E
055B6:  PUSH    1B64
055B8:  POP     1BA0
055BA:  CALL    332C
055BE:  BCLR.B  43.0
055C0:  MOV     W5,[W15++]
055C2:  MOV     W6,[W15++]
055C4:  MOV     W7,[W15++]
055C6:  MOV     W0,W4
055C8:  MOV     W5,W0
055CA:  MOV     W1,W5
055CC:  MOV     W6,W1
055CE:  MOV     W2,W6
055D0:  MOV     W7,W2
055D2:  MOV     W3,W7
055D4:  MOV     W8,W3
055D6:  CALL    1C40
055DA:  MOV     [--W15],W7
055DC:  MOV     [--W15],W6
055DE:  MOV     [--W15],W5
055E0:  MOV     W0,W5
055E2:  MOV     W1,W6
055E4:  MOV     W2,W7
055E6:  MOV     W3,W8
055E8:  MOV     1B3E,W0
055EA:  CLR     W3
055EC:  BTSC    W0.F
055EE:  SETM    W3
055F0:  MOV     W3,W1
055F2:  MOV     W3,W2
055F4:  CALL    1B2C
055F8:  MOV     W0,W10
055FA:  MOV     W1,W11
055FC:  MOV     W2,W12
055FE:  MOV     W3,W13
05600:  MOV     1B40,W0
05602:  CLR     W3
05604:  BTSC    W0.F
05606:  SETM    W3
05608:  MOV     W3,W1
0560A:  MOV     W3,W2
0560C:  CALL    1B2C
05610:  MOV     W0,1B4E
05612:  MOV     W1,1B50
05614:  MOV     W2,1B52
05616:  MOV     W3,1B54
05618:  MOV     1B46,W4
0561A:  MUL.UU  W4,#2,W0
0561C:  MOV     #A8C,W4
0561E:  ADD     W0,W4,W0
05620:  MOV     [W0],[W15++]
05622:  POP     1B56
05624:  MOV     1B56,W4
05626:  MUL.UU  W4,#10,W0
05628:  MOV     W0,1B56
0562A:  MOV     1B56,W4
0562C:  ADD     W4,#8,W0
0562E:  MOV     #B60,W4
05630:  ADD     W0,W4,W0
05632:  MOV     W0,W4
05634:  MOV     #0,W3
05636:  MOV     [W4++],[W3++]
05638:  MOV     [W4++],[W3++]
0563A:  MOV     #0,W2
0563C:  MOV     #0,W3
0563E:  CALL    1B2C
05642:  MOV     W0,1B56
05644:  MOV     W1,1B58
05646:  MOV     W2,1B5A
05648:  MOV     W3,1B5C
0564A:  MOV     1B46,W4
0564C:  MUL.UU  W4,#2,W0
0564E:  MOV     #A8C,W4
05650:  ADD     W0,W4,W0
05652:  MOV     [W0],[W15++]
05654:  POP     1B5E
05656:  MOV     1B5E,W4
05658:  MUL.UU  W4,#10,W0
0565A:  MOV     W0,1B5E
0565C:  MOV     1B5E,W4
0565E:  ADD     W4,#C,W0
05660:  MOV     #B60,W4
05662:  ADD     W0,W4,W0
05664:  MOV     W0,W4
05666:  MOV     #0,W3
05668:  MOV     [W4++],[W3++]
0566A:  MOV     [W4++],[W3++]
0566C:  MOV     #0,W2
0566E:  MOV     #0,W3
05670:  CALL    1B2C
05674:  MOV     W0,1B5E
05676:  MOV     W1,1B60
05678:  MOV     W2,1B62
0567A:  MOV     W3,1B64
0567C:  MOV     W10,1B82
0567E:  MOV     W11,1B84
05680:  MOV     W12,1B86
05682:  MOV     W13,1B88
05684:  PUSH    1B4E
05686:  POP     1B8A
05688:  PUSH    1B50
0568A:  POP     1B8C
0568C:  PUSH    1B52
0568E:  POP     1B8E
05690:  PUSH    1B54
05692:  POP     1B90
05694:  PUSH    1B56
05696:  POP     1B92
05698:  PUSH    1B58
0569A:  POP     1B94
0569C:  PUSH    1B5A
0569E:  POP     1B96
056A0:  PUSH    1B5C
056A2:  POP     1B98
056A4:  PUSH    1B5E
056A6:  POP     1B9A
056A8:  PUSH    1B60
056AA:  POP     1B9C
056AC:  PUSH    1B62
056AE:  POP     1B9E
056B0:  PUSH    1B64
056B2:  POP     1BA0
056B4:  CALL    332C
056B8:  MOV     W0,W10
056BA:  MOV     W1,W11
056BC:  MOV     W2,W12
056BE:  MOV     W3,W13
056C0:  MOV     1B46,W4
056C2:  MUL.UU  W4,#2,W0
056C4:  MOV     #A8C,W4
056C6:  ADD     W0,W4,W0
056C8:  MOV     [W0],[W15++]
056CA:  POP     1B4E
056CC:  MOV     1B4E,W4
056CE:  MUL.UU  W4,#10,W0
056D0:  MOV     W0,1B4E
056D2:  MOV     1B2A,W4
056D4:  MUL.UU  W4,#4,W0
056D6:  MOV     1B4E,W4
056D8:  ADD     W0,W4,W0
056DA:  MOV     #B60,W4
056DC:  ADD     W0,W4,W0
056DE:  MOV     W0,W4
056E0:  MOV     #0,W3
056E2:  MOV     [W4++],[W3++]
056E4:  MOV     [W4++],[W3++]
056E6:  MOV     #0,W2
056E8:  MOV     #0,W3
056EA:  CALL    1B2C
056EE:  MOV     W0,1B4E
056F0:  MOV     W1,1B50
056F2:  MOV     W2,1B52
056F4:  MOV     W3,1B54
056F6:  MOV     1B46,W4
056F8:  MUL.UU  W4,#2,W0
056FA:  MOV     #A8C,W4
056FC:  ADD     W0,W4,W0
056FE:  MOV     [W0],[W15++]
05700:  POP     1B56
05702:  MOV     1B56,W4
05704:  MUL.UU  W4,#10,W0
05706:  MOV     W0,1B56
05708:  MOV     1B2C,W4
0570A:  MUL.UU  W4,#4,W0
0570C:  MOV     1B56,W4
0570E:  ADD     W0,W4,W0
05710:  MOV     #B60,W4
05712:  ADD     W0,W4,W0
05714:  MOV     W0,W4
05716:  MOV     #0,W3
05718:  MOV     [W4++],[W3++]
0571A:  MOV     [W4++],[W3++]
0571C:  MOV     #0,W2
0571E:  MOV     #0,W3
05720:  CALL    1B2C
05724:  MOV     W0,1B56
05726:  MOV     W1,1B58
05728:  MOV     W2,1B5A
0572A:  MOV     W3,1B5C
0572C:  MOV     1B42,W0
0572E:  CLR     W3
05730:  BTSC    W0.F
05732:  SETM    W3
05734:  MOV     W3,W1
05736:  MOV     W3,W2
05738:  CALL    1B2C
0573C:  MOV     W0,1B5E
0573E:  MOV     W1,1B60
05740:  MOV     W2,1B62
05742:  MOV     W3,1B64
05744:  MOV     1B44,W0
05746:  CLR     W3
05748:  BTSC    W0.F
0574A:  SETM    W3
0574C:  MOV     W3,W1
0574E:  MOV     W3,W2
05750:  CALL    1B2C
05754:  MOV     W0,1B66
05756:  MOV     W1,1B68
05758:  MOV     W2,1B6A
0575A:  MOV     W3,1B6C
0575C:  PUSH    1B4E
0575E:  POP     1B82
05760:  PUSH    1B50
05762:  POP     1B84
05764:  PUSH    1B52
05766:  POP     1B86
05768:  PUSH    1B54
0576A:  POP     1B88
0576C:  PUSH    1B56
0576E:  POP     1B8A
05770:  PUSH    1B58
05772:  POP     1B8C
05774:  PUSH    1B5A
05776:  POP     1B8E
05778:  PUSH    1B5C
0577A:  POP     1B90
0577C:  PUSH    1B5E
0577E:  POP     1B92
05780:  PUSH    1B60
05782:  POP     1B94
05784:  PUSH    1B62
05786:  POP     1B96
05788:  PUSH    1B64
0578A:  POP     1B98
0578C:  PUSH    1B66
0578E:  POP     1B9A
05790:  PUSH    1B68
05792:  POP     1B9C
05794:  PUSH    1B6A
05796:  POP     1B9E
05798:  PUSH    1B6C
0579A:  POP     1BA0
0579C:  CALL    332C
057A0:  BCLR.B  43.0
057A2:  MOV     W5,[W15++]
057A4:  MOV     W6,[W15++]
057A6:  MOV     W7,[W15++]
057A8:  MOV     W0,W4
057AA:  MOV     W1,W5
057AC:  MOV     W2,W6
057AE:  MOV     W3,W7
057B0:  MOV     W10,W0
057B2:  MOV     W11,W1
057B4:  MOV     W12,W2
057B6:  MOV     W13,W3
057B8:  CALL    1C40
057BC:  MOV     [--W15],W7
057BE:  MOV     [--W15],W6
057C0:  MOV     [--W15],W5
057C2:  MOV     W5,[W15++]
057C4:  MOV     W6,[W15++]
057C6:  MOV     W7,[W15++]
057C8:  MOV     W0,W4
057CA:  MOV     W5,W0
057CC:  MOV     W1,W5
057CE:  MOV     W6,W1
057D0:  MOV     W2,W6
057D2:  MOV     W7,W2
057D4:  MOV     W3,W7
057D6:  MOV     W8,W3
057D8:  CALL    1E2E
057DC:  MOV     [--W15],W7
057DE:  MOV     [--W15],W6
057E0:  MOV     [--W15],W5
057E2:  BRA     NC,58D2
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3];  
057E4:  MOV     A88,W4
057E6:  MUL.UU  W4,#10,W0
057E8:  MOV     W0,W5
057EA:  MOV     #AA0,W4
057EC:  ADD     W5,W4,W6
057EE:  MOV     1B46,W4
057F0:  MUL.UU  W4,#2,W0
057F2:  MOV     #A8C,W4
057F4:  ADD     W0,W4,W0
057F6:  MOV     [W0],W7
057F8:  MOV     W7,W4
057FA:  MUL.UU  W4,#10,W0
057FC:  MOV     W0,W7
057FE:  MOV     1B26,W4
05800:  MUL.UU  W4,#4,W0
05802:  ADD     W0,W7,W0
05804:  MOV     #B60,W4
05806:  ADD     W0,W4,W0
05808:  MOV     W0,W4
0580A:  MOV     #0,W3
0580C:  MOV     [W4++],[W3++]
0580E:  MOV     [W4++],[W3++]
05810:  MOV     #0,W2
05812:  MOV     #0,W3
05814:  CALL    1B2C
05818:  MOV     #0,W4
0581A:  REPEAT  #3
0581C:  MOV     [W4++],[W6++]
0581E:  MOV     A88,W4
05820:  ADD     W4,#1,W5
05822:  MOV     W5,W4
05824:  MUL.UU  W4,#10,W0
05826:  MOV     W0,W5
05828:  ADD     W5,#8,W0
0582A:  MOV     #AA0,W4
0582C:  ADD     W0,W4,W5
0582E:  MOV     1B46,W4
05830:  MUL.UU  W4,#2,W0
05832:  MOV     #A8C,W4
05834:  ADD     W0,W4,W0
05836:  MOV     [W0],W6
05838:  MOV     W6,W4
0583A:  MUL.UU  W4,#10,W6
0583C:  MOV     1B28,W4
0583E:  MUL.UU  W4,#4,W0
05840:  ADD     W0,W6,W0
05842:  MOV     #B60,W4
05844:  ADD     W0,W4,W0
05846:  MOV     W0,W4
05848:  MOV     #0,W3
0584A:  MOV     [W4++],[W3++]
0584C:  MOV     [W4++],[W3++]
0584E:  MOV     #0,W2
05850:  MOV     #0,W3
05852:  CALL    1B2C
05856:  MOV     #0,W4
05858:  REPEAT  #3
0585A:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
0585C:  MOV     A88,W4
0585E:  ADD     W4,#1,W5
05860:  MOV     W5,W4
05862:  MUL.UU  W4,#10,W0
05864:  MOV     W0,W5
05866:  MOV     #AA0,W4
05868:  ADD     W5,W4,W6
0586A:  MOV     1B46,W4
0586C:  MUL.UU  W4,#2,W0
0586E:  MOV     #A8C,W4
05870:  ADD     W0,W4,W0
05872:  MOV     [W0],W7
05874:  MOV     W7,W4
05876:  MUL.UU  W4,#10,W0
05878:  MOV     W0,W7
0587A:  MOV     #B60,W4
0587C:  ADD     W7,W4,W0
0587E:  MOV     W0,W4
05880:  MOV     #0,W3
05882:  MOV     [W4++],[W3++]
05884:  MOV     [W4++],[W3++]
05886:  MOV     #0,W2
05888:  MOV     #0,W3
0588A:  CALL    1B2C
0588E:  MOV     #0,W4
05890:  REPEAT  #3
05892:  MOV     [W4++],[W6++]
05894:  MOV     A88,W4
05896:  MUL.UU  W4,#10,W0
05898:  MOV     W0,W5
0589A:  ADD     W5,#8,W0
0589C:  MOV     #AA0,W4
0589E:  ADD     W0,W4,W5
058A0:  MOV     1B46,W4
058A2:  MUL.UU  W4,#2,W0
058A4:  MOV     #A8C,W4
058A6:  ADD     W0,W4,W0
058A8:  MOV     [W0],W6
058AA:  MOV     W6,W4
058AC:  MUL.UU  W4,#10,W6
058AE:  ADD     W6,#4,W0
058B0:  MOV     #B60,W4
058B2:  ADD     W0,W4,W0
058B4:  MOV     W0,W4
058B6:  MOV     #0,W3
058B8:  MOV     [W4++],[W3++]
058BA:  MOV     [W4++],[W3++]
058BC:  MOV     #0,W2
058BE:  MOV     #0,W3
058C0:  CALL    1B2C
058C4:  MOV     #0,W4
058C6:  REPEAT  #3
058C8:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
058CA:  MOV     #2,W4
058CC:  MOV     W4,1B4C
.................... 	                } 
058CE:  GOTO    59BE
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y4]; 
058D2:  MOV     A88,W4
058D4:  MUL.UU  W4,#10,W0
058D6:  MOV     W0,W5
058D8:  MOV     #AA0,W4
058DA:  ADD     W5,W4,W6
058DC:  MOV     1B46,W4
058DE:  MUL.UU  W4,#2,W0
058E0:  MOV     #A8C,W4
058E2:  ADD     W0,W4,W0
058E4:  MOV     [W0],W7
058E6:  MOV     W7,W4
058E8:  MUL.UU  W4,#10,W0
058EA:  MOV     W0,W7
058EC:  ADD     W7,#8,W0
058EE:  MOV     #B60,W4
058F0:  ADD     W0,W4,W0
058F2:  MOV     W0,W4
058F4:  MOV     #0,W3
058F6:  MOV     [W4++],[W3++]
058F8:  MOV     [W4++],[W3++]
058FA:  MOV     #0,W2
058FC:  MOV     #0,W3
058FE:  CALL    1B2C
05902:  MOV     #0,W4
05904:  REPEAT  #3
05906:  MOV     [W4++],[W6++]
05908:  MOV     A88,W4
0590A:  ADD     W4,#1,W5
0590C:  MOV     W5,W4
0590E:  MUL.UU  W4,#10,W0
05910:  MOV     W0,W5
05912:  ADD     W5,#8,W0
05914:  MOV     #AA0,W4
05916:  ADD     W0,W4,W5
05918:  MOV     1B46,W4
0591A:  MUL.UU  W4,#2,W0
0591C:  MOV     #A8C,W4
0591E:  ADD     W0,W4,W0
05920:  MOV     [W0],W6
05922:  MOV     W6,W4
05924:  MUL.UU  W4,#10,W6
05926:  ADD     W6,#C,W0
05928:  MOV     #B60,W4
0592A:  ADD     W0,W4,W0
0592C:  MOV     W0,W4
0592E:  MOV     #0,W3
05930:  MOV     [W4++],[W3++]
05932:  MOV     [W4++],[W3++]
05934:  MOV     #0,W2
05936:  MOV     #0,W3
05938:  CALL    1B2C
0593C:  MOV     #0,W4
0593E:  REPEAT  #3
05940:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2];  
05942:  MOV     A88,W4
05944:  ADD     W4,#1,W5
05946:  MOV     W5,W4
05948:  MUL.UU  W4,#10,W0
0594A:  MOV     W0,W5
0594C:  MOV     #AA0,W4
0594E:  ADD     W5,W4,W6
05950:  MOV     1B46,W4
05952:  MUL.UU  W4,#2,W0
05954:  MOV     #A8C,W4
05956:  ADD     W0,W4,W0
05958:  MOV     [W0],W7
0595A:  MOV     W7,W4
0595C:  MUL.UU  W4,#10,W0
0595E:  MOV     W0,W7
05960:  MOV     1B2A,W4
05962:  MUL.UU  W4,#4,W0
05964:  ADD     W0,W7,W0
05966:  MOV     #B60,W4
05968:  ADD     W0,W4,W0
0596A:  MOV     W0,W4
0596C:  MOV     #0,W3
0596E:  MOV     [W4++],[W3++]
05970:  MOV     [W4++],[W3++]
05972:  MOV     #0,W2
05974:  MOV     #0,W3
05976:  CALL    1B2C
0597A:  MOV     #0,W4
0597C:  REPEAT  #3
0597E:  MOV     [W4++],[W6++]
05980:  MOV     A88,W4
05982:  MUL.UU  W4,#10,W0
05984:  MOV     W0,W5
05986:  ADD     W5,#8,W0
05988:  MOV     #AA0,W4
0598A:  ADD     W0,W4,W5
0598C:  MOV     1B46,W4
0598E:  MUL.UU  W4,#2,W0
05990:  MOV     #A8C,W4
05992:  ADD     W0,W4,W0
05994:  MOV     [W0],W6
05996:  MOV     W6,W4
05998:  MUL.UU  W4,#10,W6
0599A:  MOV     1B2C,W4
0599C:  MUL.UU  W4,#4,W0
0599E:  ADD     W0,W6,W0
059A0:  MOV     #B60,W4
059A2:  ADD     W0,W4,W0
059A4:  MOV     W0,W4
059A6:  MOV     #0,W3
059A8:  MOV     [W4++],[W3++]
059AA:  MOV     [W4++],[W3++]
059AC:  MOV     #0,W2
059AE:  MOV     #0,W3
059B0:  CALL    1B2C
059B4:  MOV     #0,W4
059B6:  REPEAT  #3
059B8:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
059BA:  MOV     #2,W4
059BC:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
059BE:  MOV     #1,W4
059C0:  MOV     W4,A84
.................... 	            } 
059C2:  GOTO    5A4C
.................... 	            else if (posEnd == 7 || posEnd == 0) 
059C6:  MOV     1B4A,W4
059C8:  CP      W4,#7
059CA:  BRA     Z,59D0
059CC:  CP0     1B4A
059CE:  BRA     NZ,5A4C
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
059D0:  MOV     A88,W4
059D2:  MUL.UU  W4,#10,W0
059D4:  MOV     W0,W5
059D6:  MOV     #AA0,W4
059D8:  ADD     W5,W4,W6
059DA:  MOV     1B46,W4
059DC:  MUL.UU  W4,#2,W0
059DE:  MOV     #A8C,W4
059E0:  ADD     W0,W4,W0
059E2:  MOV     [W0],W7
059E4:  MOV     W7,W4
059E6:  MUL.UU  W4,#10,W0
059E8:  MOV     W0,W7
059EA:  MOV     1B26,W4
059EC:  MUL.UU  W4,#4,W0
059EE:  ADD     W0,W7,W0
059F0:  MOV     #B60,W4
059F2:  ADD     W0,W4,W0
059F4:  MOV     W0,W4
059F6:  MOV     #0,W3
059F8:  MOV     [W4++],[W3++]
059FA:  MOV     [W4++],[W3++]
059FC:  MOV     #0,W2
059FE:  MOV     #0,W3
05A00:  CALL    1B2C
05A04:  MOV     #0,W4
05A06:  REPEAT  #3
05A08:  MOV     [W4++],[W6++]
05A0A:  MOV     A88,W4
05A0C:  MUL.UU  W4,#10,W0
05A0E:  MOV     W0,W5
05A10:  ADD     W5,#8,W0
05A12:  MOV     #AA0,W4
05A14:  ADD     W0,W4,W5
05A16:  MOV     1B46,W4
05A18:  MUL.UU  W4,#2,W0
05A1A:  MOV     #A8C,W4
05A1C:  ADD     W0,W4,W0
05A1E:  MOV     [W0],W6
05A20:  MOV     W6,W4
05A22:  MUL.UU  W4,#10,W6
05A24:  MOV     1B28,W4
05A26:  MUL.UU  W4,#4,W0
05A28:  ADD     W0,W6,W0
05A2A:  MOV     #B60,W4
05A2C:  ADD     W0,W4,W0
05A2E:  MOV     W0,W4
05A30:  MOV     #0,W3
05A32:  MOV     [W4++],[W3++]
05A34:  MOV     [W4++],[W3++]
05A36:  MOV     #0,W2
05A38:  MOV     #0,W3
05A3A:  CALL    1B2C
05A3E:  MOV     #0,W4
05A40:  REPEAT  #3
05A42:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05A44:  MOV     #1,W4
05A46:  MOV     W4,1B4C
.................... 	                path_found = true; 
05A48:  MOV     #1,W4
05A4A:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
05A4C:  GOTO    66B2
....................  
.................... 	        case 6: 
.................... 	            if (posEnd == 3) 
05A50:  MOV     1B4A,W4
05A52:  CP      W4,#3
05A54:  BRA     NZ,5ACE
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
05A56:  MOV     A88,W4
05A58:  MUL.UU  W4,#10,W0
05A5A:  MOV     W0,W5
05A5C:  MOV     #AA0,W4
05A5E:  ADD     W5,W4,W6
05A60:  MOV     1B46,W4
05A62:  MUL.UU  W4,#2,W0
05A64:  MOV     #A8C,W4
05A66:  ADD     W0,W4,W0
05A68:  MOV     [W0],W7
05A6A:  MOV     W7,W4
05A6C:  MUL.UU  W4,#10,W0
05A6E:  MOV     W0,W7
05A70:  ADD     W7,#8,W0
05A72:  MOV     #B60,W4
05A74:  ADD     W0,W4,W0
05A76:  MOV     W0,W4
05A78:  MOV     #0,W3
05A7A:  MOV     [W4++],[W3++]
05A7C:  MOV     [W4++],[W3++]
05A7E:  MOV     #0,W2
05A80:  MOV     #0,W3
05A82:  CALL    1B2C
05A86:  MOV     #0,W4
05A88:  REPEAT  #3
05A8A:  MOV     [W4++],[W6++]
05A8C:  MOV     A88,W4
05A8E:  MUL.UU  W4,#10,W0
05A90:  MOV     W0,W5
05A92:  ADD     W5,#8,W0
05A94:  MOV     #AA0,W4
05A96:  ADD     W0,W4,W5
05A98:  MOV     1B46,W4
05A9A:  MUL.UU  W4,#2,W0
05A9C:  MOV     #A8C,W4
05A9E:  ADD     W0,W4,W0
05AA0:  MOV     [W0],W6
05AA2:  MOV     W6,W4
05AA4:  MUL.UU  W4,#10,W6
05AA6:  ADD     W6,#C,W0
05AA8:  MOV     #B60,W4
05AAA:  ADD     W0,W4,W0
05AAC:  MOV     W0,W4
05AAE:  MOV     #0,W3
05AB0:  MOV     [W4++],[W3++]
05AB2:  MOV     [W4++],[W3++]
05AB4:  MOV     #0,W2
05AB6:  MOV     #0,W3
05AB8:  CALL    1B2C
05ABC:  MOV     #0,W4
05ABE:  REPEAT  #3
05AC0:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05AC2:  MOV     #1,W4
05AC4:  MOV     W4,1B4C
.................... 	                path_found = true; 
05AC6:  MOV     #1,W4
05AC8:  MOV     W4,A84
.................... 	            } 
05ACA:  GOTO    5FE8
.................... 	            else if (posEnd == 2) 
05ACE:  MOV     1B4A,W4
05AD0:  CP      W4,#2
05AD2:  BRA     NZ,5F70
.................... 	            { 
.................... 	                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
05AD4:  MOV     1B3E,W0
05AD6:  CLR     W3
05AD8:  BTSC    W0.F
05ADA:  SETM    W3
05ADC:  MOV     W3,W1
05ADE:  MOV     W3,W2
05AE0:  CALL    1B2C
05AE4:  MOV     W0,W5
05AE6:  MOV     W1,W6
05AE8:  MOV     W2,W7
05AEA:  MOV     W3,W8
05AEC:  MOV     1B40,W0
05AEE:  CLR     W3
05AF0:  BTSC    W0.F
05AF2:  SETM    W3
05AF4:  MOV     W3,W1
05AF6:  MOV     W3,W2
05AF8:  CALL    1B2C
05AFC:  MOV     W0,W9
05AFE:  MOV     W1,W10
05B00:  MOV     W2,W11
05B02:  MOV     W3,W12
05B04:  MOV     1B46,W4
05B06:  MUL.UU  W4,#2,W0
05B08:  MOV     #A8C,W4
05B0A:  ADD     W0,W4,W0
05B0C:  MOV     [W0],W13
05B0E:  MOV     W13,W4
05B10:  MUL.UU  W4,#10,W0
05B12:  MOV     W0,W13
05B14:  MOV     #B60,W4
05B16:  ADD     W13,W4,W0
05B18:  MOV     W0,W4
05B1A:  MOV     #0,W3
05B1C:  MOV     [W4++],[W3++]
05B1E:  MOV     [W4++],[W3++]
05B20:  MOV     #0,W2
05B22:  MOV     #0,W3
05B24:  CALL    1B2C
05B28:  MOV     W0,1B4E
05B2A:  MOV     W1,1B50
05B2C:  MOV     W2,1B52
05B2E:  MOV     W3,1B54
05B30:  MOV     1B46,W4
05B32:  MUL.UU  W4,#2,W0
05B34:  MOV     #A8C,W4
05B36:  ADD     W0,W4,W0
05B38:  MOV     [W0],[W15++]
05B3A:  POP     1B56
05B3C:  MOV     1B56,W4
05B3E:  MUL.UU  W4,#10,W0
05B40:  MOV     W0,1B56
05B42:  MOV     1B56,W4
05B44:  ADD     W4,#4,W0
05B46:  MOV     #B60,W4
05B48:  ADD     W0,W4,W0
05B4A:  MOV     W0,W4
05B4C:  MOV     #0,W3
05B4E:  MOV     [W4++],[W3++]
05B50:  MOV     [W4++],[W3++]
05B52:  MOV     #0,W2
05B54:  MOV     #0,W3
05B56:  CALL    1B2C
05B5A:  MOV     W0,1B56
05B5C:  MOV     W1,1B58
05B5E:  MOV     W2,1B5A
05B60:  MOV     W3,1B5C
05B62:  MOV     W5,1B82
05B64:  MOV     W6,1B84
05B66:  MOV     W7,1B86
05B68:  MOV     W8,1B88
05B6A:  MOV     W9,1B8A
05B6C:  MOV     W10,1B8C
05B6E:  MOV     W11,1B8E
05B70:  MOV     W12,1B90
05B72:  PUSH    1B4E
05B74:  POP     1B92
05B76:  PUSH    1B50
05B78:  POP     1B94
05B7A:  PUSH    1B52
05B7C:  POP     1B96
05B7E:  PUSH    1B54
05B80:  POP     1B98
05B82:  PUSH    1B56
05B84:  POP     1B9A
05B86:  PUSH    1B58
05B88:  POP     1B9C
05B8A:  PUSH    1B5A
05B8C:  POP     1B9E
05B8E:  PUSH    1B5C
05B90:  POP     1BA0
05B92:  CALL    332C
05B96:  MOV     W0,W5
05B98:  MOV     W1,W6
05B9A:  MOV     W2,W7
05B9C:  MOV     W3,W8
05B9E:  MOV     1B46,W4
05BA0:  MUL.UU  W4,#2,W0
05BA2:  MOV     #A8C,W4
05BA4:  ADD     W0,W4,W0
05BA6:  MOV     [W0],W9
05BA8:  MOV     W9,W4
05BAA:  MUL.UU  W4,#10,W0
05BAC:  MOV     W0,W9
05BAE:  MOV     #B60,W4
05BB0:  ADD     W9,W4,W0
05BB2:  MOV     W0,W4
05BB4:  MOV     #0,W3
05BB6:  MOV     [W4++],[W3++]
05BB8:  MOV     [W4++],[W3++]
05BBA:  MOV     #0,W2
05BBC:  MOV     #0,W3
05BBE:  CALL    1B2C
05BC2:  MOV     W0,W10
05BC4:  MOV     W1,W11
05BC6:  MOV     W2,W12
05BC8:  MOV     W3,W13
05BCA:  MOV     1B46,W4
05BCC:  MUL.UU  W4,#2,W0
05BCE:  MOV     #A8C,W4
05BD0:  ADD     W0,W4,W0
05BD2:  MOV     [W0],[W15++]
05BD4:  POP     1B4E
05BD6:  MOV     1B4E,W4
05BD8:  MUL.UU  W4,#10,W0
05BDA:  MOV     W0,1B4E
05BDC:  MOV     1B4E,W4
05BDE:  ADD     W4,#4,W0
05BE0:  MOV     #B60,W4
05BE2:  ADD     W0,W4,W0
05BE4:  MOV     W0,W4
05BE6:  MOV     #0,W3
05BE8:  MOV     [W4++],[W3++]
05BEA:  MOV     [W4++],[W3++]
05BEC:  MOV     #0,W2
05BEE:  MOV     #0,W3
05BF0:  CALL    1B2C
05BF4:  MOV     W0,1B4E
05BF6:  MOV     W1,1B50
05BF8:  MOV     W2,1B52
05BFA:  MOV     W3,1B54
05BFC:  MOV     1B42,W0
05BFE:  CLR     W3
05C00:  BTSC    W0.F
05C02:  SETM    W3
05C04:  MOV     W3,W1
05C06:  MOV     W3,W2
05C08:  CALL    1B2C
05C0C:  MOV     W0,1B56
05C0E:  MOV     W1,1B58
05C10:  MOV     W2,1B5A
05C12:  MOV     W3,1B5C
05C14:  MOV     1B44,W0
05C16:  CLR     W3
05C18:  BTSC    W0.F
05C1A:  SETM    W3
05C1C:  MOV     W3,W1
05C1E:  MOV     W3,W2
05C20:  CALL    1B2C
05C24:  MOV     W0,1B5E
05C26:  MOV     W1,1B60
05C28:  MOV     W2,1B62
05C2A:  MOV     W3,1B64
05C2C:  MOV     W10,1B82
05C2E:  MOV     W11,1B84
05C30:  MOV     W12,1B86
05C32:  MOV     W13,1B88
05C34:  PUSH    1B4E
05C36:  POP     1B8A
05C38:  PUSH    1B50
05C3A:  POP     1B8C
05C3C:  PUSH    1B52
05C3E:  POP     1B8E
05C40:  PUSH    1B54
05C42:  POP     1B90
05C44:  PUSH    1B56
05C46:  POP     1B92
05C48:  PUSH    1B58
05C4A:  POP     1B94
05C4C:  PUSH    1B5A
05C4E:  POP     1B96
05C50:  PUSH    1B5C
05C52:  POP     1B98
05C54:  PUSH    1B5E
05C56:  POP     1B9A
05C58:  PUSH    1B60
05C5A:  POP     1B9C
05C5C:  PUSH    1B62
05C5E:  POP     1B9E
05C60:  PUSH    1B64
05C62:  POP     1BA0
05C64:  CALL    332C
05C68:  BCLR.B  43.0
05C6A:  MOV     W5,[W15++]
05C6C:  MOV     W6,[W15++]
05C6E:  MOV     W7,[W15++]
05C70:  MOV     W0,W4
05C72:  MOV     W5,W0
05C74:  MOV     W1,W5
05C76:  MOV     W6,W1
05C78:  MOV     W2,W6
05C7A:  MOV     W7,W2
05C7C:  MOV     W3,W7
05C7E:  MOV     W8,W3
05C80:  CALL    1C40
05C84:  MOV     [--W15],W7
05C86:  MOV     [--W15],W6
05C88:  MOV     [--W15],W5
05C8A:  MOV     W0,W5
05C8C:  MOV     W1,W6
05C8E:  MOV     W2,W7
05C90:  MOV     W3,W8
05C92:  MOV     1B3E,W0
05C94:  CLR     W3
05C96:  BTSC    W0.F
05C98:  SETM    W3
05C9A:  MOV     W3,W1
05C9C:  MOV     W3,W2
05C9E:  CALL    1B2C
05CA2:  MOV     W0,W10
05CA4:  MOV     W1,W11
05CA6:  MOV     W2,W12
05CA8:  MOV     W3,W13
05CAA:  MOV     1B40,W0
05CAC:  CLR     W3
05CAE:  BTSC    W0.F
05CB0:  SETM    W3
05CB2:  MOV     W3,W1
05CB4:  MOV     W3,W2
05CB6:  CALL    1B2C
05CBA:  MOV     W0,1B4E
05CBC:  MOV     W1,1B50
05CBE:  MOV     W2,1B52
05CC0:  MOV     W3,1B54
05CC2:  MOV     1B46,W4
05CC4:  MUL.UU  W4,#2,W0
05CC6:  MOV     #A8C,W4
05CC8:  ADD     W0,W4,W0
05CCA:  MOV     [W0],[W15++]
05CCC:  POP     1B56
05CCE:  MOV     1B56,W4
05CD0:  MUL.UU  W4,#10,W0
05CD2:  MOV     W0,1B56
05CD4:  MOV     1B56,W4
05CD6:  ADD     W4,#8,W0
05CD8:  MOV     #B60,W4
05CDA:  ADD     W0,W4,W0
05CDC:  MOV     W0,W4
05CDE:  MOV     #0,W3
05CE0:  MOV     [W4++],[W3++]
05CE2:  MOV     [W4++],[W3++]
05CE4:  MOV     #0,W2
05CE6:  MOV     #0,W3
05CE8:  CALL    1B2C
05CEC:  MOV     W0,1B56
05CEE:  MOV     W1,1B58
05CF0:  MOV     W2,1B5A
05CF2:  MOV     W3,1B5C
05CF4:  MOV     1B46,W4
05CF6:  MUL.UU  W4,#2,W0
05CF8:  MOV     #A8C,W4
05CFA:  ADD     W0,W4,W0
05CFC:  MOV     [W0],[W15++]
05CFE:  POP     1B5E
05D00:  MOV     1B5E,W4
05D02:  MUL.UU  W4,#10,W0
05D04:  MOV     W0,1B5E
05D06:  MOV     1B5E,W4
05D08:  ADD     W4,#C,W0
05D0A:  MOV     #B60,W4
05D0C:  ADD     W0,W4,W0
05D0E:  MOV     W0,W4
05D10:  MOV     #0,W3
05D12:  MOV     [W4++],[W3++]
05D14:  MOV     [W4++],[W3++]
05D16:  MOV     #0,W2
05D18:  MOV     #0,W3
05D1A:  CALL    1B2C
05D1E:  MOV     W0,1B5E
05D20:  MOV     W1,1B60
05D22:  MOV     W2,1B62
05D24:  MOV     W3,1B64
05D26:  MOV     W10,1B82
05D28:  MOV     W11,1B84
05D2A:  MOV     W12,1B86
05D2C:  MOV     W13,1B88
05D2E:  PUSH    1B4E
05D30:  POP     1B8A
05D32:  PUSH    1B50
05D34:  POP     1B8C
05D36:  PUSH    1B52
05D38:  POP     1B8E
05D3A:  PUSH    1B54
05D3C:  POP     1B90
05D3E:  PUSH    1B56
05D40:  POP     1B92
05D42:  PUSH    1B58
05D44:  POP     1B94
05D46:  PUSH    1B5A
05D48:  POP     1B96
05D4A:  PUSH    1B5C
05D4C:  POP     1B98
05D4E:  PUSH    1B5E
05D50:  POP     1B9A
05D52:  PUSH    1B60
05D54:  POP     1B9C
05D56:  PUSH    1B62
05D58:  POP     1B9E
05D5A:  PUSH    1B64
05D5C:  POP     1BA0
05D5E:  CALL    332C
05D62:  MOV     W0,W10
05D64:  MOV     W1,W11
05D66:  MOV     W2,W12
05D68:  MOV     W3,W13
05D6A:  MOV     1B46,W4
05D6C:  MUL.UU  W4,#2,W0
05D6E:  MOV     #A8C,W4
05D70:  ADD     W0,W4,W0
05D72:  MOV     [W0],[W15++]
05D74:  POP     1B4E
05D76:  MOV     1B4E,W4
05D78:  MUL.UU  W4,#10,W0
05D7A:  MOV     W0,1B4E
05D7C:  MOV     1B4E,W4
05D7E:  ADD     W4,#8,W0
05D80:  MOV     #B60,W4
05D82:  ADD     W0,W4,W0
05D84:  MOV     W0,W4
05D86:  MOV     #0,W3
05D88:  MOV     [W4++],[W3++]
05D8A:  MOV     [W4++],[W3++]
05D8C:  MOV     #0,W2
05D8E:  MOV     #0,W3
05D90:  CALL    1B2C
05D94:  MOV     W0,1B4E
05D96:  MOV     W1,1B50
05D98:  MOV     W2,1B52
05D9A:  MOV     W3,1B54
05D9C:  MOV     1B46,W4
05D9E:  MUL.UU  W4,#2,W0
05DA0:  MOV     #A8C,W4
05DA2:  ADD     W0,W4,W0
05DA4:  MOV     [W0],[W15++]
05DA6:  POP     1B56
05DA8:  MOV     1B56,W4
05DAA:  MUL.UU  W4,#10,W0
05DAC:  MOV     W0,1B56
05DAE:  MOV     1B56,W4
05DB0:  ADD     W4,#C,W0
05DB2:  MOV     #B60,W4
05DB4:  ADD     W0,W4,W0
05DB6:  MOV     W0,W4
05DB8:  MOV     #0,W3
05DBA:  MOV     [W4++],[W3++]
05DBC:  MOV     [W4++],[W3++]
05DBE:  MOV     #0,W2
05DC0:  MOV     #0,W3
05DC2:  CALL    1B2C
05DC6:  MOV     W0,1B56
05DC8:  MOV     W1,1B58
05DCA:  MOV     W2,1B5A
05DCC:  MOV     W3,1B5C
05DCE:  MOV     1B42,W0
05DD0:  CLR     W3
05DD2:  BTSC    W0.F
05DD4:  SETM    W3
05DD6:  MOV     W3,W1
05DD8:  MOV     W3,W2
05DDA:  CALL    1B2C
05DDE:  MOV     W0,1B5E
05DE0:  MOV     W1,1B60
05DE2:  MOV     W2,1B62
05DE4:  MOV     W3,1B64
05DE6:  MOV     1B44,W0
05DE8:  CLR     W3
05DEA:  BTSC    W0.F
05DEC:  SETM    W3
05DEE:  MOV     W3,W1
05DF0:  MOV     W3,W2
05DF2:  CALL    1B2C
05DF6:  MOV     W0,1B66
05DF8:  MOV     W1,1B68
05DFA:  MOV     W2,1B6A
05DFC:  MOV     W3,1B6C
05DFE:  PUSH    1B4E
05E00:  POP     1B82
05E02:  PUSH    1B50
05E04:  POP     1B84
05E06:  PUSH    1B52
05E08:  POP     1B86
05E0A:  PUSH    1B54
05E0C:  POP     1B88
05E0E:  PUSH    1B56
05E10:  POP     1B8A
05E12:  PUSH    1B58
05E14:  POP     1B8C
05E16:  PUSH    1B5A
05E18:  POP     1B8E
05E1A:  PUSH    1B5C
05E1C:  POP     1B90
05E1E:  PUSH    1B5E
05E20:  POP     1B92
05E22:  PUSH    1B60
05E24:  POP     1B94
05E26:  PUSH    1B62
05E28:  POP     1B96
05E2A:  PUSH    1B64
05E2C:  POP     1B98
05E2E:  PUSH    1B66
05E30:  POP     1B9A
05E32:  PUSH    1B68
05E34:  POP     1B9C
05E36:  PUSH    1B6A
05E38:  POP     1B9E
05E3A:  PUSH    1B6C
05E3C:  POP     1BA0
05E3E:  CALL    332C
05E42:  BCLR.B  43.0
05E44:  MOV     W5,[W15++]
05E46:  MOV     W6,[W15++]
05E48:  MOV     W7,[W15++]
05E4A:  MOV     W0,W4
05E4C:  MOV     W1,W5
05E4E:  MOV     W2,W6
05E50:  MOV     W3,W7
05E52:  MOV     W10,W0
05E54:  MOV     W11,W1
05E56:  MOV     W12,W2
05E58:  MOV     W13,W3
05E5A:  CALL    1C40
05E5E:  MOV     [--W15],W7
05E60:  MOV     [--W15],W6
05E62:  MOV     [--W15],W5
05E64:  MOV     W5,[W15++]
05E66:  MOV     W6,[W15++]
05E68:  MOV     W7,[W15++]
05E6A:  MOV     W0,W4
05E6C:  MOV     W5,W0
05E6E:  MOV     W1,W5
05E70:  MOV     W6,W1
05E72:  MOV     W2,W6
05E74:  MOV     W7,W2
05E76:  MOV     W3,W7
05E78:  MOV     W8,W3
05E7A:  CALL    1E2E
05E7E:  MOV     [--W15],W7
05E80:  MOV     [--W15],W6
05E82:  MOV     [--W15],W5
05E84:  BRA     NC,5EF8
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05E86:  MOV     A88,W4
05E88:  MUL.UU  W4,#10,W0
05E8A:  MOV     W0,W5
05E8C:  MOV     #AA0,W4
05E8E:  ADD     W5,W4,W6
05E90:  MOV     1B46,W4
05E92:  MUL.UU  W4,#2,W0
05E94:  MOV     #A8C,W4
05E96:  ADD     W0,W4,W0
05E98:  MOV     [W0],W7
05E9A:  MOV     W7,W4
05E9C:  MUL.UU  W4,#10,W0
05E9E:  MOV     W0,W7
05EA0:  MOV     #B60,W4
05EA2:  ADD     W7,W4,W0
05EA4:  MOV     W0,W4
05EA6:  MOV     #0,W3
05EA8:  MOV     [W4++],[W3++]
05EAA:  MOV     [W4++],[W3++]
05EAC:  MOV     #0,W2
05EAE:  MOV     #0,W3
05EB0:  CALL    1B2C
05EB4:  MOV     #0,W4
05EB6:  REPEAT  #3
05EB8:  MOV     [W4++],[W6++]
05EBA:  MOV     A88,W4
05EBC:  MUL.UU  W4,#10,W0
05EBE:  MOV     W0,W5
05EC0:  ADD     W5,#8,W0
05EC2:  MOV     #AA0,W4
05EC4:  ADD     W0,W4,W5
05EC6:  MOV     1B46,W4
05EC8:  MUL.UU  W4,#2,W0
05ECA:  MOV     #A8C,W4
05ECC:  ADD     W0,W4,W0
05ECE:  MOV     [W0],W6
05ED0:  MOV     W6,W4
05ED2:  MUL.UU  W4,#10,W6
05ED4:  ADD     W6,#4,W0
05ED6:  MOV     #B60,W4
05ED8:  ADD     W0,W4,W0
05EDA:  MOV     W0,W4
05EDC:  MOV     #0,W3
05EDE:  MOV     [W4++],[W3++]
05EE0:  MOV     [W4++],[W3++]
05EE2:  MOV     #0,W2
05EE4:  MOV     #0,W3
05EE6:  CALL    1B2C
05EEA:  MOV     #0,W4
05EEC:  REPEAT  #3
05EEE:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
05EF0:  MOV     #1,W4
05EF2:  MOV     W4,1B4C
.................... 	                } 
05EF4:  GOTO    5F68
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
05EF8:  MOV     A88,W4
05EFA:  MUL.UU  W4,#10,W0
05EFC:  MOV     W0,W5
05EFE:  MOV     #AA0,W4
05F00:  ADD     W5,W4,W6
05F02:  MOV     1B46,W4
05F04:  MUL.UU  W4,#2,W0
05F06:  MOV     #A8C,W4
05F08:  ADD     W0,W4,W0
05F0A:  MOV     [W0],W7
05F0C:  MOV     W7,W4
05F0E:  MUL.UU  W4,#10,W0
05F10:  MOV     W0,W7
05F12:  ADD     W7,#8,W0
05F14:  MOV     #B60,W4
05F16:  ADD     W0,W4,W0
05F18:  MOV     W0,W4
05F1A:  MOV     #0,W3
05F1C:  MOV     [W4++],[W3++]
05F1E:  MOV     [W4++],[W3++]
05F20:  MOV     #0,W2
05F22:  MOV     #0,W3
05F24:  CALL    1B2C
05F28:  MOV     #0,W4
05F2A:  REPEAT  #3
05F2C:  MOV     [W4++],[W6++]
05F2E:  MOV     A88,W4
05F30:  MUL.UU  W4,#10,W0
05F32:  MOV     W0,W5
05F34:  ADD     W5,#8,W0
05F36:  MOV     #AA0,W4
05F38:  ADD     W0,W4,W5
05F3A:  MOV     1B46,W4
05F3C:  MUL.UU  W4,#2,W0
05F3E:  MOV     #A8C,W4
05F40:  ADD     W0,W4,W0
05F42:  MOV     [W0],W6
05F44:  MOV     W6,W4
05F46:  MUL.UU  W4,#10,W6
05F48:  ADD     W6,#C,W0
05F4A:  MOV     #B60,W4
05F4C:  ADD     W0,W4,W0
05F4E:  MOV     W0,W4
05F50:  MOV     #0,W3
05F52:  MOV     [W4++],[W3++]
05F54:  MOV     [W4++],[W3++]
05F56:  MOV     #0,W2
05F58:  MOV     #0,W3
05F5A:  CALL    1B2C
05F5E:  MOV     #0,W4
05F60:  REPEAT  #3
05F62:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 1; 
05F64:  MOV     #1,W4
05F66:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
05F68:  MOV     #1,W4
05F6A:  MOV     W4,A84
.................... 	            } 
05F6C:  GOTO    5FE8
.................... 	            else if (posEnd == 1) 
05F70:  MOV     1B4A,W4
05F72:  CP      W4,#1
05F74:  BRA     NZ,5FE8
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
05F76:  MOV     A88,W4
05F78:  MUL.UU  W4,#10,W0
05F7A:  MOV     W0,W5
05F7C:  MOV     #AA0,W4
05F7E:  ADD     W5,W4,W6
05F80:  MOV     1B46,W4
05F82:  MUL.UU  W4,#2,W0
05F84:  MOV     #A8C,W4
05F86:  ADD     W0,W4,W0
05F88:  MOV     [W0],W7
05F8A:  MOV     W7,W4
05F8C:  MUL.UU  W4,#10,W0
05F8E:  MOV     W0,W7
05F90:  MOV     #B60,W4
05F92:  ADD     W7,W4,W0
05F94:  MOV     W0,W4
05F96:  MOV     #0,W3
05F98:  MOV     [W4++],[W3++]
05F9A:  MOV     [W4++],[W3++]
05F9C:  MOV     #0,W2
05F9E:  MOV     #0,W3
05FA0:  CALL    1B2C
05FA4:  MOV     #0,W4
05FA6:  REPEAT  #3
05FA8:  MOV     [W4++],[W6++]
05FAA:  MOV     A88,W4
05FAC:  MUL.UU  W4,#10,W0
05FAE:  MOV     W0,W5
05FB0:  ADD     W5,#8,W0
05FB2:  MOV     #AA0,W4
05FB4:  ADD     W0,W4,W5
05FB6:  MOV     1B46,W4
05FB8:  MUL.UU  W4,#2,W0
05FBA:  MOV     #A8C,W4
05FBC:  ADD     W0,W4,W0
05FBE:  MOV     [W0],W6
05FC0:  MOV     W6,W4
05FC2:  MUL.UU  W4,#10,W6
05FC4:  ADD     W6,#4,W0
05FC6:  MOV     #B60,W4
05FC8:  ADD     W0,W4,W0
05FCA:  MOV     W0,W4
05FCC:  MOV     #0,W3
05FCE:  MOV     [W4++],[W3++]
05FD0:  MOV     [W4++],[W3++]
05FD2:  MOV     #0,W2
05FD4:  MOV     #0,W3
05FD6:  CALL    1B2C
05FDA:  MOV     #0,W4
05FDC:  REPEAT  #3
05FDE:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
05FE0:  MOV     #1,W4
05FE2:  MOV     W4,1B4C
.................... 	                path_found = true; 
05FE4:  MOV     #1,W4
05FE6:  MOV     W4,A84
.................... 	            } 
....................  
.................... 	            break; 
05FE8:  GOTO    66B2
....................  
.................... 	        case 7: 
.................... 	            if (posEnd == 5 || posEnd == 4) 
05FEC:  MOV     1B4A,W4
05FEE:  CP      W4,#5
05FF0:  BRA     Z,5FF8
05FF2:  MOV     1B4A,W4
05FF4:  CP      W4,#4
05FF6:  BRA     NZ,6078
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
05FF8:  MOV     A88,W4
05FFA:  MUL.UU  W4,#10,W0
05FFC:  MOV     W0,W5
05FFE:  MOV     #AA0,W4
06000:  ADD     W5,W4,W6
06002:  MOV     1B46,W4
06004:  MUL.UU  W4,#2,W0
06006:  MOV     #A8C,W4
06008:  ADD     W0,W4,W0
0600A:  MOV     [W0],W7
0600C:  MOV     W7,W4
0600E:  MUL.UU  W4,#10,W0
06010:  MOV     W0,W7
06012:  MOV     1B26,W4
06014:  MUL.UU  W4,#4,W0
06016:  ADD     W0,W7,W0
06018:  MOV     #B60,W4
0601A:  ADD     W0,W4,W0
0601C:  MOV     W0,W4
0601E:  MOV     #0,W3
06020:  MOV     [W4++],[W3++]
06022:  MOV     [W4++],[W3++]
06024:  MOV     #0,W2
06026:  MOV     #0,W3
06028:  CALL    1B2C
0602C:  MOV     #0,W4
0602E:  REPEAT  #3
06030:  MOV     [W4++],[W6++]
06032:  MOV     A88,W4
06034:  MUL.UU  W4,#10,W0
06036:  MOV     W0,W5
06038:  ADD     W5,#8,W0
0603A:  MOV     #AA0,W4
0603C:  ADD     W0,W4,W5
0603E:  MOV     1B46,W4
06040:  MUL.UU  W4,#2,W0
06042:  MOV     #A8C,W4
06044:  ADD     W0,W4,W0
06046:  MOV     [W0],W6
06048:  MOV     W6,W4
0604A:  MUL.UU  W4,#10,W6
0604C:  MOV     1B28,W4
0604E:  MUL.UU  W4,#4,W0
06050:  ADD     W0,W6,W0
06052:  MOV     #B60,W4
06054:  ADD     W0,W4,W0
06056:  MOV     W0,W4
06058:  MOV     #0,W3
0605A:  MOV     [W4++],[W3++]
0605C:  MOV     [W4++],[W3++]
0605E:  MOV     #0,W2
06060:  MOV     #0,W3
06062:  CALL    1B2C
06066:  MOV     #0,W4
06068:  REPEAT  #3
0606A:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0606C:  MOV     #1,W4
0606E:  MOV     W4,1B4C
.................... 	                path_found = true; 
06070:  MOV     #1,W4
06072:  MOV     W4,A84
.................... 	            } 
06074:  GOTO    66A2
.................... 	            else if (posEnd == 3) 
06078:  MOV     1B4A,W4
0607A:  CP      W4,#3
0607C:  BRA     NZ,6624
.................... 	            { 
.................... 	                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
0607E:  MOV     1B3E,W0
06080:  CLR     W3
06082:  BTSC    W0.F
06084:  SETM    W3
06086:  MOV     W3,W1
06088:  MOV     W3,W2
0608A:  CALL    1B2C
0608E:  MOV     W0,W5
06090:  MOV     W1,W6
06092:  MOV     W2,W7
06094:  MOV     W3,W8
06096:  MOV     1B40,W0
06098:  CLR     W3
0609A:  BTSC    W0.F
0609C:  SETM    W3
0609E:  MOV     W3,W1
060A0:  MOV     W3,W2
060A2:  CALL    1B2C
060A6:  MOV     W0,W9
060A8:  MOV     W1,W10
060AA:  MOV     W2,W11
060AC:  MOV     W3,W12
060AE:  MOV     1B46,W4
060B0:  MUL.UU  W4,#2,W0
060B2:  MOV     #A8C,W4
060B4:  ADD     W0,W4,W0
060B6:  MOV     [W0],W13
060B8:  MOV     W13,W4
060BA:  MUL.UU  W4,#10,W0
060BC:  MOV     W0,W13
060BE:  MOV     #B60,W4
060C0:  ADD     W13,W4,W0
060C2:  MOV     W0,W4
060C4:  MOV     #0,W3
060C6:  MOV     [W4++],[W3++]
060C8:  MOV     [W4++],[W3++]
060CA:  MOV     #0,W2
060CC:  MOV     #0,W3
060CE:  CALL    1B2C
060D2:  MOV     W0,1B4E
060D4:  MOV     W1,1B50
060D6:  MOV     W2,1B52
060D8:  MOV     W3,1B54
060DA:  MOV     1B46,W4
060DC:  MUL.UU  W4,#2,W0
060DE:  MOV     #A8C,W4
060E0:  ADD     W0,W4,W0
060E2:  MOV     [W0],[W15++]
060E4:  POP     1B56
060E6:  MOV     1B56,W4
060E8:  MUL.UU  W4,#10,W0
060EA:  MOV     W0,1B56
060EC:  MOV     1B56,W4
060EE:  ADD     W4,#4,W0
060F0:  MOV     #B60,W4
060F2:  ADD     W0,W4,W0
060F4:  MOV     W0,W4
060F6:  MOV     #0,W3
060F8:  MOV     [W4++],[W3++]
060FA:  MOV     [W4++],[W3++]
060FC:  MOV     #0,W2
060FE:  MOV     #0,W3
06100:  CALL    1B2C
06104:  MOV     W0,1B56
06106:  MOV     W1,1B58
06108:  MOV     W2,1B5A
0610A:  MOV     W3,1B5C
0610C:  MOV     W5,1B82
0610E:  MOV     W6,1B84
06110:  MOV     W7,1B86
06112:  MOV     W8,1B88
06114:  MOV     W9,1B8A
06116:  MOV     W10,1B8C
06118:  MOV     W11,1B8E
0611A:  MOV     W12,1B90
0611C:  PUSH    1B4E
0611E:  POP     1B92
06120:  PUSH    1B50
06122:  POP     1B94
06124:  PUSH    1B52
06126:  POP     1B96
06128:  PUSH    1B54
0612A:  POP     1B98
0612C:  PUSH    1B56
0612E:  POP     1B9A
06130:  PUSH    1B58
06132:  POP     1B9C
06134:  PUSH    1B5A
06136:  POP     1B9E
06138:  PUSH    1B5C
0613A:  POP     1BA0
0613C:  CALL    332C
06140:  MOV     W0,W5
06142:  MOV     W1,W6
06144:  MOV     W2,W7
06146:  MOV     W3,W8
06148:  MOV     1B46,W4
0614A:  MUL.UU  W4,#2,W0
0614C:  MOV     #A8C,W4
0614E:  ADD     W0,W4,W0
06150:  MOV     [W0],W9
06152:  MOV     W9,W4
06154:  MUL.UU  W4,#10,W0
06156:  MOV     W0,W9
06158:  MOV     1B2A,W4
0615A:  MUL.UU  W4,#4,W0
0615C:  ADD     W0,W9,W0
0615E:  MOV     #B60,W4
06160:  ADD     W0,W4,W0
06162:  MOV     W0,W4
06164:  MOV     #0,W3
06166:  MOV     [W4++],[W3++]
06168:  MOV     [W4++],[W3++]
0616A:  MOV     #0,W2
0616C:  MOV     #0,W3
0616E:  CALL    1B2C
06172:  MOV     W0,W9
06174:  MOV     W1,W10
06176:  MOV     W2,W11
06178:  MOV     W3,W12
0617A:  MOV     1B46,W4
0617C:  MUL.UU  W4,#2,W0
0617E:  MOV     #A8C,W4
06180:  ADD     W0,W4,W0
06182:  MOV     [W0],[W15++]
06184:  POP     1B4E
06186:  MOV     1B4E,W4
06188:  MUL.UU  W4,#10,W0
0618A:  MOV     W0,1B4E
0618C:  MOV     1B2C,W4
0618E:  MUL.UU  W4,#4,W0
06190:  MOV     1B4E,W4
06192:  ADD     W0,W4,W0
06194:  MOV     #B60,W4
06196:  ADD     W0,W4,W0
06198:  MOV     W0,W4
0619A:  MOV     #0,W3
0619C:  MOV     [W4++],[W3++]
0619E:  MOV     [W4++],[W3++]
061A0:  MOV     #0,W2
061A2:  MOV     #0,W3
061A4:  CALL    1B2C
061A8:  MOV     W0,1B4E
061AA:  MOV     W1,1B50
061AC:  MOV     W2,1B52
061AE:  MOV     W3,1B54
061B0:  MOV     1B42,W0
061B2:  CLR     W3
061B4:  BTSC    W0.F
061B6:  SETM    W3
061B8:  MOV     W3,W1
061BA:  MOV     W3,W2
061BC:  CALL    1B2C
061C0:  MOV     W0,1B56
061C2:  MOV     W1,1B58
061C4:  MOV     W2,1B5A
061C6:  MOV     W3,1B5C
061C8:  MOV     1B44,W0
061CA:  CLR     W3
061CC:  BTSC    W0.F
061CE:  SETM    W3
061D0:  MOV     W3,W1
061D2:  MOV     W3,W2
061D4:  CALL    1B2C
061D8:  MOV     W0,1B5E
061DA:  MOV     W1,1B60
061DC:  MOV     W2,1B62
061DE:  MOV     W3,1B64
061E0:  MOV     W9,1B82
061E2:  MOV     W10,1B84
061E4:  MOV     W11,1B86
061E6:  MOV     W12,1B88
061E8:  PUSH    1B4E
061EA:  POP     1B8A
061EC:  PUSH    1B50
061EE:  POP     1B8C
061F0:  PUSH    1B52
061F2:  POP     1B8E
061F4:  PUSH    1B54
061F6:  POP     1B90
061F8:  PUSH    1B56
061FA:  POP     1B92
061FC:  PUSH    1B58
061FE:  POP     1B94
06200:  PUSH    1B5A
06202:  POP     1B96
06204:  PUSH    1B5C
06206:  POP     1B98
06208:  PUSH    1B5E
0620A:  POP     1B9A
0620C:  PUSH    1B60
0620E:  POP     1B9C
06210:  PUSH    1B62
06212:  POP     1B9E
06214:  PUSH    1B64
06216:  POP     1BA0
06218:  CALL    332C
0621C:  BCLR.B  43.0
0621E:  MOV     W5,[W15++]
06220:  MOV     W6,[W15++]
06222:  MOV     W7,[W15++]
06224:  MOV     W0,W4
06226:  MOV     W5,W0
06228:  MOV     W1,W5
0622A:  MOV     W6,W1
0622C:  MOV     W2,W6
0622E:  MOV     W7,W2
06230:  MOV     W3,W7
06232:  MOV     W8,W3
06234:  CALL    1C40
06238:  MOV     [--W15],W7
0623A:  MOV     [--W15],W6
0623C:  MOV     [--W15],W5
0623E:  MOV     W0,W5
06240:  MOV     W1,W6
06242:  MOV     W2,W7
06244:  MOV     W3,W8
06246:  MOV     1B3E,W0
06248:  CLR     W3
0624A:  BTSC    W0.F
0624C:  SETM    W3
0624E:  MOV     W3,W1
06250:  MOV     W3,W2
06252:  CALL    1B2C
06256:  MOV     W0,W9
06258:  MOV     W1,W10
0625A:  MOV     W2,W11
0625C:  MOV     W3,W12
0625E:  MOV     1B40,W0
06260:  CLR     W3
06262:  BTSC    W0.F
06264:  SETM    W3
06266:  MOV     W3,W1
06268:  MOV     W3,W2
0626A:  CALL    1B2C
0626E:  MOV     W0,1B4E
06270:  MOV     W1,1B50
06272:  MOV     W2,1B52
06274:  MOV     W3,1B54
06276:  MOV     1B46,W4
06278:  MUL.UU  W4,#2,W0
0627A:  MOV     #A8C,W4
0627C:  ADD     W0,W4,W0
0627E:  MOV     [W0],[W15++]
06280:  POP     1B56
06282:  MOV     1B56,W4
06284:  MUL.UU  W4,#10,W0
06286:  MOV     W0,1B56
06288:  MOV     1B26,W4
0628A:  MUL.UU  W4,#4,W0
0628C:  MOV     1B56,W4
0628E:  ADD     W0,W4,W0
06290:  MOV     #B60,W4
06292:  ADD     W0,W4,W0
06294:  MOV     W0,W4
06296:  MOV     #0,W3
06298:  MOV     [W4++],[W3++]
0629A:  MOV     [W4++],[W3++]
0629C:  MOV     #0,W2
0629E:  MOV     #0,W3
062A0:  CALL    1B2C
062A4:  MOV     W0,1B56
062A6:  MOV     W1,1B58
062A8:  MOV     W2,1B5A
062AA:  MOV     W3,1B5C
062AC:  MOV     1B46,W4
062AE:  MUL.UU  W4,#2,W0
062B0:  MOV     #A8C,W4
062B2:  ADD     W0,W4,W0
062B4:  MOV     [W0],[W15++]
062B6:  POP     1B5E
062B8:  MOV     1B5E,W4
062BA:  MUL.UU  W4,#10,W0
062BC:  MOV     W0,1B5E
062BE:  MOV     1B28,W4
062C0:  MUL.UU  W4,#4,W0
062C2:  MOV     1B5E,W4
062C4:  ADD     W0,W4,W0
062C6:  MOV     #B60,W4
062C8:  ADD     W0,W4,W0
062CA:  MOV     W0,W4
062CC:  MOV     #0,W3
062CE:  MOV     [W4++],[W3++]
062D0:  MOV     [W4++],[W3++]
062D2:  MOV     #0,W2
062D4:  MOV     #0,W3
062D6:  CALL    1B2C
062DA:  MOV     W0,1B5E
062DC:  MOV     W1,1B60
062DE:  MOV     W2,1B62
062E0:  MOV     W3,1B64
062E2:  MOV     W9,1B82
062E4:  MOV     W10,1B84
062E6:  MOV     W11,1B86
062E8:  MOV     W12,1B88
062EA:  PUSH    1B4E
062EC:  POP     1B8A
062EE:  PUSH    1B50
062F0:  POP     1B8C
062F2:  PUSH    1B52
062F4:  POP     1B8E
062F6:  PUSH    1B54
062F8:  POP     1B90
062FA:  PUSH    1B56
062FC:  POP     1B92
062FE:  PUSH    1B58
06300:  POP     1B94
06302:  PUSH    1B5A
06304:  POP     1B96
06306:  PUSH    1B5C
06308:  POP     1B98
0630A:  PUSH    1B5E
0630C:  POP     1B9A
0630E:  PUSH    1B60
06310:  POP     1B9C
06312:  PUSH    1B62
06314:  POP     1B9E
06316:  PUSH    1B64
06318:  POP     1BA0
0631A:  CALL    332C
0631E:  MOV     W0,W9
06320:  MOV     W1,W10
06322:  MOV     W2,W11
06324:  MOV     W3,W12
06326:  MOV     1B46,W4
06328:  MUL.UU  W4,#2,W0
0632A:  MOV     #A8C,W4
0632C:  ADD     W0,W4,W0
0632E:  MOV     [W0],[W15++]
06330:  POP     1B4E
06332:  MOV     1B4E,W4
06334:  MUL.UU  W4,#10,W0
06336:  MOV     W0,1B4E
06338:  MOV     1B4E,W4
0633A:  ADD     W4,#8,W0
0633C:  MOV     #B60,W4
0633E:  ADD     W0,W4,W0
06340:  MOV     W0,W4
06342:  MOV     #0,W3
06344:  MOV     [W4++],[W3++]
06346:  MOV     [W4++],[W3++]
06348:  MOV     #0,W2
0634A:  MOV     #0,W3
0634C:  CALL    1B2C
06350:  MOV     W0,1B4E
06352:  MOV     W1,1B50
06354:  MOV     W2,1B52
06356:  MOV     W3,1B54
06358:  MOV     1B46,W4
0635A:  MUL.UU  W4,#2,W0
0635C:  MOV     #A8C,W4
0635E:  ADD     W0,W4,W0
06360:  MOV     [W0],[W15++]
06362:  POP     1B56
06364:  MOV     1B56,W4
06366:  MUL.UU  W4,#10,W0
06368:  MOV     W0,1B56
0636A:  MOV     1B56,W4
0636C:  ADD     W4,#C,W0
0636E:  MOV     #B60,W4
06370:  ADD     W0,W4,W0
06372:  MOV     W0,W4
06374:  MOV     #0,W3
06376:  MOV     [W4++],[W3++]
06378:  MOV     [W4++],[W3++]
0637A:  MOV     #0,W2
0637C:  MOV     #0,W3
0637E:  CALL    1B2C
06382:  MOV     W0,1B56
06384:  MOV     W1,1B58
06386:  MOV     W2,1B5A
06388:  MOV     W3,1B5C
0638A:  MOV     1B42,W0
0638C:  CLR     W3
0638E:  BTSC    W0.F
06390:  SETM    W3
06392:  MOV     W3,W1
06394:  MOV     W3,W2
06396:  CALL    1B2C
0639A:  MOV     W0,1B5E
0639C:  MOV     W1,1B60
0639E:  MOV     W2,1B62
063A0:  MOV     W3,1B64
063A2:  MOV     1B44,W0
063A4:  CLR     W3
063A6:  BTSC    W0.F
063A8:  SETM    W3
063AA:  MOV     W3,W1
063AC:  MOV     W3,W2
063AE:  CALL    1B2C
063B2:  MOV     W0,1B66
063B4:  MOV     W1,1B68
063B6:  MOV     W2,1B6A
063B8:  MOV     W3,1B6C
063BA:  PUSH    1B4E
063BC:  POP     1B82
063BE:  PUSH    1B50
063C0:  POP     1B84
063C2:  PUSH    1B52
063C4:  POP     1B86
063C6:  PUSH    1B54
063C8:  POP     1B88
063CA:  PUSH    1B56
063CC:  POP     1B8A
063CE:  PUSH    1B58
063D0:  POP     1B8C
063D2:  PUSH    1B5A
063D4:  POP     1B8E
063D6:  PUSH    1B5C
063D8:  POP     1B90
063DA:  PUSH    1B5E
063DC:  POP     1B92
063DE:  PUSH    1B60
063E0:  POP     1B94
063E2:  PUSH    1B62
063E4:  POP     1B96
063E6:  PUSH    1B64
063E8:  POP     1B98
063EA:  PUSH    1B66
063EC:  POP     1B9A
063EE:  PUSH    1B68
063F0:  POP     1B9C
063F2:  PUSH    1B6A
063F4:  POP     1B9E
063F6:  PUSH    1B6C
063F8:  POP     1BA0
063FA:  CALL    332C
063FE:  BCLR.B  43.0
06400:  MOV     W5,[W15++]
06402:  MOV     W6,[W15++]
06404:  MOV     W7,[W15++]
06406:  MOV     W0,W4
06408:  MOV     W1,W5
0640A:  MOV     W2,W6
0640C:  MOV     W3,W7
0640E:  MOV     W9,W0
06410:  MOV     W10,W1
06412:  MOV     W11,W2
06414:  MOV     W12,W3
06416:  CALL    1C40
0641A:  MOV     [--W15],W7
0641C:  MOV     [--W15],W6
0641E:  MOV     [--W15],W5
06420:  MOV     W5,[W15++]
06422:  MOV     W6,[W15++]
06424:  MOV     W7,[W15++]
06426:  MOV     W0,W4
06428:  MOV     W5,W0
0642A:  MOV     W1,W5
0642C:  MOV     W6,W1
0642E:  MOV     W2,W6
06430:  MOV     W7,W2
06432:  MOV     W3,W7
06434:  MOV     W8,W3
06436:  CALL    1E2E
0643A:  MOV     [--W15],W7
0643C:  MOV     [--W15],W6
0643E:  MOV     [--W15],W5
06440:  BRA     NC,6530
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y1]; 
06442:  MOV     A88,W4
06444:  MUL.UU  W4,#10,W0
06446:  MOV     W0,W5
06448:  MOV     #AA0,W4
0644A:  ADD     W5,W4,W6
0644C:  MOV     1B46,W4
0644E:  MUL.UU  W4,#2,W0
06450:  MOV     #A8C,W4
06452:  ADD     W0,W4,W0
06454:  MOV     [W0],W7
06456:  MOV     W7,W4
06458:  MUL.UU  W4,#10,W0
0645A:  MOV     W0,W7
0645C:  MOV     #B60,W4
0645E:  ADD     W7,W4,W0
06460:  MOV     W0,W4
06462:  MOV     #0,W3
06464:  MOV     [W4++],[W3++]
06466:  MOV     [W4++],[W3++]
06468:  MOV     #0,W2
0646A:  MOV     #0,W3
0646C:  CALL    1B2C
06470:  MOV     #0,W4
06472:  REPEAT  #3
06474:  MOV     [W4++],[W6++]
06476:  MOV     A88,W4
06478:  ADD     W4,#1,W5
0647A:  MOV     W5,W4
0647C:  MUL.UU  W4,#10,W0
0647E:  MOV     W0,W5
06480:  ADD     W5,#8,W0
06482:  MOV     #AA0,W4
06484:  ADD     W0,W4,W5
06486:  MOV     1B46,W4
06488:  MUL.UU  W4,#2,W0
0648A:  MOV     #A8C,W4
0648C:  ADD     W0,W4,W0
0648E:  MOV     [W0],W6
06490:  MOV     W6,W4
06492:  MUL.UU  W4,#10,W6
06494:  ADD     W6,#4,W0
06496:  MOV     #B60,W4
06498:  ADD     W0,W4,W0
0649A:  MOV     W0,W4
0649C:  MOV     #0,W3
0649E:  MOV     [W4++],[W3++]
064A0:  MOV     [W4++],[W3++]
064A2:  MOV     #0,W2
064A4:  MOV     #0,W3
064A6:  CALL    1B2C
064AA:  MOV     #0,W4
064AC:  REPEAT  #3
064AE:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
064B0:  MOV     A88,W4
064B2:  ADD     W4,#1,W5
064B4:  MOV     W5,W4
064B6:  MUL.UU  W4,#10,W0
064B8:  MOV     W0,W5
064BA:  MOV     #AA0,W4
064BC:  ADD     W5,W4,W6
064BE:  MOV     1B46,W4
064C0:  MUL.UU  W4,#2,W0
064C2:  MOV     #A8C,W4
064C4:  ADD     W0,W4,W0
064C6:  MOV     [W0],W7
064C8:  MOV     W7,W4
064CA:  MUL.UU  W4,#10,W0
064CC:  MOV     W0,W7
064CE:  MOV     1B2A,W4
064D0:  MUL.UU  W4,#4,W0
064D2:  ADD     W0,W7,W0
064D4:  MOV     #B60,W4
064D6:  ADD     W0,W4,W0
064D8:  MOV     W0,W4
064DA:  MOV     #0,W3
064DC:  MOV     [W4++],[W3++]
064DE:  MOV     [W4++],[W3++]
064E0:  MOV     #0,W2
064E2:  MOV     #0,W3
064E4:  CALL    1B2C
064E8:  MOV     #0,W4
064EA:  REPEAT  #3
064EC:  MOV     [W4++],[W6++]
064EE:  MOV     A88,W4
064F0:  MUL.UU  W4,#10,W0
064F2:  MOV     W0,W5
064F4:  ADD     W5,#8,W0
064F6:  MOV     #AA0,W4
064F8:  ADD     W0,W4,W5
064FA:  MOV     1B46,W4
064FC:  MUL.UU  W4,#2,W0
064FE:  MOV     #A8C,W4
06500:  ADD     W0,W4,W0
06502:  MOV     [W0],W6
06504:  MOV     W6,W4
06506:  MUL.UU  W4,#10,W6
06508:  MOV     1B2C,W4
0650A:  MUL.UU  W4,#4,W0
0650C:  ADD     W0,W6,W0
0650E:  MOV     #B60,W4
06510:  ADD     W0,W4,W0
06512:  MOV     W0,W4
06514:  MOV     #0,W3
06516:  MOV     [W4++],[W3++]
06518:  MOV     [W4++],[W3++]
0651A:  MOV     #0,W2
0651C:  MOV     #0,W3
0651E:  CALL    1B2C
06522:  MOV     #0,W4
06524:  REPEAT  #3
06526:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
06528:  MOV     #2,W4
0652A:  MOV     W4,1B4C
.................... 	                } 
0652C:  GOTO    661C
.................... 	                else 
.................... 	                { 
.................... 	                    PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel + 1].Y = TabZones[TabIntersection[i_zone]][y3]; 
06530:  MOV     A88,W4
06532:  MUL.UU  W4,#10,W0
06534:  MOV     W0,W5
06536:  MOV     #AA0,W4
06538:  ADD     W5,W4,W6
0653A:  MOV     1B46,W4
0653C:  MUL.UU  W4,#2,W0
0653E:  MOV     #A8C,W4
06540:  ADD     W0,W4,W0
06542:  MOV     [W0],W7
06544:  MOV     W7,W4
06546:  MUL.UU  W4,#10,W0
06548:  MOV     W0,W7
0654A:  MOV     1B26,W4
0654C:  MUL.UU  W4,#4,W0
0654E:  ADD     W0,W7,W0
06550:  MOV     #B60,W4
06552:  ADD     W0,W4,W0
06554:  MOV     W0,W4
06556:  MOV     #0,W3
06558:  MOV     [W4++],[W3++]
0655A:  MOV     [W4++],[W3++]
0655C:  MOV     #0,W2
0655E:  MOV     #0,W3
06560:  CALL    1B2C
06564:  MOV     #0,W4
06566:  REPEAT  #3
06568:  MOV     [W4++],[W6++]
0656A:  MOV     A88,W4
0656C:  ADD     W4,#1,W5
0656E:  MOV     W5,W4
06570:  MUL.UU  W4,#10,W0
06572:  MOV     W0,W5
06574:  ADD     W5,#8,W0
06576:  MOV     #AA0,W4
06578:  ADD     W0,W4,W5
0657A:  MOV     1B46,W4
0657C:  MUL.UU  W4,#2,W0
0657E:  MOV     #A8C,W4
06580:  ADD     W0,W4,W0
06582:  MOV     [W0],W6
06584:  MOV     W6,W4
06586:  MUL.UU  W4,#10,W6
06588:  MOV     1B28,W4
0658A:  MUL.UU  W4,#4,W0
0658C:  ADD     W0,W6,W0
0658E:  MOV     #B60,W4
06590:  ADD     W0,W4,W0
06592:  MOV     W0,W4
06594:  MOV     #0,W3
06596:  MOV     [W4++],[W3++]
06598:  MOV     [W4++],[W3++]
0659A:  MOV     #0,W2
0659C:  MOV     #0,W3
0659E:  CALL    1B2C
065A2:  MOV     #0,W4
065A4:  REPEAT  #3
065A6:  MOV     [W4++],[W5++]
.................... 	                    PtsRelai[i_rel + 1].X = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y4]; 
065A8:  MOV     A88,W4
065AA:  ADD     W4,#1,W5
065AC:  MOV     W5,W4
065AE:  MUL.UU  W4,#10,W0
065B0:  MOV     W0,W5
065B2:  MOV     #AA0,W4
065B4:  ADD     W5,W4,W6
065B6:  MOV     1B46,W4
065B8:  MUL.UU  W4,#2,W0
065BA:  MOV     #A8C,W4
065BC:  ADD     W0,W4,W0
065BE:  MOV     [W0],W7
065C0:  MOV     W7,W4
065C2:  MUL.UU  W4,#10,W0
065C4:  MOV     W0,W7
065C6:  ADD     W7,#8,W0
065C8:  MOV     #B60,W4
065CA:  ADD     W0,W4,W0
065CC:  MOV     W0,W4
065CE:  MOV     #0,W3
065D0:  MOV     [W4++],[W3++]
065D2:  MOV     [W4++],[W3++]
065D4:  MOV     #0,W2
065D6:  MOV     #0,W3
065D8:  CALL    1B2C
065DC:  MOV     #0,W4
065DE:  REPEAT  #3
065E0:  MOV     [W4++],[W6++]
065E2:  MOV     A88,W4
065E4:  MUL.UU  W4,#10,W0
065E6:  MOV     W0,W5
065E8:  ADD     W5,#8,W0
065EA:  MOV     #AA0,W4
065EC:  ADD     W0,W4,W5
065EE:  MOV     1B46,W4
065F0:  MUL.UU  W4,#2,W0
065F2:  MOV     #A8C,W4
065F4:  ADD     W0,W4,W0
065F6:  MOV     [W0],W6
065F8:  MOV     W6,W4
065FA:  MUL.UU  W4,#10,W6
065FC:  ADD     W6,#C,W0
065FE:  MOV     #B60,W4
06600:  ADD     W0,W4,W0
06602:  MOV     W0,W4
06604:  MOV     #0,W3
06606:  MOV     [W4++],[W3++]
06608:  MOV     [W4++],[W3++]
0660A:  MOV     #0,W2
0660C:  MOV     #0,W3
0660E:  CALL    1B2C
06612:  MOV     #0,W4
06614:  REPEAT  #3
06616:  MOV     [W4++],[W5++]
.................... 	                    relay_point_number = 2; 
06618:  MOV     #2,W4
0661A:  MOV     W4,1B4C
.................... 	                } 
.................... 	                path_found = true; 
0661C:  MOV     #1,W4
0661E:  MOV     W4,A84
.................... 	            } 
06620:  GOTO    66A2
.................... 	            else if (posEnd == 2 || posEnd == 1) 
06624:  MOV     1B4A,W4
06626:  CP      W4,#2
06628:  BRA     Z,6630
0662A:  MOV     1B4A,W4
0662C:  CP      W4,#1
0662E:  BRA     NZ,66A2
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y1]; 
06630:  MOV     A88,W4
06632:  MUL.UU  W4,#10,W0
06634:  MOV     W0,W5
06636:  MOV     #AA0,W4
06638:  ADD     W5,W4,W6
0663A:  MOV     1B46,W4
0663C:  MUL.UU  W4,#2,W0
0663E:  MOV     #A8C,W4
06640:  ADD     W0,W4,W0
06642:  MOV     [W0],W7
06644:  MOV     W7,W4
06646:  MUL.UU  W4,#10,W0
06648:  MOV     W0,W7
0664A:  MOV     #B60,W4
0664C:  ADD     W7,W4,W0
0664E:  MOV     W0,W4
06650:  MOV     #0,W3
06652:  MOV     [W4++],[W3++]
06654:  MOV     [W4++],[W3++]
06656:  MOV     #0,W2
06658:  MOV     #0,W3
0665A:  CALL    1B2C
0665E:  MOV     #0,W4
06660:  REPEAT  #3
06662:  MOV     [W4++],[W6++]
06664:  MOV     A88,W4
06666:  MUL.UU  W4,#10,W0
06668:  MOV     W0,W5
0666A:  ADD     W5,#8,W0
0666C:  MOV     #AA0,W4
0666E:  ADD     W0,W4,W5
06670:  MOV     1B46,W4
06672:  MUL.UU  W4,#2,W0
06674:  MOV     #A8C,W4
06676:  ADD     W0,W4,W0
06678:  MOV     [W0],W6
0667A:  MOV     W6,W4
0667C:  MUL.UU  W4,#10,W6
0667E:  ADD     W6,#4,W0
06680:  MOV     #B60,W4
06682:  ADD     W0,W4,W0
06684:  MOV     W0,W4
06686:  MOV     #0,W3
06688:  MOV     [W4++],[W3++]
0668A:  MOV     [W4++],[W3++]
0668C:  MOV     #0,W2
0668E:  MOV     #0,W3
06690:  CALL    1B2C
06694:  MOV     #0,W4
06696:  REPEAT  #3
06698:  MOV     [W4++],[W5++]
.................... 	                relay_point_number = 1; 
0669A:  MOV     #1,W4
0669C:  MOV     W4,1B4C
.................... 	                path_found = true; 
0669E:  MOV     #1,W4
066A0:  MOV     W4,A84
.................... 	            } 
....................  
....................  
.................... 	            break; 
066A2:  GOTO    66B2
....................  
.................... 	        case 8: 
....................  
.................... 	            path_found = false; 
066A6:  CLR     A84
....................  
.................... 	            break; 
066A8:  GOTO    66B2
....................  
.................... 	        default: 
.................... 	            path_found = false; 
066AC:  CLR     A84
.................... 	            break; 
066AE:  GOTO    66B2
.................... 	    } 
....................  
.................... 	    i_rel = i_rel + relay_point_number;     
066B2:  MOV     A88,W0
066B4:  ADD     1B4C,W0
066B6:  MOV     W0,A88
....................     } 
066B8:  MOV     #1A,W5
066BA:  REPEAT  #7
066BC:  MOV     [--W15],[W5--]
066BE:  MOV     [--W15],W5
066C0:  RETURN  
....................   
.................... } 
....................  
.................... /* 
.................... void checkIntersection(double pt1X, double pt1Y, double pt2X, double pt2Y) 
.................... { 
.................... 	struct Coord spot; 
....................  
.................... 	 
.................... 	int isInZone = 0; 
.................... 	int zoneToCheck = 0; 
.................... 	enum{x1, y1, x2, y2, x3, y3, x4, y4}; 
....................  
.................... 	double dX = pt2X-pt1X; 
.................... 	double dY = pt2Y-pt1Y; 
....................  
.................... 	int i = 0; 
.................... 	do 
.................... 	{ 
.................... 		i++; 
....................  
.................... 		//On calcule des points le long du trajet 
.................... 		spot.X = (dX*i)/100; 
.................... 		spot.Y = (dY*i)/100; 
....................  
....................         isInZone = 0; 
....................  
....................         //Pour chaque point du trajet on vÃ©rifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < NbreZone_check; zoneToCheck++) 
.................... 		{ 
.................... 	        //On vÃ©rifie si le point se trouve dans la zone interdite 
.................... 			if ((spot.X+pt1X) >= TabZones[zoneToCheck][x1] && (spot.X+pt1X) <= TabZones[zoneToCheck][x4]) 
.................... 			{ 
.................... 				if ((spot.Y+pt1Y) >= TabZones[zoneToCheck][y1] && (spot.Y+pt1Y) <= TabZones[zoneToCheck][y4]) 
.................... 				{ 
.................... 					//Si on a dÃ©jÃ  trouvÃ© une intersection, 
.................... 					if (intersection_found > 0) 
.................... 					{ 
.................... 						//On vÃ©rifie si ce n'est pas avec la mÃªme zone alors on peut ajouter une intersection 
.................... 						if (TabIntersection[intersection_found-1] != zoneToCheck) 
.................... 						{ 
.................... 							TabIntersection[intersection_found] = zoneToCheck; 
.................... 							intersection_found++; 
.................... 						} 
.................... 					} 
.................... 					//Si c'est la premiÃ¨re intersection qu'on trouve alors on l'ajoute 
.................... 					else 
.................... 					{ 
.................... 						TabIntersection[intersection_found] = zoneToCheck; 
.................... 						intersection_found++; 
.................... 					} 
.................... 					 
.................... 				} 
.................... 					 
.................... 					 
.................... 			} 
.................... 		} 
.................... 			 
.................... 	}while (i < 100); 
.................... } 
....................  
.................... int getPos(int px, int py, int rx1, int ry1, int rx4, int ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 4; //Le point se trouve en bas Ã  droite de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 3; //Le point se trouve Ã  droite de la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut Ã  droite de la zone 
....................         } 
....................     } 
....................     else if (px > rx1) 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
....................         } 
....................     } 
....................     else 
....................     { 
....................         if (py > ry4) 
....................         { 
....................             pos = 6; //Le point se trouve en bas Ã  gauche de la zone 
....................         } 
....................         else if (py > ry1) 
....................         { 
....................             pos = 7; //Le point se trouve Ã  gauche de la zone 
....................         } 
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut Ã  gauche de la zone 
....................         } 
....................     } 
....................  
....................     return pos; 
....................          
.................... } 
....................  
.................... void findRel(int posStart, int posEnd, int i_zone) 
.................... { 
.................... 	int path_found = false; 
....................     int relay_point_number = 0;    
....................     switch (posStart) 
....................     { 
.................... 	    case 0: 
.................... 	        if (posEnd == 3) 
.................... 	        { 
.................... 	            PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	            relay_point_number = 1; 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        else if (posEnd == 4) 
.................... 	        { 
.................... 	            if ((getDist(Pos_x, Pos_y, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], oXp, oYp)) > (getDist(Pos_x, Pos_y, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], oXp, oYp))) 
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	                relay_point_number = 1; 
.................... 	            } 
.................... 	            else  
.................... 	            { 
.................... 	                PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y3]; 
.................... 	                relay_point_number = 1; 
.................... 	            } 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        else if (posEnd ==5) 
.................... 	        { 
.................... 	        	PtsRelai[i_rel].X = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel].Y = TabZones[TabIntersection[i_zone]][y2]; 
.................... 	            relay_point_number = 1; 
.................... 	            path_found = true; 
.................... 	        } 
.................... 	        break; 
....................  
.................... 	    case 1: 
....................  
.................... 	        break; 
....................  
.................... 	    case 2: 
....................  
.................... 	        break; 
....................  
.................... 	    case 3: 
....................  
.................... 	        break; 
....................  
.................... 	    case 4: 
....................  
.................... 	        break; 
....................  
.................... 	    case 5: 
....................  
.................... 	        break; 
....................  
.................... 	    case 6: 
....................  
.................... 	        break; 
....................  
.................... 	    case 7: 
....................  
.................... 	        break; 
....................  
.................... 	    case 8: 
....................  
.................... 	        break; 
....................  
.................... 	    default : 
.................... 	        path_found = false; 
.................... 	        break; 
....................     } 
....................  
....................     i_rel = i_rel+relay_point_number; 
.................... } 
....................  
.................... void findPath() 
.................... { 
.................... 	enum{x1, y1, x2, y2, x3, y3, x4, y4}; 
....................  
.................... 	 
....................  
.................... 	//On rÃ©cupÃ¨re la position des deux points par rapport Ã  la zone 
.................... 	int pos1 = getPos(Pos_x, Pos_y, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
.................... 	int pos2 = getPos(oXp, oYp, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
....................  
.................... 	findRel(pos1, pos2, 0); 
....................  
.................... 	checkIntersection(PtsRelai[0].X, PtsRelai[0].Y, oXp, oYp); 
....................  
.................... 	if(intersection_found == 0) 
.................... 	{ 
.................... 		goToObj(); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		pos1 = getPos(PtsRelai[0].X, PtsRelai[0].Y, TabZones[TabIntersection[0]][x1], TabZones[TabIntersection[0]][y1], TabZones[TabIntersection[0]][x4], TabZones[TabIntersection[0]][y4]); 
.................... 		findRel(pos1, pos2, 1) 
.................... 	} 
.................... 	 
....................  
.................... } 
....................  
.................... void checkPath() 
.................... { 
.................... 	checkIntersection(Pos_x, Pos_y, oXp, oYp); 
....................  
.................... 	if(intersection_found == 0) 
.................... 	{ 
.................... 		__DeplToDo(oType); 
.................... 	} 
.................... 	else 
.................... 	{ 
.................... 		findPath(); 
.................... 	} 
....................  
.................... } 
.................... */ 
....................  
.................... #endif  
....................  
....................  
.................... #endif  
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////// 
.................... // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // 
.................... // La plage ROM 0 ÃÂ  511 est rÃÂ©servÃÂ©e aux objectifs. // 
.................... // 512/513 : Nombre d'objectifs 
.................... // 514/515 : Si des objectifs sont chargÃÂ©s 
.................... ////////////////////////////////////////////////////// 
....................  
.................... //******************************************************************************** 
.................... //*  Main 
.................... //**************************************************************************************************** 
.................... void main(void) 
*
0A94C:  MOV     W5,[W15++]
0A94E:  MOV     W6,[W15++]
0A950:  MOV     W7,[W15++]
0A952:  MOV     #2000,W15
0A954:  MOV     #27FF,W0
0A956:  MOV     W0,20
0A958:  NOP     
0A95A:  MOV     #7444,W0
0A95C:  MOV     W0,94
0A95E:  MOV     #4744,W0
0A960:  MOV     W0,96
0A962:  BSET.B  81.7
0A964:  BCLR.B  2E4.3
0A966:  BCLR.B  2E4.2
0A968:  BCLR.B  2E8.2
0A96A:  BCLR.B  2E8.3
0A96C:  BSET.B  207.7
0A96E:  BSET.B  207.5
0A970:  BSET.B  206.6
0A972:  BCLR.B  207.3
0A974:  BSET.B  206.7
0A976:  BCLR.B  207.0
0A978:  BSET.B  207.1
0A97A:  BCLR.B  207.2
0A97C:  CLR     20A
0A97E:  MOV     #C2,W4
0A980:  MOV     W4,204
0A982:  MOV     #8000,W4
0A984:  MOV     W4,216
0A986:  MOV     #400,W4
0A988:  MOV     W4,218
0A98A:  MOV     #A,W4
0A98C:  MOV     W4,21E
0A98E:  BCLR.B  85A.0
0A990:  BCLR.B  85A.1
0A992:  BCLR.B  85A.2
0A994:  BCLR.B  85A.3
0A996:  BCLR.B  85A.4
0A998:  BCLR.B  85A.5
0A99A:  BCLR.B  85A.6
0A99C:  BCLR.B  85A.7
0A99E:  BCLR.B  85B.0
0A9A0:  BCLR.B  85B.1
0A9A2:  BCLR.B  85B.2
0A9A4:  BCLR.B  85B.3
0A9A6:  CLR     85C
0A9A8:  CLR     85E
0A9AA:  CLR.B   860
0A9AC:  CLR     862
0A9AE:  CLR     864
0A9B0:  CLR     866
0A9B2:  CLR     868
0A9B4:  CLR     86A
0A9B6:  CLR     86C
0A9B8:  CLR.B   861
0A9BA:  CLR.B   86E
0A9BC:  MOV.B   #6,W0L
0A9BE:  MOV.B   W0L,86F
0A9C0:  CLR.B   870
0A9C2:  CLR.B   871
0A9C4:  CLR.B   872
0A9C6:  MOV.B   #1,W0L
0A9C8:  MOV.B   W0L,873
0A9CA:  MOV.B   #1,W0L
0A9CC:  MOV.B   W0L,874
0A9CE:  CLR     876
0A9D0:  CLR     878
0A9D2:  BSET.B  85B.4
0A9D4:  CLR.B   875
0A9D6:  CLR.B   87A
0A9D8:  CLR.B   87B
0A9DA:  CLR.B   87C
0A9DC:  CLR.B   87D
0A9DE:  BCLR.B  85B.5
0A9E0:  BCLR.B  85B.6
0A9E2:  MOV     #BB8,W4
0A9E4:  MOV     W4,87E
0A9E6:  CLR.B   880
0A9E8:  CLR     A82
0A9EA:  CLR     A84
0A9EC:  CLR     A86
0A9EE:  CLR     A88
0A9F0:  CLR     A8A
0A9F2:  MOV     #3E8,W4
0A9F4:  MOV     W4,C00
0A9F6:  MOV.B   #A,W0L
0A9F8:  MOV.B   W0L,881
0A9FA:  CLR     C02
0A9FC:  CLR     C04
0A9FE:  CLR     C06
0AA00:  CLR     C08
0AA02:  BCLR.B  85B.7
0AA04:  CLR     1492
0AA06:  CLR     1494
0AA08:  CLR     1496
0AA0A:  CLR     1498
0AA0C:  CLR     149A
0AA0E:  CLR     149C
0AA10:  CLR     149E
0AA12:  CLR     14A0
0AA14:  CLR     14A2
0AA16:  CLR     14A4
0AA18:  CLR     14A6
0AA1A:  CLR     14A8
0AA1C:  MOV.B   #14,W0L
0AA1E:  MOV.B   W0L,14AA
0AA20:  MOV.B   #5,W0L
0AA22:  MOV.B   W0L,14AB
0AA24:  MOV     #2,W4
0AA26:  MOV     W4,14AC
0AA28:  CLR     14AE
0AA2A:  MOV.B   #3,W0L
0AA2C:  MOV.B   W0L,14B0
0AA2E:  MOV     #C8,W4
0AA30:  MOV     W4,14B2
0AA32:  BCLR.B  14B1.0
0AA34:  CLR     14B4
0AA36:  CLR     14B6
0AA38:  CLR     1576
0AA3A:  MOV     #999A,W4
0AA3C:  MOV     W4,1578
0AA3E:  MOV     #9999,W4
0AA40:  MOV     W4,157A
0AA42:  MOV     #9999,W4
0AA44:  MOV     W4,157C
0AA46:  MOV     #3FF9,W4
0AA48:  MOV     W4,157E
0AA4A:  MOV     #64,W4
0AA4C:  MOV     W4,1580
0AA4E:  CLR     1584
0AA50:  CLR     1586
0AA52:  CLR     1588
0AA54:  CLR     158A
0AA56:  CLR     158C
0AA58:  CLR     158E
0AA5A:  CLR     1590
0AA5C:  CLR     1592
0AA5E:  CLR     1594
0AA60:  CLR     1596
0AA62:  CLR     1598
0AA64:  CLR     159A
0AA66:  MOV     #F8B6,W4
0AA68:  MOV     W4,159C
0AA6A:  MOV     #14,W4
0AA6C:  MOV     W4,159E
0AA6E:  MOV     #D9E3,W4
0AA70:  MOV     W4,15A0
0AA72:  MOV     #400B,W4
0AA74:  MOV     W4,15A2
0AA76:  CLR     15A4
0AA78:  CLR     15A6
0AA7A:  MOV     #8800,W4
0AA7C:  MOV     W4,15A8
0AA7E:  MOV     #40B3,W4
0AA80:  MOV     W4,15AA
0AA82:  MOV     #6DDB,W4
0AA84:  MOV     W4,15AC
0AA86:  MOV     #9A17,W4
0AA88:  MOV     W4,15AE
0AA8A:  MOV     #84EB,W4
0AA8C:  MOV     W4,15B0
0AA8E:  MOV     #403D,W4
0AA90:  MOV     W4,15B2
0AA92:  MOV     15A4,W0
0AA94:  MOV     15A6,W1
0AA96:  MOV     15A8,W2
0AA98:  MOV     15AA,W3
0AA9A:  MOV     #0,W4
0AA9C:  MOV     #0,W5
0AA9E:  MOV     #0,W6
0AAA0:  MOV     #4010,W7
0AAA2:  CALL    C4A
0AAA6:  MOV     W0,W5
0AAA8:  MOV     W1,W6
0AAAA:  MOV     W2,W7
0AAAC:  MOV     W3,W8
0AAAE:  MOV     W5,[W15++]
0AAB0:  MOV     W6,[W15++]
0AAB2:  MOV     W7,[W15++]
0AAB4:  MOV     159C,W0
0AAB6:  MOV     159E,W1
0AAB8:  MOV     15A0,W2
0AABA:  MOV     15A2,W3
0AABC:  MOV     #2D18,W4
0AABE:  MOV     #5444,W5
0AAC0:  MOV     #21FB,W6
0AAC2:  MOV     #4009,W7
0AAC4:  CALL    C4A
0AAC8:  MOV     [--W15],W7
0AACA:  MOV     [--W15],W6
0AACC:  MOV     [--W15],W5
0AACE:  MOV     W5,[W15++]
0AAD0:  MOV     W6,[W15++]
0AAD2:  MOV     W7,[W15++]
0AAD4:  MOV     W0,W4
0AAD6:  MOV     W5,W0
0AAD8:  MOV     W1,W5
0AADA:  MOV     W6,W1
0AADC:  MOV     W2,W6
0AADE:  MOV     W7,W2
0AAE0:  MOV     W3,W7
0AAE2:  MOV     W8,W3
0AAE4:  CALL    D5A
0AAE8:  MOV     [--W15],W7
0AAEA:  MOV     [--W15],W6
0AAEC:  MOV     [--W15],W5
0AAEE:  MOV     W0,15B4
0AAF0:  MOV     W1,15B6
0AAF2:  MOV     W2,15B8
0AAF4:  MOV     W3,15BA
0AAF6:  MOV     #9D39,W4
0AAF8:  MOV     W4,15BC
0AAFA:  MOV     #A252,W4
0AAFC:  MOV     W4,15BE
0AAFE:  MOV     #DF46,W4
0AB00:  MOV     W4,15C0
0AB02:  MOV     #3F91,W4
0AB04:  MOV     W4,15C2
0AB06:  CLR.B   15C4
0AB08:  CLR.B   15C5
0AB0A:  CLR     15C6
0AB0C:  CLR     15C8
0AB0E:  CLR     15CA
0AB10:  CLR     15CC
0AB12:  CLR     15CE
0AB14:  CLR     15D0
0AB16:  CLR     15D2
0AB18:  CLR     15D4
0AB1A:  CLR     15D6
0AB1C:  CLR     15D8
0AB1E:  BCLR.B  14B1.1
0AB20:  MOV     #7D0,W4
0AB22:  MOV     W4,15DC
0AB24:  MOV     #4B0,W4
0AB26:  MOV     W4,15DE
0AB28:  BCLR.B  14B1.4
0AB2A:  CLR     15E0
0AB2C:  CLR     15E2
0AB2E:  CLR.B   15DB
0AB30:  BCLR.B  14B1.5
0AB32:  CLR     15E4
0AB34:  CLR     15E6
0AB36:  MOV.B   #3,W0L
0AB38:  MOV.B   W0L,15E8
0AB3A:  CLR.B   15E9
0AB3C:  MOV     #C8,W4
0AB3E:  MOV     W4,15EC
0AB40:  CLR     1606
0AB42:  CLR     1608
0AB44:  CLR.B   160E
0AB46:  BCLR.B  1600.7
0AB48:  CLR     1610
0AB4A:  CLR     1612
0AB4C:  CLR     1614
0AB4E:  CLR.B   160F
0AB50:  MOV.B   #1,W0L
0AB52:  MOV.B   W0L,1616
0AB54:  BCLR.B  1617.0
0AB56:  CLR.B   1618
0AB58:  BCLR.B  1617.1
0AB5A:  CLR.B   1619
0AB5C:  MOV     #8000,W4
0AB5E:  MOV     W4,20C
0AB60:  MOV     #400,W4
0AB62:  MOV     W4,20E
0AB64:  MOV     #A,W4
0AB66:  MOV     W4,214
0AB68:  BCLR.B  1617.2
0AB6A:  BCLR.B  1617.3
0AB6C:  CLR.B   171A
0AB6E:  CLR.B   171B
0AB70:  BCLR.B  1617.4
0AB72:  CLR.B   1B1C
0AB74:  CLR     1B26
0AB76:  MOV     #3,W4
0AB78:  MOV     W4,1B28
0AB7A:  MOV     #2,W4
0AB7C:  MOV     W4,1B2A
0AB7E:  MOV     #1,W4
0AB80:  MOV     W4,1B2C
0AB82:  CLR     1B2E
0AB84:  BCLR.B  1617.5
0AB86:  SETM    2A8
0AB88:  MOV     [--W15],W7
0AB8A:  MOV     [--W15],W6
0AB8C:  MOV     [--W15],W5
0AB8E:  BCLR.B  14B1.2
0AB90:  BCLR.B  14B1.3
0AB92:  BCLR.B  14B1.6
0AB94:  BCLR.B  14B1.7
0AB96:  BCLR.B  1600.0
0AB98:  BCLR.B  1600.1
0AB9A:  BCLR.B  1600.2
0AB9C:  BCLR.B  1600.3
0AB9E:  BCLR.B  1600.4
0ABA0:  BCLR.B  1600.5
0ABA2:  BCLR.B  1600.6
0ABA4:  BRA     AC6A
0ABA6:  DATA    C2,00,08
0ABA8:  DATA    82,00,C0
0ABAA:  DATA    A0,0B,60
0ABAC:  DATA    00,C8,88
0ABAE:  DATA    0C,0A,00
0ABB0:  DATA    C0,06,14
0ABB2:  DATA    B8,00,00
0ABB4:  DATA    4B,F0,3F
0ABB6:  DATA    5C,0A,58
0ABB8:  DATA    F6,3B,8F
0ABBA:  DATA    00,C0,3C
0ABBC:  DATA    8B,28,AC
0ABBE:  DATA    3C,BE,F6
0ABC0:  DATA    3F,D2,D5
0ABC2:  DATA    44,16,8C
0ABC4:  DATA    15,D7,BF
0ABC6:  DATA    69,00,5A
0ABC8:  DATA    2E,1B,87
0ABCA:  DATA    99,3F,9A
0ABCC:  DATA    5F,AD,4B
0ABCE:  DATA    91,E4,01
0ABD0:  DATA    C0,5D,11
0ABD2:  DATA    2F,92,E4
0ABD4:  DATA    81,FB,3F
0ABD6:  DATA    38,DA,91
0ABD8:  DATA    80,9D,C5
0ABDA:  DATA    E0,BF,6F
0ABDC:  DATA    12,C0,B4
0ABDE:  DATA    C3,09,AB
0ABE0:  DATA    3F,6B,C1
0ABE2:  DATA    03,4E,C1
0ABE4:  DATA    B5,45,BF
0ABE6:  DATA    F7,40,05
0ABE8:  DATA    FF,00,5C
0ABEA:  DATA    EF,3F,F3
0ABEC:  DATA    A3,E2,F7
0ABEE:  DATA    D7,FF,01
0ABF0:  DATA    40,C0,B4
0ABF2:  DATA    FF,05,3C
0ABF4:  DATA    58,FC,3F
0ABF6:  DATA    3B,D3,C0
0ABF8:  DATA    B5,BA,8C
0ABFA:  DATA    E2,3F,39
0ABFC:  DATA    D3,C7,3D
0ABFE:  DATA    41,79,B2
0AC00:  DATA    3F,87,0D
0AC02:  DATA    3C,50,D0
0AC04:  DATA    AF,62,3F
0AC06:  DATA    30,4B,8D
0AC08:  DATA    A2,82,AA
0AC0A:  DATA    04,40,09
0AC0C:  DATA    A0,40,4A
0AC0E:  DATA    05,76,03
0AC10:  DATA    40,EC,9E
0AC12:  DATA    37,88,A6
0AC14:  DATA    44,F0,3F
0AC16:  DATA    8F,12,8D
0AC18:  DATA    29,9A,5B
0AC1A:  DATA    C7,3F,0E
0AC1C:  DATA    E0,80,7C
0AC1E:  DATA    A1,D8,86
0AC20:  DATA    3F,29,4B
0AC22:  DATA    FB,95,C2
0AC24:  DATA    37,1A,3F
0AC26:  DATA    00,00,80
0AC28:  DATA    01,15,DA
0AC2A:  DATA    00,80,02
0AC2C:  DATA    15,EA,00
0AC2E:  DATA    00,C0,12
0AC30:  DATA    15,EE,00
0AC32:  DATA    C0,05,16
0AC34:  DATA    01,00,80
0AC36:  DATA    04,16,0A
0AC38:  DATA    00,00,00
0AC3A:  DATA    00,C1,00
0AC3C:  DATA    16,1A,00
0AC3E:  DATA    C4,00,17
0AC40:  DATA    1C,00,80
0AC42:  DATA    04,1B,1D
0AC44:  DATA    00,00,00
0AC46:  DATA    00,80,04
0AC48:  DATA    1B,22,00
0AC4A:  DATA    00,00,00
0AC4C:  DATA    00,00,00
0AC4E:  INC     W2,W2
0AC50:  CP      W2,#1
0AC52:  BRA     NZ,AC5C
0AC54:  TBLRDL  [W1],W3
0AC56:  TBLRDH  [W1++],W4
0AC58:  MOV.B   6,W0L
0AC5A:  RETURN  
0AC5C:  CP      W2,#2
0AC5E:  BRA     NZ,AC64
0AC60:  MOV.B   7,W0L
0AC62:  RETURN  
0AC64:  MOV.B   8,W0L
0AC66:  CLR     W2
0AC68:  RETURN  
0AC6A:  MOV     #0,W6
0AC6C:  MOV     #0,W0
0AC6E:  MOV     W0,32
0AC70:  MOV     #ABA6,W0
0AC72:  MOV     W0,W1
0AC74:  CLR     W2
0AC76:  CALL    AC4E
0AC7A:  MOV.B   W0L,B
0AC7C:  CALL    AC4E
0AC80:  MOV.B   W0L,A
0AC82:  CP0     W5
0AC84:  BRA     Z,ACB8
0AC86:  BTSS    W5.F
0AC88:  BRA     AC98
0AC8A:  CALL    AC4E
0AC8E:  MOV.B   W0L,D
0AC90:  CALL    AC4E
0AC94:  MOV.B   W0L,C
0AC96:  BCLR    W5.F
0AC98:  BTSS    W5.E
0AC9A:  BRA     ACAC
0AC9C:  BCLR    W5.E
0AC9E:  DEC     W5,W5
0ACA0:  CALL    AC4E
0ACA4:  MOV.B   W0L,W7L
0ACA6:  REPEAT  W5
0ACA8:  MOV.B   W7L,[W6++]
0ACAA:  BRA     AC76
0ACAC:  CALL    AC4E
0ACB0:  MOV.B   W0L,[W6++]
0ACB2:  DEC     W5,W5
0ACB4:  BRA     NZ,ACAC
0ACB6:  BRA     AC76
.................... { 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////	INITIALISATION DE TOUS LES MODULES	//////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 		// Initialisation du dsPIC 
.................... 	__Init_dsPIC();	 
0ACB8:  CALL    FCE
.................... //	delay_ms(1300);  
.................... 	__Init_UART(); 
0ACBC:  CALL    1076
.................... 	//__Init_pos(); 
.................... 	delay_ms(1000); 
0ACC0:  MOV     #3E8,W0
0ACC2:  CALL    F0E
.................... 	 
.................... 		// Check si dÃÂ©marreur en place 
.................... 	if(!_DEMA)__Affichage_Erreur(1); 
0ACC6:  BTSC.B  2C3.2
0ACC8:  BRA     ACD2
0ACCA:  MOV.B   #1,W0L
0ACCC:  MOV.B   W0L,1B3A
0ACCE:  CALL    107A
....................  
.................... 				 
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 			// Configuration de la balise 
.................... 	Balise_config_plage(0, 12, 14);	// En avanÃÂ§ant 
0ACD2:  CLR.B   1B32
0ACD4:  MOV.B   #C,W0L
0ACD6:  MOV.B   W0L,1B33
0ACD8:  MOV.B   #E,W0L
0ACDA:  MOV.B   W0L,1B34
0ACDC:  CALL    1082
.................... 	delay_ms(100); 
0ACE0:  MOV     #64,W0
0ACE2:  CALL    F0E
.................... 	Balise_config_plage(1, 4, 6); // En reculant 
0ACE6:  MOV.B   #1,W0L
0ACE8:  MOV.B   W0L,1B32
0ACEA:  MOV.B   #4,W0L
0ACEC:  MOV.B   W0L,1B33
0ACEE:  MOV.B   #6,W0L
0ACF0:  MOV.B   W0L,1B34
0ACF2:  CALL    1082
.................... 	delay_ms(100); 
0ACF6:  MOV     #64,W0
0ACF8:  CALL    F0E
....................  
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 		// Set la base 
.................... 		// On n'affiche pas l'erreur ici car si on dÃÂ©branche le driver de dÃÂ©placement 
.................... 		// pour envoyer les objectifs, cela bloquerait le systÃÂ¨me 
.................... //	unsigned int8 ToSetBase=0; 
.................... 	if(_TEAM==0) 
0ACFC:  BTSC.B  2C3.4
0ACFE:  BRA     AD0A
.................... 	{ 
.................... 		_LDT1=0; 
0AD00:  BCLR.B  2D6.5
.................... 		_LDT2=1; 
0AD02:  BSET.B  2D6.6
.................... 		Team=0; 
0AD04:  BCLR.B  85B.3
.................... 	} 
0AD06:  GOTO    AD14
.................... 	else if(_TEAM==1) 
0AD0A:  BTSS.B  2C3.4
0AD0C:  BRA     AD14
.................... 	{ 
.................... 		_LDT2=0; 
0AD0E:  BCLR.B  2D6.6
.................... 		_LDT1=1; 
0AD10:  BSET.B  2D6.5
.................... 		Team=1; 
0AD12:  BSET.B  85B.3
.................... 	}	 
.................... 	//Team=1; 
.................... 	fprintf(ROBOTEQ,"!MG\r"); 
0AD14:  MOV     #0,W1
0AD16:  MOV     W1,W0
0AD18:  CLR.B   1
0AD1A:  CALL    476
0AD1E:  INC     W1,W1
0AD20:  BTSC.B  219.1
0AD22:  BRA     AD20
0AD24:  MOV     W0,21A
0AD26:  MOV     #3,W0
0AD28:  CPSGT   W1,W0
0AD2A:  BRA     AD16
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 			 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	/////////////////////////////////	PROGRAMME PRINCIPAL	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	int1 action_ok1 = 0; 
.................... 	int1 action_ok2 = 0; 
.................... 	int1 action_ok3 = 0; 
.................... 	int1 Module_inplace = 0; 
0AD2C:  BCLR.B  1B30.0
0AD2E:  BCLR.B  1B30.1
0AD30:  BCLR.B  1B30.2
0AD32:  BCLR.B  1B30.3
....................  	 
....................   	driver_Pompes(0xA0, 0, 0, 0, 0, 0);		//Désactive toute les pompes 
0AD34:  MOV.B   #A0,W0L
0AD36:  MOV.B   W0L,1B3E
0AD38:  CLR.B   1B3F
0AD3A:  CLR.B   1B40
0AD3C:  CLR.B   1B41
0AD3E:  CLR.B   1B42
0AD40:  CLR.B   1B43
0AD42:  CALL    10CC
....................  
.................... 	while(!Module_inplace) Module_inplace=__GoToZero();		//Réinitialise la couronne 
0AD46:  BTSC.B  1B30.3
0AD48:  BRA     AD58
0AD4A:  CALL    1268
0AD4E:  BCLR.B  1B30.3
0AD50:  BTSC.B  0.0
0AD52:  BSET.B  1B30.3
0AD54:  GOTO    AD46
.................... 	go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,1);	//Pour que la couronne maintient la position 
0AD58:  MOV.B   #C2,W0L
0AD5A:  MOV.B   W0L,1B3C
0AD5C:  CLR.B   1B3D
0AD5E:  MOV.B   #1,W0L
0AD60:  MOV.B   W0L,1B3E
0AD62:  MOV.B   #2,W0L
0AD64:  MOV.B   W0L,1B3F
0AD66:  MOV     #1388,W4
0AD68:  MOV     W4,1B40
0AD6A:  MOV     #1,W4
0AD6C:  MOV     W4,1B42
0AD6E:  CLR     1B44
0AD70:  CALL    114E
.................... 	delay_ms(100); 
0AD74:  MOV     #64,W0
0AD76:  CALL    F0E
.................... 	Module_inplace = 0; 
0AD7A:  BCLR.B  1B30.3
.................... 	while(!Module_inplace) Module_inplace=GoToZero_Cremaillere();		//Réinitialise la crémaillère 
0AD7C:  BTSC.B  1B30.3
0AD7E:  BRA     AD8E
0AD80:  CALL    1858
0AD84:  BCLR.B  1B30.3
0AD86:  BTSC.B  0.0
0AD88:  BSET.B  1B30.3
0AD8A:  GOTO    AD7C
.................... 	delay_ms(100); 
0AD8E:  MOV     #64,W0
0AD90:  CALL    F0E
.................... 		 
.................... 	while(1) 
.................... 	{		 
.................... 		switch(Etat_rob) 
0AD94:  MOV.B   87B,W0L
0AD96:  CLR.B   1
0AD98:  XOR     #0,W0
0AD9A:  BRA     Z,ADBE
0AD9C:  XOR     #1,W0
0AD9E:  BRA     Z,AE30
0ADA0:  XOR     #3,W0
0ADA2:  BRA     Z,AE34
0ADA4:  XOR     #1,W0
0ADA6:  BRA     Z,AE6E
0ADA8:  XOR     #7,W0
0ADAA:  BRA     Z,AEB0
0ADAC:  XOR     #1,W0
0ADAE:  BRA     Z,AF32
0ADB0:  XOR     #3,W0
0ADB2:  BRA     Z,AF8E
0ADB4:  XOR     #1,W0
0ADB6:  BRA     Z,AFE2
0ADB8:  XOR     #F,W0
0ADBA:  BRA     Z,B0AA
0ADBC:  BRA     B0F6
.................... 		{ 
.................... 			case Init: 
.................... 				//solution=(PORTA&0b11110000)/16; 
.................... 				solution = 0b0001; 
0ADBE:  MOV.B   #1,W0L
0ADC0:  MOV.B   W0L,87A
.................... 				if(NbreObjectifs > 0 && !_DEMA  && !flag_end)//si on a des objectifs et qu'il sont charger 
0ADC2:  CP0     14B4
0ADC4:  BRA     Z,AE00
0ADC6:  BTSC.B  2C3.2
0ADC8:  BRA     AE00
0ADCA:  BTSC.B  85A.7
0ADCC:  BRA     AE00
.................... 				{ 
.................... 					if(BeginTimeMS==0)  
0ADCE:  CP0     866
0ADD0:  BRA     NZ,ADDE
0ADD2:  CP0     868
0ADD4:  BRA     NZ,ADDE
.................... 					{ 
.................... 						BeginTimeMS = RealTimeMS; 
0ADD6:  PUSH    862
0ADD8:  POP     866
0ADDA:  PUSH    864
0ADDC:  POP     868
.................... 						//delay_ms(1000);  
.................... 					} 
.................... 					__Afficheur_7segments(0); 
0ADDE:  CLR.B   1B3A
0ADE0:  CLR.B   1B3B
0ADE2:  CALL    1382
.................... 					__LoadObj(NoObj,NoPts);//on mets l'objectifs dans des variables 
0ADE6:  MOV.B   873,W0L
0ADE8:  MOV.B   W0L,1B34
0ADEA:  CLR.B   1B35
0ADEC:  MOV.B   874,W0L
0ADEE:  MOV.B   W0L,1B36
0ADF0:  CLR.B   1B37
0ADF2:  CALL    18F8
.................... 					Etat_rob = Check_ZI;//on change d'etat 
0ADF6:  MOV.B   #2,W0L
0ADF8:  MOV.B   W0L,87B
.................... 					Depl_send = 0;			 
0ADFA:  BCLR.B  85B.5
.................... 				} 
0ADFC:  GOTO    AE2C
.................... 				else if(NbreObjectifs == 0) 
0AE00:  CP0     14B4
0AE02:  BRA     NZ,AE16
.................... 				{ 
.................... 					__Afficheur_7segments(1); 
0AE04:  MOV.B   #1,W0L
0AE06:  MOV.B   W0L,1B3A
0AE08:  CLR.B   1B3B
0AE0A:  CALL    1382
.................... 					__ReadObjectifs();	 
0AE0E:  CALL    1A92
.................... 				} 
0AE12:  GOTO    AE2C
.................... 				else if(_DEMA == 1 && NbreObjectifs != 0) 
0AE16:  BTSS.B  2C3.2
0AE18:  BRA     AE2C
0AE1A:  CP0     14B4
0AE1C:  BRA     Z,AE2C
.................... 				{				 
.................... 					__Afficheur_7segments(2); 
0AE1E:  MOV.B   #2,W0L
0AE20:  MOV.B   W0L,1B3A
0AE22:  CLR.B   1B3B
0AE24:  CALL    1382
.................... 					__Init_pos();					 
0AE28:  CALL    1B96
.................... 				} 
.................... 				break; 
0AE2C:  GOTO    B102
....................  
....................  
.................... 			 
.................... 			case Choose_objectif: 
....................  
.................... 				/* 
.................... 				static int obj_todo = 0; //L'objectif qu'on regarde si on peut le faire 
....................  
.................... 				obj_todo++; //On passe à l'objectif suivant 
.................... 				__LoadObj(obj_todo, 1); //On récupère les données de l'objectif dans les variables 
....................  
.................... 				if(oTime < (TimeLimit - GameTimeS) && !obj_done && !obj_notcontinuable) 
.................... 				{ 
.................... 					Etat_rob = Send_depl_action; 
.................... 				} 
....................  
.................... 				if (obj_todo >= (NbreObjectifs))  
.................... 				{ 
.................... 					obj_todo = 0; 
.................... 				} 
.................... 				*/ 
.................... 				break; 
0AE30:  GOTO    B102
.................... 				 
....................  
.................... 			case Check_ZI: 
....................  
.................... 				__Afficheur_7segments(3); 
0AE34:  MOV.B   #3,W0L
0AE36:  MOV.B   W0L,1B3A
0AE38:  CLR.B   1B3B
0AE3A:  CALL    1382
.................... 				if(checkPath()) 
0AE3E:  CALL    2174
0AE42:  CP0     W0
0AE44:  BRA     Z,AE58
.................... 				{ 
.................... 					__Afficheur_7segments(4); 
0AE46:  MOV.B   #4,W0L
0AE48:  MOV.B   W0L,1B3A
0AE4A:  CLR.B   1B3B
0AE4C:  CALL    1382
.................... 					Etat_rob = Send_depl_action; 
0AE50:  MOV.B   #3,W0L
0AE52:  MOV.B   W0L,87B
.................... 				} 
0AE54:  GOTO    AE6A
.................... 				else 
.................... 				{ 
.................... 					__Afficheur_7segments(7); 
0AE58:  MOV.B   #7,W0L
0AE5A:  MOV.B   W0L,1B3A
0AE5C:  CLR.B   1B3B
0AE5E:  CALL    1382
.................... 					findPath(); 
0AE62:  CALL    66C2
.................... 					Etat_rob = Send_depl_action_ZI; 
0AE66:  MOV.B   #4,W0L
0AE68:  MOV.B   W0L,87B
.................... 				} 
....................  
.................... 				break; 
0AE6A:  GOTO    B102
....................  
.................... 			case Send_depl_action: 
....................  
....................  
.................... 				__Afficheur_7segments(5); 
0AE6E:  MOV.B   #5,W0L
0AE70:  MOV.B   W0L,1B3A
0AE72:  CLR.B   1B3B
0AE74:  CALL    1382
.................... 				if(!Depl_send && !flag_end)//si le deplacement n'as pas ete envoye 
0AE78:  BTSC.B  85B.5
0AE7A:  BRA     AE88
0AE7C:  BTSC.B  85A.7
0AE7E:  BRA     AE88
.................... 				{ 
.................... 					__DeplToDo(oType);//envoie le déplacment 
0AE80:  MOV.B   1496,W0L
0AE82:  MOV.B   W0L,1B32
0AE84:  CALL    8E08
.................... 				} 
.................... 				if(!Action_send && !flag_end)//si l'action n'a pas ete envoyee 
0AE88:  BTSC.B  85B.7
0AE8A:  BRA     AE98
0AE8C:  BTSC.B  85A.7
0AE8E:  BRA     AE98
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
0AE90:  MOV.B   149E,W0L
0AE92:  MOV.B   W0L,1B32
0AE94:  CALL    9C48
.................... 				} 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
0AE98:  BTSS.B  85B.5
0AE9A:  BRA     AEAC
0AE9C:  BTSS.B  85B.7
0AE9E:  BRA     AEAC
0AEA0:  BTSC.B  85A.7
0AEA2:  BRA     AEAC
.................... 				{ 
.................... 					Depl_send = 0; 
0AEA4:  BCLR.B  85B.5
.................... 					Action_send = 0; 
0AEA6:  BCLR.B  85B.7
.................... 					Etat_rob = Depl_action_process; 
0AEA8:  MOV.B   #5,W0L
0AEAA:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
0AEAC:  GOTO    B102
....................  
....................  
.................... 			case Send_depl_action_ZI: 
....................  
.................... 				__Afficheur_7segments(8); 
0AEB0:  MOV.B   #8,W0L
0AEB2:  MOV.B   W0L,1B3A
0AEB4:  CLR.B   1B3B
0AEB6:  CALL    1382
.................... 				if(!Action_send)//si l'action n'a pas ete envoyee 
0AEBA:  BTSC.B  85B.7
0AEBC:  BRA     AEC6
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
0AEBE:  MOV.B   149E,W0L
0AEC0:  MOV.B   W0L,1B32
0AEC2:  CALL    9C48
.................... 				} 
....................  
.................... 				if(!Depl_send && i_depl< i_rel) 
0AEC6:  BTSC.B  85B.5
0AEC8:  BRA     AF0C
0AECA:  MOV     A8A,W0
0AECC:  MOV     A88,W4
0AECE:  CP      W4,W0
0AED0:  BRA     LE,AF0C
.................... 				{ 
.................... 					__PaP(PtsRelai[i_depl].X, PtsRelai[i_depl].Y); 
0AED2:  MOV     A8A,W4
0AED4:  MUL.UU  W4,#10,W0
0AED6:  MOV     W0,W5
0AED8:  MOV     #AA0,W4
0AEDA:  ADD     W5,W4,W0
0AEDC:  MOV     W0,W4
0AEDE:  MOV     #0,W3
0AEE0:  REPEAT  #3
0AEE2:  MOV     [W4++],[W3++]
0AEE4:  CALL    2230
0AEE8:  MOV     W0,W6
0AEEA:  MOV     A8A,W4
0AEEC:  MUL.UU  W4,#10,W0
0AEEE:  MOV     W0,W7
0AEF0:  ADD     W7,#8,W0
0AEF2:  MOV     #AA0,W4
0AEF4:  ADD     W0,W4,W0
0AEF6:  MOV     W0,W4
0AEF8:  MOV     #0,W3
0AEFA:  REPEAT  #3
0AEFC:  MOV     [W4++],[W3++]
0AEFE:  CALL    2230
0AF02:  MOV     W0,W7
0AF04:  MOV     W6,1B38
0AF06:  MOV     W7,1B3A
0AF08:  CALL    7AF0
.................... 				} 
....................  
.................... 				if (flag_depl_ok) 
0AF0C:  BTSS.B  85A.6
0AF0E:  BRA     AF16
.................... 				{ 
.................... 					i_depl++; 
0AF10:  INC     0A8A
.................... 					Depl_send = 0; 
0AF12:  BCLR.B  85B.5
.................... 					flag_depl_ok = 0; 
0AF14:  BCLR.B  85A.6
.................... 				} 
....................  
.................... 				if(i_depl >= i_rel && Action_send)//si tout a ete envoye 
0AF16:  MOV     A88,W0
0AF18:  MOV     A8A,W4
0AF1A:  CP      W4,W0
0AF1C:  BRA     LT,AF2A
0AF1E:  BTSS.B  85B.7
0AF20:  BRA     AF2A
.................... 				{ 
.................... 					Depl_send = 0; 
0AF22:  BCLR.B  85B.5
.................... 					Action_send = 0; 
0AF24:  BCLR.B  85B.7
.................... 					Etat_rob = Depl_action_process_ZI; 
0AF26:  MOV.B   #6,W0L
0AF28:  MOV.B   W0L,87B
.................... 				} 
....................  
.................... 				__Check_commande_atteint(); 
0AF2A:  CALL    77AE
....................  
.................... 				break; 
0AF2E:  GOTO    B102
....................  
.................... 			case Depl_action_process : 
....................  
.................... 				__Afficheur_7segments(6); 
0AF32:  MOV.B   #6,W0L
0AF34:  MOV.B   W0L,1B3A
0AF36:  CLR.B   1B3B
0AF38:  CALL    1382
.................... 				__Check_commande_atteint(); 
0AF3C:  CALL    77AE
.................... 				//action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
.................... 				//action_ok2 = __Check_action_end(0xC2); 
.................... 				//action_ok3 = __Check_action_end(0xC4); 
.................... 				if(flag_depl_ok && /*action_ok1 && action_ok2 && action_ok3*/Check && !flag_end && !_Detected)//on attend que tout soit fini 
0AF40:  BTSS.B  85A.6
0AF42:  BRA     AF8A
0AF44:  BTSS.B  85B.4
0AF46:  BRA     AF8A
0AF48:  BTSC.B  85A.7
0AF4A:  BRA     AF8A
0AF4C:  BTSC.B  85B.0
0AF4E:  BRA     AF8A
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
0AF50:  MOV     872,W4
0AF52:  LSR     W4,#8,W4
0AF54:  CP.B    W4L,#1
0AF56:  BRA     NZ,AF64
0AF58:  MOV     874,W4
0AF5A:  CP.B    W4L,#1
0AF5C:  BRA     NZ,AF64
0AF5E:  MOV     #3E8,W0
0AF60:  CALL    F0E
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
0AF64:  MOV     1586,W0
0AF66:  ADD     1582,W0
0AF68:  MOV     W0,1586
.................... 					Pos_y += Dist_y; 
0AF6A:  MOV     1588,W0
0AF6C:  ADD     1584,W0
0AF6E:  MOV     W0,1588
.................... 					 
.................... 					//__Afficheur_7segments(3); 
.................... 	 
.................... 					Dist_x=0; 
0AF70:  CLR     1582
.................... 					Dist_y=0; 
0AF72:  CLR     1584
.................... 					Dorient = 0; 
0AF74:  CLR     158C
0AF76:  CLR     158E
0AF78:  CLR     1590
0AF7A:  CLR     1592
.................... 					balise_on = 0; 
0AF7C:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
0AF7E:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
0AF80:  BCLR.B  1B30.0
.................... 					action_ok2 = 0; 
0AF82:  BCLR.B  1B30.1
.................... 					action_ok3 = 0; 
0AF84:  BCLR.B  1B30.2
.................... 					Etat_rob = Switch_end_obj; 
0AF86:  MOV.B   #7,W0L
0AF88:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
0AF8A:  GOTO    B102
....................  
.................... 			case Depl_action_process_ZI: 
....................  
.................... 				__Afficheur_7segments(9); 
0AF8E:  MOV.B   #9,W0L
0AF90:  MOV.B   W0L,1B3A
0AF92:  CLR.B   1B3B
0AF94:  CALL    1382
.................... 				//action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
.................... 				//action_ok2 = __Check_action_end(0xC2); 
.................... 				//action_ok3 = __Check_action_end(0xC4); 
.................... 				if(/*action_ok1 && action_ok2 && action_ok3*/ Check && !flag_end && !_Detected)//on attend que tout soit fini 
0AF98:  BTSS.B  85B.4
0AF9A:  BRA     AFDE
0AF9C:  BTSC.B  85A.7
0AF9E:  BRA     AFDE
0AFA0:  BTSC.B  85B.0
0AFA2:  BRA     AFDE
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
0AFA4:  MOV     872,W4
0AFA6:  LSR     W4,#8,W4
0AFA8:  CP.B    W4L,#1
0AFAA:  BRA     NZ,AFB8
0AFAC:  MOV     874,W4
0AFAE:  CP.B    W4L,#1
0AFB0:  BRA     NZ,AFB8
0AFB2:  MOV     #3E8,W0
0AFB4:  CALL    F0E
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
0AFB8:  MOV     1586,W0
0AFBA:  ADD     1582,W0
0AFBC:  MOV     W0,1586
.................... 					Pos_y += Dist_y; 
0AFBE:  MOV     1588,W0
0AFC0:  ADD     1584,W0
0AFC2:  MOV     W0,1588
.................... 					 
.................... 					//__Afficheur_7segments(3); 
.................... 	 
.................... 					Dist_x=0; 
0AFC4:  CLR     1582
.................... 					Dist_y=0; 
0AFC6:  CLR     1584
.................... 					Dorient = 0; 
0AFC8:  CLR     158C
0AFCA:  CLR     158E
0AFCC:  CLR     1590
0AFCE:  CLR     1592
.................... 					balise_on = 0; 
0AFD0:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
0AFD2:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
0AFD4:  BCLR.B  1B30.0
.................... 					action_ok2 = 0; 
0AFD6:  BCLR.B  1B30.1
.................... 					action_ok3 = 0; 
0AFD8:  BCLR.B  1B30.2
.................... 					Etat_rob = Switch_end_obj; 
0AFDA:  MOV.B   #7,W0L
0AFDC:  MOV.B   W0L,87B
.................... 				} 
.................... 				break;	 
0AFDE:  GOTO    B102
....................  
.................... 			 
.................... 			case Switch_end_obj: 
.................... 				if(keep_obj==0)  
0AFE2:  CP0     14A8
0AFE4:  BRA     NZ,AFFE
.................... 				{ 
.................... 					TabObjectifs[NoObj][1][8] = 0; // mise de la ponderation a 0 --> on le remploie plus 
0AFE6:  MOV.B   873,W0L
0AFE8:  CLR.B   1
0AFEA:  MOV     #138,W4
0AFEC:  MUL.UU  W0,W4,W0
0AFEE:  MOV     W0,W5
0AFF0:  ADD     W5,#18,W5
0AFF2:  ADD     W5,#10,W0
0AFF4:  MOV     #C0A,W4
0AFF6:  ADD     W0,W4,W5
0AFF8:  CLR.B   [W5]
0AFFA:  MOV.B   #0,W0L
0AFFC:  MOV.B   W0L,[W5+#1]
.................... 				} 
.................... 			 	if(Obj_end)//si fini l'objectifs,passe a l'obj suivant 
0AFFE:  CP0     14A4
0B000:  BRA     Z,B06E
.................... 				{ 
.................... 					if(Next_obj!=0) // 0--> passe a l'obj suivant, sinon va a l'obj marquer 
0B002:  CP0     14A6
0B004:  BRA     Z,B02A
.................... 					{ 
.................... 						last_obj = NoObj; 
0B006:  MOV.B   873,W0L
0B008:  MOV.B   W0L,876
0B00A:  CLR.B   877
0B00C:  CLR     878
.................... 						NoObj = Next_Obj; 
0B00E:  MOV.B   14A6,W0L
0B010:  MOV.B   W0L,873
.................... 						NoPts = 1; 
0B012:  MOV.B   #1,W0L
0B014:  MOV.B   W0L,874
.................... 						__LoadObj(NoObj,NoPts);//charge le nouveau pts						 
0B016:  MOV.B   873,W0L
0B018:  MOV.B   W0L,1B34
0B01A:  CLR.B   1B35
0B01C:  MOV.B   874,W0L
0B01E:  MOV.B   W0L,1B36
0B020:  CLR.B   1B37
0B022:  CALL    18F8
.................... 					} 
0B026:  GOTO    B06A
.................... 					else 
.................... 					{ 
.................... 						last_obj = NoObj; 
0B02A:  MOV.B   873,W0L
0B02C:  MOV.B   W0L,876
0B02E:  CLR.B   877
0B030:  CLR     878
.................... 						do //prochain objectifs avec pondÃÂ©ration de 10 
.................... 						{ 
.................... 							__Afficheur_7segments(4); 
0B032:  MOV.B   #4,W0L
0B034:  MOV.B   W0L,1B3A
0B036:  CLR.B   1B3B
0B038:  CALL    1382
.................... 							NoObj++; // on passe a l'objectifs suivant 
0B03C:  INC.B   0873
.................... 							NoPts=1; // on reprend au premier pts 
0B03E:  MOV.B   #1,W0L
0B040:  MOV.B   W0L,874
.................... 							if(NoObj == 10) 
0B042:  MOV     872,W4
0B044:  LSR     W4,#8,W4
0B046:  CP.B    W4L,#A
0B048:  BRA     NZ,B054
.................... 							{ 
.................... 								Flag_end = 1; 
0B04A:  BSET.B  85A.7
.................... 								Ponderation = 10; 
0B04C:  MOV     #A,W4
0B04E:  MOV     W4,14A2
.................... 							} 
0B050:  GOTO    B064
.................... 							else __LoadObj(NoObj,NoPts);//charge le nouveau pts 
0B054:  MOV.B   873,W0L
0B056:  MOV.B   W0L,1B34
0B058:  CLR.B   1B35
0B05A:  MOV.B   874,W0L
0B05C:  MOV.B   W0L,1B36
0B05E:  CLR.B   1B37
0B060:  CALL    18F8
.................... 	 
.................... 						}while(Ponderation!=10); 
0B064:  MOV     14A2,W4
0B066:  CP      W4,#A
0B068:  BRA     NZ,B032
....................  
.................... 					} 
.................... 				} 
0B06A:  GOTO    B090
.................... 				else 
.................... 				{ 
.................... 					if(Pt_commun==1) NoPts+=2; // skip le pts droite 
0B06E:  MOV     14A0,W4
0B070:  CP      W4,#1
0B072:  BRA     NZ,B07E
0B074:  MOV     874,W4
0B076:  ADD.B   W4L,#2,W0L
0B078:  MOV.B   W0L,874
0B07A:  GOTO    B080
.................... 					else NoPts++; // passe au pt suivant suivant																 
0B07E:  INC.B   0874
.................... 					__LoadObj(NoObj,NoPts);//charge le nouveau pts 
0B080:  MOV.B   873,W0L
0B082:  MOV.B   W0L,1B34
0B084:  CLR.B   1B35
0B086:  MOV.B   874,W0L
0B088:  MOV.B   W0L,1B36
0B08A:  CLR.B   1B37
0B08C:  CALL    18F8
.................... 				}	 
.................... 				if(Pt_commun!=0)//si point pas symetrique 
0B090:  CP0     14A0
0B092:  BRA     Z,B0A0
.................... 				{ 
.................... 					if(Team)//pt droite 
0B094:  BTSS.B  85B.3
0B096:  BRA     B0A0
.................... 					{ 
.................... 						if(Pt_commun==1) NoPts++; // passe ÃÂ  l'obj suivant (pt droite) 
0B098:  MOV     14A0,W4
0B09A:  CP      W4,#1
0B09C:  BRA     NZ,B0A0
0B09E:  INC.B   0874
.................... 					} 
.................... 				} 
.................... 				 
.................... 				if(!Flag_end) Etat_rob = Init; 
0B0A0:  BTSC.B  85A.7
0B0A2:  BRA     B0A6
0B0A4:  CLR.B   87B
.................... 				break; 
0B0A6:  GOTO    B102
.................... 			case Wait_end: //case wait 
.................... 				if(flag_error) //erreur --> clignotement 7 segments 
0B0AA:  BTSS.B  85B.2
0B0AC:  BRA     B0D0
.................... 				{ 
.................... 					__Afficheur_7segments(No_erreur,1); 
0B0AE:  MOV.B   870,W0L
0B0B0:  MOV.B   W0L,1B3A
0B0B2:  MOV.B   #1,W0L
0B0B4:  MOV.B   W0L,1B3B
0B0B6:  CALL    1382
.................... 					delay_ms(1000); 
0B0BA:  MOV     #3E8,W0
0B0BC:  CALL    F0E
.................... 					__Afficheur_7segments(No_erreur,0); 
0B0C0:  MOV.B   870,W0L
0B0C2:  MOV.B   W0L,1B3A
0B0C4:  CLR.B   1B3B
0B0C6:  CALL    1382
.................... 					delay_ms(1000); 
0B0CA:  MOV     #3E8,W0
0B0CC:  CALL    F0E
.................... 				} 
.................... 				if(flagGameEnd) 
0B0D0:  BTSS.B  85A.0
0B0D2:  BRA     B0F2
.................... 				{ 
.................... 					__Afficheur_7segments(99); 
0B0D4:  MOV.B   #63,W0L
0B0D6:  MOV.B   W0L,1B3A
0B0D8:  CLR.B   1B3B
0B0DA:  CALL    1382
.................... 					// Desactive tout le reste 
.................... 					MoveServo(0,20); 
0B0DE:  CLR     1B32
0B0E0:  MOV     #14,W4
0B0E2:  MOV     W4,1B34
0B0E4:  CALL    9CD4
.................... 					disable_interrupts(INTR_GLOBAL); 
0B0E8:  BCLR.B  81.7
0B0EA:  MOV     #E0,W4
0B0EC:  MOV     W4,42
0B0EE:  BSET.B  81.7
.................... 					flagGameEnd=0;			 
0B0F0:  BCLR.B  85A.0
.................... 				}				 
.................... 				break;			 
0B0F2:  GOTO    B102
.................... 			default: 
.................... 				__Affichage_erreur(3);  
0B0F6:  MOV.B   #3,W0L
0B0F8:  MOV.B   W0L,1B3A
0B0FA:  CALL    107A
.................... 				break; 
0B0FE:  GOTO    B102
.................... 		} 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
....................  
....................         //////////////////////////////////////////////////////////////////////////////////// 
.................... 		////////////////////////	ACTION PARALLELES	//////////////////////////////////// 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
.................... 		 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        BALISE          ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(flagBaliseCheck && !flag_end && balise_on && !flag_error) 
0B102:  BTSS.B  85A.2
0B104:  BRA     B2A8
0B106:  BTSC.B  85A.7
0B108:  BRA     B2A8
0B10A:  BTSS.B  85B.1
0B10C:  BRA     B2A8
0B10E:  BTSC.B  85B.2
0B110:  BRA     B2A8
....................       	{ 
....................         	Value_bal = Check_balise(); 			//Recuperation de la valeur de la bailse 
0B112:  CALL    9D0A
0B116:  MOV.B   W0L,871
....................         	tempo_bal++; 							//temporisation de la balise, d'une fois detecte, il faut passer 4  tempo bal = 4 pour continuer 
0B118:  INC.B   0872
.................... 	        if(Value_bal>=MAX_VALUE_DETECT_BALISE) 	//si adversaire trop proche 
0B11A:  MOV.B   14B0,W0L
0B11C:  MOV     870,W4
0B11E:  LSR     W4,#8,W4
0B120:  CP.B    W4L,W0L
0B122:  BRA     NC,B234
.................... 	        {    
.................... 	       		tempo_bal = 0;						//remise a 0 de la tempo 
0B124:  CLR.B   872
....................            		__Afficheur_7segments(44); 
0B126:  MOV.B   #2C,W0L
0B128:  MOV.B   W0L,1B3A
0B12A:  CLR.B   1B3B
0B12C:  CALL    1382
.................... 	           	_LED2,_LED3,_LED4 = 1; 
0B130:  BSET.B  2D0.4
.................... 	           	_Detected = 1;						//indique que l'on a detecte l'adversaire 
0B132:  BSET.B  85B.0
.................... 	         
.................... 	            /////////////////// Arret du robot /////////////////////////////////////// 
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 9000_^MDEC 2 9000\r");	//rampe de dec. plus raide  
0B134:  MOV     #0,W1
0B136:  MOV     W1,W0
0B138:  CLR.B   1
0B13A:  CALL    488
0B13E:  INC     W1,W1
0B140:  BTSC.B  219.1
0B142:  BRA     B140
0B144:  MOV     W0,21A
0B146:  MOV     #19,W0
0B148:  CPSGT   W1,W0
0B14A:  BRA     B136
.................... 	            delay_ms(20); 
0B14C:  MOV     #14,W0
0B14E:  CALL    F0E
.................... 	            fprintf(ROBOTEQ,"!S 1 0_!S 2 0\r");				//vitesse du robot a 0 --> il va freiner 
0B152:  MOV     #0,W1
0B154:  MOV     W1,W0
0B156:  CLR.B   1
0B158:  CALL    4B0
0B15C:  INC     W1,W1
0B15E:  BTSC.B  219.1
0B160:  BRA     B15E
0B162:  MOV     W0,21A
0B164:  MOV     #D,W0
0B166:  CPSGT   W1,W0
0B168:  BRA     B154
....................  
.................... 	            if(Time_detected==0) // recuperation du temps de la detection 
0B16A:  CP0.B   86E
0B16C:  BRA     NZ,B176
.................... 	            { 
.................... 	               Time_detected = GameTimeS; 
0B16E:  MOV.B   861,W0L
0B170:  MOV.B   W0L,86E
.................... 	            } 
0B172:  GOTO    B230
.................... 	            else if(((GameTimeS - Time_detected) >= TIME_tempo_dectected))//on attend 6s 
0B176:  MOV     860,W4
0B178:  LSR     W4,#8,W4
0B17A:  MOV     86E,W3
0B17C:  SUB.B   W4L,W3L,W0L
0B17E:  MOV     86E,W4
0B180:  LSR     W4,#8,W4
0B182:  CP.B    W4L,W0L
0B184:  BRA     GTU,B230
.................... 	            {       
.................... 	               if(TabObjectifs[(NoObj+1)][1][8]!=10 && TabObjectifs[(NoObj+1)][1][8]!=0)//si obj suivant pond entre 1 et 9 --> on switch l'obj 
0B186:  MOV     872,W4
0B188:  LSR     W4,#8,W4
0B18A:  ADD     W4,#1,W5
0B18C:  MOV     #138,W4
0B18E:  MUL.UU  W5,W4,W0
0B190:  MOV     W0,W5
0B192:  ADD     W5,#18,W5
0B194:  ADD     W5,#10,W0
0B196:  MOV     #C0A,W4
0B198:  ADD     W0,W4,W0
0B19A:  MOV     [W0],W5
0B19C:  CP      W5,#A
0B19E:  BRA     Z,B230
0B1A0:  MOV     872,W4
0B1A2:  LSR     W4,#8,W4
0B1A4:  ADD     W4,#1,W5
0B1A6:  MOV     #138,W4
0B1A8:  MUL.UU  W5,W4,W0
0B1AA:  MOV     W0,W5
0B1AC:  ADD     W5,#18,W5
0B1AE:  ADD     W5,#10,W0
0B1B0:  MOV     #C0A,W4
0B1B2:  ADD     W0,W4,W0
0B1B4:  MOV     [W0],W5
0B1B6:  CP0     W5
0B1B8:  BRA     Z,B230
.................... 	               { 
.................... 	                   /////////////////// actualisation position x,y /////////////////// 
.................... 	                  __actual_pos();// actualisation de la Pos xy  
0B1BA:  CALL    9D46
....................  
.................... 	                   /////////////////// effacer l'ordre en cours  ///////////////////  
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
0B1BE:  MOV     #0,W1
0B1C0:  MOV     W1,W0
0B1C2:  CLR.B   1
0B1C4:  CALL    202
0B1C8:  INC     W1,W1
0B1CA:  BTSC.B  219.1
0B1CC:  BRA     B1CA
0B1CE:  MOV     W0,21A
0B1D0:  MOV     #13,W0
0B1D2:  CPSGT   W1,W0
0B1D4:  BRA     B1C0
.................... 	                  delay_ms(10); 
0B1D6:  MOV     #A,W0
0B1D8:  CALL    F0E
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
0B1DC:  MOV     #0,W1
0B1DE:  MOV     W1,W0
0B1E0:  CLR.B   1
0B1E2:  CALL    224
0B1E6:  INC     W1,W1
0B1E8:  BTSC.B  219.1
0B1EA:  BRA     B1E8
0B1EC:  MOV     W0,21A
0B1EE:  MOV     #13,W0
0B1F0:  CPSGT   W1,W0
0B1F2:  BRA     B1DE
....................  
.................... 	                   /////////////////// Passage a l'obj suivant  /////////////////// 
.................... 	                  NoObj++; // passage a l'objectif suivant 
0B1F4:  INC.B   0873
.................... 	                  NoPts = 1; // on demarre par le premier pts 
0B1F6:  MOV.B   #1,W0L
0B1F8:  MOV.B   W0L,874
.................... 	                  __LoadObj(NoObj,NoPts);//charge le nouveau pts 
0B1FA:  MOV.B   873,W0L
0B1FC:  MOV.B   W0L,1B34
0B1FE:  CLR.B   1B35
0B200:  MOV.B   874,W0L
0B202:  MOV.B   W0L,1B36
0B204:  CLR.B   1B37
0B206:  CALL    18F8
.................... 	                
.................... 	                  if(Pt_commun!=0)//si point pas symetrique 
0B20A:  CP0     14A0
0B20C:  BRA     Z,B21A
.................... 	                  { 
.................... 	                  if(Team)//pt droite 
0B20E:  BTSS.B  85B.3
0B210:  BRA     B21A
.................... 	                  { 
.................... 	                     if(Pt_commun==1) NoPts++; // passe ÃÂ  l'obj suivant (pt droite) 
0B212:  MOV     14A0,W4
0B214:  CP      W4,#1
0B216:  BRA     NZ,B21A
0B218:  INC.B   0874
.................... 	                  } 
.................... 	                  } 
.................... 	                  Etat_rob = Init; // on recommence le programme 
0B21A:  CLR.B   87B
.................... 	                  _Detected = 0; 
0B21C:  BCLR.B  85B.0
.................... 	                  balise_on = 0; 
0B21E:  BCLR.B  85B.1
.................... 	                  Dist_x = 0; 
0B220:  CLR     1582
.................... 	                  Dist_y = 0; 
0B222:  CLR     1584
.................... 	                  Dorient = 0;  
0B224:  CLR     158C
0B226:  CLR     158E
0B228:  CLR     1590
0B22A:  CLR     1592
.................... 	                  _LED2,_LED3,_LED4 = 0; 
0B22C:  BCLR.B  2D0.4
.................... 	                  Time_detected=0; 
0B22E:  CLR.B   86E
.................... 	               } 
.................... 	            } 
.................... 	        } 
0B230:  GOTO    B2A4
.................... 	        else if(_Detected && tempo_bal == 4) // si detecte et que l'adv n'est plus la  
0B234:  BTSS.B  85B.0
0B236:  BRA     B2A4
0B238:  MOV     872,W4
0B23A:  CP.B    W4L,#4
0B23C:  BRA     NZ,B2A4
.................... 	        { 
.................... 	             /////////////////// Reprise de l'ordre  ///////////////////          
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 6000_^MDEC 2 6000\r");//on reprend le dernier ordre    
0B23E:  MOV     #0,W1
0B240:  MOV     W1,W0
0B242:  CLR.B   1
0B244:  CALL    4CC
0B248:  INC     W1,W1
0B24A:  BTSC.B  219.1
0B24C:  BRA     B24A
0B24E:  MOV     W0,21A
0B250:  MOV     #19,W0
0B252:  CPSGT   W1,W0
0B254:  BRA     B240
.................... 	            fprintf(ROBOTEQ,"!S 1 %u_!S 2 %u\r",oVitMax,oVitMax); 
0B256:  MOV     #0,W1
0B258:  MOV     W1,W0
0B25A:  CLR.B   1
0B25C:  CALL    4F4
0B260:  INC     W1,W1
0B262:  BTSC.B  219.1
0B264:  BRA     B262
0B266:  MOV     W0,21A
0B268:  MOV     #4,W0
0B26A:  CPSGT   W1,W0
0B26C:  BRA     B258
0B26E:  MOV     149C,W0
0B270:  MOV     #0,W4
0B272:  CALL    6DFA
0B276:  MOV     #7,W1
0B278:  MOV     W1,W0
0B27A:  CLR.B   1
0B27C:  CALL    4F4
0B280:  INC     W1,W1
0B282:  BTSC.B  219.1
0B284:  BRA     B282
0B286:  MOV     W0,21A
0B288:  MOV     #C,W0
0B28A:  CPSGT   W1,W0
0B28C:  BRA     B278
0B28E:  MOV     149C,W0
0B290:  MOV     #0,W4
0B292:  CALL    6DFA
0B296:  BTSC.B  219.1
0B298:  BRA     B296
0B29A:  MOV     #D,W4
0B29C:  MOV     W4,21A
....................  
.................... 	            Time_detected = 0;  
0B29E:  CLR.B   86E
.................... 	            _LED1=0; 
0B2A0:  BCLR.B  2D0.1
.................... 	            _Detected = 0; 
0B2A2:  BCLR.B  85B.0
....................              
.................... 	        } 
.................... 	        _LED1=!_LED1;  
0B2A4:  BTG.B   2D0.1
.................... 	        flagBaliseCheck = 0; 
0B2A6:  BCLR.B  85A.2
.................... 	    }    
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        UART            ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(PCh_flagUARTReadyToDecode) __UART_Decode(TabDecoded); 
0B2A8:  BTSS.B  1617.2
0B2AA:  BRA     B2B4
0B2AC:  MOV     #171C,W4
0B2AE:  MOV     W4,1B32
0B2B0:  CALL    A654
....................  
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        Fin du prog.    ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if((Flag_end || flagTimeOut || flag_error) && !IsPassedTimeOut) 
0B2B4:  BTSC.B  85A.7
0B2B6:  BRA     B2C0
0B2B8:  BTSC.B  85A.1
0B2BA:  BRA     B2C0
0B2BC:  BTSS.B  85B.2
0B2BE:  BRA     B31C
0B2C0:  BTSC.B  85A.5
0B2C2:  BRA     B31C
.................... 		{ 
.................... 			__Afficheur_7segments(points); 
0B2C4:  MOV.B   875,W0L
0B2C6:  MOV.B   W0L,1B3A
0B2C8:  CLR.B   1B3B
0B2CA:  CALL    1382
....................  
.................... 			IsPassedTimeOut=1; 
0B2CE:  BSET.B  85A.5
.................... 			// arret moteurs 
.................... 			fprintf(ROBOTEQ, "!EX \r");  
0B2D0:  MOV     #0,W1
0B2D2:  MOV     W1,W0
0B2D4:  CLR.B   1
0B2D6:  CALL    512
0B2DA:  INC     W1,W1
0B2DC:  BTSC.B  219.1
0B2DE:  BRA     B2DC
0B2E0:  MOV     W0,21A
0B2E2:  MOV     #4,W0
0B2E4:  CPSGT   W1,W0
0B2E6:  BRA     B2D2
.................... 			driver_Pompes(0xA0,0,0,0,0,0); 
0B2E8:  MOV.B   #A0,W0L
0B2EA:  MOV.B   W0L,1B3E
0B2EC:  CLR.B   1B3F
0B2EE:  CLR.B   1B40
0B2F0:  CLR.B   1B41
0B2F2:  CLR.B   1B42
0B2F4:  CLR.B   1B43
0B2F6:  CALL    10CC
.................... 			driver_moteur(0xC0,0); 
0B2FA:  MOV.B   #C0,W0L
0B2FC:  MOV.B   W0L,1B3A
0B2FE:  CLR.B   1B3B
0B300:  CALL    120E
.................... 			driver_moteur(0xC2,0); 
0B304:  MOV.B   #C2,W0L
0B306:  MOV.B   W0L,1B3A
0B308:  CLR.B   1B3B
0B30A:  CALL    120E
.................... 			driver_moteur(0xC4,0); 
0B30E:  MOV.B   #C4,W0L
0B310:  MOV.B   W0L,1B3A
0B312:  CLR.B   1B3B
0B314:  CALL    120E
.................... 			Etat_rob = Wait_end; 
0B318:  MOV.B   #8,W0L
0B31A:  MOV.B   W0L,87B
.................... 		} 
0B31C:  GOTO    AD94
.................... 		 
.................... 	} 
.................... } 
....................  
....................  
.................... /** 
.................... * \fn void TIMER1_isr(void) 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 19.10.2015 
.................... * 
.................... * \brief Met ÃÂ  jour la pose, gÃÂ¨re le profil trapÃÂ©zoÃÂ¯dal et le PID 
.................... *		 S'active chaque 1 [ms] 
.................... * 
.................... */ 
.................... #INT_TIMER1 HIGH 
.................... void TIMER1_isr(void) 
*
00B32:  PUSH    42
00B34:  PUSH    36
00B36:  PUSH    32
00B38:  MOV     W0,[W15++]
00B3A:  MOV     #2,W0
00B3C:  REPEAT  #C
00B3E:  MOV     [W0++],[W15++]
*
0B320:  BRA     B320
.................... { 
.................... 	// Compte le temps rÃÂ©el 
.................... 	RealTimeMS ++; 
*
00B40:  INC     0862
00B42:  BTSC.B  42.1
00B44:  INC     0864
.................... 	// Temps de jeu 
.................... 	if(BeginTimeMS!=0) 
00B46:  CP0     866
00B48:  BRA     NZ,B4E
00B4A:  CP0     868
00B4C:  BRA     Z,B7A
.................... 	{ 
.................... 		GameTimeMS=RealTimeMS-BeginTimeMS; 
00B4E:  MOV     862,W4
00B50:  MOV     866,W3
00B52:  SUB     W4,W3,W0
00B54:  MOV     W0,86A
00B56:  MOV     864,W4
00B58:  MOV     868,W3
00B5A:  SUBB    W4,W3,W0
00B5C:  MOV     W0,86C
.................... 		if(GameTimeMS%1000==0)GameTimeS++; 
00B5E:  BSET.B  43.0
00B60:  MOV     86A,W0
00B62:  MOV     86C,W1
00B64:  MOV     #3E8,W2
00B66:  MOV     #0,W3
00B68:  CALL    ADE
00B6C:  MOV     W0,W5
00B6E:  MOV     W1,W6
00B70:  CP0     W5
00B72:  BRA     NZ,B7A
00B74:  CP0     W6
00B76:  BRA     NZ,B7A
00B78:  INC.B   0861
.................... 	}	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	//////////////////////////////////	TASK GIVER	//////////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Balise ÃÂ  checker 
.................... 	if(GameTimeS == 92) FlagGameEnd = 1;  
00B7A:  MOV     860,W4
00B7C:  LSR     W4,#8,W4
00B7E:  XOR.B   #5C,W4L
00B80:  BRA     NZ,B84
00B82:  BSET.B  85A.0
.................... 	if(BeginTimeMS!=0 && GameTimeMS%TIME_TO_CHECK_BAL==0) 
00B84:  CP0     866
00B86:  BRA     NZ,B8C
00B88:  CP0     868
00B8A:  BRA     Z,BA8
00B8C:  BSET.B  43.0
00B8E:  MOV     86A,W0
00B90:  MOV     86C,W1
00B92:  MOV     14B2,W2
00B94:  MOV     #0,W3
00B96:  CALL    ADE
00B9A:  MOV     W0,W5
00B9C:  MOV     W1,W6
00B9E:  CP0     W5
00BA0:  BRA     NZ,BA8
00BA2:  CP0     W6
00BA4:  BRA     NZ,BA8
.................... 	{ 
.................... 		// Check Balise 
.................... 		flagBaliseCheck=1; 
00BA6:  BSET.B  85A.2
.................... 	} 
.................... 	if(BeginTimeMS!=0 && GameTimeMS%500==0)ToDisplay=!ToDisplay; 
00BA8:  CP0     866
00BAA:  BRA     NZ,BB0
00BAC:  CP0     868
00BAE:  BRA     Z,BCC
00BB0:  BSET.B  43.0
00BB2:  MOV     86A,W0
00BB4:  MOV     86C,W1
00BB6:  MOV     #1F4,W2
00BB8:  MOV     #0,W3
00BBA:  CALL    ADE
00BBE:  MOV     W0,W5
00BC0:  MOV     W1,W6
00BC2:  CP0     W5
00BC4:  BRA     NZ,BCC
00BC6:  CP0     W6
00BC8:  BRA     NZ,BCC
00BCA:  BTG.B   85A.4
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////	WATCHDOG INTERRUPTS	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// WD Times 
.................... 	static unsigned int16 UART_WD_TIME=0; 
.................... 	 
.................... 	// Watchdog UART, rÃÂ©initialise la capture 
.................... 	if(PCh_flagUARTWatchdog==1) 
00BCC:  BTSS.B  1617.3
00BCE:  BRA     BEA
.................... 	{ 
.................... 		UART_WD_TIME++; 
00BD0:  INC     1B2E
.................... 		if(UART_WD_TIME>=UART_WD_DELAY) 
00BD2:  MOV.B   14AA,W0L
00BD4:  CLR.B   1
00BD6:  MOV     1B2E,W4
00BD8:  CP      W4,W0
00BDA:  BRA     NC,BE6
.................... 		{ 
.................... 			// Reset UART 
.................... 			ToDoUART = 0; 
00BDC:  CLR.B   171B
.................... 			PosTabToDecode=0; 
00BDE:  CLR.B   171A
.................... 			UARTToSendBack=0; 
00BE0:  CLR.B   1B1C
.................... 			UARTWaitResp=0; 
00BE2:  BCLR.B  1617.4
.................... 			// Desactive le watchdog UART 
.................... 			PCh_flagUARTWatchdog = 0; 
00BE4:  BCLR.B  1617.3
.................... 		} 
.................... 	} 
00BE6:  GOTO    BEC
.................... 	else UART_WD_TIME=0; 
00BEA:  CLR     1B2E
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////		PROGRAM END		//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// AprÃÂ¨s 1min30, on arrÃÂªte les ÃÂ©lÃÂ©ments essentiels 
.................... 	if(BeginTimeMS!=0 && GameTimeS>=98) 
00BEC:  CP0     866
00BEE:  BRA     NZ,BF4
00BF0:  CP0     868
00BF2:  BRA     Z,C00
00BF4:  MOV     860,W4
00BF6:  LSR     W4,#8,W4
00BF8:  MOV     #62,W3
00BFA:  CP.B    W3L,W4L
00BFC:  BRA     GTU,C00
.................... 	{ 
.................... 		flagTimeOut=1; 
00BFE:  BSET.B  85A.1
.................... 	} 
.................... 	// AprÃÂ¨s la fin de jeu, on ouvre le parasol  
.................... 	if(BeginTimeMS!=0 && GameTimeS>=92) 
00C00:  CP0     866
00C02:  BRA     NZ,C08
00C04:  CP0     868
00C06:  BRA     Z,C12
00C08:  MOV     860,W4
00C0A:  LSR     W4,#8,W4
00C0C:  MOV     #5C,W3
00C0E:  CP.B    W3L,W4L
00C10:  BRA     GTU,C12
.................... 	{ 
.................... 		//flagGameEnd=1; 
.................... 	}	 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... //// Timer de clignotement d'erreur. //// 
.................... //////////////////////////////////////// 
00C12:  BCLR.B  84.3
00C14:  MOV     #1A,W0
00C16:  REPEAT  #C
00C18:  MOV     [--W15],[W0--]
00C1A:  MOV     [--W15],W0
00C1C:  POP     32
00C1E:  POP     36
00C20:  POP     42
00C22:  RETFIE  
.................... #INT_TIMER3 
.................... void TIMER3_isr(void) 
00C24:  PUSH    42
00C26:  PUSH    36
00C28:  PUSH    32
00C2A:  MOV     W0,[W15++]
00C2C:  MOV     #2,W0
00C2E:  REPEAT  #C
00C30:  MOV     [W0++],[W15++]
.................... { 
.................... 	static int1 On_Off_Error = 0; 
.................... 	 
.................... 	// Si doit afficher une erreur 
.................... 	if(flagError) 
00C32:  BTSS.B  85A.3
00C34:  BRA     C38
.................... 	{ 
.................... 	//	__Afficheur_7segments(NO_ERROR,On_Off_Error); 
.................... 		On_Off_Error =! On_Off_Error; 
00C36:  BTG.B   1617.5
.................... 	}	 
00C38:  BCLR.B  84.7
00C3A:  MOV     #1A,W0
00C3C:  REPEAT  #C
00C3E:  MOV     [--W15],[W0--]
00C40:  MOV     [--W15],W0
00C42:  POP     32
00C44:  POP     36
00C46:  POP     42
00C48:  RETFIE  
.................... }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

Configuration Fuses:
   Word  1L: C712   HS2_PLL8
          H: 0000  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: 0000  
   Word  3L: 8730   NOPUT BORRES NOBROWNOUT MCLR
          H: 0000  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: 0000  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: 0000  
   Word  6L: 0007   NOWRT NOPROTECT
          H: 0000  
   Word  7L: 4003   ICSP1 DEBUG
          H: 0000  

   Some fuses have been forced to be compatible with the ICD debugger.
