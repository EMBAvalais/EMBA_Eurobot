CCS PCD C Compiler, Version 5.016, 13176               22-mars-19 15:55

               Filename:   N:\GrandRobot26102018\Code\main.lst

               ROM used:   41492 bytes (42%)
                           Largest free fragment is 32768
               RAM used:   6879 (85%) at main() level
                           7466 (92%) worst case
               Stack size: 2048

*
00000:  GOTO    9808
*
0001A:  DATA    B2,0A,00
*
00020:  DATA    62,05,00
00022:  DATA    A4,0B,00
*
00026:  DATA    E6,08,00
*
00044:  DATA    88,05,00
.................... /*==================================================================================================== 
.................... =											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy				  												== 
.................... ===  Date				: 8.6.2017																	== 
.................... ===  Nom du programme 	: InterfaceRoboteQ.mcp (fichier main.c)										== 
.................... ===  Version 			: V2.0.0.0.0																== 
.................... =====================================================================================================*/ 
....................  
.................... #include <30F6014A.h> 
.................... //////////// Standard Header file for the DSPIC30F6014A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014A 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    3F,44,00
0010E:  DATA    52,0D,00
00110:  DATA    00,00,00
00112:  CLR     32
00114:  MOV     #11E,W3
00116:  ADD     W3,W0,W0
00118:  TBLRDL.B[W0],W0L
0011A:  CLR.B   1
0011C:  RETURN  
0011E:  DATA    3F,41,00
00120:  DATA    20,31,00
00122:  DATA    0D,00,00
00124:  CLR     32
00126:  MOV     #130,W3
00128:  ADD     W3,W0,W0
0012A:  TBLRDL.B[W0],W0L
0012C:  CLR.B   1
0012E:  RETURN  
00130:  DATA    3F,41,00
00132:  DATA    20,32,00
00134:  DATA    0D,00,00
00136:  CLR     32
00138:  MOV     #142,W3
0013A:  ADD     W3,W0,W0
0013C:  TBLRDL.B[W0],W0L
0013E:  CLR.B   1
00140:  RETURN  
00142:  DATA    5E,4D,00
00144:  DATA    4D,4F,00
00146:  DATA    44,20,00
00148:  DATA    31,20,00
0014A:  DATA    30,5F,00
0014C:  DATA    5E,4D,00
0014E:  DATA    4D,4F,00
00150:  DATA    44,20,00
00152:  DATA    32,20,00
00154:  DATA    30,0D,00
00156:  DATA    00,00,00
00158:  CLR     32
0015A:  MOV     #164,W3
0015C:  ADD     W3,W0,W0
0015E:  TBLRDL.B[W0],W0L
00160:  CLR.B   1
00162:  RETURN  
00164:  DATA    5E,4D,00
00166:  DATA    4D,4F,00
00168:  DATA    44,20,00
0016A:  DATA    31,20,00
0016C:  DATA    33,5F,00
0016E:  DATA    5E,4D,00
00170:  DATA    4D,4F,00
00172:  DATA    44,20,00
00174:  DATA    32,20,00
00176:  DATA    33,0D,00
00178:  DATA    00,00,00
0017A:  CLR     32
0017C:  MOV     #186,W3
0017E:  ADD     W3,W0,W0
00180:  TBLRDL.B[W0],W0L
00182:  CLR.B   1
00184:  RETURN  
00186:  DATA    21,53,00
00188:  DATA    20,31,00
0018A:  DATA    20,25,00
0018C:  DATA    30,34,00
0018E:  DATA    75,5F,00
00190:  DATA    21,53,00
00192:  DATA    20,32,00
00194:  DATA    20,25,00
00196:  DATA    30,34,00
00198:  DATA    75,20,00
0019A:  DATA    0D,00,00
0019C:  CLR     32
0019E:  MOV     #1A8,W3
001A0:  ADD     W3,W0,W0
001A2:  TBLRDL.B[W0],W0L
001A4:  CLR.B   1
001A6:  RETURN  
001A8:  DATA    21,50,00
001AA:  DATA    52,20,00
001AC:  DATA    31,20,00
001AE:  DATA    25,64,00
001B0:  DATA    5F,21,00
001B2:  DATA    50,52,00
001B4:  DATA    20,32,00
001B6:  DATA    20,25,00
001B8:  DATA    64,20,00
001BA:  DATA    0D,00,00
001BC:  CLR     32
001BE:  MOV     #1C8,W3
001C0:  ADD     W3,W0,W0
001C2:  TBLRDL.B[W0],W0L
001C4:  CLR.B   1
001C6:  RETURN  
001C8:  DATA    21,53,00
001CA:  DATA    20,31,00
001CC:  DATA    20,31,00
001CE:  DATA    30,30,00
001D0:  DATA    5F,21,00
001D2:  DATA    53,20,00
001D4:  DATA    32,20,00
001D6:  DATA    31,30,00
001D8:  DATA    30,0D,00
001DA:  DATA    00,00,00
001DC:  CLR     32
001DE:  MOV     #1E8,W3
001E0:  ADD     W3,W0,W0
001E2:  TBLRDL.B[W0],W0L
001E4:  CLR.B   1
001E6:  RETURN  
001E8:  DATA    21,50,00
001EA:  DATA    52,20,00
001EC:  DATA    31,20,00
001EE:  DATA    31,5F,00
001F0:  DATA    21,50,00
001F2:  DATA    52,20,00
001F4:  DATA    32,20,00
001F6:  DATA    31,0D,00
001F8:  DATA    00,00,00
001FA:  CLR     32
001FC:  MOV     #206,W3
001FE:  ADD     W3,W0,W0
00200:  TBLRDL.B[W0],W0L
00202:  CLR.B   1
00204:  RETURN  
00206:  DATA    21,50,00
00208:  DATA    52,20,00
0020A:  DATA    31,20,00
0020C:  DATA    25,30,00
0020E:  DATA    37,64,00
00210:  DATA    5F,21,00
00212:  DATA    50,52,00
00214:  DATA    20,32,00
00216:  DATA    20,25,00
00218:  DATA    30,37,00
0021A:  DATA    64,20,00
0021C:  DATA    0D,00,00
0021E:  CLR     32
00220:  MOV     #22A,W3
00222:  ADD     W3,W0,W0
00224:  TBLRDL.B[W0],W0L
00226:  CLR.B   1
00228:  RETURN  
0022A:  DATA    21,4D,00
0022C:  DATA    53,20,00
0022E:  DATA    31,0D,00
00230:  DATA    00,00,00
00232:  CLR     32
00234:  MOV     #23E,W3
00236:  ADD     W3,W0,W0
00238:  TBLRDL.B[W0],W0L
0023A:  CLR.B   1
0023C:  RETURN  
0023E:  DATA    21,4D,00
00240:  DATA    53,20,00
00242:  DATA    32,0D,00
00244:  DATA    00,00,00
00246:  CLR     32
00248:  MOV     #252,W3
0024A:  ADD     W3,W0,W0
0024C:  TBLRDL.B[W0],W0L
0024E:  CLR.B   1
00250:  RETURN  
00252:  DATA    52,45,00
00254:  DATA    53,45,00
00256:  DATA    54,20,00
00258:  DATA    33,32,00
0025A:  DATA    31,36,00
0025C:  DATA    35,34,00
0025E:  DATA    39,38,00
00260:  DATA    37,20,00
00262:  DATA    0D,00,00
00264:  CLR     32
00266:  MOV     #270,W3
00268:  ADD     W3,W0,W0
0026A:  TBLRDL.B[W0],W0L
0026C:  CLR.B   1
0026E:  RETURN  
00270:  DATA    7E,4B,00
00272:  DATA    50,20,00
00274:  DATA    31,20,00
00276:  DATA    0D,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    7E,4B,00
00286:  DATA    49,20,00
00288:  DATA    31,20,00
0028A:  DATA    0D,00,00
0028C:  CLR     32
0028E:  MOV     #298,W3
00290:  ADD     W3,W0,W0
00292:  TBLRDL.B[W0],W0L
00294:  CLR.B   1
00296:  RETURN  
00298:  DATA    7E,4B,00
0029A:  DATA    44,20,00
0029C:  DATA    31,20,00
0029E:  DATA    0D,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    7E,4B,00
002AE:  DATA    50,20,00
002B0:  DATA    32,20,00
002B2:  DATA    0D,00,00
002B4:  CLR     32
002B6:  MOV     #2C0,W3
002B8:  ADD     W3,W0,W0
002BA:  TBLRDL.B[W0],W0L
002BC:  CLR.B   1
002BE:  RETURN  
002C0:  DATA    7E,4B,00
002C2:  DATA    49,20,00
002C4:  DATA    32,20,00
002C6:  DATA    0D,00,00
002C8:  CLR     32
002CA:  MOV     #2D4,W3
002CC:  ADD     W3,W0,W0
002CE:  TBLRDL.B[W0],W0L
002D0:  CLR.B   1
002D2:  RETURN  
002D4:  DATA    7E,4B,00
002D6:  DATA    44,20,00
002D8:  DATA    32,20,00
002DA:  DATA    0D,00,00
002DC:  CLR     32
002DE:  MOV     #2E8,W3
002E0:  ADD     W3,W0,W0
002E2:  TBLRDL.B[W0],W0L
002E4:  CLR.B   1
002E6:  RETURN  
002E8:  DATA    7E,4D,00
002EA:  DATA    41,43,00
002EC:  DATA    20,31,00
002EE:  DATA    20,0D,00
002F0:  DATA    00,00,00
002F2:  CLR     32
002F4:  MOV     #2FE,W3
002F6:  ADD     W3,W0,W0
002F8:  TBLRDL.B[W0],W0L
002FA:  CLR.B   1
002FC:  RETURN  
002FE:  DATA    7E,4D,00
00300:  DATA    44,45,00
00302:  DATA    43,20,00
00304:  DATA    31,20,00
00306:  DATA    0D,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    7E,4D,00
00316:  DATA    41,43,00
00318:  DATA    20,32,00
0031A:  DATA    20,0D,00
0031C:  DATA    00,00,00
0031E:  CLR     32
00320:  MOV     #32A,W3
00322:  ADD     W3,W0,W0
00324:  TBLRDL.B[W0],W0L
00326:  CLR.B   1
00328:  RETURN  
0032A:  DATA    7E,4D,00
0032C:  DATA    44,45,00
0032E:  DATA    43,20,00
00330:  DATA    32,20,00
00332:  DATA    0D,00,00
00334:  CLR     32
00336:  MOV     #26,W3
00338:  SUB     W0,W3,W3
0033A:  BRA     C,346
0033C:  MOV     #350,W3
0033E:  ADD     W3,W0,W0
00340:  TBLRDL.B[W0],W0L
00342:  CLR.B   1
00344:  RETURN  
00346:  MOV     #350,W0
00348:  ADD     W3,W3,W3
0034A:  ADD     W3,W0,W3
0034C:  TBLRDH  [W3],W0
0034E:  RETURN  
00350:  DATA    5E,4B,49
00352:  DATA    50,20,20
00354:  DATA    31,20,32
00356:  DATA    25,75,20
00358:  DATA    5F,5E,25
0035A:  DATA    4B,49,75
0035C:  DATA    20,31,5F
0035E:  DATA    20,25,5E
00360:  DATA    75,5F,4B
00362:  DATA    5E,4B,44
00364:  DATA    44,20,20
00366:  DATA    31,20,32
00368:  DATA    25,75,20
0036A:  DATA    5F,5E,25
0036C:  DATA    4B,50,75
0036E:  DATA    20,32,20
00370:  DATA    20,25,0D
00372:  DATA    75,5F,00
00374:  DATA    5E,4B,00
00376:  CLR     32
00378:  MOV     #1E,W3
0037A:  SUB     W0,W3,W3
0037C:  BRA     C,388
0037E:  MOV     #392,W3
00380:  ADD     W3,W0,W0
00382:  TBLRDL.B[W0],W0L
00384:  CLR.B   1
00386:  RETURN  
00388:  MOV     #392,W0
0038A:  ADD     W3,W3,W3
0038C:  ADD     W3,W0,W3
0038E:  TBLRDH  [W3],W0
00390:  RETURN  
00392:  DATA    5E,4D,5F
00394:  DATA    41,43,5E
00396:  DATA    20,31,4D
00398:  DATA    20,25,44
0039A:  DATA    75,5F,45
0039C:  DATA    5E,4D,43
0039E:  DATA    44,45,20
003A0:  DATA    43,20,32
003A2:  DATA    31,20,20
003A4:  DATA    25,75,25
003A6:  DATA    5F,5E,75
003A8:  DATA    4D,41,20
003AA:  DATA    43,20,0D
003AC:  DATA    32,20,00
003AE:  DATA    25,75,00
003B0:  CLR     32
003B2:  MOV     #3BC,W3
003B4:  ADD     W3,W0,W0
003B6:  TBLRDL.B[W0],W0L
003B8:  CLR.B   1
003BA:  RETURN  
003BC:  DATA    45,45,00
003BE:  DATA    53,41,00
003C0:  DATA    56,20,00
003C2:  DATA    0D,00,00
003C4:  CLR     32
003C6:  MOV     #3D0,W3
003C8:  ADD     W3,W0,W0
003CA:  TBLRDL.B[W0],W0L
003CC:  CLR.B   1
003CE:  RETURN  
003D0:  DATA    43,61,00
003D2:  DATA    72,74,00
003D4:  DATA    65,20,00
003D6:  DATA    50,72,00
003D8:  DATA    69,6E,00
003DA:  DATA    63,69,00
003DC:  DATA    70,61,00
003DE:  DATA    6C,65,00
003E0:  DATA    20,3A,00
003E2:  DATA    20,43,00
003E4:  DATA    6F,6D,00
003E6:  DATA    6D,61,00
003E8:  DATA    6E,64,00
003EA:  DATA    65,20,00
003EC:  DATA    49,6E,00
003EE:  DATA    63,6F,00
003F0:  DATA    6E,6E,00
003F2:  DATA    75,65,00
003F4:  DATA    0D,00,00
003F6:  CLR     32
003F8:  MOV     #402,W3
003FA:  ADD     W3,W0,W0
003FC:  TBLRDL.B[W0],W0L
003FE:  CLR.B   1
00400:  RETURN  
00402:  DATA    21,4D,00
00404:  DATA    47,0D,00
00406:  DATA    00,00,00
00408:  CLR     32
0040A:  MOV     #414,W3
0040C:  ADD     W3,W0,W0
0040E:  TBLRDL.B[W0],W0L
00410:  CLR.B   1
00412:  RETURN  
00414:  DATA    5E,4D,00
00416:  DATA    44,45,00
00418:  DATA    43,20,00
0041A:  DATA    31,20,00
0041C:  DATA    39,30,00
0041E:  DATA    30,30,00
00420:  DATA    5F,5E,00
00422:  DATA    4D,44,00
00424:  DATA    45,43,00
00426:  DATA    20,32,00
00428:  DATA    20,39,00
0042A:  DATA    30,30,00
0042C:  DATA    30,0D,00
0042E:  DATA    00,00,00
00430:  CLR     32
00432:  MOV     #43C,W3
00434:  ADD     W3,W0,W0
00436:  TBLRDL.B[W0],W0L
00438:  CLR.B   1
0043A:  RETURN  
0043C:  DATA    21,53,00
0043E:  DATA    20,31,00
00440:  DATA    20,30,00
00442:  DATA    5F,21,00
00444:  DATA    53,20,00
00446:  DATA    32,20,00
00448:  DATA    30,0D,00
0044A:  DATA    00,00,00
0044C:  CLR     32
0044E:  MOV     #458,W3
00450:  ADD     W3,W0,W0
00452:  TBLRDL.B[W0],W0L
00454:  CLR.B   1
00456:  RETURN  
00458:  DATA    5E,4D,00
0045A:  DATA    44,45,00
0045C:  DATA    43,20,00
0045E:  DATA    31,20,00
00460:  DATA    36,30,00
00462:  DATA    30,30,00
00464:  DATA    5F,5E,00
00466:  DATA    4D,44,00
00468:  DATA    45,43,00
0046A:  DATA    20,32,00
0046C:  DATA    20,36,00
0046E:  DATA    30,30,00
00470:  DATA    30,0D,00
00472:  DATA    00,00,00
00474:  CLR     32
00476:  MOV     #480,W3
00478:  ADD     W3,W0,W0
0047A:  TBLRDL.B[W0],W0L
0047C:  CLR.B   1
0047E:  RETURN  
00480:  DATA    21,53,00
00482:  DATA    20,31,00
00484:  DATA    20,25,00
00486:  DATA    75,5F,00
00488:  DATA    21,53,00
0048A:  DATA    20,32,00
0048C:  DATA    20,25,00
0048E:  DATA    75,0D,00
00490:  DATA    00,00,00
00492:  CLR     32
00494:  MOV     #49E,W3
00496:  ADD     W3,W0,W0
00498:  TBLRDL.B[W0],W0L
0049A:  CLR.B   1
0049C:  RETURN  
0049E:  DATA    21,45,00
004A0:  DATA    58,20,00
004A2:  DATA    0D,00,00
*
00632:  MOV     W5,[W15++]
00634:  MOV     #C,W5
00636:  REPEAT  #3
00638:  MOV     [W5++],[W15++]
0063A:  MUL.UU  W0,W2,W4
0063C:  BTSS    W3.F
0063E:  BRA     644
00640:  MUL.SS  W0,W3,W6
00642:  BRA     646
00644:  MUL.UU  W0,W3,W6
00646:  BCLR.B  42.0
00648:  ADD     W6,W5,W5
0064A:  ADDC    W7,#0,W8
0064C:  BTSS    W1.F
0064E:  BRA     654
00650:  MUL.SS  W1,W2,W6
00652:  BRA     656
00654:  MUL.UU  W1,W2,W6
00656:  ADDC    W6,W5,W5
00658:  ADDC    W7,W8,W8
0065A:  ADDC    #0,W9
0065C:  MUL.SS  W1,W3,W6
0065E:  ADDC    W6,W8,W8
00660:  ADDC    W9,W7,W7
00662:  MOV     W7,W3
00664:  MOV     W8,W2
00666:  MOV     W5,W1
00668:  MOV     W4,W0
0066A:  MOV     #12,W5
0066C:  REPEAT  #3
0066E:  MOV     [--W15],[W5--]
00670:  MOV     [--W15],W5
00672:  RETURN  
*
00A5E:  MOV     W5,[W15++]
00A60:  MOV     #C,W5
00A62:  REPEAT  #3
00A64:  MOV     [W5++],[W15++]
00A66:  MOV     #0,W9
00A68:  BTSC.B  43.0
00A6A:  MOV     #1,W9
00A6C:  MOV     W9,[W15++]
00A6E:  CLR     W4
00A70:  CLR     W5
00A72:  CLR     W6
00A74:  CLR     W7
00A76:  XOR     W2,W3,W8
00A78:  BRA     Z,A9C
00A7A:  MOV     #20,W8
00A7C:  BCLR.B  42.0
00A7E:  RLC     W0,W0
00A80:  RLC     W1,W1
00A82:  RLC     W4,W4
00A84:  RLC     W5,W5
00A86:  CP      W5,W3
00A88:  BRA     NZ,A8C
00A8A:  CPB     W4,W2
00A8C:  BRA     NC,A94
00A8E:  SUB     W4,W2,W4
00A90:  SUBB    W5,W3,W5
00A92:  BSET.B  42.0
00A94:  RLC     W6,W6
00A96:  RLC     W7,W7
00A98:  DEC     W8,W8
00A9A:  BRA     NZ,A7C
00A9C:  MOV     W7,W1
00A9E:  MOV     W6,W0
00AA0:  MOV     [--W15],W9
00AA2:  CP0     W9
00AA4:  BRA     Z,AA8
00AA6:  MOV.D   W4,W0
00AA8:  MOV     #12,W5
00AAA:  REPEAT  #3
00AAC:  MOV     [--W15],[W5--]
00AAE:  MOV     [--W15],W5
00AB0:  RETURN  
*
00BCA:  MOV     W8,[W15++]
00BCC:  MOV     #12,W8
00BCE:  REPEAT  #4
00BD0:  MOV     [W8++],[W15++]
00BD2:  CLR     W11
00BD4:  MUL.UU  W12,#0,W12
00BD6:  MOV     W3,W8
00BD8:  MOV     W7,W9
00BDA:  MOV     #7FF,W10
00BDC:  BCLR.B  42.0
00BDE:  BCLR.B  42.1
00BE0:  ASR     W8,#4,W8
00BE2:  AND     W10,W8,W8
00BE4:  CP0     W8
00BE6:  BRA     Z,CCA
00BE8:  BCLR.B  42.0
00BEA:  BCLR.B  42.1
00BEC:  ASR     W9,#4,W9
00BEE:  AND     W10,W9,W9
00BF0:  CP0     W9
00BF2:  BRA     Z,CCA
00BF4:  ADD     W9,W8,W8
00BF6:  BTSC    W9.B
00BF8:  BRA     C02
00BFA:  SUB     #3FF,W8
00BFC:  BRA     Z,CCA
00BFE:  BRA     NC,CCA
00C00:  BRA     C08
00C02:  MOV     #401,W10
00C04:  ADD.B   W10L,W5L,W5L
00C06:  BRA     C,CCA
00C08:  XOR     W3,W7,W13
00C0A:  BCLR.B  42.0
00C0C:  BCLR.B  42.1
00C0E:  AND     #F,W3
00C10:  BSET    W3.4
00C12:  AND     #F,W7
00C14:  BSET    W7.4
00C16:  MOV     W8,[W15++]
00C18:  MUL.UU  W4,W1,W8
00C1A:  MUL.UU  W5,W0,W10
00C1C:  ADD     W8,W10,W10
00C1E:  ADDC    W9,W11,W11
00C20:  ADDC    #0,W12
00C22:  MUL.UU  W4,W2,W8
00C24:  ADD     W8,W11,W11
00C26:  ADDC    W9,W12,W12
00C28:  MUL.UU  W5,W1,W8
00C2A:  CLR     W10
00C2C:  ADD     W8,W11,W11
00C2E:  ADDC    W9,W12,W12
00C30:  ADDC    #0,W10
00C32:  MUL.UU  W6,W0,W8
00C34:  ADD     W8,W11,W11
00C36:  ADDC    W9,W12,W12
00C38:  ADDC    #0,W10
00C3A:  CLR     W11
00C3C:  MUL.UU  W4,W3,W8
00C3E:  ADD     W8,W12,W12
00C40:  ADDC    W9,W10,W10
00C42:  ADDC    #0,W11
00C44:  MUL.UU  W5,W2,W8
00C46:  ADD     W8,W12,W12
00C48:  ADDC    W9,W10,W10
00C4A:  ADDC    #0,W11
00C4C:  MUL.UU  W6,W1,W8
00C4E:  ADD     W8,W12,W12
00C50:  ADDC    W9,W10,W10
00C52:  ADDC    #0,W11
00C54:  MUL.UU  W7,W0,W8
00C56:  ADD     W8,W12,W12
00C58:  ADDC    W9,W10,W10
00C5A:  ADDC    #0,W11
00C5C:  MOV     W12,W0
00C5E:  CLR     W12
00C60:  MUL.UU  W5,W3,W8
00C62:  ADD     W8,W10,W10
00C64:  ADDC    W9,W11,W11
00C66:  ADDC    #0,W12
00C68:  MUL.UU  W6,W2,W8
00C6A:  ADD     W8,W10,W10
00C6C:  ADDC    W9,W11,W11
00C6E:  ADDC    #0,W12
00C70:  MUL.UU  W6,W3,W8
00C72:  ADD     W8,W11,W11
00C74:  ADDC    W9,W12,W12
00C76:  MUL.UU  W7,W1,W8
00C78:  ADD     W8,W10,W10
00C7A:  ADDC    W9,W11,W11
00C7C:  ADDC    #0,W12
00C7E:  MUL.UU  W7,W2,W8
00C80:  ADD     W8,W11,W11
00C82:  ADDC    W9,W12,W12
00C84:  MUL.UU  W7,W3,W8
00C86:  ADD     W8,W12,W12
00C88:  MOV     W10,W1
00C8A:  MOV     W11,W2
00C8C:  MOV     W12,W3
00C8E:  MOV     #5,W4
00C90:  BCLR.B  42.0
00C92:  RRC     W3,W3
00C94:  RRC     W2,W2
00C96:  RRC     W1,W1
00C98:  RRC     W0,W0
00C9A:  DEC     W4,W4
00C9C:  BRA     NZ,C90
00C9E:  MOV     [--W15],W8
00CA0:  INC     W8,W8
00CA2:  IOR      W0,  W1,W6
00CA4:  BRA     Z,CA8
00CA6:  BRA     CAC
00CA8:  IOR      W2,  W3,W6
00CAA:  BRA     Z,CBC
00CAC:  BTSC    W3.4
00CAE:  BRA     CBC
00CB0:  BCLR.B  42.0
00CB2:  RLC     W0,W0
00CB4:  RLC     W1,W1
00CB6:  RLC     W2,W2
00CB8:  RLC     W3,W3
00CBA:  DEC     W8,W8
00CBC:  SL      W8,#4,W8
00CBE:  BCLR    W3.F
00CC0:  BTSC    W13.F
00CC2:  BSET    W3.F
00CC4:  BCLR    W3.4
00CC6:  XOR     W8,W3,W3
00CC8:  BRA     CD0
00CCA:  MUL.UU  W0,#0,W0
00CCC:  MUL.UU  W0,#0,W2
00CCE:  BRA     CD0
00CD0:  MOV     #1A,W8
00CD2:  REPEAT  #4
00CD4:  MOV     [--W15],[W8--]
00CD6:  MOV     [--W15],W8
00CD8:  RETURN  
00CDA:  MOV     W8,[W15++]
00CDC:  MOV     #12,W8
00CDE:  REPEAT  #4
00CE0:  MOV     [W8++],[W15++]
00CE2:  XOR     W3,W7,W13
00CE4:  MOV     W3,W8
00CE6:  MOV     W7,W9
00CE8:  MOV     #7FF,W10
00CEA:  BCLR.B  42.0
00CEC:  BCLR.B  42.1
00CEE:  ASR     W8,#4,W8
00CF0:  AND     W10,W8,W8
00CF2:  CP0     W8
00CF4:  BRA     Z,DCE
00CF6:  BCLR.B  42.0
00CF8:  BCLR.B  42.1
00CFA:  ASR     W9,#4,W9
00CFC:  AND     W10,W9,W9
00CFE:  CP0     W9
00D00:  BRA     Z,DCE
00D02:  CLR     W10
00D04:  SUB     W8,W9,W12
00D06:  BRA     NC,D0E
00D08:  ADD     #3FF,W12
00D0A:  BRA     C,DCE
00D0C:  BRA     D16
00D0E:  MOV     #401,W11
00D10:  SUB     W12,W11,W12
00D12:  BRA     NC,DCE
00D14:  BRA     Z,DCE
00D16:  CLR     W8
00D18:  CLR     W9
00D1A:  CLR     W10
00D1C:  CLR     W11
00D1E:  AND     #1F,W3
00D20:  BSET    W3.4
00D22:  AND     #1F,W7
00D24:  BSET    W7.4
00D26:  MOV     W12,[W15++]
00D28:  MOV     #36,W12
00D2A:  SUB     W0,W4,W0
00D2C:  SUBB    W1,W5,W1
00D2E:  SUBB    W2,W6,W2
00D30:  SUBB    W3,W7,W3
00D32:  BRA     N,D38
00D34:  BRA     C,D42
00D36:  BRA     NZ,D44
00D38:  ADD     W0,W4,W0
00D3A:  ADDC    W1,W5,W1
00D3C:  ADDC    W2,W6,W2
00D3E:  ADDC    W3,W7,W3
00D40:  BRA     D44
00D42:  BSET    W8.0
00D44:  DEC     W12,W12
00D46:  BRA     Z,D5E
00D48:  BCLR.B  42.0
00D4A:  RLC     W0,W0
00D4C:  RLC     W1,W1
00D4E:  RLC     W2,W2
00D50:  RLC     W3,W3
00D52:  BCLR.B  42.0
00D54:  RLC     W8,W8
00D56:  RLC     W9,W9
00D58:  RLC     W10,W10
00D5A:  RLC     W11,W11
00D5C:  BRA     D2A
00D5E:  MOV     [--W15],W12
00D60:  BTSC    W11.5
00D62:  BRA     D66
00D64:  BRA     D72
00D66:  BCLR.B  42.0
00D68:  RRC     W11,W11
00D6A:  RRC     W10,W10
00D6C:  RRC     W9,W9
00D6E:  RRC     W8,W8
00D70:  BRA     D78
00D72:  DEC     W12,W12
00D74:  BCLR.B  42.0
00D76:  BRA     Z,DCE
00D78:  BTSC.B  42.0
00D7A:  BRA     D8E
00D7C:  RLC     W0,W0
00D7E:  RLC     W1,W1
00D80:  RLC     W2,W2
00D82:  RLC     W3,W3
00D84:  SUB     W0,W4,W4
00D86:  SUBB    W1,W5,W5
00D88:  SUBB    W2,W6,W6
00D8A:  SUBB    W3,W7,W7
00D8C:  BRA     NC,DB8
00D8E:  INC     W8,W8
00D90:  BRA     NZ,DB8
00D92:  INC     W9,W9
00D94:  BRA     NZ,DB8
00D96:  INC     W10,W10
00D98:  BRA     NZ,DB8
00D9A:  INC     W11,W11
00D9C:  BRA     NZ,DB8
00D9E:  INC     W12,W12
00DA0:  BRA     Z,DCE
00DA2:  BRA     DB8
00DA4:  DEC     W12,W12
00DA6:  BRA     Z,DCE
00DA8:  BTSC    W11.4
00DAA:  BRA     DB8
00DAC:  BCLR.B  42.0
00DAE:  RLC     W8,W8
00DB0:  RLC     W9,W9
00DB2:  RLC     W10,W10
00DB4:  RLC     W11,W11
00DB6:  BRA     DA8
00DB8:  SL      W12,#4,W12
00DBA:  BCLR.B  42.0
00DBC:  BCLR    W12.F
00DBE:  BTSC    W13.F
00DC0:  BSET    W12.F
00DC2:  BCLR    W11.4
00DC4:  XOR     W12,W11,W3
00DC6:  MOV     W10,W2
00DC8:  MOV     W9,W1
00DCA:  MOV     W8,W0
00DCC:  BRA     DD8
00DCE:  MOV     #0,W0
00DD0:  MOV     #0,W1
00DD2:  MOV     #0,W2
00DD4:  MOV     #0,W3
00DD6:  BRA     DD8
00DD8:  MOV     #1A,W8
00DDA:  REPEAT  #4
00DDC:  MOV     [--W15],[W8--]
00DDE:  MOV     [--W15],W8
00DE0:  RETURN  
*
01046:  MOV     #F000,W1
01048:  ADD     W1,W3,W3
0104A:  MOV     #7F,W1
0104C:  ADDC    W1,#0,W1
0104E:  MOV     W1,32
01050:  BCLR    W5.0
01052:  CP0     W5
01054:  BRA     Z,105C
01056:  TBLRDL  [W3++],[W4++]
01058:  DEC2    W5,W5
0105A:  BRA     NZ,1054
0105C:  RETURN  
*
01394:  MOV     W5,[W15++]
01396:  MOV     #C,W5
01398:  REPEAT  #3
0139A:  MOV     [W5++],[W15++]
0139C:  MOV     W0,W4
0139E:  MOV     W1,W5
013A0:  MOV     W2,W6
013A2:  MOV     W3,W7
013A4:  CLR     W0
013A6:  CLR     W1
013A8:  CLR     W2
013AA:  CLR     W3
013AC:  BCLR    W8.0
013AE:  BTSS    W7.F
013B0:  BRA     13BC
013B2:  BSET    W8.0
013B4:  NEG     W4,W4
013B6:  COM     W5,W5
013B8:  COM     W6,W6
013BA:  COM     W7,W7
013BC:  IOR      W4,  W5,W9
013BE:  BRA     NZ,13C4
013C0:  IOR      W6,  W7,W9
013C2:  BRA     Z,13EE
013C4:  MOV     #473,W9
013C6:  BTSC    W3.4
013C8:  BRA     13E0
013CA:  BCLR.B  42.0
013CC:  RLC     W4,W4
013CE:  RLC     W5,W5
013D0:  RLC     W6,W6
013D2:  RLC     W7,W7
013D4:  RLC     W0,W0
013D6:  RLC     W1,W1
013D8:  RLC     W2,W2
013DA:  RLC     W3,W3
013DC:  DEC     W9,W9
013DE:  BRA     NZ,13C6
013E0:  SL      W9,#4,W9
013E2:  BCLR.B  42.0
013E4:  BCLR    W9.F
013E6:  BCLR    W3.4
013E8:  XOR     W9,W3,W3
013EA:  BTSC    W8.0
013EC:  BSET    W3.F
013EE:  MOV     #12,W5
013F0:  REPEAT  #3
013F2:  MOV     [--W15],[W5--]
013F4:  MOV     [--W15],W5
013F6:  RETURN  
*
014A2:  MOV     W5,[W15++]
014A4:  MOV     #C,W5
014A6:  REPEAT  #3
014A8:  MOV     [W5++],[W15++]
014AA:  MOV     #0,W9
014AC:  BTSC.B  43.0
014AE:  MOV     #1,W9
014B0:  MOV     W9,[W15++]
014B2:  XOR     W1,W3,W9
014B4:  BTSS    W1.F
014B6:  BRA     14BE
014B8:  COM     W1,W1
014BA:  NEG     W0,W0
014BC:  ADDC    W1,#0,W1
014BE:  BTSS    W3.F
014C0:  BRA     14C8
014C2:  COM     W3,W3
014C4:  NEG     W2,W2
014C6:  ADDC    W3,#0,W3
014C8:  XOR     W2,W3,W4
014CA:  BRA     Z,14F6
014CC:  CLR     W4
014CE:  CLR     W5
014D0:  CLR     W6
014D2:  CLR     W7
014D4:  MOV     #20,W8
014D6:  BCLR.B  42.0
014D8:  RLC     W0,W0
014DA:  RLC     W1,W1
014DC:  RLC     W4,W4
014DE:  RLC     W5,W5
014E0:  CP      W5,W3
014E2:  BRA     NZ,14E6
014E4:  CPB     W4,W2
014E6:  BRA     NC,14EE
014E8:  SUB     W4,W2,W4
014EA:  SUBB    W5,W3,W5
014EC:  BSET.B  42.0
014EE:  RLC     W6,W6
014F0:  RLC     W7,W7
014F2:  DEC     W8,W8
014F4:  BRA     NZ,14D6
014F6:  BTSS    W9.F
014F8:  BRA     1508
014FA:  NEG     W6,W0
014FC:  BRA     Z,1500
014FE:  BRA     NZ,1504
01500:  NEG     W7,W1
01502:  BRA     150E
01504:  COM     W7,W1
01506:  BRA     150E
01508:  MOV     W7,W1
0150A:  MOV     W6,W0
0150C:  BRA     150E
0150E:  MOV     [--W15],W9
01510:  CP0     W9
01512:  BRA     Z,1516
01514:  MOV.D   W4,W0
01516:  MOV     #12,W5
01518:  REPEAT  #3
0151A:  MOV     [--W15],[W5--]
0151C:  MOV     [--W15],W5
0151E:  RETURN  
*
017CC:  MOV     W5,[W15++]
017CE:  MOV     W6,[W15++]
017D0:  MOV     #8E,W1
017D2:  BCLR    W6.0
017D4:  BTSS    W0.F
017D6:  BRA     17DE
017D8:  BSET    W6.0
017DA:  NEG     W0,W0
017DC:  BRA     17DE
017DE:  CP0     W0
017E0:  BRA     Z,180A
017E2:  BTSC    W0.F
017E4:  BRA     17EE
017E6:  BCLR.B  42.0
017E8:  RLC     W0,W0
017EA:  DEC     W1,W1
017EC:  BRA     17E2
017EE:  SWAP    W1
017F0:  BCLR.B  42.0
017F2:  RRC     W1,W1
017F4:  BCLR    W0.F
017F6:  SWAP    W0
017F8:  XOR.B   W0L,W1L,W1L
017FA:  AND.B   #0,W0L
017FC:  BTSC    W6.0
017FE:  BSET    W1.F
01800:  BRA     1810
01802:  MOV.B   W1L,W0L
01804:  BSET    W1.7
01806:  AND.B   #0,W1L
01808:  BRA     1810
0180A:  CLR     W0
0180C:  CLR     W1
0180E:  BRA     1810
01810:  MOV     [--W15],W6
01812:  MOV     [--W15],W5
01814:  RETURN  
01816:  MOV     W5,[W15++]
01818:  MOV     W6,[W15++]
0181A:  MOV     W7,[W15++]
0181C:  XOR     W1,W3,W4
0181E:  BTSS    W4.F
01820:  BRA     182E
01822:  BCLR.B  42.0
01824:  BCLR.B  42.1
01826:  BTSS    W1.F
01828:  BRA     1876
0182A:  BSET.B  42.0
0182C:  BRA     1876
0182E:  MOV     W1,W4
01830:  MOV     W0,W5
01832:  MOV     W3,W6
01834:  MOV     W2,W7
01836:  RLC     W1,W1
01838:  SWAP    W1
0183A:  RLC     W3,W3
0183C:  SWAP    W3
0183E:  SUB.B   W3L,W1L,W1L
01840:  BRA     Z,184C
01842:  BTSS    W4.F
01844:  BRA     1876
01846:  MOV     #1,W0
01848:  XOR.B   42
0184A:  BRA     1876
0184C:  MOV.B   W4L,W1L
0184E:  MOV.B   W6L,W3L
01850:  BCLR    W1.7
01852:  BCLR    W3.7
01854:  SUB.B   W3L,W1L,W1L
01856:  BRA     Z,1862
01858:  BTSS    W4.F
0185A:  BRA     1876
0185C:  MOV     #1,W0
0185E:  XOR.B   42
01860:  BRA     1876
01862:  SUB     W7,W5,W1
01864:  BRA     Z,1870
01866:  BTSS    W4.F
01868:  BRA     1876
0186A:  MOV     #1,W0
0186C:  XOR.B   42
0186E:  BRA     1876
01870:  BCLR.B  42.0
01872:  BRA     1876
01874:  BRA     1876
01876:  MOV     [--W15],W7
01878:  MOV     [--W15],W6
0187A:  MOV     [--W15],W5
0187C:  RETURN  
0187E:  MOV     W5,[W15++]
01880:  MOV     #C,W5
01882:  REPEAT  #4
01884:  MOV     [W5++],[W15++]
01886:  CLR     W9
01888:  XOR     W1,W3,W9
0188A:  MOV     W1,W6
0188C:  MOV     W0,W5
0188E:  MOV     W3,W8
01890:  MOV     W2,W7
01892:  RLC     W1,W1
01894:  SWAP    W1
01896:  ZE      W1,W1
01898:  CP0     W1
0189A:  BRA     Z,1938
0189C:  RLC     W3,W3
0189E:  SWAP    W3
018A0:  ZE      W3,W3
018A2:  CP0     W3
018A4:  BRA     Z,1938
018A6:  CLR     W0
018A8:  SUB.B   W1L,W3L,W0L
018AA:  BRA     NC,18B2
018AC:  ADD.B   #7F,W0L
018AE:  BRA     C,1938
018B0:  BRA     18B8
018B2:  SUB.B   #81,W0L
018B4:  BRA     NC,1938
018B6:  BRA     Z,1938
018B8:  MOV     W5,W1
018BA:  MOV     W6,W2
018BC:  BSET    W2.7
018BE:  AND     #FF,W2
018C0:  AND     #FF,W8
018C2:  BSET    W8.7
018C4:  MOV     #19,W10
018C6:  CLR     W3
018C8:  CLR     W4
018CA:  SUB     W1,W7,W1
018CC:  SUBB    W2,W8,W2
018CE:  BRA     N,18D4
018D0:  BRA     C,18DA
018D2:  BRA     NZ,18DC
018D4:  ADD     W1,W7,W1
018D6:  ADDC    W2,W8,W2
018D8:  BRA     18DC
018DA:  BSET    W4.0
018DC:  DEC     W10,W10
018DE:  BRA     Z,18EE
018E0:  BCLR.B  42.0
018E2:  RLC     W1,W1
018E4:  RLC     W2,W2
018E6:  BCLR.B  42.0
018E8:  RLC     W4,W4
018EA:  RLC     W3,W3
018EC:  BRA     18CA
018EE:  CLR     W10
018F0:  BTSC    W3.8
018F2:  BRA     18F6
018F4:  BRA     1902
018F6:  BCLR.B  42.0
018F8:  RRC     W3,W3
018FA:  BCLR    W3.7
018FC:  RRC     W4,W4
018FE:  RLC     W10,W10
01900:  BRA     1906
01902:  DEC     W0,W0
01904:  BRA     Z,1938
01906:  BTSC    W10.F
01908:  BRA     NC,1914
0190A:  RLC     W1,W1
0190C:  RLC     W2,W2
0190E:  SUB     W1,W7,W1
01910:  SUBB    W2,W8,W2
01912:  BRA     NC,1926
01914:  INC     W4,W4
01916:  BRA     NZ,1926
01918:  INC     W3,W3
0191A:  BRA     NZ,1926
0191C:  INC     W0,W0
0191E:  BRA     Z,1938
01920:  BRA     1926
01922:  DEC     W0,W0
01924:  BRA     Z,1938
01926:  SWAP    W0
01928:  RRC     W0,W1
0192A:  BSET    W1.F
0192C:  BTSS    W9.F
0192E:  BCLR    W1.F
01930:  BCLR    W3.7
01932:  XOR.B   W3L,W1L,W1L
01934:  MOV     W4,W0
01936:  BRA     193E
01938:  MOV     #0,W0
0193A:  MOV     #0,W1
0193C:  BRA     193E
0193E:  MOV     #14,W5
01940:  REPEAT  #4
01942:  MOV     [--W15],[W5--]
01944:  MOV     [--W15],W5
01946:  RETURN  
01948:  MOV     W0,W2
0194A:  MOV     W1,W3
0194C:  MOV.B   W1L,W0L
0194E:  SWAP    W0
01950:  BSET    W0.F
01952:  RLC     W1,W1
01954:  SWAP    W1
01956:  ZE      W1,W1
01958:  MOV     #8E,W4
0195A:  SUB.B   W4L,W1L,W1L
0195C:  BRA     Z,196A
0195E:  CP0     W0
01960:  BRA     Z,196A
01962:  BCLR.B  42.0
01964:  RRC     W0,W0
01966:  DEC     W1,W1
01968:  BRA     NZ,195E
0196A:  BTSS    W3.F
0196C:  BRA     1972
0196E:  NEG     W0,W0
01970:  BRA     1972
01972:  RETURN  
01974:  MOV     W5,[W15++]
01976:  MOV     W6,[W15++]
01978:  MOV     #8E,W1
0197A:  CP0     W0
0197C:  BRA     Z,19A2
0197E:  BTSC    W0.F
01980:  BRA     198A
01982:  BCLR.B  42.0
01984:  RLC     W0,W0
01986:  DEC     W1,W1
01988:  BRA     197E
0198A:  SWAP    W1
0198C:  BCLR.B  42.0
0198E:  RRC     W1,W1
01990:  BCLR    W0.F
01992:  SWAP    W0
01994:  XOR.B   W0L,W1L,W1L
01996:  AND.B   #0,W0L
01998:  BRA     19A8
0199A:  MOV.B   W1L,W0L
0199C:  BSET    W1.7
0199E:  AND.B   #0,W1L
019A0:  BRA     19A8
019A2:  CLR     W0
019A4:  CLR     W1
019A6:  BRA     19A8
019A8:  MOV     [--W15],W6
019AA:  MOV     [--W15],W5
019AC:  RETURN  
019AE:  MOV     W5,[W15++]
019B0:  MOV     #C,W5
019B2:  REPEAT  #4
019B4:  MOV     [W5++],[W15++]
019B6:  MOV     W0,W4
019B8:  MOV     W1,W5
019BA:  MOV     W3,W7
019BC:  MOV     W2,W6
019BE:  BCLR.B  42.0
019C0:  BCLR.B  42.1
019C2:  RLC     W1,W1
019C4:  SWAP    W1
019C6:  AND     #FF,W1
019C8:  CP0     W1
019CA:  BRA     Z,1A62
019CC:  BCLR.B  42.0
019CE:  BCLR.B  42.1
019D0:  RLC     W3,W3
019D2:  SWAP    W3
019D4:  AND     #FF,W3
019D6:  CP0     W3
019D8:  BRA     Z,1A62
019DA:  ZE      W0,W0
019DC:  ADD.B   W3L,W1L,W0L
019DE:  BRA     C,19E8
019E0:  SUB     #7F,W0
019E2:  BRA     Z,1A62
019E4:  BRA     NC,1A62
019E6:  BRA     19EC
019E8:  ADD.B   #81,W0L
019EA:  BRA     C,1A62
019EC:  XOR     W5,W7,W10
019EE:  BCLR.B  42.0
019F0:  BCLR.B  42.1
019F2:  AND     #FF,W5
019F4:  BSET    W5.7
019F6:  BCLR.B  42.0
019F8:  AND     #FF,W7
019FA:  BSET    W7.7
019FC:  MUL.UU  W4,W6,W2
019FE:  MUL.UU  W5,W6,W8
01A00:  ADDC    W8,W3,W3
01A02:  MOV     W9,W1
01A04:  BTSC.B  42.0
01A06:  INC     W1,W1
01A08:  BCLR.B  42.0
01A0A:  MUL.UU  W7,W4,W8
01A0C:  ADDC    W8,W3,W3
01A0E:  ADDC    W9,W1,W1
01A10:  MUL.UU  W5,W7,W8
01A12:  ADDC    W8,W1,W1
01A14:  INC     W0,W0
01A16:  CP0     W1
01A18:  BTSC.B  42.1
01A1A:  BRA     1A1E
01A1C:  BRA     1A24
01A1E:  CP0     W3
01A20:  BTSC.B  42.1
01A22:  BRA     1A2E
01A24:  BTSC    W1.F
01A26:  BRA     1A2E
01A28:  RLC     W3,W3
01A2A:  RLC     W1,W1
01A2C:  DEC     W0,W0
01A2E:  MOV     W1,W2
01A30:  BCLR.B  42.0
01A32:  BTSS    W3.7
01A34:  BRA     1A48
01A36:  MOV     #FF00,W7
01A38:  AND     W3,W7,W3
01A3A:  ADD     #100,W3
01A3C:  ADDC    W2,#0,W2
01A3E:  CP0     W2
01A40:  BRA     NZ,1A48
01A42:  CP0     W3
01A44:  BRA     NZ,1A48
01A46:  INC     W0,W0
01A48:  SWAP    W0
01A4A:  BCLR.B  42.0
01A4C:  BCLR.B  42.1
01A4E:  RRC     W0,W1
01A50:  BTSC    W10.F
01A52:  BSET    W1.F
01A54:  BCLR    W2.F
01A56:  SWAP    W2
01A58:  XOR.B   W2L,W1L,W1L
01A5A:  SWAP    W3
01A5C:  MOV.B   W3L,W2L
01A5E:  MOV     W2,W0
01A60:  BRA     1A68
01A62:  MOV     #0,W0
01A64:  MOV     #0,W1
01A66:  BRA     1A68
01A68:  MOV     #14,W5
01A6A:  REPEAT  #4
01A6C:  MOV     [--W15],[W5--]
01A6E:  MOV     [--W15],W5
01A70:  RETURN  
01A72:  MOV     W5,[W15++]
01A74:  MOV     #C,W5
01A76:  REPEAT  #3
01A78:  MOV     [W5++],[W15++]
01A7A:  CLR     W9
01A7C:  MOV     #8000,W8
01A7E:  BTSC.B  43.0
01A80:  XOR     W8,W3,W3
01A82:  CP0     W0
01A84:  BRA     NZ,1A8C
01A86:  MOV     #7FFF,W10
01A88:  AND     W1,W10,W10
01A8A:  BTSS.B  42.1
01A8C:  MOV     W1,W10
01A8E:  XOR     W3,W10,W11
01A90:  MOV     W1,W6
01A92:  MOV     W3,W7
01A94:  MOV     W3,W12
01A96:  BCLR.B  42.1
01A98:  BCLR.B  42.0
01A9A:  RLC     W6,W6
01A9C:  SWAP    W6
01A9E:  AND     #FF,W6
01AA0:  CP0     W6
01AA2:  BRA     Z,1BE6
01AA4:  BCLR.B  42.1
01AA6:  BCLR.B  42.0
01AA8:  RLC     W7,W7
01AAA:  SWAP    W7
01AAC:  AND     #FF,W7
01AAE:  CP0     W7
01AB0:  BRA     Z,1BF0
01AB2:  BCLR.B  42.1
01AB4:  BCLR.B  42.0
01AB6:  CP      W7,W6
01AB8:  BRA     Z,1BF2
01ABA:  BRA     N,1C02
01ABC:  BCLR    W9.0
01ABE:  BSET    W9.1
01AC0:  SUB     W7,W6,W8
01AC2:  MOV     W7,W6
01AC4:  AND     #FF,W1
01AC6:  BSET    W1.7
01AC8:  AND     #FF,W3
01ACA:  BSET    W3.7
01ACC:  MOV     #28,W7
01ACE:  CP      W7,W8
01AD0:  BRA     N,1AF4
01AD2:  BCLR.B  42.1
01AD4:  BCLR.B  42.0
01AD6:  RRC     W1,W1
01AD8:  RRC     W0,W0
01ADA:  DEC     W8,W8
01ADC:  BRA     NZ,1AD2
01ADE:  BRA     1AFA
01AE0:  MOV     #28,W7
01AE2:  CP      W7,W8
01AE4:  BRA     N,1AF8
01AE6:  BCLR.B  42.1
01AE8:  BCLR.B  42.0
01AEA:  RRC     W3,W3
01AEC:  RRC     W2,W2
01AEE:  DEC     W8,W8
01AF0:  BRA     NZ,1AE6
01AF2:  BRA     1B12
01AF4:  MOV     W2,W0
01AF6:  MOV     W3,W1
01AF8:  BRA     1B80
01AFA:  BTSS    W11.F
01AFC:  BRA     1B20
01AFE:  BTSC    W9.4
01B00:  MOV     W12,W11
01B02:  NEG     W0,W0
01B04:  BRA     Z,1B0A
01B06:  COM.B   W1L,W1L
01B08:  BRA     1B0C
01B0A:  NEG     W1,W1
01B0C:  BTSC    W9.4
01B0E:  BRA     1B66
01B10:  BRA     1B20
01B12:  BTSS    W11.F
01B14:  BRA     1B20
01B16:  NEG     W2,W2
01B18:  BRA     Z,1B1E
01B1A:  COM.B   W3L,W3L
01B1C:  BRA     1B20
01B1E:  NEG     W3,W3
01B20:  AND     #FF,W5
01B22:  BCLR.B  42.1
01B24:  BCLR.B  42.0
01B26:  ADD     W0,W2,W0
01B28:  ADDC.B  W1L,W3L,W1L
01B2A:  BTSC.B  42.0
01B2C:  BSET    W9.3
01B2E:  BTSC    W9.0
01B30:  BRA     1B44
01B32:  BTSC    W9.1
01B34:  BRA     1B38
01B36:  BRA     1B4E
01B38:  BTSC    W11.F
01B3A:  BRA     1B66
01B3C:  BTSC    W9.3
01B3E:  BRA     1B92
01B40:  BSET    W9.6
01B42:  BRA     1B80
01B44:  BTSC    W11.F
01B46:  BRA     1B66
01B48:  BTSC    W9.3
01B4A:  BRA     1B92
01B4C:  BRA     1B80
01B4E:  BCLR    W9.2
01B50:  BTSC    W11.F
01B52:  BRA     1B5C
01B54:  MOV     W10,W11
01B56:  BTSC    W9.3
01B58:  BRA     1B92
01B5A:  BRA     1BC8
01B5C:  BSET    W9.4
01B5E:  XOR.B   #80,W1L
01B60:  BTSC    W1.7
01B62:  BRA     1AFE
01B64:  MOV     W10,W11
01B66:  AND     #FF,W1
01B68:  IOR      W0,  W1,W7
01B6A:  BRA     Z,1B80
01B6C:  BTSC    W1.7
01B6E:  BRA     1B80
01B70:  BCLR.B  42.1
01B72:  BCLR.B  42.0
01B74:  RLC     W0,W0
01B76:  RLC     W1,W1
01B78:  DEC     W6,W6
01B7A:  BTSC.B  42.1
01B7C:  BRA     1BE0
01B7E:  BRA     1B6C
01B80:  BTSC    W9.0
01B82:  MOV     W10,W11
01B84:  BTSC    W9.1
01B86:  MOV     W12,W11
01B88:  BTSS    W9.5
01B8A:  BRA     1BC0
01B8C:  BTSC    W10.F
01B8E:  BSET    W0.8
01B90:  BRA     1BC8
01B92:  BSET.B  42.0
01B94:  RRC.B   W1L,W1L
01B96:  RRC     W0,W0
01B98:  BTSC.B  42.0
01B9A:  BSET    W9.5
01B9C:  INC     W6,W6
01B9E:  BRA     Z,1BE0
01BA0:  BTSS    W9.5
01BA2:  BRA     1BB4
01BA4:  INC     W0,W0
01BA6:  BRA     NZ,1BB4
01BA8:  INC.B   W1L,W1L
01BAA:  BRA     NZ,1BB4
01BAC:  RRC.B   W1L,W1L
01BAE:  RRC     W0,W0
01BB0:  INC     W6,W6
01BB2:  BRA     Z,1BE0
01BB4:  BTSC    W9.0
01BB6:  MOV     W10,W11
01BB8:  BTSC    W9.1
01BBA:  MOV     W12,W11
01BBC:  BTSC.B  42.1
01BBE:  BRA     1BE0
01BC0:  BTSC    W9.6
01BC2:  MOV     W10,W11
01BC4:  BTSC    W9.7
01BC6:  MOV     W12,W11
01BC8:  IOR      W0,  W1,W2
01BCA:  BRA     Z,1C12
01BCC:  BCLR    W1.7
01BCE:  SWAP    W6
01BD0:  BCLR.B  42.1
01BD2:  BCLR.B  42.0
01BD4:  RRC     W6,W6
01BD6:  XOR     W6,W1,W1
01BD8:  BSET    W1.F
01BDA:  BTSS    W11.F
01BDC:  BCLR    W1.F
01BDE:  BRA     1C12
01BE0:  MOV     #0,W0
01BE2:  MOV     #0,W1
01BE4:  BRA     1C12
01BE6:  BTSC    W10.F
01BE8:  XOR     W8,W3,W3
01BEA:  MOV     W2,W0
01BEC:  MOV     W3,W1
01BEE:  BRA     1C12
01BF0:  BRA     1C12
01BF2:  AND     #FF,W3
01BF4:  BSET    W3.7
01BF6:  AND     #FF,W1
01BF8:  BSET    W1.7
01BFA:  BTSC    W11.F
01BFC:  BCLR    W3.7
01BFE:  BSET    W9.2
01C00:  BRA     1B12
01C02:  SUB     W6,W7,W8
01C04:  AND     #FF,W1
01C06:  BSET    W1.7
01C08:  AND     #FF,W3
01C0A:  BSET    W3.7
01C0C:  BCLR    W9.1
01C0E:  BSET    W9.0
01C10:  BRA     1AE0
01C12:  MOV     #12,W5
01C14:  REPEAT  #3
01C16:  MOV     [--W15],[W5--]
01C18:  MOV     [--W15],W5
01C1A:  RETURN  
*
06536:  MOV     W8,[W15++]
06538:  MOV     #12,W8
0653A:  REPEAT  #4
0653C:  MOV     [W8++],[W15++]
0653E:  MOV     #8000,W8
06540:  BTSC.B  43.0
06542:  XOR     W8,W7,W7
06544:  CP0     W0
06546:  BRA     NZ,6556
06548:  CP0     W1
0654A:  BRA     NZ,6556
0654C:  CP0     W2
0654E:  BRA     NZ,6556
06550:  MOV     #7FFF,W10
06552:  AND     W3,W10,W10
06554:  BTSS.B  42.1
06556:  MOV     W3,W10
06558:  XOR     W7,W10,W11
0655A:  MOV     W3,W8
0655C:  MOV     W7,W9
0655E:  MOV     W7,W12
06560:  MOV     #7FF,W13
06562:  BCLR.B  42.1
06564:  BCLR.B  42.0
06566:  ASR     W8,#4,W8
06568:  AND     W13,W8,W8
0656A:  CP0     W8
0656C:  BRA     Z,66E6
0656E:  BCLR.B  42.1
06570:  BCLR.B  42.0
06572:  ASR     W9,#4,W9
06574:  AND     W13,W9,W9
06576:  CP0     W9
06578:  BRA     Z,66F6
0657A:  CLR     W13
0657C:  BCLR.B  42.1
0657E:  BCLR.B  42.0
06580:  CP      W9,W8
06582:  BRA     Z,66F8
06584:  BRA     N,6708
06586:  BCLR    W13.0
06588:  BSET    W13.1
0658A:  SUB     W9,W8,W8
0658C:  AND     #F,W3
0658E:  BSET    W3.4
06590:  AND     #F,W7
06592:  BSET    W7.4
06594:  SUB     #34,W8
06596:  BRA     NN,65C4
06598:  ADD     #34,W8
0659A:  BCLR.B  42.1
0659C:  BCLR.B  42.0
0659E:  RRC     W3,W3
065A0:  RRC     W2,W2
065A2:  RRC     W1,W1
065A4:  RRC     W0,W0
065A6:  DEC     W8,W8
065A8:  BRA     NZ,659A
065AA:  BRA     65D4
065AC:  SUB     #34,W8
065AE:  BRA     NN,65CE
065B0:  ADD     #34,W8
065B2:  BCLR.B  42.1
065B4:  BCLR.B  42.0
065B6:  RRC     W7,W7
065B8:  RRC     W6,W6
065BA:  RRC     W5,W5
065BC:  RRC     W4,W4
065BE:  DEC     W8,W8
065C0:  BRA     NZ,65B2
065C2:  BRA     65FA
065C4:  MOV     W4,W0
065C6:  MOV     W5,W1
065C8:  MOV     W6,W2
065CA:  MOV     W7,W3
065CC:  XOR     W11,W12,W12
065CE:  BTSC    W12.F
065D0:  BTG     W11.F
065D2:  BRA     66C6
065D4:  BTSS    W11.F
065D6:  BRA     6616
065D8:  BTSC    W13.4
065DA:  MOV     W12,W11
065DC:  COM     W0,W0
065DE:  COM     W1,W1
065E0:  COM     W2,W2
065E2:  COM.B   W3L,W3L
065E4:  AND.B   #1F,W3L
065E6:  INC     W0,W0
065E8:  BRA     NZ,65F4
065EA:  INC     W1,W1
065EC:  BRA     NZ,65F4
065EE:  INC     W2,W2
065F0:  BRA     NZ,65F4
065F2:  INC.B   W3L,W3L
065F4:  BTSC    W13.4
065F6:  BRA     665C
065F8:  BRA     6616
065FA:  BTSS    W11.F
065FC:  BRA     6616
065FE:  COM     W4,W4
06600:  COM     W5,W5
06602:  COM     W6,W6
06604:  COM.B   W7L,W7L
06606:  AND.B   #1F,W7L
06608:  INC     W4,W4
0660A:  BRA     NZ,6616
0660C:  INC     W5,W5
0660E:  BRA     NZ,6616
06610:  INC     W6,W6
06612:  BRA     NZ,6616
06614:  INC.B   W7L,W7L
06616:  BCLR.B  42.1
06618:  BCLR.B  42.0
0661A:  ADD     W0,W4,W0
0661C:  ADDC    W1,W5,W1
0661E:  ADDC    W2,W6,W2
06620:  ADDC.B  W3L,W7L,W3L
06622:  BTSC    W3.5
06624:  BSET    W13.3
06626:  BTSC    W13.0
06628:  BRA     663C
0662A:  BTSC    W13.1
0662C:  BRA     6630
0662E:  BRA     6646
06630:  BTSC    W11.F
06632:  BRA     665C
06634:  BTSC    W13.3
06636:  BRA     668A
06638:  BSET    W13.6
0663A:  BRA     667E
0663C:  BTSC    W11.F
0663E:  BRA     665C
06640:  BTSC    W13.3
06642:  BRA     668A
06644:  BRA     667E
06646:  BTSC    W11.F
06648:  BRA     6652
0664A:  MOV     W10,W11
0664C:  BTSC    W13.3
0664E:  BRA     668A
06650:  BRA     66C6
06652:  BSET    W13.4
06654:  XOR.B   #10,W3L
06656:  BTSC    W3.4
06658:  BRA     65D8
0665A:  MOV     W10,W11
0665C:  AND     #1F,W3
0665E:  IOR      W3,  W2,W8
06660:  BRA     NZ,6666
06662:  IOR      W1,  W0,W8
06664:  BRA     Z,667E
06666:  BTSC    W3.4
06668:  BRA     667E
0666A:  BCLR.B  42.1
0666C:  BCLR.B  42.0
0666E:  RLC     W0,W0
06670:  RLC     W1,W1
06672:  RLC     W2,W2
06674:  RLC     W3,W3
06676:  DEC     W9,W9
06678:  BTSC.B  42.1
0667A:  BRA     66E0
0667C:  BRA     6666
0667E:  BTSC    W13.0
06680:  MOV     W10,W11
06682:  BTSC    W13.1
06684:  MOV     W12,W11
06686:  BTSS    W13.5
06688:  BRA     66C6
0668A:  BCLR.B  42.0
0668C:  RRC.B   W3L,W3L
0668E:  RRC     W2,W2
06690:  RRC     W1,W1
06692:  RRC     W0,W0
06694:  BTSC.B  42.0
06696:  BSET    W13.5
06698:  INC     W9,W9
0669A:  BTSC.B  42.1
0669C:  BRA     66E0
0669E:  BTSS    W13.5
066A0:  BRA     66BE
066A2:  INC     W0,W0
066A4:  BRA     NZ,66BE
066A6:  INC     W1,W1
066A8:  BRA     NZ,66BE
066AA:  INC     W2,W2
066AC:  BRA     NZ,66BE
066AE:  INC     W3,W3
066B0:  BRA     NZ,66BE
066B2:  RRC.B   W3L,W3L
066B4:  RRC     W2,W2
066B6:  RRC     W1,W1
066B8:  RRC     W0,W0
066BA:  INC     W9,W9
066BC:  BRA     Z,66E0
066BE:  BTSC    W13.0
066C0:  MOV     W10,W11
066C2:  BTSC    W13.1
066C4:  MOV     W12,W11
066C6:  IOR      W0,  W1,W4
066C8:  BRA     NZ,66CE
066CA:  IOR      W2,  W3,W4
066CC:  BRA     Z,671A
066CE:  BCLR    W3.4
066D0:  BCLR.B  42.1
066D2:  BCLR.B  42.0
066D4:  SL      W9,#4,W9
066D6:  XOR     W9,W3,W3
066D8:  BSET    W3.F
066DA:  BTSS    W11.F
066DC:  BCLR    W3.F
066DE:  BRA     671A
066E0:  MUL.UU  W0,#0,W0
066E2:  MUL.UU  W2,#0,W2
066E4:  BRA     671A
066E6:  MOV     #8000,W8
066E8:  BTSC    W10.F
066EA:  XOR     W8,W7,W7
066EC:  MOV     W5,W1
066EE:  MOV     W4,W0
066F0:  MOV     W6,W2
066F2:  MOV     W7,W3
066F4:  BRA     671A
066F6:  BRA     671A
066F8:  AND     #F,W7
066FA:  BSET    W7.4
066FC:  AND     #F,W3
066FE:  BSET    W3.4
06700:  BTSC    W11.F
06702:  BCLR    W7.4
06704:  BSET    W13.2
06706:  BRA     65FA
06708:  AND     #F,W3
0670A:  BSET    W3.4
0670C:  AND     #F,W7
0670E:  BSET    W7.4
06710:  SUB     W8,W9,W8
06712:  ADD     W8,W9,W9
06714:  BCLR    W13.1
06716:  BSET    W13.0
06718:  BRA     65AC
0671A:  MOV     #1A,W8
0671C:  REPEAT  #4
0671E:  MOV     [--W15],[W8--]
06720:  MOV     [--W15],W8
06722:  RETURN  
06724:  MOV     W8,[W15++]
06726:  MOV     W9,[W15++]
06728:  MOV     W10,[W15++]
0672A:  XOR     W3,W7,W9
0672C:  BTSS    W9.F
0672E:  BRA     673C
06730:  BCLR.B  42.0
06732:  BCLR.B  42.1
06734:  BTSS    W3.F
06736:  BRA     67A0
06738:  BSET.B  42.0
0673A:  BRA     67A0
0673C:  MOV     #7FF,W10
0673E:  MOV     W3,W8
06740:  MOV     W7,W9
06742:  ASR     W8,#4,W8
06744:  AND     W10,W8,W8
06746:  ASR     W9,#4,W9
06748:  AND     W10,W9,W9
0674A:  SUB     W9,W8,W10
0674C:  BRA     Z,6758
0674E:  BTSS    W3.F
06750:  BRA     67A0
06752:  MOV     #1,W0
06754:  XOR.B   42
06756:  BRA     67A0
06758:  MOV     W3,W8
0675A:  MOV     W7,W9
0675C:  AND     #1F,W3
0675E:  AND     #1F,W7
06760:  BCLR    W3.4
06762:  BCLR    W7.4
06764:  SUB.B   W7L,W3L,W10L
06766:  BRA     Z,6772
06768:  BTSS    W8.F
0676A:  BRA     67A0
0676C:  MOV     #1,W0
0676E:  XOR.B   42
06770:  BRA     67A0
06772:  SUB     W6,W2,W10
06774:  BRA     Z,6780
06776:  BTSS    W8.F
06778:  BRA     67A0
0677A:  MOV     #1,W0
0677C:  XOR.B   42
0677E:  BRA     67A0
06780:  SUB     W5,W1,W10
06782:  BRA     Z,678E
06784:  BTSS    W8.F
06786:  BRA     67A0
06788:  MOV     #1,W0
0678A:  XOR.B   42
0678C:  BRA     67A0
0678E:  SUB     W4,W0,W10
06790:  BRA     Z,679C
06792:  BTSS    W8.F
06794:  BRA     67A0
06796:  MOV     #1,W0
06798:  XOR.B   42
0679A:  BRA     67A0
0679C:  BCLR.B  42.0
0679E:  BRA     67A0
067A0:  MOV     [--W15],W10
067A2:  MOV     [--W15],W9
067A4:  MOV     [--W15],W8
067A6:  RETURN  
067A8:  MOV     W5,[W15++]
067AA:  MOV     W6,[W15++]
067AC:  MOV     W3,W4
067AE:  MOV     W3,W6
067B0:  BCLR.B  42.0
067B2:  ASR     W4,#4,W4
067B4:  MOV     #7FF,W5
067B6:  AND     W5,W4,W4
067B8:  BRA     NZ,67C0
067BA:  MUL.UU  W0,#0,W0
067BC:  CLR     W2
067BE:  BRA     67E6
067C0:  SUB     #380,W4
067C2:  AND     #F,W3
067C4:  MOV     #3,W7
067C6:  BCLR.B  42.0
067C8:  RLC     W0,W0
067CA:  RLC     W1,W1
067CC:  RLC     W2,W2
067CE:  RLC     W3,W3
067D0:  DEC     W7,W7
067D2:  BRA     NZ,67C6
067D4:  MOV     W1,W0
067D6:  MOV     W2,W1
067D8:  BCLR    W3.7
067DA:  SWAP    W4
067DC:  BCLR.B  42.0
067DE:  RRC     W4,W4
067E0:  BTSC    W6.F
067E2:  BSET    W4.F
067E4:  XOR     W4,W3,W2
067E6:  MOV     [--W15],W6
067E8:  MOV     [--W15],W5
067EA:  RETURN  
067EC:  MOV     W5,[W15++]
067EE:  MOV     W1,W5
067F0:  MOV     W0,W2
067F2:  MOV     #B6,W4
067F4:  RLC     W1,W1
067F6:  SWAP    W1
067F8:  AND     #FF,W1
067FA:  SUB.B   W4L,W1L,W4L
067FC:  MOV.B   W5L,W3L
067FE:  BSET    W3.7
06800:  AND     #FF,W3
06802:  CLR     W0
06804:  CLR     W1
06806:  CP      W4,#1F
06808:  BRA     N,6828
0680A:  BCLR.B  42.0
0680C:  RRC     W3,W3
0680E:  RRC     W2,W2
06810:  RRC     W1,W1
06812:  RRC     W0,W0
06814:  DEC     W4,W4
06816:  BRA     NZ,680A
06818:  BTSS    W5.F
0681A:  BRA     6828
0681C:  NEG     W0,W0
0681E:  BRA     Z,6824
06820:  COM     W1,W1
06822:  BRA     6828
06824:  NEG     W1,W1
06826:  BRA     6828
06828:  MOV     [--W15],W5
0682A:  RETURN  
*
06888:  MOV     W5,[W15++]
0688A:  MOV     #C,W5
0688C:  REPEAT  #3
0688E:  MOV     [W5++],[W15++]
06890:  MOV     W0,W7
06892:  MOV     W4,W9
06894:  BCLR    W4.F
06896:  CP0     W4
06898:  BRA     NZ,68A6
0689A:  BTSC    W9.F
0689C:  BRA     68A2
0689E:  MOV     #0,W5
068A0:  BRA     68C0
068A2:  MOV     #0,W5
068A4:  BRA     68C0
068A6:  SUB.B   W4L,#6,W5L
068A8:  BRA     NC,68BE
068AA:  MOV     #30,W0
068AC:  BTSS    W9.F
068AE:  MOV     #20,W0
068B0:  BTSC.B  219.1
068B2:  BRA     68B0
068B4:  MOV     W0,21A
068B6:  DEC     W5,W5
068B8:  BRA     NN,68B0
068BA:  MOV     #5,W5
068BC:  BRA     68C0
068BE:  MOV     W4,W5
068C0:  MOV     #6,W4
068C2:  BSET    W5.E
068C4:  BTSC    W9.F
068C6:  BSET    W5.F
068C8:  MOV     #2710,W8
068CA:  REPEAT  #11
068CC:  DIV.U   W7,W8
068CE:  CALL    6902
068D2:  MOV     W1,W7
068D4:  MOV     #3E8,W8
068D6:  REPEAT  #11
068D8:  DIV.U   W7,W8
068DA:  CALL    6902
068DE:  MOV     W1,W7
068E0:  MOV     #64,W8
068E2:  REPEAT  #11
068E4:  DIV.U   W7,W8
068E6:  CALL    6902
068EA:  MOV     W1,W7
068EC:  MOV     #A,W8
068EE:  REPEAT  #11
068F0:  DIV.U   W7,W8
068F2:  CALL    6902
068F6:  MOV     #30,W0
068F8:  ADD.B   W1L,W0L,W0L
068FA:  BTSC.B  219.1
068FC:  BRA     68FA
068FE:  MOV     W0,21A
06900:  BRA     6930
06902:  MOV     #30,W6
06904:  CP0     W0
06906:  BRA     NZ,6924
06908:  BTSS    W5.E
0690A:  BRA     6926
0690C:  DEC     W4,W4
0690E:  CP.B    W4L,W5L
06910:  BRA     Z,6916
06912:  BTSC.B  42.0
06914:  RETURN  
06916:  CP0     W0
06918:  BRA     NZ,6924
0691A:  BTSS    W5.E
0691C:  BRA     6926
0691E:  BTSS    W5.F
06920:  MOV     #20,W6
06922:  BRA     6926
06924:  BCLR    W5.E
06926:  ADD.B   W6L,W0L,W0L
06928:  BTSC.B  219.1
0692A:  BRA     6928
0692C:  MOV     W0,21A
0692E:  RETURN  
06930:  MOV     #12,W5
06932:  REPEAT  #3
06934:  MOV     [--W15],[W5--]
06936:  MOV     [--W15],W5
06938:  RETURN  
0693A:  MOV     W6,[W15++]
0693C:  MOV     W7,[W15++]
0693E:  MOV     W8,[W15++]
06940:  MOV     W9,[W15++]
06942:  CLR     W4
06944:  CLR     W5
06946:  CLR     W6
06948:  CLR     W7
0694A:  XOR     W2,W3,W8
0694C:  BRA     Z,6970
0694E:  MOV     #20,W8
06950:  BCLR.B  42.0
06952:  RLC     W0,W0
06954:  RLC     W1,W1
06956:  RLC     W4,W4
06958:  RLC     W5,W5
0695A:  CP      W5,W3
0695C:  BRA     NZ,6960
0695E:  CPB     W4,W2
06960:  BRA     NC,6968
06962:  SUB     W4,W2,W4
06964:  SUBB    W5,W3,W5
06966:  BSET.B  42.0
06968:  RLC     W6,W6
0696A:  RLC     W7,W7
0696C:  DEC     W8,W8
0696E:  BRA     NZ,6950
06970:  MOV     W7,W1
06972:  MOV     W6,W0
06974:  MOV     [--W15],W9
06976:  MOV     [--W15],W8
06978:  MOV     [--W15],W7
0697A:  MOV     [--W15],W6
0697C:  RETURN  
0697E:  MOV     W5,[W15++]
06980:  MOV     #C,W5
06982:  REPEAT  #7
06984:  MOV     [W5++],[W15++]
06986:  BTSS    W1.F
06988:  BRA     6998
0698A:  NEG     W0,W0
0698C:  BRA     Z,6990
0698E:  BRA     NZ,6994
06990:  NEG     W1,W1
06992:  BRA     6996
06994:  COM     W1,W1
06996:  BSET    W4.8
06998:  CLR     W5
0699A:  MOV     W0,W6
0699C:  MOV     W1,W7
0699E:  MOV     W4,W12
069A0:  BCLR    W4.F
069A2:  CP0.B   W4L
069A4:  BRA     NZ,69A8
069A6:  BRA     69D8
069A8:  SUB.B   W4L,#B,W5L
069AA:  BRA     NC,69D8
069AC:  SUB.B   W4L,W5L,W4L
069AE:  BTSS    W12.F
069B0:  BRA     69C8
069B2:  BTSS    W4.8
069B4:  BRA     69C4
069B6:  MOV     #2D,W0
069B8:  BTSC.B  219.1
069BA:  BRA     69B8
069BC:  MOV     W0,21A
069BE:  BCLR    W4.8
069C0:  DEC     W5,W5
069C2:  BRA     N,69D8
069C4:  MOV     #30,W0
069C6:  BRA     69CA
069C8:  MOV     #20,W0
069CA:  BTSC.B  219.1
069CC:  BRA     69CA
069CE:  MOV     W0,21A
069D0:  DEC     W5,W5
069D2:  BRA     NN,69CA
069D4:  BTSC    W4.8
069D6:  DEC.B   W4L,W4L
069D8:  MOV     #E,W8
069DA:  MOV     #0,W9
069DC:  LNK     #10
069DE:  MOV     W12,[W14+W8]
069E0:  DEC2    W8,W8
069E2:  BRA     NN,69DE
069E4:  MOV     W4,W5
069E6:  MOV     #A,W4
069E8:  BTSC    W5.8
069EA:  INC     W4,W4
069EC:  BSET    W5.E
069EE:  BTSC    W12.F
069F0:  BSET    W5.F
069F2:  CP0.B   W5L
069F4:  BRA     Z,69F8
069F6:  DEC.B   W5L,W5L
069F8:  MOV     W4,[W14]
069FA:  MOV     W5,[W14+#2]
069FC:  MOV     W6,W0
069FE:  MOV     W7,W1
06A00:  MOV     #CA00,W2
06A02:  MOV     #3B9A,W3
06A04:  MOV     #2710,W8
06A06:  BCLR    W13.F
06A08:  BCLR.B  43.0
06A0A:  CALL    693A
06A0E:  BTG     W13.F
06A10:  BTSC    W13.F
06A12:  BRA     6A22
06A14:  MOV     W0,[W14+#8]
06A16:  MOV     W1,[W14+#A]
06A18:  MOV     W0,W2
06A1A:  MOV     W1,W3
06A1C:  MOV     [W14+#4],W0
06A1E:  MOV     [W14+#6],W1
06A20:  BRA     6A08
06A22:  MOV     W2,[W14+#8]
06A24:  MOV     W3,[W14+#A]
06A26:  MOV     W4,[W14+#4]
06A28:  MOV     W5,[W14+#6]
06A2A:  MOV     [W14],W4
06A2C:  MOV     [W14+#2],W5
06A2E:  MOV     #30,W6
06A30:  CP0     W0
06A32:  BRA     NZ,6A56
06A34:  BTSS    W5.E
06A36:  BRA     6A5A
06A38:  DEC     W4,W4
06A3A:  MOV     W4,[W14]
06A3C:  CP0     W4
06A3E:  BRA     Z,6A5A
06A40:  CP.B    W4L,W5L
06A42:  BRA     Z,6A48
06A44:  BTSC.B  42.0
06A46:  BRA     6A78
06A48:  BTSS    W5.F
06A4A:  BRA     6A52
06A4C:  BTSS    W5.8
06A4E:  BRA     6A70
06A50:  BRA     6A60
06A52:  MOV     #20,W6
06A54:  BRA     6A70
06A56:  BCLR    W5.E
06A58:  MOV     W5,[W14+#2]
06A5A:  MOV     [W14+#2],W5
06A5C:  BTSS    W5.8
06A5E:  BRA     6A70
06A60:  BCLR    W5.8
06A62:  MOV     W5,[W14+#2]
06A64:  MOV     W0,W10
06A66:  MOV     #2D,W0
06A68:  BTSC.B  219.1
06A6A:  BRA     6A68
06A6C:  MOV     W0,21A
06A6E:  MOV     W10,W0
06A70:  ADD.B   W6L,W0L,W0L
06A72:  BTSC.B  219.1
06A74:  BRA     6A72
06A76:  MOV     W0,21A
06A78:  MOV     [W14+#8],W0
06A7A:  MOV     [W14+#A],W1
06A7C:  MOV     #A,W2
06A7E:  CLR     W3
06A80:  CP      W0,#1
06A82:  BRA     Z,6A86
06A84:  BRA     6A08
06A86:  ULNK    
06A88:  MOV     #1A,W5
06A8A:  REPEAT  #7
06A8C:  MOV     [--W15],[W5--]
06A8E:  MOV     [--W15],W5
06A90:  RETURN  
*
06EF4:  MOV     W5,[W15++]
06EF6:  MOV     #C,W5
06EF8:  REPEAT  #5
06EFA:  MOV     [W5++],[W15++]
06EFC:  MOV     W3,W8
06EFE:  MOV     W2,W7
06F00:  MOV     W1,W6
06F02:  MOV     W0,W5
06F04:  MOV     W3,W9
06F06:  MOV     #473,W11
06F08:  ASR     W3,#4,W3
06F0A:  MOV     #7FF,W10
06F0C:  AND     W10,W3,W3
06F0E:  SUB     W11,W3,W11
06F10:  AND     #1F,W8
06F12:  BSET    W8.4
06F14:  CLR     W0
06F16:  CLR     W1
06F18:  CLR     W2
06F1A:  CLR     W3
06F1C:  BCLR.B  42.0
06F1E:  RRC     W8,W8
06F20:  RRC     W7,W7
06F22:  RRC     W6,W6
06F24:  RRC     W5,W5
06F26:  RRC     W3,W3
06F28:  RRC     W2,W2
06F2A:  RRC     W1,W1
06F2C:  RRC     W0,W0
06F2E:  DEC     W11,W11
06F30:  BRA     NZ,6F1C
06F32:  BTSS    W9.F
06F34:  BRA     6F40
06F36:  NEG     W0,W0
06F38:  COM     W1,W1
06F3A:  COM     W2,W2
06F3C:  COM     W3,W3
06F3E:  BRA     6F40
06F40:  MOV     #16,W5
06F42:  REPEAT  #5
06F44:  MOV     [--W15],[W5--]
06F46:  MOV     [--W15],W5
06F48:  RETURN  
*
07E54:  MOV     W5,[W15++]
07E56:  MOV     W2,W3
07E58:  MOV     W2,W5
07E5A:  BCLR.B  42.0
07E5C:  RLC     W3,W3
07E5E:  SWAP    W3
07E60:  AND     #FF,W3
07E62:  BRA     NZ,7E6A
07E64:  MUL.UU  W0,#0,W0
07E66:  MUL.UU  W2,#0,W2
07E68:  BRA     7E96
07E6A:  ADD     #380,W3
07E6C:  AND     #7F,W2
07E6E:  MOV     #3,W6
07E70:  CLR     W4
07E72:  BCLR.B  42.0
07E74:  RRC     W2,W2
07E76:  RRC     W1,W1
07E78:  RRC     W0,W0
07E7A:  BTSC.B  42.0
07E7C:  INC     W4,W4
07E7E:  DEC     W6,W6
07E80:  BRA     NZ,7E72
07E82:  BCLR    W2.7
07E84:  SL      W3,#4,W3
07E86:  BCLR    W3.F
07E88:  BTSC    W5.F
07E8A:  BSET    W3.F
07E8C:  XOR     W2,W3,W3
07E8E:  MOV     W1,W2
07E90:  MOV     W0,W1
07E92:  ADD     W4,W1,W1
07E94:  CLR     W0
07E96:  MOV     [--W15],W5
07E98:  RETURN  
07E9A:  MOV     W12,[W15++]
07E9C:  MOV     W13,[W15++]
07E9E:  CLR     W8
07EA0:  CLR     W9
07EA2:  CLR     W10
07EA4:  CLR     W11
07EA6:  CLR     W12
07EA8:  CLR     W13
07EAA:  MOV     #E,W8
07EAC:  MOV     #0,W9
07EAE:  LNK     #10
07EB0:  MOV     W12,[W14+W8]
07EB2:  DEC2    W8,W8
07EB4:  BRA     NN,7EB0
07EB6:  XOR     W4,W5,W8
07EB8:  BRA     NZ,7EBE
07EBA:  XOR     W6,W7,W8
07EBC:  BRA     Z,7F1C
07EBE:  CLR     W8
07EC0:  MOV     #40,W13
07EC2:  MOV     #40,W13
07EC4:  BCLR.B  42.0
07EC6:  RLC     W0,W0
07EC8:  RLC     W1,W1
07ECA:  RLC     W2,W2
07ECC:  RLC     W3,W3
07ECE:  RLC     W8,W8
07ED0:  RLC     W9,W9
07ED2:  RLC     W10,W10
07ED4:  RLC     W11,W11
07ED6:  CP      W11,W7
07ED8:  BRA     NZ,7EE4
07EDA:  CPB     W10,W6
07EDC:  BRA     NZ,7EE4
07EDE:  CPB     W9,W5
07EE0:  BRA     NZ,7EE4
07EE2:  CPB     W8,W4
07EE4:  BRA     NC,7EF0
07EE6:  SUB     W8,W4,W8
07EE8:  SUBB    W9,W5,W9
07EEA:  SUBB    W10,W6,W10
07EEC:  SUBB    W11,W7,W11
07EEE:  BSET.B  42.0
07EF0:  MOV     W8,[W14]
07EF2:  MOV     W9,[W14+#2]
07EF4:  MOV     W10,[W14+#4]
07EF6:  MOV     W11,[W14+#6]
07EF8:  MOV     [W14+#8],W8
07EFA:  MOV     [W14+#A],W9
07EFC:  MOV     [W14+#C],W10
07EFE:  MOV     [W14+#E],W11
07F00:  RLC     W8,W8
07F02:  RLC     W9,W9
07F04:  RLC     W10,W10
07F06:  RLC     W11,W11
07F08:  MOV     W8,[W14+#8]
07F0A:  MOV     W9,[W14+#A]
07F0C:  MOV     W10,[W14+#C]
07F0E:  MOV     W11,[W14+#E]
07F10:  MOV     [W14],W8
07F12:  MOV     [W14+#2],W9
07F14:  MOV     [W14+#4],W10
07F16:  MOV     [W14+#6],W11
07F18:  DEC     W13,W13
07F1A:  BRA     NZ,7EC4
07F1C:  MOV     [W14+#8],W0
07F1E:  MOV     [W14+#A],W1
07F20:  MOV     [W14+#C],W2
07F22:  MOV     [W14+#E],W3
07F24:  ULNK    
07F26:  BRA     7F28
07F28:  MOV     [--W15],W13
07F2A:  MOV     [--W15],W12
07F2C:  RETURN  
07F2E:  MOV     W5,[W15++]
07F30:  MOV     #C,W5
07F32:  REPEAT  #5
07F34:  MOV     [W5++],[W15++]
07F36:  BTSS    W3.F
07F38:  BRA     7F4A
07F3A:  COM     W1,W1
07F3C:  COM     W2,W2
07F3E:  COM     W3,W3
07F40:  NEG     W0,W0
07F42:  ADDC    W1,#0,W1
07F44:  ADDC    W2,#0,W2
07F46:  ADDC    W3,#0,W3
07F48:  BSET    W4.8
07F4A:  MOV     W0,W6
07F4C:  MOV     W4,W12
07F4E:  BCLR    W4.F
07F50:  CP0     W4
07F52:  BRA     NZ,7F56
07F54:  BRA     7F86
07F56:  SUB.B   W4L,#14,W5L
07F58:  BRA     NC,7F86
07F5A:  SUB.B   W4L,W5L,W4L
07F5C:  BTSS    W12.F
07F5E:  BRA     7F76
07F60:  BTSS    W4.8
07F62:  BRA     7F72
07F64:  MOV     #2D,W0
07F66:  BTSC.B  219.1
07F68:  BRA     7F66
07F6A:  MOV     W0,21A
07F6C:  BCLR    W4.8
07F6E:  DEC     W5,W5
07F70:  BRA     N,7F86
07F72:  MOV     #30,W0
07F74:  BRA     7F78
07F76:  MOV     #20,W0
07F78:  BTSC.B  219.1
07F7A:  BRA     7F78
07F7C:  MOV     W0,21A
07F7E:  DEC     W5,W5
07F80:  BRA     NN,7F78
07F82:  BTSC    W4.8
07F84:  DEC.B   W4L,W4L
07F86:  MOV     #E,W8
07F88:  MOV     #0,W9
07F8A:  LNK     #16
07F8C:  MOV     W12,[W14+W8]
07F8E:  DEC2    W8,W8
07F90:  BRA     NN,7F8C
07F92:  MOV     W4,W5
07F94:  MOV     #13,W4
07F96:  BTSC    W5.8
07F98:  INC     W4,W4
07F9A:  BSET    W5.E
07F9C:  BTSC    W12.F
07F9E:  BSET    W5.F
07FA0:  CP0.B   W5L
07FA2:  BRA     Z,7FA6
07FA4:  DEC.B   W5L,W5L
07FA6:  MOV     W4,[W14]
07FA8:  MOV     W5,[W14+#2]
07FAA:  MOV     W6,W0
07FAC:  CLR     W4
07FAE:  MOV     #A764,W5
07FB0:  MOV     #B6B3,W6
07FB2:  MOV     #DE0,W7
07FB4:  BCLR    W13.F
07FB6:  MOV     W13,[W14+#14]
07FB8:  CALL    7E9A
07FBC:  MOV     [W14+#14],W13
07FBE:  BTG     W13.F
07FC0:  MOV     W13,[W14+#14]
07FC2:  BTSC    W13.F
07FC4:  BRA     7FE0
07FC6:  MOV     W0,[W14+#C]
07FC8:  MOV     W1,[W14+#E]
07FCA:  MOV     W2,[W14+#10]
07FCC:  MOV     W3,[W14+#12]
07FCE:  MOV     W0,W4
07FD0:  MOV     W1,W5
07FD2:  MOV     W2,W6
07FD4:  MOV     W3,W7
07FD6:  MOV     [W14+#4],W0
07FD8:  MOV     [W14+#6],W1
07FDA:  MOV     [W14+#8],W2
07FDC:  MOV     [W14+#A],W3
07FDE:  BRA     7FB8
07FE0:  MOV     W4,[W14+#C]
07FE2:  MOV     W5,[W14+#E]
07FE4:  MOV     W6,[W14+#10]
07FE6:  MOV     W7,[W14+#12]
07FE8:  MOV     W8,[W14+#4]
07FEA:  MOV     W9,[W14+#6]
07FEC:  MOV     W10,[W14+#8]
07FEE:  MOV     W11,[W14+#A]
07FF0:  MOV     [W14],W4
07FF2:  MOV     [W14+#2],W5
07FF4:  MOV     #30,W6
07FF6:  CP0     W0
07FF8:  BRA     NZ,801C
07FFA:  BTSS    W5.E
07FFC:  BRA     8020
07FFE:  DEC     W4,W4
08000:  MOV     W4,[W14]
08002:  CP0     W4
08004:  BRA     Z,8020
08006:  CP.B    W4L,W5L
08008:  BRA     Z,800E
0800A:  BTSC.B  42.0
0800C:  BRA     803C
0800E:  BTSS    W5.F
08010:  BRA     8018
08012:  BTSS    W5.8
08014:  BRA     8034
08016:  BRA     8024
08018:  MOV     #20,W6
0801A:  BRA     8034
0801C:  BCLR    W5.E
0801E:  MOV     W5,[W14+#2]
08020:  BTSS    W5.8
08022:  BRA     8034
08024:  BCLR    W5.8
08026:  MOV     W5,[W14+#2]
08028:  MOV     W0,W10
0802A:  MOV     #2D,W0
0802C:  BTSC.B  219.1
0802E:  BRA     802C
08030:  MOV     W0,21A
08032:  MOV     W10,W0
08034:  ADD.B   W6L,W0L,W0L
08036:  BTSC.B  219.1
08038:  BRA     8036
0803A:  MOV     W0,21A
0803C:  MOV     [W14+#C],W0
0803E:  MOV     [W14+#E],W1
08040:  MOV     [W14+#10],W2
08042:  MOV     [W14+#12],W3
08044:  MOV     #A,W4
08046:  CLR     W5
08048:  MUL.UU  W6,#0,W6
0804A:  CP      W0,#1
0804C:  BRA     Z,8050
0804E:  BRA     7FB8
08050:  ULNK    
08052:  MOV     #16,W5
08054:  REPEAT  #5
08056:  MOV     [--W15],[W5--]
08058:  MOV     [--W15],W5
0805A:  RETURN  
0805C:  MOV     W5,[W15++]
0805E:  MOV     #C,W5
08060:  REPEAT  #3
08062:  MOV     [W5++],[W15++]
08064:  MOV     W0,W4
08066:  MOV     W1,W5
08068:  MOV     W2,W6
0806A:  MOV     W3,W7
0806C:  CLR     W0
0806E:  CLR     W1
08070:  CLR     W2
08072:  CLR     W3
08074:  BCLR    W8.0
08076:  BTSS    W7.F
08078:  BRA     8084
0807A:  BSET    W8.0
0807C:  NEG     W4,W4
0807E:  COM     W5,W5
08080:  COM     W6,W6
08082:  COM     W7,W7
08084:  IOR      W4,  W5,W9
08086:  BRA     NZ,808C
08088:  IOR      W6,  W7,W9
0808A:  BRA     Z,80B6
0808C:  MOV     #473,W9
0808E:  BTSC    W3.4
08090:  BRA     80A8
08092:  BCLR.B  42.0
08094:  RLC     W4,W4
08096:  RLC     W5,W5
08098:  RLC     W6,W6
0809A:  RLC     W7,W7
0809C:  RLC     W0,W0
0809E:  RLC     W1,W1
080A0:  RLC     W2,W2
080A2:  RLC     W3,W3
080A4:  DEC     W9,W9
080A6:  BRA     NZ,808E
080A8:  SL      W9,#4,W9
080AA:  BCLR.B  42.0
080AC:  BCLR    W9.F
080AE:  BCLR    W3.4
080B0:  XOR     W9,W3,W3
080B2:  BTSC    W8.0
080B4:  BSET    W3.F
080B6:  MOV     #12,W5
080B8:  REPEAT  #3
080BA:  MOV     [--W15],[W5--]
080BC:  MOV     [--W15],W5
080BE:  RETURN  
*
08170:  MOV     W5,[W15++]
08172:  MOV     #C,W5
08174:  REPEAT  #5
08176:  MOV     [W5++],[W15++]
08178:  MOV     W3,W8
0817A:  MOV     W2,W7
0817C:  MOV     W1,W6
0817E:  MOV     W0,W5
08180:  MOV     W3,W9
08182:  MOV     #473,W11
08184:  ASR     W3,#4,W3
08186:  MOV     #7FF,W10
08188:  AND     W10,W3,W3
0818A:  SUB     W11,W3,W11
0818C:  AND     #1F,W8
0818E:  BSET    W8.4
08190:  CLR     W0
08192:  CLR     W1
08194:  CLR     W2
08196:  CLR     W3
08198:  BCLR.B  42.0
0819A:  RRC     W8,W8
0819C:  RRC     W7,W7
0819E:  RRC     W6,W6
081A0:  RRC     W5,W5
081A2:  RRC     W3,W3
081A4:  RRC     W2,W2
081A6:  RRC     W1,W1
081A8:  RRC     W0,W0
081AA:  DEC     W11,W11
081AC:  BRA     NZ,8198
081AE:  BTSS    W9.F
081B0:  BRA     81BC
081B2:  NEG     W0,W0
081B4:  COM     W1,W1
081B6:  COM     W2,W2
081B8:  COM     W3,W3
081BA:  BRA     81BC
081BC:  MOV     #16,W5
081BE:  REPEAT  #5
081C0:  MOV     [--W15],[W5--]
081C2:  MOV     [--W15],W5
081C4:  RETURN  
*
08FD4:  PUSH    42
08FD6:  MOV     W0,[W15++]
08FD8:  BCLR.B  81.7
08FDA:  MOV     42,W4
08FDC:  IOR     #E0,W4
08FDE:  MOV     W4,42
08FE0:  BSET.B  81.7
08FE2:  MOV     W1,760
08FE4:  MOV     #55,W4
08FE6:  MOV     W4,766
08FE8:  MOV     #AA,W4
08FEA:  MOV     W4,766
08FEC:  BSET.B  761.7
08FEE:  NOP     
08FF0:  NOP     
08FF2:  BTSC.B  761.7
08FF4:  BRA     8FF2
08FF6:  MOV     [--W15],W0
08FF8:  BCLR.B  81.7
08FFA:  POP     42
08FFC:  BSET.B  81.7
08FFE:  RETURN  
09000:  MOV     W1,[W15++]
09002:  MOV     #F000,W1
09004:  ADD     W1,W0,W0
09006:  CLR     W1
09008:  MOV     #7F,W1
0900A:  ADDC    W1,#0,W1
0900C:  MOV     W1,32
0900E:  MOV     [--W15],W1
09010:  BCLR    W2.0
09012:  CP0     W2
09014:  BRA     Z,9038
09016:  TBLWTL  [W1],[W0]
09018:  MOV     W1,[W15++]
0901A:  MOV     #4044,W1
0901C:  CALL    8FD4
09020:  MOV     [--W15],W1
09022:  TBLWTL  [W1++],[W0]
09024:  INC2    W0,W0
09026:  BRA     NZ,902A
09028:  INC     0032
0902A:  MOV     W1,[W15++]
0902C:  MOV     #4004,W1
0902E:  CALL    8FD4
09032:  MOV     [--W15],W1
09034:  DEC2    W2,W2
09036:  BRA     NZ,9016
09038:  RETURN  
....................  
.................... #list 
....................  
.................... #include "DSPIC30F_registers.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... #word WREG0 = 0x000 
.................... #word WREG1 = 0x002 
.................... #word WREG2 = 0x004 
.................... #word WREG3 = 0x006 
.................... #word WREG4 = 0x008 
.................... #word WREG5 = 0x00A 
.................... #word WREG6 = 0x00C 
.................... #word WREG7 = 0x00E 
.................... #word WREG8 = 0x010 
.................... #word WREG9 = 0x012 
.................... #word WREG10 = 0x014 
.................... #word WREG11 = 0x016 
.................... #word WREG12 = 0x018 
.................... #word WREG13 = 0x01A 
.................... #word WREG14 = 0x01C 
.................... #word WREG15 = 0x01E 
.................... #word SPLIM = 0x020 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x022 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x024 
.................... #word ACCAU = 0x026 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x028 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x02A 
.................... #word ACCBU = 0x02C 
.................... #word PC = 0x02E 
.................... #word PCH = 0x02E 
.................... #word PC = 0x02E 
.................... #word PCH = 0x030 
.................... #word TBLPAG = 0x032 
.................... #word PSVPAG = 0x034 
.................... #word RCOUNT = 0x036 
.................... #word DCOUNT = 0x038 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03A 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03C 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x03E 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x040 
.................... #word SR = 0x042 
.................... #word CORCON = 0x044 
.................... #word MODCON = 0x046 
.................... #word XMODSRT = 0x048 
.................... #word XMODEND = 0x04A 
.................... #word YMODSRT = 0x04C 
.................... #word YMODEND = 0x04E 
.................... #word XBREV = 0x050 
.................... #word DISICNT = 0x052 
.................... #word INTCON1 = 0x080 
.................... #word INTCON2 = 0x082 
.................... #word IFS0 = 0x084 
.................... #word IFS1 = 0x086 
.................... #word IFS2 = 0x088 
.................... #word IEC0 = 0x08C 
.................... #word IEC1 = 0x08E 
.................... #word IEC2 = 0x090 
.................... #word IPC0 = 0x094 
.................... #word IPC1 = 0x096 
.................... #word IPC2 = 0x098 
.................... #word IPC3 = 0x09A 
.................... #word IPC4 = 0x09C 
.................... #word IPC5 = 0x09E 
.................... #word IPC6 = 0x0A0 
.................... #word IPC7 = 0x0A2 
.................... #word IPC8 = 0x0A4 
.................... #word IPC9 = 0x0A6 
.................... #word IPC10 = 0x0A8 
.................... #word INTREG = 0x0B0 
.................... #word CNEN1 = 0x0C0 
.................... #word CNEN2 = 0x0C2 
.................... #word CNPU1 = 0x0C4 
.................... #word CNPU2 = 0x0C6 
.................... #word TMR1 = 0x100 
.................... #word PR1 = 0x102 
.................... #word T1CON = 0x104 
.................... #word TMR2 = 0x106 
.................... #word TMR3HLD = 0x108 
.................... #word TMR3 = 0x10A 
.................... #word PR2 = 0x10C 
.................... #word PR3 = 0x10E 
.................... #word T2CON = 0x110 
.................... #word T3CON = 0x112 
.................... #word TMR4 = 0x114 
.................... #word TMR5HLD = 0x116 
.................... #word TMR5 = 0x118 
.................... #word PR4 = 0x11A 
.................... #word PR5 = 0x11C 
.................... #word T4CON = 0x11E 
.................... #word T5CON = 0x120 
.................... #word IC1BUF = 0x140 
.................... #word IC1CON = 0x142 
.................... #word IC2BUF = 0x144 
.................... #word IC2CON = 0x146 
.................... #word IC3BUF = 0x148 
.................... #word IC3CON = 0x14A 
.................... #word IC4BUF = 0x14C 
.................... #word IC4CON = 0x14E 
.................... #word IC5BUF = 0x150 
.................... #word IC5CON = 0x152 
.................... #word IC6BUF = 0x154 
.................... #word IC6CON = 0x156 
.................... #word IC7BUF = 0x158 
.................... #word IC7CON = 0x15A 
.................... #word IC8BUF = 0x15C 
.................... #word IC8CON = 0x15E 
.................... #word OC1RS = 0x180 
.................... #word OC1R = 0x182 
.................... #word OC1CON = 0x184 
.................... #word OC2RS = 0x186 
.................... #word OC2R = 0x188 
.................... #word OC2CON = 0x18A 
.................... #word OC3RS = 0x18C 
.................... #word OC3R = 0x18E 
.................... #word OC3CON = 0x190 
.................... #word OC4RS = 0x192 
.................... #word OC4R = 0x194 
.................... #word OC4CON = 0x196 
.................... #word OC5RS = 0x198 
.................... #word OC5R = 0x19A 
.................... #word OC5CON = 0x19C 
.................... #word OC6RS = 0x19E 
.................... #word OC6R = 0x1A0 
.................... #word OC6CON = 0x1A2 
.................... #word OC7RS = 0x1A4 
.................... #word OC7R = 0x1A6 
.................... #word OC7CON = 0x1A8 
.................... #word OC8RS = 0x1AA 
.................... #word OC8R = 0x1AC 
.................... #word OC8CON = 0x1AE 
.................... #word I2CRCV = 0x200 
.................... #word I2CTRN = 0x202 
.................... #word I2CBRG = 0x204 
.................... #word I2CCON = 0x206 
.................... #word I2CSTAT = 0x208 
.................... #word I2CADD = 0x20A 
.................... #word U1MODE = 0x20C 
.................... #word U1STA = 0x20E 
.................... #word U1TXREG = 0x210 
.................... #word U1RXREG = 0x212 
.................... #word U1BRG = 0x214 
.................... #word U2MODE = 0x216 
.................... #word U2STA = 0x218 
.................... #word U2TXREG = 0x21A 
.................... #word U2RXREG = 0x21C 
.................... #word U2BRG = 0x21E 
.................... #word SPI1STAT = 0x220 
.................... #word SPI1CON = 0x222 
.................... #word SPI1BUF = 0x224 
.................... #word SPI2STAT = 0x226 
.................... #word SPI2CON = 0x228 
.................... #word SPI2BUF = 0x22A 
.................... #word DCICON1 = 0x240 
.................... #word DCICON2 = 0x242 
.................... #word DCICON3 = 0x244 
.................... #word DCISTAT = 0x246 
.................... #word TSCON = 0x248 
.................... #word RSCON = 0x24C 
.................... #word RXBUF0 = 0x250 
.................... #word RXBUF1 = 0x252 
.................... #word RXBUF2 = 0x254 
.................... #word RXBUF3 = 0x256 
.................... #word TXBUF0 = 0x258 
.................... #word TXBUF1 = 0x25A 
.................... #word TXBUF2 = 0x25C 
.................... #word TXBUF3 = 0x25E 
.................... #word ADCBUF0 = 0x280 
.................... #word ADCBUF1 = 0x282 
.................... #word ADCBUF2 = 0x284 
.................... #word ADCBUF3 = 0x286 
.................... #word ADCBUF4 = 0x288 
.................... #word ADCBUF5 = 0x28A 
.................... #word ADCBUF6 = 0x28C 
.................... #word ADCBUF7 = 0x28E 
.................... #word ADCBUF8 = 0x290 
.................... #word ADCBUF9 = 0x292 
.................... #word ADCBUFA = 0x294 
.................... #word ADCBUFB = 0x296 
.................... #word ADCBUFC = 0x298 
.................... #word ADCBUFD = 0x29A 
.................... #word ADCBUFE = 0x29C 
.................... #word ADCBUFF = 0x29E 
.................... #word ADCON1 = 0x2A0 
.................... #word ADCON2 = 0x2A2 
.................... #word ADCON3 = 0x2A4 
.................... #word ADCHS = 0x2A6 
.................... #word ADPCFG = 0x2A8 
.................... #word ADCSSL = 0x2AA 
.................... #word TRISA = 0x2C0 
.................... #word PORTA = 0x2C2 
.................... #word LATA = 0x2C4 
.................... #word TRISB = 0x2C6 
.................... #word PORTB = 0x2C8 
.................... #word LATB = 0x2CA 
.................... #word TRISC = 0x2CC 
.................... #word PORTC = 0x2CE 
.................... #word LATC = 0x2D0 
.................... #word TRISD = 0x2D2 
.................... #word PORTD = 0x2D4 
.................... #word LATD = 0x2D6 
.................... #word TRISF = 0x2DE 
.................... #word PORTF = 0x2E0 
.................... #word LATF = 0x2E2 
.................... #word TRISG = 0x2E4 
.................... #word PORTG = 0x2E6 
.................... #word LATG = 0x2E8 
.................... #word C1RXF0SID = 0x300 
.................... #word C1RXF0EIDH = 0x302 
.................... #word C1RXF0EIDL = 0x304 
.................... #word C1RXF1SID = 0x308 
.................... #word C1RXF1EIDH = 0x30A 
.................... #word C1RXF1EIDL = 0x30C 
.................... #word C1RXF2SID = 0x310 
.................... #word C1RXF2EIDH = 0x312 
.................... #word C1RXF2EIDL = 0x314 
.................... #word C1RXF3SID = 0x318 
.................... #word C1RXF3EIDH = 0x31A 
.................... #word C1RXF3EIDL = 0x31C 
.................... #word C1RXF4SID = 0x320 
.................... #word C1RXF4EIDH = 0x322 
.................... #word C1RXF4EIDL = 0x324 
.................... #word C1RXF5SID = 0x328 
.................... #word C1RXF5EIDH = 0x32A 
.................... #word C1RXF5EIDL = 0x32C 
.................... #word C1RXM0SID = 0x330 
.................... #word C1RXM0EIDH = 0x332 
.................... #word C1RXM0EIDL = 0x334 
.................... #word C1RXM1SID = 0x338 
.................... #word C1RXM1EIDH = 0x33A 
.................... #word C1RXM1EIDL = 0x33C 
.................... #word C1TX2SID = 0x340 
.................... #word C1TX2EID = 0x342 
.................... #word C1TX2DLC = 0x344 
.................... #word C1TX2B1 = 0x346 
.................... #word C1TX2B2 = 0x348 
.................... #word C1TX2B3 = 0x34A 
.................... #word C1TX2B4 = 0x34C 
.................... #word C1TX2CON = 0x34E 
.................... #word C1TX1SID = 0x350 
.................... #word C1TX1EID = 0x352 
.................... #word C1TX1DLC = 0x354 
.................... #word C1TX1B1 = 0x356 
.................... #word C1TX1B2 = 0x358 
.................... #word C1TX1B3 = 0x35A 
.................... #word C1TX1B4 = 0x35C 
.................... #word C1TX1CON = 0x35E 
.................... #word C1TX0SID = 0x360 
.................... #word C1TX0EID = 0x362 
.................... #word C1TX0DLC = 0x364 
.................... #word C1TX0B1 = 0x366 
.................... #word C1TX0B2 = 0x368 
.................... #word C1TX0B3 = 0x36A 
.................... #word C1TX0B4 = 0x36C 
.................... #word C1TX0CON = 0x36E 
.................... #word C1RX1SID = 0x370 
.................... #word C1RX1EID = 0x372 
.................... #word C1RX1DLC = 0x374 
.................... #word C1RX1B1 = 0x376 
.................... #word C1RX1B2 = 0x378 
.................... #word C1RX1B3 = 0x37A 
.................... #word C1RX1B4 = 0x37C 
.................... #word C1RX1CON = 0x37E 
.................... #word C1RX0SID = 0x380 
.................... #word C1RX0EID = 0x382 
.................... #word C1RX0DLC = 0x384 
.................... #word C1RX0B1 = 0x386 
.................... #word C1RX0B2 = 0x388 
.................... #word C1RX0B3 = 0x38A 
.................... #word C1RX0B4 = 0x38C 
.................... #word C1RX0CON = 0x38E 
.................... #word C1CTRL = 0x390 
.................... #word C1CFG1 = 0x392 
.................... #word C1CFG2 = 0x394 
.................... #word C1INTF = 0x396 
.................... #word C1INTE = 0x398 
.................... #word C1EC = 0x39A 
.................... #word C2RXF0SID = 0x3C0 
.................... #word C2RXF0EIDH = 0x3C2 
.................... #word C2RXF0EIDL = 0x3C4 
.................... #word C2RXF1SID = 0x3C8 
.................... #word C2RXF1EIDH = 0x3CA 
.................... #word C2RXF1EIDL = 0x3CC 
.................... #word C2RXF2SID = 0x3D0 
.................... #word C2RXF2EIDH = 0x3D2 
.................... #word C2RXF2EIDL = 0x3D4 
.................... #word C2RXF3SID = 0x3D8 
.................... #word C2RXF3EIDH = 0x3DA 
.................... #word C2RXF3EIDL = 0x3DC 
.................... #word C2RXF4SID = 0x3E0 
.................... #word C2RXF4EIDH = 0x3E2 
.................... #word C2RXF4EIDL = 0x3E4 
.................... #word C2RXF5SID = 0x3E8 
.................... #word C2RXF5EIDH = 0x3EA 
.................... #word C2RXF5EIDL = 0x3EC 
.................... #word C2RXM0SID = 0x3F0 
.................... #word C2RXM0EIDH = 0x3F2 
.................... #word C2RXM0EIDL = 0x3F4 
.................... #word C2RXM1SID = 0x3F8 
.................... #word C2RXM1EIDH = 0x3FA 
.................... #word C2RXM1EIDL = 0x3FC 
.................... #word C2TX2SID = 0x400 
.................... #word C2TX2EID = 0x402 
.................... #word C2TX2DLC = 0x404 
.................... #word C2TX2B1 = 0x406 
.................... #word C2TX2B2 = 0x408 
.................... #word C2TX2B3 = 0x40A 
.................... #word C2TX2B4 = 0x40C 
.................... #word C2TX2CON = 0x40E 
.................... #word C2TX1SID = 0x410 
.................... #word C2TX1EID = 0x412 
.................... #word C2TX1DLC = 0x414 
.................... #word C2TX1B1 = 0x416 
.................... #word C2TX1B2 = 0x418 
.................... #word C2TX1B3 = 0x41A 
.................... #word C2TX1B4 = 0x41C 
.................... #word C2TX1CON = 0x41E 
.................... #word C2TX0SID = 0x420 
.................... #word C2TX0EID = 0x422 
.................... #word C2TX0DLC = 0x424 
.................... #word C2TX0B1 = 0x426 
.................... #word C2TX0B2 = 0x428 
.................... #word C2TX0B3 = 0x42A 
.................... #word C2TX0B4 = 0x42C 
.................... #word C2TX0CON = 0x42E 
.................... #word C2RX1SID = 0x430 
.................... #word C2RX1EID = 0x432 
.................... #word C2RX1DLC = 0x434 
.................... #word C2RX1B1 = 0x436 
.................... #word C2RX1B2 = 0x438 
.................... #word C2RX1B3 = 0x43A 
.................... #word C2RX1B4 = 0x43C 
.................... #word C2RX1CON = 0x43E 
.................... #word C2RX0SID = 0x440 
.................... #word C2RX0EID = 0x442 
.................... #word C2RX0DLC = 0x444 
.................... #word C2RX0B1 = 0x446 
.................... #word C2RX0B2 = 0x448 
.................... #word C2RX0B3 = 0x44A 
.................... #word C2RX0B4 = 0x44C 
.................... #word C2RX0CON = 0x44E 
.................... #word C2CTRL = 0x450 
.................... #word C2CFG1 = 0x452 
.................... #word C2CFG2 = 0x454 
.................... #word C2INTF = 0x456 
.................... #word C2INTE = 0x458 
.................... #word C2EC = 0x45A 
.................... #word RCON = 0x740 
.................... #word OSCCON = 0x742 
.................... #word OSCTUN = 0x744 
.................... #word NVMCON = 0x760 
.................... #word NVMADR = 0x762 
.................... #word NVMADRU = 0x764 
.................... #word NVMKEY = 0x766 
.................... #word PMD1 = 0x770 
.................... #word PMD2 = 0x772 
....................  
....................  
.................... // Fuses 
.................... #fuses NOWDT, HS2_PLL8, NOPUT, NOPROTECT, DEBUG, NOBROWNOUT, NOWRT 
.................... #device ICD=TRUE 
.................... // Dfinit la vitesse du quartz (prendre en compte si PLL employe) 
.................... #use delay(clock=80000000) 
*
00DE2:  CP0     W0
00DE4:  BTSC.B  42.1
00DE6:  BRA     DF4
00DE8:  REPEAT  #E1B
00DEA:  NOP     
00DEC:  REPEAT  #3FFE
00DEE:  NOP     
00DF0:  DEC     W0,W0
00DF2:  BRA     NZ,DE8
00DF4:  RETURN  
.................... // Config IIC 
.................... #use i2c(master,force_hw,slow,I2C1) 
*
00E4C:  MOV     #FFFF,W0
00E4E:  BTSS.B  208.3
00E50:  BRA     E5C
00E52:  BTSC.B  209.6
00E54:  BRA     E52
00E56:  MOV     W1,202
00E58:  BTSC.B  209.6
00E5A:  BRA     E58
00E5C:  MOV     #0,W0
00E5E:  BTSC.B  209.7
00E60:  INC     W0,W0
00E62:  RETURN  
*
08B56:  MOV     #FFFF,W0
08B58:  BTSS.B  208.3
08B5A:  BRA     8B7E
08B5C:  MOV     206,W2
08B5E:  AND     W2,#1F,W2
08B60:  BRA     NZ,8B5C
08B62:  BSET.B  206.3
08B64:  BTSC    W1.0
08B66:  BCLR.B  206.5
08B68:  BTSS    W1.0
08B6A:  BSET.B  206.5
08B6C:  MOV     206,W2
08B6E:  AND     W2,#1F,W2
08B70:  BRA     NZ,8B6C
08B72:  BSET.B  206.4
08B74:  BTSS.B  208.1
08B76:  BRA     8B74
08B78:  MOV     200,W0
08B7A:  BTSC.B  208.6
08B7C:  BCLR.B  208.6
08B7E:  RETURN  
.................... #build(stack=2048) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,STREAM=ROBOTEQ) // Pour pouvoir utiliser le RS232/2 
.................... //#use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=ROBOTEQ/*UART*/) // Pour pouvoir utiliser le RS232/1 
.................... #use spi (MASTER, MODE=0, BAUD=100000, SPI1, FORCE_HW) 
....................  
.................... // Variables utiles (globales) 
.................... int1 flagGameEnd=0,flagTimeOut=0;	// Dfinit si le temps est dpass 
.................... int1 flagBaliseCheck=0;				// Dfinit si adversaire dtect 
.................... int1 flagError=0; 					// Si une erreur doit tre affiche 
.................... int1 flag_started = 0; 
.................... int1 ToDisplay=0; 
.................... int1 IsPassedTimeOut=0; 
.................... int1 flag_depl_ok = 0; 
.................... int1 flag_end = 0; 
.................... int1 _Detected = 0;  
.................... int1 balise_on = 0; 
.................... int1 flag_error = 0;  
.................... int1 Team=0; 
....................  
.................... signed int32 ActualPosition = 0; 
.................... unsigned int32 RealTimeMS=0,BeginTimeMS=0,GameTimeMS=0; 
.................... unsigned int8 value_balise=0;	// Valeur de la balise en dtection 
.................... unsigned int8 GameTimeS=0;	// Temps de jeu 
.................... unsigned int8 Time_detected = 0; 
.................... unsigned int8 TIME_tempo_dectected = 4; 
.................... unsigned int8 No_erreur = 0;  
.................... unsigned int8 Value_bal = 0;  
.................... unsigned int8 Tempo_bal = 0 ;  
....................  
....................  
.................... unsigned int8 NoObj = 1; 
.................... unsigned int8 NoPts = 1; 
.................... unsigned int32 last_obj = 0; 
....................  
.................... int1 Check = 1; 
.................... unsigned int8 points = 0; 
.................... unsigned int8 solution = 0; 
....................  
.................... unsigned int8 Write_cmd_arduino(unsigned int8 cmd,unsigned int8 taille, unsigned int8 *data ) ; 
....................  
....................  
.................... // Dfinit les constantes ASCII, comme il n'a pas l'air de les prendre ... 
.................... enum{NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL,BS,TAB,LF,VT,FF,CR,SO,SI,DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB,CAN,EM,SUB,ESC,FS,GS,RS,US,SPACE}; 
.................... enum{Init, Choose_objectif, Check_ZI, Send_depl_action, Send_depl_action_ZI, Depl_action_process, Depl_action_process_ZI,Switch_end_obj,Wait_end} Etat_rob = Init; 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... #define BalSensitivity 3 
.................... #define MARGE 360 
.................... #define SIZE_TABLE_X 3000 
.................... #define SIZE_TABLE_Y 2000 
.................... 	 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Inclusion des fichiers sources 
.................... #include "driver_moteur.c" 
.................... //========================================================================================== 
.................... //																							 
.................... //						EMVs - Fonctions pour DRIVER MOTEUR MAXON 											 
.................... //						--------------------------												 
.................... //																							 
.................... //========================================================================================= 
.................... //	Dvelopp par:		: Carrupt Aurlien    												 
.................... //						: Duay Daniel    												 
.................... //  Date				: 15.03.2013															 
.................... //  Date de modif.		: 14.02.2017															 
.................... //  Nom de la lib	 	: driver_moteur.c													 
.................... //  Version 			: V2.1																 
.................... //========================================================================================= 
.................... // Description :																			 
.................... //=============																			 
.................... //	Ce code contient les fonctions qui permettent au master de communiquer avec le driver  	 
.................... //	de moteur V3.0																			 
.................... //   
.................... //======================================================================================== 
.................... //DIRECTIVES DE PRECOMPILATIONS 
.................... //======================================================================================== 
....................  
.................... #DEFINE DRV_MODE_COURANT 0		// !!!!!!  NON IMPLEMENTE !!!!!   rgulation en mode courant  
.................... #DEFINE DRV_MODE_VITESSE 1		// rgulation en mode vitesse  
.................... #DEFINE DRV_MODE_NON_REGUL 2	// mode rgulation dsactive  
.................... #DEFINE DRV_STOP 0				// Arrt du moteur et arrt d'urgence 
.................... #DEFINE DRV_RESET 1				// Reset du driver 
....................  
.................... #DEFINE DRV_ARRET_COURANT 0					// Arret en courant  
.................... #DEFINE DRV_ARRET_POSITION_ABSOLUE 1		// Arret en position absoulue 
.................... #DEFINE DRV_ARRET_POSITION_RELATIVE 2		// Arret en position relative 
.................... #DEFINE DRV_ARRET_TEMPS 3					// Arret en position temps  
.................... 			 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: go_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Dvelopp par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer un ordre de dplacement au moteur		 	      																	 
.................... // paramtres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					direction :			sens de rotation du moteur (int8) -> 0 ou 1																			 
.................... //					mode_regulation : 	!!!!!!  NON IMPLEMENTE !!!!!  DRV_MODE_COURANT (int8) -> rgulation en courant ->paramtre_1 = valeur du courant qu'on souhaite maintenir [mA] (int16) 
.................... //										DRV_MODE_VITESSE (int8) -> rgulation en vitesse  ->paramtre_1 = valeur de vitesse qu'on souhaite maintenir [impulse/s] (int16) 
.................... //										DRV_MODE_NON_REGUL (int8) -> rgulation dsactive ->paramtre_1 = valeur de la PWM 0-100 en %  (int16) 
.................... //					mode_d'arret 	: 	DRV_ARRET_POSITION_ABSOLUE (int8)	-> 	parametre_2 = position a atteindre [impulse] (int32)																			   
.................... //										DRV_ARRET_POSITION_RELATIVE (int8)	->	parametre_2 = nombre d'impulsion d'encodeur a effectuer [impulse] (int32) 
.................... //										DRV_ARRET_TEMPS (int8)				->	parametre_2 = temps du parcours [ms] (int32) 
.................... //										DRV_ARRET_COURANT (int8)			->	parametre_2 = valeur du courant d'arrt souhait [mA] (int32)								 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilis																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne rpond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 go_driver_moteur(int8 adresse_driver, int8 direction, int8 mode_regulation, int16 parametre_1, int8 mode_arret, signed int32 parametre_2) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
.................... 	int8 config; 
.................... 	 
.................... 	 
.................... 	config = ((mode_regulation & 0b00000111)<<5) + ((direction & 0b00000001)<<4) + (mode_arret & 0b00000111); 
.................... 	val1 = make8(parametre_1, 0); 
.................... 	val2 = make8(parametre_1, 1); 
.................... 	val3 = make8(parametre_2, 0); 
.................... 	val4 = make8(parametre_2, 1); 
.................... 	val5 = make8(parametre_2, 2); 
.................... 	val6 = make8(parametre_2, 3); 
.................... 	 
.................... 	i2c_start(); 
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(0x48);					//Type de commande (4 bits high) et nombre de donne (4 bits low)  
.................... 		i2c_write(config);					//configuration 
.................... 		i2c_write(val1);					// parametre_1 
.................... 		i2c_write(val2); 
.................... 		i2c_write(val3);					// parametre_2 
.................... 		i2c_write(val4); 
.................... 		i2c_write(val5);					 
.................... 		i2c_write(val6); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 2; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur_pid																																 
.................... //================================================================================================================================================================================================= 
.................... //	Dvelopp par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les valeurs du PID du rgulateur driver moteur	 	      																	 
.................... // paramtres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					reg_P 			= Valeur P du rgulateur (int16)  valeur en millime  ex: 1250 = 1.25 
.................... //					reg_I 			= Valeur I du rgulateur (int16)			idem 
.................... //					reg_D 			= Valeur D du rgulateur (int16)			idem 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilis																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne rpond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur_pid(int8 adresse_driver, int16 reg_P, int16 reg_I, int16 reg_D) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
....................  
.................... 	val1 = make8(reg_P, 0); 
.................... 	val2 = make8(reg_P, 1); 
.................... 	val3 = make8(reg_I, 0); 
.................... 	val4 = make8(reg_I, 1); 
.................... 	val5 = make8(reg_D, 0); 
.................... 	val6 = make8(reg_D, 1); 
....................  
.................... 	i2c_start(); 
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(0x37);					//Type de commande (4 bits high) et nombre de donne (4 bits low)  
.................... 		i2c_write(val1);					// parametre P 
.................... 		i2c_write(val2); 
.................... 		i2c_write(val3);					// parametre I 
.................... 		i2c_write(val4); 
.................... 		i2c_write(val5);					// parametre D					 
.................... 		i2c_write(val6); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 2; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Dvelopp par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 18.03.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les rampes d'acclration et de dclration ainsi que le courant max du moteur 
.................... // paramtres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					acceleration 	= valeur d'acclration en imp./sec (int16) 
.................... //					deceleration 	= valeur de dclration en imp./sec (int16)  
.................... //					courant_max 	= Valeur du courant max en mA (int16) 
.................... //					impuls_tour		= Impulsion par tour de moteur aprs le rducteur -> encodeur * rducteur 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilis																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne rpond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur(int8 adresse_driver, int16 acceleration, int16 deceleration, int16 courant_max, int16 impuls_tour) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6, val7, val8; 
....................  
.................... 	val1 = make8(acceleration, 0); 
.................... 	val2 = make8(acceleration, 1); 
.................... 	val3 = make8(deceleration, 0); 
.................... 	val4 = make8(deceleration, 1); 
.................... 	val5 = make8(courant_max, 0); 
.................... 	val6 = make8(courant_max, 1); 
.................... 	val7 = make8(impuls_tour, 0); 
.................... 	val8 = make8(impuls_tour, 1); 
....................  
.................... 	i2c_start(); 
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(0x29);					//Type de commande (4 bits high) et nombre de donne (4 bits low)  
.................... 		i2c_write(val1);					// acclration 
.................... 		i2c_write(val2); 
.................... 		i2c_write(val3);					// dclration 
.................... 		i2c_write(val4); 
.................... 		i2c_write(val5);					// courant max					 
.................... 		i2c_write(val6); 
.................... 		i2c_write(val7);					// impulsion par tour					 
.................... 		i2c_write(val8); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 2; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Dvelopp par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer des ordres courts direct comme d'arrter le moteur mme s'il n'a pas fini l'ordre prcdent ou reset le driver 
.................... // paramtres 	:  	adresse_driver 	= Adresse I2C du driver	(int8) 
.................... //					ordre		 	= ordre  effectuer (stop = 0, reset = 1) (int8) 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilis																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne rpond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 driver_moteur(int8 adresse_driver, int8 ordre) 
.................... { 
.................... 	i2c_start(); 
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(((ordre << 4) & 0b00010000) + 0x01);					//Type de commande (4 bits high) et nombre de donne (4 bits low)  
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 2; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_driver_moteur	 														 
.................... == Crateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  Permet de lire l'tat du driver								      	 
.................... == paramtre 	:  Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  retourne le status du driver											 
.................... ==				   0-> Arret  (le driver a fini tout traitement et attend le prochain ordre)	 
.................... ==				   1-> Marche (le driver est entrain d'excuter l'ordre)													 
.................... ==				   2-> Surcharge (le driver a dpass la limite de courant max. dfini par l'utilisateur)															 
.................... ==				   3-> Erreur PONT-H (Temprature IC trop leve, courant trop lev) 
.................... ==				   4-> BUSY (le slave est entrain de traiter la prochaine commande) 
.................... ==				   5-> not ready  (le slave ne rpond pas)															 
.................... /*===================================================================================================================================================================================================*/ 
.................... unsigned int8 read_driver_moteur(int8 adresse_driver) 
.................... { 
.................... 	int8 driver_etat=0; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
.................... 	ack = i2c_write(adresse_driver+1); 
.................... 	if(ack == 0) 
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
.................... 	} 
.................... 	else driver_etat = 5; 
....................  
.................... 	i2c_stop(); 
.................... 	return driver_etat; 
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_pos_moteur	 														 
.................... == Crateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  	Permet de lire la valeur du capteur incrmental du moteur 
.................... ==					Attention n'utiliser cette fonction seulement quand le moteur est  l'arrt, sinon il y a un risque de faire planter la communication I2C						      	 
.................... == paramtre 	:  	Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  	signed 32bits -> la valeur actuel du capteur incrmental du moteur 
.................... ==					2147483647 -> interdiction de lire la position pendant un mouvement 
.................... ==					2147483648 -> not ready  (le slave ne rpond pas)  
.................... ==				    
.................... /*===================================================================================================================================================================================================*/ 
.................... signed int32 read_pos_moteur(int8 adresse_driver) 
.................... { 
.................... 	int8 ack=0; 
.................... 	unsigned int8 buffer[4]; 
.................... 	signed int32 pos_value; 
....................  
.................... 	if (read_driver_moteur(adresse_driver) != 1) 
.................... 		{ 
.................... 			i2c_start(); 
.................... 			ack = i2c_write(adresse_driver+1); 
.................... 			if(ack == 0) 
.................... 			{ 
.................... 				i2c_read(1); 
.................... 				buffer[0]=i2c_read(1); 
.................... 				buffer[1]=i2c_read(1); 
.................... 				buffer[2]=i2c_read(1); 
.................... 				buffer[3]=i2c_read(0); 
.................... 				pos_value = make32(buffer[3],buffer[2],buffer[1],buffer[0]); 
.................... 			} 
.................... 			else pos_value = 2147483648; 
.................... 		 
.................... 			i2c_stop(); 
.................... 		} 
.................... 	else pos_value = 2147483647; 
....................  
.................... 	return pos_value; 
.................... }	 
.................... 	 
.................... //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... #include "Com_balises.c" 
.................... #ifndef Com_balises 
.................... #define Com_balises 
.................... 	 
.................... void Balise_config_plage(int8 no_plage, int8 deb_plage, int8 fin_plage) 
.................... {	 
.................... 	i2c_start(); 
*
00E64:  BTSS.B  208.3
00E66:  BRA     E70
00E68:  BSET.B  206.1
00E6A:  BTSC.B  206.1
00E6C:  BRA     E6A
00E6E:  BRA     E76
00E70:  BSET.B  206.0
00E72:  BTSC.B  206.0
00E74:  BRA     E72
.................... 	i2c_write(0x20);			// adresse de la balise 
00E76:  MOV.B   #20,W1L
00E78:  CALL    E4C
.................... 	i2c_write(0x10);			// instruction de config 
00E7C:  MOV.B   #10,W1L
00E7E:  CALL    E4C
.................... 	i2c_write(no_plage); 
00E82:  MOV.B   1B3A,W0L
00E84:  MOV.B   W0L,2
00E86:  CALL    E4C
.................... 	i2c_write(deb_plage); 
00E8A:  MOV.B   1B3B,W0L
00E8C:  MOV.B   W0L,W1L
00E8E:  CALL    E4C
.................... 	i2c_write(fin_plage); 
00E92:  MOV.B   1B3C,W0L
00E94:  MOV.B   W0L,2
00E96:  CALL    E4C
.................... 	i2c_write('@');				// fin de la communication 
00E9A:  MOV.B   #40,W1L
00E9C:  CALL    E4C
.................... 	i2c_stop(); 
00EA0:  MOV     #1F,W0
00EA2:  AND     206,W0
00EA4:  BRA     NZ,EA0
00EA6:  BSET.B  206.2
00EA8:  BTSC.B  206.2
00EAA:  BRA     EA8
00EAC:  RETURN  
.................... } 
....................  
.................... void Balise_set_plage(int8 select_plage) 
.................... { 
.................... 	i2c_start(); 
*
0766C:  BTSS.B  208.3
0766E:  BRA     7678
07670:  BSET.B  206.1
07672:  BTSC.B  206.1
07674:  BRA     7672
07676:  BRA     767E
07678:  BSET.B  206.0
0767A:  BTSC.B  206.0
0767C:  BRA     767A
.................... 	i2c_write(0x20);			// adresse de la balise 
0767E:  MOV.B   #20,W1L
07680:  CALL    E4C
.................... 	i2c_write(0x80);			// instruction de set 
07684:  MOV.B   #80,W1L
07686:  CALL    E4C
.................... 	i2c_write(select_plage); 
0768A:  MOV.B   1B96,W0L
0768C:  MOV.B   W0L,2
0768E:  CALL    E4C
.................... 	i2c_write('@');				// fin de la communication 
07692:  MOV.B   #40,W1L
07694:  CALL    E4C
.................... 	i2c_stop();	 
07698:  MOV     #1F,W0
0769A:  AND     206,W0
0769C:  BRA     NZ,7698
0769E:  BSET.B  206.2
076A0:  BTSC.B  206.2
076A2:  BRA     76A0
076A4:  RETURN  
.................... } 
....................  
.................... unsigned int8 Check_balise(void) 
.................... { 
.................... 	static unsigned int8 ack_balise=0; 
....................  
.................... 	i2c_start(); 
*
08B80:  BTSS.B  208.3
08B82:  BRA     8B8C
08B84:  BSET.B  206.1
08B86:  BTSC.B  206.1
08B88:  BRA     8B86
08B8A:  BRA     8B92
08B8C:  BSET.B  206.0
08B8E:  BTSC.B  206.0
08B90:  BRA     8B8E
.................... 	ack_balise=i2c_write(0x21);			// adresse de balise en lecture 
08B92:  MOV.B   #21,W1L
08B94:  CALL    E4C
08B98:  MOV.B   W0L,87C
.................... 	if(ack_balise==0) 
08B9A:  CP0.B   87C
08B9C:  BRA     NZ,8BAE
.................... 	{					// si elle est dtecte - demander sa lecture 
.................... 		delay_us(30); 
08B9E:  REPEAT  #256
08BA0:  NOP     
.................... 		value_balise=i2c_read(0); 
08BA2:  MOV     #0,W1
08BA4:  MOV     W1,[W15++]
08BA6:  MOV     [--W15],W1
08BA8:  CALL    8B56
08BAC:  MOV.B   W0L,86C
.................... 	} 
.................... 	i2c_stop(); 
08BAE:  MOV     #1F,W0
08BB0:  AND     206,W0
08BB2:  BRA     NZ,8BAE
08BB4:  BSET.B  206.2
08BB6:  BTSC.B  206.2
08BB8:  BRA     8BB6
....................  
.................... 	return value_balise; 
08BBA:  MOV.B   86C,W0L
08BBC:  MOV.B   W0L,0
08BBE:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Init.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 05.03.2015																== 
.................... ===  Nom du programme 	: InterfaceRoboteQuC.mcp													== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Fonctions d'initialisation du dsPIC30F6014A.				    								== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Init 
.................... #define ___Init 
....................  
.................... //**************************************************************************************************** 
.................... //*  Dfintion des bits 
.................... //*  ! Utiliser LATx pour des sorties et PORTx pour des entres lorsque commandes succintes rapides. ! 
.................... //**************************************************************************************************** 
....................  
.................... /*#bit _LED1 = LATC.1			//--| 
.................... #bit _LED2 = LATC.2			//	| 
.................... #bit _LED3 = LATC.3			//	|- LEDs 
.................... #bit _LED4 = LATC.4			//	| 
.................... */ 
....................  
.................... #BIT LED1 = LATC.1 
.................... #BIT LED2 = LATC.2 
.................... #BIT LED3 = LATC.3 
....................  
.................... /* 
.................... #bit _DEMA = PORTA.10		//--| 
.................... #bit _TEAM = PORTA.12		//	| 
.................... #bit _Capdist = PORTA.13		//	|- Digital Inputs 
.................... #bit _Dig4 = PORTA.6		//	| 
.................... #bit _ZeroPoint = PORTA.7		//  | 
.................... #bit _Dig6 = PORTA.9		//	| 
.................... */ 
....................  
.................... #BIT IN_DIG1 = PORTA.10 
.................... #BIT IN_DIG2 = PORTA.12 
.................... #BIT IN_DIG3 = PORTA.13 
.................... #BIT _DEMA = PORTA.6 
.................... #BIT _TEAM = PORTA.7 
.................... #BIT IN_DIG6 = PORTA.9 
....................  
.................... #BIT OUT_DIG1 = LATD.0 
.................... #BIT OUT_DIG2 = LATD.1 
.................... #BIT OUT_DIG3 = LATD.2 
.................... #BIT OUT_DIG4 = LATD.3 
.................... #BIT OUT_DIG5 = LATD.4 
.................... #BIT OUT_DIG6 = LATD.5 
.................... #BIT OUT_DIG7 = LATD.6 
.................... #BIT OUT_DIG8 = LATD.7 
....................  
.................... #bit _Tim1On = T1CON.15 
.................... #bit _Tim2On = T2CON.15 
.................... #bit _Tim3On = T3CON.15 
....................  
.................... #bit _I2CEN = I2CCON.15 
.................... #bit _GCEN = I2CCON.7 
....................  
.................... #bit CS1     = PORTB.2 
.................... #bit _En_Diz = PORTB.10 
.................... #bit _EN_Uni = PORTB.11 
....................  
....................  
.................... enum{STOP,CHARGE_OBJ,DRIVER_GO,OBJ_PERSO,DRIVER_DONE,OBJ_DONE,WAIT}State=STOP; 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    __Init_dsPIC 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    30.01.2015 
.................... //  Statut :    Fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Config. et initialisation du dsPIC30F6014A. 
.................... //	Paramtre(s): / 
.................... //  Rsultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Init_dsPIC(void) 
.................... { 
.................... 	//------------------------------------------------------------------------------ 
.................... 	// Configuration des I/O 
.................... 	TRISA = 0b0011011011000000;		// RA6,7,9,10,12,13 : Digital Input 
*
00DF6:  MOV     #36C0,W4
00DF8:  MOV     W4,2C0
.................... 	PORTA=0; 
00DFA:  CLR     2C2
.................... 	TRISB = 0b0000000001111000;		// RB2-5: Analog Input 
00DFC:  MOV     #78,W4
00DFE:  MOV     W4,2C6
.................... 	PORTB=0; 
00E00:  CLR     2C8
.................... 	TRISC = 0b0000000000000000;		// RC1-4: LEDs 
00E02:  CLR     2CC
.................... 	PORTC=0; 
00E04:  CLR     2CE
.................... 	TRISD = 0b0000000000000000;		// RD0-7: Outputs  // 2018 RD4  RD7 utilis en entre 
00E06:  CLR     2D2
.................... 	PORTD=0; 
00E08:  CLR     2D4
.................... 	TRISF = 0b0000000010010100;		// RF2-5: Rx1, Tx1, Rx2, Tx2 
00E0A:  MOV     #94,W4
00E0C:  MOV     W4,2DE
.................... 	PORTF=0; 
00E0E:  CLR     2E0
.................... 	TRISG = 0b0000000010000000;		// RG2-3: SCL-SDA 
00E10:  MOV     #80,W4
00E12:  MOV     W4,2E4
.................... 	PORTG=0;  
00E14:  CLR     2E6
....................  
....................  
.................... // configuration de l'I2C 
.................... 	I2CCON = 0x800f;//LAISSER, SINON L'I2C PLANTE 
00E16:  MOV     #800F,W4
00E18:  MOV     W4,206
.................... //	_GCEN=0; 
.................... //	_I2CEN=1; 
....................  
.................... 	//setup_adc(ADC_CLOCK_INTERNAL); 
.................... 	//setup_adc_ports(sAN3 | sAN4 | sAN5 | sAN6); 
.................... 	 
.................... 	// Temps de jeu 
.................... 	// Set le timer1  1 [ms] 
.................... 	setup_timer1(TMR_INTERNAL,0x4E20);	 
00E1A:  CLR     104
00E1C:  MOV     #4E20,W4
00E1E:  MOV     W4,102
00E20:  MOV     #8000,W4
00E22:  MOV     W4,104
....................  
.................... 	// Capture balise 
.................... 	// Set le timer3 avec la frquence interne, incrment chaque 64 instructions, jusque 31250 => 100 [ms] 
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, 31250); 
00E24:  CLR     112
00E26:  MOV     #7A12,W4
00E28:  MOV     W4,10E
00E2A:  MOV     #8020,W4
00E2C:  MOV     W4,112
.................... 	 
.................... 	// Autorise le timer1 
.................... 	enable_interrupts(INT_TIMER1); 
00E2E:  BSET.B  8C.3
.................... 	// Autorise le timer3 
.................... 	enable_interrupts(INT_TIMER3); 
00E30:  BSET.B  8C.7
.................... 	// Interruptions RS232 
.................... 	enable_interrupts(INT_RDA2);	// Rception RS232/1 
00E32:  BSET.B  8F.0
.................... 	// Autorise les interruptions globalement 
.................... 	enable_interrupts(INTR_GLOBAL); 
00E34:  BCLR.B  81.7
00E36:  CLR     42
00E38:  BSET.B  81.7
.................... 	 
.................... 	//	config_driver_moteur_pid(0xC0, 200, 1, 0); 
.................... 	//	config_driver_moteur_pid(0xC2, 200, 1, 0); 
.................... 	delay_ms(10); 
00E3A:  MOV     #A,W0
00E3C:  CALL    DE2
.................... 	 
.................... 	//config_driver_moteur(0xC0, 5000, 5000, 2000,88064);//moteur cremaillere 
.................... 	//config_driver_moteur(0xC2, 5000, 5000, 2000,11776);//moteur couronne 
.................... 	delay_ms(10); 
00E40:  MOV     #A,W0
00E42:  CALL    DE2
.................... 	 
.................... 	return; 
00E46:  RETURN  
.................... 	 
.................... } 
.................... 	 
.................... #endif 
....................  
.................... #include "data/___data.h" 
.................... /* 
.................... * \file ___data.h 
.................... * \brief Data pour le robot. 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.03.2016 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___data_H 
.................... #define ___data_H 
....................  
.................... 	 
.................... 	int1 Depl_send = 0; 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	////////// Gestion erreurs 
.................... 	int1 Base = 0; 
.................... 	int16 TableWidth =3000; 
.................... 	unsigned int8 NbreZone_check = 0; 
.................... 	char RoboteQ_receiveBuffer[256]={};			// Buffer des donnes reues 
.................... 	unsigned int8 TabSentRS232[256]={0}; 
.................... 	 
.................... 	unsigned int8 nbre_obj = 0; 
.................... 	 
.................... 	int8 data_to_transmit[16];	//Tableau qui contient les donnes  envoyer par le SPI 
.................... 	struct etat  
.................... 	{ 
.................... 	  unsigned int8 bras; 
.................... 	  unsigned int8 msg; 
.................... 	  unsigned int8 cam; 
.................... 	}; 
.................... 	 
.................... 	struct etat stat; 
....................  
....................  
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	//														ZONES INTERDITES 
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	 
.................... 	int intersection_found = 0; 
.................... 	int path_found = 0; 
.................... 	int path_impossible = 0; 
.................... 	int path_opposite = 0; 
.................... 	int path_tooclose = 0; 
.................... 	 
.................... 	int relay_point_number = 0; 
.................... 	int i_rel = 0; 
.................... 	int i_depl = 0; 
....................  
.................... 	int TabIntersection[10]; 
.................... 	 
.................... 	long PtsRelai[20][2] = {0}; 
....................  
.................... 	//Tableau contenant les zone interdites. Chaque zone contient {x1, y1, x4, y4} 
.................... 	//zones interdites crites directement dans le code. !! Mettre en commentaire si on les lit depuis le PC !! 
.................... 	//long TabZones[10][4] = {{100,900,1200,1200}, {500,500,1200,560}, {0,0,0,0}, {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}}; 
.................... 	long TabZones[10][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; 
.................... 	long TabZonesPC[8] = {0}; 
....................  
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	 
.................... 	unsigned int16 TIME_SURCHAUFFE_MS = 1000; 
.................... 	unsigned int8 Erreur_max_surchauffe = 10; 
.................... 	unsigned int32 Time_ejection = 0; 
.................... 	unsigned int32 Time_ejection_toDo = 0; 
.................... 	int1 Action_send = 0;	 
....................  
.................... 	signed int16 TabObjectifs[7][13][12] = {0}; 
....................  
.................... 	// Objectif en cours 
.................... 	signed int16 oXp=0,oYp=0,oType=0,oAvAr=0,oCoteTourn=0,oVitMax=0,Obj_Action = 0,Pt_commun = 0,Ponderation = 0,Obj_end = 0,Next_obj = 0,keep_obj = 0;	 
.................... 	 
.................... 	 
.................... 	////////// UART 
.................... 	unsigned int8 UART_WD_DELAY = 20;	// Dlai du watchdog UART, en [ms]; par pas de 1 [ms] 
.................... 	unsigned int8 UART_NBR_REP_NAK = 5;	// Combien de fois maximum il faut rpter une commande si le rcepteur n'a pas compris  
.................... 	// Adresse UART du driver 
.................... 	unsigned int32 UART_ADDR = 2; 
.................... 	 
.................... 	////////// IIC 
.................... 	// Combien de fois maximum il faut rpter une commande si le rcepteur n'a pas compris 
.................... //	unsigned int8 IIC_NBR_REP_NAK = 5;	 
.................... 	// Combien de fois on rssaie un envoie 
.................... //	unsigned int8 IIC_NBR_REP_ENV = 5; 
....................  	//Adresse IIC du driver 
.................... //	unsigned int8 DRIVER_IIC_ADR = 0x50; 
.................... //	unsigned int8 TabToSendIIC[60]={0}; 
....................  
.................... 	 
.................... 	////////// Balise ///////// 
.................... 	unsigned int8 MAX_VALUE_DETECT_BALISE = 3; // Valeur maximum pour la dtection de l'adversaire (action trig si <=) 
.................... 	unsigned int16 TIME_TO_CHECK_BAL=200;	// Temps avant chaque check balise 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Mise en marche/arrt 
.................... int1 flagMarche = 0; 
.................... int1 flag_action_done = 0; 
....................  
.................... // Pour le nombre d'objectifs dj enregistrs 
.................... unsigned int16 NbreObjectifs = 0; 
.................... 	// Pour connatre le prochain objectif  atteindre 
.................... unsigned int16 NextObj = 0; 
....................  
.................... ////PC 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
01C1C:  MOV     W5,[W15++]
01C1E:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
01C20:  BCLR.B  1BCB.0
....................    y = x; 
01C22:  PUSH    1BC6
01C24:  POP     1BCC
01C26:  PUSH    1BC8
01C28:  POP     1BCE
....................  
....................    if (x < 0) 
01C2A:  MOV     1BC6,W0
01C2C:  MOV     1BC8,W1
01C2E:  MOV     #0,W2
01C30:  MOV     #0,W3
01C32:  CALL    1816
01C36:  BRA     NC,1C44
....................    { 
....................       s = 1; 
01C38:  BSET.B  1BCB.0
....................       y = -y; 
01C3A:  MOV     #1BCC,W0
01C3C:  MOV     #1BCC,W1
01C3E:  REPEAT  #3
01C40:  MOV     [W0++],[W1++]
01C42:  BTG.B   1BCF.7
....................    } 
....................  
....................    if (y <= 32768.0) 
01C44:  MOV     1BCC,W0
01C46:  MOV     1BCE,W1
01C48:  MOV     #0,W2
01C4A:  MOV     #4700,W3
01C4C:  CALL    1816
01C50:  BRA     C,1C54
01C52:  BRA     NZ,1C68
....................       res = (float32)(unsigned int16)y; 
01C54:  MOV     1BCC,W0
01C56:  MOV     1BCE,W1
01C58:  CALL    1948
01C5C:  CALL    1974
01C60:  MOV     W0,1BD0
01C62:  MOV     W1,1BD2
01C64:  GOTO    1CFC
....................  
....................  else if (y < 10000000.0) 
01C68:  MOV     1BCC,W0
01C6A:  MOV     1BCE,W1
01C6C:  MOV     #9680,W2
01C6E:  MOV     #4B18,W3
01C70:  CALL    1816
01C74:  BRA     NC,1CF4
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
01C76:  MOV     1BCC,W0
01C78:  MOV     1BCE,W1
01C7A:  MOV     #0,W2
01C7C:  MOV     #3800,W3
01C7E:  CALL    19AE
01C82:  CALL    1948
01C86:  MOV     W0,1BD4
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
01C88:  MOV     1BCC,W0
01C8A:  MOV     1BCE,W1
01C8C:  MOV     #0,W2
01C8E:  MOV     #3800,W3
01C90:  CALL    19AE
01C94:  MOV     W0,W5
01C96:  MOV     W1,W6
01C98:  MOV     1BD4,W0
01C9A:  CALL    1974
01C9E:  BSET.B  43.0
01CA0:  MOV     W0,W2
01CA2:  MOV     W1,W3
01CA4:  MOV     W5,W0
01CA6:  MOV     W6,W1
01CA8:  CALL    1A72
01CAC:  MOV     W0,W2
01CAE:  MOV     W1,W3
01CB0:  MOV     #0,W0
01CB2:  MOV     #4700,W1
01CB4:  CALL    19AE
01CB8:  MOV     W0,1BCC
01CBA:  MOV     W1,1BCE
....................       res = 32768.0*(float32)l; 
01CBC:  MOV     1BD4,W0
01CBE:  CALL    1974
01CC2:  MOV     W0,W2
01CC4:  MOV     W1,W3
01CC6:  MOV     #0,W0
01CC8:  MOV     #4700,W1
01CCA:  CALL    19AE
01CCE:  MOV     W0,1BD0
01CD0:  MOV     W1,1BD2
....................       res += (float32)(unsigned int16)y; 
01CD2:  MOV     1BCC,W0
01CD4:  MOV     1BCE,W1
01CD6:  CALL    1948
01CDA:  CALL    1974
01CDE:  BCLR.B  43.0
01CE0:  MOV     W0,W2
01CE2:  MOV     W1,W3
01CE4:  MOV     1BD0,W0
01CE6:  MOV     1BD2,W1
01CE8:  CALL    1A72
01CEC:  MOV     W0,1BD0
01CEE:  MOV     W1,1BD2
....................    } 
01CF0:  GOTO    1CFC
....................  
....................  else 
....................   res = y; 
01CF4:  PUSH    1BCC
01CF6:  POP     1BD0
01CF8:  PUSH    1BCE
01CFA:  POP     1BD2
....................  
....................  y = y - (float32)(unsigned int16)y; 
01CFC:  MOV     1BCC,W0
01CFE:  MOV     1BCE,W1
01D00:  CALL    1948
01D04:  CALL    1974
01D08:  BSET.B  43.0
01D0A:  MOV     W0,W2
01D0C:  MOV     W1,W3
01D0E:  MOV     1BCC,W0
01D10:  MOV     1BCE,W1
01D12:  CALL    1A72
01D16:  MOV     W0,1BCC
01D18:  MOV     W1,1BCE
....................  
....................  if (s) 
01D1A:  BTSS.B  1BCB.0
01D1C:  BRA     1D28
....................   res = -res; 
01D1E:  MOV     #1BD0,W0
01D20:  MOV     #1BD0,W1
01D22:  REPEAT  #3
01D24:  MOV     [W0++],[W1++]
01D26:  BTG.B   1BD3.7
....................  
....................  if (y != 0) 
01D28:  MOV     1BCC,W0
01D2A:  MOV     1BCE,W1
01D2C:  MOV     #0,W2
01D2E:  MOV     #0,W3
01D30:  CALL    1816
01D34:  BRA     Z,1D6C
....................  { 
....................   if (s == 1 && n == 0) 
01D36:  BTSS.B  1BCB.0
01D38:  BRA     1D50
01D3A:  CP0.B   1BCA
01D3C:  BRA     NZ,1D50
....................    res -= 1.0; 
01D3E:  BSET.B  43.0
01D40:  MOV     1BD0,W0
01D42:  MOV     1BD2,W1
01D44:  MOV     #0,W2
01D46:  MOV     #3F80,W3
01D48:  CALL    1A72
01D4C:  MOV     W0,1BD0
01D4E:  MOV     W1,1BD2
....................  
....................   if (s == 0 && n == 1) 
01D50:  BTSC.B  1BCB.0
01D52:  BRA     1D6C
01D54:  MOV     1BCA,W4
01D56:  CP.B    W4L,#1
01D58:  BRA     NZ,1D6C
....................    res += 1.0; 
01D5A:  BCLR.B  43.0
01D5C:  MOV     1BD0,W0
01D5E:  MOV     1BD2,W1
01D60:  MOV     #0,W2
01D62:  MOV     #3F80,W3
01D64:  CALL    1A72
01D68:  MOV     W0,1BD0
01D6A:  MOV     W1,1BD2
....................  } 
....................  if (x == 0) 
01D6C:  MOV     1BC6,W0
01D6E:  MOV     1BC8,W1
01D70:  MOV     #0,W2
01D72:  MOV     #0,W3
01D74:  CALL    1816
01D78:  BRA     NZ,1D7E
....................     res = 0; 
01D7A:  CLR     1BD0
01D7C:  CLR     1BD2
....................  
....................  return (res); 
01D7E:  MOV     1BD0,W0
01D80:  MOV     1BD2,W1
01D82:  MOV     [--W15],W6
01D84:  MOV     [--W15],W5
01D86:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
01D9C:  CLR.B   1BCA
01D9E:  PUSH    1BBA
01DA0:  POP     1BC6
01DA2:  PUSH    1BBC
01DA4:  POP     1BC8
01DA6:  CALL    1C1C
01DAA:  MOV.D   W0,W0
01DAC:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
01D88:  MOV.B   #1,W0L
01D8A:  MOV.B   W0L,1BCA
01D8C:  PUSH    1BBA
01D8E:  POP     1BC6
01D90:  PUSH    1BBC
01D92:  POP     1BC8
01D94:  CALL    1C1C
01D98:  MOV.D   W0,W0
01D9A:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
*
01DAE:  MOV     W5,[W15++]
01DB0:  MOV     W6,[W15++]
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
01DB2:  MOV     1BA4,W0
01DB4:  MOV     1BA6,W1
01DB6:  MOV     #0,W2
01DB8:  MOV     #0,W3
01DBA:  CALL    1816
01DBE:  BRA     Z,1E38
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
01DC0:  MOV     1BA0,W0
01DC2:  MOV     1BA2,W1
01DC4:  MOV     1BA4,W2
01DC6:  MOV     1BA6,W3
01DC8:  CALL    187E
01DCC:  MOV     W0,W5
01DCE:  MOV     W1,W6
01DD0:  MOV     W5,W0
01DD2:  MOV     W6,W1
01DD4:  MOV     #0,W2
01DD6:  MOV     #0,W3
01DD8:  CALL    1816
01DDC:  BRA     NC,1DFA
01DDE:  MOV     1BA0,W0
01DE0:  MOV     1BA2,W1
01DE2:  MOV     1BA4,W2
01DE4:  MOV     1BA6,W3
01DE6:  CALL    187E
01DEA:  MOV     W0,W5
01DEC:  MOV     W1,W6
01DEE:  MOV     W5,1BBA
01DF0:  MOV     W6,1BBC
01DF2:  CALL    1D88
01DF6:  GOTO    1E12
01DFA:  MOV     1BA0,W0
01DFC:  MOV     1BA2,W1
01DFE:  MOV     1BA4,W2
01E00:  MOV     1BA6,W3
01E02:  CALL    187E
01E06:  MOV     W0,W5
01E08:  MOV     W1,W6
01E0A:  MOV     W5,1BBA
01E0C:  MOV     W6,1BBC
01E0E:  CALL    1D9C
01E12:  MOV     W0,1BA8
01E14:  MOV     W1,1BAA
....................       return(x-(i*y)); 
01E16:  MOV     1BA8,W0
01E18:  MOV     1BAA,W1
01E1A:  MOV     1BA4,W2
01E1C:  MOV     1BA6,W3
01E1E:  CALL    19AE
01E22:  BSET.B  43.0
01E24:  MOV     W0,W2
01E26:  MOV     W1,W3
01E28:  MOV     1BA0,W0
01E2A:  MOV     1BA2,W1
01E2C:  CALL    1A72
01E30:  MOV.D   W0,W0
01E32:  BRA     1E38
....................    } 
01E34:  GOTO    1E38
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
01E38:  MOV     [--W15],W6
01E3A:  MOV     [--W15],W5
01E3C:  RETURN  
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
*
01FF0:  MOV     W5,[W15++]
01FF2:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
01FF4:  MOV     1BA0,W0
01FF6:  MOV     1BA2,W1
01FF8:  MOV     #AA3B,W2
01FFA:  MOV     #3FB8,W3
01FFC:  CALL    19AE
02000:  CALL    1948
02004:  MOV.B   W0L,1BB1
....................    s = 0; 
02006:  BCLR.B  1BB2.0
....................    y = x; 
02008:  PUSH    1BA0
0200A:  POP     1BA4
0200C:  PUSH    1BA2
0200E:  POP     1BA6
....................  
....................    if (x < 0) 
02010:  MOV     1BA0,W0
02012:  MOV     1BA2,W1
02014:  MOV     #0,W2
02016:  MOV     #0,W3
02018:  CALL    1816
0201C:  BRA     NC,2034
....................    { 
....................       s = 1; 
0201E:  BSET.B  1BB2.0
....................       n = -n; 
02020:  MOV     #0,W4
02022:  MOV     1BB0,W3
02024:  LSR     W3,#8,W3
02026:  SUB.B   W4L,W3L,W0L
02028:  MOV.B   W0L,1BB1
....................       y = -y; 
0202A:  MOV     #1BA4,W0
0202C:  MOV     #1BA4,W1
0202E:  REPEAT  #3
02030:  MOV     [W0++],[W1++]
02032:  BTG.B   1BA7.7
....................    } 
....................  
....................    res = 0.0; 
02034:  CLR     1BA8
02036:  CLR     1BAA
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
02038:  MOV.B   1BB1,W0L
0203A:  SE      W0,W0
0203C:  ADD     #7F,W0
0203E:  MOV.B   W0L,1BB0
....................    if(bit_test(data1,0)) 
02040:  BTSS.B  1BB0.0
02042:  BRA     2052
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
02044:  MOV     #1BA8,W5
02046:  ADD     W5,#2,W5
02048:  MOV     W5,W0
0204A:  MOV     W0,W5
0204C:  MOV.B   [W5],W4L
0204E:  IOR.B   #80,W4L
02050:  MOV.B   W4L,[W5+#0]
....................    rotate_right(&data1,1); 
02052:  MOV     #1BB0,W1
02054:  RRNC.B  [W1],[W1--]
....................    bit_clear(data1,7); 
02056:  MOV     #1BB0,W4
02058:  BCLR    [W4].7
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
0205A:  MOV     #1BA8,W5
0205C:  ADD     W5,#3,W5
0205E:  MOV     W5,W0
02060:  MOV     W0,W5
02062:  MOV     1BB0,W0
02064:  MOV.B   W0L,[W5+#0]
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
02066:  MOV     1BA4,W0
02068:  MOV     1BA6,W1
0206A:  MOV     #AA3B,W2
0206C:  MOV     #3FB8,W3
0206E:  CALL    19AE
02072:  MOV     W0,W5
02074:  MOV     W1,W6
02076:  MOV.B   1BB1,W0L
02078:  SE      W0,W0
0207A:  CALL    17CC
0207E:  BSET.B  43.0
02080:  MOV     W0,W2
02082:  MOV     W1,W3
02084:  MOV     W5,W0
02086:  MOV     W6,W1
02088:  CALL    1A72
0208C:  MOV     W0,1BA4
0208E:  MOV     W1,1BA6
....................  
....................    r = pe[0]*y + pe[1]; 
02090:  MOV     #887C,W0
02092:  MOV     #3959,W1
02094:  MOV     1BA4,W2
02096:  MOV     1BA6,W3
02098:  CALL    19AE
0209C:  MOV     W0,W5
0209E:  MOV     W1,W6
020A0:  BCLR.B  43.0
020A2:  MOV     W5,W0
020A4:  MOV     W6,W1
020A6:  MOV     #97E0,W2
020A8:  MOV     #3AA6,W3
020AA:  CALL    1A72
020AE:  MOV     W0,1BAC
020B0:  MOV     W1,1BAE
....................    r = r*y + pe[2]; 
020B2:  MOV     1BAC,W0
020B4:  MOV     1BAE,W1
020B6:  MOV     1BA4,W2
020B8:  MOV     1BA6,W3
020BA:  CALL    19AE
020BE:  MOV     W0,W5
020C0:  MOV     W1,W6
020C2:  BCLR.B  43.0
020C4:  MOV     W5,W0
020C6:  MOV     W6,W1
020C8:  MOV     #1DC4,W2
020CA:  MOV     #3C1E,W3
020CC:  CALL    1A72
020D0:  MOV     W0,1BAC
020D2:  MOV     W1,1BAE
....................    r = r*y + pe[3]; 
020D4:  MOV     1BAC,W0
020D6:  MOV     1BAE,W1
020D8:  MOV     1BA4,W2
020DA:  MOV     1BA6,W3
020DC:  CALL    19AE
020E0:  MOV     W0,W5
020E2:  MOV     W1,W6
020E4:  BCLR.B  43.0
020E6:  MOV     W5,W0
020E8:  MOV     W6,W1
020EA:  MOV     #505E,W2
020EC:  MOV     #3D63,W3
020EE:  CALL    1A72
020F2:  MOV     W0,1BAC
020F4:  MOV     W1,1BAE
....................    r = r*y + pe[4]; 
020F6:  MOV     1BAC,W0
020F8:  MOV     1BAE,W1
020FA:  MOV     1BA4,W2
020FC:  MOV     1BA6,W3
020FE:  CALL    19AE
02102:  MOV     W0,W5
02104:  MOV     W1,W6
02106:  BCLR.B  43.0
02108:  MOV     W5,W0
0210A:  MOV     W6,W1
0210C:  MOV     #FE1A,W2
0210E:  MOV     #3E75,W3
02110:  CALL    1A72
02114:  MOV     W0,1BAC
02116:  MOV     W1,1BAE
....................    r = r*y + pe[5]; 
02118:  MOV     1BAC,W0
0211A:  MOV     1BAE,W1
0211C:  MOV     1BA4,W2
0211E:  MOV     1BA6,W3
02120:  CALL    19AE
02124:  MOV     W0,W5
02126:  MOV     W1,W6
02128:  BCLR.B  43.0
0212A:  MOV     W5,W0
0212C:  MOV     W6,W1
0212E:  MOV     #7218,W2
02130:  MOV     #3F31,W3
02132:  CALL    1A72
02136:  MOV     W0,1BAC
02138:  MOV     W1,1BAE
....................  
....................    res = res*(1.0 + y*r); 
0213A:  MOV     1BA4,W0
0213C:  MOV     1BA6,W1
0213E:  MOV     1BAC,W2
02140:  MOV     1BAE,W3
02142:  CALL    19AE
02146:  BCLR.B  43.0
02148:  MOV     W0,W2
0214A:  MOV     W1,W3
0214C:  MOV     #0,W0
0214E:  MOV     #3F80,W1
02150:  CALL    1A72
02154:  MOV     W0,W2
02156:  MOV     W1,W3
02158:  MOV     1BA8,W0
0215A:  MOV     1BAA,W1
0215C:  CALL    19AE
02160:  MOV     W0,1BA8
02162:  MOV     W1,1BAA
....................  
....................    if (s) 
02164:  BTSS.B  1BB2.0
02166:  BRA     2178
....................       res = 1.0/res; 
02168:  MOV     #0,W0
0216A:  MOV     #3F80,W1
0216C:  MOV     1BA8,W2
0216E:  MOV     1BAA,W3
02170:  CALL    187E
02174:  MOV     W0,1BA8
02176:  MOV     W1,1BAA
....................    return(res); 
02178:  MOV     1BA8,W0
0217A:  MOV     1BAA,W1
0217C:  MOV     [--W15],W6
0217E:  MOV     [--W15],W5
02180:  RETURN  
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
*
01E3E:  MOV     W5,[W15++]
01E40:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
01E42:  PUSH    1BA0
01E44:  POP     1BA4
01E46:  PUSH    1BA2
01E48:  POP     1BA6
....................  
....................    if (y != 1.0) 
01E4A:  MOV     1BA4,W0
01E4C:  MOV     1BA6,W1
01E4E:  MOV     #0,W2
01E50:  MOV     #3F80,W3
01E52:  CALL    1816
01E56:  BRA     Z,1FE2
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
01E58:  MOV     #1BA4,W5
01E5A:  ADD     W5,#3,W5
01E5C:  MOV     W5,W0
01E5E:  MOV     W0,[W15++]
01E60:  MOV.B   [W0],W0L
01E62:  MOV.B   W0L,1BB5
01E64:  MOV     [--W15],W0
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
01E66:  MOV     #1BA4,W5
01E68:  ADD     W5,#3,W5
01E6A:  MOV     W5,W0
01E6C:  MOV     W0,W5
01E6E:  MOV.B   #3F,W0L
01E70:  MOV.B   W0L,[W5]
....................    data1 = *(((unsigned int8 *)(&y))+2); 
01E72:  MOV     #1BA4,W5
01E74:  ADD     W5,#2,W5
01E76:  MOV     W5,W0
01E78:  MOV     1BB4,W4
01E7A:  MOV.B   [W0+#0],W4L
01E7C:  MOV     W4,1BB4
....................    bit_clear(data1,7); 
01E7E:  MOV     #1BB4,W4
01E80:  BCLR    [W4].7
....................    *(((unsigned int8 *)(&y))+2) = data1; 
01E82:  MOV     #1BA4,W5
01E84:  ADD     W5,#2,W5
01E86:  MOV     W5,W0
01E88:  MOV     W0,W5
01E8A:  MOV     1BB4,W0
01E8C:  MOV.B   W0L,[W5+#0]
....................    if(bit_test(data2,7)) 
01E8E:  BTSS.B  1BB5.7
01E90:  BRA     1EA0
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
01E92:  MOV     #1BA4,W5
01E94:  ADD     W5,#3,W5
01E96:  MOV     W5,W0
01E98:  MOV     W0,W5
01E9A:  MOV.B   [W5],W4L
01E9C:  IOR.B   #80,W4L
01E9E:  MOV.B   W4L,[W5+#0]
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
01EA0:  BSET.B  43.0
01EA2:  MOV     1BA4,W0
01EA4:  MOV     1BA6,W1
01EA6:  MOV     #0,W2
01EA8:  MOV     #3F80,W3
01EAA:  CALL    1A72
01EAE:  MOV     W0,W5
01EB0:  MOV     W1,W6
01EB2:  BCLR.B  43.0
01EB4:  MOV     1BA4,W0
01EB6:  MOV     1BA6,W1
01EB8:  MOV     #0,W2
01EBA:  MOV     #3F80,W3
01EBC:  CALL    1A72
01EC0:  MOV     W0,W2
01EC2:  MOV     W1,W3
01EC4:  MOV     W5,W0
01EC6:  MOV     W6,W1
01EC8:  CALL    187E
01ECC:  MOV     W0,1BA4
01ECE:  MOV     W1,1BA6
....................  
....................       y2=y*y; 
01ED0:  MOV     1BA4,W0
01ED2:  MOV     1BA6,W1
01ED4:  MOV     1BA4,W2
01ED6:  MOV     1BA6,W3
01ED8:  CALL    19AE
01EDC:  MOV     W0,1BB0
01EDE:  MOV     W1,1BB2
....................  
....................       res = pl[0]*y2 + pl[1]; 
01EE0:  MOV     #4799,W0
01EE2:  MOV     #BF8A,W1
01EE4:  MOV     1BB0,W2
01EE6:  MOV     1BB2,W3
01EE8:  CALL    19AE
01EEC:  MOV     W0,W5
01EEE:  MOV     W1,W6
01EF0:  BCLR.B  43.0
01EF2:  MOV     W5,W0
01EF4:  MOV     W6,W1
01EF6:  MOV     #0,W2
01EF8:  MOV     #4000,W3
01EFA:  CALL    1A72
01EFE:  MOV     W0,1BA8
01F00:  MOV     W1,1BAA
....................  
....................       r = ql[0]*y2 + ql[1]; 
01F02:  MOV     #F34C,W0
01F04:  MOV     #3DBA,W1
01F06:  MOV     1BB0,W2
01F08:  MOV     1BB2,W3
01F0A:  CALL    19AE
01F0E:  MOV     W0,W5
01F10:  MOV     W1,W6
01F12:  BCLR.B  43.0
01F14:  MOV     W5,W0
01F16:  MOV     W6,W1
01F18:  MOV     #9D2B,W2
01F1A:  MOV     #BF5F,W3
01F1C:  CALL    1A72
01F20:  MOV     W0,1BAC
01F22:  MOV     W1,1BAE
....................       r = r*y2 + 1.0; 
01F24:  MOV     1BAC,W0
01F26:  MOV     1BAE,W1
01F28:  MOV     1BB0,W2
01F2A:  MOV     1BB2,W3
01F2C:  CALL    19AE
01F30:  MOV     W0,W5
01F32:  MOV     W1,W6
01F34:  BCLR.B  43.0
01F36:  MOV     W5,W0
01F38:  MOV     W6,W1
01F3A:  MOV     #0,W2
01F3C:  MOV     #3F80,W3
01F3E:  CALL    1A72
01F42:  MOV     W0,1BAC
01F44:  MOV     W1,1BAE
....................  
....................       res = y*res/r; 
01F46:  MOV     1BA4,W0
01F48:  MOV     1BA6,W1
01F4A:  MOV     1BA8,W2
01F4C:  MOV     1BAA,W3
01F4E:  CALL    19AE
01F52:  MOV     W0,W5
01F54:  MOV     W1,W6
01F56:  MOV     W5,W0
01F58:  MOV     W6,W1
01F5A:  MOV     1BAC,W2
01F5C:  MOV     1BAE,W3
01F5E:  CALL    187E
01F62:  MOV     W0,1BA8
01F64:  MOV     W1,1BAA
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
01F66:  MOV     #1BA0,W5
01F68:  ADD     W5,#3,W5
01F6A:  MOV     W5,W0
01F6C:  MOV     1BB4,W4
01F6E:  MOV.B   [W0+#0],W4L
01F70:  MOV     W4,1BB4
....................     rotate_left(&data1,1); 
01F72:  MOV     #1BB4,W1
01F74:  RLNC.B  [W1],[W1++]
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
01F76:  MOV     #1BA0,W5
01F78:  ADD     W5,#2,W5
01F7A:  MOV     W5,W0
01F7C:  MOV     W0,[W15++]
01F7E:  MOV.B   [W0],W0L
01F80:  MOV.B   W0L,1BB5
01F82:  MOV     [--W15],W0
....................     if(bit_test (data2,7)) 
01F84:  BTSS.B  1BB5.7
01F86:  BRA     1F8C
....................       bit_set(data1,0); 
01F88:  MOV     #1BB4,W4
01F8A:  BSET    [W4].0
....................     n = data1 - 0x7E; 
01F8C:  MOV     1BB4,W4
01F8E:  CLR.B   9
01F90:  MOV     #7E,W3
01F92:  SUB     W4,W3,W0
01F94:  MOV.B   W0L,1BB6
.................... #endif 
....................  
....................       if (n<0)  
01F96:  MOV.B   1BB6,W0L
01F98:  SE      W0,W0
01F9A:  CP      W0,#0
01F9C:  BRA     GE,1FB4
....................          r = -(float32)-n; 
01F9E:  MOV     #0,W4
01FA0:  MOV     1BB6,W3
01FA2:  SUB.B   W4L,W3L,W0L
01FA4:  SE      W0,W0
01FA6:  CALL    17CC
01FAA:  MOV     W0,1BAC
01FAC:  MOV     W1,1BAE
01FAE:  BTG.B   1BAF.7
01FB0:  GOTO    1FC0
....................       else 
....................          r = (float32)n; 
01FB4:  MOV.B   1BB6,W0L
01FB6:  SE      W0,W0
01FB8:  CALL    17CC
01FBC:  MOV     W0,1BAC
01FBE:  MOV     W1,1BAE
....................  
....................       res += r*LN2; 
01FC0:  MOV     1BAC,W0
01FC2:  MOV     1BAE,W1
01FC4:  MOV     #7218,W2
01FC6:  MOV     #3F31,W3
01FC8:  CALL    19AE
01FCC:  BCLR.B  43.0
01FCE:  MOV     W0,W2
01FD0:  MOV     W1,W3
01FD2:  MOV     1BA8,W0
01FD4:  MOV     1BAA,W1
01FD6:  CALL    1A72
01FDA:  MOV     W0,1BA8
01FDC:  MOV     W1,1BAA
....................    } 
01FDE:  GOTO    1FE6
....................  
....................    else 
....................       res = 0.0; 
01FE2:  CLR     1BA8
01FE4:  CLR     1BAA
....................  
....................    return(res); 
01FE6:  MOV     1BA8,W0
01FE8:  MOV     1BAA,W1
01FEA:  MOV     [--W15],W6
01FEC:  MOV     [--W15],W5
01FEE:  RETURN  
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
*
02182:  MOV     W5,[W15++]
02184:  MOV     W6,[W15++]
02186:  MOV     W7,[W15++]
02188:  MOV     W8,[W15++]
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
0218A:  MOV     1B8C,W0
0218C:  MOV     1B8E,W1
0218E:  MOV     #0,W2
02190:  MOV     #0,W3
02192:  CALL    1816
02196:  BRA     NC,2248
02198:  PUSH    1B90
0219A:  POP     1BA0
0219C:  PUSH    1B92
0219E:  POP     1BA2
021A0:  CLR     1BA4
021A2:  MOV     #3F80,W4
021A4:  MOV     W4,1BA6
021A6:  CALL    1DAE
021AA:  MOV     W0,W7
021AC:  MOV     W1,W8
021AE:  MOV     W7,W0
021B0:  MOV     W8,W1
021B2:  MOV     #0,W2
021B4:  MOV     #0,W3
021B6:  CALL    1816
021BA:  BRA     NZ,2248
....................       if(fmod(y, 2) == 0) { 
021BC:  PUSH    1B90
021BE:  POP     1BA0
021C0:  PUSH    1B92
021C2:  POP     1BA2
021C4:  CLR     1BA4
021C6:  MOV     #4000,W4
021C8:  MOV     W4,1BA6
021CA:  CALL    1DAE
021CE:  MOV     W0,W7
021D0:  MOV     W1,W8
021D2:  MOV     W7,W0
021D4:  MOV     W8,W1
021D6:  MOV     #0,W2
021D8:  MOV     #0,W3
021DA:  CALL    1816
021DE:  BRA     NZ,2212
....................          return (exp(log(-x) * y)); 
021E0:  MOV     1B8C,W5
021E2:  MOV     1B8E,W6
021E4:  BTG     W6.F
021E6:  MOV     W5,1BA0
021E8:  MOV     W6,1BA2
021EA:  CALL    1E3E
021EE:  MOV     W0,W5
021F0:  MOV     W1,W6
021F2:  MOV     W5,W0
021F4:  MOV     W6,W1
021F6:  MOV     1B90,W2
021F8:  MOV     1B92,W3
021FA:  CALL    19AE
021FE:  MOV     W0,W5
02200:  MOV     W1,W6
02202:  MOV     W5,1BA0
02204:  MOV     W6,1BA2
02206:  CALL    1FF0
0220A:  MOV.D   W0,W0
0220C:  BRA     22CE
....................       } else { 
0220E:  GOTO    2244
....................          return (-exp(log(-x) * y)); 
02212:  MOV     1B8C,W5
02214:  MOV     1B8E,W6
02216:  BTG     W6.F
02218:  MOV     W5,1BA0
0221A:  MOV     W6,1BA2
0221C:  CALL    1E3E
02220:  MOV     W0,W5
02222:  MOV     W1,W6
02224:  MOV     W5,W0
02226:  MOV     W6,W1
02228:  MOV     1B90,W2
0222A:  MOV     1B92,W3
0222C:  CALL    19AE
02230:  MOV     W0,W5
02232:  MOV     W1,W6
02234:  MOV     W5,1BA0
02236:  MOV     W6,1BA2
02238:  CALL    1FF0
0223C:  MOV.D   W0,W0
0223E:  BTG     W1.F
02240:  MOV.D   W0,W0
02242:  BRA     22CE
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
02244:  GOTO    22CE
02248:  MOV     1B8C,W0
0224A:  MOV     1B8E,W1
0224C:  MOV     #0,W2
0224E:  MOV     #0,W3
02250:  CALL    1816
02254:  BRA     NC,2284
02256:  PUSH    1B90
02258:  POP     1BA0
0225A:  PUSH    1B92
0225C:  POP     1BA2
0225E:  CLR     1BA4
02260:  MOV     #3F80,W4
02262:  MOV     W4,1BA6
02264:  CALL    1DAE
02268:  MOV     W0,W7
0226A:  MOV     W1,W8
0226C:  MOV     W7,W0
0226E:  MOV     W8,W1
02270:  MOV     #0,W2
02272:  MOV     #0,W3
02274:  CALL    1816
02278:  BRA     Z,2284
....................       return 0; 
0227A:  MOV     #0,W0
0227C:  MOV     #0,W1
0227E:  BRA     22CE
....................    } else { 
02280:  GOTO    22CE
....................       if(x != 0 || 0 >= y) { 
02284:  MOV     1B8C,W0
02286:  MOV     1B8E,W1
02288:  MOV     #0,W2
0228A:  MOV     #0,W3
0228C:  CALL    1816
02290:  BRA     NZ,22A2
02292:  MOV     1B90,W0
02294:  MOV     1B92,W1
02296:  MOV     #0,W2
02298:  MOV     #0,W3
0229A:  CALL    1816
0229E:  BRA     C,22A2
022A0:  BRA     NZ,22CE
....................          return (exp(log(x) * y)); 
022A2:  PUSH    1B8C
022A4:  POP     1BA0
022A6:  PUSH    1B8E
022A8:  POP     1BA2
022AA:  CALL    1E3E
022AE:  MOV     W0,W5
022B0:  MOV     W1,W6
022B2:  MOV     W5,W0
022B4:  MOV     W6,W1
022B6:  MOV     1B90,W2
022B8:  MOV     1B92,W3
022BA:  CALL    19AE
022BE:  MOV     W0,W5
022C0:  MOV     W1,W6
022C2:  MOV     W5,1BA0
022C4:  MOV     W6,1BA2
022C6:  CALL    1FF0
022CA:  MOV.D   W0,W0
022CC:  BRA     22CE
....................       } 
....................    } 
022CE:  MOV     [--W15],W8
022D0:  MOV     [--W15],W7
022D2:  MOV     [--W15],W6
022D4:  MOV     [--W15],W5
022D6:  RETURN  
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
022D8:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
022DA:  MOV     1B88,W0
022DC:  MOV     1B8A,W1
022DE:  MOV     #0,W2
022E0:  MOV     #0,W3
022E2:  CALL    1816
022E6:  BRA     C,22EA
022E8:  BRA     NZ,22F0
....................       return(0.0); 
022EA:  MOV     #0,W0
022EC:  MOV     #0,W1
022EE:  BRA     23DE
....................  
....................    y=x; 
022F0:  PUSH    1B88
022F2:  POP     1B8C
022F4:  PUSH    1B8A
022F6:  POP     1B8E
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
022F8:  MOV     #1B8C,W5
022FA:  ADD     W5,#3,W5
022FC:  MOV     W5,1B98
....................     data1 = *(((unsigned int8 *)(&y))+3); 
022FE:  MOV     #1B8C,W5
02300:  ADD     W5,#3,W5
02302:  MOV     W5,W0
02304:  MOV     1B94,W4
02306:  MOV.B   [W0+#0],W4L
02308:  MOV     W4,1B94
0230A:  CLR.B   1B95
....................     data2 = *(((unsigned int8 *)(&y))+2); 
0230C:  MOV     #1B8C,W5
0230E:  ADD     W5,#2,W5
02310:  MOV     W5,W0
02312:  MOV     1B96,W4
02314:  MOV.B   [W0+#0],W4L
02316:  MOV     W4,1B96
02318:  CLR.B   1B97
....................     rotate_left(&data1,1);     
0231A:  MOV     #1B94,W1
0231C:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
0231E:  BTSS.B  1B96.7
02320:  BRA     2326
....................        bit_set(data1,0);     
02322:  MOV     #1B94,W4
02324:  BSET    [W4].0
....................     data1 = ((data1+127) >>1); 
02326:  MOV     #7F,W4
02328:  MOV     1B94,W3
0232A:  ADD     W3,W4,W5
0232C:  MOV     W5,1B94
0232E:  LSR     1B94
....................     bit_clear(data2,7); 
02330:  MOV     #1B96,W4
02332:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
02334:  BTSS.B  1B94.0
02336:  BRA     233C
....................        bit_set(data2,7); 
02338:  MOV     #1B96,W4
0233A:  BSET    [W4].7
....................     data1 = data1 >>1; 
0233C:  LSR     1B94
....................     *(((unsigned int8 *)(&y))+3) = data1; 
0233E:  MOV     #1B8C,W5
02340:  ADD     W5,#3,W5
02342:  MOV     W5,W0
02344:  MOV     W0,W5
02346:  MOV     1B94,W0
02348:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
0234A:  MOV     #1B8C,W5
0234C:  ADD     W5,#2,W5
0234E:  MOV     W5,W0
02350:  MOV     W0,W5
02352:  MOV     1B96,W0
02354:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
02356:  PUSH    1B8C
02358:  POP     1B90
0235A:  PUSH    1B8E
0235C:  POP     1B92
....................       y+=(x/y); 
0235E:  MOV     1B88,W0
02360:  MOV     1B8A,W1
02362:  MOV     1B8C,W2
02364:  MOV     1B8E,W3
02366:  CALL    187E
0236A:  BCLR.B  43.0
0236C:  MOV     W0,W2
0236E:  MOV     W1,W3
02370:  MOV     1B8C,W0
02372:  MOV     1B8E,W1
02374:  CALL    1A72
02378:  MOV     W0,1B8C
0237A:  MOV     W1,1B8E
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
0237C:  MOV     #1B8C,W5
0237E:  ADD     W5,#3,W5
02380:  MOV     W5,W0
02382:  MOV     1B94,W4
02384:  MOV.B   [W0+#0],W4L
02386:  MOV     W4,1B94
02388:  CLR.B   1B95
....................     data2 = *(((unsigned int8 *)(&y))+2); 
0238A:  MOV     #1B8C,W5
0238C:  ADD     W5,#2,W5
0238E:  MOV     W5,W0
02390:  MOV     1B96,W4
02392:  MOV.B   [W0+#0],W4L
02394:  MOV     W4,1B96
02396:  CLR.B   1B97
....................     rotate_left(&data1,1); 
02398:  MOV     #1B94,W1
0239A:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
0239C:  BTSS.B  1B96.7
0239E:  BRA     23A4
....................        bit_set(data1,0);     
023A0:  MOV     #1B94,W4
023A2:  BSET    [W4].0
....................     data1--; 
023A4:  DEC     1B94
....................     bit_clear(data2,7); 
023A6:  MOV     #1B96,W4
023A8:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
023AA:  BTSS.B  1B94.0
023AC:  BRA     23B2
....................        bit_set(data2,7); 
023AE:  MOV     #1B96,W4
023B0:  BSET    [W4].7
....................     data1 = data1 >>1; 
023B2:  LSR     1B94
....................     *(((unsigned int8 *)(&y))+3) = data1; 
023B4:  MOV     #1B8C,W5
023B6:  ADD     W5,#3,W5
023B8:  MOV     W5,W0
023BA:  MOV     W0,W5
023BC:  MOV     1B94,W0
023BE:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
023C0:  MOV     #1B8C,W5
023C2:  ADD     W5,#2,W5
023C4:  MOV     W5,W0
023C6:  MOV     W0,W5
023C8:  MOV     1B96,W0
023CA:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
023CC:  MOV     1B90,W0
023CE:  MOV     1B92,W1
023D0:  MOV     1B8C,W2
023D2:  MOV     1B8E,W3
023D4:  CALL    1816
023D8:  BRA     NZ,2356
....................  
....................    return(res); 
023DA:  MOV     1B90,W0
023DC:  MOV     1B92,W1
023DE:  MOV     [--W15],W5
023E0:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
*
06DD6:  MOV     W5,[W15++]
06DD8:  MOV     W6,[W15++]
06DDA:  MOV     W7,[W15++]
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
06DDC:  MOV     1C04,W0
06DDE:  MOV     1C06,W1
06DE0:  MOV     1C08,W2
06DE2:  MOV     1C0A,W3
06DE4:  MOV     #0,W4
06DE6:  MOV     #0,W5
06DE8:  MOV     #0,W6
06DEA:  MOV     #0,W7
06DEC:  CALL    6724
06DF0:  BRA     C,6DF4
06DF2:  BRA     NZ,6DFE
....................       return(0.0); 
06DF4:  MOV     #0,W0
06DF6:  MOV     #0,W1
06DF8:  MOV     #0,W2
06DFA:  MOV     #0,W3
06DFC:  BRA     6EEC
....................  
....................    y=x; 
06DFE:  PUSH    1C04
06E00:  POP     1C0C
06E02:  PUSH    1C06
06E04:  POP     1C0E
06E06:  PUSH    1C08
06E08:  POP     1C10
06E0A:  PUSH    1C0A
06E0C:  POP     1C12
....................    p= (((unsigned int16 *)(&y))+3); 
06E0E:  MOV     #1C0C,W5
06E10:  ADD     W5,#6,W5
06E12:  MOV     W5,1C1C
....................    temp1 = *p; 
06E14:  MOV     1C1C,W0
06E16:  MOV     [W0],[W15++]
06E18:  POP     1C1E
....................    temp2 = *p; 
06E1A:  MOV     1C1C,W0
06E1C:  MOV     [W0],[W15++]
06E1E:  POP     1C20
....................    bit_clear(temp1,15); 
06E20:  MOV     #1C1E,W4
06E22:  BCLR    [W4].F
....................    temp1 = (temp1>>4)+1023; 
06E24:  MOV     1C1E,W5
06E26:  LSR     W5,#4,W5
06E28:  MOV     #3FF,W4
06E2A:  ADD     W5,W4,W0
06E2C:  MOV     W0,1C1E
....................    temp1 = temp1 >> 1; 
06E2E:  LSR     1C1E
....................    temp1 = (temp1<<4) & 0xFFF0; 
06E30:  MOV     1C1E,W5
06E32:  SL      W5,#4,W5
06E34:  MOV     #FFF0,W0
06E36:  AND     W0,W5,W0
06E38:  MOV     W0,1C1E
....................    if(bit_test(temp2,15)) 
06E3A:  BTSS.B  1C21.7
06E3C:  BRA     6E42
....................       bit_set(temp1,15); 
06E3E:  MOV     #1C1E,W4
06E40:  BSET    [W4].F
....................    temp2 = temp2 & 0x000F; 
06E42:  MOV     1C20,W0
06E44:  AND     W0,#F,W0
06E46:  MOV     W0,1C20
....................    temp1 ^= temp2; 
06E48:  MOV     1C20,W0
06E4A:  XOR     1C1E
....................     
....................    (*p) = temp1; 
06E4C:  MOV     1C1C,W5
06E4E:  MOV     1C1E,W4
06E50:  MOV     W4,[W5+#0]
....................     
....................    do { 
....................       res=y; 
06E52:  PUSH    1C0C
06E54:  POP     1C14
06E56:  PUSH    1C0E
06E58:  POP     1C16
06E5A:  PUSH    1C10
06E5C:  POP     1C18
06E5E:  PUSH    1C12
06E60:  POP     1C1A
....................       y+=(x/y); 
06E62:  MOV     1C04,W0
06E64:  MOV     1C06,W1
06E66:  MOV     1C08,W2
06E68:  MOV     1C0A,W3
06E6A:  MOV     1C0C,W4
06E6C:  MOV     1C0E,W5
06E6E:  MOV     1C10,W6
06E70:  MOV     1C12,W7
06E72:  CALL    CDA
06E76:  BCLR.B  43.0
06E78:  MOV     W0,W4
06E7A:  MOV     W1,W5
06E7C:  MOV     W2,W6
06E7E:  MOV     W3,W7
06E80:  MOV     1C0C,W0
06E82:  MOV     1C0E,W1
06E84:  MOV     1C10,W2
06E86:  MOV     1C12,W3
06E88:  CALL    6536
06E8C:  MOV     W0,1C0C
06E8E:  MOV     W1,1C0E
06E90:  MOV     W2,1C10
06E92:  MOV     W3,1C12
....................      temp1 = *p; 
06E94:  MOV     1C1C,W0
06E96:  MOV     [W0],[W15++]
06E98:  POP     1C1E
....................      temp2 = *p; 
06E9A:  MOV     1C1C,W0
06E9C:  MOV     [W0],[W15++]
06E9E:  POP     1C20
....................      bit_clear(temp1,15); 
06EA0:  MOV     #1C1E,W4
06EA2:  BCLR    [W4].F
....................      temp1 = (temp1>>4); 
06EA4:  MOV     1C1E,W0
06EA6:  LSR     W0,#4,W0
06EA8:  MOV     W0,1C1E
....................      temp1--; 
06EAA:  DEC     1C1E
....................      temp1 = (temp1<<4) & 0xFFF0; 
06EAC:  MOV     1C1E,W5
06EAE:  SL      W5,#4,W5
06EB0:  MOV     #FFF0,W0
06EB2:  AND     W0,W5,W0
06EB4:  MOV     W0,1C1E
....................      if(bit_test(temp2,15)) 
06EB6:  BTSS.B  1C21.7
06EB8:  BRA     6EBE
....................         bit_set(temp1,15); 
06EBA:  MOV     #1C1E,W4
06EBC:  BSET    [W4].F
....................      temp2 = temp2 & 0x000F; 
06EBE:  MOV     1C20,W0
06EC0:  AND     W0,#F,W0
06EC2:  MOV     W0,1C20
....................      temp1 ^= temp2; 
06EC4:  MOV     1C20,W0
06EC6:  XOR     1C1E
....................      (*p) = temp1; 
06EC8:  MOV     1C1C,W5
06ECA:  MOV     1C1E,W4
06ECC:  MOV     W4,[W5+#0]
....................  
....................    } while(res != y); 
06ECE:  MOV     1C14,W0
06ED0:  MOV     1C16,W1
06ED2:  MOV     1C18,W2
06ED4:  MOV     1C1A,W3
06ED6:  MOV     1C0C,W4
06ED8:  MOV     1C0E,W5
06EDA:  MOV     1C10,W6
06EDC:  MOV     1C12,W7
06EDE:  CALL    6724
06EE2:  BRA     NZ,6E52
....................  
....................    return(res); 
06EE4:  MOV     1C14,W0
06EE6:  MOV     1C16,W1
06EE8:  MOV     1C18,W2
06EEA:  MOV     1C1A,W3
06EEC:  MOV     [--W15],W7
06EEE:  MOV     [--W15],W6
06EF0:  MOV     [--W15],W5
06EF2:  RETURN  
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
*
081C6:  MOV     W5,[W15++]
081C8:  MOV     W6,[W15++]
081CA:  MOV     W7,[W15++]
081CC:  MOV     W8,[W15++]
081CE:  CLR     1B94
081D0:  CLR     1B96
081D2:  CLR     1B98
081D4:  MOV     #3FF0,W4
081D6:  MOV     W4,1B9A
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
081D8:  MOV     #FF1F,W4
081DA:  MOV     W4,1BA6
081DC:  SETM    1BA8
081DE:  SETM    1BAA
081E0:  MOV     #BFDF,W4
081E2:  MOV     W4,1BAC
081E4:  MOV     #1C35,W4
081E6:  MOV     W4,1BAE
081E8:  MOV     #5555,W4
081EA:  MOV     W4,1BB0
081EC:  MOV     #5555,W4
081EE:  MOV     W4,1BB2
081F0:  MOV     #3FA5,W4
081F2:  MOV     W4,1BB4
081F4:  MOV     #3F1C,W4
081F6:  MOV     W4,1BB6
081F8:  MOV     #16A7,W4
081FA:  MOV     W4,1BB8
081FC:  MOV     #C16C,W4
081FE:  MOV     W4,1BBA
08200:  MOV     #BF56,W4
08202:  MOV     W4,1BBC
08204:  MOV     #F3E6,W4
08206:  MOV     W4,1BBE
08208:  MOV     #D65,W4
0820A:  MOV     W4,1BC0
0820C:  MOV     #1A0,W4
0820E:  MOV     W4,1BC2
08210:  MOV     #3EFA,W4
08212:  MOV     W4,1BC4
08214:  MOV     #A3E,W4
08216:  MOV     W4,1BC6
08218:  MOV     #3931,W4
0821A:  MOV     W4,1BC8
0821C:  MOV     #7E4C,W4
0821E:  MOV     W4,1BCA
08220:  MOV     #BE92,W4
08222:  MOV     W4,1BCC
08224:  MOV     #DDFB,W4
08226:  MOV     W4,1BCE
08228:  MOV     #2B77,W4
0822A:  MOV     W4,1BD0
0822C:  MOV     #EDB1,W4
0822E:  MOV     W4,1BD2
08230:  MOV     #3E21,W4
08232:  MOV     W4,1BD4
08234:  MOV     #6FCC,W4
08236:  MOV     W4,1BD6
08238:  MOV     #8FF7,W4
0823A:  MOV     W4,1BD8
0823C:  MOV     #C610,W4
0823E:  MOV     W4,1BDA
08240:  MOV     #BDA8,W4
08242:  MOV     W4,1BDC
08244:  MOV     #124C,W4
08246:  MOV     W4,1BDE
08248:  MOV     #8E1C,W4
0824A:  MOV     W4,1BE0
0824C:  MOV     #3AF9,W4
0824E:  MOV     W4,1BE2
08250:  MOV     #3CF3,W4
08252:  MOV     W4,1BE4
08254:  MOV     #7676,W4
08256:  MOV     W4,1BE6
08258:  MOV     #350F,W4
0825A:  MOV     W4,1BE8
0825C:  MOV     #C0DE,W4
0825E:  MOV     W4,1BEA
08260:  MOV     #3CF0,W4
08262:  MOV     W4,1BEC
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
08264:  MOV     1B7C,W0
08266:  MOV     1B7E,W1
08268:  MOV     1B80,W2
0826A:  MOV     1B82,W3
0826C:  MOV     #0,W4
0826E:  MOV     #0,W5
08270:  MOV     #0,W6
08272:  MOV     #0,W7
08274:  CALL    6724
08278:  BRA     NC,8284
0827A:  MOV     #1B7C,W0
0827C:  MOV     #1B7C,W1
0827E:  REPEAT  #7
08280:  MOV     [W0++],[W1++]
08282:  BTG.B   1B83.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
08284:  MOV     1B7C,W0
08286:  MOV     1B7E,W1
08288:  MOV     1B80,W2
0828A:  MOV     1B82,W3
0828C:  MOV     #C884,W4
0828E:  MOV     #6DC9,W5
08290:  MOV     #5F30,W6
08292:  MOV     #3FE4,W7
08294:  CALL    BCA
08298:  CALL    8170
0829C:  MOV.B   W0L,1B9C
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
0829E:  MOV     1B7C,W0
082A0:  MOV     1B7E,W1
082A2:  MOV     1B80,W2
082A4:  MOV     1B82,W3
082A6:  MOV     #C884,W4
082A8:  MOV     #6DC9,W5
082AA:  MOV     #5F30,W6
082AC:  MOV     #3FE4,W7
082AE:  CALL    BCA
082B2:  MOV     W0,W5
082B4:  MOV     W1,W6
082B6:  MOV     W2,W7
082B8:  MOV     W3,W8
082BA:  MOV     #0,W1
082BC:  MOV     #0,W2
082BE:  MOV     #0,W3
082C0:  MOV.B   1B9C,W0L
082C2:  CLR.B   1
082C4:  CALL    805C
082C8:  BSET.B  43.0
082CA:  MOV     W5,[W15++]
082CC:  MOV     W6,[W15++]
082CE:  MOV     W7,[W15++]
082D0:  MOV     W0,W4
082D2:  MOV     W5,W0
082D4:  MOV     W1,W5
082D6:  MOV     W6,W1
082D8:  MOV     W2,W6
082DA:  MOV     W7,W2
082DC:  MOV     W3,W7
082DE:  MOV     W8,W3
082E0:  CALL    6536
082E4:  MOV     [--W15],W7
082E6:  MOV     [--W15],W6
082E8:  MOV     [--W15],W5
082EA:  MOV     W0,1B9E
082EC:  MOV     W1,1BA0
082EE:  MOV     W2,1BA2
082F0:  MOV     W3,1BA4
....................    quad = quad % 4;                    // quadrant (0 to 3) 
082F2:  MOV.B   1B9C,W0L
082F4:  AND.B   W0L,#3,W0L
082F6:  MOV.B   W0L,1B9C
....................  
....................    if (quad == 0 || quad == 2) 
082F8:  CP0.B   1B9C
082FA:  BRA     Z,8302
082FC:  MOV     1B9C,W4
082FE:  CP.B    W4L,#2
08300:  BRA     NZ,8322
....................       t = frac * PI_DIV_BY_TWO; 
08302:  MOV     1B9E,W0
08304:  MOV     1BA0,W1
08306:  MOV     1BA2,W2
08308:  MOV     1BA4,W3
0830A:  MOV     #2D18,W4
0830C:  MOV     #5444,W5
0830E:  MOV     #21FB,W6
08310:  MOV     #3FF9,W7
08312:  CALL    BCA
08316:  MOV     W0,1B8C
08318:  MOV     W1,1B8E
0831A:  MOV     W2,1B90
0831C:  MOV     W3,1B92
0831E:  GOTO    83B8
....................    else if (quad == 1) 
08322:  MOV     1B9C,W4
08324:  CP.B    W4L,#1
08326:  BRA     NZ,8372
....................       t = (1-frac) * PI_DIV_BY_TWO; 
08328:  BSET.B  43.0
0832A:  MOV     #0,W0
0832C:  MOV     #0,W1
0832E:  MOV     #0,W2
08330:  MOV     #3FF0,W3
08332:  MOV     1B9E,W4
08334:  MOV     1BA0,W5
08336:  MOV     1BA2,W6
08338:  MOV     1BA4,W7
0833A:  CALL    6536
0833E:  MOV     W0,W5
08340:  MOV     W1,W6
08342:  MOV     W2,W7
08344:  MOV     W3,W8
08346:  MOV     W5,[W15++]
08348:  MOV     W6,[W15++]
0834A:  MOV     W7,[W15++]
0834C:  MOV     W5,W0
0834E:  MOV     W6,W1
08350:  MOV     W7,W2
08352:  MOV     W8,W3
08354:  MOV     #2D18,W4
08356:  MOV     #5444,W5
08358:  MOV     #21FB,W6
0835A:  MOV     #3FF9,W7
0835C:  CALL    BCA
08360:  MOV     [--W15],W7
08362:  MOV     [--W15],W6
08364:  MOV     [--W15],W5
08366:  MOV     W0,1B8C
08368:  MOV     W1,1B8E
0836A:  MOV     W2,1B90
0836C:  MOV     W3,1B92
0836E:  GOTO    83B8
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
08372:  BSET.B  43.0
08374:  MOV     1B9E,W0
08376:  MOV     1BA0,W1
08378:  MOV     1BA2,W2
0837A:  MOV     1BA4,W3
0837C:  MOV     #0,W4
0837E:  MOV     #0,W5
08380:  MOV     #0,W6
08382:  MOV     #3FF0,W7
08384:  CALL    6536
08388:  MOV     W0,W5
0838A:  MOV     W1,W6
0838C:  MOV     W2,W7
0838E:  MOV     W3,W8
08390:  MOV     W5,[W15++]
08392:  MOV     W6,[W15++]
08394:  MOV     W7,[W15++]
08396:  MOV     W5,W0
08398:  MOV     W6,W1
0839A:  MOV     W7,W2
0839C:  MOV     W8,W3
0839E:  MOV     #2D18,W4
083A0:  MOV     #5444,W5
083A2:  MOV     #21FB,W6
083A4:  MOV     #3FF9,W7
083A6:  CALL    BCA
083AA:  MOV     [--W15],W7
083AC:  MOV     [--W15],W6
083AE:  MOV     [--W15],W5
083B0:  MOV     W0,1B8C
083B2:  MOV     W1,1B8E
083B4:  MOV     W2,1B90
083B6:  MOV     W3,1B92
....................  
....................    y = 1.0; 
083B8:  CLR     1B84
083BA:  CLR     1B86
083BC:  CLR     1B88
083BE:  MOV     #3FF0,W4
083C0:  MOV     W4,1B8A
....................    t = t * t; 
083C2:  MOV     1B8C,W0
083C4:  MOV     1B8E,W1
083C6:  MOV     1B90,W2
083C8:  MOV     1B92,W3
083CA:  MOV     1B8C,W4
083CC:  MOV     1B8E,W5
083CE:  MOV     1B90,W6
083D0:  MOV     1B92,W7
083D2:  CALL    BCA
083D6:  MOV     W0,1B8C
083D8:  MOV     W1,1B8E
083DA:  MOV     W2,1B90
083DC:  MOV     W3,1B92
....................    for (i = 0; i <= 8; i++) 
083DE:  CLR.B   1B9D
083E0:  MOV     1B9C,W4
083E2:  LSR     W4,#8,W4
083E4:  CP.B    W4L,#8
083E6:  BRA     GTU,8458
....................    { 
....................       t2 = t2 * t; 
083E8:  MOV     1B94,W0
083EA:  MOV     1B96,W1
083EC:  MOV     1B98,W2
083EE:  MOV     1B9A,W3
083F0:  MOV     1B8C,W4
083F2:  MOV     1B8E,W5
083F4:  MOV     1B90,W6
083F6:  MOV     1B92,W7
083F8:  CALL    BCA
083FC:  MOV     W0,1B94
083FE:  MOV     W1,1B96
08400:  MOV     W2,1B98
08402:  MOV     W3,1B9A
....................       y = y + p_64[i] * t2; 
08404:  MOV.B   1B9D,W0L
08406:  CLR.B   1
08408:  SL      W0,#3,W0
0840A:  MOV     #1BA6,W4
0840C:  ADD     W0,W4,W0
0840E:  MOV     #A,W4
08410:  REPEAT  #3
08412:  MOV     [W0++],[W4++]
08414:  MOV     W5,[W15++]
08416:  MOV     W6,[W15++]
08418:  MOV     W7,[W15++]
0841A:  MOV     W5,W0
0841C:  MOV     W6,W1
0841E:  MOV     W7,W2
08420:  MOV     W8,W3
08422:  MOV     1B94,W4
08424:  MOV     1B96,W5
08426:  MOV     1B98,W6
08428:  MOV     1B9A,W7
0842A:  CALL    BCA
0842E:  MOV     [--W15],W7
08430:  MOV     [--W15],W6
08432:  MOV     [--W15],W5
08434:  BCLR.B  43.0
08436:  MOV     W0,W4
08438:  MOV     W1,W5
0843A:  MOV     W2,W6
0843C:  MOV     W3,W7
0843E:  MOV     1B84,W0
08440:  MOV     1B86,W1
08442:  MOV     1B88,W2
08444:  MOV     1B8A,W3
08446:  CALL    6536
0844A:  MOV     W0,1B84
0844C:  MOV     W1,1B86
0844E:  MOV     W2,1B88
08450:  MOV     W3,1B8A
08452:  INC.B   1B9D
08454:  GOTO    83E0
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
08458:  MOV     1B9C,W4
0845A:  CP.B    W4L,#2
0845C:  BRA     Z,8464
0845E:  MOV     1B9C,W4
08460:  CP.B    W4L,#1
08462:  BRA     NZ,846E
....................       y = -y;  // correct sign 
08464:  MOV     #1B84,W0
08466:  MOV     #1B84,W1
08468:  REPEAT  #7
0846A:  MOV     [W0++],[W1++]
0846C:  BTG.B   1B8B.7
....................  
....................    return (y); 
0846E:  MOV     1B84,W0
08470:  MOV     1B86,W1
08472:  MOV     1B88,W2
08474:  MOV     1B8A,W3
08476:  MOV     [--W15],W8
08478:  MOV     [--W15],W7
0847A:  MOV     [--W15],W6
0847C:  MOV     [--W15],W5
0847E:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
08480:  MOV     W5,[W15++]
08482:  MOV     W6,[W15++]
08484:  MOV     W7,[W15++]
08486:  MOV     W8,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
08488:  BSET.B  43.0
0848A:  MOV     1B62,W0
0848C:  MOV     1B64,W1
0848E:  MOV     1B66,W2
08490:  MOV     1B68,W3
08492:  MOV     #2D18,W4
08494:  MOV     #5444,W5
08496:  MOV     #21FB,W6
08498:  MOV     #3FF9,W7
0849A:  CALL    6536
0849E:  MOV     W0,W5
084A0:  MOV     W1,W6
084A2:  MOV     W2,W7
084A4:  MOV     W3,W8
084A6:  MOV     W5,1B7C
084A8:  MOV     W6,1B7E
084AA:  MOV     W7,1B80
084AC:  MOV     W8,1B82
084AE:  CALL    81C6
084B2:  MOV     [--W15],W8
084B4:  MOV     [--W15],W7
084B6:  MOV     [--W15],W6
084B8:  MOV     [--W15],W5
084BA:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
*
06F4A:  MOV     W5,[W15++]
06F4C:  MOV     W6,[W15++]
06F4E:  MOV     W7,[W15++]
06F50:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
06F52:  BCLR.B  1BC9.0
....................    y = x; 
06F54:  PUSH    1BC0
06F56:  POP     1BCA
06F58:  PUSH    1BC2
06F5A:  POP     1BCC
06F5C:  PUSH    1BC4
06F5E:  POP     1BCE
06F60:  PUSH    1BC6
06F62:  POP     1BD0
....................  
....................    if (x < 0) 
06F64:  MOV     1BC0,W0
06F66:  MOV     1BC2,W1
06F68:  MOV     1BC4,W2
06F6A:  MOV     1BC6,W3
06F6C:  MOV     #0,W4
06F6E:  MOV     #0,W5
06F70:  MOV     #0,W6
06F72:  MOV     #0,W7
06F74:  CALL    6724
06F78:  BRA     NC,6F86
....................    { 
....................       s = 1; 
06F7A:  BSET.B  1BC9.0
....................       y = -y; 
06F7C:  MOV     #1BCA,W0
06F7E:  MOV     #1BCA,W1
06F80:  REPEAT  #7
06F82:  MOV     [W0++],[W1++]
06F84:  BTG.B   1BD1.7
....................    } 
....................  
....................    if (y > 0.5) 
06F86:  MOV     #0,W0
06F88:  MOV     #0,W1
06F8A:  MOV     #0,W2
06F8C:  MOV     #3FE0,W3
06F8E:  MOV     1BCA,W4
06F90:  MOV     1BCC,W5
06F92:  MOV     1BCE,W6
06F94:  MOV     1BD0,W7
06F96:  CALL    6724
06F9A:  BRA     NC,6FFE
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
06F9C:  BSET.B  43.0
06F9E:  MOV     #0,W0
06FA0:  MOV     #0,W1
06FA2:  MOV     #0,W2
06FA4:  MOV     #3FF0,W3
06FA6:  MOV     1BCA,W4
06FA8:  MOV     1BCC,W5
06FAA:  MOV     1BCE,W6
06FAC:  MOV     1BD0,W7
06FAE:  CALL    6536
06FB2:  MOV     W0,W5
06FB4:  MOV     W1,W6
06FB6:  MOV     W2,W7
06FB8:  MOV     W3,W8
06FBA:  MOV     W5,[W15++]
06FBC:  MOV     W6,[W15++]
06FBE:  MOV     W7,[W15++]
06FC0:  MOV     W5,W0
06FC2:  MOV     W6,W1
06FC4:  MOV     W7,W2
06FC6:  MOV     W8,W3
06FC8:  MOV     #0,W4
06FCA:  MOV     #0,W5
06FCC:  MOV     #0,W6
06FCE:  MOV     #3FE0,W7
06FD0:  CALL    BCA
06FD4:  MOV     [--W15],W7
06FD6:  MOV     [--W15],W6
06FD8:  MOV     [--W15],W5
06FDA:  MOV     W0,W5
06FDC:  MOV     W1,W6
06FDE:  MOV     W2,W7
06FE0:  MOV     W3,W8
06FE2:  MOV     W5,1C04
06FE4:  MOV     W6,1C06
06FE6:  MOV     W7,1C08
06FE8:  MOV     W8,1C0A
06FEA:  CALL    6DD6
06FEE:  MOV     W0,1BCA
06FF0:  MOV     W1,1BCC
06FF2:  MOV     W2,1BCE
06FF4:  MOV     W3,1BD0
....................       n += 2; 
06FF6:  MOV     1BC8,W4
06FF8:  ADD.B   W4L,#2,W4L
06FFA:  MOV.B   W4L,W0L
06FFC:  MOV.B   W0L,1BC8
....................    } 
....................  
....................    y2=y*y; 
06FFE:  MOV     1BCA,W0
07000:  MOV     1BCC,W1
07002:  MOV     1BCE,W2
07004:  MOV     1BD0,W3
07006:  MOV     1BCA,W4
07008:  MOV     1BCC,W5
0700A:  MOV     1BCE,W6
0700C:  MOV     1BD0,W7
0700E:  CALL    BCA
07012:  MOV     W0,1BE2
07014:  MOV     W1,1BE4
07016:  MOV     W2,1BE6
07018:  MOV     W3,1BE8
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
0701A:  MOV     14F2,W0
0701C:  MOV     14F4,W1
0701E:  MOV     14F6,W2
07020:  MOV     14F8,W3
07022:  MOV     1BE2,W4
07024:  MOV     1BE4,W5
07026:  MOV     1BE6,W6
07028:  MOV     1BE8,W7
0702A:  CALL    BCA
0702E:  MOV     W0,W5
07030:  MOV     W1,W6
07032:  MOV     W2,W7
07034:  MOV     W3,W8
07036:  BCLR.B  43.0
07038:  MOV     W5,[W15++]
0703A:  MOV     W6,[W15++]
0703C:  MOV     W7,[W15++]
0703E:  MOV     W5,W0
07040:  MOV     W6,W1
07042:  MOV     W7,W2
07044:  MOV     W8,W3
07046:  MOV     14EA,W4
07048:  MOV     14EC,W5
0704A:  MOV     14EE,W6
0704C:  MOV     14F0,W7
0704E:  CALL    6536
07052:  MOV     [--W15],W7
07054:  MOV     [--W15],W6
07056:  MOV     [--W15],W5
07058:  MOV     W0,1BD2
0705A:  MOV     W1,1BD4
0705C:  MOV     W2,1BD6
0705E:  MOV     W3,1BD8
....................    res = res*y2 + pas_64[2]; 
07060:  MOV     1BD2,W0
07062:  MOV     1BD4,W1
07064:  MOV     1BD6,W2
07066:  MOV     1BD8,W3
07068:  MOV     1BE2,W4
0706A:  MOV     1BE4,W5
0706C:  MOV     1BE6,W6
0706E:  MOV     1BE8,W7
07070:  CALL    BCA
07074:  MOV     W0,W5
07076:  MOV     W1,W6
07078:  MOV     W2,W7
0707A:  MOV     W3,W8
0707C:  BCLR.B  43.0
0707E:  MOV     W5,[W15++]
07080:  MOV     W6,[W15++]
07082:  MOV     W7,[W15++]
07084:  MOV     W5,W0
07086:  MOV     W6,W1
07088:  MOV     W7,W2
0708A:  MOV     W8,W3
0708C:  MOV     14E2,W4
0708E:  MOV     14E4,W5
07090:  MOV     14E6,W6
07092:  MOV     14E8,W7
07094:  CALL    6536
07098:  MOV     [--W15],W7
0709A:  MOV     [--W15],W6
0709C:  MOV     [--W15],W5
0709E:  MOV     W0,1BD2
070A0:  MOV     W1,1BD4
070A2:  MOV     W2,1BD6
070A4:  MOV     W3,1BD8
....................    res = res*y2 + pas_64[1]; 
070A6:  MOV     1BD2,W0
070A8:  MOV     1BD4,W1
070AA:  MOV     1BD6,W2
070AC:  MOV     1BD8,W3
070AE:  MOV     1BE2,W4
070B0:  MOV     1BE4,W5
070B2:  MOV     1BE6,W6
070B4:  MOV     1BE8,W7
070B6:  CALL    BCA
070BA:  MOV     W0,W5
070BC:  MOV     W1,W6
070BE:  MOV     W2,W7
070C0:  MOV     W3,W8
070C2:  BCLR.B  43.0
070C4:  MOV     W5,[W15++]
070C6:  MOV     W6,[W15++]
070C8:  MOV     W7,[W15++]
070CA:  MOV     W5,W0
070CC:  MOV     W6,W1
070CE:  MOV     W7,W2
070D0:  MOV     W8,W3
070D2:  MOV     14DA,W4
070D4:  MOV     14DC,W5
070D6:  MOV     14DE,W6
070D8:  MOV     14E0,W7
070DA:  CALL    6536
070DE:  MOV     [--W15],W7
070E0:  MOV     [--W15],W6
070E2:  MOV     [--W15],W5
070E4:  MOV     W0,1BD2
070E6:  MOV     W1,1BD4
070E8:  MOV     W2,1BD6
070EA:  MOV     W3,1BD8
....................    res = res*y2 + pas_64[0]; 
070EC:  MOV     1BD2,W0
070EE:  MOV     1BD4,W1
070F0:  MOV     1BD6,W2
070F2:  MOV     1BD8,W3
070F4:  MOV     1BE2,W4
070F6:  MOV     1BE4,W5
070F8:  MOV     1BE6,W6
070FA:  MOV     1BE8,W7
070FC:  CALL    BCA
07100:  MOV     W0,W5
07102:  MOV     W1,W6
07104:  MOV     W2,W7
07106:  MOV     W3,W8
07108:  BCLR.B  43.0
0710A:  MOV     W5,[W15++]
0710C:  MOV     W6,[W15++]
0710E:  MOV     W7,[W15++]
07110:  MOV     W5,W0
07112:  MOV     W6,W1
07114:  MOV     W7,W2
07116:  MOV     W8,W3
07118:  MOV     14D2,W4
0711A:  MOV     14D4,W5
0711C:  MOV     14D6,W6
0711E:  MOV     14D8,W7
07120:  CALL    6536
07124:  MOV     [--W15],W7
07126:  MOV     [--W15],W6
07128:  MOV     [--W15],W5
0712A:  MOV     W0,1BD2
0712C:  MOV     W1,1BD4
0712E:  MOV     W2,1BD6
07130:  MOV     W3,1BD8
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
07132:  MOV     151A,W0
07134:  MOV     151C,W1
07136:  MOV     151E,W2
07138:  MOV     1520,W3
0713A:  MOV     1BE2,W4
0713C:  MOV     1BE4,W5
0713E:  MOV     1BE6,W6
07140:  MOV     1BE8,W7
07142:  CALL    BCA
07146:  MOV     W0,W5
07148:  MOV     W1,W6
0714A:  MOV     W2,W7
0714C:  MOV     W3,W8
0714E:  BCLR.B  43.0
07150:  MOV     W5,[W15++]
07152:  MOV     W6,[W15++]
07154:  MOV     W7,[W15++]
07156:  MOV     W5,W0
07158:  MOV     W6,W1
0715A:  MOV     W7,W2
0715C:  MOV     W8,W3
0715E:  MOV     1512,W4
07160:  MOV     1514,W5
07162:  MOV     1516,W6
07164:  MOV     1518,W7
07166:  CALL    6536
0716A:  MOV     [--W15],W7
0716C:  MOV     [--W15],W6
0716E:  MOV     [--W15],W5
07170:  MOV     W0,1BDA
07172:  MOV     W1,1BDC
07174:  MOV     W2,1BDE
07176:  MOV     W3,1BE0
....................    r = r*y2 + qas_64[2]; 
07178:  MOV     1BDA,W0
0717A:  MOV     1BDC,W1
0717C:  MOV     1BDE,W2
0717E:  MOV     1BE0,W3
07180:  MOV     1BE2,W4
07182:  MOV     1BE4,W5
07184:  MOV     1BE6,W6
07186:  MOV     1BE8,W7
07188:  CALL    BCA
0718C:  MOV     W0,W5
0718E:  MOV     W1,W6
07190:  MOV     W2,W7
07192:  MOV     W3,W8
07194:  BCLR.B  43.0
07196:  MOV     W5,[W15++]
07198:  MOV     W6,[W15++]
0719A:  MOV     W7,[W15++]
0719C:  MOV     W5,W0
0719E:  MOV     W6,W1
071A0:  MOV     W7,W2
071A2:  MOV     W8,W3
071A4:  MOV     150A,W4
071A6:  MOV     150C,W5
071A8:  MOV     150E,W6
071AA:  MOV     1510,W7
071AC:  CALL    6536
071B0:  MOV     [--W15],W7
071B2:  MOV     [--W15],W6
071B4:  MOV     [--W15],W5
071B6:  MOV     W0,1BDA
071B8:  MOV     W1,1BDC
071BA:  MOV     W2,1BDE
071BC:  MOV     W3,1BE0
....................    r = r*y2 + qas_64[1]; 
071BE:  MOV     1BDA,W0
071C0:  MOV     1BDC,W1
071C2:  MOV     1BDE,W2
071C4:  MOV     1BE0,W3
071C6:  MOV     1BE2,W4
071C8:  MOV     1BE4,W5
071CA:  MOV     1BE6,W6
071CC:  MOV     1BE8,W7
071CE:  CALL    BCA
071D2:  MOV     W0,W5
071D4:  MOV     W1,W6
071D6:  MOV     W2,W7
071D8:  MOV     W3,W8
071DA:  BCLR.B  43.0
071DC:  MOV     W5,[W15++]
071DE:  MOV     W6,[W15++]
071E0:  MOV     W7,[W15++]
071E2:  MOV     W5,W0
071E4:  MOV     W6,W1
071E6:  MOV     W7,W2
071E8:  MOV     W8,W3
071EA:  MOV     1502,W4
071EC:  MOV     1504,W5
071EE:  MOV     1506,W6
071F0:  MOV     1508,W7
071F2:  CALL    6536
071F6:  MOV     [--W15],W7
071F8:  MOV     [--W15],W6
071FA:  MOV     [--W15],W5
071FC:  MOV     W0,1BDA
071FE:  MOV     W1,1BDC
07200:  MOV     W2,1BDE
07202:  MOV     W3,1BE0
....................    r = r*y2 + qas_64[0]; 
07204:  MOV     1BDA,W0
07206:  MOV     1BDC,W1
07208:  MOV     1BDE,W2
0720A:  MOV     1BE0,W3
0720C:  MOV     1BE2,W4
0720E:  MOV     1BE4,W5
07210:  MOV     1BE6,W6
07212:  MOV     1BE8,W7
07214:  CALL    BCA
07218:  MOV     W0,W5
0721A:  MOV     W1,W6
0721C:  MOV     W2,W7
0721E:  MOV     W3,W8
07220:  BCLR.B  43.0
07222:  MOV     W5,[W15++]
07224:  MOV     W6,[W15++]
07226:  MOV     W7,[W15++]
07228:  MOV     W5,W0
0722A:  MOV     W6,W1
0722C:  MOV     W7,W2
0722E:  MOV     W8,W3
07230:  MOV     14FA,W4
07232:  MOV     14FC,W5
07234:  MOV     14FE,W6
07236:  MOV     1500,W7
07238:  CALL    6536
0723C:  MOV     [--W15],W7
0723E:  MOV     [--W15],W6
07240:  MOV     [--W15],W5
07242:  MOV     W0,1BDA
07244:  MOV     W1,1BDC
07246:  MOV     W2,1BDE
07248:  MOV     W3,1BE0
....................    r = r*y2 + 1.0; 
0724A:  MOV     1BDA,W0
0724C:  MOV     1BDC,W1
0724E:  MOV     1BDE,W2
07250:  MOV     1BE0,W3
07252:  MOV     1BE2,W4
07254:  MOV     1BE4,W5
07256:  MOV     1BE6,W6
07258:  MOV     1BE8,W7
0725A:  CALL    BCA
0725E:  MOV     W0,W5
07260:  MOV     W1,W6
07262:  MOV     W2,W7
07264:  MOV     W3,W8
07266:  BCLR.B  43.0
07268:  MOV     W5,[W15++]
0726A:  MOV     W6,[W15++]
0726C:  MOV     W7,[W15++]
0726E:  MOV     W5,W0
07270:  MOV     W6,W1
07272:  MOV     W7,W2
07274:  MOV     W8,W3
07276:  MOV     #0,W4
07278:  MOV     #0,W5
0727A:  MOV     #0,W6
0727C:  MOV     #3FF0,W7
0727E:  CALL    6536
07282:  MOV     [--W15],W7
07284:  MOV     [--W15],W6
07286:  MOV     [--W15],W5
07288:  MOV     W0,1BDA
0728A:  MOV     W1,1BDC
0728C:  MOV     W2,1BDE
0728E:  MOV     W3,1BE0
....................  
....................    res = y*res/r; 
07290:  MOV     1BCA,W0
07292:  MOV     1BCC,W1
07294:  MOV     1BCE,W2
07296:  MOV     1BD0,W3
07298:  MOV     1BD2,W4
0729A:  MOV     1BD4,W5
0729C:  MOV     1BD6,W6
0729E:  MOV     1BD8,W7
072A0:  CALL    BCA
072A4:  MOV     W0,W5
072A6:  MOV     W1,W6
072A8:  MOV     W2,W7
072AA:  MOV     W3,W8
072AC:  MOV     W5,[W15++]
072AE:  MOV     W6,[W15++]
072B0:  MOV     W7,[W15++]
072B2:  MOV     W5,W0
072B4:  MOV     W6,W1
072B6:  MOV     W7,W2
072B8:  MOV     W8,W3
072BA:  MOV     1BDA,W4
072BC:  MOV     1BDC,W5
072BE:  MOV     1BDE,W6
072C0:  MOV     1BE0,W7
072C2:  CALL    CDA
072C6:  MOV     [--W15],W7
072C8:  MOV     [--W15],W6
072CA:  MOV     [--W15],W5
072CC:  MOV     W0,1BD2
072CE:  MOV     W1,1BD4
072D0:  MOV     W2,1BD6
072D2:  MOV     W3,1BD8
....................  
....................    if (n & 2)     // |x| > 0.5 
072D4:  MOV.B   1BC8,W0L
072D6:  CLR.B   1
072D8:  AND     W0,#2,W0
072DA:  CP0     W0
072DC:  BRA     Z,7310
....................       res = PI_DIV_BY_TWO - 2.0*res; 
072DE:  MOV     #0,W0
072E0:  MOV     #0,W1
072E2:  MOV     #0,W2
072E4:  MOV     #4000,W3
072E6:  MOV     1BD2,W4
072E8:  MOV     1BD4,W5
072EA:  MOV     1BD6,W6
072EC:  MOV     1BD8,W7
072EE:  CALL    BCA
072F2:  BSET.B  43.0
072F4:  MOV     W0,W4
072F6:  MOV     W1,W5
072F8:  MOV     W2,W6
072FA:  MOV     W3,W7
072FC:  MOV     #2D18,W0
072FE:  MOV     #5444,W1
07300:  MOV     #21FB,W2
07302:  MOV     #3FF9,W3
07304:  CALL    6536
07308:  MOV     W0,1BD2
0730A:  MOV     W1,1BD4
0730C:  MOV     W2,1BD6
0730E:  MOV     W3,1BD8
....................    if (s) 
07310:  BTSS.B  1BC9.0
07312:  BRA     731E
....................       res = -res; 
07314:  MOV     #1BD2,W0
07316:  MOV     #1BD2,W1
07318:  REPEAT  #7
0731A:  MOV     [W0++],[W1++]
0731C:  BTG.B   1BD9.7
....................    if (n & 1)           // take arccos 
0731E:  MOV.B   1BC8,W0L
07320:  CLR.B   1
07322:  AND     W0,#1,W0
07324:  CP0     W0
07326:  BRA     Z,7346
....................       res = PI_DIV_BY_TWO - res; 
07328:  BSET.B  43.0
0732A:  MOV     #2D18,W0
0732C:  MOV     #5444,W1
0732E:  MOV     #21FB,W2
07330:  MOV     #3FF9,W3
07332:  MOV     1BD2,W4
07334:  MOV     1BD4,W5
07336:  MOV     1BD6,W6
07338:  MOV     1BD8,W7
0733A:  CALL    6536
0733E:  MOV     W0,1BD2
07340:  MOV     W1,1BD4
07342:  MOV     W2,1BD6
07344:  MOV     W3,1BD8
....................  
....................    return(res); 
07346:  MOV     1BD2,W0
07348:  MOV     1BD4,W1
0734A:  MOV     1BD6,W2
0734C:  MOV     1BD8,W3
0734E:  MOV     [--W15],W8
07350:  MOV     [--W15],W7
07352:  MOV     [--W15],W6
07354:  MOV     [--W15],W5
07356:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
07358:  CLR.B   1BC8
0735A:  PUSH    1BA0
0735C:  POP     1BC0
0735E:  PUSH    1BA2
07360:  POP     1BC2
07362:  PUSH    1BA4
07364:  POP     1BC4
07366:  PUSH    1BA6
07368:  POP     1BC6
0736A:  CALL    6F4A
0736E:  MOV     W0,1BA8
07370:  MOV     W1,1BAA
07372:  MOV     W2,1BAC
07374:  MOV     W3,1BAE
....................    return(r); 
07376:  MOV     1BA8,W0
07378:  MOV     1BAA,W1
0737A:  MOV     1BAC,W2
0737C:  MOV     1BAE,W3
0737E:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
07380:  MOV.B   #1,W0L
07382:  MOV.B   W0L,1BC8
07384:  PUSH    1BA0
07386:  POP     1BC0
07388:  PUSH    1BA2
0738A:  POP     1BC2
0738C:  PUSH    1BA4
0738E:  POP     1BC4
07390:  PUSH    1BA6
07392:  POP     1BC6
07394:  CALL    6F4A
07398:  MOV     W0,1BA8
0739A:  MOV     W1,1BAA
0739C:  MOV     W2,1BAC
0739E:  MOV     W3,1BAE
....................    return(r); 
073A0:  MOV     1BA8,W0
073A2:  MOV     1BAA,W1
073A4:  MOV     1BAC,W2
073A6:  MOV     1BAE,W3
073A8:  RETURN  
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
00674:  MOV     W5,[W15++]
00676:  MOV     W6,[W15++]
00678:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0067A:  CLR     1D76
....................    sign = 0; 
0067C:  CLR     1D72
....................    base = 10; 
0067E:  MOV     #A,W4
00680:  MOV     W4,1D74
....................    result = 0; 
00682:  CLR     1D6E
00684:  CLR     1D70
....................  
....................    if (!s) 
00686:  CP0     1D6C
00688:  BRA     NZ,690
....................       return 0; 
0068A:  MOV     #0,W0
0068C:  MOV     #0,W1
0068E:  BRA     862
....................    c = s[index++]; 
00690:  MOV     1D76,W0
00692:  INC     1D76
00694:  MOV     W0,W5
00696:  MOV     W5,W0
00698:  ADD     1D6C,W0
0069A:  MOV     1D78,W4
0069C:  MOV.B   [W0+#0],W4L
0069E:  MOV     W4,1D78
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
006A0:  MOV     1D78,W4
006A2:  XOR.B   #2D,W4L
006A4:  BRA     NZ,6BE
....................    { 
....................       sign = 1;         // Set the sign to negative 
006A6:  MOV     #1,W4
006A8:  MOV     W4,1D72
....................       c = s[index++]; 
006AA:  MOV     1D76,W0
006AC:  INC     1D76
006AE:  MOV     W0,W5
006B0:  MOV     W5,W0
006B2:  ADD     1D6C,W0
006B4:  MOV     1D78,W4
006B6:  MOV.B   [W0+#0],W4L
006B8:  MOV     W4,1D78
....................    } 
006BA:  GOTO    6D4
....................    else if (c == '+') 
006BE:  MOV     1D78,W4
006C0:  XOR.B   #2B,W4L
006C2:  BRA     NZ,6D4
....................    { 
....................       c = s[index++]; 
006C4:  MOV     1D76,W0
006C6:  INC     1D76
006C8:  MOV     W0,W5
006CA:  MOV     W5,W0
006CC:  ADD     1D6C,W0
006CE:  MOV     1D78,W4
006D0:  MOV.B   [W0+#0],W4L
006D2:  MOV     W4,1D78
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
006D4:  MOV     1D78,W4
006D6:  MOV     #30,W3
006D8:  CP.B    W3L,W4L
006DA:  BRA     GT,842
006DC:  MOV     1D78,W4
006DE:  MOV     #39,W3
006E0:  CP.B    W3L,W4L
006E2:  BRA     LT,842
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
006E4:  MOV     1D78,W4
006E6:  XOR.B   #30,W4L
006E8:  BRA     NZ,714
006EA:  MOV     1D76,W0
006EC:  ADD     1D6C,W0
006EE:  MOV.B   [W0],W4L
006F0:  XOR.B   #78,W4L
006F2:  BRA     Z,6FE
006F4:  MOV     1D76,W0
006F6:  ADD     1D6C,W0
006F8:  MOV.B   [W0],W4L
006FA:  XOR.B   #58,W4L
006FC:  BRA     NZ,714
....................       { 
....................          base = 16; 
006FE:  MOV     #10,W4
00700:  MOV     W4,1D74
....................          index++; 
00702:  INC     1D76
....................          c = s[index++]; 
00704:  MOV     1D76,W0
00706:  INC     1D76
00708:  MOV     W0,W5
0070A:  MOV     W5,W0
0070C:  ADD     1D6C,W0
0070E:  MOV     1D78,W4
00710:  MOV.B   [W0+#0],W4L
00712:  MOV     W4,1D78
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
00714:  MOV     1D74,W4
00716:  CP      W4,#A
00718:  BRA     NZ,76A
....................       { 
....................          while (c >= '0' && c <= '9') 
0071A:  MOV     1D78,W4
0071C:  MOV     #30,W3
0071E:  CP.B    W3L,W4L
00720:  BRA     GT,766
00722:  MOV     1D78,W4
00724:  MOV     #39,W3
00726:  CP.B    W3L,W4L
00728:  BRA     LT,766
....................          { 
....................             result = 10*result + (c - '0'); 
0072A:  MOV     #A,W0
0072C:  MOV     #0,W1
0072E:  MOV     1D6E,W2
00730:  MOV     1D70,W3
00732:  CALL    632
00736:  MOV     W0,W5
00738:  MOV     W1,W6
0073A:  MOV     1D78,W4
0073C:  SUB.B   #30,W4L
0073E:  MOV.B   W4L,W0L
00740:  MOV.B   W0L,0
00742:  SE      W0,W0
00744:  CLR     W1
00746:  BTSC    W0.F
00748:  SETM    W1
0074A:  ADD     W0,W5,W0
0074C:  MOV     W0,1D6E
0074E:  ADDC    W1,W6,W0
00750:  MOV     W0,1D70
....................             c = s[index++]; 
00752:  MOV     1D76,W0
00754:  INC     1D76
00756:  MOV     W0,W5
00758:  MOV     W5,W0
0075A:  ADD     1D6C,W0
0075C:  MOV     1D78,W4
0075E:  MOV.B   [W0+#0],W4L
00760:  MOV     W4,1D78
00762:  GOTO    71A
....................          } 
....................       } 
00766:  GOTO    842
....................       else if (base == 16)    // The number is a hexa number 
0076A:  MOV     1D74,W4
0076C:  CP      W4,#10
0076E:  BRA     NZ,842
....................       { 
....................          c = toupper(c); 
00770:  MOV     1D78,W4
00772:  MOV     #61,W3
00774:  CP.B    W3L,W4L
00776:  BRA     GTU,786
00778:  MOV     1D78,W4
0077A:  MOV     #7A,W3
0077C:  CP.B    W3L,W4L
0077E:  BRA     NC,786
00780:  MOV.B   1D78,W0L
00782:  AND.B   #DF,W0L
00784:  BRA     788
00786:  MOV.B   1D78,W0L
00788:  MOV.B   W0L,1D78
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
0078A:  MOV     1D78,W4
0078C:  MOV     #30,W3
0078E:  CP.B    W3L,W4L
00790:  BRA     GT,79C
00792:  MOV     1D78,W4
00794:  MOV     #39,W3
00796:  CP.B    W3L,W4L
00798:  BRA     LT,79C
0079A:  BRA     7AC
0079C:  MOV     1D78,W4
0079E:  MOV     #41,W3
007A0:  CP.B    W3L,W4L
007A2:  BRA     GT,842
007A4:  MOV     1D78,W4
007A6:  MOV     #46,W3
007A8:  CP.B    W3L,W4L
007AA:  BRA     LT,842
....................          { 
....................             if (c >= '0' && c <= '9') 
007AC:  MOV     1D78,W4
007AE:  MOV     #30,W3
007B0:  CP.B    W3L,W4L
007B2:  BRA     GT,7EA
007B4:  MOV     1D78,W4
007B6:  MOV     #39,W3
007B8:  CP.B    W3L,W4L
007BA:  BRA     LT,7EA
....................                result = (result << 4) + (c - '0'); 
007BC:  MOV     #4,W4
007BE:  MOV     1D6E,W5
007C0:  MOV     1D70,W6
007C2:  INC     W4,W4
007C4:  DEC     W4,W4
007C6:  BRA     Z,7CE
007C8:  SL      W5,W5
007CA:  RLC     W6,W6
007CC:  BRA     7C4
007CE:  MOV     1D78,W4
007D0:  SUB.B   #30,W4L
007D2:  MOV.B   W4L,W0L
007D4:  MOV.B   W0L,0
007D6:  SE      W0,W0
007D8:  CLR     W1
007DA:  BTSC    W0.F
007DC:  SETM    W1
007DE:  ADD     W0,W5,W0
007E0:  MOV     W0,1D6E
007E2:  ADDC    W1,W6,W0
007E4:  MOV     W0,1D70
007E6:  GOTO    814
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
007EA:  MOV     #4,W4
007EC:  MOV     1D6E,W5
007EE:  MOV     1D70,W6
007F0:  INC     W4,W4
007F2:  DEC     W4,W4
007F4:  BRA     Z,7FC
007F6:  SL      W5,W5
007F8:  RLC     W6,W6
007FA:  BRA     7F2
007FC:  MOV     1D78,W4
007FE:  SUB.B   #41,W4L
00800:  MOV.B   W4L,W0L
00802:  MOV.B   W0L,0
00804:  ZE      W0,W0
00806:  CLR.B   1
00808:  ADD     W0,#A,W0
0080A:  ADD     W0,W5,W0
0080C:  MOV     W0,1D6E
0080E:  MOV     #0,W4
00810:  ADDC    W4,W6,W0
00812:  MOV     W0,1D70
....................  
....................             c = s[index++];c = toupper(c); 
00814:  MOV     1D76,W0
00816:  INC     1D76
00818:  MOV     W0,W5
0081A:  MOV     W5,W0
0081C:  ADD     1D6C,W0
0081E:  MOV     1D78,W4
00820:  MOV.B   [W0+#0],W4L
00822:  MOV     W4,1D78
00824:  MOV     1D78,W4
00826:  MOV     #61,W3
00828:  CP.B    W3L,W4L
0082A:  BRA     GTU,83A
0082C:  MOV     1D78,W4
0082E:  MOV     #7A,W3
00830:  CP.B    W3L,W4L
00832:  BRA     NC,83A
00834:  MOV.B   1D78,W0L
00836:  AND.B   #DF,W0L
00838:  BRA     83C
0083A:  MOV.B   1D78,W0L
0083C:  MOV.B   W0L,1D78
0083E:  GOTO    78A
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
00842:  MOV     1D74,W4
00844:  CP      W4,#A
00846:  BRA     NZ,85E
00848:  MOV     1D72,W4
0084A:  CP      W4,#1
0084C:  BRA     NZ,85E
....................       result = -result; 
0084E:  MOV     #0,W4
00850:  MOV     1D6E,W3
00852:  SUB     W4,W3,W0
00854:  MOV     W0,1D6E
00856:  MOV     #0,W4
00858:  MOV     1D70,W3
0085A:  SUBB    W4,W3,W0
0085C:  MOV     W0,1D70
....................  
....................    return(result); 
0085E:  MOV     1D6E,W0
00860:  MOV     1D70,W1
00862:  MOV     [--W15],W7
00864:  MOV     [--W15],W6
00866:  MOV     [--W15],W5
00868:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "servomoteur/servomoteur.h" 
.................... #ifndef _SERVOMOTEUR_H 
.................... #define _SERVOMOTEUR_H 
....................  
.................... // Nombre de servomoteurs (0  MAXSERVO-1) 
.................... #DEFINE MAXSERVO 1 
.................... // Valeurs min et max de l'impulsion en [100us] pour la protection des servomoteurs 
.................... #DEFINE MINSERVOPOSITION 9 
.................... #DEFINE MAXSERVOPOSITION 20 
.................... // Normalement 9 et 21 pour 900us et 2.1ms 
....................  
.................... // Structure pour la gestion des servomoteurs 
.................... struct T_Servo{ 
.................... 	int Position; 
.................... 	int Count; 
.................... 	int OpenValue; 
.................... 	int CloseValue; 
.................... }; 
....................  
.................... struct T_Servo ServoTab[MAXSERVO]; 
....................  
.................... void MoveServo(int number, int position); 
.................... void SetServo(int number, int state); 
.................... void OpenServo(int number); 
.................... void CloseServo(int number); 
.................... void CheckServo(); 
.................... void __Init_Servos(); 
....................  
.................... #include "servomoteur/servomoteur.c" 
.................... ///============================================================================================ 
.................... ///	void MoveServo(int number, int position) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de modifier la valeur de consigne (l'angle) d'un servomoteur 
.................... ///	Position dfini la longueur de l'impulsion en [100us] 
.................... ///============================================================================================ 
.................... void MoveServo(int number, int position) 
.................... { 
.................... 	// Protection pour ne pas bloquer le servo en bute 
.................... 	if(position < MINSERVOPOSITION) 
.................... 		position = MINSERVOPOSITION; 
.................... 	 
.................... 	if (position > MAXSERVOPOSITION) 
.................... 		position = MAXSERVOPOSITION; 
.................... 	// Dfinition de position du servomoteur 
.................... 	ServoTab[number].Position = position; 
.................... 	 
.................... 	enable_interrupts(INT_TIMER2); 
.................... 	delay_ms(500); 
.................... 	disable_interrupts(INT_TIMER2); 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void SetServo(int number, int state) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de dfinir la sortie propre  chaque servomoteur 
.................... ///	output_bit() demande l'adresse du bit utilis (par exemple avec un "#define PIN_A3 5651") 
.................... ///============================================================================================ 
.................... void SetServo(int number, int state) 
.................... { 
.................... 	switch (number) 
*
004A4:  MOV     1D7E,W0
004A6:  XOR     #0,W0
004A8:  BRA     Z,4AC
004AA:  BRA     4BC
.................... 	{ 
.................... 		case 0:		// Pour le servomoteur droit 
.................... 			output_bit(PIN_D4,state);	 
004AC:  CP0     1D80
004AE:  BRA     NZ,4B4
004B0:  BCLR.B  2D6.4
004B2:  BRA     4B6
004B4:  BSET.B  2D6.4
004B6:  BCLR.B  2D2.4
.................... 			break; 
004B8:  GOTO    4C0
.................... 		default : 
.................... 			break; 
004BC:  GOTO    4C0
.................... 	} 
004C0:  RETURN  
.................... 	 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void CheckServo() 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Gre la commande des servomoteurs 
.................... ///	Doit tre appel toutes les 100us 
.................... ///============================================================================================ 
.................... void CheckServo() 
004C2:  MOV     W5,[W15++]
004C4:  MOV     W6,[W15++]
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
004C6:  CLR     1D7A
004C8:  MOV     1D7A,W4
004CA:  CP      W4,#1
004CC:  BRA     GE,55C
.................... 	{ 
.................... 		if(ServoTab[i].Count<ServoTab[i].Position) 
004CE:  MOV     1D7A,W4
004D0:  MUL.UU  W4,#8,W0
004D2:  MOV     W0,W5
004D4:  ADD     W5,#2,W5
004D6:  MOV     W5,W0
004D8:  MOV     #1588,W4
004DA:  ADD     W0,W4,W0
004DC:  MOV     [W0],W5
004DE:  MOV     1D7A,W4
004E0:  MUL.UU  W4,#8,W6
004E2:  MOV     #1588,W4
004E4:  ADD     W6,W4,W0
004E6:  MOV     W0,W4
004E8:  MOV     [W4],W0
004EA:  CP      W5,W0
004EC:  BRA     GE,50E
.................... 		{ 
.................... 			// Ton 
.................... 			SetServo(i,1); 
004EE:  PUSH    1D7A
004F0:  POP     1D7E
004F2:  MOV     #1,W4
004F4:  MOV     W4,1D80
004F6:  CALL    4A4
.................... 			ServoTab[i].Count++; 
004FA:  MOV     1D7A,W4
004FC:  MUL.UU  W4,#8,W0
004FE:  MOV     W0,W5
00500:  ADD     W5,#2,W5
00502:  MOV     W5,W0
00504:  MOV     #1588,W4
00506:  ADD     W0,W4,W5
00508:  INC     [W5],[W5]
.................... 		}  
0050A:  GOTO    556
.................... 		else  
.................... 		{ 
.................... 			if(ServoTab[i].Count<197)  
0050E:  MOV     1D7A,W4
00510:  MUL.UU  W4,#8,W0
00512:  MOV     W0,W5
00514:  ADD     W5,#2,W5
00516:  MOV     W5,W0
00518:  MOV     #1588,W4
0051A:  ADD     W0,W4,W0
0051C:  MOV     [W0],W5
0051E:  MOV     #C5,W4
00520:  CP      W4,W5
00522:  BRA     LE,542
.................... 			{ 
.................... 				// Toff 
.................... 				SetServo(i,0); 
00524:  PUSH    1D7A
00526:  POP     1D7E
00528:  CLR     1D80
0052A:  CALL    4A4
.................... 				ServoTab[i].Count++; 
0052E:  MOV     1D7A,W4
00530:  MUL.UU  W4,#8,W0
00532:  MOV     W0,W5
00534:  ADD     W5,#2,W5
00536:  MOV     W5,W0
00538:  MOV     #1588,W4
0053A:  ADD     W0,W4,W5
0053C:  INC     [W5],[W5]
.................... 			}  
0053E:  GOTO    556
.................... 			else  
.................... 			{ 
.................... 				// Fin de la priode 
.................... 				ServoTab[i].Count = 0; 
00542:  MOV     1D7A,W4
00544:  MUL.UU  W4,#8,W0
00546:  MOV     W0,W5
00548:  ADD     W5,#2,W5
0054A:  MOV     W5,W0
0054C:  MOV     #1588,W4
0054E:  ADD     W0,W4,W5
00550:  CLR.B   [W5]
00552:  MOV.B   #0,W0L
00554:  MOV.B   W0L,[W5+#1]
.................... 			} 
.................... 		} 
00556:  INC     1D7A
00558:  GOTO    4C8
.................... 	} 
0055C:  MOV     [--W15],W6
0055E:  MOV     [--W15],W5
00560:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void OpenServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Dplace un servomoteur  sa position ouverte dfinie avec ServoTab[x].OpenValue 
.................... ///============================================================================================ 
.................... void OpenServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].OpenValue); 
.................... } 
.................... ///============================================================================================ 
.................... /// void CloseServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Dplace un servomoteur  sa position ferme dfinie avec ServoTab[x].CloseValue 
.................... ///============================================================================================ 
.................... void CloseServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].CloseValue); 
.................... } 
....................  
.................... ///	Initialisation de la structure des servomoteurs: 
.................... void __Init_Servos(void) 
.................... { 
.................... 	unsigned int8 i=0; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
.................... 	{ 
.................... 		ServoTab[i].Position = 0; 
.................... 		ServoTab[i].Count = 0; 
.................... 	} 
....................  
.................... 	///	Configuration du TIMER2 pour 100us: 
.................... ///-------------------------------------------------------------------- 
.................... 	setup_timer2(TMR_INTERNAL, 1973); 
.................... 	// 1/((80MHz)/4)*1*2000 = 100us 
.................... 	enable_interrupts(INT_TIMER2); 
.................... } 
....................  
.................... ///	Interruption TIMER2 
.................... ///-------------------------------------------------------------------- 
.................... 	#INT_TIMER2 HIGH 
.................... 	void timer2_isr() 
00562:  PUSH    42
00564:  PUSH    36
00566:  PUSH    32
00568:  MOV     W0,[W15++]
0056A:  MOV     #2,W0
0056C:  REPEAT  #C
0056E:  MOV     [W0++],[W15++]
.................... 	{ 
.................... 		set_timer2(0); 
00570:  CLR     106
.................... 		CheckServo(); 
00572:  CALL    4C2
.................... 	} 
....................  
....................  
.................... #endif 
....................  
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS - PRINCIPE 
.................... ///==================================================================== 
.................... /// 
.................... ///	Le but est de gnrer des sorties pour la commandes de servomoteurs. 
.................... ///	Les sorties sont mises  jour chaque 100us grce au TIMER2. 
.................... ///	Les impulsions de commande sont envoyes en continu. 
.................... /// 
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS  - UTILISATION 
.................... ///==================================================================== 
.................... /// 
.................... ///	MAXSERVO permet de dfinir le nombre de servomoteurs utiliss 
.................... ///	MINSERVOPOSITION et MAXSERVOPOSITION fixent les valeurs min et max 
.................... ///	des impulsions  gnrer pour la commande des servomoteurs, en 
.................... ///	gnral on se limite  900us (9) et 2.1ms (21) 
.................... /// 
.................... ///	CheckServo(): gre la commande des servomoteurs,  appeler toutes 
.................... ///	toutes les 100us 
.................... /// 
.................... ///	MoveServo(number, position): permet de modifier la valeur de consigne 
.................... ///	d'un servomoteur 
.................... /// 
.................... ///	SetServo(numer, state): utilis par CheckServo(), le switch case 
.................... ///	permet de dfinir les sorties propres  chaque servomoteurs. 
....................  
.................... #include "LCD/___LCD.h" 
.................... /* 
.................... * \file ___LCD.h 
.................... * \brief Gre l'afficheur LCD I2C (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_H 
00576:  BCLR.B  84.6
00578:  MOV     #1A,W0
0057A:  REPEAT  #C
0057C:  MOV     [--W15],[W0--]
0057E:  MOV     [--W15],W0
00580:  POP     32
00582:  POP     36
00584:  POP     42
00586:  RETFIE  
.................... #define ___LCD_H 
....................  
.................... void __Init_LCD(void); // Init LCD 
.................... void __ClearLCD(void);	// Efface l'cran 
.................... void __WriteLCD(unsigned int8 _Command);	// Ecrit la commande  
.................... void __WriteCount(float64 _Value, int1 _Mode);	// Ecrit une valeur, int32 si mode = 0, float si mode = 1 
.................... void __SautLig(unsigned int8 _Lig);	// Saute d'une ligne sur l'cran 
....................  
.................... #include "LCD/___LCD.c" 
.................... /* 
.................... * \file ___LCD.c 
.................... * \brief Gre l'afficheur LCD I2C (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_C 
.................... #define ___LCD_C 
....................  
.................... void __Init_LCD(void) 
.................... { 
.................... 	// Config LCD IIC 
.................... 	i2c_start(); 
.................... 	i2c_write(0x50);	// Adresse du LCD 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x52);	// Contraste 
.................... 	i2c_write(0x24);	// 36 sur 50 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x53);	// Brightness backlight 
.................... 	i2c_write(6);		// 6 sur 8 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x51);	// Efface l'cran 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __ClearLCD 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __ClearLCD(void) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Clear le LCD 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x51); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteLCD 
.................... // Ecrit ou envoi une commande au LCD. 
.................... // Prend quoi crire. 
.................... // Ne retourne rien. 
.................... void __WriteLCD(unsigned int8 _Command) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
.................... unsigned int8 ack=i2c_write(0x50); 
.................... 	// Se connecte au LCD 
.................... 	if(ack==0) 
.................... 	// Ecrit ou envoi la comande au LCD 
.................... 	i2c_write(_Command); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteCount 
.................... // Permet d'crire la valeur de la roue folle. 
.................... // Prend la valeur  crire et le mode (0 = crit. int, 1 = crit. float tronqu) 
.................... // Ne retourne rien. 
.................... void __WriteCount(float64 _Value, int1 _Mode) 
.................... { 
.................... 	// Index d'affichage 
.................... 	unsigned int8 IAff=0, TabValue[16]; 
.................... 	 
.................... 	// Selon mode d'affichage choisi 
.................... 	// Transforme le nombre en chane de caractre 
.................... 	if(_Mode == 0) 
.................... 	sprintf(TabValue,"%7Ld ",(int32)_Value); 
.................... 	else	 
.................... 	sprintf(TabValue,"%6.3f ",(float64)_Value); 
.................... 		 
.................... 	// Affiche les caractres  la suite 
.................... 	while(TabValue[IAff]!=0x00) 
.................... 	{ 
.................... 		__WriteLCD(TabValue[IAff]); 
.................... 		Iaff++; 
.................... 	}	 
....................  
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... }	 
....................  
.................... // __SautLig 
.................... // Saute  la seconde ligne 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __SautLig(unsigned int8 _Lig) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Saute  la seconde ligne 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x45); 
.................... 	i2c_write(_Lig); 
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Deplacement/___Depl.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl 
.................... #define ___Depl 
....................  
....................  
.................... /////////////////  Deplacement Progress  //////////////////////////////// 
.................... float64 amp_limit = 1.6;				 // limite de courant depl progress 
.................... unsigned int16 DIST_SECU_PROGRESS = 100; // distance de secu sur le deplacement progress en mm 
.................... 	 
.................... /////////////////  Localisation  //////////////////////////////// 
.................... signed int16 Dist_x,Dist_y=0; 
.................... signed int16 Pos_x = 0; //en mm 
.................... signed int16 Pos_y = 0;//en mm 
.................... signed int16 Orient_deg = 0; 
.................... float64 Dorient = 0;  
.................... float64 Orient = 0; 
.................... float64 DIAM_ENCO = 3.415;	// Diamtre des encodeurs, en [cm] 
.................... float64 IMPULSES_ENCO = 5000;	// Nombre d'impulsions de l'encodeur (sans compter le x4 du QEI) 
.................... float64 ENTRAXE_ROUESFOLLES = 27.51922;//31.6006	// Entraxe entre les deux centres des roues folles, en [cm] 
....................  
.................... ///////////////// Calcul //////////////////////////////////////// 
.................... float64 COEFF_D	= (float64) (IMPULSES_ENCO*4)/(DIAM_ENCO*PI);	// Nbre de pas pour 1 [cm] 
.................... float64 CONV_DEG_RAD = (float64) (PI / 180); 
....................  
.................... ////////////////////// Gestion de la reception //////////////////////////////////// 
.................... unsigned int8 RoboteQ_receiveToProceed = 0;	// Position maximale pour la rception 
.................... unsigned int8 RoboteQ_receiveLenght = 0;	// Longeur totale de la donne 
.................... signed int32 Dist_Do = 0; 
....................  
.................... ///////////////////// Impulsions ////////////////////////////////////////////////// 
.................... signed int32 value_enco_g_start = 0;		//valeur enco debut deplacment 
.................... signed int32 value_enco_d_start = 0;		//valeur enco debut deplacement 
.................... signed int32 value_enco_g_end = 0;			//valeur enco fin deplacment 
.................... signed int32 value_enco_d_end = 0;			//valeur enco fin deplacement	 
....................  
....................  
.................... /////////////////  Prototype fct  //////////////////////////////// 
.................... void __Stop(); 
.................... void __DeplToDo(unsigned int8 _Command);	// 0--> turn, 1--> PaP, 2--> progress, 4-->nothing 
.................... void __Turn(signed int16 _Ang);				 
.................... void __PaP(int16 _X, int16 _Y); 
.................... void __Progress(int16 _X, int16 _Y); 
.................... void __Nothing(void); 
.................... float64 __Get_amp(int channel); 
.................... void __Init_pos(void); 
.................... void __LoadObj(unsigned int16 _Obj); // Charge les diffrents paramtres des objectifs selon lequel est slectionn 
.................... float64 __Conv_Ang_4Quadr(float64 _Ang); // Convertit un angle selon le cadran de l'objectif. 
.................... void __Get_enco_value(int1 start_end); 
.................... #include "Deplacement/___Depl.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl_c 
.................... #define ___Depl_c 
....................  
.................... //********************************************************************************************************************* 
.................... // arrondi_float 
.................... // 
.................... // Cette fonction permet d'arrondir un nombre decimal en entier relatif 
.................... // 12.7863 => 13 
.................... // 14.45621 => 14  
.................... // 
.................... // Developpe par : Louis Mayencourt 
.................... // Date :          01.12.2010  
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : nombre a convertir  
.................... // return      : nombre converti 
.................... // 
.................... //********************************************************************************************************************* 
.................... signed int32 arrondi_float_signed(float nombre) 
.................... { 
.................... 	float chiffres_apres_virgule;		// contient les chiffres apres la virgule du float a convertir  
....................  
.................... // prend les chiffres apres la virgule 
.................... 	chiffres_apres_virgule = nombre-floor(nombre); 
*
0682C:  PUSH    1B9C
0682E:  POP     1BBA
06830:  PUSH    1B9E
06832:  POP     1BBC
06834:  CALL    1D9C
06838:  BSET.B  43.0
0683A:  MOV     W0,W2
0683C:  MOV     W1,W3
0683E:  MOV     1B9C,W0
06840:  MOV     1B9E,W1
06842:  CALL    1A72
06846:  MOV     W0,1BA0
06848:  MOV     W1,1BA2
....................  
.................... // test si il faut arrondir vers le bas ou le haut 
.................... 	if(chiffres_apres_virgule>=0.5) return( (signed int32)(ceil(nombre))); 
0684A:  MOV     #0,W0
0684C:  MOV     #3F00,W1
0684E:  MOV     1BA0,W2
06850:  MOV     1BA2,W3
06852:  CALL    1816
06856:  BRA     C,685A
06858:  BRA     NZ,6872
0685A:  PUSH    1B9C
0685C:  POP     1BBA
0685E:  PUSH    1B9E
06860:  POP     1BBC
06862:  CALL    1D88
06866:  CALL    67EC
0686A:  MOV.D   W0,W0
0686C:  BRA     6886
0686E:  GOTO    6886
.................... 	else return( (signed int32)(floor(nombre))); 
06872:  PUSH    1B9C
06874:  POP     1BBA
06876:  PUSH    1B9E
06878:  POP     1BBC
0687A:  CALL    1D9C
0687E:  CALL    67EC
06882:  MOV.D   W0,W0
06884:  BRA     6886
06886:  RETURN  
.................... } 
....................  
.................... void __Affichage_Erreur(int8 nombre) 
.................... { 
.................... 	No_erreur = nombre;  
*
08850:  MOV.B   1B3C,W0L
08852:  MOV.B   W0L,870
.................... 	flag_error = 1;  
08854:  BSET.B  85B.3
.................... 		// Quitte la fonction 
.................... 	return; 
08856:  RETURN  
.................... } 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Check_commande_atteint 
.................... //	Auteur :	BORREM 
.................... //	Date:	    18.2.15 
.................... //  Statut :    fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Check si la commande donn aux moteurs a t finie 
.................... void __Check_commande_atteint(void) 
*
073AA:  MOV     W5,[W15++]
073AC:  MOV     W6,[W15++]
073AE:  BCLR.B  1B96.1
.................... { 
.................... 	int1 comm_atteinte_m1,comm_atteinte_m2 = 0; 
.................... 	fprintf(ROBOTEQ,"?DR\r"); 
073B0:  MOV     #0,W1
073B2:  MOV     W1,W0
073B4:  CLR.B   1
073B6:  CALL    100
073BA:  INC     W1,W1
073BC:  BTSC.B  219.1
073BE:  BRA     73BC
073C0:  MOV     W0,21A
073C2:  MOV     #3,W0
073C4:  CPSGT   W1,W0
073C6:  BRA     73B2
.................... //il renvoie DR=x:x 
.................... 	delay_ms(20); 
073C8:  MOV     #14,W0
073CA:  CALL    DE2
.................... //on vrifie que le premier caractre n'indique pas une rptiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] != '!' && RoboteQ_receiveBuffer[0] != '?' && RoboteQ_receiveBuffer[0] != '~' && RoboteQ_receiveBuffer[0] != '^' && RoboteQ_receiveBuffer[0] != '#') 
073CE:  MOV     882,W4
073D0:  XOR.B   #21,W4L
073D2:  BRA     Z,73F8
073D4:  MOV     882,W4
073D6:  XOR.B   #3F,W4L
073D8:  BRA     Z,73F8
073DA:  MOV     882,W4
073DC:  XOR.B   #7E,W4L
073DE:  BRA     Z,73F8
073E0:  MOV     882,W4
073E2:  XOR.B   #5E,W4L
073E4:  BRA     Z,73F8
073E6:  MOV     882,W4
073E8:  XOR.B   #23,W4L
073EA:  BRA     Z,73F8
.................... 	{ 
.................... 		comm_atteinte_m1 = RoboteQ_receiveBuffer[3]; // affectation du premier x dans la variable 
073EC:  BCLR.B  1B96.0
073EE:  BTSC.B  885.0
073F0:  BSET.B  1B96.0
.................... 		comm_atteinte_m2 = RoboteQ_receiveBuffer[5]; // affectation du deuxime x dans la variable 
073F2:  BCLR.B  1B96.1
073F4:  BTSC.B  887.0
073F6:  BSET.B  1B96.1
.................... 	} 
.................... 	if(comm_atteinte_m1 == 1 && comm_atteinte_m2== 1) // si commande des deux moteurs dini  
073F8:  BTSS.B  1B96.0
073FA:  BRA     7402
073FC:  BTSS.B  1B96.1
073FE:  BRA     7402
.................... 	{ 
.................... 		flag_depl_ok =1 ; // on peut passer au dplacement suivant 
07400:  BSET.B  85A.7
.................... 	} 
07402:  MOV     [--W15],W6
07404:  MOV     [--W15],W5
07406:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_amp(int channel) 
.................... * \brief Recupere la valeur du courant dans les moteurs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] channel--> 1 moteur 1, 2  moteur 2  
.................... * \return Ne retourne rien 
.................... */ 
.................... float64 __Get_amp(int channel) 
*
080C0:  MOV     W5,[W15++]
080C2:  MOV     W6,[W15++]
080C4:  CLR     1B64
080C6:  MOV.B   #2,W0L
080C8:  MOV.B   W0L,1B66
.................... { 
.................... 	unsigned int16 ampere = 0; 
.................... 	unsigned int8 i = 2; 
.................... 	if(channel == 1) 
080CA:  MOV     1B62,W4
080CC:  CP      W4,#1
080CE:  BRA     NZ,80EC
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 1\r"); 
080D0:  MOV     #0,W1
080D2:  MOV     W1,W0
080D4:  CLR.B   1
080D6:  CALL    112
080DA:  INC     W1,W1
080DC:  BTSC.B  219.1
080DE:  BRA     80DC
080E0:  MOV     W0,21A
080E2:  MOV     #4,W0
080E4:  CPSGT   W1,W0
080E6:  BRA     80D2
.................... 	} 
080E8:  GOTO    8104
.................... 	else 
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 2\r"); 
080EC:  MOV     #0,W1
080EE:  MOV     W1,W0
080F0:  CLR.B   1
080F2:  CALL    124
080F6:  INC     W1,W1
080F8:  BTSC.B  219.1
080FA:  BRA     80F8
080FC:  MOV     W0,21A
080FE:  MOV     #4,W0
08100:  CPSGT   W1,W0
08102:  BRA     80EE
.................... 	}  
.................... 	//il renvoie DR=x:x 
.................... 	delay_ms(10); 
08104:  MOV     #A,W0
08106:  CALL    DE2
.................... 	//on verifie que le premier caractere n'indique pas une rptiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] == 'A') 
0810A:  MOV     882,W4
0810C:  XOR.B   #41,W4L
0810E:  BRA     NZ,8160
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= '\r') 
08110:  MOV     1B66,W4
08112:  CLR.B   9
08114:  MOV     #882,W3
08116:  ADD     W4,W3,W0
08118:  MOV.B   [W0],W4L
0811A:  CP.B    W4L,#D
0811C:  BRA     Z,814E
.................... 		{ 
.................... 			if(RoboteQ_receiveBuffer[i]!=0x2D) // 0x2D -> signe '-' en ascii, courant neg -> on prend en abs 
0811E:  MOV     1B66,W4
08120:  CLR.B   9
08122:  MOV     #882,W3
08124:  ADD     W4,W3,W0
08126:  MOV.B   [W0],W5L
08128:  SE      W5,W5
0812A:  MOV     #2D,W4
0812C:  CP      W4,W5
0812E:  BRA     Z,8148
.................... 			{ 
.................... 				ampere  *= 10; 
08130:  MOV     1B64,W4
08132:  MUL.UU  W4,#A,W0
08134:  MOV     W0,1B64
.................... 				ampere  += RoboteQ_receiveBuffer[i]-0x30; 
08136:  MOV     1B66,W4
08138:  CLR.B   9
0813A:  MOV     #882,W3
0813C:  ADD     W4,W3,W0
0813E:  MOV.B   [W0],W5L
08140:  SE      W5,W5
08142:  MOV     #30,W4
08144:  SUB     W5,W4,W0
08146:  ADD     1B64
.................... 			} 
.................... 			i++;  
08148:  INC.B   1B66
0814A:  GOTO    8110
.................... 		} 
.................... 		return(ampere); 
0814E:  MOV     1B64,W0
08150:  MOV     #0,W1
08152:  MOV     #0,W2
08154:  MOV     #0,W3
08156:  CALL    805C
0815A:  BRA     816A
.................... 	} 
0815C:  GOTO    816A
.................... 	else 
.................... 	{ 
.................... 		return(0); 
08160:  MOV     #0,W0
08162:  MOV     #0,W1
08164:  MOV     #0,W2
08166:  MOV     #0,W3
08168:  BRA     816A
.................... 	} 
0816A:  MOV     [--W15],W6
0816C:  MOV     [--W15],W5
0816E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_enco_value(int1 start_end) 
.................... * \brief Recupere la valeur des encodeurs du robot 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] 1 -> enco au depart, 0 -> enco a la fin 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Get_enco_value(int1 start_end) 
*
07408:  MOV     W5,[W15++]
0740A:  MOV     W6,[W15++]
0740C:  MOV.B   #2,W0L
0740E:  MOV.B   W0L,1B97
07410:  BCLR.B  1B98.0
.................... { 
.................... 	unsigned int8 i = 2; 
.................... 	int1 flag_inverted = 0; 
.................... 	if(start_end) // si recuperation enco au depart --> on clear tout 
07412:  CP0.B   1B96
07414:  BRA     Z,7426
.................... 	{ 
.................... 		value_enco_g_start = 0; 
07416:  CLR     15E4
07418:  CLR     15E6
.................... 		value_enco_d_start = 0; 
0741A:  CLR     15E8
0741C:  CLR     15EA
.................... 		value_enco_g_end   = 0; 
0741E:  CLR     15EC
07420:  CLR     15EE
.................... 		value_enco_d_end   = 0; 
07422:  CLR     15F0
07424:  CLR     15F2
.................... 	} 
....................  
.................... 	fprintf(ROBOTEQ,"?C\r"); // on demande la valeur des encodeurs 
07426:  BTSC.B  219.1
07428:  BRA     7426
0742A:  MOV     #3F,W4
0742C:  MOV     W4,21A
0742E:  BTSC.B  219.1
07430:  BRA     742E
07432:  MOV     #43,W4
07434:  MOV     W4,21A
07436:  BTSC.B  219.1
07438:  BRA     7436
0743A:  MOV     #D,W4
0743C:  MOV     W4,21A
.................... 	delay_ms(20); 
0743E:  MOV     #14,W0
07440:  CALL    DE2
.................... 	 
.................... 	if(RoboteQ_receiveBuffer[0] == 'C') // si on reoit C=xxxx:xxxx 
07444:  MOV     882,W4
07446:  XOR.B   #43,W4L
07448:  BRA     NZ,7634
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= ':') 
0744A:  MOV     1B96,W4
0744C:  LSR     W4,#8,W4
0744E:  MOV     #882,W3
07450:  ADD     W4,W3,W0
07452:  MOV.B   [W0],W4L
07454:  XOR.B   #3A,W4L
07456:  BRA     Z,750E
.................... 		{ 
.................... 			if(start_end) 
07458:  CP0.B   1B96
0745A:  BRA     Z,74B4
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
0745C:  MOV     1B96,W4
0745E:  LSR     W4,#8,W4
07460:  MOV     #882,W3
07462:  ADD     W4,W3,W0
07464:  MOV.B   [W0],W5L
07466:  SE      W5,W5
07468:  MOV     #2D,W4
0746A:  CP      W4,W5
0746C:  BRA     NZ,7474
.................... 				{ 
.................... 					flag_inverted = 1; 
0746E:  BSET.B  1B98.0
.................... 				} 
07470:  GOTO    74B0
07474:  PUSH    42
07476:  BCLR.B  81.7
07478:  SETM.B  42
0747A:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_start *= 10; 
0747C:  MOV     15E4,W0
0747E:  MOV     15E6,W1
07480:  MOV     #A,W2
07482:  MOV     #0,W3
07484:  CALL    632
07488:  BCLR.B  81.7
0748A:  POP     42
0748C:  BSET.B  81.7
0748E:  MOV     W0,15E4
07490:  MOV     W1,15E6
.................... 					value_enco_g_start += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
07492:  MOV     1B96,W4
07494:  LSR     W4,#8,W4
07496:  MOV     #882,W3
07498:  ADD     W4,W3,W0
0749A:  MOV.B   [W0],W5L
0749C:  SE      W5,W5
0749E:  MOV     #30,W4
074A0:  SUB     W5,W4,W0
074A2:  CLR     W1
074A4:  BTSC    W0.F
074A6:  SETM    W1
074A8:  ADD     15E4
074AA:  MOV     W1,W0
074AC:  ADDC    15E6,W0
074AE:  MOV     W0,15E6
.................... 				}				 
.................... 			} 
074B0:  GOTO    7508
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
074B4:  MOV     1B96,W4
074B6:  LSR     W4,#8,W4
074B8:  MOV     #882,W3
074BA:  ADD     W4,W3,W0
074BC:  MOV.B   [W0],W5L
074BE:  SE      W5,W5
074C0:  MOV     #2D,W4
074C2:  CP      W4,W5
074C4:  BRA     NZ,74CC
.................... 				{ 
.................... 					flag_inverted = 1; 
074C6:  BSET.B  1B98.0
.................... 				} 
074C8:  GOTO    7508
074CC:  PUSH    42
074CE:  BCLR.B  81.7
074D0:  SETM.B  42
074D2:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_end *= 10; 
074D4:  MOV     15EC,W0
074D6:  MOV     15EE,W1
074D8:  MOV     #A,W2
074DA:  MOV     #0,W3
074DC:  CALL    632
074E0:  BCLR.B  81.7
074E2:  POP     42
074E4:  BSET.B  81.7
074E6:  MOV     W0,15EC
074E8:  MOV     W1,15EE
.................... 					value_enco_g_end += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
074EA:  MOV     1B96,W4
074EC:  LSR     W4,#8,W4
074EE:  MOV     #882,W3
074F0:  ADD     W4,W3,W0
074F2:  MOV.B   [W0],W5L
074F4:  SE      W5,W5
074F6:  MOV     #30,W4
074F8:  SUB     W5,W4,W0
074FA:  CLR     W1
074FC:  BTSC    W0.F
074FE:  SETM    W1
07500:  ADD     15EC
07502:  MOV     W1,W0
07504:  ADDC    15EE,W0
07506:  MOV     W0,15EE
.................... 				} 
.................... 			} 
.................... 			i++; 
07508:  INC.B   1B97
0750A:  GOTO    744A
.................... 		} 
.................... 		if(flag_inverted) //si l'on a recu un nbre d'impulses negatifs 
0750E:  BTSS.B  1B98.0
07510:  BRA     753E
.................... 		{ 
.................... 			if(start_end)  
07512:  CP0.B   1B96
07514:  BRA     Z,752C
.................... 			{ 
.................... 				value_enco_g_start = 0-value_enco_g_start; // on inverse tout 
07516:  MOV     #0,W4
07518:  MOV     15E4,W3
0751A:  SUB     W4,W3,W0
0751C:  MOV     W0,15E4
0751E:  MOV     #0,W4
07520:  MOV     15E6,W3
07522:  SUBB    W4,W3,W0
07524:  MOV     W0,15E6
.................... 				flag_inverted = 0; 
07526:  BCLR.B  1B98.0
.................... 			} 
07528:  GOTO    753E
.................... 			else 
.................... 			{ 
.................... 				value_enco_g_end = 0-value_enco_g_end;	// on inverse tout 
0752C:  MOV     #0,W4
0752E:  MOV     15EC,W3
07530:  SUB     W4,W3,W0
07532:  MOV     W0,15EC
07534:  MOV     #0,W4
07536:  MOV     15EE,W3
07538:  SUBB    W4,W3,W0
0753A:  MOV     W0,15EE
.................... 				flag_inverted = 0; 
0753C:  BCLR.B  1B98.0
.................... 			} 
.................... 		} 
.................... 		i++; 
0753E:  INC.B   1B97
.................... 		while(RoboteQ_receiveBuffer[i]!='\r')//tant que la transmission n'est pas fini 
07540:  MOV     1B96,W4
07542:  LSR     W4,#8,W4
07544:  MOV     #882,W3
07546:  ADD     W4,W3,W0
07548:  MOV.B   [W0],W4L
0754A:  CP.B    W4L,#D
0754C:  BRA     Z,7604
.................... 		{ 
.................... 			if(start_end) 
0754E:  CP0.B   1B96
07550:  BRA     Z,75AA
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
07552:  MOV     1B96,W4
07554:  LSR     W4,#8,W4
07556:  MOV     #882,W3
07558:  ADD     W4,W3,W0
0755A:  MOV.B   [W0],W5L
0755C:  SE      W5,W5
0755E:  MOV     #2D,W4
07560:  CP      W4,W5
07562:  BRA     NZ,756A
.................... 				{ 
.................... 					flag_inverted = 1; 
07564:  BSET.B  1B98.0
.................... 				} 
07566:  GOTO    75A6
0756A:  PUSH    42
0756C:  BCLR.B  81.7
0756E:  SETM.B  42
07570:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_start *= 10; 
07572:  MOV     15E8,W0
07574:  MOV     15EA,W1
07576:  MOV     #A,W2
07578:  MOV     #0,W3
0757A:  CALL    632
0757E:  BCLR.B  81.7
07580:  POP     42
07582:  BSET.B  81.7
07584:  MOV     W0,15E8
07586:  MOV     W1,15EA
.................... 					value_enco_d_start += RoboteQ_receiveBuffer[i]-0x30; 
07588:  MOV     1B96,W4
0758A:  LSR     W4,#8,W4
0758C:  MOV     #882,W3
0758E:  ADD     W4,W3,W0
07590:  MOV.B   [W0],W5L
07592:  SE      W5,W5
07594:  MOV     #30,W4
07596:  SUB     W5,W4,W0
07598:  CLR     W1
0759A:  BTSC    W0.F
0759C:  SETM    W1
0759E:  ADD     15E8
075A0:  MOV     W1,W0
075A2:  ADDC    15EA,W0
075A4:  MOV     W0,15EA
.................... 				} 
.................... 			} 
075A6:  GOTO    75FE
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
075AA:  MOV     1B96,W4
075AC:  LSR     W4,#8,W4
075AE:  MOV     #882,W3
075B0:  ADD     W4,W3,W0
075B2:  MOV.B   [W0],W5L
075B4:  SE      W5,W5
075B6:  MOV     #2D,W4
075B8:  CP      W4,W5
075BA:  BRA     NZ,75C2
.................... 				{ 
.................... 					flag_inverted = 1; 
075BC:  BSET.B  1B98.0
.................... 				} 
075BE:  GOTO    75FE
075C2:  PUSH    42
075C4:  BCLR.B  81.7
075C6:  SETM.B  42
075C8:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_end *= 10; 
075CA:  MOV     15F0,W0
075CC:  MOV     15F2,W1
075CE:  MOV     #A,W2
075D0:  MOV     #0,W3
075D2:  CALL    632
075D6:  BCLR.B  81.7
075D8:  POP     42
075DA:  BSET.B  81.7
075DC:  MOV     W0,15F0
075DE:  MOV     W1,15F2
.................... 					value_enco_d_end += RoboteQ_receiveBuffer[i]-0x30;			 
075E0:  MOV     1B96,W4
075E2:  LSR     W4,#8,W4
075E4:  MOV     #882,W3
075E6:  ADD     W4,W3,W0
075E8:  MOV.B   [W0],W5L
075EA:  SE      W5,W5
075EC:  MOV     #30,W4
075EE:  SUB     W5,W4,W0
075F0:  CLR     W1
075F2:  BTSC    W0.F
075F4:  SETM    W1
075F6:  ADD     15F0
075F8:  MOV     W1,W0
075FA:  ADDC    15F2,W0
075FC:  MOV     W0,15F2
.................... 				} 
.................... 			} 
.................... 			i++;		 
075FE:  INC.B   1B97
07600:  GOTO    7540
.................... 		} 
.................... 		if(flag_inverted)//si l'on a recu un nbre d'impulses negatifs 
07604:  BTSS.B  1B98.0
07606:  BRA     7634
.................... 		{ 
.................... 			if(start_end) 
07608:  CP0.B   1B96
0760A:  BRA     Z,7622
.................... 			{ 
.................... 				value_enco_d_start = 0-value_enco_d_start;// on inverse tout 
0760C:  MOV     #0,W4
0760E:  MOV     15E8,W3
07610:  SUB     W4,W3,W0
07612:  MOV     W0,15E8
07614:  MOV     #0,W4
07616:  MOV     15EA,W3
07618:  SUBB    W4,W3,W0
0761A:  MOV     W0,15EA
.................... 				flag_inverted = 0; 
0761C:  BCLR.B  1B98.0
.................... 			} 
0761E:  GOTO    7634
.................... 			else 
.................... 			{ 
.................... 				value_enco_d_end = 0-value_enco_d_end;// on inverse tout 
07622:  MOV     #0,W4
07624:  MOV     15F0,W3
07626:  SUB     W4,W3,W0
07628:  MOV     W0,15F0
0762A:  MOV     #0,W4
0762C:  MOV     15F2,W3
0762E:  SUBB    W4,W3,W0
07630:  MOV     W0,15F2
.................... 				flag_inverted = 0; 
07632:  BCLR.B  1B98.0
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	if(!start_end) 
07634:  CP0.B   1B96
07636:  BRA     NZ,7666
.................... 	{ 
.................... 		Dist_Do = ((value_enco_g_end-value_enco_g_start)+(value_enco_d_end-value_enco_d_start))/2; // calcul distance parcourue 
07638:  MOV     15EC,W4
0763A:  MOV     15E4,W3
0763C:  SUB     W4,W3,W5
0763E:  MOV     15EE,W4
07640:  MOV     15E6,W3
07642:  SUBB    W4,W3,W6
07644:  MOV     15F0,W4
07646:  MOV     15E8,W3
07648:  SUB     W4,W3,W0
0764A:  MOV     15F2,W4
0764C:  MOV     15EA,W3
0764E:  SUBB    W4,W3,W1
07650:  ADD     W0,W5,W5
07652:  ADDC    W1,W6,W6
07654:  BCLR.B  43.0
07656:  MOV     W5,W0
07658:  MOV     W6,W1
0765A:  MOV     #2,W2
0765C:  MOV     #0,W3
0765E:  CALL    14A2
07662:  MOV     W0,15E0
07664:  MOV     W1,15E2
.................... 	} 
07666:  MOV     [--W15],W6
07668:  MOV     [--W15],W5
0766A:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Actual_pos(void) 
.................... * \brief Actualise la position xy du robot s'il doit switcher d'objectifs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] - 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __actual_pos(void) 
*
08BC0:  MOV     W5,[W15++]
08BC2:  MOV     W6,[W15++]
08BC4:  MOV     W7,[W15++]
08BC6:  MOV     W8,[W15++]
08BC8:  CLR     1B3A
08BCA:  CLR     1B3C
08BCC:  CLR     1B3E
08BCE:  CLR     1B40
08BD0:  CLR     1B42
08BD2:  CLR     1B44
.................... { 
.................... 	signed int32 Dist_Do_mm = 0; 
.................... 	signed int32 dx = 0; 
.................... 	signed int32 dy = 0; 
.................... 	__Get_enco_value(0); // recuperation delta x,y 
08BD4:  CLR.B   1B96
08BD6:  CALL    7408
.................... 							 
.................... 	Dist_Do_mm = (signed int32)(Dist_Do/(COEFF_D/10)); 
08BDA:  MOV     15CE,W0
08BDC:  MOV     15D0,W1
08BDE:  MOV     15D2,W2
08BE0:  MOV     15D4,W3
08BE2:  MOV     #0,W4
08BE4:  MOV     #0,W5
08BE6:  MOV     #0,W6
08BE8:  MOV     #4024,W7
08BEA:  CALL    CDA
08BEE:  MOV     W0,W5
08BF0:  MOV     W1,W6
08BF2:  MOV     W2,W7
08BF4:  MOV     W3,W8
08BF6:  MOV     15E0,W0
08BF8:  MOV     15E2,W1
08BFA:  CLR     W3
08BFC:  BTSC    W1.F
08BFE:  SETM    W3
08C00:  MOV     W3,W2
08C02:  CALL    1394
08C06:  MOV     W5,[W15++]
08C08:  MOV     W6,[W15++]
08C0A:  MOV     W7,[W15++]
08C0C:  MOV     W5,W4
08C0E:  MOV     W6,W5
08C10:  MOV     W7,W6
08C12:  MOV     W8,W7
08C14:  CALL    CDA
08C18:  MOV     [--W15],W7
08C1A:  MOV     [--W15],W6
08C1C:  MOV     [--W15],W5
08C1E:  CALL    6EF4
08C22:  MOV     W0,1B3A
08C24:  MOV     W1,1B3C
.................... 	///////////////////////// Calcul dx,dy //////////////////////////// 
.................... 	if(0 <= Orient && Orient <= PI)//entre 0 et 180deg 
08C26:  MOV     #0,W0
08C28:  MOV     #0,W1
08C2A:  MOV     #0,W2
08C2C:  MOV     #0,W3
08C2E:  MOV     15AE,W4
08C30:  MOV     15B0,W5
08C32:  MOV     15B2,W6
08C34:  MOV     15B4,W7
08C36:  CALL    6724
08C3A:  BRA     C,8C3E
08C3C:  BRA     NZ,8D0E
08C3E:  MOV     15AE,W0
08C40:  MOV     15B0,W1
08C42:  MOV     15B2,W2
08C44:  MOV     15B4,W3
08C46:  MOV     #2D18,W4
08C48:  MOV     #5444,W5
08C4A:  MOV     #21FB,W6
08C4C:  MOV     #4009,W7
08C4E:  CALL    6724
08C52:  BRA     C,8C56
08C54:  BRA     NZ,8D0E
.................... 	{ 
.................... 		dx =  (signed int16)(cos(Orient) * Dist_Do_mm); 
08C56:  PUSH    15AE
08C58:  POP     1B7C
08C5A:  PUSH    15B0
08C5C:  POP     1B7E
08C5E:  PUSH    15B2
08C60:  POP     1B80
08C62:  PUSH    15B4
08C64:  POP     1B82
08C66:  CALL    81C6
08C6A:  MOV     W0,W5
08C6C:  MOV     W1,W6
08C6E:  MOV     W2,W7
08C70:  MOV     W3,W8
08C72:  MOV     1B3A,W0
08C74:  MOV     1B3C,W1
08C76:  CLR     W3
08C78:  BTSC    W1.F
08C7A:  SETM    W3
08C7C:  MOV     W3,W2
08C7E:  CALL    1394
08C82:  MOV     W5,[W15++]
08C84:  MOV     W6,[W15++]
08C86:  MOV     W7,[W15++]
08C88:  MOV     W0,W4
08C8A:  MOV     W5,W0
08C8C:  MOV     W1,W5
08C8E:  MOV     W6,W1
08C90:  MOV     W2,W6
08C92:  MOV     W7,W2
08C94:  MOV     W3,W7
08C96:  MOV     W8,W3
08C98:  CALL    BCA
08C9C:  MOV     [--W15],W7
08C9E:  MOV     [--W15],W6
08CA0:  MOV     [--W15],W5
08CA2:  CALL    6EF4
08CA6:  CLR     W1
08CA8:  BTSC    W0.F
08CAA:  SETM    W1
08CAC:  MOV     W0,1B3E
08CAE:  MOV     W1,1B40
.................... 		dy =  (signed int16)(sin(Orient) * Dist_Do_mm);	 
08CB0:  PUSH    15AE
08CB2:  POP     1B62
08CB4:  PUSH    15B0
08CB6:  POP     1B64
08CB8:  PUSH    15B2
08CBA:  POP     1B66
08CBC:  PUSH    15B4
08CBE:  POP     1B68
08CC0:  CALL    8480
08CC4:  MOV     W0,W5
08CC6:  MOV     W1,W6
08CC8:  MOV     W2,W7
08CCA:  MOV     W3,W8
08CCC:  MOV     1B3A,W0
08CCE:  MOV     1B3C,W1
08CD0:  CLR     W3
08CD2:  BTSC    W1.F
08CD4:  SETM    W3
08CD6:  MOV     W3,W2
08CD8:  CALL    1394
08CDC:  MOV     W5,[W15++]
08CDE:  MOV     W6,[W15++]
08CE0:  MOV     W7,[W15++]
08CE2:  MOV     W0,W4
08CE4:  MOV     W5,W0
08CE6:  MOV     W1,W5
08CE8:  MOV     W6,W1
08CEA:  MOV     W2,W6
08CEC:  MOV     W7,W2
08CEE:  MOV     W3,W7
08CF0:  MOV     W8,W3
08CF2:  CALL    BCA
08CF6:  MOV     [--W15],W7
08CF8:  MOV     [--W15],W6
08CFA:  MOV     [--W15],W5
08CFC:  CALL    6EF4
08D00:  CLR     W1
08D02:  BTSC    W0.F
08D04:  SETM    W1
08D06:  MOV     W0,1B42
08D08:  MOV     W1,1B44
.................... 	} 
08D0A:  GOTO    8FA6
.................... 	else if(( (Orient>PI) && ((3*PI)/2 >= Orient)) || (Orient <= (-PI/2) && Orient > -PI))//180 et 270deg 
08D0E:  MOV     #2D18,W0
08D10:  MOV     #5444,W1
08D12:  MOV     #21FB,W2
08D14:  MOV     #4009,W3
08D16:  MOV     15AE,W4
08D18:  MOV     15B0,W5
08D1A:  MOV     15B2,W6
08D1C:  MOV     15B4,W7
08D1E:  CALL    6724
08D22:  BRA     NC,8D3C
08D24:  MOV     15AE,W0
08D26:  MOV     15B0,W1
08D28:  MOV     15B2,W2
08D2A:  MOV     15B4,W3
08D2C:  MOV     #21D2,W4
08D2E:  MOV     #7F33,W5
08D30:  MOV     #D97C,W6
08D32:  MOV     #4012,W7
08D34:  CALL    6724
08D38:  BRA     C,8D6A
08D3A:  BRA     Z,8D6A
08D3C:  MOV     15AE,W0
08D3E:  MOV     15B0,W1
08D40:  MOV     15B2,W2
08D42:  MOV     15B4,W3
08D44:  MOV     #2D18,W4
08D46:  MOV     #5444,W5
08D48:  MOV     #21FB,W6
08D4A:  MOV     #BFF9,W7
08D4C:  CALL    6724
08D50:  BRA     C,8D54
08D52:  BRA     NZ,8E5E
08D54:  MOV     #2D18,W0
08D56:  MOV     #5444,W1
08D58:  MOV     #21FB,W2
08D5A:  MOV     #C009,W3
08D5C:  MOV     15AE,W4
08D5E:  MOV     15B0,W5
08D60:  MOV     15B2,W6
08D62:  MOV     15B4,W7
08D64:  CALL    6724
08D68:  BRA     NC,8E5E
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm; 
08D6A:  MOV     #0,W4
08D6C:  MOV     1B3A,W3
08D6E:  SUB     W4,W3,W0
08D70:  MOV     W0,1B3A
08D72:  MOV     #0,W4
08D74:  MOV     1B3C,W3
08D76:  SUBB    W4,W3,W0
08D78:  MOV     W0,1B3C
.................... 		dx = (signed int16)(sin(3*(PI/2)-Orient) * Dist_Do_mm); 
08D7A:  BSET.B  43.0
08D7C:  MOV     #21D2,W0
08D7E:  MOV     #7F33,W1
08D80:  MOV     #D97C,W2
08D82:  MOV     #4012,W3
08D84:  MOV     15AE,W4
08D86:  MOV     15B0,W5
08D88:  MOV     15B2,W6
08D8A:  MOV     15B4,W7
08D8C:  CALL    6536
08D90:  MOV     W0,W5
08D92:  MOV     W1,W6
08D94:  MOV     W2,W7
08D96:  MOV     W3,W8
08D98:  MOV     W5,1B62
08D9A:  MOV     W6,1B64
08D9C:  MOV     W7,1B66
08D9E:  MOV     W8,1B68
08DA0:  CALL    8480
08DA4:  MOV     W0,W5
08DA6:  MOV     W1,W6
08DA8:  MOV     W2,W7
08DAA:  MOV     W3,W8
08DAC:  MOV     1B3A,W0
08DAE:  MOV     1B3C,W1
08DB0:  CLR     W3
08DB2:  BTSC    W1.F
08DB4:  SETM    W3
08DB6:  MOV     W3,W2
08DB8:  CALL    1394
08DBC:  MOV     W5,[W15++]
08DBE:  MOV     W6,[W15++]
08DC0:  MOV     W7,[W15++]
08DC2:  MOV     W0,W4
08DC4:  MOV     W5,W0
08DC6:  MOV     W1,W5
08DC8:  MOV     W6,W1
08DCA:  MOV     W2,W6
08DCC:  MOV     W7,W2
08DCE:  MOV     W3,W7
08DD0:  MOV     W8,W3
08DD2:  CALL    BCA
08DD6:  MOV     [--W15],W7
08DD8:  MOV     [--W15],W6
08DDA:  MOV     [--W15],W5
08DDC:  CALL    6EF4
08DE0:  CLR     W1
08DE2:  BTSC    W0.F
08DE4:  SETM    W1
08DE6:  MOV     W0,1B3E
08DE8:  MOV     W1,1B40
.................... 		dy = (signed int16)(cos(3*(PI/2)-Orient) * Dist_Do_mm); 
08DEA:  BSET.B  43.0
08DEC:  MOV     #21D2,W0
08DEE:  MOV     #7F33,W1
08DF0:  MOV     #D97C,W2
08DF2:  MOV     #4012,W3
08DF4:  MOV     15AE,W4
08DF6:  MOV     15B0,W5
08DF8:  MOV     15B2,W6
08DFA:  MOV     15B4,W7
08DFC:  CALL    6536
08E00:  MOV     W0,W5
08E02:  MOV     W1,W6
08E04:  MOV     W2,W7
08E06:  MOV     W3,W8
08E08:  MOV     W5,1B7C
08E0A:  MOV     W6,1B7E
08E0C:  MOV     W7,1B80
08E0E:  MOV     W8,1B82
08E10:  CALL    81C6
08E14:  MOV     W0,W5
08E16:  MOV     W1,W6
08E18:  MOV     W2,W7
08E1A:  MOV     W3,W8
08E1C:  MOV     1B3A,W0
08E1E:  MOV     1B3C,W1
08E20:  CLR     W3
08E22:  BTSC    W1.F
08E24:  SETM    W3
08E26:  MOV     W3,W2
08E28:  CALL    1394
08E2C:  MOV     W5,[W15++]
08E2E:  MOV     W6,[W15++]
08E30:  MOV     W7,[W15++]
08E32:  MOV     W0,W4
08E34:  MOV     W5,W0
08E36:  MOV     W1,W5
08E38:  MOV     W6,W1
08E3A:  MOV     W2,W6
08E3C:  MOV     W7,W2
08E3E:  MOV     W3,W7
08E40:  MOV     W8,W3
08E42:  CALL    BCA
08E46:  MOV     [--W15],W7
08E48:  MOV     [--W15],W6
08E4A:  MOV     [--W15],W5
08E4C:  CALL    6EF4
08E50:  CLR     W1
08E52:  BTSC    W0.F
08E54:  SETM    W1
08E56:  MOV     W0,1B42
08E58:  MOV     W1,1B44
.................... 	} 
08E5A:  GOTO    8FA6
.................... 	else if(((Orient>(3*PI/2)) && (Orient < (2*PI))) || (Orient < 0 && Orient > (-PI/2)))//270deg et 360deg 
08E5E:  MOV     #21D2,W0
08E60:  MOV     #7F33,W1
08E62:  MOV     #D97C,W2
08E64:  MOV     #4012,W3
08E66:  MOV     15AE,W4
08E68:  MOV     15B0,W5
08E6A:  MOV     15B2,W6
08E6C:  MOV     15B4,W7
08E6E:  CALL    6724
08E72:  BRA     NC,8E8A
08E74:  MOV     15AE,W0
08E76:  MOV     15B0,W1
08E78:  MOV     15B2,W2
08E7A:  MOV     15B4,W3
08E7C:  MOV     #2D18,W4
08E7E:  MOV     #5444,W5
08E80:  MOV     #21FB,W6
08E82:  MOV     #4019,W7
08E84:  CALL    6724
08E88:  BRA     C,8EB6
08E8A:  MOV     15AE,W0
08E8C:  MOV     15B0,W1
08E8E:  MOV     15B2,W2
08E90:  MOV     15B4,W3
08E92:  MOV     #0,W4
08E94:  MOV     #0,W5
08E96:  MOV     #0,W6
08E98:  MOV     #0,W7
08E9A:  CALL    6724
08E9E:  BRA     NC,8FA6
08EA0:  MOV     #2D18,W0
08EA2:  MOV     #5444,W1
08EA4:  MOV     #21FB,W2
08EA6:  MOV     #BFF9,W3
08EA8:  MOV     15AE,W4
08EAA:  MOV     15B0,W5
08EAC:  MOV     15B2,W6
08EAE:  MOV     15B4,W7
08EB0:  CALL    6724
08EB4:  BRA     NC,8FA6
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm;  
08EB6:  MOV     #0,W4
08EB8:  MOV     1B3A,W3
08EBA:  SUB     W4,W3,W0
08EBC:  MOV     W0,1B3A
08EBE:  MOV     #0,W4
08EC0:  MOV     1B3C,W3
08EC2:  SUBB    W4,W3,W0
08EC4:  MOV     W0,1B3C
.................... 		dx = (signed int16)(sin(-(PI/2)-Orient) * Dist_Do_mm); 
08EC6:  BSET.B  43.0
08EC8:  MOV     #2D18,W0
08ECA:  MOV     #5444,W1
08ECC:  MOV     #21FB,W2
08ECE:  MOV     #BFF9,W3
08ED0:  MOV     15AE,W4
08ED2:  MOV     15B0,W5
08ED4:  MOV     15B2,W6
08ED6:  MOV     15B4,W7
08ED8:  CALL    6536
08EDC:  MOV     W0,W5
08EDE:  MOV     W1,W6
08EE0:  MOV     W2,W7
08EE2:  MOV     W3,W8
08EE4:  MOV     W5,1B62
08EE6:  MOV     W6,1B64
08EE8:  MOV     W7,1B66
08EEA:  MOV     W8,1B68
08EEC:  CALL    8480
08EF0:  MOV     W0,W5
08EF2:  MOV     W1,W6
08EF4:  MOV     W2,W7
08EF6:  MOV     W3,W8
08EF8:  MOV     1B3A,W0
08EFA:  MOV     1B3C,W1
08EFC:  CLR     W3
08EFE:  BTSC    W1.F
08F00:  SETM    W3
08F02:  MOV     W3,W2
08F04:  CALL    1394
08F08:  MOV     W5,[W15++]
08F0A:  MOV     W6,[W15++]
08F0C:  MOV     W7,[W15++]
08F0E:  MOV     W0,W4
08F10:  MOV     W5,W0
08F12:  MOV     W1,W5
08F14:  MOV     W6,W1
08F16:  MOV     W2,W6
08F18:  MOV     W7,W2
08F1A:  MOV     W3,W7
08F1C:  MOV     W8,W3
08F1E:  CALL    BCA
08F22:  MOV     [--W15],W7
08F24:  MOV     [--W15],W6
08F26:  MOV     [--W15],W5
08F28:  CALL    6EF4
08F2C:  CLR     W1
08F2E:  BTSC    W0.F
08F30:  SETM    W1
08F32:  MOV     W0,1B3E
08F34:  MOV     W1,1B40
.................... 		dy = (signed int16)(cos(-(PI/2)-Orient) * Dist_Do_mm); 
08F36:  BSET.B  43.0
08F38:  MOV     #2D18,W0
08F3A:  MOV     #5444,W1
08F3C:  MOV     #21FB,W2
08F3E:  MOV     #BFF9,W3
08F40:  MOV     15AE,W4
08F42:  MOV     15B0,W5
08F44:  MOV     15B2,W6
08F46:  MOV     15B4,W7
08F48:  CALL    6536
08F4C:  MOV     W0,W5
08F4E:  MOV     W1,W6
08F50:  MOV     W2,W7
08F52:  MOV     W3,W8
08F54:  MOV     W5,1B7C
08F56:  MOV     W6,1B7E
08F58:  MOV     W7,1B80
08F5A:  MOV     W8,1B82
08F5C:  CALL    81C6
08F60:  MOV     W0,W5
08F62:  MOV     W1,W6
08F64:  MOV     W2,W7
08F66:  MOV     W3,W8
08F68:  MOV     1B3A,W0
08F6A:  MOV     1B3C,W1
08F6C:  CLR     W3
08F6E:  BTSC    W1.F
08F70:  SETM    W3
08F72:  MOV     W3,W2
08F74:  CALL    1394
08F78:  MOV     W5,[W15++]
08F7A:  MOV     W6,[W15++]
08F7C:  MOV     W7,[W15++]
08F7E:  MOV     W0,W4
08F80:  MOV     W5,W0
08F82:  MOV     W1,W5
08F84:  MOV     W6,W1
08F86:  MOV     W2,W6
08F88:  MOV     W7,W2
08F8A:  MOV     W3,W7
08F8C:  MOV     W8,W3
08F8E:  CALL    BCA
08F92:  MOV     [--W15],W7
08F94:  MOV     [--W15],W6
08F96:  MOV     [--W15],W5
08F98:  CALL    6EF4
08F9C:  CLR     W1
08F9E:  BTSC    W0.F
08FA0:  SETM    W1
08FA2:  MOV     W0,1B42
08FA4:  MOV     W1,1B44
.................... 	} 
.................... 	Pos_x = (signed int16)(Pos_x - dx); //mise a jour pos x 
08FA6:  MOV     15A0,W0
08FA8:  CLR     W1
08FAA:  BTSC    W0.F
08FAC:  SETM    W1
08FAE:  MOV     1B3E,W4
08FB0:  SUB     W0,W4,W0
08FB2:  MOV     1B40,W4
08FB4:  SUBB    W1,W4,W1
08FB6:  MOV     W0,15A0
.................... 	Pos_y = (signed int16)(Pos_y - dy);	//mise a jour pos y 
08FB8:  MOV     15A2,W0
08FBA:  CLR     W1
08FBC:  BTSC    W0.F
08FBE:  SETM    W1
08FC0:  MOV     1B42,W4
08FC2:  SUB     W0,W4,W0
08FC4:  MOV     1B44,W4
08FC6:  SUBB    W1,W4,W1
08FC8:  MOV     W0,15A2
08FCA:  MOV     [--W15],W8
08FCC:  MOV     [--W15],W7
08FCE:  MOV     [--W15],W6
08FD0:  MOV     [--W15],W5
08FD2:  RETURN  
.................... } 
.................... /* 
.................... 	Borgeat Rmy 
....................  
.................... 	20.2.2017 
....................  
.................... 	Initialise la postion de dpart du robot. 
.................... 	Gere le cote duquel se trouve le robot 
.................... */ 
.................... void __Init_pos(void) 
*
013F8:  MOV     W5,[W15++]
013FA:  MOV     W6,[W15++]
013FC:  MOV     W7,[W15++]
013FE:  MOV     W8,[W15++]
.................... { 
.................... 	Pos_x = read_eeprom(0xFF0); 
01400:  MOV     #FF0,W3
01402:  MOV     #0,W4
01404:  MOV     #2,W5
01406:  CALL    1046
0140A:  MOV     W0,15A0
.................... 	Pos_y = read_eeprom(0xFF2); 
0140C:  MOV     #FF2,W3
0140E:  MOV     #0,W4
01410:  MOV     #2,W5
01412:  CALL    1046
01416:  MOV     W0,15A2
.................... 	Orient_deg = read_eeprom(0xFF4); 
01418:  MOV     #FF4,W3
0141A:  MOV     #0,W4
0141C:  MOV     #2,W5
0141E:  CALL    1046
01422:  MOV     W0,15A4
....................  
.................... 	//si on est de l'autre cote du terrain 
.................... 	if(TEAM) 
01424:  BTSS.B  85B.4
01426:  BRA     144C
.................... 	{ 
.................... 		Pos_x = TableWidth-Pos_x; 
01428:  MOV     87E,W4
0142A:  MOV     15A0,W3
0142C:  SUB     W4,W3,W0
0142E:  MOV     W0,15A0
.................... 		if(Orient_deg<=180)Orient_deg=180-Orient_deg ; 
01430:  MOV     15A4,W4
01432:  MOV     #B4,W3
01434:  CP      W3,W4
01436:  BRA     LT,1444
01438:  MOV     #B4,W4
0143A:  MOV     15A4,W3
0143C:  SUB     W4,W3,W0
0143E:  MOV     W0,15A4
01440:  GOTO    144C
.................... 		else Orient_deg = 540 - Orient_deg ; 
01444:  MOV     #21C,W4
01446:  MOV     15A4,W3
01448:  SUB     W4,W3,W0
0144A:  MOV     W0,15A4
.................... 	}		 
.................... 	Orient = (float64)(Orient_deg*PI/180); 
0144C:  MOV     15A4,W0
0144E:  CLR     W3
01450:  BTSC    W0.F
01452:  SETM    W3
01454:  MOV     W3,W1
01456:  MOV     W3,W2
01458:  CALL    1394
0145C:  MOV     #2D18,W4
0145E:  MOV     #5444,W5
01460:  MOV     #21FB,W6
01462:  MOV     #4009,W7
01464:  CALL    BCA
01468:  MOV     W0,W5
0146A:  MOV     W1,W6
0146C:  MOV     W2,W7
0146E:  MOV     W3,W8
01470:  MOV     W5,[W15++]
01472:  MOV     W6,[W15++]
01474:  MOV     W7,[W15++]
01476:  MOV     W5,W0
01478:  MOV     W6,W1
0147A:  MOV     W7,W2
0147C:  MOV     W8,W3
0147E:  MOV     #0,W4
01480:  MOV     #0,W5
01482:  MOV     #8000,W6
01484:  MOV     #4066,W7
01486:  CALL    CDA
0148A:  MOV     [--W15],W7
0148C:  MOV     [--W15],W6
0148E:  MOV     [--W15],W5
01490:  MOV     W0,15AE
01492:  MOV     W1,15B0
01494:  MOV     W2,15B2
01496:  MOV     W3,15B4
01498:  MOV     [--W15],W8
0149A:  MOV     [--W15],W7
0149C:  MOV     [--W15],W6
0149E:  MOV     [--W15],W5
014A0:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __Action_Writting(unsigned int8 _Command) 
.................... * \brief Demande d'criture, entre 0x00 et 0x79. 
.................... * 
.................... * \author Barman Corentin / rev. Amand Axel 
.................... * \version 2.0 
.................... * \date 19.11.2015 
.................... * 
.................... * \param[in] _Command Choisit la commande  effectuer 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __DeplToDo(unsigned int8 _Command) 
.................... { 
.................... 	switch(_Command) 
*
08858:  MOV.B   1B3A,W0L
0885A:  CLR.B   1
0885C:  XOR     #0,W0
0885E:  BRA     Z,886E
08860:  XOR     #1,W0
08862:  BRA     Z,887A
08864:  XOR     #3,W0
08866:  BRA     Z,888A
08868:  XOR     #1,W0
0886A:  BRA     Z,889A
0886C:  BRA     88A2
.................... 	{ 
.................... 		// !!! En ajoutant des types de dplacement, 
.................... 		//		pensez  les grer dans __LoadObj() tout en bas du fichier. 
.................... 		//		Comme le X est par exemple utiliser pour donner un angle, 
.................... 		//		si comme un dpl. PP vous fates TailleTable - X .... 
.................... 		//		Autant dire que le robot va faire n'importe quoi ^^ 
.................... 		case 0 : 
.................... 			__Turn((signed int16) oXp);			 
0886E:  PUSH    14AE
08870:  POP     1B3C
08872:  CALL    6A92
.................... 			break; 
08876:  GOTO    88AE
.................... 		case 1 : 
.................... 			__PaP(oXp, oYp); 
0887A:  PUSH    14AE
0887C:  POP     1B40
0887E:  PUSH    14B0
08880:  POP     1B42
08882:  CALL    76A6
.................... 			break; 
08886:  GOTO    88AE
.................... 		case 2 : 
.................... 			__Progress(oXp, oYp); //se dplace d'une certaine distance, jusqu'a ce qu'on tape dans un bord, ou que l'ordre soit fini 
0888A:  PUSH    14AE
0888C:  POP     1B3C
0888E:  PUSH    14B0
08890:  POP     1B3E
08892:  CALL    84BC
.................... 			break; 
08896:  GOTO    88AE
.................... 		case 3 : 
.................... 			__Nothing(); 
0889A:  CALL    8848
.................... 			break; 
0889E:  GOTO    88AE
.................... 		default: 
.................... 			__Affichage_erreur(4); 
088A2:  MOV.B   #4,W0L
088A4:  MOV.B   W0L,1B3C
088A6:  CALL    8850
.................... 			break; 
088AA:  GOTO    88AE
.................... 	} 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
088AE:  RETURN  
.................... 	 
.................... 	 
.................... } 
....................  
....................  
.................... void __Stop() 
.................... { 
.................... 		 
.................... 	/////////////////// effacer l'ordre en cours  ///////////////////  
....................    	fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
*
06334:  MOV     #0,W1
06336:  MOV     W1,W0
06338:  CLR.B   1
0633A:  CALL    136
0633E:  INC     W1,W1
06340:  BTSC.B  219.1
06342:  BRA     6340
06344:  MOV     W0,21A
06346:  MOV     #13,W0
06348:  CPSGT   W1,W0
0634A:  BRA     6336
....................    	delay_ms(10); 
0634C:  MOV     #A,W0
0634E:  CALL    DE2
....................    	fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
06352:  MOV     #0,W1
06354:  MOV     W1,W0
06356:  CLR.B   1
06358:  CALL    158
0635C:  INC     W1,W1
0635E:  BTSC.B  219.1
06360:  BRA     635E
06362:  MOV     W0,21A
06364:  MOV     #13,W0
06366:  CPSGT   W1,W0
06368:  BRA     6354
....................    	 
....................    	Etat_rob = Wait_end; 
0636A:  MOV.B   #8,W0L
0636C:  MOV.B   W0L,87B
0636E:  RETURN  
.................... }   	 
.................... /** 
.................... * \fn void __Turn(signed int16 _Ang) 
.................... * \brief Tourne sur place jusqu'a l'angle donne. 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] Angle d'arrive  
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Turn(signed int16 _Ang) 
*
06A92:  MOV     W5,[W15++]
06A94:  MOV     W6,[W15++]
06A96:  MOV     W7,[W15++]
06A98:  MOV     W8,[W15++]
06A9A:  CLR     1B3E
06A9C:  CLR     1B40
06A9E:  CLR     1B42
06AA0:  CLR     1B44
06AA2:  CLR     1B46
06AA4:  CLR     1B48
06AA6:  CLR     1B4A
06AA8:  CLR     1B4C
06AAA:  CLR     1B4E
06AAC:  CLR     1B50
06AAE:  CLR     1B52
06AB0:  CLR     1B54
06AB2:  CLR     1B56
06AB4:  CLR     1B58
.................... { 
.................... 	float64 AngToDo = 0;			 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer en nombre d'impulses 
.................... 	signed int32 impulse_g = 0; 	//impulse mot g 
.................... 	signed int32 impulse_d = 0;		//impulse mot d 
.................... 	float64 temporaire = 0; 
....................  
.................... 	// Convertit la valeur de l'angle en radian 
.................... 	AngToDo = (_Ang * CONV_DEG_RAD) - Orient ; 
06AB6:  MOV     1B3C,W0
06AB8:  CLR     W3
06ABA:  BTSC    W0.F
06ABC:  SETM    W3
06ABE:  MOV     W3,W1
06AC0:  MOV     W3,W2
06AC2:  CALL    1394
06AC6:  MOV     15D6,W4
06AC8:  MOV     15D8,W5
06ACA:  MOV     15DA,W6
06ACC:  MOV     15DC,W7
06ACE:  CALL    BCA
06AD2:  MOV     W0,W5
06AD4:  MOV     W1,W6
06AD6:  MOV     W2,W7
06AD8:  MOV     W3,W8
06ADA:  BSET.B  43.0
06ADC:  MOV     W5,[W15++]
06ADE:  MOV     W6,[W15++]
06AE0:  MOV     W7,[W15++]
06AE2:  MOV     W5,W0
06AE4:  MOV     W6,W1
06AE6:  MOV     W7,W2
06AE8:  MOV     W8,W3
06AEA:  MOV     15AE,W4
06AEC:  MOV     15B0,W5
06AEE:  MOV     15B2,W6
06AF0:  MOV     15B4,W7
06AF2:  CALL    6536
06AF6:  MOV     [--W15],W7
06AF8:  MOV     [--W15],W6
06AFA:  MOV     [--W15],W5
06AFC:  MOV     W0,1B3E
06AFE:  MOV     W1,1B40
06B00:  MOV     W2,1B42
06B02:  MOV     W3,1B44
....................  
.................... 	if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
06B04:  MOV     14B6,W4
06B06:  CP      W4,#2
06B08:  BRA     NZ,6B42
06B0A:  MOV     #0,W0
06B0C:  MOV     #0,W1
06B0E:  MOV     #0,W2
06B10:  MOV     #0,W3
06B12:  MOV     1B3E,W4
06B14:  MOV     1B40,W5
06B16:  MOV     1B42,W6
06B18:  MOV     1B44,W7
06B1A:  CALL    6724
06B1E:  BRA     NC,6B42
.................... 	{ 
.................... 		AngToDo += -2 * PI; //on tourne sur la gauche 
06B20:  BCLR.B  43.0
06B22:  MOV     1B3E,W0
06B24:  MOV     1B40,W1
06B26:  MOV     1B42,W2
06B28:  MOV     1B44,W3
06B2A:  MOV     #2D18,W4
06B2C:  MOV     #5444,W5
06B2E:  MOV     #21FB,W6
06B30:  MOV     #C019,W7
06B32:  CALL    6536
06B36:  MOV     W0,1B3E
06B38:  MOV     W1,1B40
06B3A:  MOV     W2,1B42
06B3C:  MOV     W3,1B44
.................... 	}	 
06B3E:  GOTO    6B7C
.................... 	else if(oCoteTourn==1&&AngToDo<0) // on force le robot  tourner sur la gauche 	 
06B42:  MOV     14B6,W4
06B44:  CP      W4,#1
06B46:  BRA     NZ,6B7C
06B48:  MOV     1B3E,W0
06B4A:  MOV     1B40,W1
06B4C:  MOV     1B42,W2
06B4E:  MOV     1B44,W3
06B50:  MOV     #0,W4
06B52:  MOV     #0,W5
06B54:  MOV     #0,W6
06B56:  MOV     #0,W7
06B58:  CALL    6724
06B5C:  BRA     NC,6B7C
.................... 	{ 
.................... 		AngToDo += 2 * PI;//On tourne sur la droite	 
06B5E:  BCLR.B  43.0
06B60:  MOV     1B3E,W0
06B62:  MOV     1B40,W1
06B64:  MOV     1B42,W2
06B66:  MOV     1B44,W3
06B68:  MOV     #2D18,W4
06B6A:  MOV     #5444,W5
06B6C:  MOV     #21FB,W6
06B6E:  MOV     #4019,W7
06B70:  CALL    6536
06B74:  MOV     W0,1B3E
06B76:  MOV     W1,1B40
06B78:  MOV     W2,1B42
06B7A:  MOV     W3,1B44
.................... 	} 
.................... 	 
.................... 	if(AngToDo > PI && oCoteTourn==0) // on a plus de 180 
06B7C:  MOV     #2D18,W0
06B7E:  MOV     #5444,W1
06B80:  MOV     #21FB,W2
06B82:  MOV     #4009,W3
06B84:  MOV     1B3E,W4
06B86:  MOV     1B40,W5
06B88:  MOV     1B42,W6
06B8A:  MOV     1B44,W7
06B8C:  CALL    6724
06B90:  BRA     NC,6BB8
06B92:  CP0     14B6
06B94:  BRA     NZ,6BB8
.................... 	{ 
.................... 		AngToDo -= 2*PI; // on tourne ds l'autre sens 
06B96:  BSET.B  43.0
06B98:  MOV     1B3E,W0
06B9A:  MOV     1B40,W1
06B9C:  MOV     1B42,W2
06B9E:  MOV     1B44,W3
06BA0:  MOV     #2D18,W4
06BA2:  MOV     #5444,W5
06BA4:  MOV     #21FB,W6
06BA6:  MOV     #4019,W7
06BA8:  CALL    6536
06BAC:  MOV     W0,1B3E
06BAE:  MOV     W1,1B40
06BB0:  MOV     W2,1B42
06BB2:  MOV     W3,1B44
.................... 	} 
06BB4:  GOTO    6BF0
.................... 	else if(AngToDo < -PI  && oCoteTourn==0) // si on moins que -180   
06BB8:  MOV     1B3E,W0
06BBA:  MOV     1B40,W1
06BBC:  MOV     1B42,W2
06BBE:  MOV     1B44,W3
06BC0:  MOV     #2D18,W4
06BC2:  MOV     #5444,W5
06BC4:  MOV     #21FB,W6
06BC6:  MOV     #C009,W7
06BC8:  CALL    6724
06BCC:  BRA     NC,6BF0
06BCE:  CP0     14B6
06BD0:  BRA     NZ,6BF0
.................... 	{ 
.................... 		AngToDo += 2 * PI; // on tourne ds l'autre sens 
06BD2:  BCLR.B  43.0
06BD4:  MOV     1B3E,W0
06BD6:  MOV     1B40,W1
06BD8:  MOV     1B42,W2
06BDA:  MOV     1B44,W3
06BDC:  MOV     #2D18,W4
06BDE:  MOV     #5444,W5
06BE0:  MOV     #21FB,W6
06BE2:  MOV     #4019,W7
06BE4:  CALL    6536
06BE8:  MOV     W0,1B3E
06BEA:  MOV     W1,1B40
06BEC:  MOV     W2,1B42
06BEE:  MOV     W3,1B44
.................... 	}	 
....................  
.................... 	if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
06BF0:  MOV     #432D,W0
06BF2:  MOV     #EB1C,W1
06BF4:  MOV     #36E2,W2
06BF6:  MOV     #BF1A,W3
06BF8:  MOV     1B3E,W4
06BFA:  MOV     1B40,W5
06BFC:  MOV     1B42,W6
06BFE:  MOV     1B44,W7
06C00:  CALL    6724
06C04:  BRA     NC,6C24
06C06:  MOV     1B3E,W0
06C08:  MOV     1B40,W1
06C0A:  MOV     1B42,W2
06C0C:  MOV     1B44,W3
06C0E:  MOV     #432D,W4
06C10:  MOV     #EB1C,W5
06C12:  MOV     #36E2,W6
06C14:  MOV     #3F1A,W7
06C16:  CALL    6724
06C1A:  BRA     NC,6C24
06C1C:  CLR     1B3E
06C1E:  CLR     1B40
06C20:  CLR     1B42
06C22:  CLR     1B44
.................... 	temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse ncessaire pour la rotation 
06C24:  MOV     15C6,W0
06C26:  MOV     15C8,W1
06C28:  MOV     15CA,W2
06C2A:  MOV     15CC,W3
06C2C:  MOV     15B6,W4
06C2E:  MOV     15B8,W5
06C30:  MOV     15BA,W6
06C32:  MOV     15BC,W7
06C34:  CALL    CDA
06C38:  MOV     W0,W4
06C3A:  MOV     W1,W5
06C3C:  MOV     W2,W6
06C3E:  MOV     W3,W7
06C40:  MOV     1B3E,W0
06C42:  MOV     1B40,W1
06C44:  MOV     1B42,W2
06C46:  MOV     1B44,W3
06C48:  CALL    BCA
06C4C:  MOV     W0,W5
06C4E:  MOV     W1,W6
06C50:  MOV     W2,W7
06C52:  MOV     W3,W8
06C54:  MOV     W5,[W15++]
06C56:  MOV     W6,[W15++]
06C58:  MOV     W7,[W15++]
06C5A:  MOV     W5,W0
06C5C:  MOV     W6,W1
06C5E:  MOV     W7,W2
06C60:  MOV     W8,W3
06C62:  MOV     15BE,W4
06C64:  MOV     15C0,W5
06C66:  MOV     15C2,W6
06C68:  MOV     15C4,W7
06C6A:  CALL    BCA
06C6E:  MOV     [--W15],W7
06C70:  MOV     [--W15],W6
06C72:  MOV     [--W15],W5
06C74:  MOV     W0,W5
06C76:  MOV     W1,W6
06C78:  MOV     W2,W7
06C7A:  MOV     W3,W8
06C7C:  MOV     W5,[W15++]
06C7E:  MOV     W6,[W15++]
06C80:  MOV     W7,[W15++]
06C82:  MOV     W5,W0
06C84:  MOV     W6,W1
06C86:  MOV     W7,W2
06C88:  MOV     W8,W3
06C8A:  MOV     #0,W4
06C8C:  MOV     #0,W5
06C8E:  MOV     #0,W6
06C90:  MOV     #4000,W7
06C92:  CALL    BCA
06C96:  MOV     [--W15],W7
06C98:  MOV     [--W15],W6
06C9A:  MOV     [--W15],W5
06C9C:  MOV     W0,W5
06C9E:  MOV     W1,W6
06CA0:  MOV     W2,W7
06CA2:  MOV     W3,W8
06CA4:  MOV     W5,[W15++]
06CA6:  MOV     W6,[W15++]
06CA8:  MOV     W7,[W15++]
06CAA:  MOV     W5,W0
06CAC:  MOV     W6,W1
06CAE:  MOV     W7,W2
06CB0:  MOV     W8,W3
06CB2:  MOV     #2D18,W4
06CB4:  MOV     #5444,W5
06CB6:  MOV     #21FB,W6
06CB8:  MOV     #4009,W7
06CBA:  CALL    CDA
06CBE:  MOV     [--W15],W7
06CC0:  MOV     [--W15],W6
06CC2:  MOV     [--W15],W5
06CC4:  MOV     W0,1B52
06CC6:  MOV     W1,1B54
06CC8:  MOV     W2,1B56
06CCA:  MOV     W3,1B58
.................... 	AngToDo_int = (signed int32)(arrondi_float_signed(temporaire));	 
06CCC:  MOV     1B52,W0
06CCE:  MOV     1B54,W1
06CD0:  MOV     1B56,W2
06CD2:  MOV     1B58,W3
06CD4:  CALL    67A8
06CD8:  MOV     W1,W5
06CDA:  MOV     W2,W6
06CDC:  MOV     W5,1B9C
06CDE:  MOV     W6,1B9E
06CE0:  CALL    682C
06CE4:  MOV     W0,1B46
06CE6:  MOV     W1,1B48
.................... 	// on envoie les donnee au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
06CE8:  MOV     #0,W1
06CEA:  MOV     W1,W0
06CEC:  CLR.B   1
06CEE:  CALL    17A
06CF2:  INC     W1,W1
06CF4:  BTSC.B  219.1
06CF6:  BRA     6CF4
06CF8:  MOV     W0,21A
06CFA:  MOV     #4,W0
06CFC:  CPSGT   W1,W0
06CFE:  BRA     6CEA
06D00:  MOV     14B8,W0
06D02:  MOV     #8004,W4
06D04:  CALL    6888
06D08:  MOV     #9,W1
06D0A:  MOV     W1,W0
06D0C:  CLR.B   1
06D0E:  CALL    17A
06D12:  INC     W1,W1
06D14:  BTSC.B  219.1
06D16:  BRA     6D14
06D18:  MOV     W0,21A
06D1A:  MOV     #E,W0
06D1C:  CPSGT   W1,W0
06D1E:  BRA     6D0A
06D20:  MOV     14B8,W0
06D22:  MOV     #8004,W4
06D24:  CALL    6888
06D28:  BTSC.B  219.1
06D2A:  BRA     6D28
06D2C:  MOV     #20,W4
06D2E:  MOV     W4,21A
06D30:  BTSC.B  219.1
06D32:  BRA     6D30
06D34:  MOV     #D,W4
06D36:  MOV     W4,21A
.................... 	 
.................... 	//balise  
.................... 	balise_on = 0; 
06D38:  BCLR.B  85B.2
.................... 	 
.................... 	impulse_g = AngToDo_int; 
06D3A:  PUSH    1B46
06D3C:  POP     1B4A
06D3E:  PUSH    1B48
06D40:  POP     1B4C
.................... 	impulse_d = 0-AngToDo_int; 
06D42:  MOV     #0,W4
06D44:  MOV     1B46,W3
06D46:  SUB     W4,W3,W0
06D48:  MOV     W0,1B4E
06D4A:  MOV     #0,W4
06D4C:  MOV     1B48,W3
06D4E:  SUBB    W4,W3,W0
06D50:  MOV     W0,1B50
.................... 	fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
06D52:  MOV     #0,W1
06D54:  MOV     W1,W0
06D56:  CLR.B   1
06D58:  CALL    19C
06D5C:  INC     W1,W1
06D5E:  BTSC.B  219.1
06D60:  BRA     6D5E
06D62:  MOV     W0,21A
06D64:  MOV     #5,W0
06D66:  CPSGT   W1,W0
06D68:  BRA     6D54
06D6A:  MOV     1B4A,W0
06D6C:  MOV     1B4C,W1
06D6E:  MOV     #0,W4
06D70:  CALL    697E
06D74:  MOV     #8,W1
06D76:  MOV     W1,W0
06D78:  CLR.B   1
06D7A:  CALL    19C
06D7E:  INC     W1,W1
06D80:  BTSC.B  219.1
06D82:  BRA     6D80
06D84:  MOV     W0,21A
06D86:  MOV     #E,W0
06D88:  CPSGT   W1,W0
06D8A:  BRA     6D76
06D8C:  MOV     1B4E,W0
06D8E:  MOV     1B50,W1
06D90:  MOV     #0,W4
06D92:  CALL    697E
06D96:  BTSC.B  219.1
06D98:  BRA     6D96
06D9A:  MOV     #20,W4
06D9C:  MOV     W4,21A
06D9E:  BTSC.B  219.1
06DA0:  BRA     6D9E
06DA2:  MOV     #D,W4
06DA4:  MOV     W4,21A
.................... 	 
.................... 	Depl_send = 1; 
06DA6:  BSET.B  85B.6
.................... 	Orient = (float64)(_Ang * CONV_DEG_RAD); // mise  jour de l'angle 
06DA8:  MOV     1B3C,W0
06DAA:  CLR     W3
06DAC:  BTSC    W0.F
06DAE:  SETM    W3
06DB0:  MOV     W3,W1
06DB2:  MOV     W3,W2
06DB4:  CALL    1394
06DB8:  MOV     15D6,W4
06DBA:  MOV     15D8,W5
06DBC:  MOV     15DA,W6
06DBE:  MOV     15DC,W7
06DC0:  CALL    BCA
06DC4:  MOV     W0,15AE
06DC6:  MOV     W1,15B0
06DC8:  MOV     W2,15B2
06DCA:  MOV     W3,15B4
06DCC:  MOV     [--W15],W8
06DCE:  MOV     [--W15],W7
06DD0:  MOV     [--W15],W6
06DD2:  MOV     [--W15],W5
06DD4:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __PaP(signed int16 _X, signed int16 _Y) 
.................... * \brief Depl Pap du robot. 
.................... *		Le deplacement se fait tel que : 
.................... *			- Rotation vers le point a atteindre 
.................... *			- Deplacement ligne droite 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] coordonee x,y de la pos d'arrivee 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __PaP(signed int16 _X, signed int16 _Y) 
*
076A6:  MOV     W5,[W15++]
076A8:  MOV     #C,W5
076AA:  REPEAT  #3
076AC:  MOV     [W5++],[W15++]
076AE:  CLR     1B54
076B0:  CLR     1B56
076B2:  CLR     1B58
076B4:  CLR     1B5A
076B6:  CLR     1B5C
076B8:  CLR     1B5E
076BA:  CLR     1B60
076BC:  CLR     1B62
076BE:  CLR     1B64
076C0:  CLR     1B66
076C2:  CLR     1B68
076C4:  CLR     1B6A
076C6:  CLR     1B6C
076C8:  CLR     1B6E
076CA:  CLR     1B70
076CC:  CLR     1B72
076CE:  CLR     1B74
076D0:  CLR     1B76
076D2:  CLR     1B78
076D4:  CLR     1B7A
.................... { 
....................  
.................... 	float64	dx,dy,distToDo = 0;	 
.................... 	signed int32 distToDo_int = 0;	//dist a effectuer 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer 
.................... 	signed int32 impulse_g = 0;	 	//impulse mot gauche 
.................... 	signed int32 impulse_d = 0;		//impulse mot droite 
.................... 	static int1 etat_deplacement = 0; 
.................... 	float64 AngToDo = 0; 
.................... 	float64 temporaire = 0; 
.................... 	 
.................... 	 
.................... 	dx = (_X - Pos_x) * (COEFF_D/10); //calcul deplacment en x et transformation en pas 
076D6:  MOV     1B40,W4
076D8:  MOV     15A0,W3
076DA:  SUB     W4,W3,W5
076DC:  MOV     W5,[W15++]
076DE:  MOV     15CE,W0
076E0:  MOV     15D0,W1
076E2:  MOV     15D2,W2
076E4:  MOV     15D4,W3
076E6:  MOV     #0,W4
076E8:  MOV     #0,W5
076EA:  MOV     #0,W6
076EC:  MOV     #4024,W7
076EE:  CALL    CDA
076F2:  MOV     [--W15],W5
076F4:  MOV     W0,W6
076F6:  MOV     W1,W7
076F8:  MOV     W2,W8
076FA:  MOV     W3,W9
076FC:  MOV     W5,W0
076FE:  CLR     W3
07700:  BTSC    W0.F
07702:  SETM    W3
07704:  MOV     W3,W1
07706:  MOV     W3,W2
07708:  CALL    1394
0770C:  MOV     W5,[W15++]
0770E:  MOV     W6,[W15++]
07710:  MOV     W7,[W15++]
07712:  MOV     W6,W4
07714:  MOV     W7,W5
07716:  MOV     W8,W6
07718:  MOV     W9,W7
0771A:  CALL    BCA
0771E:  MOV     [--W15],W7
07720:  MOV     [--W15],W6
07722:  MOV     [--W15],W5
07724:  MOV     W0,1B44
07726:  MOV     W1,1B46
07728:  MOV     W2,1B48
0772A:  MOV     W3,1B4A
.................... 	dy = (_Y - Pos_Y) * (COEFF_D/10); //calcul deplacment en y et transformation en pas 
0772C:  MOV     1B42,W4
0772E:  MOV     15A2,W3
07730:  SUB     W4,W3,W5
07732:  MOV     W5,[W15++]
07734:  MOV     15CE,W0
07736:  MOV     15D0,W1
07738:  MOV     15D2,W2
0773A:  MOV     15D4,W3
0773C:  MOV     #0,W4
0773E:  MOV     #0,W5
07740:  MOV     #0,W6
07742:  MOV     #4024,W7
07744:  CALL    CDA
07748:  MOV     [--W15],W5
0774A:  MOV     W0,W6
0774C:  MOV     W1,W7
0774E:  MOV     W2,W8
07750:  MOV     W3,W9
07752:  MOV     W5,W0
07754:  CLR     W3
07756:  BTSC    W0.F
07758:  SETM    W3
0775A:  MOV     W3,W1
0775C:  MOV     W3,W2
0775E:  CALL    1394
07762:  MOV     W5,[W15++]
07764:  MOV     W6,[W15++]
07766:  MOV     W7,[W15++]
07768:  MOV     W6,W4
0776A:  MOV     W7,W5
0776C:  MOV     W8,W6
0776E:  MOV     W9,W7
07770:  CALL    BCA
07774:  MOV     [--W15],W7
07776:  MOV     [--W15],W6
07778:  MOV     [--W15],W5
0777A:  MOV     W0,1B4C
0777C:  MOV     W1,1B4E
0777E:  MOV     W2,1B50
07780:  MOV     W3,1B52
.................... 	distToDo = sqrt((dx*dx)+(dy*dy)); //calcul de la distance 
07782:  MOV     1B44,W0
07784:  MOV     1B46,W1
07786:  MOV     1B48,W2
07788:  MOV     1B4A,W3
0778A:  MOV     1B44,W4
0778C:  MOV     1B46,W5
0778E:  MOV     1B48,W6
07790:  MOV     1B4A,W7
07792:  CALL    BCA
07796:  MOV     W0,W5
07798:  MOV     W1,W6
0779A:  MOV     W2,W7
0779C:  MOV     W3,W8
0779E:  MOV     W5,[W15++]
077A0:  MOV     W6,[W15++]
077A2:  MOV     W7,[W15++]
077A4:  MOV     1B4C,W0
077A6:  MOV     1B4E,W1
077A8:  MOV     1B50,W2
077AA:  MOV     1B52,W3
077AC:  MOV     1B4C,W4
077AE:  MOV     1B4E,W5
077B0:  MOV     1B50,W6
077B2:  MOV     1B52,W7
077B4:  CALL    BCA
077B8:  MOV     [--W15],W7
077BA:  MOV     [--W15],W6
077BC:  MOV     [--W15],W5
077BE:  BCLR.B  43.0
077C0:  MOV     W5,[W15++]
077C2:  MOV     W6,[W15++]
077C4:  MOV     W7,[W15++]
077C6:  MOV     W0,W4
077C8:  MOV     W5,W0
077CA:  MOV     W1,W5
077CC:  MOV     W6,W1
077CE:  MOV     W2,W6
077D0:  MOV     W7,W2
077D2:  MOV     W3,W7
077D4:  MOV     W8,W3
077D6:  CALL    6536
077DA:  MOV     [--W15],W7
077DC:  MOV     [--W15],W6
077DE:  MOV     [--W15],W5
077E0:  MOV     W0,W5
077E2:  MOV     W1,W6
077E4:  MOV     W2,W7
077E6:  MOV     W3,W8
077E8:  MOV     W5,1C04
077EA:  MOV     W6,1C06
077EC:  MOV     W7,1C08
077EE:  MOV     W8,1C0A
077F0:  CALL    6DD6
077F4:  MOV     W0,1B54
077F6:  MOV     W1,1B56
077F8:  MOV     W2,1B58
077FA:  MOV     W3,1B5A
.................... 	distToDo_int = distToDo ; 
077FC:  MOV     1B54,W0
077FE:  MOV     1B56,W1
07800:  MOV     1B58,W2
07802:  MOV     1B5A,W3
07804:  CALL    6EF4
07808:  MOV     W0,1B5C
0780A:  MOV     W1,1B5E
....................  
.................... 	switch(etat_deplacement) 
0780C:  CLR     W0
0780E:  BTSC.B  C24.3
07810:  INC     W0,W0
07812:  CLR.B   1
07814:  XOR     #0,W0
07816:  BRA     Z,781E
07818:  XOR     #1,W0
0781A:  BRA     Z,7D2A
0781C:  BRA     7E4A
.................... 	{ 
.................... 		case 0: // gestion de l'angle 
.................... 		 
.................... 			/////////////////////////////////////////////// 
.................... 			//////////Calcul de l'angle//////////////////// 
.................... 			/////////////////////////////////////////////// 
.................... 				if(dx >= 0) // 1er et 4eme quadrant 
0781E:  MOV     #0,W0
07820:  MOV     #0,W1
07822:  MOV     #0,W2
07824:  MOV     #0,W3
07826:  MOV     1B44,W4
07828:  MOV     1B46,W5
0782A:  MOV     1B48,W6
0782C:  MOV     1B4A,W7
0782E:  CALL    6724
07832:  BRA     C,7836
07834:  BRA     NZ,7894
.................... 				{ 
.................... 					AngToDo = asin(dy/distToDo) - Orient;	 
07836:  MOV     1B4C,W0
07838:  MOV     1B4E,W1
0783A:  MOV     1B50,W2
0783C:  MOV     1B52,W3
0783E:  MOV     1B54,W4
07840:  MOV     1B56,W5
07842:  MOV     1B58,W6
07844:  MOV     1B5A,W7
07846:  CALL    CDA
0784A:  MOV     W0,W5
0784C:  MOV     W1,W6
0784E:  MOV     W2,W7
07850:  MOV     W3,W8
07852:  MOV     W5,1BA0
07854:  MOV     W6,1BA2
07856:  MOV     W7,1BA4
07858:  MOV     W8,1BA6
0785A:  CALL    7358
0785E:  MOV     W0,W5
07860:  MOV     W1,W6
07862:  MOV     W2,W7
07864:  MOV     W3,W8
07866:  BSET.B  43.0
07868:  MOV     W5,[W15++]
0786A:  MOV     W6,[W15++]
0786C:  MOV     W7,[W15++]
0786E:  MOV     W5,W0
07870:  MOV     W6,W1
07872:  MOV     W7,W2
07874:  MOV     W8,W3
07876:  MOV     15AE,W4
07878:  MOV     15B0,W5
0787A:  MOV     15B2,W6
0787C:  MOV     15B4,W7
0787E:  CALL    6536
07882:  MOV     [--W15],W7
07884:  MOV     [--W15],W6
07886:  MOV     [--W15],W5
07888:  MOV     W0,1B6C
0788A:  MOV     W1,1B6E
0788C:  MOV     W2,1B70
0788E:  MOV     W3,1B72
.................... 				} 
07890:  GOTO    79F0
.................... 				 
.................... 				else if(dx <= 0 && dy > 0)//2eme quandrant 
07894:  MOV     1B44,W0
07896:  MOV     1B46,W1
07898:  MOV     1B48,W2
0789A:  MOV     1B4A,W3
0789C:  MOV     #0,W4
0789E:  MOV     #0,W5
078A0:  MOV     #0,W6
078A2:  MOV     #0,W7
078A4:  CALL    6724
078A8:  BRA     C,78AC
078AA:  BRA     NZ,7920
078AC:  MOV     #0,W0
078AE:  MOV     #0,W1
078B0:  MOV     #0,W2
078B2:  MOV     #0,W3
078B4:  MOV     1B4C,W4
078B6:  MOV     1B4E,W5
078B8:  MOV     1B50,W6
078BA:  MOV     1B52,W7
078BC:  CALL    6724
078C0:  BRA     NC,7920
.................... 				{ 
.................... 					AngToDo = acos(dx/distToDo) - Orient; 
078C2:  MOV     1B44,W0
078C4:  MOV     1B46,W1
078C6:  MOV     1B48,W2
078C8:  MOV     1B4A,W3
078CA:  MOV     1B54,W4
078CC:  MOV     1B56,W5
078CE:  MOV     1B58,W6
078D0:  MOV     1B5A,W7
078D2:  CALL    CDA
078D6:  MOV     W0,W5
078D8:  MOV     W1,W6
078DA:  MOV     W2,W7
078DC:  MOV     W3,W8
078DE:  MOV     W5,1BA0
078E0:  MOV     W6,1BA2
078E2:  MOV     W7,1BA4
078E4:  MOV     W8,1BA6
078E6:  CALL    7380
078EA:  MOV     W0,W5
078EC:  MOV     W1,W6
078EE:  MOV     W2,W7
078F0:  MOV     W3,W8
078F2:  BSET.B  43.0
078F4:  MOV     W5,[W15++]
078F6:  MOV     W6,[W15++]
078F8:  MOV     W7,[W15++]
078FA:  MOV     W5,W0
078FC:  MOV     W6,W1
078FE:  MOV     W7,W2
07900:  MOV     W8,W3
07902:  MOV     15AE,W4
07904:  MOV     15B0,W5
07906:  MOV     15B2,W6
07908:  MOV     15B4,W7
0790A:  CALL    6536
0790E:  MOV     [--W15],W7
07910:  MOV     [--W15],W6
07912:  MOV     [--W15],W5
07914:  MOV     W0,1B6C
07916:  MOV     W1,1B6E
07918:  MOV     W2,1B70
0791A:  MOV     W3,1B72
.................... 				} 
0791C:  GOTO    79F0
.................... 				 
.................... 				else if(dx < 0 && dy <= 0)//3eme quadrant 
07920:  MOV     1B44,W0
07922:  MOV     1B46,W1
07924:  MOV     1B48,W2
07926:  MOV     1B4A,W3
07928:  MOV     #0,W4
0792A:  MOV     #0,W5
0792C:  MOV     #0,W6
0792E:  MOV     #0,W7
07930:  CALL    6724
07934:  BRA     NC,79F0
07936:  MOV     1B4C,W0
07938:  MOV     1B4E,W1
0793A:  MOV     1B50,W2
0793C:  MOV     1B52,W3
0793E:  MOV     #0,W4
07940:  MOV     #0,W5
07942:  MOV     #0,W6
07944:  MOV     #0,W7
07946:  CALL    6724
0794A:  BRA     C,794E
0794C:  BRA     NZ,79F0
.................... 				{ 
.................... 					AngToDo = asin(abs(dy)/distToDo) + PI - Orient;	 
0794E:  MOV     1B4C,W0
07950:  MOV     1B4E,W1
07952:  MOV     1B50,W2
07954:  MOV     1B52,W3
07956:  BCLR    W3.F
07958:  MOV     W0,W5
0795A:  MOV     W1,W6
0795C:  MOV     W2,W7
0795E:  MOV     W3,W8
07960:  MOV     W5,[W15++]
07962:  MOV     W6,[W15++]
07964:  MOV     W7,[W15++]
07966:  MOV     W5,W0
07968:  MOV     W6,W1
0796A:  MOV     W7,W2
0796C:  MOV     W8,W3
0796E:  MOV     1B54,W4
07970:  MOV     1B56,W5
07972:  MOV     1B58,W6
07974:  MOV     1B5A,W7
07976:  CALL    CDA
0797A:  MOV     [--W15],W7
0797C:  MOV     [--W15],W6
0797E:  MOV     [--W15],W5
07980:  MOV     W0,W5
07982:  MOV     W1,W6
07984:  MOV     W2,W7
07986:  MOV     W3,W8
07988:  MOV     W5,1BA0
0798A:  MOV     W6,1BA2
0798C:  MOV     W7,1BA4
0798E:  MOV     W8,1BA6
07990:  CALL    7358
07994:  MOV     W0,W5
07996:  MOV     W1,W6
07998:  MOV     W2,W7
0799A:  MOV     W3,W8
0799C:  BCLR.B  43.0
0799E:  MOV     W5,[W15++]
079A0:  MOV     W6,[W15++]
079A2:  MOV     W7,[W15++]
079A4:  MOV     W5,W0
079A6:  MOV     W6,W1
079A8:  MOV     W7,W2
079AA:  MOV     W8,W3
079AC:  MOV     #2D18,W4
079AE:  MOV     #5444,W5
079B0:  MOV     #21FB,W6
079B2:  MOV     #4009,W7
079B4:  CALL    6536
079B8:  MOV     [--W15],W7
079BA:  MOV     [--W15],W6
079BC:  MOV     [--W15],W5
079BE:  MOV     W0,W5
079C0:  MOV     W1,W6
079C2:  MOV     W2,W7
079C4:  MOV     W3,W8
079C6:  BSET.B  43.0
079C8:  MOV     W5,[W15++]
079CA:  MOV     W6,[W15++]
079CC:  MOV     W7,[W15++]
079CE:  MOV     W5,W0
079D0:  MOV     W6,W1
079D2:  MOV     W7,W2
079D4:  MOV     W8,W3
079D6:  MOV     15AE,W4
079D8:  MOV     15B0,W5
079DA:  MOV     15B2,W6
079DC:  MOV     15B4,W7
079DE:  CALL    6536
079E2:  MOV     [--W15],W7
079E4:  MOV     [--W15],W6
079E6:  MOV     [--W15],W5
079E8:  MOV     W0,1B6C
079EA:  MOV     W1,1B6E
079EC:  MOV     W2,1B70
079EE:  MOV     W3,1B72
.................... 				} 
.................... 				 
.................... 			//////////////////////////////////////////////// 
.................... 			////////////Gestion de l'angle////////////////// 
.................... 			//////////////////////////////////////////////// 
.................... 				if(oAvAr) 
079F0:  CP0     14B4
079F2:  BRA     Z,7A7E
.................... 				{ 
.................... 					AngToDo += PI;	 
079F4:  BCLR.B  43.0
079F6:  MOV     1B6C,W0
079F8:  MOV     1B6E,W1
079FA:  MOV     1B70,W2
079FC:  MOV     1B72,W3
079FE:  MOV     #2D18,W4
07A00:  MOV     #5444,W5
07A02:  MOV     #21FB,W6
07A04:  MOV     #4009,W7
07A06:  CALL    6536
07A0A:  MOV     W0,1B6C
07A0C:  MOV     W1,1B6E
07A0E:  MOV     W2,1B70
07A10:  MOV     W3,1B72
.................... 					if(AngToDo > PI) // si on a plus de 180 
07A12:  MOV     #2D18,W0
07A14:  MOV     #5444,W1
07A16:  MOV     #21FB,W2
07A18:  MOV     #4009,W3
07A1A:  MOV     1B6C,W4
07A1C:  MOV     1B6E,W5
07A1E:  MOV     1B70,W6
07A20:  MOV     1B72,W7
07A22:  CALL    6724
07A26:  BRA     NC,7A4A
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
07A28:  BSET.B  43.0
07A2A:  MOV     1B6C,W0
07A2C:  MOV     1B6E,W1
07A2E:  MOV     1B70,W2
07A30:  MOV     1B72,W3
07A32:  MOV     #2D18,W4
07A34:  MOV     #5444,W5
07A36:  MOV     #21FB,W6
07A38:  MOV     #4019,W7
07A3A:  CALL    6536
07A3E:  MOV     W0,1B6C
07A40:  MOV     W1,1B6E
07A42:  MOV     W2,1B70
07A44:  MOV     W3,1B72
.................... 					} 
07A46:  GOTO    7A7E
.................... 					else if(AngToDo < -PI) // si on moins que -180   
07A4A:  MOV     1B6C,W0
07A4C:  MOV     1B6E,W1
07A4E:  MOV     1B70,W2
07A50:  MOV     1B72,W3
07A52:  MOV     #2D18,W4
07A54:  MOV     #5444,W5
07A56:  MOV     #21FB,W6
07A58:  MOV     #C009,W7
07A5A:  CALL    6724
07A5E:  BRA     NC,7A7E
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07A60:  BCLR.B  43.0
07A62:  MOV     1B6C,W0
07A64:  MOV     1B6E,W1
07A66:  MOV     1B70,W2
07A68:  MOV     1B72,W3
07A6A:  MOV     #2D18,W4
07A6C:  MOV     #5444,W5
07A6E:  MOV     #21FB,W6
07A70:  MOV     #4019,W7
07A72:  CALL    6536
07A76:  MOV     W0,1B6C
07A78:  MOV     W1,1B6E
07A7A:  MOV     W2,1B70
07A7C:  MOV     W3,1B72
.................... 					} 
.................... 				}					 
.................... 				if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
07A7E:  MOV     14B6,W4
07A80:  CP      W4,#2
07A82:  BRA     NZ,7ABC
07A84:  MOV     #0,W0
07A86:  MOV     #0,W1
07A88:  MOV     #0,W2
07A8A:  MOV     #0,W3
07A8C:  MOV     1B6C,W4
07A8E:  MOV     1B6E,W5
07A90:  MOV     1B70,W6
07A92:  MOV     1B72,W7
07A94:  CALL    6724
07A98:  BRA     NC,7ABC
.................... 				{ 
.................... 					AngToDo += -2 * PI; //on tourne sur la gauche 
07A9A:  BCLR.B  43.0
07A9C:  MOV     1B6C,W0
07A9E:  MOV     1B6E,W1
07AA0:  MOV     1B70,W2
07AA2:  MOV     1B72,W3
07AA4:  MOV     #2D18,W4
07AA6:  MOV     #5444,W5
07AA8:  MOV     #21FB,W6
07AAA:  MOV     #C019,W7
07AAC:  CALL    6536
07AB0:  MOV     W0,1B6C
07AB2:  MOV     W1,1B6E
07AB4:  MOV     W2,1B70
07AB6:  MOV     W3,1B72
.................... 				}	 
07AB8:  GOTO    7B6A
.................... 				 
.................... 				else if(oCoteTourn==1&&AngToDo<0) // on force le robot  tourner sur la gauche 	 
07ABC:  MOV     14B6,W4
07ABE:  CP      W4,#1
07AC0:  BRA     NZ,7AFA
07AC2:  MOV     1B6C,W0
07AC4:  MOV     1B6E,W1
07AC6:  MOV     1B70,W2
07AC8:  MOV     1B72,W3
07ACA:  MOV     #0,W4
07ACC:  MOV     #0,W5
07ACE:  MOV     #0,W6
07AD0:  MOV     #0,W7
07AD2:  CALL    6724
07AD6:  BRA     NC,7AFA
.................... 				{ 
.................... 					AngToDo += 2 * PI;//On tourne sur la droite	 
07AD8:  BCLR.B  43.0
07ADA:  MOV     1B6C,W0
07ADC:  MOV     1B6E,W1
07ADE:  MOV     1B70,W2
07AE0:  MOV     1B72,W3
07AE2:  MOV     #2D18,W4
07AE4:  MOV     #5444,W5
07AE6:  MOV     #21FB,W6
07AE8:  MOV     #4019,W7
07AEA:  CALL    6536
07AEE:  MOV     W0,1B6C
07AF0:  MOV     W1,1B6E
07AF2:  MOV     W2,1B70
07AF4:  MOV     W3,1B72
.................... 				}				 
07AF6:  GOTO    7B6A
.................... 				 
.................... 				else if(oCoteTourn==0) 
07AFA:  CP0     14B6
07AFC:  BRA     NZ,7B6A
.................... 				{ 
.................... 					if(AngToDo > PI) // si on a plus de 180 
07AFE:  MOV     #2D18,W0
07B00:  MOV     #5444,W1
07B02:  MOV     #21FB,W2
07B04:  MOV     #4009,W3
07B06:  MOV     1B6C,W4
07B08:  MOV     1B6E,W5
07B0A:  MOV     1B70,W6
07B0C:  MOV     1B72,W7
07B0E:  CALL    6724
07B12:  BRA     NC,7B36
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
07B14:  BSET.B  43.0
07B16:  MOV     1B6C,W0
07B18:  MOV     1B6E,W1
07B1A:  MOV     1B70,W2
07B1C:  MOV     1B72,W3
07B1E:  MOV     #2D18,W4
07B20:  MOV     #5444,W5
07B22:  MOV     #21FB,W6
07B24:  MOV     #4019,W7
07B26:  CALL    6536
07B2A:  MOV     W0,1B6C
07B2C:  MOV     W1,1B6E
07B2E:  MOV     W2,1B70
07B30:  MOV     W3,1B72
.................... 					} 
07B32:  GOTO    7B6A
.................... 					else if(AngToDo < -PI) // si on moins que -180   
07B36:  MOV     1B6C,W0
07B38:  MOV     1B6E,W1
07B3A:  MOV     1B70,W2
07B3C:  MOV     1B72,W3
07B3E:  MOV     #2D18,W4
07B40:  MOV     #5444,W5
07B42:  MOV     #21FB,W6
07B44:  MOV     #C009,W7
07B46:  CALL    6724
07B4A:  BRA     NC,7B6A
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
07B4C:  BCLR.B  43.0
07B4E:  MOV     1B6C,W0
07B50:  MOV     1B6E,W1
07B52:  MOV     1B70,W2
07B54:  MOV     1B72,W3
07B56:  MOV     #2D18,W4
07B58:  MOV     #5444,W5
07B5A:  MOV     #21FB,W6
07B5C:  MOV     #4019,W7
07B5E:  CALL    6536
07B62:  MOV     W0,1B6C
07B64:  MOV     W1,1B6E
07B66:  MOV     W2,1B70
07B68:  MOV     W3,1B72
.................... 					}	 
.................... 				} 
.................... 				 
.................... 			if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
07B6A:  MOV     #432D,W0
07B6C:  MOV     #EB1C,W1
07B6E:  MOV     #36E2,W2
07B70:  MOV     #BF1A,W3
07B72:  MOV     1B6C,W4
07B74:  MOV     1B6E,W5
07B76:  MOV     1B70,W6
07B78:  MOV     1B72,W7
07B7A:  CALL    6724
07B7E:  BRA     NC,7B9E
07B80:  MOV     1B6C,W0
07B82:  MOV     1B6E,W1
07B84:  MOV     1B70,W2
07B86:  MOV     1B72,W3
07B88:  MOV     #432D,W4
07B8A:  MOV     #EB1C,W5
07B8C:  MOV     #36E2,W6
07B8E:  MOV     #3F1A,W7
07B90:  CALL    6724
07B94:  BRA     NC,7B9E
07B96:  CLR     1B6C
07B98:  CLR     1B6E
07B9A:  CLR     1B70
07B9C:  CLR     1B72
.................... 			temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse ncessaire pour la rotation 
07B9E:  MOV     15C6,W0
07BA0:  MOV     15C8,W1
07BA2:  MOV     15CA,W2
07BA4:  MOV     15CC,W3
07BA6:  MOV     15B6,W4
07BA8:  MOV     15B8,W5
07BAA:  MOV     15BA,W6
07BAC:  MOV     15BC,W7
07BAE:  CALL    CDA
07BB2:  MOV     W0,W4
07BB4:  MOV     W1,W5
07BB6:  MOV     W2,W6
07BB8:  MOV     W3,W7
07BBA:  MOV     1B6C,W0
07BBC:  MOV     1B6E,W1
07BBE:  MOV     1B70,W2
07BC0:  MOV     1B72,W3
07BC2:  CALL    BCA
07BC6:  MOV     W0,W5
07BC8:  MOV     W1,W6
07BCA:  MOV     W2,W7
07BCC:  MOV     W3,W8
07BCE:  MOV     W5,[W15++]
07BD0:  MOV     W6,[W15++]
07BD2:  MOV     W7,[W15++]
07BD4:  MOV     W5,W0
07BD6:  MOV     W6,W1
07BD8:  MOV     W7,W2
07BDA:  MOV     W8,W3
07BDC:  MOV     15BE,W4
07BDE:  MOV     15C0,W5
07BE0:  MOV     15C2,W6
07BE2:  MOV     15C4,W7
07BE4:  CALL    BCA
07BE8:  MOV     [--W15],W7
07BEA:  MOV     [--W15],W6
07BEC:  MOV     [--W15],W5
07BEE:  MOV     W0,W5
07BF0:  MOV     W1,W6
07BF2:  MOV     W2,W7
07BF4:  MOV     W3,W8
07BF6:  MOV     W5,[W15++]
07BF8:  MOV     W6,[W15++]
07BFA:  MOV     W7,[W15++]
07BFC:  MOV     W5,W0
07BFE:  MOV     W6,W1
07C00:  MOV     W7,W2
07C02:  MOV     W8,W3
07C04:  MOV     #0,W4
07C06:  MOV     #0,W5
07C08:  MOV     #0,W6
07C0A:  MOV     #4000,W7
07C0C:  CALL    BCA
07C10:  MOV     [--W15],W7
07C12:  MOV     [--W15],W6
07C14:  MOV     [--W15],W5
07C16:  MOV     W0,W5
07C18:  MOV     W1,W6
07C1A:  MOV     W2,W7
07C1C:  MOV     W3,W8
07C1E:  MOV     W5,[W15++]
07C20:  MOV     W6,[W15++]
07C22:  MOV     W7,[W15++]
07C24:  MOV     W5,W0
07C26:  MOV     W6,W1
07C28:  MOV     W7,W2
07C2A:  MOV     W8,W3
07C2C:  MOV     #2D18,W4
07C2E:  MOV     #5444,W5
07C30:  MOV     #21FB,W6
07C32:  MOV     #4009,W7
07C34:  CALL    CDA
07C38:  MOV     [--W15],W7
07C3A:  MOV     [--W15],W6
07C3C:  MOV     [--W15],W5
07C3E:  MOV     W0,1B74
07C40:  MOV     W1,1B76
07C42:  MOV     W2,1B78
07C44:  MOV     W3,1B7A
.................... 			AngToDo_int = (signed int32)(arrondi_float_signed(temporaire)); 
07C46:  MOV     1B74,W0
07C48:  MOV     1B76,W1
07C4A:  MOV     1B78,W2
07C4C:  MOV     1B7A,W3
07C4E:  CALL    67A8
07C52:  MOV     W1,W5
07C54:  MOV     W2,W6
07C56:  MOV     W5,1B9C
07C58:  MOV     W6,1B9E
07C5A:  CALL    682C
07C5E:  MOV     W0,1B60
07C60:  MOV     W1,1B62
.................... 			/////////////////////////////////////////////////// 
.................... 			/////////////////Envoi de l'angle au Roboteq/////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			if(AngToDo_int != 0) 
07C62:  CP0     1B60
07C64:  BRA     NZ,7C6A
07C66:  CP0     1B62
07C68:  BRA     Z,7CEE
.................... 			{ 
.................... 				//balise 
.................... 				balise_on = 0; //desactive la balise sur une rotation 
07C6A:  BCLR.B  85B.2
.................... 				 
.................... 				fprintf(ROBOTEQ,"!S 1 100_!S 2 100\r"); 
07C6C:  MOV     #0,W1
07C6E:  MOV     W1,W0
07C70:  CLR.B   1
07C72:  CALL    1BC
07C76:  INC     W1,W1
07C78:  BTSC.B  219.1
07C7A:  BRA     7C78
07C7C:  MOV     W0,21A
07C7E:  MOV     #11,W0
07C80:  CPSGT   W1,W0
07C82:  BRA     7C6E
.................... 				// on envoie les donnee au ROBOTEQ 
.................... 							 
.................... 				impulse_g = AngToDo_int; 
07C84:  PUSH    1B60
07C86:  POP     1B64
07C88:  PUSH    1B62
07C8A:  POP     1B66
.................... 				//impulse_d = 0-AngToDo_int; 
.................... 				impulse_d = AngToDo_int; 
07C8C:  PUSH    1B60
07C8E:  POP     1B68
07C90:  PUSH    1B62
07C92:  POP     1B6A
.................... 				fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
07C94:  MOV     #0,W1
07C96:  MOV     W1,W0
07C98:  CLR.B   1
07C9A:  CALL    19C
07C9E:  INC     W1,W1
07CA0:  BTSC.B  219.1
07CA2:  BRA     7CA0
07CA4:  MOV     W0,21A
07CA6:  MOV     #5,W0
07CA8:  CPSGT   W1,W0
07CAA:  BRA     7C96
07CAC:  MOV     1B64,W0
07CAE:  MOV     1B66,W1
07CB0:  MOV     #0,W4
07CB2:  CALL    697E
07CB6:  MOV     #8,W1
07CB8:  MOV     W1,W0
07CBA:  CLR.B   1
07CBC:  CALL    19C
07CC0:  INC     W1,W1
07CC2:  BTSC.B  219.1
07CC4:  BRA     7CC2
07CC6:  MOV     W0,21A
07CC8:  MOV     #E,W0
07CCA:  CPSGT   W1,W0
07CCC:  BRA     7CB8
07CCE:  MOV     1B68,W0
07CD0:  MOV     1B6A,W1
07CD2:  MOV     #0,W4
07CD4:  CALL    697E
07CD8:  BTSC.B  219.1
07CDA:  BRA     7CD8
07CDC:  MOV     #20,W4
07CDE:  MOV     W4,21A
07CE0:  BTSC.B  219.1
07CE2:  BRA     7CE0
07CE4:  MOV     #D,W4
07CE6:  MOV     W4,21A
.................... 				 
.................... 				etat_deplacement  = 1;	 
07CE8:  BSET.B  C24.3
.................... 			}					 
07CEA:  GOTO    7D08
.................... 			else 
.................... 			{			 
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r"); 
07CEE:  MOV     #0,W1
07CF0:  MOV     W1,W0
07CF2:  CLR.B   1
07CF4:  CALL    1DC
07CF8:  INC     W1,W1
07CFA:  BTSC.B  219.1
07CFC:  BRA     7CFA
07CFE:  MOV     W0,21A
07D00:  MOV     #F,W0
07D02:  CPSGT   W1,W0
07D04:  BRA     7CF0
.................... 				etat_deplacement = 1; 
07D06:  BSET.B  C24.3
.................... 			}	 
.................... 			Orient = (float64)(Orient + AngToDo);	 
07D08:  BCLR.B  43.0
07D0A:  MOV     15AE,W0
07D0C:  MOV     15B0,W1
07D0E:  MOV     15B2,W2
07D10:  MOV     15B4,W3
07D12:  MOV     1B6C,W4
07D14:  MOV     1B6E,W5
07D16:  MOV     1B70,W6
07D18:  MOV     1B72,W7
07D1A:  CALL    6536
07D1E:  MOV     W0,15AE
07D20:  MOV     W1,15B0
07D22:  MOV     W2,15B2
07D24:  MOV     W3,15B4
.................... 			break; 
07D26:  GOTO    7E4A
.................... 		case 1 : // gestion de la distance 
.................... 		 
.................... 			if(distToDo!=0)//si on doit faire avancer le robot 
07D2A:  MOV     1B54,W0
07D2C:  MOV     1B56,W1
07D2E:  MOV     1B58,W2
07D30:  MOV     1B5A,W3
07D32:  MOV     #0,W4
07D34:  MOV     #0,W5
07D36:  MOV     #0,W6
07D38:  MOV     #0,W7
07D3A:  CALL    6724
07D3E:  BRA     Z,7E42
.................... 			{		 
.................... 				__Check_commande_atteint();  
07D40:  CALL    73AA
.................... 				__Get_enco_value(1);	//recupere la valeur des encos du pt de depart 
07D44:  MOV.B   #1,W0L
07D46:  MOV.B   W0L,1B96
07D48:  CALL    7408
.................... 				 
.................... 				if(flag_depl_ok == 1)//On attend que le deplacment precedent soit fini(angle) 
07D4C:  BTSS.B  85A.7
07D4E:  BRA     7E3E
.................... 				{ 
.................... 					fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
07D50:  MOV     #0,W1
07D52:  MOV     W1,W0
07D54:  CLR.B   1
07D56:  CALL    17A
07D5A:  INC     W1,W1
07D5C:  BTSC.B  219.1
07D5E:  BRA     7D5C
07D60:  MOV     W0,21A
07D62:  MOV     #4,W0
07D64:  CPSGT   W1,W0
07D66:  BRA     7D52
07D68:  MOV     14B8,W0
07D6A:  MOV     #8004,W4
07D6C:  CALL    6888
07D70:  MOV     #9,W1
07D72:  MOV     W1,W0
07D74:  CLR.B   1
07D76:  CALL    17A
07D7A:  INC     W1,W1
07D7C:  BTSC.B  219.1
07D7E:  BRA     7D7C
07D80:  MOV     W0,21A
07D82:  MOV     #E,W0
07D84:  CPSGT   W1,W0
07D86:  BRA     7D72
07D88:  MOV     14B8,W0
07D8A:  MOV     #8004,W4
07D8C:  CALL    6888
07D90:  BTSC.B  219.1
07D92:  BRA     7D90
07D94:  MOV     #20,W4
07D96:  MOV     W4,21A
07D98:  BTSC.B  219.1
07D9A:  BRA     7D98
07D9C:  MOV     #D,W4
07D9E:  MOV     W4,21A
.................... 					 
.................... 					flag_depl_ok = 0; 
07DA0:  BCLR.B  85A.7
.................... 					 
.................... 					if(oAvAr)//si on recule 
07DA2:  CP0     14B4
07DA4:  BRA     Z,7DC2
.................... 					{		 
.................... 						Balise_set_plage(1);//plage  l'arriere du robot						 
07DA6:  MOV.B   #1,W0L
07DA8:  MOV.B   W0L,1B96
07DAA:  CALL    766C
.................... 						distToDo_int = 0 - distToDo_int; //impulse negative --> recule 
07DAE:  MOV     #0,W4
07DB0:  MOV     1B5C,W3
07DB2:  SUB     W4,W3,W0
07DB4:  MOV     W0,1B5C
07DB6:  MOV     #0,W4
07DB8:  MOV     1B5E,W3
07DBA:  SUBB    W4,W3,W0
07DBC:  MOV     W0,1B5E
.................... 					} 
07DBE:  GOTO    7DC8
.................... 					else  
.................... 					{ 
.................... 						Balise_set_plage(0);//plage  l'avant du robot 
07DC2:  CLR.B   1B96
07DC4:  CALL    766C
.................... 					} 
.................... 					//balise	 
.................... 					balise_on = 1; // active la balise sur un depl 
07DC8:  BSET.B  85B.2
.................... 					//////////////////////////////////////////////////// 
.................... 					////////////envoie au Roobreq/////////////////////// 
.................... 					/////////////////////////////////////////////////// 
.................... 	 
.................... 					fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-distToDo_int,distToDo_int);						 
07DCA:  MOV     #0,W4
07DCC:  MOV     1B5C,W3
07DCE:  SUB     W4,W3,W5
07DD0:  MOV     #0,W4
07DD2:  MOV     1B5E,W3
07DD4:  SUBB    W4,W3,W6
07DD6:  MOV     #0,W1
07DD8:  MOV     W1,W0
07DDA:  CLR.B   1
07DDC:  CALL    1FA
07DE0:  INC     W1,W1
07DE2:  BTSC.B  219.1
07DE4:  BRA     7DE2
07DE6:  MOV     W0,21A
07DE8:  MOV     #5,W0
07DEA:  CPSGT   W1,W0
07DEC:  BRA     7DD8
07DEE:  MOV     W5,W0
07DF0:  MOV     W6,W1
07DF2:  MOV     #8007,W4
07DF4:  CALL    697E
07DF8:  MOV     #A,W1
07DFA:  MOV     W1,W0
07DFC:  CLR.B   1
07DFE:  CALL    1FA
07E02:  INC     W1,W1
07E04:  BTSC.B  219.1
07E06:  BRA     7E04
07E08:  MOV     W0,21A
07E0A:  MOV     #10,W0
07E0C:  CPSGT   W1,W0
07E0E:  BRA     7DFA
07E10:  MOV     1B5C,W0
07E12:  MOV     1B5E,W1
07E14:  MOV     #8007,W4
07E16:  CALL    697E
07E1A:  BTSC.B  219.1
07E1C:  BRA     7E1A
07E1E:  MOV     #20,W4
07E20:  MOV     W4,21A
07E22:  BTSC.B  219.1
07E24:  BRA     7E22
07E26:  MOV     #D,W4
07E28:  MOV     W4,21A
.................... 					Depl_send = 1;							//indique que l'on a fini d'envoyer les ordres du dplacment 
07E2A:  BSET.B  85B.6
.................... 					etat_deplacement = 0; 
07E2C:  BCLR.B  C24.3
.................... 					Dist_x = (signed int16)(_X - Pos_x);	//mise a jour pos x 
07E2E:  MOV     1B40,W4
07E30:  MOV     15A0,W3
07E32:  SUB     W4,W3,W0
07E34:  MOV     W0,159C
.................... 					Dist_y = (signed int16)(_Y - Pos_y); 	//mise a jour pos y 
07E36:  MOV     1B42,W4
07E38:  MOV     15A2,W3
07E3A:  SUB     W4,W3,W0
07E3C:  MOV     W0,159E
.................... 				}	 
.................... 			} 
07E3E:  GOTO    7E46
.................... 			else 
.................... 			{				 
.................... 				Depl_send = 1; 
07E42:  BSET.B  85B.6
.................... 				etat_deplacement = 0; 
07E44:  BCLR.B  C24.3
.................... 			} 
.................... 		break; 
07E46:  GOTO    7E4A
.................... 	} 
.................... 	// Quitte la fonction 
.................... 	return; 
07E4A:  MOV     #12,W5
07E4C:  REPEAT  #3
07E4E:  MOV     [--W15],[W5--]
07E50:  MOV     [--W15],W5
07E52:  RETURN  
.................... } 
.................... /* 
.................... 	/** 
.................... * \fn void __Progress(int16 _X, int16 _Y) 
.................... * \brief Fonction utile pour s'etalonner dans un bord  
.................... * \		 s'arrete en detectant une limite de courant  
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 23.2.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Progress(int16 _X, int16 _Y) 
*
084BC:  MOV     W5,[W15++]
084BE:  MOV     #C,W5
084C0:  REPEAT  #6
084C2:  MOV     [W5++],[W15++]
084C4:  CLR     1B40
084C6:  CLR     1B42
084C8:  CLR     1B44
084CA:  CLR     1B46
084CC:  CLR     1B48
084CE:  CLR     1B4A
084D0:  CLR     1B4C
084D2:  CLR     1B4E
084D4:  CLR     1B50
084D6:  CLR     1B52
084D8:  CLR     1B54
084DA:  CLR     1B56
.................... { 
.................... 	static unsigned int8 etat_depl; 
.................... 	float64 amp = 0;				//courant dans le moteur 1 
.................... 	float64 amp2 = 0;				//courant dans le moteur 2  
.................... 	static int1 m1_stop,m2_stop;	//arret moteur 1 et arret moteur 2 
....................  
.................... 	float64 Dist = 0;  
....................  
.................... 	switch(etat_depl) 
084DC:  MOV.B   15F4,W0L
084DE:  CLR.B   1
084E0:  XOR     #0,W0
084E2:  BRA     Z,84EA
084E4:  XOR     #1,W0
084E6:  BRA     Z,867A
084E8:  BRA     883E
.................... 	{ 
.................... 		case 0: 
.................... 		 	Dist = sqrt(((_X - Pos_x) * (_X - Pos_x)) + ((_Y - Pos_y) * (_Y - Pos_y))) + DIST_SECU_PROGRESS; // calcul distance de depl  
084EA:  MOV     1B3C,W4
084EC:  MOV     15A0,W3
084EE:  SUB     W4,W3,W5
084F0:  MOV     1B3C,W4
084F2:  MOV     15A0,W3
084F4:  SUB     W4,W3,W0
084F6:  MUL.SS  W5,W0,W0
084F8:  MOV     W0,W5
084FA:  MOV     1B3E,W4
084FC:  MOV     15A2,W3
084FE:  SUB     W4,W3,W6
08500:  MOV     1B3E,W4
08502:  MOV     15A2,W3
08504:  SUB     W4,W3,W0
08506:  MUL.SS  W6,W0,W0
08508:  ADD     W0,W5,W0
0850A:  CALL    17CC
0850E:  MOV     W0,W5
08510:  MOV     W1,W6
08512:  MOV     W5,1B88
08514:  MOV     W6,1B8A
08516:  CALL    22D8
0851A:  MOV     W0,W5
0851C:  MOV     W1,W6
0851E:  MOV     159A,W0
08520:  CALL    1974
08524:  BCLR.B  43.0
08526:  MOV     W0,W2
08528:  MOV     W1,W3
0852A:  MOV     W5,W0
0852C:  MOV     W6,W1
0852E:  CALL    1A72
08532:  MOV     W1,W2
08534:  MOV     W0,W1
08536:  MOV     #0,W0
08538:  CALL    7E54
0853C:  MOV     W0,1B50
0853E:  MOV     W1,1B52
08540:  MOV     W2,1B54
08542:  MOV     W3,1B56
.................... 		 	Dist *= (COEFF_D/10);	//conversion mm en pas 
08544:  MOV     15CE,W0
08546:  MOV     15D0,W1
08548:  MOV     15D2,W2
0854A:  MOV     15D4,W3
0854C:  MOV     #0,W4
0854E:  MOV     #0,W5
08550:  MOV     #0,W6
08552:  MOV     #4024,W7
08554:  CALL    CDA
08558:  MOV     W0,W4
0855A:  MOV     W1,W5
0855C:  MOV     W2,W6
0855E:  MOV     W3,W7
08560:  MOV     1B50,W0
08562:  MOV     1B52,W1
08564:  MOV     1B54,W2
08566:  MOV     1B56,W3
08568:  CALL    BCA
0856C:  MOV     W0,1B50
0856E:  MOV     W1,1B52
08570:  MOV     W2,1B54
08572:  MOV     W3,1B56
.................... 			flag_depl_ok = 0; 
08574:  BCLR.B  85A.7
.................... 			 
.................... 			//balise	 
.................... 			balise_on = 1; // active la balise sur un depl				 
08576:  BSET.B  85B.2
.................... 			 
.................... 			if(oAvAr)//si on recule 
08578:  CP0     14B4
0857A:  BRA     Z,85A6
.................... 			{	 
.................... 				Balise_set_plage(1);//plage  l'arriere du robot					 
0857C:  MOV.B   #1,W0L
0857E:  MOV.B   W0L,1B96
08580:  CALL    766C
.................... 				Dist = 0 - Dist; 	// on inverse la distance 
08584:  BSET.B  43.0
08586:  MOV     #0,W0
08588:  MOV     #0,W1
0858A:  MOV     #0,W2
0858C:  MOV     #0,W3
0858E:  MOV     1B50,W4
08590:  MOV     1B52,W5
08592:  MOV     1B54,W6
08594:  MOV     1B56,W7
08596:  CALL    6536
0859A:  MOV     W0,1B50
0859C:  MOV     W1,1B52
0859E:  MOV     W2,1B54
085A0:  MOV     W3,1B56
.................... 			} 
085A2:  GOTO    85AC
.................... 			else  
.................... 			{ 
.................... 				Balise_set_plage(0);//plage  l'avant du robot 
085A6:  CLR.B   1B96
085A8:  CALL    766C
.................... 			} 
.................... 			//////////////////////////////////////////////////// 
.................... 			////////////envoie au Roobreq/////////////////////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			//__Get_enco_value(1); 
.................... 			 
.................... 			fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax);	 
085AC:  MOV     #0,W1
085AE:  MOV     W1,W0
085B0:  CLR.B   1
085B2:  CALL    17A
085B6:  INC     W1,W1
085B8:  BTSC.B  219.1
085BA:  BRA     85B8
085BC:  MOV     W0,21A
085BE:  MOV     #4,W0
085C0:  CPSGT   W1,W0
085C2:  BRA     85AE
085C4:  MOV     14B8,W0
085C6:  MOV     #8004,W4
085C8:  CALL    6888
085CC:  MOV     #9,W1
085CE:  MOV     W1,W0
085D0:  CLR.B   1
085D2:  CALL    17A
085D6:  INC     W1,W1
085D8:  BTSC.B  219.1
085DA:  BRA     85D8
085DC:  MOV     W0,21A
085DE:  MOV     #E,W0
085E0:  CPSGT   W1,W0
085E2:  BRA     85CE
085E4:  MOV     14B8,W0
085E6:  MOV     #8004,W4
085E8:  CALL    6888
085EC:  BTSC.B  219.1
085EE:  BRA     85EC
085F0:  MOV     #20,W4
085F2:  MOV     W4,21A
085F4:  BTSC.B  219.1
085F6:  BRA     85F4
085F8:  MOV     #D,W4
085FA:  MOV     W4,21A
.................... 			fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",-Dist,-Dist);		 
085FC:  MOV     1B50,W5
085FE:  MOV     1B52,W6
08600:  MOV     1B54,W7
08602:  MOV     1B56,W8
08604:  BTG     W8.F
08606:  MOV     1B50,W9
08608:  MOV     1B52,W10
0860A:  MOV     1B54,W11
0860C:  MOV     1B56,W12
0860E:  BTG     W12.F
08610:  MOV     #0,W1
08612:  MOV     W1,W0
08614:  CLR.B   1
08616:  CALL    19C
0861A:  INC     W1,W1
0861C:  BTSC.B  219.1
0861E:  BRA     861C
08620:  MOV     W0,21A
08622:  MOV     #5,W0
08624:  CPSGT   W1,W0
08626:  BRA     8612
08628:  MOV     W5,W0
0862A:  MOV     W6,W1
0862C:  MOV     W7,W2
0862E:  MOV     W8,W3
08630:  MOV     #0,W4
08632:  CALL    7F2E
08636:  MOV     #8,W1
08638:  MOV     W1,W0
0863A:  CLR.B   1
0863C:  CALL    19C
08640:  INC     W1,W1
08642:  BTSC.B  219.1
08644:  BRA     8642
08646:  MOV     W0,21A
08648:  MOV     #E,W0
0864A:  CPSGT   W1,W0
0864C:  BRA     8638
0864E:  MOV     W9,W0
08650:  MOV     W10,W1
08652:  MOV     W11,W2
08654:  MOV     W12,W3
08656:  MOV     #0,W4
08658:  CALL    7F2E
0865C:  BTSC.B  219.1
0865E:  BRA     865C
08660:  MOV     #20,W4
08662:  MOV     W4,21A
08664:  BTSC.B  219.1
08666:  BRA     8664
08668:  MOV     #D,W4
0866A:  MOV     W4,21A
.................... 			 
.................... 			etat_depl = 1; 
0866C:  MOV.B   #1,W0L
0866E:  MOV.B   W0L,15F4
.................... 			delay_ms(20); 
08670:  MOV     #14,W0
08672:  CALL    DE2
.................... 			 
.................... 			break; 
08676:  GOTO    883E
.................... 		case 1:  
.................... 			amp = (float64)(__Get_amp(1));	//recup du courant du mot 1 
0867A:  MOV     #1,W4
0867C:  MOV     W4,1B62
0867E:  CALL    80C0
08682:  MOV     W0,1B40
08684:  MOV     W1,1B42
08686:  MOV     W2,1B44
08688:  MOV     W3,1B46
.................... 			amp2 =(float64)(__Get_amp(2));	//recup du courant du mot 2 
0868A:  MOV     #2,W4
0868C:  MOV     W4,1B62
0868E:  CALL    80C0
08692:  MOV     W0,1B48
08694:  MOV     W1,1B4A
08696:  MOV     W2,1B4C
08698:  MOV     W3,1B4E
.................... 			amp /= 10;					  	// roboteq envoie 15A pour 1,5A --> /10 
0869A:  MOV     1B40,W0
0869C:  MOV     1B42,W1
0869E:  MOV     1B44,W2
086A0:  MOV     1B46,W3
086A2:  MOV     #0,W4
086A4:  MOV     #0,W5
086A6:  MOV     #0,W6
086A8:  MOV     #4024,W7
086AA:  CALL    CDA
086AE:  MOV     W0,1B40
086B0:  MOV     W1,1B42
086B2:  MOV     W2,1B44
086B4:  MOV     W3,1B46
.................... 			amp2 /= 10;					 	// roboteq envoie 15A pour 1,5A --> /10 
086B6:  MOV     1B48,W0
086B8:  MOV     1B4A,W1
086BA:  MOV     1B4C,W2
086BC:  MOV     1B4E,W3
086BE:  MOV     #0,W4
086C0:  MOV     #0,W5
086C2:  MOV     #0,W6
086C4:  MOV     #4024,W7
086C6:  CALL    CDA
086CA:  MOV     W0,1B48
086CC:  MOV     W1,1B4A
086CE:  MOV     W2,1B4C
086D0:  MOV     W3,1B4E
.................... 			if(amp >= amp_limit)		 	//Seuil courant ds mot 1 detecte  
086D2:  MOV     1592,W0
086D4:  MOV     1594,W1
086D6:  MOV     1596,W2
086D8:  MOV     1598,W3
086DA:  MOV     1B40,W4
086DC:  MOV     1B42,W5
086DE:  MOV     1B44,W6
086E0:  MOV     1B46,W7
086E2:  CALL    6724
086E6:  BRA     C,86EA
086E8:  BRA     NZ,8704
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 1\r");	//Stop le mot 1  
086EA:  MOV     #0,W1
086EC:  MOV     W1,W0
086EE:  CLR.B   1
086F0:  CALL    21E
086F4:  INC     W1,W1
086F6:  BTSC.B  219.1
086F8:  BRA     86F6
086FA:  MOV     W0,21A
086FC:  MOV     #5,W0
086FE:  CPSGT   W1,W0
08700:  BRA     86EC
.................... 				m1_stop = 1; 
08702:  BSET.B  C24.4
.................... 			} 
.................... 			if(amp2 >= amp_limit)			//Seuil courant ds mot 2 detecte 
08704:  MOV     1592,W0
08706:  MOV     1594,W1
08708:  MOV     1596,W2
0870A:  MOV     1598,W3
0870C:  MOV     1B48,W4
0870E:  MOV     1B4A,W5
08710:  MOV     1B4C,W6
08712:  MOV     1B4E,W7
08714:  CALL    6724
08718:  BRA     C,871C
0871A:  BRA     NZ,8736
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 2\r");	//Stop le mot 2 
0871C:  MOV     #0,W1
0871E:  MOV     W1,W0
08720:  CLR.B   1
08722:  CALL    232
08726:  INC     W1,W1
08728:  BTSC.B  219.1
0872A:  BRA     8728
0872C:  MOV     W0,21A
0872E:  MOV     #5,W0
08730:  CPSGT   W1,W0
08732:  BRA     871E
.................... 				m2_stop = 1; 
08734:  BSET.B  C24.5
.................... 			}	 
.................... 			if(m1_stop==1 && m2_stop==1)	//les 2 moteurs stopes 
08736:  BTSS.B  C24.4
08738:  BRA     87A4
0873A:  BTSS.B  C24.5
0873C:  BRA     87A4
.................... 			{ 
....................  
.................... 				fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); 	//passage en open loop speed 
0873E:  MOV     #0,W1
08740:  MOV     W1,W0
08742:  CLR.B   1
08744:  CALL    136
08748:  INC     W1,W1
0874A:  BTSC.B  219.1
0874C:  BRA     874A
0874E:  MOV     W0,21A
08750:  MOV     #13,W0
08752:  CPSGT   W1,W0
08754:  BRA     8740
.................... 				delay_ms(10); 
08756:  MOV     #A,W0
08758:  CALL    DE2
.................... 				fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); 	//passage en closed loop count postion 
0875C:  MOV     #0,W1
0875E:  MOV     W1,W0
08760:  CLR.B   1
08762:  CALL    158
08766:  INC     W1,W1
08768:  BTSC.B  219.1
0876A:  BRA     8768
0876C:  MOV     W0,21A
0876E:  MOV     #13,W0
08770:  CPSGT   W1,W0
08772:  BRA     875E
.................... 								 
.................... 				Depl_send = 1; 							  	//fin du dplacment 
08774:  BSET.B  85B.6
.................... 				etat_depl = 0; 
08776:  CLR.B   15F4
....................  
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r");	   
08778:  MOV     #0,W1
0877A:  MOV     W1,W0
0877C:  CLR.B   1
0877E:  CALL    1DC
08782:  INC     W1,W1
08784:  BTSC.B  219.1
08786:  BRA     8784
08788:  MOV     W0,21A
0878A:  MOV     #F,W0
0878C:  CPSGT   W1,W0
0878E:  BRA     877A
.................... 				 
.................... 				Dist_x = (signed int16)(_X-Pos_x);			//mise a jour pos x 
08790:  MOV     1B3C,W4
08792:  MOV     15A0,W3
08794:  SUB     W4,W3,W0
08796:  MOV     W0,159C
.................... 				Dist_y = (signed int16)(_Y-Pos_y);			//mise a jour pos y 
08798:  MOV     1B3E,W4
0879A:  MOV     15A2,W3
0879C:  SUB     W4,W3,W0
0879E:  MOV     W0,159E
.................... 			} 
087A0:  GOTO    883A
.................... 			else // si pos atteinte 
.................... 			{					 
.................... 				__Check_commande_atteint();  
087A4:  CALL    73AA
.................... 				if(flag_depl_ok == 1) //On attend que le deplacment precedent soit fini(angle) 
087A8:  BTSS.B  85A.7
087AA:  BRA     883A
.................... 				{ 
.................... 					Dist_x =  cos(Orient) * Dist;			//mise a jour pos x 
087AC:  PUSH    15AE
087AE:  POP     1B7C
087B0:  PUSH    15B0
087B2:  POP     1B7E
087B4:  PUSH    15B2
087B6:  POP     1B80
087B8:  PUSH    15B4
087BA:  POP     1B82
087BC:  CALL    81C6
087C0:  MOV     W0,W5
087C2:  MOV     W1,W6
087C4:  MOV     W2,W7
087C6:  MOV     W3,W8
087C8:  MOV     W5,[W15++]
087CA:  MOV     W6,[W15++]
087CC:  MOV     W7,[W15++]
087CE:  MOV     W5,W0
087D0:  MOV     W6,W1
087D2:  MOV     W7,W2
087D4:  MOV     W8,W3
087D6:  MOV     1B50,W4
087D8:  MOV     1B52,W5
087DA:  MOV     1B54,W6
087DC:  MOV     1B56,W7
087DE:  CALL    BCA
087E2:  MOV     [--W15],W7
087E4:  MOV     [--W15],W6
087E6:  MOV     [--W15],W5
087E8:  CALL    6EF4
087EC:  MOV     W0,159C
.................... 					Dist_y =  sin(Orient) * Dist;			//mise a jour pos y 
087EE:  PUSH    15AE
087F0:  POP     1B62
087F2:  PUSH    15B0
087F4:  POP     1B64
087F6:  PUSH    15B2
087F8:  POP     1B66
087FA:  PUSH    15B4
087FC:  POP     1B68
087FE:  CALL    8480
08802:  MOV     W0,W5
08804:  MOV     W1,W6
08806:  MOV     W2,W7
08808:  MOV     W3,W8
0880A:  MOV     W5,[W15++]
0880C:  MOV     W6,[W15++]
0880E:  MOV     W7,[W15++]
08810:  MOV     W5,W0
08812:  MOV     W6,W1
08814:  MOV     W7,W2
08816:  MOV     W8,W3
08818:  MOV     1B50,W4
0881A:  MOV     1B52,W5
0881C:  MOV     1B54,W6
0881E:  MOV     1B56,W7
08820:  CALL    BCA
08824:  MOV     [--W15],W7
08826:  MOV     [--W15],W6
08828:  MOV     [--W15],W5
0882A:  CALL    6EF4
0882E:  MOV     W0,159E
....................  
.................... 					//remise a zero des varaibles 
.................... 					flag_depl_ok = 0; 
08830:  BCLR.B  85A.7
.................... 					Depl_send = 1; 
08832:  BSET.B  85B.6
.................... 					m1_stop = 0; 
08834:  BCLR.B  C24.4
.................... 					m2_stop = 0;								 
08836:  BCLR.B  C24.5
.................... 					etat_depl = 0;			 
08838:  CLR.B   15F4
.................... 				} 
.................... 			} 
.................... 			break; 
0883A:  GOTO    883E
.................... 	} 
0883E:  MOV     #18,W5
08840:  REPEAT  #6
08842:  MOV     [--W15],[W5--]
08844:  MOV     [--W15],W5
08846:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Nothing(void) 
.................... * \brief Passe l'objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
....................  
.................... void __Nothing(void) 
.................... { 
.................... 	flag_depl_ok = 1;  
08848:  BSET.B  85A.7
.................... 	Depl_send=1; 
0884A:  BSET.B  85B.6
.................... 	balise_on = 0; 
0884C:  BCLR.B  85B.2
.................... 	// Quitte la fonction 
.................... 	return; 
0884E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __LoadObj(unsigned int8 _Obj) 
.................... * \brief Charge le prochain objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 2.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param [in] _Obj Numero de l'objectif desire 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __LoadObj(unsigned int16 _Obj,unsigned int16 pts) 
*
00EAE:  MOV     W5,[W15++]
.................... {	 
.................... 	// Enregistre Xp, en [mm] 
.................... 	oXp=TabObjectifs[_Obj][pts][0]; 
00EB0:  MOV     1B3C,W4
00EB2:  MOV     #138,W3
00EB4:  MUL.UU  W4,W3,W0
00EB6:  MOV     W0,W5
00EB8:  MOV     1B3E,W4
00EBA:  MUL.UU  W4,#18,W0
00EBC:  ADD     W0,W5,W5
00EBE:  MOV     #C26,W4
00EC0:  ADD     W5,W4,W0
00EC2:  MOV     [W0],[W15++]
00EC4:  POP     14AE
....................  
.................... 	// Enregistre Yp, en [mm] 
.................... 	oYp=TabObjectifs[_Obj][pts][1]; 
00EC6:  MOV     1B3C,W4
00EC8:  MOV     #138,W3
00ECA:  MUL.UU  W4,W3,W0
00ECC:  MOV     W0,W5
00ECE:  MOV     1B3E,W4
00ED0:  MUL.UU  W4,#18,W0
00ED2:  ADD     W0,W5,W5
00ED4:  ADD     W5,#2,W5
00ED6:  MOV     W5,W0
00ED8:  MOV     #C26,W4
00EDA:  ADD     W0,W4,W0
00EDC:  MOV     [W0],[W15++]
00EDE:  POP     14B0
....................  
.................... 	// Enregistre le type de deplacement, en [nbre] 
.................... 	oType=TabObjectifs[_Obj][pts][2]; 
00EE0:  MOV     1B3C,W4
00EE2:  MOV     #138,W3
00EE4:  MUL.UU  W4,W3,W0
00EE6:  MOV     W0,W5
00EE8:  MOV     1B3E,W4
00EEA:  MUL.UU  W4,#18,W0
00EEC:  ADD     W0,W5,W5
00EEE:  ADD     W5,#4,W5
00EF0:  MOV     W5,W0
00EF2:  MOV     #C26,W4
00EF4:  ADD     W0,W4,W0
00EF6:  MOV     [W0],[W15++]
00EF8:  POP     14B2
....................  
.................... 	// Enregistre si avance ou recule 
.................... 	oAvAr=TabObjectifs[_Obj][pts][3]; 
00EFA:  MOV     1B3C,W4
00EFC:  MOV     #138,W3
00EFE:  MUL.UU  W4,W3,W0
00F00:  MOV     W0,W5
00F02:  MOV     1B3E,W4
00F04:  MUL.UU  W4,#18,W0
00F06:  ADD     W0,W5,W5
00F08:  ADD     W5,#6,W5
00F0A:  MOV     W5,W0
00F0C:  MOV     #C26,W4
00F0E:  ADD     W0,W4,W0
00F10:  MOV     [W0],[W15++]
00F12:  POP     14B4
....................  
.................... 	// Enregistre le cote duquel tourner 
.................... 	oCoteTourn=TabObjectifs[_Obj][pts][4]; 
00F14:  MOV     1B3C,W4
00F16:  MOV     #138,W3
00F18:  MUL.UU  W4,W3,W0
00F1A:  MOV     W0,W5
00F1C:  MOV     1B3E,W4
00F1E:  MUL.UU  W4,#18,W0
00F20:  ADD     W0,W5,W5
00F22:  ADD     W5,#8,W5
00F24:  MOV     W5,W0
00F26:  MOV     #C26,W4
00F28:  ADD     W0,W4,W0
00F2A:  MOV     [W0],[W15++]
00F2C:  POP     14B6
....................  
.................... 	// Enregistre la vitesse maximum, en [mm/s] (en [0/000] pour RoboteQ) 
.................... 	oVitMax=TabObjectifs[_Obj][pts][5]; 
00F2E:  MOV     1B3C,W4
00F30:  MOV     #138,W3
00F32:  MUL.UU  W4,W3,W0
00F34:  MOV     W0,W5
00F36:  MOV     1B3E,W4
00F38:  MUL.UU  W4,#18,W0
00F3A:  ADD     W0,W5,W5
00F3C:  ADD     W5,#A,W5
00F3E:  MOV     W5,W0
00F40:  MOV     #C26,W4
00F42:  ADD     W0,W4,W0
00F44:  MOV     [W0],[W15++]
00F46:  POP     14B8
....................  
.................... 	//Enregistre l'action a faire 
.................... 	Obj_Action = TabObjectifs[_Obj][pts][6]; 
00F48:  MOV     1B3C,W4
00F4A:  MOV     #138,W3
00F4C:  MUL.UU  W4,W3,W0
00F4E:  MOV     W0,W5
00F50:  MOV     1B3E,W4
00F52:  MUL.UU  W4,#18,W0
00F54:  ADD     W0,W5,W5
00F56:  ADD     W5,#C,W5
00F58:  MOV     W5,W0
00F5A:  MOV     #C26,W4
00F5C:  ADD     W0,W4,W0
00F5E:  MOV     [W0],[W15++]
00F60:  POP     14BA
.................... 	 
.................... 	//Enregistre si le pt est symetrique ou non 
.................... 	Pt_commun = TabObjectifs[_Obj][pts][7]; 
00F62:  MOV     1B3C,W4
00F64:  MOV     #138,W3
00F66:  MUL.UU  W4,W3,W0
00F68:  MOV     W0,W5
00F6A:  MOV     1B3E,W4
00F6C:  MUL.UU  W4,#18,W0
00F6E:  ADD     W0,W5,W5
00F70:  ADD     W5,#E,W5
00F72:  MOV     W5,W0
00F74:  MOV     #C26,W4
00F76:  ADD     W0,W4,W0
00F78:  MOV     [W0],[W15++]
00F7A:  POP     14BC
.................... 	 
.................... 	//ponderation objectifs 
.................... 	Ponderation = TabObjectifs[_Obj][pts][8];	 
00F7C:  MOV     1B3C,W4
00F7E:  MOV     #138,W3
00F80:  MUL.UU  W4,W3,W0
00F82:  MOV     W0,W5
00F84:  MOV     1B3E,W4
00F86:  MUL.UU  W4,#18,W0
00F88:  ADD     W0,W5,W5
00F8A:  ADD     W5,#10,W5
00F8C:  MOV     W5,W0
00F8E:  MOV     #C26,W4
00F90:  ADD     W0,W4,W0
00F92:  MOV     [W0],[W15++]
00F94:  POP     14BE
.................... 	 
.................... 	//Objectifs fini ou non 
.................... 	Obj_end	= TabObjectifs[_Obj][pts][9];  
00F96:  MOV     1B3C,W4
00F98:  MOV     #138,W3
00F9A:  MUL.UU  W4,W3,W0
00F9C:  MOV     W0,W5
00F9E:  MOV     1B3E,W4
00FA0:  MUL.UU  W4,#18,W0
00FA2:  ADD     W0,W5,W5
00FA4:  ADD     W5,#12,W5
00FA6:  MOV     W5,W0
00FA8:  MOV     #C26,W4
00FAA:  ADD     W0,W4,W0
00FAC:  MOV     [W0],[W15++]
00FAE:  POP     14C0
.................... 	 
.................... 	//prochain objectifs 
.................... 	Next_obj = TabObjectifs[_Obj][pts][10]; 
00FB0:  MOV     1B3C,W4
00FB2:  MOV     #138,W3
00FB4:  MUL.UU  W4,W3,W0
00FB6:  MOV     W0,W5
00FB8:  MOV     1B3E,W4
00FBA:  MUL.UU  W4,#18,W0
00FBC:  ADD     W0,W5,W5
00FBE:  ADD     W5,#14,W5
00FC0:  MOV     W5,W0
00FC2:  MOV     #C26,W4
00FC4:  ADD     W0,W4,W0
00FC6:  MOV     [W0],[W15++]
00FC8:  POP     14C2
.................... 	 
.................... 	keep_obj = TabObjectifs[_Obj][pts][11]; 
00FCA:  MOV     1B3C,W4
00FCC:  MOV     #138,W3
00FCE:  MUL.UU  W4,W3,W0
00FD0:  MOV     W0,W5
00FD2:  MOV     1B3E,W4
00FD4:  MUL.UU  W4,#18,W0
00FD6:  ADD     W0,W5,W5
00FD8:  ADD     W5,#16,W5
00FDA:  MOV     W5,W0
00FDC:  MOV     #C26,W4
00FDE:  ADD     W0,W4,W0
00FE0:  MOV     [W0],[W15++]
00FE2:  POP     14C4
....................  
.................... 	// Switch les donnees selon la base choisie et le mode 
.................... 	if(TEAM) 
00FE4:  BTSS.B  85B.4
00FE6:  BRA     1042
.................... 	{ 
.................... 		switch(oType) 
00FE8:  MOV     14B2,W0
00FEA:  XOR     #0,W0
00FEC:  BRA     Z,FF4
00FEE:  XOR     #1,W0
00FF0:  BRA     Z,1014
00FF2:  BRA     103E
.................... 		{ 
.................... 			case 0 : 
.................... 				if(oXp<=180)oXp=180-oXp; //gestion angle 
00FF4:  MOV     14AE,W4
00FF6:  MOV     #B4,W3
00FF8:  CP      W3,W4
00FFA:  BRA     LT,1008
00FFC:  MOV     #B4,W4
00FFE:  MOV     14AE,W3
01000:  SUB     W4,W3,W0
01002:  MOV     W0,14AE
01004:  GOTO    1010
.................... 				else oXp = 540 - oXp; 
01008:  MOV     #21C,W4
0100A:  MOV     14AE,W3
0100C:  SUB     W4,W3,W0
0100E:  MOV     W0,14AE
.................... 				break; 
01010:  GOTO    1042
.................... 			case 1 : 
.................... 				// PaP ou retient sur place, calcul automatique de l'angle, inversion oX et oCoteTourn 
.................... 				// Enregistre Xp, en [mm] 
.................... 				oXp = TableWidth - oXp; 
01014:  MOV     87E,W4
01016:  MOV     14AE,W3
01018:  SUB     W4,W3,W0
0101A:  MOV     W0,14AE
.................... 				// Enregistre le cote duquel tourner 
.................... 				if(oCoteTourn==1)oCoteTourn=2; 
0101C:  MOV     14B6,W4
0101E:  CP      W4,#1
01020:  BRA     NZ,102A
01022:  MOV     #2,W4
01024:  MOV     W4,14B6
01026:  GOTO    103A
.................... 				else if(oCoteTourn==2)oCoteTourn=1; 
0102A:  MOV     14B6,W4
0102C:  CP      W4,#2
0102E:  BRA     NZ,1038
01030:  MOV     #1,W4
01032:  MOV     W4,14B6
01034:  GOTO    103A
.................... 				else oCoteTourn=0; 
01038:  CLR     14B6
.................... 	 
.................... 				break; 
0103A:  GOTO    1042
.................... 			default : 
.................... 				break; 
0103E:  GOTO    1042
.................... 		}		 
.................... 	}						 
01042:  MOV     [--W15],W5
01044:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    RDA_isr 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    27.03.2015 
.................... //  Statut :    OK 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Interruption pour la rception RS232.  
.................... #INT_RDA2 
.................... void RDA2_isr(void) 
*
00588:  PUSH    42
0058A:  PUSH    36
0058C:  PUSH    32
0058E:  MOV     W0,[W15++]
00590:  MOV     #2,W0
00592:  REPEAT  #C
00594:  MOV     [W0++],[W15++]
.................... { 
.................... 	// Pour la lecture du caractre reu 
.................... 	char myChar; 
.................... 	// Rception 
.................... 	myChar = fgetc(ROBOTEQ); 
00596:  BTSS.B  218.0
00598:  BRA     596
0059A:  MOV     21C,W0
0059C:  MOV.B   W0L,1D4A
.................... 	// Ajout au buffer et incrmentation de la longeur du buffer 
.................... 	RoboteQ_receiveBuffer[RoboteQ_receiveLenght] = myChar; 
0059E:  MOV     15DE,W4
005A0:  LSR     W4,#8,W4
005A2:  MOV     #882,W3
005A4:  ADD     W4,W3,W5
005A6:  MOV     1D4A,W0
005A8:  MOV.B   W0L,[W5+#0]
.................... 	RoboteQ_receiveLenght++; 
005AA:  INC.B   15DF
.................... 	 
.................... 	// Si on trouve la fin de la commande 
.................... 	if(myChar == '\r') 
005AC:  MOV     1D4A,W4
005AE:  CP.B    W4L,#D
005B0:  BRA     NZ,5B8
.................... 	{ 
.................... 		// On dit qu'on peut lire le buffer de rception 
.................... 		RoboteQ_receiveToProceed = RoboteQ_receiveLenght; 
005B2:  MOV.B   15DF,W0L
005B4:  MOV.B   W0L,15DE
.................... 		RoboteQ_receiveLenght=0; 
005B6:  CLR.B   15DF
.................... 	} 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: TestCartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contrle du robor secondaire.																	== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_h 
005B8:  BCLR.B  87.0
005BA:  MOV     #1A,W0
005BC:  REPEAT  #C
005BE:  MOV     [--W15],[W0--]
005C0:  MOV     [--W15],W0
005C2:  POP     32
005C4:  POP     36
005C6:  POP     42
005C8:  RETFIE  
.................... #define ___Functions_h 
....................  
....................  
.................... //unsigned int16 soll_vit_rot  = 1450; 
.................... unsigned int16 soll_vit_rot_zero = 2000;  
.................... unsigned int16 soll_vit_mov = 1200; 
....................  
.................... int1 Sens_rot_Couronne = 0; 
....................  
.................... signed int32 Endposition = 0; //position qui doit etre atteinte a la fin du depl 
.................... unsigned int8 Etat_ejection = 0; 
.................... int1 bras_out = 0; 
.................... //int1 bras_in  = 0; 
.................... //int1 flag_module_fond = 0; 
....................  
....................  
.................... void Standby_stop(); 
.................... void Standby_scan(); 
.................... void Take_front(); 
.................... void Take_side(); 
.................... void Take_goldenium(); 
.................... void Put_balance(); 
.................... void Put_accelerator(); 
.................... void Check_action_done(); 
....................  
.................... unsigned int8 Write_cmd_arduino(unsigned int8 cmd,unsigned int8 taille, unsigned int8 *data ) ; 
.................... Read_etat_arduino(struct etat *value) ; 
....................  
.................... void __ReadObjectifs(void); 
.................... void __resetEEPROM(void); 
.................... void __reset_roboteq(void); 
.................... void __GetRoboteqPID(unsigned int8 valeur); 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2); 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr); 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend); 
.................... void __Action_Writting(unsigned int8 ActionToDo); 
.................... void __ReadZones_Interdites(void); 
.................... int1 reinitialisation(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
....................  
.................... #include "Functions.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel 
.................... 						: Borgeat Rmy     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Function.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient des fonctions pour le robot																== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_c 
.................... #define ___Functions_c 
....................  
....................  
.................... #DEFINE START 30 
....................  
....................  
....................  
....................  
.................... //unsigned int8 points = 0;////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... // Actions  effectuer 
.................... void __Action_Writting(unsigned int8 ActionToDo) 
.................... { 
.................... //	unsigned int8 StateDriver = 0; 
.................... 	switch(ActionToDo) 
*
08AC2:  MOV.B   1B3A,W0L
08AC4:  CLR.B   1
08AC6:  XOR     #0,W0
08AC8:  BRA     Z,8AEC
08ACA:  XOR     #1,W0
08ACC:  BRA     Z,8AF2
08ACE:  XOR     #3,W0
08AD0:  BRA     Z,8AFA
08AD2:  XOR     #1,W0
08AD4:  BRA     Z,8B02
08AD6:  XOR     #7,W0
08AD8:  BRA     Z,8B0A
08ADA:  XOR     #1,W0
08ADC:  BRA     Z,8B12
08ADE:  XOR     #2,W0
08AE0:  BRA     Z,8B1A
08AE2:  XOR     #F,W0
08AE4:  BRA     Z,8B22
08AE6:  XOR     #1,W0
08AE8:  BRA     Z,8B2A
08AEA:  BRA     8B2E
.................... 	{ 
.................... 		// Ne fait rien 
.................... 		case 0 : 
.................... 			Action_send=1; 
08AEC:  BSET.B  C24.0
.................... 			break;		 
08AEE:  GOTO    8B32
.................... 		case 1 : 
.................... 			Standby_stop(); 
08AF2:  CALL    8966
.................... 			break;	 
08AF6:  GOTO    8B32
.................... 		case 2 :  
.................... 			Standby_scan(); 
08AFA:  CALL    8980
.................... 			break; 
08AFE:  GOTO    8B32
.................... 		case 3 :  
.................... 			Take_front(); 
08B02:  CALL    8A3C
.................... 			break; 
08B06:  GOTO    8B32
.................... 		case 4 :  
.................... 			Take_side(); 
08B0A:  CALL    8A92
.................... 			break; 
08B0E:  GOTO    8B32
.................... 		case 5 :  
.................... 			Take_goldenium(); 
08B12:  CALL    8AA6
.................... 			break; 
08B16:  GOTO    8B32
.................... 		case 7 : 
.................... 			Put_balance(); 
08B1A:  CALL    8ABA
.................... 			break; 
08B1E:  GOTO    8B32
.................... 		case 8 :  
.................... 			Put_accelerator(); 
08B22:  CALL    8ABE
.................... 			break; 
08B26:  GOTO    8B32
.................... 		case 9 :  
.................... 			//reinitialisation(); 
.................... 			break; 
08B2A:  GOTO    8B32
.................... 		default : 
.................... 			//__Affichage_erreur(5); 
.................... 			break; 
08B2E:  GOTO    8B32
.................... 	} 
08B32:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant d'ordonner  l'arduino de ne rien faire et 
.................... // garder le bras immobile  
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Standby_stop() 
.................... { 
.................... 	data_to_transmit[0] = 1; 
*
08966:  MOV.B   #1,W0L
08968:  MOV.B   W0L,A82
.................... 	Write_cmd_arduino(10,1, &data_to_transmit ); 
0896A:  MOV.B   #A,W0L
0896C:  MOV.B   W0L,1B3C
0896E:  MOV.B   #1,W0L
08970:  MOV.B   W0L,1B3D
08972:  MOV     #A82,W4
08974:  MOV     W4,1B3E
08976:  CALL    88B0
....................  
.................... 	LED1 = 1; 
0897A:  BSET.B  2D0.1
.................... 	 
.................... 	Action_send = 1; 
0897C:  BSET.B  C24.0
0897E:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant d'ordonner  l'arduino de ne rien faire mais de 
.................... // scaner la zone et enlever les palets qui pourraient gner le dplacement  
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Standby_scan() 
.................... { 
.................... 	data_to_transmit[0] = 2; 
08980:  MOV.B   #2,W0L
08982:  MOV.B   W0L,A82
.................... 	Write_cmd_arduino(10,1, &data_to_transmit ); 
08984:  MOV.B   #A,W0L
08986:  MOV.B   W0L,1B3C
08988:  MOV.B   #1,W0L
0898A:  MOV.B   W0L,1B3D
0898C:  MOV     #A82,W4
0898E:  MOV     W4,1B3E
08990:  CALL    88B0
....................  
.................... 	LED1 = 1; 
08994:  BSET.B  2D0.1
.................... 	delay_ms(200); 
08996:  MOV     #C8,W0
08998:  CALL    DE2
.................... 	LED1 = 0; 
0899C:  BCLR.B  2D0.1
.................... 	LED2 = 1; 
0899E:  BSET.B  2D0.2
.................... 	delay_ms(200); 
089A0:  MOV     #C8,W0
089A2:  CALL    DE2
.................... 	LED2 = 0; 
089A6:  BCLR.B  2D0.2
.................... 	LED3 = 1; 
089A8:  BSET.B  2D0.3
.................... 	delay_ms(200); 
089AA:  MOV     #C8,W0
089AC:  CALL    DE2
.................... 	LED3 = 0; 
089B0:  BCLR.B  2D0.3
.................... 	delay_ms(200); 
089B2:  MOV     #C8,W0
089B4:  CALL    DE2
.................... 	LED3 = 1; 
089B8:  BSET.B  2D0.3
.................... 	delay_ms(200); 
089BA:  MOV     #C8,W0
089BC:  CALL    DE2
.................... 	LED3 = 0; 
089C0:  BCLR.B  2D0.3
.................... 	LED2 = 1; 
089C2:  BSET.B  2D0.2
.................... 	delay_ms(200); 
089C4:  MOV     #C8,W0
089C6:  CALL    DE2
.................... 	LED2 = 0; 
089CA:  BCLR.B  2D0.2
.................... 	LED1 = 1; 
089CC:  BSET.B  2D0.1
.................... 	delay_ms(200); 
089CE:  MOV     #C8,W0
089D0:  CALL    DE2
.................... 	LED1 = 0; 
089D4:  BCLR.B  2D0.1
.................... 	delay_ms(180); 
089D6:  MOV     #B4,W0
089D8:  CALL    DE2
.................... 	 
.................... 	Action_send = 1; 
089DC:  BSET.B  C24.0
089DE:  RETURN  
....................  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant d'ordonner  l'arduino de prendre les palets qui se trouvent 
.................... // devant lui 
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Take_front() 
.................... { 
.................... 	Write_cmd_arduino(20,1, &data_to_transmit ); 
*
08A3C:  MOV.B   #14,W0L
08A3E:  MOV.B   W0L,1B3C
08A40:  MOV.B   #1,W0L
08A42:  MOV.B   W0L,1B3D
08A44:  MOV     #A82,W4
08A46:  MOV     W4,1B3E
08A48:  CALL    88B0
.................... 	LED3 = 1; 
08A4C:  BSET.B  2D0.3
.................... 	delay_ms(50); 
08A4E:  MOV     #32,W0
08A50:  CALL    DE2
.................... 	 
.................... 	Read_etat_arduino(&stat); 
08A54:  MOV     #A92,W4
08A56:  MOV     W4,1B3C
08A58:  CALL    89E0
.................... 	while(stat.msg != 1) 
08A5C:  MOV     A92,W4
08A5E:  LSR     W4,#8,W4
08A60:  CP.B    W4L,#1
08A62:  BRA     Z,8A86
.................... 	{ 
.................... 		Write_cmd_arduino(20,1, &data_to_transmit ); 
08A64:  MOV.B   #14,W0L
08A66:  MOV.B   W0L,1B3C
08A68:  MOV.B   #1,W0L
08A6A:  MOV.B   W0L,1B3D
08A6C:  MOV     #A82,W4
08A6E:  MOV     W4,1B3E
08A70:  CALL    88B0
.................... 		delay_ms(50); 
08A74:  MOV     #32,W0
08A76:  CALL    DE2
.................... 		Read_etat_arduino(&stat); 
08A7A:  MOV     #A92,W4
08A7C:  MOV     W4,1B3C
08A7E:  CALL    89E0
08A82:  GOTO    8A5C
.................... 	} 
.................... 	delay_ms(200); 
08A86:  MOV     #C8,W0
08A88:  CALL    DE2
.................... 	LED3 = 0; 
08A8C:  BCLR.B  2D0.3
.................... 	/* 
.................... 	 
.................... 	 
.................... 	while(!_DEMA) 
.................... 	{ 
.................... 		LED1 = 1; 
.................... 		delay_ms(200); 
.................... 		LED1 = 0; 
.................... 		delay_ms(200); 
.................... 		 
.................... 		LED1 = 1; 
.................... 		delay_ms(200); 
.................... 		LED1 = 0; 
.................... 		delay_ms(200); 
.................... 		 
.................... 		LED1 = 1; 
.................... 		delay_ms(200); 
.................... 		LED1 = 0; 
.................... 		delay_ms(200); 
.................... 		 
.................... 	}	 
.................... 	*/ 
.................... 	Action_send = 1; 
08A8E:  BSET.B  C24.0
08A90:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant d'ordonner  l'arduino de prendre les palets qui se trouvent 
.................... // sur le ct  
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Take_side() 
.................... { 
.................... 	Write_cmd_arduino(30,1, &data_to_transmit ); 
08A92:  MOV.B   #1E,W0L
08A94:  MOV.B   W0L,1B3C
08A96:  MOV.B   #1,W0L
08A98:  MOV.B   W0L,1B3D
08A9A:  MOV     #A82,W4
08A9C:  MOV     W4,1B3E
08A9E:  CALL    88B0
.................... 	Action_send = 1; 
08AA2:  BSET.B  C24.0
08AA4:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant d'ordonner  l'arduino de prendre le goldenium 
.................... // devant lui 
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Take_goldenium() 
.................... { 
.................... 	Write_cmd_arduino(40,1, &data_to_transmit ); 
08AA6:  MOV.B   #28,W0L
08AA8:  MOV.B   W0L,1B3C
08AAA:  MOV.B   #1,W0L
08AAC:  MOV.B   W0L,1B3D
08AAE:  MOV     #A82,W4
08AB0:  MOV     W4,1B3E
08AB2:  CALL    88B0
.................... 	Action_send = 1; 
08AB6:  BSET.B  C24.0
08AB8:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant de vider les rservoirs dans la balancce 
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Put_balance() 
.................... { 
.................... 	Action_send = 1; 
08ABA:  BSET.B  C24.0
08ABC:  RETURN  
.................... 	 
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant de vider le rservoir dans l'acclrateur 
.................... //===================================================================================================================== 
.................... // Dvelopp par : Rithner Aurlien 
.................... // Date          : 01.03.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : aucun 
.................... // return        : rien 
.................... // 
.................... //********************************************************************************************************************* 
.................... void Put_accelerator() 
.................... { 
.................... 	 
.................... 	Action_send = 1; 
08ABE:  BSET.B  C24.0
08AC0:  RETURN  
.................... } 
....................  
....................  
.................... void Check_action_done() 
.................... { 
.................... 	Read_etat_arduino(&stat); 
*
08B34:  MOV     #A92,W4
08B36:  MOV     W4,1B3C
08B38:  CALL    89E0
.................... 	 
.................... 	if(stat.bras == 0) 
08B3C:  CP0.B   A92
08B3E:  BRA     NZ,8B46
.................... 	{ 
.................... 		flag_action_done = 1; 
08B40:  BSET.B  C24.2
.................... 	} 
08B42:  GOTO    8B54
.................... 	else if(stat.bras == 2) 
08B46:  MOV     A92,W4
08B48:  CP.B    W4L,#2
08B4A:  BRA     NZ,8B52
.................... 	{ 
.................... 		//LCD ERREUR BRAS 
.................... 		flag_action_done = 0; 
08B4C:  BCLR.B  C24.2
.................... 	} 
08B4E:  GOTO    8B54
.................... 	else 
.................... 	{ 
.................... 		flag_action_done = 0; 
08B52:  BCLR.B  C24.2
.................... 	}			 
08B54:  RETURN  
.................... }	 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant de donner un ordre  l'arduino 
.................... // 
.................... // Dvelopp par : Daniel Duay 
.................... // Date          : 07.02.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : cmd      = commande  excuter (int8) valeur de 1  255 
.................... //                 taille   = longueur des datas  envoyer max. 16 bytes (int8) 
.................... //                 data     = valeur  envoyer (int8)) 
.................... // return        : none 
.................... //													 
.................... // 
.................... //********************************************************************************************************************* 
.................... unsigned int8 Write_cmd_arduino(unsigned int8 cmd,unsigned int8 taille, unsigned int8 *data )  
*
088B0:  MOV     W5,[W15++]
.................... { 
.................... 	unsigned int8 boucle; 
.................... 	unsigned int8 crc; 
.................... 	 
.................... 	if (taille > 16) taille = 16;           // taille du buffer max.  envoyer 
088B2:  MOV     1B3C,W4
088B4:  LSR     W4,#8,W4
088B6:  CP.B    W4L,#10
088B8:  BRA     LEU,88BE
088BA:  MOV.B   #10,W0L
088BC:  MOV.B   W0L,1B3D
.................... 	CS1	= 0; 
088BE:  BCLR.B  2C8.2
.................... 	delay_us(1); 
088C0:  REPEAT  #12
088C2:  NOP     
.................... 	spi_write(cmd);     // commande  envoyer 
088C4:  BCLR.B  220.6
088C6:  BTSS.B  220.0
088C8:  BRA     88CE
088CA:  MOV.B   224,W0L
088CC:  BRA     88C6
088CE:  MOV.B   1B3C,W0L
088D0:  MOV.B   W0L,224
088D2:  BTSS.B  220.0
088D4:  BRA     88D2
.................... 	crc = cmd; 
088D6:  MOV.B   1B3C,W0L
088D8:  MOV.B   W0L,1B41
.................... 	delay_us(10); 
088DA:  REPEAT  #C6
088DC:  NOP     
.................... 	spi_write(taille);  // longueur des datas 
088DE:  BCLR.B  220.6
088E0:  BTSS.B  220.0
088E2:  BRA     88E8
088E4:  MOV.B   224,W0L
088E6:  BRA     88E0
088E8:  MOV.B   1B3D,W0L
088EA:  MOV.B   W0L,224
088EC:  BTSS.B  220.0
088EE:  BRA     88EC
.................... 	crc = crc + taille; 
088F0:  MOV.B   1B41,W0L
088F2:  ADD.B   1B3D,W0L
088F4:  MOV.B   W0L,1B41
.................... 	delay_us(10); 
088F6:  REPEAT  #C6
088F8:  NOP     
.................... 	 
.................... 	for (boucle=0;boucle<taille;boucle++)   // data  envoyer 
088FA:  CLR.B   1B40
088FC:  MOV.B   1B40,W0L
088FE:  MOV     1B3C,W4
08900:  LSR     W4,#8,W4
08902:  CP.B    W4L,W0L
08904:  BRA     LEU,893C
.................... 	{ 
.................... 	    spi_write(data[boucle]);         
08906:  MOV     1B40,W4
08908:  CLR.B   9
0890A:  MOV     W4,W0
0890C:  ADD     1B3E,W0
0890E:  MOV.B   [W0],W5L
08910:  BCLR.B  220.6
08912:  BTSS.B  220.0
08914:  BRA     891A
08916:  MOV.B   224,W0L
08918:  BRA     8912
0891A:  PUSH    224
0891C:  MOV.B   W5L,[W15-#2]
0891E:  POP     224
08920:  BTSS.B  220.0
08922:  BRA     8920
.................... 	    crc = crc + data[boucle]; 
08924:  MOV     1B40,W4
08926:  CLR.B   9
08928:  MOV     W4,W0
0892A:  ADD     1B3E,W0
0892C:  MOV     W0,W4
0892E:  MOV.B   [W4],W0L
08930:  ADD.B   1B41
.................... 	    delay_us(10); 
08932:  REPEAT  #C6
08934:  NOP     
08936:  INC.B   1B40
08938:  GOTO    88FC
.................... 	} 
.................... 	crc = 0xFF - crc + 1;   // calcul du CRC 
0893C:  MOV     1B40,W4
0893E:  LSR     W4,#8,W4
08940:  MOV     #FF,W3
08942:  SUB     W3,W4,W5
08944:  ADD.B   W5L,#1,W5L
08946:  MOV.B   W5L,W0L
08948:  MOV.B   W0L,1B41
.................... 	spi_write(crc);         // envoi du CRC 
0894A:  BCLR.B  220.6
0894C:  BTSS.B  220.0
0894E:  BRA     8954
08950:  MOV.B   224,W0L
08952:  BRA     894C
08954:  MOV.B   1B41,W0L
08956:  MOV.B   W0L,224
08958:  BTSS.B  220.0
0895A:  BRA     8958
.................... 	delay_us(10); 
0895C:  REPEAT  #C6
0895E:  NOP     
.................... 	CS1	= 1; 
08960:  BSET.B  2C8.2
08962:  MOV     [--W15],W5
08964:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // Fonction permettant de lire l'tat de l'arduino 
.................... // 
.................... // Dvelopp par : Daniel Duay 
.................... // Date          : 07.02.2019  
.................... // Rvision      : 
.................... // 
.................... // paramtres    : structure contenant l'tat des 3 variables 
.................... //                 bras variable pour sauvegarder l'tat du bras 
.................... //                 msg variable pour signaler si les messages reu par le slave sont corrects 
.................... //                 cam variable pour sauvegarder l'tat de la camra 
.................... // return        : retourne le status de l'arduino 
.................... //                 3 bits low bit 0..2(status du bras)        
.................... //				   0-> Arret  (le bras a fini tout traitement et attend le prochain ordre)	 
.................... //				   1-> Marche (le bras est entrain d'excuter l'ordre)													 
.................... //				   2-> Erreur bras 
.................... //				   3-> Action en traitement 
.................... //				   4-> Action termine 
.................... //                 2 bits middle bit 3..4 (rception message) 
.................... //				   0-> pas de message ou ordre pas trait 
.................... //				   1-> message reu + checksum OK 
.................... //                 2-> erreur CRC rception message 
.................... //                 3 bits high bit 5..7 (status de la camra)        
.................... //				   0-> aucune dtection (la camra ne dtecte aucun palet)	 
.................... //				   1-> dtection niveau 1 (la camra dtecte un palet, le robot doit ralentir )													 
.................... //				   2-> dtection niveau 2 (la camra dtecte un palet trs proche, le robot doirt s'arrter)													 
.................... // 
.................... //********************************************************************************************************************* 
.................... Read_etat_arduino(struct etat *value)  
*
089E0:  MOV     W5,[W15++]
089E2:  MOV     W6,[W15++]
089E4:  CLR.B   1B3E
.................... { 
.................... 	unsigned int8 arduino_etat=0; 
.................... 	 
.................... 	CS1	= 0; 
089E6:  BCLR.B  2C8.2
.................... 	delay_us(1); 
089E8:  REPEAT  #12
089EA:  NOP     
.................... 	arduino_etat = spi_read(0x00); 
089EC:  BCLR.B  220.6
089EE:  BTSS.B  220.0
089F0:  BRA     89F6
089F2:  MOV.B   224,W0L
089F4:  BRA     89EE
089F6:  CLR.B   224
089F8:  BTSS.B  220.0
089FA:  BRA     89F8
089FC:  MOV.B   224,W0L
089FE:  MOV.B   W0L,1B3E
.................... 	value->bras =  (arduino_etat & 0x07); 
08A00:  MOV     #0,W0
08A02:  ADD     1B3C,W0
08A04:  MOV     W0,W5
08A06:  MOV.B   1B3E,W0L
08A08:  CLR.B   1
08A0A:  AND     W0,#7,W0
08A0C:  MOV.B   W0L,[W5]
.................... 	value->msg =  (arduino_etat & 0x18) >> 3; 
08A0E:  MOV     #1,W0
08A10:  ADD     1B3C,W0
08A12:  MOV     W0,W5
08A14:  MOV.B   1B3E,W0L
08A16:  CLR.B   1
08A18:  AND     W0,#18,W6
08A1A:  LSR     W6,#3,W0
08A1C:  MOV.B   W0L,[W5]
08A1E:  MOV.B   W0L,[W5]
.................... 	value->cam =  (arduino_etat & 0xE0) >> 5; 
08A20:  MOV     #2,W0
08A22:  ADD     1B3C,W0
08A24:  MOV     W0,W5
08A26:  MOV     1B3E,W6
08A28:  AND     #E0,W6
08A2A:  LSR     W6,#5,W0
08A2C:  MOV.B   W0L,[W5]
08A2E:  MOV.B   W0L,[W5]
.................... 	delay_us(1); 
08A30:  REPEAT  #12
08A32:  NOP     
.................... 	CS1	= 1; 
08A34:  BSET.B  2C8.2
08A36:  MOV     [--W15],W6
08A38:  MOV     [--W15],W5
08A3A:  RETURN  
.................... } 
....................  
....................  
.................... /* 
.................... 	Fct qui reset une partie de l'eeprom en 
.................... 	remettant les valeurs  0xffff 
.................... 	 
.................... 	Auteur : Borgeat Rmy 
.................... 	Date   : 9.2.2017 
.................... */ 
.................... void __resetEEPROM(void) 
*
09456:  MOV     W5,[W15++]
09458:  CLR     1B5E
.................... { 
.................... 	unsigned int16 adresse = 0; 
.................... 	for(adresse = 0; adresse <= 0xFFF; adresse +=  2) 
0945A:  CLR     1B5E
0945C:  MOV     1B5E,W4
0945E:  MOV     #FFF,W3
09460:  CP      W3,W4
09462:  BRA     NC,947A
.................... 	{ 
.................... 		write_eeprom(adresse, 0xFFFF);//on crase l'eeprom 
09464:  MOV     #FFFF,W5
09466:  MOV     1B5E,W0
09468:  MOV     #A,W1
0946A:  MOV     #2,W2
0946C:  CALL    9000
09470:  MOV     1B5E,W4
09472:  ADD     W4,#2,W4
09474:  MOV     W4,1B5E
09476:  GOTO    945C
.................... 	} 
0947A:  MOV     [--W15],W5
0947C:  RETURN  
.................... } 
.................... void __reset_roboteq(void) 
.................... { 
.................... 	fputc('%',ROBOTEQ); 
*
09432:  MOV.B   #25,W0L
09434:  BTSC.B  219.1
09436:  BRA     9434
09438:  MOV.B   W0L,21A
0943A:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"RESET 321654987 \r"); 
0943C:  MOV     #0,W1
0943E:  MOV     W1,W0
09440:  CLR.B   1
09442:  CALL    246
09446:  INC     W1,W1
09448:  BTSC.B  219.1
0944A:  BRA     9448
0944C:  MOV     W0,21A
0944E:  MOV     #10,W0
09450:  CPSGT   W1,W0
09452:  BRA     943E
09454:  RETURN  
.................... } 
....................  
.................... /*======================================================================================= 
.................... 	Fct qui va recuperer les pid du roboteq et les mettre dans un tableau 
.................... =========================================================================================	 
.................... 	Auteur : Borgeat Rmy 
.................... 	Date : 16.2.2017 
.................... =========================================================================================	 
.................... 	! on doit faire passer 6x dans la fct. 
.................... 	On doit mettre une boucle exeterieur, car avec dans la fct, 
.................... 	on resete la dedans, et donc on ne peut pas recuperer des caractere 
.................... 	 
.................... 	Trame envoyer : Tab{2,0,:,10,...\r) 
.................... 					Tab{kp1 : ki1 : ...) 
.................... 	Les : separe les donnes, le \r annonce la fin du tableau 
.................... 	 
.................... 	!on peut pas chainer les commande, car il ecrase a chaque fois la reponse de l'ordre precdent 
.................... ==========================================================================================*/ 
.................... void __GetRoboteqPID(unsigned int8 valeur) 
*
0903A:  MOV     W5,[W15++]
0903C:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 i = 3; // car on recoit KP=110 -> on veut que la valeur --> on saute les 3 premiers caractere 
.................... 	static int8 y = 0; 
.................... 	 
.................... 	switch(valeur) // on demande au roboteq es valeur 
0903E:  MOV.B   1B5E,W0L
09040:  CLR.B   1
09042:  XOR     #0,W0
09044:  BRA     Z,906C
09046:  XOR     #1,W0
09048:  BRA     Z,908E
0904A:  XOR     #3,W0
0904C:  BRA     Z,90B0
0904E:  XOR     #1,W0
09050:  BRA     Z,90D2
09052:  XOR     #7,W0
09054:  BRA     Z,90F4
09056:  XOR     #1,W0
09058:  BRA     Z,9116
0905A:  XOR     #3,W0
0905C:  BRA     Z,9138
0905E:  XOR     #1,W0
09060:  BRA     Z,915E
09062:  XOR     #F,W0
09064:  BRA     Z,9184
09066:  XOR     #1,W0
09068:  BRA     Z,91AA
0906A:  BRA     91D0
.................... 	{ 
.................... 		case 0: 
.................... 			fprintf(ROBOTEQ,"~KP 1 \r");			 
0906C:  MOV     #0,W1
0906E:  MOV     W1,W0
09070:  CLR.B   1
09072:  CALL    264
09076:  INC     W1,W1
09078:  BTSC.B  219.1
0907A:  BRA     9078
0907C:  MOV     W0,21A
0907E:  MOV     #6,W0
09080:  CPSGT   W1,W0
09082:  BRA     906E
.................... 			delay_ms(10);			 
09084:  MOV     #A,W0
09086:  CALL    DE2
.................... 			break; 
0908A:  GOTO    91D0
.................... 		case 1: 
.................... 			fprintf(ROBOTEQ,"~KI 1 \r"); 
0908E:  MOV     #0,W1
09090:  MOV     W1,W0
09092:  CLR.B   1
09094:  CALL    278
09098:  INC     W1,W1
0909A:  BTSC.B  219.1
0909C:  BRA     909A
0909E:  MOV     W0,21A
090A0:  MOV     #6,W0
090A2:  CPSGT   W1,W0
090A4:  BRA     9090
.................... 			delay_ms(10); 
090A6:  MOV     #A,W0
090A8:  CALL    DE2
.................... 			break; 
090AC:  GOTO    91D0
.................... 		case 2: 
.................... 			fprintf(ROBOTEQ,"~KD 1 \r"); 
090B0:  MOV     #0,W1
090B2:  MOV     W1,W0
090B4:  CLR.B   1
090B6:  CALL    28C
090BA:  INC     W1,W1
090BC:  BTSC.B  219.1
090BE:  BRA     90BC
090C0:  MOV     W0,21A
090C2:  MOV     #6,W0
090C4:  CPSGT   W1,W0
090C6:  BRA     90B2
.................... 			delay_ms(10); 
090C8:  MOV     #A,W0
090CA:  CALL    DE2
.................... 			break; 
090CE:  GOTO    91D0
.................... 		case 3: 
.................... 			fprintf(ROBOTEQ,"~KP 2 \r"); 
090D2:  MOV     #0,W1
090D4:  MOV     W1,W0
090D6:  CLR.B   1
090D8:  CALL    2A0
090DC:  INC     W1,W1
090DE:  BTSC.B  219.1
090E0:  BRA     90DE
090E2:  MOV     W0,21A
090E4:  MOV     #6,W0
090E6:  CPSGT   W1,W0
090E8:  BRA     90D4
.................... 			delay_ms(10); 
090EA:  MOV     #A,W0
090EC:  CALL    DE2
.................... 			break; 
090F0:  GOTO    91D0
.................... 		case 4: 
.................... 			fprintf(ROBOTEQ,"~KI 2 \r"); 
090F4:  MOV     #0,W1
090F6:  MOV     W1,W0
090F8:  CLR.B   1
090FA:  CALL    2B4
090FE:  INC     W1,W1
09100:  BTSC.B  219.1
09102:  BRA     9100
09104:  MOV     W0,21A
09106:  MOV     #6,W0
09108:  CPSGT   W1,W0
0910A:  BRA     90F6
.................... 			delay_ms(10); 
0910C:  MOV     #A,W0
0910E:  CALL    DE2
.................... 			break; 
09112:  GOTO    91D0
.................... 		case 5: 
.................... 			fprintf(ROBOTEQ,"~KD 2 \r"); 
09116:  MOV     #0,W1
09118:  MOV     W1,W0
0911A:  CLR.B   1
0911C:  CALL    2C8
09120:  INC     W1,W1
09122:  BTSC.B  219.1
09124:  BRA     9122
09126:  MOV     W0,21A
09128:  MOV     #6,W0
0912A:  CPSGT   W1,W0
0912C:  BRA     9118
.................... 			delay_ms(10); 
0912E:  MOV     #A,W0
09130:  CALL    DE2
.................... 			break;	 
09134:  GOTO    91D0
.................... 		case 6: 
.................... 			fprintf(ROBOTEQ,"~MAC 1 \r"); 
09138:  MOV     #0,W1
0913A:  MOV     W1,W0
0913C:  CLR.B   1
0913E:  CALL    2DC
09142:  INC     W1,W1
09144:  BTSC.B  219.1
09146:  BRA     9144
09148:  MOV     W0,21A
0914A:  MOV     #7,W0
0914C:  CPSGT   W1,W0
0914E:  BRA     913A
.................... 			delay_ms(10); 
09150:  MOV     #A,W0
09152:  CALL    DE2
.................... 			i = 4; 
09156:  MOV.B   #4,W0L
09158:  MOV.B   W0L,15FE
.................... 			break;	 
0915A:  GOTO    91D0
.................... 		case 7: 
.................... 			fprintf(ROBOTEQ,"~MDEC 1 \r"); 
0915E:  MOV     #0,W1
09160:  MOV     W1,W0
09162:  CLR.B   1
09164:  CALL    2F2
09168:  INC     W1,W1
0916A:  BTSC.B  219.1
0916C:  BRA     916A
0916E:  MOV     W0,21A
09170:  MOV     #8,W0
09172:  CPSGT   W1,W0
09174:  BRA     9160
.................... 			delay_ms(10); 
09176:  MOV     #A,W0
09178:  CALL    DE2
.................... 			i = 5; 
0917C:  MOV.B   #5,W0L
0917E:  MOV.B   W0L,15FE
.................... 			break;	 
09180:  GOTO    91D0
.................... 		case 8: 
.................... 			fprintf(ROBOTEQ,"~MAC 2 \r"); 
09184:  MOV     #0,W1
09186:  MOV     W1,W0
09188:  CLR.B   1
0918A:  CALL    308
0918E:  INC     W1,W1
09190:  BTSC.B  219.1
09192:  BRA     9190
09194:  MOV     W0,21A
09196:  MOV     #7,W0
09198:  CPSGT   W1,W0
0919A:  BRA     9186
.................... 			delay_ms(10); 
0919C:  MOV     #A,W0
0919E:  CALL    DE2
.................... 			i = 4; 
091A2:  MOV.B   #4,W0L
091A4:  MOV.B   W0L,15FE
.................... 			break;	 
091A6:  GOTO    91D0
.................... 		case 9: 
.................... 			fprintf(ROBOTEQ,"~MDEC 2 \r"); 
091AA:  MOV     #0,W1
091AC:  MOV     W1,W0
091AE:  CLR.B   1
091B0:  CALL    31E
091B4:  INC     W1,W1
091B6:  BTSC.B  219.1
091B8:  BRA     91B6
091BA:  MOV     W0,21A
091BC:  MOV     #8,W0
091BE:  CPSGT   W1,W0
091C0:  BRA     91AC
.................... 			delay_ms(10); 
091C2:  MOV     #A,W0
091C4:  CALL    DE2
.................... 			i = 5; 
091C8:  MOV.B   #5,W0L
091CA:  MOV.B   W0L,15FE
.................... 			break;	 
091CC:  GOTO    91D0
.................... 	}	 
....................  
.................... 	if(RoboteQ_receiveBuffer[0] == 'K' || RoboteQ_receiveBuffer[0] == 'M') 
091D0:  MOV     882,W4
091D2:  XOR.B   #4B,W4L
091D4:  BRA     Z,91DC
091D6:  MOV     882,W4
091D8:  XOR.B   #4D,W4L
091DA:  BRA     NZ,9230
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i] != 0x0D) // On commence du [2] pour sauter le 'C='. Le +3 est pour le C,= et : (C=xxx:xxx). 
091DC:  MOV.B   15FE,W0L
091DE:  SE      W0,W0
091E0:  MOV     #882,W4
091E2:  ADD     W0,W4,W0
091E4:  MOV.B   [W0],W5L
091E6:  SE      W5,W5
091E8:  CP      W5,#D
091EA:  BRA     Z,9206
.................... 		{  
.................... 			TabSentRS232[y] = RoboteQ_receiveBuffer[i];				 
091EC:  MOV.B   15FF,W0L
091EE:  SE      W0,W0
091F0:  MOV     #982,W4
091F2:  ADD     W0,W4,W5
091F4:  MOV.B   15FE,W0L
091F6:  SE      W0,W0
091F8:  MOV     #882,W4
091FA:  ADD     W0,W4,W0
091FC:  MOV.B   [W0],[W5]
.................... 			i++; 
091FE:  INC.B   15FE
.................... 			y++; 
09200:  INC.B   15FF
09202:  GOTO    91DC
.................... 		} 
.................... 		if(valeur<9) 
09206:  MOV     1B5E,W4
09208:  CP.B    W4L,#9
0920A:  BRA     C,921E
.................... 		{	 
.................... 			TabSentRS232[y] = ':';//seperation des valeur	 
0920C:  MOV.B   15FF,W0L
0920E:  SE      W0,W0
09210:  MOV     #982,W4
09212:  ADD     W0,W4,W5
09214:  MOV.B   #3A,W0L
09216:  MOV.B   W0L,[W5]
.................... 			y++; 
09218:  INC.B   15FF
.................... 		} 
0921A:  GOTO    922C
.................... 		else 
.................... 		{ 
.................... 			TabSentRS232[y] = '\r'; // fin de transmssion 
0921E:  MOV.B   15FF,W0L
09220:  SE      W0,W0
09222:  MOV     #982,W4
09224:  ADD     W0,W4,W5
09226:  MOV.B   #D,W0L
09228:  MOV.B   W0L,[W5]
.................... 			y = 0 ;	 
0922A:  CLR.B   15FF
.................... 		} 
.................... 		i = 3; 
0922C:  MOV.B   #3,W0L
0922E:  MOV.B   W0L,15FE
.................... 	}	 
09230:  MOV     [--W15],W6
09232:  MOV     [--W15],W5
09234:  RETURN  
....................  
.................... } 
.................... /* 
.................... 	Fct qui va changer les paramtre PID du roboteq. 
.................... 	Les parametre ont ete recu du pc et ont les save en 
.................... 	dans l'eeprom du roboteq 
.................... 	 
.................... 	Auteur : Borgeat Rmy 
.................... 	Date   : 16.2.2017 
.................... */ 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2) 
09236:  MOV     W5,[W15++]
.................... { 
.................... 	//envoi des paramtres PID au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"^KP 1 %u_^KI 1 %u_^KD 1 %u_^KP 2 %u_^KI 2 %u_^KD 2 %u \r",P1,I1,D1,P2,I2,D2); 
09238:  MOV     #0,W1
0923A:  MOV     W1,W0
0923C:  CLR.B   1
0923E:  CALL    334
09242:  INC     W1,W1
09244:  BTSC.B  219.1
09246:  BRA     9244
09248:  MOV     W0,21A
0924A:  MOV     #5,W0
0924C:  CPSGT   W1,W0
0924E:  BRA     923A
09250:  MOV.B   1B86,W0L
09252:  CLR.B   1
09254:  MOV     #0,W4
09256:  CALL    6888
0925A:  MOV     #8,W1
0925C:  MOV     W1,W0
0925E:  CLR.B   1
09260:  CALL    334
09264:  INC     W1,W1
09266:  BTSC.B  219.1
09268:  BRA     9266
0926A:  MOV     W0,21A
0926C:  MOV     #E,W0
0926E:  CPSGT   W1,W0
09270:  BRA     925C
09272:  MOV.B   1B87,W0L
09274:  CLR.B   1
09276:  MOV     #0,W4
09278:  CALL    6888
0927C:  MOV     #11,W1
0927E:  MOV     W1,W0
09280:  CLR.B   1
09282:  CALL    334
09286:  INC     W1,W1
09288:  BTSC.B  219.1
0928A:  BRA     9288
0928C:  MOV     W0,21A
0928E:  MOV     #17,W0
09290:  CPSGT   W1,W0
09292:  BRA     927E
09294:  MOV.B   1B88,W0L
09296:  CLR.B   1
09298:  MOV     #0,W4
0929A:  CALL    6888
0929E:  MOV     #1A,W1
092A0:  MOV     W1,W0
092A2:  CLR.B   1
092A4:  CALL    334
092A8:  INC     W1,W1
092AA:  BTSC.B  219.1
092AC:  BRA     92AA
092AE:  MOV     W0,21A
092B0:  MOV     #20,W0
092B2:  CPSGT   W1,W0
092B4:  BRA     92A0
092B6:  MOV.B   1B89,W0L
092B8:  CLR.B   1
092BA:  MOV     #0,W4
092BC:  CALL    6888
092C0:  MOV     #23,W1
092C2:  MOV     W1,W0
092C4:  CLR.B   1
092C6:  CALL    334
092CA:  INC     W1,W1
092CC:  BTSC.B  219.1
092CE:  BRA     92CC
092D0:  MOV     W0,21A
092D2:  MOV     #29,W0
092D4:  CPSGT   W1,W0
092D6:  BRA     92C2
092D8:  MOV.B   1B8A,W0L
092DA:  CLR.B   1
092DC:  MOV     #0,W4
092DE:  CALL    6888
092E2:  MOV     #2C,W1
092E4:  MOV     W1,W0
092E6:  CLR.B   1
092E8:  CALL    334
092EC:  INC     W1,W1
092EE:  BTSC.B  219.1
092F0:  BRA     92EE
092F2:  MOV     W0,21A
092F4:  MOV     #32,W0
092F6:  CPSGT   W1,W0
092F8:  BRA     92E4
092FA:  MOV.B   1B8B,W0L
092FC:  CLR.B   1
092FE:  MOV     #0,W4
09300:  CALL    6888
09304:  BTSC.B  219.1
09306:  BRA     9304
09308:  MOV     #20,W4
0930A:  MOV     W4,21A
0930C:  BTSC.B  219.1
0930E:  BRA     930C
09310:  MOV     #D,W4
09312:  MOV     W4,21A
.................... 	fprintf(ROBOTEQ,"^MAC 1 %u_^MDEC 1 %u_^MAC 2 %u_^MDEC 2 %u \r",ac1,dc1,ac2,dc2);// envoie au Roboteq 
09314:  MOV     #0,W1
09316:  MOV     W1,W0
09318:  CLR.B   1
0931A:  CALL    376
0931E:  INC     W1,W1
09320:  BTSC.B  219.1
09322:  BRA     9320
09324:  MOV     W0,21A
09326:  MOV     #6,W0
09328:  CPSGT   W1,W0
0932A:  BRA     9316
0932C:  MOV.B   1B8C,W0L
0932E:  CLR.B   1
09330:  MOV     #0,W4
09332:  CALL    6888
09336:  MOV     #9,W1
09338:  MOV     W1,W0
0933A:  CLR.B   1
0933C:  CALL    376
09340:  INC     W1,W1
09342:  BTSC.B  219.1
09344:  BRA     9342
09346:  MOV     W0,21A
09348:  MOV     #11,W0
0934A:  CPSGT   W1,W0
0934C:  BRA     9338
0934E:  MOV.B   1B8D,W0L
09350:  CLR.B   1
09352:  MOV     #0,W4
09354:  CALL    6888
09358:  MOV     #14,W1
0935A:  MOV     W1,W0
0935C:  CLR.B   1
0935E:  CALL    376
09362:  INC     W1,W1
09364:  BTSC.B  219.1
09366:  BRA     9364
09368:  MOV     W0,21A
0936A:  MOV     #1B,W0
0936C:  CPSGT   W1,W0
0936E:  BRA     935A
09370:  MOV.B   1B8E,W0L
09372:  CLR.B   1
09374:  MOV     #0,W4
09376:  CALL    6888
0937A:  MOV     #1E,W1
0937C:  MOV     W1,W0
0937E:  CLR.B   1
09380:  CALL    376
09384:  INC     W1,W1
09386:  BTSC.B  219.1
09388:  BRA     9386
0938A:  MOV     W0,21A
0938C:  MOV     #26,W0
0938E:  CPSGT   W1,W0
09390:  BRA     937C
09392:  MOV.B   1B8F,W0L
09394:  CLR.B   1
09396:  MOV     #0,W4
09398:  CALL    6888
0939C:  BTSC.B  219.1
0939E:  BRA     939C
093A0:  MOV     #20,W4
093A2:  MOV     W4,21A
093A4:  BTSC.B  219.1
093A6:  BRA     93A4
093A8:  MOV     #D,W4
093AA:  MOV     W4,21A
....................  
.................... 	write_eeprom(300,P1); 
093AC:  MOV.B   1B86,W0L
093AE:  MOV.B   W0L,A
093B0:  CLR.B   B
093B2:  MOV     #12C,W0
093B4:  MOV     #A,W1
093B6:  MOV     #2,W2
093B8:  CALL    9000
.................... 	write_eeprom(302,I1); 
093BC:  MOV.B   1B87,W0L
093BE:  MOV.B   W0L,W5L
093C0:  CLR.B   B
093C2:  MOV     #12E,W0
093C4:  MOV     #A,W1
093C6:  MOV     #2,W2
093C8:  CALL    9000
.................... 	write_eeprom(304,D1); 
093CC:  MOV.B   1B88,W0L
093CE:  MOV.B   W0L,A
093D0:  CLR.B   B
093D2:  MOV     #130,W0
093D4:  MOV     #A,W1
093D6:  MOV     #2,W2
093D8:  CALL    9000
.................... 	write_eeprom(306,P2); 
093DC:  MOV.B   1B89,W0L
093DE:  MOV.B   W0L,W5L
093E0:  CLR.B   B
093E2:  MOV     #132,W0
093E4:  MOV     #A,W1
093E6:  MOV     #2,W2
093E8:  CALL    9000
.................... 	write_eeprom(308,I2); 
093EC:  MOV.B   1B8A,W0L
093EE:  MOV.B   W0L,A
093F0:  CLR.B   B
093F2:  MOV     #134,W0
093F4:  MOV     #A,W1
093F6:  MOV     #2,W2
093F8:  CALL    9000
.................... 	write_eeprom(310,D2); 
093FC:  MOV.B   1B8B,W0L
093FE:  MOV.B   W0L,W5L
09400:  CLR.B   B
09402:  MOV     #136,W0
09404:  MOV     #A,W1
09406:  MOV     #2,W2
09408:  CALL    9000
.................... 	 
.................... 	//Sauvegarde en eeprom 
.................... 	fputc('%',ROBOTEQ);//pas le choix de faire un putc, car le % est un caractre rserv pour le pritnf 
0940C:  MOV.B   #25,W0L
0940E:  BTSC.B  219.1
09410:  BRA     940E
09412:  MOV.B   W0L,21A
09414:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"EESAV \r");//envoie du reste de la commande 
09416:  MOV     #0,W1
09418:  MOV     W1,W0
0941A:  CLR.B   1
0941C:  CALL    3B0
09420:  INC     W1,W1
09422:  BTSC.B  219.1
09424:  BRA     9422
09426:  MOV     W0,21A
09428:  MOV     #6,W0
0942A:  CPSGT   W1,W0
0942C:  BRA     9418
0942E:  MOV     [--W15],W5
09430:  RETURN  
....................  
.................... } 
....................  
.................... // Rcupre tous les objectifs et les stock en eeprom 
.................... void __ReadObjectifs(void) 
*
0105E:  MOV     W5,[W15++]
01060:  MOV     W6,[W15++]
01062:  CLR     1B5E
01064:  CLR.B   1B62
01066:  CLR     1B64
01068:  CLR     1B66
0106A:  CLR     1B68
.................... { 
.................... 	// Lit les objectifs stocks en EEPROM 
.................... 	// Les lments d'objectifs sont stocks chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int8 j1, j2, j3 = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset = 0; 
.................... 	unsigned int16 NumObj = 0; 
.................... 	unsigned int16 Obj = 0; 
.................... 	 
.................... 	for(j1 = 0; j1< 7; j1++) 
0106C:  CLR.B   1B60
0106E:  MOV     1B60,W4
01070:  CP.B    W4L,#7
01072:  BRA     C,10BC
.................... 	{ 
.................... 		 for(j2 = 0; j2< 13; j2++) 
01074:  CLR.B   1B61
01076:  MOV     1B60,W4
01078:  LSR     W4,#8,W4
0107A:  CP.B    W4L,#D
0107C:  BRA     C,10B6
.................... 		{ 
.................... 			for(j3 = 0; j3< 12; j3++) 
0107E:  CLR.B   1B62
01080:  MOV     1B62,W4
01082:  CP.B    W4L,#C
01084:  BRA     C,10B0
.................... 			{ 
.................... 				TabObjectifs[j1][j2][j3] = 0; 
01086:  MOV     1B60,W4
01088:  CLR.B   9
0108A:  MOV     #138,W3
0108C:  MUL.UU  W4,W3,W0
0108E:  MOV     W0,W5
01090:  MOV     1B60,W4
01092:  LSR     W4,#8,W4
01094:  MUL.UU  W4,#18,W0
01096:  ADD     W0,W5,W5
01098:  MOV.B   1B62,W0L
0109A:  CLR.B   1
0109C:  SL      W0,#1,W0
0109E:  ADD     W0,W5,W0
010A0:  MOV     #C26,W4
010A2:  ADD     W0,W4,W5
010A4:  CLR.B   [W5]
010A6:  MOV.B   #0,W0L
010A8:  MOV.B   W0L,[W5+#1]
010AA:  INC.B   1B62
010AC:  GOTO    1080
.................... 			} 
010B0:  INC.B   1B61
010B2:  GOTO    1076
.................... 		} 
010B6:  INC.B   1B60
010B8:  GOTO    106E
.................... 	}			 
.................... 				 
.................... 	nbre_obj = read_eeprom(0xFFE); 
010BC:  MOV     #FFE,W3
010BE:  MOV     #0,W4
010C0:  MOV     #2,W5
010C2:  CALL    1046
010C6:  MOV.B   W0L,881
.................... 	if(nbre_obj == 0xFF) 
010C8:  MOV     880,W4
010CA:  LSR     W4,#8,W4
010CC:  XOR.B   #FF,W4L
010CE:  BRA     NZ,10D2
.................... 	{ 
.................... 		nbre_obj = 0; 
010D0:  CLR.B   881
.................... 	} 
.................... 	 
.................... 	offset = 0; 
010D2:  CLR     1600
.................... 	 
.................... 	for(y = 0; y < nbre_obj; y++) 
010D4:  CLR     1B64
010D6:  MOV.B   881,W0L
010D8:  CLR.B   1
010DA:  MOV     1B64,W4
010DC:  CP      W4,W0
010DE:  BRA     C,1156
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
010E0:  MOV     1600,W3
010E2:  MOV     #0,W4
010E4:  MOV     #2,W5
010E6:  CALL    1046
010EA:  MOV     W0,1B68
.................... 		NumObj = read_eeprom(offset+2); 
010EC:  MOV     1600,W4
010EE:  ADD     W4,#2,W4
010F0:  MOV     W4,W5
010F2:  MOV     W5,[W15++]
010F4:  MOV     W5,W3
010F6:  MOV     #0,W4
010F8:  MOV     #2,W5
010FA:  CALL    1046
010FE:  MOV     [--W15],W5
01100:  MOV     W0,1B66
.................... 		for( i = 0 ; i < 24; i += 2) 
01102:  CLR     1B5E
01104:  MOV     1B5E,W4
01106:  CP      W4,#18
01108:  BRA     C,114A
.................... 		{			 
.................... 			TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
0110A:  MOV     1B68,W4
0110C:  MOV     #138,W3
0110E:  MUL.UU  W4,W3,W0
01110:  MOV     W0,W5
01112:  MOV     1B66,W4
01114:  MUL.UU  W4,#18,W0
01116:  ADD     W0,W5,W5
01118:  MOV     1B5E,W6
0111A:  LSR     W6,#1,W6
0111C:  SL      W6,#1,W0
0111E:  ADD     W0,W5,W0
01120:  MOV     #C26,W4
01122:  ADD     W0,W4,W5
01124:  MOV     1B5E,W4
01126:  ADD     W4,#4,W4
01128:  MOV     W4,W6
0112A:  MOV     W6,W0
0112C:  ADD     1600,W0
0112E:  MOV     W0,W6
01130:  MOV     W5,[W15++]
01132:  MOV     W6,W3
01134:  MOV     #0,W4
01136:  MOV     #2,W5
01138:  CALL    1046
0113C:  MOV     [--W15],W5
0113E:  MOV     W0,[W5]
01140:  MOV     1B5E,W4
01142:  ADD     W4,#2,W4
01144:  MOV     W4,1B5E
01146:  GOTO    1104
.................... 		}	 
.................... 		 
.................... 		offset += 28;// offset de +24,afin de lire les objectifs suivant 
0114A:  MOV     1600,W4
0114C:  ADD     W4,#1C,W4
0114E:  MOV     W4,1600
01150:  INC     1B64
01152:  GOTO    10D6
.................... 	}	 
.................... 	 
.................... 	NbreObjectifs= nbre_obj;	 
01156:  MOV.B   881,W0L
01158:  MOV.B   W0L,14CE
0115A:  CLR.B   14CF
0115C:  MOV     [--W15],W6
0115E:  MOV     [--W15],W5
01160:  RETURN  
.................... 	 
.................... /* 
.................... 	while(y==0) 
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
.................... 		NumObj = read_eeprom(offset+2); 
.................... 		if(Obj!=0xFFFF)//Si il en reste 
.................... 		{ 
.................... 			for( i = 0 ; i < 24; i += 2) 
.................... 			{			 
.................... 				TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
.................... 			}	 
.................... 			offset += 28;// offset de +24,afin de lire les objectifs suivant	 
.................... 			NbreObjectifs=Obj;	 
.................... 		} 
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
.................... 		} 
.................... 	} 
.................... 	*/ 
.................... 	 
.................... 			 
....................  
.................... } 
.................... // Rcupre tous les objectifs et les stock en eeprom 
.................... void __ReadZones_Interdites(void) 
01162:  MOV     W5,[W15++]
01164:  MOV     W6,[W15++]
01166:  MOV     W7,[W15++]
01168:  CLR     1B5E
0116A:  CLR     1B60
0116C:  CLR     1B62
0116E:  CLR     1B64
.................... { 
.................... 	// Lit les objectifs stocks en EEPROM 
.................... 	// Les lments d'objectifs sont stocks chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	unsigned int16 temp_read = 0; 
.................... 	static int16 offset = 0xF2A; 
.................... 	unsigned int16 NumZone = 0; 
.................... 	 
....................  
.................... 	while(y==0) 
01170:  CP0     1B60
01172:  BRA     NZ,138C
.................... 	{ 
.................... 		NumZone = read_eeprom(offset);//on check si il reste des objectifs 
01174:  MOV     1602,W3
01176:  MOV     #0,W4
01178:  MOV     #2,W5
0117A:  CALL    1046
0117E:  MOV     W0,1B64
.................... 		if(NumZone!=0xFFFF)//Si il en reste 
01180:  MOV     1B64,W4
01182:  MOV     #FFFF,W3
01184:  CP      W3,W4
01186:  BRA     Z,1384
.................... 		{ 
.................... 			for( i = 0 ; i < 16; i += 2) 
01188:  CLR     1B5E
0118A:  MOV     1B5E,W4
0118C:  CP      W4,#10
0118E:  BRA     C,11CC
.................... 			{ 
.................... 				temp_read = read_eeprom(i+2+offset);//remplir le tableau avec les objectifs 
01190:  MOV     1B5E,W4
01192:  ADD     W4,#2,W4
01194:  MOV     W4,W5
01196:  MOV     W5,W0
01198:  ADD     1602,W0
0119A:  MOV     W0,W5
0119C:  MOV     W5,[W15++]
0119E:  MOV     W5,W3
011A0:  MOV     #0,W4
011A2:  MOV     #2,W5
011A4:  CALL    1046
011A8:  MOV     [--W15],W5
011AA:  MOV     W0,1B62
.................... 				 
.................... 				TabZonesPC[(i/2)] = temp_read; 
011AC:  MOV     1B5E,W5
011AE:  LSR     W5,#1,W5
011B0:  SL      W5,#2,W0
011B2:  MOV     #BFA,W4
011B4:  ADD     W0,W4,W5
011B6:  MOV     1B62,W4
011B8:  MOV     W4,[W5+#0]
011BA:  MOV.B   #0,W0L
011BC:  MOV.B   W0L,[W5+#2]
011BE:  MOV.B   #0,W0L
011C0:  MOV.B   W0L,[W5+#3]
011C2:  MOV     1B5E,W4
011C4:  ADD     W4,#2,W4
011C6:  MOV     W4,1B5E
011C8:  GOTO    118A
.................... 			}	 
....................  
.................... 			TabZones[NumZone-1][0] = TabZonesPC[0]; 
011CC:  MOV     1B64,W4
011CE:  SUB     W4,#1,W5
011D0:  SL      W5,#4,W5
011D2:  MOV     #B5A,W4
011D4:  ADD     W5,W4,W6
011D6:  MOV     #BFA,W4
011D8:  MOV     [W4++],[W6++]
011DA:  MOV     [W4++],[W6++]
.................... 			TabZones[NumZone-1][1] = TabZonesPC[1]; 
011DC:  MOV     1B64,W4
011DE:  SUB     W4,#1,W5
011E0:  SL      W5,#4,W5
011E2:  ADD     W5,#4,W5
011E4:  MOV     W5,W0
011E6:  MOV     #B5A,W4
011E8:  ADD     W0,W4,W5
011EA:  MOV     #BFE,W4
011EC:  MOV     [W4++],[W5++]
011EE:  MOV     [W4++],[W5++]
.................... 			TabZones[NumZone-1][2] = TabZonesPC[4]; 
011F0:  MOV     1B64,W4
011F2:  SUB     W4,#1,W5
011F4:  SL      W5,#4,W5
011F6:  ADD     W5,#8,W5
011F8:  MOV     W5,W0
011FA:  MOV     #B5A,W4
011FC:  ADD     W0,W4,W5
011FE:  MOV     #C0A,W4
01200:  MOV     [W4++],[W5++]
01202:  MOV     [W4++],[W5++]
.................... 			TabZones[NumZone-1][3] = TabZonesPC[5]; 
01204:  MOV     1B64,W4
01206:  SUB     W4,#1,W5
01208:  SL      W5,#4,W5
0120A:  ADD     W5,#C,W5
0120C:  MOV     W5,W0
0120E:  MOV     #B5A,W4
01210:  ADD     W0,W4,W5
01212:  MOV     #C0E,W4
01214:  MOV     [W4++],[W5++]
01216:  MOV     [W4++],[W5++]
.................... 			 
.................... 			if(TabZones[NumZone-1][0] < MARGE)TabZones[NumZone-1][0] = 0; else TabZones[NumZone-1][0] -= (MARGE/2);	 
01218:  MOV     1B64,W4
0121A:  SUB     W4,#1,W5
0121C:  SL      W5,#4,W5
0121E:  MOV     #B5A,W4
01220:  ADD     W5,W4,W0
01222:  MOV     #C,W4
01224:  MOV     [W0++],[W4++]
01226:  MOV     [W0++],[W4++]
01228:  CP      W7,#0
0122A:  BRA     GT,1250
0122C:  BRA     LT,1234
0122E:  MOV     #168,W4
01230:  CP      W4,W6
01232:  BRA     LEU,1250
01234:  MOV     1B64,W4
01236:  SUB     W4,#1,W5
01238:  SL      W5,#4,W5
0123A:  MOV     #B5A,W4
0123C:  ADD     W5,W4,W6
0123E:  CLR.B   [W6]
01240:  MOV.B   #0,W0L
01242:  MOV.B   W0L,[W6+#1]
01244:  MOV.B   #0,W0L
01246:  MOV.B   W0L,[W6+#2]
01248:  MOV.B   #0,W0L
0124A:  MOV.B   W0L,[W6+#3]
0124C:  GOTO    1266
01250:  MOV     1B64,W4
01252:  SUB     W4,#1,W5
01254:  SL      W5,#4,W5
01256:  MOV     #B5A,W4
01258:  ADD     W5,W4,W6
0125A:  MOV     [W6],W4
0125C:  SUB     #B4,W4
0125E:  MOV     W4,[W6]
01260:  MOV     [++W6],W4
01262:  SUBB    W4,#0,W0
01264:  MOV     W0,[W6+#0]
.................... 			if(TabZones[NumZone-1][1] < MARGE)TabZones[NumZone-1][1] = 0; else TabZones[NumZone-1][1] -= (MARGE/2);	 
01266:  MOV     1B64,W4
01268:  SUB     W4,#1,W5
0126A:  SL      W5,#4,W5
0126C:  ADD     W5,#4,W5
0126E:  MOV     W5,W0
01270:  MOV     #B5A,W4
01272:  ADD     W0,W4,W0
01274:  MOV     #A,W4
01276:  MOV     [W0++],[W4++]
01278:  MOV     [W0++],[W4++]
0127A:  CP      W6,#0
0127C:  BRA     GT,12A6
0127E:  BRA     LT,1286
01280:  MOV     #168,W4
01282:  CP      W4,W5
01284:  BRA     LEU,12A6
01286:  MOV     1B64,W4
01288:  SUB     W4,#1,W5
0128A:  SL      W5,#4,W5
0128C:  ADD     W5,#4,W5
0128E:  MOV     W5,W0
01290:  MOV     #B5A,W4
01292:  ADD     W0,W4,W5
01294:  CLR.B   [W5]
01296:  MOV.B   #0,W0L
01298:  MOV.B   W0L,[W5+#1]
0129A:  MOV.B   #0,W0L
0129C:  MOV.B   W0L,[W5+#2]
0129E:  MOV.B   #0,W0L
012A0:  MOV.B   W0L,[W5+#3]
012A2:  GOTO    12C0
012A6:  MOV     1B64,W4
012A8:  SUB     W4,#1,W5
012AA:  SL      W5,#4,W5
012AC:  ADD     W5,#4,W5
012AE:  MOV     W5,W0
012B0:  MOV     #B5A,W4
012B2:  ADD     W0,W4,W5
012B4:  MOV     [W5],W4
012B6:  SUB     #B4,W4
012B8:  MOV     W4,[W5]
012BA:  MOV     [++W5],W4
012BC:  SUBB    W4,#0,W0
012BE:  MOV     W0,[W5+#0]
.................... 			if(TabZones[NumZone-1][2] > (SIZE_TABLE_X-MARGE))TabZones[NumZone-1][2] = 3000; else TabZones[NumZone-1][2] += (MARGE/2);	 
012C0:  MOV     1B64,W4
012C2:  SUB     W4,#1,W5
012C4:  SL      W5,#4,W5
012C6:  ADD     W5,#8,W5
012C8:  MOV     W5,W0
012CA:  MOV     #B5A,W4
012CC:  ADD     W0,W4,W0
012CE:  MOV     #A,W4
012D0:  MOV     [W0++],[W4++]
012D2:  MOV     [W0++],[W4++]
012D4:  CP      W6,#0
012D6:  BRA     LT,1302
012D8:  BRA     GT,12E0
012DA:  MOV     #A50,W4
012DC:  CP      W4,W5
012DE:  BRA     C,1302
012E0:  MOV     1B64,W4
012E2:  SUB     W4,#1,W5
012E4:  SL      W5,#4,W5
012E6:  ADD     W5,#8,W5
012E8:  MOV     W5,W0
012EA:  MOV     #B5A,W4
012EC:  ADD     W0,W4,W5
012EE:  MOV.B   #B8,W0L
012F0:  MOV.B   W0L,[W5]
012F2:  MOV.B   #B,W0L
012F4:  MOV.B   W0L,[W5+#1]
012F6:  MOV.B   #0,W0L
012F8:  MOV.B   W0L,[W5+#2]
012FA:  MOV.B   #0,W0L
012FC:  MOV.B   W0L,[W5+#3]
012FE:  GOTO    131C
01302:  MOV     1B64,W4
01304:  SUB     W4,#1,W5
01306:  SL      W5,#4,W5
01308:  ADD     W5,#8,W5
0130A:  MOV     W5,W0
0130C:  MOV     #B5A,W4
0130E:  ADD     W0,W4,W5
01310:  MOV     [W5],W4
01312:  ADD     #B4,W4
01314:  MOV     W4,[W5]
01316:  MOV     [++W5],W4
01318:  ADDC    W4,#0,W4
0131A:  MOV     W4,[W5]
.................... 			if(TabZones[NumZone-1][3] > (SIZE_TABLE_Y-MARGE))TabZones[NumZone-1][3] = 2000; else TabZones[NumZone-1][3] += (MARGE/2); 
0131C:  MOV     1B64,W4
0131E:  SUB     W4,#1,W5
01320:  SL      W5,#4,W5
01322:  ADD     W5,#C,W5
01324:  MOV     W5,W0
01326:  MOV     #B5A,W4
01328:  ADD     W0,W4,W0
0132A:  MOV     #A,W4
0132C:  MOV     [W0++],[W4++]
0132E:  MOV     [W0++],[W4++]
01330:  CP      W6,#0
01332:  BRA     LT,135E
01334:  BRA     GT,133C
01336:  MOV     #668,W4
01338:  CP      W4,W5
0133A:  BRA     C,135E
0133C:  MOV     1B64,W4
0133E:  SUB     W4,#1,W5
01340:  SL      W5,#4,W5
01342:  ADD     W5,#C,W5
01344:  MOV     W5,W0
01346:  MOV     #B5A,W4
01348:  ADD     W0,W4,W5
0134A:  MOV.B   #D0,W0L
0134C:  MOV.B   W0L,[W5]
0134E:  MOV.B   #7,W0L
01350:  MOV.B   W0L,[W5+#1]
01352:  MOV.B   #0,W0L
01354:  MOV.B   W0L,[W5+#2]
01356:  MOV.B   #0,W0L
01358:  MOV.B   W0L,[W5+#3]
0135A:  GOTO    1378
0135E:  MOV     1B64,W4
01360:  SUB     W4,#1,W5
01362:  SL      W5,#4,W5
01364:  ADD     W5,#C,W5
01366:  MOV     W5,W0
01368:  MOV     #B5A,W4
0136A:  ADD     W0,W4,W5
0136C:  MOV     [W5],W4
0136E:  ADD     #B4,W4
01370:  MOV     W4,[W5]
01372:  MOV     [++W5],W4
01374:  ADDC    W4,#0,W4
01376:  MOV     W4,[W5]
.................... 			 
.................... 			offset += 18;// offset de +24,afin de lire les objectifs suivant	 
01378:  MOV     1602,W4
0137A:  ADD     W4,#12,W4
0137C:  MOV     W4,1602
.................... 			NbreZone_check++; 
0137E:  INC.B   0880
.................... 		} 
01380:  GOTO    1388
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
01384:  MOV     #1,W4
01386:  MOV     W4,1B60
.................... 		} 
01388:  GOTO    1170
.................... 			 
.................... 	} 
0138C:  MOV     [--W15],W7
0138E:  MOV     [--W15],W6
01390:  MOV     [--W15],W5
01392:  RETURN  
.................... //	NbreZone = read_eeprom(512);	 
.................... } 
....................  
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour afficher le code de la carte afficheur 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 Affichage_Score(unsigned int8 adresse_driver, unsigned int8 Total) 
.................... { 
.................... 	i2c_start(); 
.................... 	if(i2c_write(adresse_driver) == 0)			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(Total); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 0; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "PC/___PC.h" 
.................... /* 
.................... * \file ___PC.h 
.................... * \brief Gre la communication PC (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_H 
.................... #define ___PC_H 
....................  
....................  
....................  
.................... // Config RS232 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=RS232) 
.................... // Config UART 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,stream=UARTi) 
....................  
.................... // Dfinit quand un tableau est  dcoder 
.................... int1 PCh_flagUARTReadyToDecode = 0; 
.................... // Watchdog pour viter un blocage UART 
.................... int1 PCh_flagUARTWatchdog = 0; 
....................  
....................  
.................... void __Init_UART(void);	// Initialise 
.................... void __UART_Decode(unsigned int32* _Tab);	// Dcode une trame 
.................... void __SendBackUART(void); // Renvoi la dernire commande envoye 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec); // Dcode un tableau 
.................... #include "PC/___PC.c" 
.................... /* 
.................... * \file ___PC.c 
.................... * \brief Gre la communication PC (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_C 
.................... #define ___PC_C 
....................  
.................... // Bits & define 
.................... 	// Contient la trame  dcoder 
.................... unsigned int8 TabToDecode[256]={0}; 
.................... unsigned int8 PosTabToDecode = 0; 
.................... unsigned int8 ToDoUART = 0; 
.................... 	// Contient les valeurs dcodes 
.................... unsigned int32 TabDecoded[256]={0}; 
.................... 	// Attend une rponse 
.................... int1 UARTWaitResp=0; 
.................... 	// Nombre de fois  renvoyer 
.................... unsigned int8 UARTToSendBack=0; 
.................... 	 
....................  
.................... /** 
.................... * \fn void __Init_UART(void) 
.................... * \brief Initie l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Init_UART(void) 
.................... { 
.................... 	// Rception 
.................... 	enable_interrupts(INT_RDA); 
*
00E48:  BSET.B  8D.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
00E4A:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void RDA_isr(void) 
.................... * \brief Interruption RDA, rcupre les caractres du RS232. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... */ 
.................... #INT_RDA 
.................... void RDA_isr(void) 
*
008E6:  PUSH    42
008E8:  PUSH    36
008EA:  PUSH    32
008EC:  MOV     W0,[W15++]
008EE:  MOV     #2,W0
008F0:  REPEAT  #C
008F2:  MOV     [W0++],[W15++]
.................... {	 
.................... 	// Checksum UART 
.................... 	static unsigned int8 HashR1, HashR2, HashC1, HashC2; 
.................... 	if(PCh_flagUARTReadyToDecode==0) 
008F4:  BTSC.B  1604.0
008F6:  BRA     A4C
.................... 	{ 
.................... 		// Active le watchdog UART 
.................... 		PCh_flagUARTWatchdog = 1; 
008F8:  BSET.B  1604.1
.................... 		// Traite la rception 
.................... 		while(kbhit(RS232)) 
008FA:  BTSS.B  20E.0
008FC:  BRA     A4C
.................... 		{ 
.................... 			// Rcupration donne 
.................... 			unsigned int8 Dataa = fgetc(RS232); 
008FE:  BTSS.B  20E.0
00900:  BRA     8FE
00902:  MOV     212,W0
00904:  MOV.B   W0L,1D4A
.................... 			 
.................... 			// Si c'est une rponse  un envoi, on remet  0 l'attente de rponse et la fausse erreur 
.................... 			if(UARTWaitResp && Dataa==ACK)  
00906:  BTSS.B  1604.2
00908:  BRA     918
0090A:  MOV     1D4A,W4
0090C:  CP.B    W4L,#6
0090E:  BRA     NZ,918
.................... 			{ 
.................... 				UARTWaitResp=0; 
00910:  BCLR.B  1604.2
.................... 				UARTToSendBack=0; 
00912:  CLR.B   1707
.................... 				 
.................... 			}	 
00914:  GOTO    A48
.................... 			// Si ce n'est pas OK, renvoie un certain nombre de fois 
.................... 			else if(UARTWaitResp && Dataa==NAK) 
00918:  BTSS.B  1604.2
0091A:  BRA     93C
0091C:  MOV     1D4A,W4
0091E:  CP.B    W4L,#15
00920:  BRA     NZ,93C
.................... 			{ 
.................... 				if(UARTToSendBack<UART_NBR_REP_NAK) {__SendBackUART();UARTToSendBack++;} 
00922:  MOV.B   1707,W0L
00924:  MOV     14C6,W4
00926:  CP.B    W4L,W0L
00928:  BRA     LEU,934
0092A:  CALL    5CA
0092E:  INC.B   1707
00930:  GOTO    938
.................... 				else {UARTWaitResp=0;UARTToSendBack=0;} 
00934:  BCLR.B  1604.2
00936:  CLR.B   1707
.................... 			} 
00938:  GOTO    A48
.................... 			// Rception 
.................... 			else 
.................... 			{	 
.................... 				// Dbut de transmission 
.................... 				if(Dataa == STX&&ToDoUART==0) 
0093C:  MOV     1D4A,W4
0093E:  CP.B    W4L,#2
00940:  BRA     NZ,956
00942:  CP0.B   1706
00944:  BRA     NZ,956
.................... 				{ 
.................... 					HashC1 = HashC2 = 0; 
00946:  CLR.B   1B0B
00948:  MOV.B   1B0B,W0L
0094A:  MOV.B   W0L,1B0A
.................... 					ToDoUART=1;  
0094C:  MOV.B   #1,W0L
0094E:  MOV.B   W0L,1706
.................... 					PosTabToDecode=0; 
00950:  CLR.B   1605
.................... 				} 
00952:  GOTO    A48
.................... 				// Fin de transmission 
.................... 				else if(Dataa == ETX&&ToDoUART==5)		 
00956:  MOV     1D4A,W4
00958:  CP.B    W4L,#3
0095A:  BRA     NZ,9DA
0095C:  MOV     1706,W4
0095E:  CP.B    W4L,#5
00960:  BRA     NZ,9DA
.................... 				{		 
.................... 					if(HashC1==ETX||HashC1==CR)HashC1++; // Pour viter de dtecter une fausse fin de tableau, le caractre ETC doit tre rserv. 
00962:  MOV     1B0A,W4
00964:  CP.B    W4L,#3
00966:  BRA     Z,96E
00968:  MOV     1B0A,W4
0096A:  CP.B    W4L,#D
0096C:  BRA     NZ,970
0096E:  INC.B   1B0A
.................... 					if(HashC2==ETX||HashC2==CR)HashC2++; // Pour viter de dtecter une fausse fin de tableau, le caractre ETC doit tre rserv. 
00970:  MOV     1B0A,W4
00972:  LSR     W4,#8,W4
00974:  CP.B    W4L,#3
00976:  BRA     Z,980
00978:  MOV     1B0A,W4
0097A:  LSR     W4,#8,W4
0097C:  CP.B    W4L,#D
0097E:  BRA     NZ,982
00980:  INC.B   1B0B
.................... 					// Si trame OK 
.................... 					if(HashC1==HashR1 && HashC2==HashR2) 
00982:  MOV.B   1B0A,W0L
00984:  CP.B    1B08
00986:  BRA     NZ,9C4
00988:  MOV.B   1B0B,W0L
0098A:  CP.B    1B09
0098C:  BRA     NZ,9C4
.................... 					{ 
.................... 						TabToDecode[PosTabToDecode] = ETX; 
0098E:  MOV     1604,W4
00990:  LSR     W4,#8,W4
00992:  MOV     #1606,W3
00994:  ADD     W4,W3,W5
00996:  MOV.B   #3,W0L
00998:  MOV.B   W0L,[W5]
.................... 						// Dcode le tableau 
.................... 						__CommDecode(TabToDecode,TabDecoded); 
0099A:  MOV     #1606,W4
0099C:  MOV     W4,1D4C
0099E:  MOV     #1708,W4
009A0:  MOV     W4,1D4E
009A2:  CALL    86A
.................... 						if(TabDecoded[0]==UART_ADDR) 
009A6:  MOV     1708,W0
009A8:  CP      14C8
009AA:  BRA     NZ,9C0
009AC:  MOV     170A,W0
009AE:  CP      14CA
009B0:  BRA     NZ,9C0
.................... 						{	 
.................... 							// Dit qu'on est prts  recevoir 
.................... 							PCh_flagUARTReadyToDecode=1; 
009B2:  BSET.B  1604.0
.................... 							// Renvoie un simple OK 
.................... 							fputc(ACK,RS232); 
009B4:  MOV.B   #6,W0L
009B6:  BTSC.B  20F.1
009B8:  BRA     9B6
009BA:  MOV.B   W0L,210
009BC:  CLR.B   211
.................... 							// Dit qu'on attend une rponse 
.................... 							UARTWaitResp=1; 
009BE:  BSET.B  1604.2
.................... 						}	 
.................... 					} 
009C0:  GOTO    9CE
.................... 					else fputc(NAK,RS232); // Erreur de rception, envoi un pas ok 
009C4:  MOV.B   #15,W0L
009C6:  BTSC.B  20F.1
009C8:  BRA     9C6
009CA:  MOV.B   W0L,210
009CC:  CLR.B   211
.................... 					ToDoUART = 0; 
009CE:  CLR.B   1706
.................... 					PosTabToDecode=0; 
009D0:  CLR.B   1605
.................... 					UARTToSendBack=0; 
009D2:  CLR.B   1707
.................... 					// Dsactive le watchdog UART 
.................... 					PCh_flagUARTWatchdog = 0; 
009D4:  BCLR.B  1604.1
.................... 				} 
009D6:  GOTO    A48
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==1)ToDoUART=2; 
009DA:  MOV     1706,W4
009DC:  CP.B    W4L,#1
009DE:  BRA     NZ,9E8
009E0:  MOV.B   #2,W0L
009E2:  MOV.B   W0L,1706
009E4:  GOTO    A48
.................... 				// Enregistre le premier Hash 
.................... 				else if(ToDoUART==2) 
009E8:  MOV     1706,W4
009EA:  CP.B    W4L,#2
009EC:  BRA     NZ,9FA
.................... 				{ 
.................... 					HashR1 = Dataa; 
009EE:  MOV.B   1D4A,W0L
009F0:  MOV.B   W0L,1B08
.................... 					ToDoUART=3;	 
009F2:  MOV.B   #3,W0L
009F4:  MOV.B   W0L,1706
.................... 				}	 
009F6:  GOTO    A48
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==3)ToDoUART=4; 
009FA:  MOV     1706,W4
009FC:  CP.B    W4L,#3
009FE:  BRA     NZ,A08
00A00:  MOV.B   #4,W0L
00A02:  MOV.B   W0L,1706
00A04:  GOTO    A48
.................... 				// Enregistre le second Hash 
.................... 				else if(ToDoUART==4) 
00A08:  MOV     1706,W4
00A0A:  CP.B    W4L,#4
00A0C:  BRA     NZ,A1A
.................... 				{ 
.................... 					HashR2 = Dataa; 
00A0E:  MOV.B   1D4A,W0L
00A10:  MOV.B   W0L,1B09
.................... 					ToDoUART=5; 
00A12:  MOV.B   #5,W0L
00A14:  MOV.B   W0L,1706
.................... 				} 
00A16:  GOTO    A48
.................... 				// Capture la trame 
.................... 				else if(ToDoUART == 5)  
00A1A:  MOV     1706,W4
00A1C:  CP.B    W4L,#5
00A1E:  BRA     NZ,A48
.................... 				{ 
.................... 					// Hash les valeurs reues 
.................... 					HashC1 += Dataa; 
00A20:  MOV.B   1B0A,W0L
00A22:  ADD.B   1D4A,W0L
00A24:  MOV.B   W0L,1B0A
.................... 					HashC2 = (HashC2+Dataa)*(PosTabToDecode+1);	 
00A26:  MOV.B   1B0B,W0L
00A28:  ADD.B   1D4A,W0L
00A2A:  MOV.B   W0L,A
00A2C:  MOV     1604,W4
00A2E:  LSR     W4,#8,W4
00A30:  ADD     W4,#1,W4
00A32:  MOV     W4,W0
00A34:  CLR.B   B
00A36:  MUL.UU  W5,W0,W0
00A38:  MOV.B   W0L,1B0B
.................... 					// Retire l'incrment ASCII et enregistre 
.................... 					TabToDecode[PosTabToDecode] = Dataa; 
00A3A:  MOV     1604,W4
00A3C:  LSR     W4,#8,W4
00A3E:  MOV     #1606,W3
00A40:  ADD     W4,W3,W5
00A42:  MOV     1D4A,W0
00A44:  MOV.B   W0L,[W5+#0]
.................... 					 
.................... 					PosTabToDecode++; 
00A46:  INC.B   1605
.................... 				} 
.................... 			}			 
00A48:  GOTO    8FA
.................... 		}	 
.................... 	}		 
.................... 	// Quitte l'interruption 
.................... 	return; 
00A4C:  BCLR.B  85.1
00A4E:  MOV     #1A,W0
00A50:  REPEAT  #C
00A52:  MOV     [--W15],[W0--]
00A54:  MOV     [--W15],W0
00A56:  POP     32
00A58:  POP     36
00A5A:  POP     42
00A5C:  RETFIE  
.................... } 
....................  
.................... /** 
.................... * \fn void __UART_Decode(char* Tab) 
.................... * \brief Dcode la trame de l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \param[in] (*)_Tab Tableau avec lequel travailler 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __UART_Decode(unsigned int32* _Tab) 
*
0947E:  MOV     W5,[W15++]
09480:  MOV     #C,W5
09482:  REPEAT  #7
09484:  MOV     [W5++],[W15++]
09486:  CLR     1B3C
09488:  CLR     1B40
0948A:  CLR     1B42
0948C:  CLR     1B44
.................... { 
.................... 	unsigned int16 index = 0; 
.................... 	unsigned int16 Xo,Yo = 0; 
.................... 	signed int16 phi = 0;	 
.................... 	static int16 memo; 
.................... 	static int16 Memorise; 
.................... 	unsigned int16 Adresse = 0; 
.................... 	// Regarde quoi faire 
.................... 	switch(*(_Tab+1)) // On saute la premire adresse mmoire qui contient l'adresse du driver 
0948E:  MOV     1B3A,W4
09490:  ADD     W4,#4,W4
09492:  MOV     W4,W0
09494:  MOV     W0,W5
09496:  MOV     #0,W3
09498:  MOV     [W5++],[W3++]
0949A:  MOV     [W5++],[W3++]
0949C:  CP0     W0
0949E:  BRA     NZ,94A4
094A0:  CP0     W1
094A2:  BRA     Z,9530
094A4:  CP      W0,#1
094A6:  BRA     NZ,94AC
094A8:  CP0     W1
094AA:  BRA     Z,953A
094AC:  CP      W0,#2
094AE:  BRA     NZ,94B4
094B0:  CP0     W1
094B2:  BRA     Z,9548
094B4:  CP      W0,#3
094B6:  BRA     NZ,94BC
094B8:  CP0     W1
094BA:  BRA     Z,954E
094BC:  CP      W0,#4
094BE:  BRA     NZ,94C4
094C0:  CP0     W1
094C2:  BRA     Z,9552
094C4:  CP      W0,#A
094C6:  BRA     NZ,94CC
094C8:  CP0     W1
094CA:  BRA     Z,9556
094CC:  CP      W0,#B
094CE:  BRA     NZ,94D4
094D0:  CP0     W1
094D2:  BRA     Z,9570
094D4:  CP      W0,#C
094D6:  BRA     NZ,94DC
094D8:  CP0     W1
094DA:  BRA     Z,9574
094DC:  CP      W0,#14
094DE:  BRA     NZ,94E4
094E0:  CP0     W1
094E2:  BRA     Z,95BE
094E4:  CP      W0,#15
094E6:  BRA     NZ,94EC
094E8:  CP0     W1
094EA:  BRA     Z,95F2
094EC:  CP      W0,#16
094EE:  BRA     NZ,94F4
094F0:  CP0     W1
094F2:  BRA     Z,9648
094F4:  CP      W0,#17
094F6:  BRA     NZ,94FC
094F8:  CP0     W1
094FA:  BRA     Z,965C
094FC:  CP      W0,#18
094FE:  BRA     NZ,9504
09500:  CP0     W1
09502:  BRA     Z,96A4
09504:  CP      W0,#19
09506:  BRA     NZ,950C
09508:  CP0     W1
0950A:  BRA     Z,976E
0950C:  CP      W0,#1E
0950E:  BRA     NZ,9514
09510:  CP0     W1
09512:  BRA     Z,977C
09514:  CP      W0,#1F
09516:  BRA     NZ,951C
09518:  CP0     W1
0951A:  BRA     Z,9780
0951C:  CP      W0,#13
0951E:  BRA     NZ,9524
09520:  CP0     W1
09522:  BRA     Z,9784
09524:  MOV     #32,W4
09526:  CP      W0,W4
09528:  BRA     NZ,952E
0952A:  CP0     W1
0952C:  BRA     Z,97DC
0952E:  BRA     97E0
.................... 	{ 
.................... 		// Test Comm - LED Blink 
.................... 		case 0 : 
.................... 			LED1=LED2=LED3=1; 
09530:  BSET.B  2D0.3
09532:  BSET.B  2D0.2
09534:  BSET.B  2D0.1
.................... 			break; 
09536:  GOTO    97FC
.................... 		// Demande si est connect	 
.................... 		case 1 : 
.................... 			fputc(0x31,RS232); 
0953A:  MOV.B   #31,W0L
0953C:  BTSC.B  20F.1
0953E:  BRA     953C
09540:  MOV.B   W0L,210
09542:  CLR.B   211
.................... 			break; 
09544:  GOTO    97FC
.................... 		// Reset la plaque 
.................... 		case 2 : 
.................... 			reset_cpu(); 
09548:  RESET   
.................... 			break; 
0954A:  GOTO    97FC
.................... 		// Demande si RoboteQ connect 
.................... 		case 3 : 
.................... 			// ? 
.................... 			break; 
0954E:  GOTO    97FC
.................... 		// Configuration du robot 
.................... 		case 4 :			 
.................... 			break; 
09552:  GOTO    97FC
.................... 		// Change d'objectif 
.................... 		case 10 : 
.................... 			flagMarche = (int1)(*(_Tab+2)); 
09556:  BCLR.B  C24.1
09558:  MOV     1B3A,W4
0955A:  ADD     W4,#8,W4
0955C:  MOV     W4,W0
0955E:  MOV.B   [W0],W4L
09560:  BCLR.B  0.0
09562:  BTSC.B  8.0
09564:  BSET.B  0.0
09566:  BTSS    W0.0
09568:  BRA     956C
0956A:  BSET.B  C24.1
.................... 			break; 
0956C:  GOTO    97FC
.................... 		//	Arrt d'urgence 
.................... 		case 11 : 
.................... 			 
.................... 			break; 
09570:  GOTO    97FC
.................... 		// Set la position de dpart 
.................... 		case 12 : 
.................... 			Xo = *(_Tab+2); 
09574:  MOV     1B3A,W4
09576:  ADD     W4,#8,W4
09578:  MOV     W4,W0
0957A:  MOV     [W0],[W15++]
0957C:  POP     1B3E
.................... 			Yo = *(_Tab+3); 
0957E:  MOV     1B3A,W4
09580:  ADD     W4,#C,W4
09582:  MOV     W4,W0
09584:  MOV     [W0],[W15++]
09586:  POP     1B40
.................... 			phi = *(_Tab+4); 
09588:  MOV     1B3A,W4
0958A:  ADD     W4,#10,W4
0958C:  MOV     W4,W0
0958E:  MOV     W0,W4
09590:  MOV     #0,W3
09592:  MOV     [W4++],[W3++]
09594:  MOV     [W4++],[W3++]
09596:  MOV     W0,1B42
.................... 			 
.................... 			write_eeprom(0xFF0,Xo); 
09598:  MOV     #FF0,W0
0959A:  MOV     #1B3E,W1
0959C:  MOV     #2,W2
0959E:  CALL    9000
.................... 			write_eeprom(0xFF2,Yo); 
095A2:  MOV     #FF2,W0
095A4:  MOV     #1B40,W1
095A6:  MOV     #2,W2
095A8:  CALL    9000
.................... 			write_eeprom(0xFF4,phi); 
095AC:  MOV     #FF4,W0
095AE:  MOV     #1B42,W1
095B0:  MOV     #2,W2
095B2:  CALL    9000
.................... 			 
.................... 			__Init_pos();	 
095B6:  CALL    13F8
.................... 			break; 
095BA:  GOTO    97FC
.................... 		 
.................... 		// Enregistre le nombre d'objectifs 
.................... 		case 20 : 
.................... 		memo = 0; 
095BE:  CLR     1B0C
.................... 		Memorise = 0; 
095C0:  CLR     1B0E
.................... 		nbre_obj = *(_Tab+2); 
095C2:  MOV     1B3A,W4
095C4:  ADD     W4,#8,W4
095C6:  MOV     W4,W0
095C8:  MOV     W0,[W15++]
095CA:  MOV.B   [W0],W0L
095CC:  MOV.B   W0L,881
095CE:  MOV     [--W15],W0
.................... 		write_eeprom(0xFFE, nbre_obj);//on sauvegarde les objectifs dans l'EEPROM 
095D0:  MOV.B   881,W0L
095D2:  MOV.B   W0L,W5L
095D4:  CLR.B   B
095D6:  MOV     #FFE,W0
095D8:  MOV     #A,W1
095DA:  MOV     #2,W2
095DC:  CALL    9000
.................... 		delay_ms(5); 
095E0:  MOV     #5,W0
095E2:  CALL    DE2
.................... 		__ReadObjectifs(); 
095E6:  CALL    105E
.................... 		__ReadZones_Interdites(); 
095EA:  CALL    1162
.................... 		 
.................... 			break; 
095EE:  GOTO    97FC
.................... 		// Sauvegarde un objectif en EEPROM 
.................... 		case 21 : 
.................... 		if(memo <= 0xF00) 
095F2:  MOV     1B0C,W4
095F4:  MOV     #F00,W3
095F6:  CP      W3,W4
095F8:  BRA     LT,9644
.................... 		{			 
.................... 			for(index = memo; index <  (memo + 28); index += 2) 
095FA:  PUSH    1B0C
095FC:  POP     1B3C
095FE:  MOV     1B0C,W4
09600:  ADD     W4,#1C,W4
09602:  MOV     W4,W0
09604:  MOV     1B3C,W4
09606:  CP      W4,W0
09608:  BRA     GE,9640
.................... 			{ 
.................... 				write_eeprom(index, *( _Tab +((index - memo)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0960A:  MOV     1B3C,W4
0960C:  MOV     1B0C,W3
0960E:  SUB     W4,W3,W5
09610:  MOV     W5,W4
09612:  MOV     #2,W3
09614:  REPEAT  #11
09616:  DIV.S   W4,W3
09618:  MOV     W0,W5
0961A:  MOV     W5,W4
0961C:  MUL.UU  W4,#4,W0
0961E:  MOV     1B3A,W4
09620:  ADD     W0,W4,W5
09622:  ADD     W5,#C,W5
09624:  MOV     W5,W0
09626:  MOV     #A,W4
09628:  MOV     [W0++],[W4++]
0962A:  MOV     [W0++],[W4++]
0962C:  MOV     1B3C,W0
0962E:  MOV     #A,W1
09630:  MOV     #2,W2
09632:  CALL    9000
09636:  MOV     1B3C,W4
09638:  ADD     W4,#2,W4
0963A:  MOV     W4,1B3C
0963C:  GOTO    95FE
.................... 				 
.................... 			} 
.................... 			memo = index; //offset afin d'aller crie plus loin dans l'eeprom 
09640:  PUSH    1B3C
09642:  POP     1B0C
.................... 		}	 
.................... 		 
.................... 		break; 
09644:  GOTO    97FC
.................... 		// Dfinit le prochain objectif  charger 
.................... 		case 22 : 
.................... 			NextObj=(unsigned int16)*(_Tab+2); 
09648:  MOV     1B3A,W4
0964A:  ADD     W4,#8,W4
0964C:  MOV     W4,W0
0964E:  MOV     W0,W4
09650:  MOV     #0,W3
09652:  MOV     [W4++],[W3++]
09654:  MOV     [W4++],[W3++]
09656:  MOV     W0,14D0
.................... 			break; 
09658:  GOTO    97FC
.................... 		// Set les PIDs de roboteQ 
.................... 		case 23 : 
.................... 			while(index<250)//reset le tableau 
0965C:  MOV     1B3C,W4
0965E:  MOV     #FA,W3
09660:  CP      W3,W4
09662:  BRA     LEU,9674
.................... 			{ 
.................... 				 TabSentRS232[index] = '\r'; 
09664:  MOV     #982,W4
09666:  MOV     1B3C,W3
09668:  ADD     W3,W4,W5
0966A:  MOV.B   #D,W0L
0966C:  MOV.B   W0L,[W5]
.................... 				 index++; 
0966E:  INC     1B3C
09670:  GOTO    965C
.................... 			} 
.................... 			index = 0; 
09674:  CLR     1B3C
.................... 			index = 0; 
09676:  CLR     1B3C
.................... 			while(index<10) // on recupere les donnees 
09678:  MOV     1B3C,W4
0967A:  CP      W4,#A
0967C:  BRA     C,968C
.................... 			{ 
.................... 				 __GetRoboteqPID(index); 
0967E:  MOV.B   1B3C,W0L
09680:  MOV.B   W0L,1B5E
09682:  CALL    903A
.................... 				 index++; 
09686:  INC     1B3C
09688:  GOTO    9678
0968C:  PUSH    42
0968E:  BCLR.B  81.7
09690:  SETM.B  42
09692:  BSET.B  81.7
.................... 			} 
.................... 			__SendBackUART(); // on envoie a la plaque 
09694:  CALL    5CA
09698:  BCLR.B  81.7
0969A:  POP     42
0969C:  BSET.B  81.7
.................... 			index = 0; 
0969E:  CLR     1B3C
.................... 			break; 
096A0:  GOTO    97FC
.................... 		case 24 : 
.................... 			__SetRoboteqPID(*(_Tab+2),*(_Tab+3),*(_Tab+4),*(_Tab+5),*(_Tab+6),*(_Tab+7),*(_Tab+8),*(_Tab+9),*(_Tab+10),*(_Tab+11)); 
096A4:  MOV     1B3A,W4
096A6:  ADD     W4,#8,W4
096A8:  MOV     W4,W0
096AA:  MOV     #A,W4
096AC:  MOV     [W0++],[W4++]
096AE:  MOV     [W0++],[W4++]
096B0:  MOV     1B3A,W4
096B2:  ADD     W4,#C,W4
096B4:  MOV     W4,W0
096B6:  MOV     #E,W4
096B8:  MOV     [W0++],[W4++]
096BA:  MOV     [W0++],[W4++]
096BC:  MOV     1B3A,W4
096BE:  ADD     W4,#10,W4
096C0:  MOV     W4,W0
096C2:  MOV     #12,W4
096C4:  MOV     [W0++],[W4++]
096C6:  MOV     [W0++],[W4++]
096C8:  MOV     1B3A,W4
096CA:  ADD     W4,#14,W4
096CC:  MOV     W4,W0
096CE:  MOV     #16,W4
096D0:  MOV     [W0++],[W4++]
096D2:  MOV     [W0++],[W4++]
096D4:  MOV     1B3A,W4
096D6:  ADD     W4,#18,W4
096D8:  MOV     W4,W0
096DA:  MOV     #1A,W4
096DC:  MOV     [W0++],[W4++]
096DE:  MOV     [W0++],[W4++]
096E0:  MOV     1B3A,W4
096E2:  ADD     W4,#1C,W4
096E4:  MOV     W4,W0
096E6:  MOV     #1B48,W4
096E8:  MOV     [W0++],[W4++]
096EA:  MOV     [W0++],[W4++]
096EC:  MOV     #20,W4
096EE:  MOV     1B3A,W3
096F0:  ADD     W3,W4,W0
096F2:  MOV     #1B4C,W4
096F4:  MOV     [W0++],[W4++]
096F6:  MOV     [W0++],[W4++]
096F8:  MOV     #24,W4
096FA:  MOV     1B3A,W3
096FC:  ADD     W3,W4,W0
096FE:  MOV     #1B50,W4
09700:  MOV     [W0++],[W4++]
09702:  MOV     [W0++],[W4++]
09704:  MOV     #28,W4
09706:  MOV     1B3A,W3
09708:  ADD     W3,W4,W0
0970A:  MOV     #1B54,W4
0970C:  MOV     [W0++],[W4++]
0970E:  MOV     [W0++],[W4++]
09710:  MOV     #2C,W4
09712:  MOV     1B3A,W3
09714:  ADD     W3,W4,W0
09716:  MOV     #1B58,W4
09718:  MOV     [W0++],[W4++]
0971A:  MOV     [W0++],[W4++]
0971C:  PUSH    1B86
0971E:  MOV.B   W5L,[W15-#2]
09720:  POP     1B86
09722:  PUSH    1B86
09724:  MOV.B   W7L,[W15-#1]
09726:  POP     1B86
09728:  PUSH    1B88
0972A:  MOV.B   W9L,[W15-#2]
0972C:  POP     1B88
0972E:  PUSH    1B88
09730:  MOV.B   W11L,[W15-#1]
09732:  POP     1B88
09734:  PUSH    1B8A
09736:  MOV.B   W13L,[W15-#2]
09738:  POP     1B8A
0973A:  MOV     W0,[W15++]
0973C:  MOV.B   1B48,W0L
0973E:  MOV.B   W0L,1B8B
09740:  MOV     [--W15],W0
09742:  MOV     W0,[W15++]
09744:  MOV.B   1B4C,W0L
09746:  MOV.B   W0L,1B8C
09748:  MOV     [--W15],W0
0974A:  MOV     W0,[W15++]
0974C:  MOV.B   1B50,W0L
0974E:  MOV.B   W0L,1B8D
09750:  MOV     [--W15],W0
09752:  MOV     W0,[W15++]
09754:  MOV.B   1B54,W0L
09756:  MOV.B   W0L,1B8E
09758:  MOV     [--W15],W0
0975A:  MOV     W0,[W15++]
0975C:  MOV.B   1B58,W0L
0975E:  MOV.B   W0L,1B8F
09760:  MOV     [--W15],W0
09762:  CALL    9236
.................... 			__reset_Roboteq(); 
09766:  CALL    9432
.................... 			break; 
0976A:  GOTO    97FC
.................... 		 
.................... 		//erase eeprom 
.................... 		case 25 : 
.................... 			__resetEEPROM(); 
0976E:  CALL    9456
.................... 			reset_cpu();     
09772:  RESET   
.................... 			break;		 
09774:  GOTO    97FC
.................... 		 
.................... 			break; 
09778:  GOTO    97FC
.................... 		// Ouvre ou ferme l'tau 
.................... 		case 30 : 
.................... 			break; 
0977C:  GOTO    97FC
.................... 		// Position hold ou release du servo 
.................... 		case 31 : 
.................... 			break;			 
09780:  GOTO    97FC
.................... 		case 19 : 
.................... 			for(Adresse = Memorise ; Adresse <= 16 + Memorise ; Adresse += 2) 
09784:  PUSH    1B0E
09786:  POP     1B44
09788:  MOV     #10,W0
0978A:  ADD     1B0E,W0
0978C:  MOV     1B44,W4
0978E:  CP      W4,W0
09790:  BRA     GT,97D4
.................... 			{ 
.................... 				write_eeprom(Adresse + 0xF2A , *( _Tab +((Adresse - Memorise)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
09792:  MOV     #F2A,W4
09794:  MOV     1B44,W3
09796:  ADD     W3,W4,W5
09798:  MOV     1B44,W4
0979A:  MOV     1B0E,W3
0979C:  SUB     W4,W3,W6
0979E:  MOV     W6,W4
097A0:  MOV     #2,W3
097A2:  REPEAT  #11
097A4:  DIV.S   W4,W3
097A6:  MOV     W0,W6
097A8:  MOV     W6,W4
097AA:  MUL.UU  W4,#4,W0
097AC:  MOV     1B3A,W4
097AE:  ADD     W0,W4,W6
097B0:  ADD     W6,#C,W6
097B2:  MOV     W6,W0
097B4:  MOV     #C,W4
097B6:  MOV     [W0++],[W4++]
097B8:  MOV     [W0++],[W4++]
097BA:  MOV     W5,W0
097BC:  MOV     #C,W1
097BE:  MOV     #2,W2
097C0:  CALL    9000
.................... 				delay_ms(5); 
097C4:  MOV     #5,W0
097C6:  CALL    DE2
097CA:  MOV     1B44,W4
097CC:  ADD     W4,#2,W4
097CE:  MOV     W4,1B44
097D0:  GOTO    9788
.................... 			} 
.................... 			Memorise = Adresse; //offset afin d'aler crie plus loin dans l'eeprom 
097D4:  PUSH    1B44
097D6:  POP     1B0E
.................... 		 
.................... 			break; 
097D8:  GOTO    97FC
.................... 		// Ne lit plus les objectifs en ROM avant une nouvelle criture	 
.................... 		case 50 :			 
.................... 			break;	 
097DC:  GOTO    97FC
.................... 			 
.................... 			// Avertit le PC d'une action inconnue 
.................... 		default : 
.................... 			fprintf(RS232,"Carte Principale : Commande Inconnue\r"); 
097E0:  MOV     #0,W1
097E2:  MOV     W1,W0
097E4:  CLR.B   1
097E6:  CALL    3C4
097EA:  INC     W1,W1
097EC:  BTSC.B  20F.1
097EE:  BRA     97EC
097F0:  MOV     W0,210
097F2:  MOV     #24,W0
097F4:  CPSGT   W1,W0
097F6:  BRA     97E2
.................... 			break; 
097F8:  GOTO    97FC
.................... 	} 
.................... 	 
.................... 	// Permet de recevoir  nouveau 
.................... 	PCh_flagUARTReadyToDecode = 0; 
097FC:  BCLR.B  1604.0
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
097FE:  MOV     #1A,W5
09800:  REPEAT  #7
09802:  MOV     [--W15],[W5--]
09804:  MOV     [--W15],W5
09806:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __SendBackUART(void) 
.................... * \brief Envoi des commandes en UART 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.01.2016 
.................... * 
.................... * \return Ne retourne rien 
....................  
.................... */ 
.................... void __SendBackUART(void) 
*
005CA:  MOV     W5,[W15++]
005CC:  MOV     #982,W4
005CE:  MOV     W4,1D4C
005D0:  CLR.B   1D4E
.................... { 
.................... 	char* ptrBuffy = TabSentRS232; 
.................... 	// Envoi commande 
.................... 	unsigned int8 ToEndSend=0; 
.................... 	while(*(ptrBuffy+ToEndSend)!='\r' && *(ptrBuffy+ToEndSend)!=ETX) // Attend de voir la fin de tableau 
005D2:  MOV     1D4E,W4
005D4:  CLR.B   9
005D6:  MOV     1D4C,W3
005D8:  ADD     W3,W4,W0
005DA:  MOV.B   [W0],W4L
005DC:  CP.B    W4L,#D
005DE:  BRA     Z,608
005E0:  MOV     1D4E,W4
005E2:  CLR.B   9
005E4:  MOV     1D4C,W3
005E6:  ADD     W3,W4,W0
005E8:  MOV.B   [W0],W4L
005EA:  CP.B    W4L,#3
005EC:  BRA     Z,608
.................... 	{ 
.................... 		fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi la commande 
005EE:  MOV     1D4E,W4
005F0:  CLR.B   9
005F2:  MOV     1D4C,W3
005F4:  ADD     W3,W4,W0
005F6:  MOV.B   [W0],W5L
005F8:  MOV.B   W5L,W0L
005FA:  BTSC.B  20F.1
005FC:  BRA     5FA
005FE:  MOV.B   W0L,210
00600:  CLR.B   211
.................... 		ToEndSend++; 
00602:  INC.B   1D4E
00604:  GOTO    5D2
.................... 	}	 
.................... 	fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi le caractre de fin de commande 
00608:  MOV     1D4E,W4
0060A:  CLR.B   9
0060C:  MOV     1D4C,W3
0060E:  ADD     W3,W4,W0
00610:  MOV.B   [W0],W5L
00612:  MOV.B   W5L,W0L
00614:  BTSC.B  20F.1
00616:  BRA     614
00618:  MOV.B   W0L,210
0061A:  CLR.B   211
.................... 	TabSentRS232[ToEndSend]=*(ptrBuffy+ToEndSend); 
0061C:  MOV     1D4E,W4
0061E:  CLR.B   9
00620:  MOV     #982,W3
00622:  ADD     W4,W3,W5
00624:  MOV     1D4E,W4
00626:  CLR.B   9
00628:  MOV     1D4C,W3
0062A:  ADD     W3,W4,W0
0062C:  MOV.B   [W0],[W5]
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
0062E:  MOV     [--W15],W5
00630:  RETURN  
.................... }	 
....................  
.................... // Dcode un tableau 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec) 
*
0086A:  MOV     W5,[W15++]
0086C:  MOV.B   #1,W0L
0086E:  MOV.B   W0L,1D50
00870:  CLR.B   1D51
00872:  CLR.B   1D52
.................... { 
.................... 	// Permet de se balader dans le tableau 
.................... 	unsigned int8 i=1,j=0,ki=0; 
.................... 	char TempTab[11]={0}; // Taille max d'un int32 + NULL 
00874:  CLR     1D54
00876:  CLR     1D56
00878:  CLR     1D58
0087A:  CLR     1D5A
0087C:  CLR     1D5C
0087E:  CLR.B   1D5E
.................... 	// On dcode tout 
.................... 	while(_TabToDec[i]!=ETX) 
00880:  MOV     1D50,W4
00882:  CLR.B   9
00884:  MOV     W4,W0
00886:  ADD     1D4C,W0
00888:  MOV.B   [W0],W4L
0088A:  CP.B    W4L,#3
0088C:  BRA     Z,8E2
.................... 	{ 
.................... 		// On cherche la fin d'un nombre 
.................... 		while(_TabToDec[i]!=SPACE) 
0088E:  MOV     1D50,W4
00890:  CLR.B   9
00892:  MOV     W4,W0
00894:  ADD     1D4C,W0
00896:  MOV.B   [W0],W4L
00898:  XOR.B   #20,W4L
0089A:  BRA     Z,8B6
.................... 		{ 
.................... 			TempTab[j]=(char)(_TabToDec[i]); 
0089C:  MOV     1D50,W4
0089E:  LSR     W4,#8,W4
008A0:  MOV     #1D54,W3
008A2:  ADD     W4,W3,W5
008A4:  MOV     1D50,W4
008A6:  CLR.B   9
008A8:  MOV     W4,W0
008AA:  ADD     1D4C,W0
008AC:  MOV.B   [W0],[W5]
.................... 			i++;j++; 
008AE:  INC.B   1D50
008B0:  INC.B   1D51
008B2:  GOTO    88E
.................... 		}	 
.................... 		TempTab[j]=NUL; 
008B6:  MOV     1D50,W4
008B8:  LSR     W4,#8,W4
008BA:  MOV     #1D54,W3
008BC:  ADD     W4,W3,W5
008BE:  CLR.B   [W5]
.................... 		i++;j=0; 
008C0:  INC.B   1D50
008C2:  CLR.B   1D51
.................... 		// On enregistre le nombres 
.................... 		_TabDec[ki]=(unsigned int32)atoi32(TempTab); 
008C4:  MOV.B   1D52,W0L
008C6:  CLR.B   1
008C8:  SL      W0,#2,W0
008CA:  MOV     1D4E,W4
008CC:  ADD     W0,W4,W5
008CE:  MOV     #1D54,W4
008D0:  MOV     W4,1D6C
008D2:  CALL    674
008D6:  MOV     #0,W4
008D8:  MOV     [W4++],[W5++]
008DA:  MOV     [W4++],[W5++]
.................... 		ki++; 
008DC:  INC.B   1D52
008DE:  GOTO    880
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
008E2:  MOV     [--W15],W5
008E4:  RETURN  
.................... }	 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner Aurlien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de grer et d'viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_h 
.................... #define ___Zones_interdites_h 
....................  
....................  
....................  
.................... enum{x1, y1, x4, y4}; 
.................... enum{X, Y}; 
....................  
.................... int x3 = 0; 
.................... int y3 = 3; 
.................... int x2 = 2; 
.................... int y2 = 1; 
....................  
.................... int32 start_point_X, start_point_Y, end_point_X, end_point_Y; 
.................... signed int32 spot_X, spot_Y;  
....................  
.................... //********************************************************************************************************************* 
.................... // checkPath 
.................... // 
.................... // Cette fonction permet de vrifier si le trajet du point A  B passe sur une zone interdite 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... int checkPath(); 
....................  
.................... void checkPtsRelai(); 
....................  
.................... //********************************************************************************************************************* 
.................... // findPath 
.................... // 
.................... // Cette fonction permet de trouver le trajet pour arriver  la destination en vitant les zones interdites 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findPath(); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dpart et d'arrive 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... int16 getDist(int16 x1, int16 y1, int16 x2, int16 y2); 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vrifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dpart et d'arrive 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(int16 pt1X, int16 pt1Y, int16 pt2X, int16 pt2Y); 
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dfinir la position relative d'un point par rapport  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dtermines en prolongeant les cts du rectangle, les zones sont numrotes 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnes du point, rx1 et ry1 sommet en haut  gauche, rx4 et ry4 sommet en bas  droite  
.................... // return      : entier de 0  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int16 px, int16 py, int16 rx1, int16 ry1, int16 rx4, int16 ry4); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour viter la zone interdite en dfinissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnes du point de dpart, xEnd et yEnd coordonnes du point de dpart, 
.................... // return      : entier de 0  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int16 xStart, int16 yStart, int16 xEnd, int16 yEnd, int i_zone); 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.c" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner Aurlien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de grer et d'viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_c 
.................... #define ___Zones_interdites_c 
....................  
.................... //********************************************************************************************************************* 
.................... // checkPath 
.................... // 
.................... // Cette fonction permet de vrifier si le trajet du point A  B passe sur une zone interdite 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... int checkPath() 
*
016D8:  MOV     W5,[W15++]
016DA:  MOV     W6,[W15++]
016DC:  MOV     W7,[W15++]
016DE:  MOV     W8,[W15++]
.................... { 
.................... 	path_found = 0; 
016E0:  CLR     A98
.................... 		 
....................     start_point_X = Pos_x; 
016E2:  MOV     15A0,W0
016E4:  CLR     W1
016E6:  BTSC    W0.F
016E8:  SETM    W1
016EA:  MOV     W0,1B18
016EC:  MOV     W1,1B1A
....................     start_point_Y = Pos_y; 
016EE:  MOV     15A2,W0
016F0:  CLR     W1
016F2:  BTSC    W0.F
016F4:  SETM    W1
016F6:  MOV     W0,1B1C
016F8:  MOV     W1,1B1E
....................  
....................     end_point_X = oXp; 
016FA:  MOV     14AE,W0
016FC:  CLR     W1
016FE:  BTSC    W0.F
01700:  SETM    W1
01702:  MOV     W0,1B20
01704:  MOV     W1,1B22
....................     end_point_Y = oYp; 
01706:  MOV     14B0,W0
01708:  CLR     W1
0170A:  BTSC    W0.F
0170C:  SETM    W1
0170E:  MOV     W0,1B24
01710:  MOV     W1,1B26
....................  
....................     checkIntersection(start_point_X, start_point_Y, end_point_X, end_point_Y); 
01712:  MOV     1B18,W5
01714:  MOV     1B1C,W6
01716:  MOV     1B20,W7
01718:  MOV     1B24,W8
0171A:  MOV     W5,1B4A
0171C:  MOV     W6,1B4C
0171E:  MOV     W7,1B4E
01720:  MOV     W8,1B50
01722:  CALL    1520
.................... 		 
.................... 	if (intersection_found > 0) 
01726:  MOV     A96,W4
01728:  CP      W4,#0
0172A:  BRA     LE,1732
.................... 	{ 
.................... 			path_found = 0; 
0172C:  CLR     A98
.................... 	} 
0172E:  GOTO    1736
.................... 	else 
.................... 	{ 
.................... 			path_found = 1; 
01732:  MOV     #1,W4
01734:  MOV     W4,A98
.................... 	} 
....................  
.................... 	return path_found; 
01736:  PUSH    A98
01738:  POP     0
0173A:  MOV     [--W15],W8
0173C:  MOV     [--W15],W7
0173E:  MOV     [--W15],W6
01740:  MOV     [--W15],W5
01742:  RETURN  
....................    
.................... } 
....................  
.................... void checkPtsRelai() 
*
06370:  MOV     W5,[W15++]
06372:  MOV     #C,W5
06374:  REPEAT  #3
06376:  MOV     [W5++],[W15++]
.................... { 
.................... 	//On vrifie si un des points relais se trouve trop prs du bord 
.................... 	path_tooclose = 0; 
06378:  CLR     A9E
....................     int i = 1; 
0637A:  MOV     #1,W4
0637C:  MOV     W4,1B40
....................     do 
....................     { 
....................     	if(PtsRelai[i_rel - i][X] < (MARGE/2) || PtsRelai[i_rel - i][Y] < (MARGE/2) || PtsRelai[i_rel - i][X] > (SIZE_TABLE_X-(MARGE/2)) || PtsRelai[i_rel - i][Y] > (SIZE_TABLE_Y-(MARGE/2))) 
0637E:  MOV     AA2,W4
06380:  MOV     1B40,W3
06382:  SUB     W4,W3,W5
06384:  MOV     W5,W4
06386:  MUL.UU  W4,#8,W0
06388:  MOV     W0,W5
0638A:  MOV     #ABA,W4
0638C:  ADD     W5,W4,W0
0638E:  MOV     #C,W4
06390:  MOV     [W0++],[W4++]
06392:  MOV     [W0++],[W4++]
06394:  CP      W7,#0
06396:  BRA     LT,640A
06398:  BRA     GT,63A0
0639A:  MOV     #B4,W4
0639C:  CP      W4,W6
0639E:  BRA     GTU,640A
063A0:  MOV     AA2,W4
063A2:  MOV     1B40,W3
063A4:  SUB     W4,W3,W6
063A6:  MOV     W6,W4
063A8:  MUL.UU  W4,#8,W6
063AA:  ADD     W6,#4,W6
063AC:  MOV     W6,W0
063AE:  MOV     #ABA,W4
063B0:  ADD     W0,W4,W0
063B2:  MOV     #C,W4
063B4:  MOV     [W0++],[W4++]
063B6:  MOV     [W0++],[W4++]
063B8:  CP      W7,#0
063BA:  BRA     LT,640A
063BC:  BRA     GT,63C4
063BE:  MOV     #B4,W4
063C0:  CP      W4,W6
063C2:  BRA     GTU,640A
063C4:  MOV     AA2,W4
063C6:  MOV     1B40,W3
063C8:  SUB     W4,W3,W6
063CA:  MOV     W6,W4
063CC:  MUL.UU  W4,#8,W6
063CE:  MOV     #ABA,W4
063D0:  ADD     W6,W4,W0
063D2:  MOV     #E,W4
063D4:  MOV     [W0++],[W4++]
063D6:  MOV     [W0++],[W4++]
063D8:  CP      W8,#0
063DA:  BRA     GT,640A
063DC:  BRA     LT,63E4
063DE:  MOV     #B04,W4
063E0:  CP      W4,W7
063E2:  BRA     NC,640A
063E4:  MOV     AA2,W4
063E6:  MOV     1B40,W3
063E8:  SUB     W4,W3,W7
063EA:  MOV     W7,W4
063EC:  MUL.UU  W4,#8,W0
063EE:  MOV     W0,W7
063F0:  ADD     W7,#4,W7
063F2:  MOV     W7,W0
063F4:  MOV     #ABA,W4
063F6:  ADD     W0,W4,W0
063F8:  MOV     #E,W4
063FA:  MOV     [W0++],[W4++]
063FC:  MOV     [W0++],[W4++]
063FE:  CP      W8,#0
06400:  BRA     LT,640E
06402:  BRA     GT,640A
06404:  MOV     #71C,W4
06406:  CP      W4,W7
06408:  BRA     C,640E
....................     	{ 
....................     		path_tooclose = 1; 
0640A:  MOV     #1,W4
0640C:  MOV     W4,A9E
....................     	} 
....................     	i++; 
0640E:  INC     1B40
....................  
....................     }while(!path_tooclose && i <= relay_point_number); 
06410:  CP0     A9E
06412:  BRA     NZ,641E
06414:  MOV     1B40,W0
06416:  MOV     AA0,W4
06418:  CP      W4,W0
0641A:  BRA     LT,641E
0641C:  BRA     637E
....................  
.................... 	if(path_impossible == 0) 
0641E:  CP0     A9A
06420:  BRA     NZ,646C
.................... 	{ 
.................... 	    //Alors on recalcul le trajet en passant par l'autre ct de la zone interdite 
.................... 	    if(path_tooclose) 
06422:  CP0     A9E
06424:  BRA     Z,6468
.................... 	    { 
.................... 	    	path_opposite = 1; 
06426:  MOV     #1,W4
06428:  MOV     W4,A9C
.................... 	    	i_rel = i_rel-relay_point_number; 
0642A:  MOV     AA2,W4
0642C:  MOV     AA0,W3
0642E:  SUB     W4,W3,W0
06430:  MOV     W0,AA2
.................... 	    	findRel(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y, 0); 
06432:  MOV     AA2,W4
06434:  SUB     W4,#1,W5
06436:  MOV     W5,W4
06438:  MUL.UU  W4,#8,W0
0643A:  MOV     W0,W5
0643C:  MOV     #ABA,W4
0643E:  ADD     W5,W4,W0
06440:  MOV     [W0],W6
06442:  MOV     AA2,W4
06444:  SUB     W4,#1,W7
06446:  MOV     W7,W4
06448:  MUL.UU  W4,#8,W0
0644A:  MOV     W0,W7
0644C:  ADD     W7,#4,W7
0644E:  MOV     W7,W0
06450:  MOV     #ABA,W4
06452:  ADD     W0,W4,W0
06454:  MOV     [W0],W7
06456:  MOV     1B20,W8
06458:  MOV     1B24,W9
0645A:  MOV     W6,1B4E
0645C:  MOV     W7,1B50
0645E:  MOV     W8,1B52
06460:  MOV     W9,1B54
06462:  CLR     1B56
06464:  CALL    2464
.................... 	    } 
.................... 	} 
06468:  GOTO    647A
.................... 	else 
.................... 	{ 
.................... 		//Alors on recalcul le trajet en passant par l'autre ct de la zone interdite 
.................... 	    if(path_tooclose) 
0646C:  CP0     A9E
0646E:  BRA     Z,6478
.................... 	    { 
.................... 	    	__Stop(); 
06470:  CALL    6334
.................... 	    } 
06474:  GOTO    647A
.................... 	    else 
.................... 	    { 
.................... 		    path_impossible = 0; 
06478:  CLR     A9A
.................... 		}  
.................... 		 
.................... 	}	     
0647A:  MOV     #12,W5
0647C:  REPEAT  #3
0647E:  MOV     [--W15],[W5--]
06480:  MOV     [--W15],W5
06482:  RETURN  
....................  
....................  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // findPath 
.................... // 
.................... // Cette fonction permet de trouver le trajet pour arriver  la destination en vitant les zones interdites 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findPath() 
06484:  MOV     W5,[W15++]
06486:  MOV     #C,W5
06488:  REPEAT  #3
0648A:  MOV     [W5++],[W15++]
0648C:  CLR     1B3A
0648E:  CLR     1B3C
.................... { 
....................    	int i = 0; 
....................    	int exit = 0; 
....................     //Si on intercepte encore une zone alors intersection_found sera > 0 
....................     while(intersection_found > 0 && !exit && !flag_end) 
06490:  MOV     A96,W4
06492:  CP      W4,#0
06494:  BRA     LE,652C
06496:  CP0     1B3C
06498:  BRA     NZ,652C
0649A:  BTSC.B  85B.0
0649C:  BRA     652C
....................     { 
....................         //Tant qu'on intercepte une zone depuis le point relai on continue  en chercher un autre 
....................         i++; 
0649E:  INC     1B3A
....................          
....................         if(path_impossible == 1) 
064A0:  MOV     A9A,W4
064A2:  CP      W4,#1
064A4:  BRA     NZ,64AE
....................         { 
....................        	 	path_opposite = 1; 
064A6:  MOV     #1,W4
064A8:  MOV     W4,A9C
....................        	} 
064AA:  GOTO    64B0
....................        	else 
....................        	{ 
.................... 	      	path_opposite = 0; 
064AE:  CLR     A9C
.................... 	    } 
.................... 	      								  
....................          
....................         //On trouve le premier point relai 
....................         findRel(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y, 0); 
064B0:  MOV     AA2,W4
064B2:  SUB     W4,#1,W5
064B4:  MOV     W5,W4
064B6:  MUL.UU  W4,#8,W0
064B8:  MOV     W0,W5
064BA:  MOV     #ABA,W4
064BC:  ADD     W5,W4,W0
064BE:  MOV     [W0],W6
064C0:  MOV     AA2,W4
064C2:  SUB     W4,#1,W7
064C4:  MOV     W7,W4
064C6:  MUL.UU  W4,#8,W0
064C8:  MOV     W0,W7
064CA:  ADD     W7,#4,W7
064CC:  MOV     W7,W0
064CE:  MOV     #ABA,W4
064D0:  ADD     W0,W4,W0
064D2:  MOV     [W0],W7
064D4:  MOV     1B20,W8
064D6:  MOV     1B24,W9
064D8:  MOV     W6,1B4E
064DA:  MOV     W7,1B50
064DC:  MOV     W8,1B52
064DE:  MOV     W9,1B54
064E0:  CLR     1B56
064E2:  CALL    2464
....................          
....................         //On vrifie si un des points relais se trouve trop prs du bord 
....................    		//Si c'est le cas alors on a recalcul le trajet en passant de l'autre ct de la zone 
....................         checkPtsRelai(); 
064E6:  CALL    6370
....................         if(path_impossible == 1) 
064EA:  MOV     A9A,W4
064EC:  CP      W4,#1
064EE:  BRA     NZ,64F4
....................         { 
.................... 	        exit = 1; 
064F0:  MOV     #1,W4
064F2:  MOV     W4,1B3C
.................... 	    }  
....................         //On vrifie si depuis le premier point relai on intercepte encore une zone 
....................         checkIntersection(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y); 
064F4:  MOV     AA2,W4
064F6:  SUB     W4,#1,W5
064F8:  MOV     W5,W4
064FA:  MUL.UU  W4,#8,W0
064FC:  MOV     W0,W5
064FE:  MOV     #ABA,W4
06500:  ADD     W5,W4,W0
06502:  MOV     [W0],W6
06504:  MOV     AA2,W4
06506:  SUB     W4,#1,W7
06508:  MOV     W7,W4
0650A:  MUL.UU  W4,#8,W0
0650C:  MOV     W0,W7
0650E:  ADD     W7,#4,W7
06510:  MOV     W7,W0
06512:  MOV     #ABA,W4
06514:  ADD     W0,W4,W0
06516:  MOV     [W0],W7
06518:  MOV     1B20,W8
0651A:  MOV     1B24,W9
0651C:  MOV     W6,1B4A
0651E:  MOV     W7,1B4C
06520:  MOV     W8,1B4E
06522:  MOV     W9,1B50
06524:  CALL    1520
06528:  GOTO    6490
....................     } 
0652C:  MOV     #12,W5
0652E:  REPEAT  #3
06530:  MOV     [--W15],[W5--]
06532:  MOV     [--W15],W5
06534:  RETURN  
....................      
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getDist 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dpart et d'arrive 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... int16 getDist(int16 x1, int16 y1, int16 x2, int16 y2) 
*
023E2:  MOV     W5,[W15++]
023E4:  MOV     W6,[W15++]
023E6:  MOV     W7,[W15++]
023E8:  MOV     W8,[W15++]
.................... { 
....................     return (sqrt(pow(fabs(x2-x1),2)) + (pow(fabs(y2-y1),2))); 
023EA:  MOV     1B76,W4
023EC:  MOV     1B72,W3
023EE:  SUB     W4,W3,W5
023F0:  MOV     W5,W0
023F2:  BTSS    W0.F
023F4:  BRA     23FA
023F6:  MOV     #0,W4
023F8:  SUB     W4,W5,W0
023FA:  CALL    17CC
023FE:  MOV     W0,W5
02400:  MOV     W1,W6
02402:  MOV     W5,1B8C
02404:  MOV     W6,1B8E
02406:  CLR     1B90
02408:  MOV     #4000,W4
0240A:  MOV     W4,1B92
0240C:  CALL    2182
02410:  MOV     W0,W5
02412:  MOV     W1,W6
02414:  MOV     W5,1B88
02416:  MOV     W6,1B8A
02418:  CALL    22D8
0241C:  MOV     W0,W5
0241E:  MOV     W1,W6
02420:  MOV     1B78,W4
02422:  MOV     1B74,W3
02424:  SUB     W4,W3,W7
02426:  MOV     W7,W0
02428:  BTSS    W0.F
0242A:  BRA     2430
0242C:  MOV     #0,W4
0242E:  SUB     W4,W7,W0
02430:  CALL    17CC
02434:  MOV     W0,W7
02436:  MOV     W1,W8
02438:  MOV     W7,1B8C
0243A:  MOV     W8,1B8E
0243C:  CLR     1B90
0243E:  MOV     #4000,W4
02440:  MOV     W4,1B92
02442:  CALL    2182
02446:  BCLR.B  43.0
02448:  MOV     W0,W2
0244A:  MOV     W1,W3
0244C:  MOV     W5,W0
0244E:  MOV     W6,W1
02450:  CALL    1A72
02454:  CALL    1948
02458:  MOV     W0,0
0245A:  MOV     [--W15],W8
0245C:  MOV     [--W15],W7
0245E:  MOV     [--W15],W6
02460:  MOV     [--W15],W5
02462:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vrifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dpart et d'arrive 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(int16 pt1X, int16 pt1Y, int16 pt2X, int16 pt2Y) 
*
01520:  MOV     W5,[W15++]
01522:  MOV     W6,[W15++]
01524:  MOV     W7,[W15++]
01526:  MOV     W8,[W15++]
01528:  CLR     1B52
.................... { 
.................... 	 
....................  
....................     int zoneToCheck = 0; 
....................  
....................     intersection_found = 0; 
0152A:  CLR     A96
....................  
....................     int j; 
....................     for ( j= 0; j < 10; j++) 
0152C:  CLR     1B54
0152E:  MOV     1B54,W4
01530:  CP      W4,#A
01532:  BRA     GE,1548
....................     { 
....................         TabIntersection[j] = 0; 
01534:  MOV     1B54,W4
01536:  MUL.UU  W4,#2,W0
01538:  MOV     #AA6,W4
0153A:  ADD     W0,W4,W5
0153C:  CLR.B   [W5]
0153E:  MOV.B   #0,W0L
01540:  MOV.B   W0L,[W5+#1]
01542:  INC     1B54
01544:  GOTO    152E
....................     } 
....................      
....................  
....................     signed int32 dX = pt2X-pt1X; 
....................     signed int32 dY = pt2Y-pt1Y; 
....................  
....................     int i = 0; 
01548:  MOV     1B4E,W4
0154A:  MOV     1B4A,W3
0154C:  SUB     W4,W3,W0
0154E:  CLR     W1
01550:  BTSC    W0.F
01552:  SETM    W1
01554:  MOV     W0,1B56
01556:  MOV     W1,1B58
01558:  MOV     1B50,W4
0155A:  MOV     1B4C,W3
0155C:  SUB     W4,W3,W0
0155E:  CLR     W1
01560:  BTSC    W0.F
01562:  SETM    W1
01564:  MOV     W0,1B5A
01566:  MOV     W1,1B5C
01568:  CLR     1B5E
....................  
....................     do 
....................     { 
....................         i++; 
0156A:  INC     1B5E
....................  
....................         //On calcule des points le long du trajet 
....................         spot_X = (dX*i)/100; 
0156C:  MOV     1B5E,W0
0156E:  CLR     W1
01570:  BTSC    W0.F
01572:  SETM    W1
01574:  PUSH    42
01576:  BCLR.B  81.7
01578:  SETM.B  42
0157A:  BSET.B  81.7
0157C:  MOV     W0,W2
0157E:  MOV     W1,W3
01580:  MOV     1B56,W0
01582:  MOV     1B58,W1
01584:  CALL    632
01588:  BCLR.B  81.7
0158A:  POP     42
0158C:  BSET.B  81.7
0158E:  MOV     W0,W5
01590:  MOV     W1,W6
01592:  BCLR.B  43.0
01594:  MOV     W5,W0
01596:  MOV     W6,W1
01598:  MOV     #64,W2
0159A:  MOV     #0,W3
0159C:  CALL    14A2
015A0:  MOV     W0,1B28
015A2:  MOV     W1,1B2A
....................         spot_Y = (dY*i)/100; 
015A4:  MOV     1B5E,W0
015A6:  CLR     W1
015A8:  BTSC    W0.F
015AA:  SETM    W1
015AC:  PUSH    42
015AE:  BCLR.B  81.7
015B0:  SETM.B  42
015B2:  BSET.B  81.7
015B4:  MOV     W0,W2
015B6:  MOV     W1,W3
015B8:  MOV     1B5A,W0
015BA:  MOV     1B5C,W1
015BC:  CALL    632
015C0:  BCLR.B  81.7
015C2:  POP     42
015C4:  BSET.B  81.7
015C6:  MOV     W0,W5
015C8:  MOV     W1,W6
015CA:  BCLR.B  43.0
015CC:  MOV     W5,W0
015CE:  MOV     W6,W1
015D0:  MOV     #64,W2
015D2:  MOV     #0,W3
015D4:  CALL    14A2
015D8:  MOV     W0,1B2C
015DA:  MOV     W1,1B2E
....................  
....................  
....................         //Pour chaque point du trajet on vrifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < 10; zoneToCheck++) 
015DC:  CLR     1B52
015DE:  MOV     1B52,W4
015E0:  CP      W4,#A
015E2:  BRA     GE,16B2
....................         { 
....................             //On vrifie si le point se trouve dans la zone interdite 
.................... 	        if ((spot_X+pt1X) > TabZones[zoneToCheck][0] && (spot_X+pt1X) < TabZones[zoneToCheck][2]) 
015E4:  MOV     1B4A,W0
015E6:  CLR     W1
015E8:  BTSC    W0.F
015EA:  SETM    W1
015EC:  MOV     1B28,W4
015EE:  ADD     W0,W4,W5
015F0:  MOV     1B2A,W4
015F2:  ADDC    W1,W4,W6
015F4:  MOV     1B52,W4
015F6:  MUL.UU  W4,#10,W0
015F8:  MOV     W0,W7
015FA:  MOV     #B5A,W4
015FC:  ADD     W7,W4,W0
015FE:  MOV     W0,W4
01600:  MOV     #0,W3
01602:  MOV     [W4++],[W3++]
01604:  MOV     [W4++],[W3++]
01606:  CP      W1,W6
01608:  BRA     GT,16AC
0160A:  BRA     LT,1610
0160C:  CP      W0,W5
0160E:  BRA     C,16AC
01610:  MOV     1B4A,W0
01612:  CLR     W1
01614:  BTSC    W0.F
01616:  SETM    W1
01618:  MOV     1B28,W4
0161A:  ADD     W0,W4,W5
0161C:  MOV     1B2A,W4
0161E:  ADDC    W1,W4,W6
01620:  MOV     1B52,W4
01622:  MUL.UU  W4,#10,W8
01624:  ADD     W8,#8,W8
01626:  MOV     W8,W0
01628:  MOV     #B5A,W4
0162A:  ADD     W0,W4,W0
0162C:  MOV     W0,W4
0162E:  MOV     #0,W3
01630:  MOV     [W4++],[W3++]
01632:  MOV     [W4++],[W3++]
01634:  CP      W6,W1
01636:  BRA     GT,16AC
01638:  BRA     LT,163E
0163A:  CP      W5,W0
0163C:  BRA     C,16AC
.................... 	        { 
.................... 		        if ((spot_Y+pt1Y) > TabZones[zoneToCheck][1] && (spot_Y+pt1Y) < TabZones[zoneToCheck][3]) 
0163E:  MOV     1B4C,W0
01640:  CLR     W1
01642:  BTSC    W0.F
01644:  SETM    W1
01646:  MOV     1B2C,W4
01648:  ADD     W0,W4,W5
0164A:  MOV     1B2E,W4
0164C:  ADDC    W1,W4,W6
0164E:  MOV     1B52,W4
01650:  MUL.UU  W4,#10,W0
01652:  MOV     W0,W7
01654:  ADD     W7,#4,W7
01656:  MOV     W7,W0
01658:  MOV     #B5A,W4
0165A:  ADD     W0,W4,W0
0165C:  MOV     W0,W4
0165E:  MOV     #0,W3
01660:  MOV     [W4++],[W3++]
01662:  MOV     [W4++],[W3++]
01664:  CP      W1,W6
01666:  BRA     GT,16AC
01668:  BRA     LT,166E
0166A:  CP      W0,W5
0166C:  BRA     C,16AC
0166E:  MOV     1B4C,W0
01670:  CLR     W1
01672:  BTSC    W0.F
01674:  SETM    W1
01676:  MOV     1B2C,W4
01678:  ADD     W0,W4,W5
0167A:  MOV     1B2E,W4
0167C:  ADDC    W1,W4,W6
0167E:  MOV     1B52,W4
01680:  MUL.UU  W4,#10,W0
01682:  MOV     W0,W7
01684:  ADD     W7,#C,W7
01686:  MOV     W7,W0
01688:  MOV     #B5A,W4
0168A:  ADD     W0,W4,W0
0168C:  MOV     W0,W4
0168E:  MOV     #0,W3
01690:  MOV     [W4++],[W3++]
01692:  MOV     [W4++],[W3++]
01694:  CP      W6,W1
01696:  BRA     GT,16AC
01698:  BRA     LT,169E
0169A:  CP      W5,W0
0169C:  BRA     C,16AC
.................... 		        { 
.................... 			        
....................                     TabIntersection[intersection_found] = zoneToCheck; 
0169E:  MOV     A96,W4
016A0:  MUL.UU  W4,#2,W0
016A2:  MOV     #AA6,W4
016A4:  ADD     W0,W4,W5
016A6:  MOV     1B52,W4
016A8:  MOV     W4,[W5+#0]
....................                     intersection_found++; 
016AA:  INC     0A96
.................... 			 
.................... 		        } 
.................... 			 
.................... 			 
.................... 	        } 
016AC:  INC     1B52
016AE:  GOTO    15DE
....................         } 
.................... 	 
....................     }while (i < 100 && intersection_found == 0); 
016B2:  MOV     1B5E,W4
016B4:  MOV     #64,W3
016B6:  CP      W3,W4
016B8:  BRA     LE,16BE
016BA:  CP0     A96
016BC:  BRA     Z,156A
....................  
....................     if(intersection_found > 0) 
016BE:  MOV     A96,W4
016C0:  CP      W4,#0
016C2:  BRA     LE,16CA
....................     { 
....................     	path_found = 0; 
016C4:  CLR     A98
....................     } 
016C6:  GOTO    16CE
....................     else 
....................     { 
....................     	path_found = 1; 
016CA:  MOV     #1,W4
016CC:  MOV     W4,A98
....................     } 
016CE:  MOV     [--W15],W8
016D0:  MOV     [--W15],W7
016D2:  MOV     [--W15],W6
016D4:  MOV     [--W15],W5
016D6:  RETURN  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dfinir la position relative d'un point par rapport  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dtermines en prolongeant les cts du rectangle, les zones sont numrotes 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnes du point, rx1 et ry1 sommet en haut  gauche, rx4 et ry4 sommet en bas  droite  
.................... // return      : entier de 0  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int16 px, int16 py, int16 rx1, int16 ry1, int16 rx4, int16 ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
*
01744:  MOV     1B7A,W0
01746:  MOV     1B72,W4
01748:  CP      W4,W0
0174A:  BRA     LE,1774
....................     { 
....................         if (py > ry4) 
0174C:  MOV     1B7C,W0
0174E:  MOV     1B74,W4
01750:  CP      W4,W0
01752:  BRA     LE,175C
....................         { 
....................             pos = 4; //Le point se trouve en bas  droite de la zone 
01754:  MOV     #4,W4
01756:  MOV     W4,1B7E
....................         } 
01758:  GOTO    1770
....................         else if (py > ry1) 
0175C:  MOV     1B78,W0
0175E:  MOV     1B74,W4
01760:  CP      W4,W0
01762:  BRA     LE,176C
....................         { 
....................             pos = 3; //Le point se trouve  droite de la zone 
01764:  MOV     #3,W4
01766:  MOV     W4,1B7E
....................         } 
01768:  GOTO    1770
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut  droite de la zone 
0176C:  MOV     #2,W4
0176E:  MOV     W4,1B7E
....................         } 
....................     } 
01770:  GOTO    17C6
....................     else if (px > rx1) 
01774:  MOV     1B76,W0
01776:  MOV     1B72,W4
01778:  CP      W4,W0
0177A:  BRA     LE,17A4
....................     { 
....................         if (py > ry4) 
0177C:  MOV     1B7C,W0
0177E:  MOV     1B74,W4
01780:  CP      W4,W0
01782:  BRA     LE,178C
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
01784:  MOV     #5,W4
01786:  MOV     W4,1B7E
....................         } 
01788:  GOTO    17A0
....................         else if (py > ry1) 
0178C:  MOV     1B78,W0
0178E:  MOV     1B74,W4
01790:  CP      W4,W0
01792:  BRA     LE,179C
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
01794:  MOV     #8,W4
01796:  MOV     W4,1B7E
....................         } 
01798:  GOTO    17A0
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
0179C:  MOV     #1,W4
0179E:  MOV     W4,1B7E
....................         } 
....................     } 
017A0:  GOTO    17C6
....................     else 
....................     { 
....................         if (py > ry4) 
017A4:  MOV     1B7C,W0
017A6:  MOV     1B74,W4
017A8:  CP      W4,W0
017AA:  BRA     LE,17B4
....................         { 
....................             pos = 6; //Le point se trouve en bas  gauche de la zone 
017AC:  MOV     #6,W4
017AE:  MOV     W4,1B7E
....................         } 
017B0:  GOTO    17C6
....................         else if (py > ry1) 
017B4:  MOV     1B78,W0
017B6:  MOV     1B74,W4
017B8:  CP      W4,W0
017BA:  BRA     LE,17C4
....................         { 
....................             pos = 7; //Le point se trouve  gauche de la zone 
017BC:  MOV     #7,W4
017BE:  MOV     W4,1B7E
....................         } 
017C0:  GOTO    17C6
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut  gauche de la zone 
017C4:  CLR     1B7E
....................         } 
....................     } 
....................  
....................     return pos; 
017C6:  PUSH    1B7E
017C8:  POP     0
017CA:  RETURN  
....................          
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour viter la zone interdite en dfinissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : Aurlien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnes du point de dpart, xEnd et yEnd coordonnes du point de dpart, 
.................... // return      : entier de 0  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int16 xStart, int16 yStart, int16 xEnd, int16 yEnd, int i_zone) 
*
02464:  MOV     W5,[W15++]
02466:  MOV     #C,W5
02468:  REPEAT  #4
0246A:  MOV     [W5++],[W15++]
0246C:  MOV     1B56,W4
0246E:  MUL.UU  W4,#2,W0
02470:  MOV     #AA6,W4
02472:  ADD     W0,W4,W0
02474:  MOV     [W0],W5
02476:  MOV     W5,W4
02478:  MUL.UU  W4,#10,W0
0247A:  MOV     W0,W5
0247C:  MOV     #B5A,W4
0247E:  ADD     W5,W4,W0
02480:  MOV     [W0],W6
02482:  MOV     1B56,W4
02484:  MUL.UU  W4,#2,W0
02486:  MOV     #AA6,W4
02488:  ADD     W0,W4,W0
0248A:  MOV     [W0],W7
0248C:  MOV     W7,W4
0248E:  MUL.UU  W4,#10,W0
02490:  MOV     W0,W7
02492:  ADD     W7,#4,W7
02494:  MOV     W7,W0
02496:  MOV     #B5A,W4
02498:  ADD     W0,W4,W0
0249A:  MOV     [W0],W7
0249C:  MOV     1B56,W4
0249E:  MUL.UU  W4,#2,W0
024A0:  MOV     #AA6,W4
024A2:  ADD     W0,W4,W0
024A4:  MOV     [W0],W8
024A6:  MOV     W8,W4
024A8:  MUL.UU  W4,#10,W8
024AA:  ADD     W8,#8,W8
024AC:  MOV     W8,W0
024AE:  MOV     #B5A,W4
024B0:  ADD     W0,W4,W0
024B2:  MOV     [W0],W8
024B4:  MOV     1B56,W4
024B6:  MUL.UU  W4,#2,W0
024B8:  MOV     #AA6,W4
024BA:  ADD     W0,W4,W0
024BC:  MOV     [W0],W9
024BE:  MOV     W9,W4
024C0:  MUL.UU  W4,#10,W0
024C2:  MOV     W0,W9
024C4:  ADD     W9,#C,W9
024C6:  MOV     W9,W0
024C8:  MOV     #B5A,W4
024CA:  ADD     W0,W4,W0
024CC:  MOV     [W0],W9
024CE:  PUSH    1B4E
024D0:  POP     1B72
024D2:  PUSH    1B50
024D4:  POP     1B74
024D6:  MOV     W6,1B76
024D8:  MOV     W7,1B78
024DA:  MOV     W8,1B7A
024DC:  MOV     W9,1B7C
024DE:  CALL    1744
024E2:  MOV     W0,1B58
024E4:  MOV     1B56,W4
024E6:  MUL.UU  W4,#2,W0
024E8:  MOV     #AA6,W4
024EA:  ADD     W0,W4,W0
024EC:  MOV     [W0],W6
024EE:  MOV     W6,W4
024F0:  MUL.UU  W4,#10,W6
024F2:  MOV     #B5A,W4
024F4:  ADD     W6,W4,W0
024F6:  MOV     [W0],W7
024F8:  MOV     1B56,W4
024FA:  MUL.UU  W4,#2,W0
024FC:  MOV     #AA6,W4
024FE:  ADD     W0,W4,W0
02500:  MOV     [W0],W8
02502:  MOV     W8,W4
02504:  MUL.UU  W4,#10,W8
02506:  ADD     W8,#4,W8
02508:  MOV     W8,W0
0250A:  MOV     #B5A,W4
0250C:  ADD     W0,W4,W0
0250E:  MOV     [W0],W8
02510:  MOV     1B56,W4
02512:  MUL.UU  W4,#2,W0
02514:  MOV     #AA6,W4
02516:  ADD     W0,W4,W0
02518:  MOV     [W0],W9
0251A:  MOV     W9,W4
0251C:  MUL.UU  W4,#10,W0
0251E:  MOV     W0,W9
02520:  ADD     W9,#8,W9
02522:  MOV     W9,W0
02524:  MOV     #B5A,W4
02526:  ADD     W0,W4,W0
02528:  MOV     [W0],W9
0252A:  MOV     1B56,W4
0252C:  MUL.UU  W4,#2,W0
0252E:  MOV     #AA6,W4
02530:  ADD     W0,W4,W0
02532:  MOV     [W0],W10
02534:  MOV     W10,W4
02536:  MUL.UU  W4,#10,W10
02538:  ADD     W10,#C,W10
0253A:  MOV     W10,W0
0253C:  MOV     #B5A,W4
0253E:  ADD     W0,W4,W0
02540:  MOV     [W0],W10
02542:  PUSH    1B52
02544:  POP     1B72
02546:  PUSH    1B54
02548:  POP     1B74
0254A:  MOV     W7,1B76
0254C:  MOV     W8,1B78
0254E:  MOV     W9,1B7A
02550:  MOV     W10,1B7C
02552:  CALL    1744
02556:  MOV     W0,1B5A
.................... { 
.................... 	//On rcupre la position des deux points par rapport  la zone 
....................     int posStart = getPos(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................     int posEnd = getPos(xEnd, yEnd, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................  
....................     relay_point_number = 0; 
02558:  CLR     AA0
....................  
....................  
....................  
....................     if(posStart == 8 || posEnd == 8) 
0255A:  MOV     1B58,W4
0255C:  CP      W4,#8
0255E:  BRA     Z,2566
02560:  MOV     1B5A,W4
02562:  CP      W4,#8
02564:  BRA     NZ,256C
....................     { 
....................     	path_found = 0; 
02566:  CLR     A98
....................     	//path_impossible = 1; 
....................     }	 
02568:  GOTO    632A
....................     else 
....................     { 
.................... 	    switch (posStart) 
0256C:  MOV     1B58,W0
0256E:  XOR     #0,W0
02570:  BRA     Z,2594
02572:  XOR     #1,W0
02574:  BRA     Z,2BFA
02576:  XOR     #3,W0
02578:  BRA     Z,357E
0257A:  XOR     #1,W0
0257C:  BRA     Z,3AE0
0257E:  XOR     #7,W0
02580:  BRA     Z,445C
02582:  XOR     #1,W0
02584:  BRA     Z,4A5C
02586:  XOR     #3,W0
02588:  BRA     Z,53D8
0258A:  XOR     #1,W0
0258C:  BRA     Z,5994
0258E:  XOR     #F,W0
02590:  BRA     Z,6318
02592:  BRA     631E
.................... 	    { 
.................... 	        case 0: 
....................  
.................... 	        	if(path_opposite) 
02594:  CP0     A9C
02596:  BRA     Z,28F6
.................... 			    { 
.................... 			    	if (posEnd == 3) 
02598:  MOV     1B5A,W4
0259A:  CP      W4,#3
0259C:  BRA     NZ,2656
.................... 		            { 
....................  
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0259E:  MOV     AA2,W4
025A0:  MUL.UU  W4,#8,W0
025A2:  MOV     W0,W5
025A4:  MOV     #ABA,W4
025A6:  ADD     W5,W4,W6
025A8:  MOV     1B56,W4
025AA:  MUL.UU  W4,#2,W0
025AC:  MOV     #AA6,W4
025AE:  ADD     W0,W4,W0
025B0:  MOV     [W0],W7
025B2:  MOV     W7,W4
025B4:  MUL.UU  W4,#10,W0
025B6:  MOV     W0,W7
025B8:  MOV     1B10,W4
025BA:  MUL.UU  W4,#4,W0
025BC:  ADD     W0,W7,W0
025BE:  MOV     #B5A,W4
025C0:  ADD     W0,W4,W0
025C2:  MOV     [W0++],[W6++]
025C4:  MOV     [W0++],[W6++]
025C6:  MOV     AA2,W4
025C8:  MUL.UU  W4,#8,W0
025CA:  MOV     W0,W5
025CC:  ADD     W5,#4,W5
025CE:  MOV     W5,W0
025D0:  MOV     #ABA,W4
025D2:  ADD     W0,W4,W5
025D4:  MOV     1B56,W4
025D6:  MUL.UU  W4,#2,W0
025D8:  MOV     #AA6,W4
025DA:  ADD     W0,W4,W0
025DC:  MOV     [W0],W6
025DE:  MOV     W6,W4
025E0:  MUL.UU  W4,#10,W6
025E2:  MOV     1B12,W4
025E4:  MUL.UU  W4,#4,W0
025E6:  ADD     W0,W6,W0
025E8:  MOV     #B5A,W4
025EA:  ADD     W0,W4,W0
025EC:  MOV     [W0++],[W5++]
025EE:  MOV     [W0++],[W5++]
.................... 	                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
025F0:  MOV     AA2,W4
025F2:  ADD     W4,#1,W4
025F4:  MOV     W4,W5
025F6:  MOV     W5,W4
025F8:  MUL.UU  W4,#8,W0
025FA:  MOV     W0,W5
025FC:  MOV     #ABA,W4
025FE:  ADD     W5,W4,W6
02600:  MOV     1B56,W4
02602:  MUL.UU  W4,#2,W0
02604:  MOV     #AA6,W4
02606:  ADD     W0,W4,W0
02608:  MOV     [W0],W7
0260A:  MOV     W7,W4
0260C:  MUL.UU  W4,#10,W0
0260E:  MOV     W0,W7
02610:  ADD     W7,#8,W7
02612:  MOV     W7,W0
02614:  MOV     #B5A,W4
02616:  ADD     W0,W4,W0
02618:  MOV     [W0++],[W6++]
0261A:  MOV     [W0++],[W6++]
0261C:  MOV     AA2,W4
0261E:  ADD     W4,#1,W4
02620:  MOV     W4,W5
02622:  MOV     W5,W4
02624:  MUL.UU  W4,#8,W0
02626:  MOV     W0,W5
02628:  ADD     W5,#4,W5
0262A:  MOV     W5,W0
0262C:  MOV     #ABA,W4
0262E:  ADD     W0,W4,W5
02630:  MOV     1B56,W4
02632:  MUL.UU  W4,#2,W0
02634:  MOV     #AA6,W4
02636:  ADD     W0,W4,W0
02638:  MOV     [W0],W6
0263A:  MOV     W6,W4
0263C:  MUL.UU  W4,#10,W6
0263E:  ADD     W6,#C,W6
02640:  MOV     W6,W0
02642:  MOV     #B5A,W4
02644:  ADD     W0,W4,W0
02646:  MOV     [W0++],[W5++]
02648:  MOV     [W0++],[W5++]
.................... 	                    relay_point_number = 2; 
0264A:  MOV     #2,W4
0264C:  MOV     W4,AA0
.................... 		                path_found = true; 
0264E:  MOV     #1,W4
02650:  MOV     W4,A98
.................... 		            } 
02652:  GOTO    28F2
.................... 		            else if (posEnd == 4) 
02656:  MOV     1B5A,W4
02658:  CP      W4,#4
0265A:  BRA     NZ,2838
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
0265C:  MOV     1B56,W4
0265E:  MUL.UU  W4,#2,W0
02660:  MOV     #AA6,W4
02662:  ADD     W0,W4,W0
02664:  MOV     [W0],W5
02666:  MOV     W5,W4
02668:  MUL.UU  W4,#10,W0
0266A:  MOV     W0,W5
0266C:  MOV     1B10,W4
0266E:  MUL.UU  W4,#4,W0
02670:  ADD     W0,W5,W0
02672:  MOV     #B5A,W4
02674:  ADD     W0,W4,W0
02676:  MOV     [W0],W5
02678:  MOV     1B56,W4
0267A:  MUL.UU  W4,#2,W0
0267C:  MOV     #AA6,W4
0267E:  ADD     W0,W4,W0
02680:  MOV     [W0],W6
02682:  MOV     W6,W4
02684:  MUL.UU  W4,#10,W6
02686:  MOV     1B12,W4
02688:  MUL.UU  W4,#4,W0
0268A:  ADD     W0,W6,W0
0268C:  MOV     #B5A,W4
0268E:  ADD     W0,W4,W0
02690:  MOV     [W0],W6
02692:  PUSH    1B4E
02694:  POP     1B72
02696:  PUSH    1B50
02698:  POP     1B74
0269A:  MOV     W5,1B76
0269C:  MOV     W6,1B78
0269E:  CALL    23E2
026A2:  MOV     W0,W5
026A4:  MOV     1B56,W4
026A6:  MUL.UU  W4,#2,W0
026A8:  MOV     #AA6,W4
026AA:  ADD     W0,W4,W0
026AC:  MOV     [W0],W6
026AE:  MOV     W6,W4
026B0:  MUL.UU  W4,#10,W6
026B2:  MOV     1B10,W4
026B4:  MUL.UU  W4,#4,W0
026B6:  ADD     W0,W6,W0
026B8:  MOV     #B5A,W4
026BA:  ADD     W0,W4,W0
026BC:  MOV     [W0],W6
026BE:  MOV     1B56,W4
026C0:  MUL.UU  W4,#2,W0
026C2:  MOV     #AA6,W4
026C4:  ADD     W0,W4,W0
026C6:  MOV     [W0],W7
026C8:  MOV     W7,W4
026CA:  MUL.UU  W4,#10,W0
026CC:  MOV     W0,W7
026CE:  MOV     1B12,W4
026D0:  MUL.UU  W4,#4,W0
026D2:  ADD     W0,W7,W0
026D4:  MOV     #B5A,W4
026D6:  ADD     W0,W4,W0
026D8:  MOV     [W0],W7
026DA:  MOV     W6,1B72
026DC:  MOV     W7,1B74
026DE:  PUSH    1B52
026E0:  POP     1B76
026E2:  PUSH    1B54
026E4:  POP     1B78
026E6:  CALL    23E2
026EA:  ADD     W0,W5,W5
026EC:  MOV     1B56,W4
026EE:  MUL.UU  W4,#2,W0
026F0:  MOV     #AA6,W4
026F2:  ADD     W0,W4,W0
026F4:  MOV     [W0],W6
026F6:  MOV     W6,W4
026F8:  MUL.UU  W4,#10,W6
026FA:  MOV     1B14,W4
026FC:  MUL.UU  W4,#4,W0
026FE:  ADD     W0,W6,W0
02700:  MOV     #B5A,W4
02702:  ADD     W0,W4,W0
02704:  MOV     [W0],W6
02706:  MOV     1B56,W4
02708:  MUL.UU  W4,#2,W0
0270A:  MOV     #AA6,W4
0270C:  ADD     W0,W4,W0
0270E:  MOV     [W0],W7
02710:  MOV     W7,W4
02712:  MUL.UU  W4,#10,W0
02714:  MOV     W0,W7
02716:  MOV     1B16,W4
02718:  MUL.UU  W4,#4,W0
0271A:  ADD     W0,W7,W0
0271C:  MOV     #B5A,W4
0271E:  ADD     W0,W4,W0
02720:  MOV     [W0],W7
02722:  PUSH    1B4E
02724:  POP     1B72
02726:  PUSH    1B50
02728:  POP     1B74
0272A:  MOV     W6,1B76
0272C:  MOV     W7,1B78
0272E:  CALL    23E2
02732:  MOV     W0,W6
02734:  MOV     1B56,W4
02736:  MUL.UU  W4,#2,W0
02738:  MOV     #AA6,W4
0273A:  ADD     W0,W4,W0
0273C:  MOV     [W0],W7
0273E:  MOV     W7,W4
02740:  MUL.UU  W4,#10,W0
02742:  MOV     W0,W7
02744:  MOV     1B14,W4
02746:  MUL.UU  W4,#4,W0
02748:  ADD     W0,W7,W0
0274A:  MOV     #B5A,W4
0274C:  ADD     W0,W4,W0
0274E:  MOV     [W0],W7
02750:  MOV     1B56,W4
02752:  MUL.UU  W4,#2,W0
02754:  MOV     #AA6,W4
02756:  ADD     W0,W4,W0
02758:  MOV     [W0],W8
0275A:  MOV     W8,W4
0275C:  MUL.UU  W4,#10,W8
0275E:  MOV     1B16,W4
02760:  MUL.UU  W4,#4,W0
02762:  ADD     W0,W8,W0
02764:  MOV     #B5A,W4
02766:  ADD     W0,W4,W0
02768:  MOV     [W0],W8
0276A:  MOV     W7,1B72
0276C:  MOV     W8,1B74
0276E:  PUSH    1B52
02770:  POP     1B76
02772:  PUSH    1B54
02774:  POP     1B78
02776:  CALL    23E2
0277A:  ADD     W0,W6,W0
0277C:  CP      W0,W5
0277E:  BRA     GE,27DA
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
02780:  MOV     AA2,W4
02782:  MUL.UU  W4,#8,W0
02784:  MOV     W0,W5
02786:  MOV     #ABA,W4
02788:  ADD     W5,W4,W6
0278A:  MOV     1B56,W4
0278C:  MUL.UU  W4,#2,W0
0278E:  MOV     #AA6,W4
02790:  ADD     W0,W4,W0
02792:  MOV     [W0],W7
02794:  MOV     W7,W4
02796:  MUL.UU  W4,#10,W0
02798:  MOV     W0,W7
0279A:  MOV     1B10,W4
0279C:  MUL.UU  W4,#4,W0
0279E:  ADD     W0,W7,W0
027A0:  MOV     #B5A,W4
027A2:  ADD     W0,W4,W0
027A4:  MOV     [W0++],[W6++]
027A6:  MOV     [W0++],[W6++]
027A8:  MOV     AA2,W4
027AA:  MUL.UU  W4,#8,W0
027AC:  MOV     W0,W5
027AE:  ADD     W5,#4,W5
027B0:  MOV     W5,W0
027B2:  MOV     #ABA,W4
027B4:  ADD     W0,W4,W5
027B6:  MOV     1B56,W4
027B8:  MUL.UU  W4,#2,W0
027BA:  MOV     #AA6,W4
027BC:  ADD     W0,W4,W0
027BE:  MOV     [W0],W6
027C0:  MOV     W6,W4
027C2:  MUL.UU  W4,#10,W6
027C4:  MOV     1B12,W4
027C6:  MUL.UU  W4,#4,W0
027C8:  ADD     W0,W6,W0
027CA:  MOV     #B5A,W4
027CC:  ADD     W0,W4,W0
027CE:  MOV     [W0++],[W5++]
027D0:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
027D2:  MOV     #1,W4
027D4:  MOV     W4,AA0
.................... 		                } 
027D6:  GOTO    2830
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
027DA:  MOV     AA2,W4
027DC:  MUL.UU  W4,#8,W0
027DE:  MOV     W0,W5
027E0:  MOV     #ABA,W4
027E2:  ADD     W5,W4,W6
027E4:  MOV     1B56,W4
027E6:  MUL.UU  W4,#2,W0
027E8:  MOV     #AA6,W4
027EA:  ADD     W0,W4,W0
027EC:  MOV     [W0],W7
027EE:  MOV     W7,W4
027F0:  MUL.UU  W4,#10,W0
027F2:  MOV     W0,W7
027F4:  MOV     1B14,W4
027F6:  MUL.UU  W4,#4,W0
027F8:  ADD     W0,W7,W0
027FA:  MOV     #B5A,W4
027FC:  ADD     W0,W4,W0
027FE:  MOV     [W0++],[W6++]
02800:  MOV     [W0++],[W6++]
02802:  MOV     AA2,W4
02804:  MUL.UU  W4,#8,W0
02806:  MOV     W0,W5
02808:  ADD     W5,#4,W5
0280A:  MOV     W5,W0
0280C:  MOV     #ABA,W4
0280E:  ADD     W0,W4,W5
02810:  MOV     1B56,W4
02812:  MUL.UU  W4,#2,W0
02814:  MOV     #AA6,W4
02816:  ADD     W0,W4,W0
02818:  MOV     [W0],W6
0281A:  MOV     W6,W4
0281C:  MUL.UU  W4,#10,W6
0281E:  MOV     1B16,W4
02820:  MUL.UU  W4,#4,W0
02822:  ADD     W0,W6,W0
02824:  MOV     #B5A,W4
02826:  ADD     W0,W4,W0
02828:  MOV     [W0++],[W5++]
0282A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0282C:  MOV     #1,W4
0282E:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
02830:  MOV     #1,W4
02832:  MOV     W4,A98
.................... 		            } 
02834:  GOTO    28F2
.................... 		            else if (posEnd == 5) 
02838:  MOV     1B5A,W4
0283A:  CP      W4,#5
0283C:  BRA     NZ,28F2
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0283E:  MOV     AA2,W4
02840:  MUL.UU  W4,#8,W0
02842:  MOV     W0,W5
02844:  MOV     #ABA,W4
02846:  ADD     W5,W4,W6
02848:  MOV     1B56,W4
0284A:  MUL.UU  W4,#2,W0
0284C:  MOV     #AA6,W4
0284E:  ADD     W0,W4,W0
02850:  MOV     [W0],W7
02852:  MOV     W7,W4
02854:  MUL.UU  W4,#10,W0
02856:  MOV     W0,W7
02858:  MOV     1B14,W4
0285A:  MUL.UU  W4,#4,W0
0285C:  ADD     W0,W7,W0
0285E:  MOV     #B5A,W4
02860:  ADD     W0,W4,W0
02862:  MOV     [W0++],[W6++]
02864:  MOV     [W0++],[W6++]
02866:  MOV     AA2,W4
02868:  MUL.UU  W4,#8,W0
0286A:  MOV     W0,W5
0286C:  ADD     W5,#4,W5
0286E:  MOV     W5,W0
02870:  MOV     #ABA,W4
02872:  ADD     W0,W4,W5
02874:  MOV     1B56,W4
02876:  MUL.UU  W4,#2,W0
02878:  MOV     #AA6,W4
0287A:  ADD     W0,W4,W0
0287C:  MOV     [W0],W6
0287E:  MOV     W6,W4
02880:  MUL.UU  W4,#10,W6
02882:  MOV     1B16,W4
02884:  MUL.UU  W4,#4,W0
02886:  ADD     W0,W6,W0
02888:  MOV     #B5A,W4
0288A:  ADD     W0,W4,W0
0288C:  MOV     [W0++],[W5++]
0288E:  MOV     [W0++],[W5++]
.................... 	                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
02890:  MOV     AA2,W4
02892:  ADD     W4,#1,W4
02894:  MOV     W4,W5
02896:  MOV     W5,W4
02898:  MUL.UU  W4,#8,W0
0289A:  MOV     W0,W5
0289C:  MOV     #ABA,W4
0289E:  ADD     W5,W4,W6
028A0:  MOV     1B56,W4
028A2:  MUL.UU  W4,#2,W0
028A4:  MOV     #AA6,W4
028A6:  ADD     W0,W4,W0
028A8:  MOV     [W0],W7
028AA:  MOV     W7,W4
028AC:  MUL.UU  W4,#10,W0
028AE:  MOV     W0,W7
028B0:  ADD     W7,#8,W7
028B2:  MOV     W7,W0
028B4:  MOV     #B5A,W4
028B6:  ADD     W0,W4,W0
028B8:  MOV     [W0++],[W6++]
028BA:  MOV     [W0++],[W6++]
028BC:  MOV     AA2,W4
028BE:  ADD     W4,#1,W4
028C0:  MOV     W4,W5
028C2:  MOV     W5,W4
028C4:  MUL.UU  W4,#8,W0
028C6:  MOV     W0,W5
028C8:  ADD     W5,#4,W5
028CA:  MOV     W5,W0
028CC:  MOV     #ABA,W4
028CE:  ADD     W0,W4,W5
028D0:  MOV     1B56,W4
028D2:  MUL.UU  W4,#2,W0
028D4:  MOV     #AA6,W4
028D6:  ADD     W0,W4,W0
028D8:  MOV     [W0],W6
028DA:  MOV     W6,W4
028DC:  MUL.UU  W4,#10,W6
028DE:  ADD     W6,#C,W6
028E0:  MOV     W6,W0
028E2:  MOV     #B5A,W4
028E4:  ADD     W0,W4,W0
028E6:  MOV     [W0++],[W5++]
028E8:  MOV     [W0++],[W5++]
.................... 	                    relay_point_number = 2; 
028EA:  MOV     #2,W4
028EC:  MOV     W4,AA0
.................... 		                path_found = true; 
028EE:  MOV     #1,W4
028F0:  MOV     W4,A98
.................... 		            } 
.................... 			    } 
028F2:  GOTO    2BF6
.................... 			    else 
.................... 			    { 
.................... 	            	if (posEnd == 3) 
028F6:  MOV     1B5A,W4
028F8:  CP      W4,#3
028FA:  BRA     NZ,295A
.................... 		            { 
....................  
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
028FC:  MOV     AA2,W4
028FE:  MUL.UU  W4,#8,W0
02900:  MOV     W0,W5
02902:  MOV     #ABA,W4
02904:  ADD     W5,W4,W6
02906:  MOV     1B56,W4
02908:  MUL.UU  W4,#2,W0
0290A:  MOV     #AA6,W4
0290C:  ADD     W0,W4,W0
0290E:  MOV     [W0],W7
02910:  MOV     W7,W4
02912:  MUL.UU  W4,#10,W0
02914:  MOV     W0,W7
02916:  MOV     1B14,W4
02918:  MUL.UU  W4,#4,W0
0291A:  ADD     W0,W7,W0
0291C:  MOV     #B5A,W4
0291E:  ADD     W0,W4,W0
02920:  MOV     [W0++],[W6++]
02922:  MOV     [W0++],[W6++]
02924:  MOV     AA2,W4
02926:  MUL.UU  W4,#8,W0
02928:  MOV     W0,W5
0292A:  ADD     W5,#4,W5
0292C:  MOV     W5,W0
0292E:  MOV     #ABA,W4
02930:  ADD     W0,W4,W5
02932:  MOV     1B56,W4
02934:  MUL.UU  W4,#2,W0
02936:  MOV     #AA6,W4
02938:  ADD     W0,W4,W0
0293A:  MOV     [W0],W6
0293C:  MOV     W6,W4
0293E:  MUL.UU  W4,#10,W6
02940:  MOV     1B16,W4
02942:  MUL.UU  W4,#4,W0
02944:  ADD     W0,W6,W0
02946:  MOV     #B5A,W4
02948:  ADD     W0,W4,W0
0294A:  MOV     [W0++],[W5++]
0294C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0294E:  MOV     #1,W4
02950:  MOV     W4,AA0
.................... 		                path_found = true; 
02952:  MOV     #1,W4
02954:  MOV     W4,A98
.................... 		            } 
02956:  GOTO    2BF6
.................... 		            else if (posEnd == 4) 
0295A:  MOV     1B5A,W4
0295C:  CP      W4,#4
0295E:  BRA     NZ,2B3C
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
02960:  MOV     1B56,W4
02962:  MUL.UU  W4,#2,W0
02964:  MOV     #AA6,W4
02966:  ADD     W0,W4,W0
02968:  MOV     [W0],W5
0296A:  MOV     W5,W4
0296C:  MUL.UU  W4,#10,W0
0296E:  MOV     W0,W5
02970:  MOV     1B10,W4
02972:  MUL.UU  W4,#4,W0
02974:  ADD     W0,W5,W0
02976:  MOV     #B5A,W4
02978:  ADD     W0,W4,W0
0297A:  MOV     [W0],W5
0297C:  MOV     1B56,W4
0297E:  MUL.UU  W4,#2,W0
02980:  MOV     #AA6,W4
02982:  ADD     W0,W4,W0
02984:  MOV     [W0],W6
02986:  MOV     W6,W4
02988:  MUL.UU  W4,#10,W6
0298A:  MOV     1B12,W4
0298C:  MUL.UU  W4,#4,W0
0298E:  ADD     W0,W6,W0
02990:  MOV     #B5A,W4
02992:  ADD     W0,W4,W0
02994:  MOV     [W0],W6
02996:  PUSH    1B4E
02998:  POP     1B72
0299A:  PUSH    1B50
0299C:  POP     1B74
0299E:  MOV     W5,1B76
029A0:  MOV     W6,1B78
029A2:  CALL    23E2
029A6:  MOV     W0,W5
029A8:  MOV     1B56,W4
029AA:  MUL.UU  W4,#2,W0
029AC:  MOV     #AA6,W4
029AE:  ADD     W0,W4,W0
029B0:  MOV     [W0],W6
029B2:  MOV     W6,W4
029B4:  MUL.UU  W4,#10,W6
029B6:  MOV     1B10,W4
029B8:  MUL.UU  W4,#4,W0
029BA:  ADD     W0,W6,W0
029BC:  MOV     #B5A,W4
029BE:  ADD     W0,W4,W0
029C0:  MOV     [W0],W6
029C2:  MOV     1B56,W4
029C4:  MUL.UU  W4,#2,W0
029C6:  MOV     #AA6,W4
029C8:  ADD     W0,W4,W0
029CA:  MOV     [W0],W7
029CC:  MOV     W7,W4
029CE:  MUL.UU  W4,#10,W0
029D0:  MOV     W0,W7
029D2:  MOV     1B12,W4
029D4:  MUL.UU  W4,#4,W0
029D6:  ADD     W0,W7,W0
029D8:  MOV     #B5A,W4
029DA:  ADD     W0,W4,W0
029DC:  MOV     [W0],W7
029DE:  MOV     W6,1B72
029E0:  MOV     W7,1B74
029E2:  PUSH    1B52
029E4:  POP     1B76
029E6:  PUSH    1B54
029E8:  POP     1B78
029EA:  CALL    23E2
029EE:  ADD     W0,W5,W5
029F0:  MOV     1B56,W4
029F2:  MUL.UU  W4,#2,W0
029F4:  MOV     #AA6,W4
029F6:  ADD     W0,W4,W0
029F8:  MOV     [W0],W6
029FA:  MOV     W6,W4
029FC:  MUL.UU  W4,#10,W6
029FE:  MOV     1B14,W4
02A00:  MUL.UU  W4,#4,W0
02A02:  ADD     W0,W6,W0
02A04:  MOV     #B5A,W4
02A06:  ADD     W0,W4,W0
02A08:  MOV     [W0],W6
02A0A:  MOV     1B56,W4
02A0C:  MUL.UU  W4,#2,W0
02A0E:  MOV     #AA6,W4
02A10:  ADD     W0,W4,W0
02A12:  MOV     [W0],W7
02A14:  MOV     W7,W4
02A16:  MUL.UU  W4,#10,W0
02A18:  MOV     W0,W7
02A1A:  MOV     1B16,W4
02A1C:  MUL.UU  W4,#4,W0
02A1E:  ADD     W0,W7,W0
02A20:  MOV     #B5A,W4
02A22:  ADD     W0,W4,W0
02A24:  MOV     [W0],W7
02A26:  PUSH    1B4E
02A28:  POP     1B72
02A2A:  PUSH    1B50
02A2C:  POP     1B74
02A2E:  MOV     W6,1B76
02A30:  MOV     W7,1B78
02A32:  CALL    23E2
02A36:  MOV     W0,W6
02A38:  MOV     1B56,W4
02A3A:  MUL.UU  W4,#2,W0
02A3C:  MOV     #AA6,W4
02A3E:  ADD     W0,W4,W0
02A40:  MOV     [W0],W7
02A42:  MOV     W7,W4
02A44:  MUL.UU  W4,#10,W0
02A46:  MOV     W0,W7
02A48:  MOV     1B14,W4
02A4A:  MUL.UU  W4,#4,W0
02A4C:  ADD     W0,W7,W0
02A4E:  MOV     #B5A,W4
02A50:  ADD     W0,W4,W0
02A52:  MOV     [W0],W7
02A54:  MOV     1B56,W4
02A56:  MUL.UU  W4,#2,W0
02A58:  MOV     #AA6,W4
02A5A:  ADD     W0,W4,W0
02A5C:  MOV     [W0],W8
02A5E:  MOV     W8,W4
02A60:  MUL.UU  W4,#10,W8
02A62:  MOV     1B16,W4
02A64:  MUL.UU  W4,#4,W0
02A66:  ADD     W0,W8,W0
02A68:  MOV     #B5A,W4
02A6A:  ADD     W0,W4,W0
02A6C:  MOV     [W0],W8
02A6E:  MOV     W7,1B72
02A70:  MOV     W8,1B74
02A72:  PUSH    1B52
02A74:  POP     1B76
02A76:  PUSH    1B54
02A78:  POP     1B78
02A7A:  CALL    23E2
02A7E:  ADD     W0,W6,W0
02A80:  CP      W0,W5
02A82:  BRA     GE,2ADE
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
02A84:  MOV     AA2,W4
02A86:  MUL.UU  W4,#8,W0
02A88:  MOV     W0,W5
02A8A:  MOV     #ABA,W4
02A8C:  ADD     W5,W4,W6
02A8E:  MOV     1B56,W4
02A90:  MUL.UU  W4,#2,W0
02A92:  MOV     #AA6,W4
02A94:  ADD     W0,W4,W0
02A96:  MOV     [W0],W7
02A98:  MOV     W7,W4
02A9A:  MUL.UU  W4,#10,W0
02A9C:  MOV     W0,W7
02A9E:  MOV     1B14,W4
02AA0:  MUL.UU  W4,#4,W0
02AA2:  ADD     W0,W7,W0
02AA4:  MOV     #B5A,W4
02AA6:  ADD     W0,W4,W0
02AA8:  MOV     [W0++],[W6++]
02AAA:  MOV     [W0++],[W6++]
02AAC:  MOV     AA2,W4
02AAE:  MUL.UU  W4,#8,W0
02AB0:  MOV     W0,W5
02AB2:  ADD     W5,#4,W5
02AB4:  MOV     W5,W0
02AB6:  MOV     #ABA,W4
02AB8:  ADD     W0,W4,W5
02ABA:  MOV     1B56,W4
02ABC:  MUL.UU  W4,#2,W0
02ABE:  MOV     #AA6,W4
02AC0:  ADD     W0,W4,W0
02AC2:  MOV     [W0],W6
02AC4:  MOV     W6,W4
02AC6:  MUL.UU  W4,#10,W6
02AC8:  MOV     1B16,W4
02ACA:  MUL.UU  W4,#4,W0
02ACC:  ADD     W0,W6,W0
02ACE:  MOV     #B5A,W4
02AD0:  ADD     W0,W4,W0
02AD2:  MOV     [W0++],[W5++]
02AD4:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
02AD6:  MOV     #1,W4
02AD8:  MOV     W4,AA0
.................... 		                } 
02ADA:  GOTO    2B34
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
02ADE:  MOV     AA2,W4
02AE0:  MUL.UU  W4,#8,W0
02AE2:  MOV     W0,W5
02AE4:  MOV     #ABA,W4
02AE6:  ADD     W5,W4,W6
02AE8:  MOV     1B56,W4
02AEA:  MUL.UU  W4,#2,W0
02AEC:  MOV     #AA6,W4
02AEE:  ADD     W0,W4,W0
02AF0:  MOV     [W0],W7
02AF2:  MOV     W7,W4
02AF4:  MUL.UU  W4,#10,W0
02AF6:  MOV     W0,W7
02AF8:  MOV     1B10,W4
02AFA:  MUL.UU  W4,#4,W0
02AFC:  ADD     W0,W7,W0
02AFE:  MOV     #B5A,W4
02B00:  ADD     W0,W4,W0
02B02:  MOV     [W0++],[W6++]
02B04:  MOV     [W0++],[W6++]
02B06:  MOV     AA2,W4
02B08:  MUL.UU  W4,#8,W0
02B0A:  MOV     W0,W5
02B0C:  ADD     W5,#4,W5
02B0E:  MOV     W5,W0
02B10:  MOV     #ABA,W4
02B12:  ADD     W0,W4,W5
02B14:  MOV     1B56,W4
02B16:  MUL.UU  W4,#2,W0
02B18:  MOV     #AA6,W4
02B1A:  ADD     W0,W4,W0
02B1C:  MOV     [W0],W6
02B1E:  MOV     W6,W4
02B20:  MUL.UU  W4,#10,W6
02B22:  MOV     1B12,W4
02B24:  MUL.UU  W4,#4,W0
02B26:  ADD     W0,W6,W0
02B28:  MOV     #B5A,W4
02B2A:  ADD     W0,W4,W0
02B2C:  MOV     [W0++],[W5++]
02B2E:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
02B30:  MOV     #1,W4
02B32:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
02B34:  MOV     #1,W4
02B36:  MOV     W4,A98
.................... 		            } 
02B38:  GOTO    2BF6
.................... 		            else if (posEnd == 5) 
02B3C:  MOV     1B5A,W4
02B3E:  CP      W4,#5
02B40:  BRA     NZ,2BF6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
02B42:  MOV     AA2,W4
02B44:  MUL.UU  W4,#8,W0
02B46:  MOV     W0,W5
02B48:  MOV     #ABA,W4
02B4A:  ADD     W5,W4,W6
02B4C:  MOV     1B56,W4
02B4E:  MUL.UU  W4,#2,W0
02B50:  MOV     #AA6,W4
02B52:  ADD     W0,W4,W0
02B54:  MOV     [W0],W7
02B56:  MOV     W7,W4
02B58:  MUL.UU  W4,#10,W0
02B5A:  MOV     W0,W7
02B5C:  MOV     1B14,W4
02B5E:  MUL.UU  W4,#4,W0
02B60:  ADD     W0,W7,W0
02B62:  MOV     #B5A,W4
02B64:  ADD     W0,W4,W0
02B66:  MOV     [W0++],[W6++]
02B68:  MOV     [W0++],[W6++]
02B6A:  MOV     AA2,W4
02B6C:  MUL.UU  W4,#8,W0
02B6E:  MOV     W0,W5
02B70:  ADD     W5,#4,W5
02B72:  MOV     W5,W0
02B74:  MOV     #ABA,W4
02B76:  ADD     W0,W4,W5
02B78:  MOV     1B56,W4
02B7A:  MUL.UU  W4,#2,W0
02B7C:  MOV     #AA6,W4
02B7E:  ADD     W0,W4,W0
02B80:  MOV     [W0],W6
02B82:  MOV     W6,W4
02B84:  MUL.UU  W4,#10,W6
02B86:  MOV     1B16,W4
02B88:  MUL.UU  W4,#4,W0
02B8A:  ADD     W0,W6,W0
02B8C:  MOV     #B5A,W4
02B8E:  ADD     W0,W4,W0
02B90:  MOV     [W0++],[W5++]
02B92:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
02B94:  MOV     AA2,W4
02B96:  ADD     W4,#1,W4
02B98:  MOV     W4,W5
02B9A:  MOV     W5,W4
02B9C:  MUL.UU  W4,#8,W0
02B9E:  MOV     W0,W5
02BA0:  MOV     #ABA,W4
02BA2:  ADD     W5,W4,W6
02BA4:  MOV     1B56,W4
02BA6:  MUL.UU  W4,#2,W0
02BA8:  MOV     #AA6,W4
02BAA:  ADD     W0,W4,W0
02BAC:  MOV     [W0],W7
02BAE:  MOV     W7,W4
02BB0:  MUL.UU  W4,#10,W0
02BB2:  MOV     W0,W7
02BB4:  ADD     W7,#8,W7
02BB6:  MOV     W7,W0
02BB8:  MOV     #B5A,W4
02BBA:  ADD     W0,W4,W0
02BBC:  MOV     [W0++],[W6++]
02BBE:  MOV     [W0++],[W6++]
02BC0:  MOV     AA2,W4
02BC2:  ADD     W4,#1,W4
02BC4:  MOV     W4,W5
02BC6:  MOV     W5,W4
02BC8:  MUL.UU  W4,#8,W0
02BCA:  MOV     W0,W5
02BCC:  ADD     W5,#4,W5
02BCE:  MOV     W5,W0
02BD0:  MOV     #ABA,W4
02BD2:  ADD     W0,W4,W5
02BD4:  MOV     1B56,W4
02BD6:  MUL.UU  W4,#2,W0
02BD8:  MOV     #AA6,W4
02BDA:  ADD     W0,W4,W0
02BDC:  MOV     [W0],W6
02BDE:  MOV     W6,W4
02BE0:  MUL.UU  W4,#10,W6
02BE2:  ADD     W6,#C,W6
02BE4:  MOV     W6,W0
02BE6:  MOV     #B5A,W4
02BE8:  ADD     W0,W4,W0
02BEA:  MOV     [W0++],[W5++]
02BEC:  MOV     [W0++],[W5++]
....................  
.................... 		                relay_point_number = 2; 
02BEE:  MOV     #2,W4
02BF0:  MOV     W4,AA0
.................... 		                path_found = true; 
02BF2:  MOV     #1,W4
02BF4:  MOV     W4,A98
.................... 		            } 
.................... 			    } 
....................  
....................  
.................... 	            break; 
02BF6:  GOTO    6324
....................  
.................... 	        case 1: 
.................... 	        	if(path_opposite) 
02BFA:  CP0     A9C
02BFC:  BRA     Z,322A
.................... 	        	{ 
.................... 	    			if (posEnd == 3) 
02BFE:  MOV     1B5A,W4
02C00:  CP      W4,#3
02C02:  BRA     NZ,2D12
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
02C04:  MOV     AA2,W4
02C06:  MUL.UU  W4,#8,W0
02C08:  MOV     W0,W5
02C0A:  MOV     #ABA,W4
02C0C:  ADD     W5,W4,W6
02C0E:  MOV     1B56,W4
02C10:  MUL.UU  W4,#2,W0
02C12:  MOV     #AA6,W4
02C14:  ADD     W0,W4,W0
02C16:  MOV     [W0],W7
02C18:  MOV     W7,W4
02C1A:  MUL.UU  W4,#10,W0
02C1C:  MOV     W0,W7
02C1E:  MOV     #B5A,W4
02C20:  ADD     W7,W4,W0
02C22:  MOV     [W0++],[W6++]
02C24:  MOV     [W0++],[W6++]
02C26:  MOV     AA2,W4
02C28:  MUL.UU  W4,#8,W0
02C2A:  MOV     W0,W5
02C2C:  ADD     W5,#4,W5
02C2E:  MOV     W5,W0
02C30:  MOV     #ABA,W4
02C32:  ADD     W0,W4,W5
02C34:  MOV     1B56,W4
02C36:  MUL.UU  W4,#2,W0
02C38:  MOV     #AA6,W4
02C3A:  ADD     W0,W4,W0
02C3C:  MOV     [W0],W6
02C3E:  MOV     W6,W4
02C40:  MUL.UU  W4,#10,W6
02C42:  ADD     W6,#4,W6
02C44:  MOV     W6,W0
02C46:  MOV     #B5A,W4
02C48:  ADD     W0,W4,W0
02C4A:  MOV     [W0++],[W5++]
02C4C:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
02C4E:  MOV     AA2,W4
02C50:  ADD     W4,#1,W4
02C52:  MOV     W4,W5
02C54:  MOV     W5,W4
02C56:  MUL.UU  W4,#8,W0
02C58:  MOV     W0,W5
02C5A:  MOV     #ABA,W4
02C5C:  ADD     W5,W4,W6
02C5E:  MOV     1B56,W4
02C60:  MUL.UU  W4,#2,W0
02C62:  MOV     #AA6,W4
02C64:  ADD     W0,W4,W0
02C66:  MOV     [W0],W7
02C68:  MOV     W7,W4
02C6A:  MUL.UU  W4,#10,W0
02C6C:  MOV     W0,W7
02C6E:  MOV     1B10,W4
02C70:  MUL.UU  W4,#4,W0
02C72:  ADD     W0,W7,W0
02C74:  MOV     #B5A,W4
02C76:  ADD     W0,W4,W0
02C78:  MOV     [W0++],[W6++]
02C7A:  MOV     [W0++],[W6++]
02C7C:  MOV     AA2,W4
02C7E:  ADD     W4,#1,W4
02C80:  MOV     W4,W5
02C82:  MOV     W5,W4
02C84:  MUL.UU  W4,#8,W0
02C86:  MOV     W0,W5
02C88:  ADD     W5,#4,W5
02C8A:  MOV     W5,W0
02C8C:  MOV     #ABA,W4
02C8E:  ADD     W0,W4,W5
02C90:  MOV     1B56,W4
02C92:  MUL.UU  W4,#2,W0
02C94:  MOV     #AA6,W4
02C96:  ADD     W0,W4,W0
02C98:  MOV     [W0],W6
02C9A:  MOV     W6,W4
02C9C:  MUL.UU  W4,#10,W6
02C9E:  MOV     1B12,W4
02CA0:  MUL.UU  W4,#4,W0
02CA2:  ADD     W0,W6,W0
02CA4:  MOV     #B5A,W4
02CA6:  ADD     W0,W4,W0
02CA8:  MOV     [W0++],[W5++]
02CAA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y4]; 
02CAC:  MOV     AA2,W4
02CAE:  ADD     W4,#2,W4
02CB0:  MOV     W4,W5
02CB2:  MOV     W5,W4
02CB4:  MUL.UU  W4,#8,W0
02CB6:  MOV     W0,W5
02CB8:  MOV     #ABA,W4
02CBA:  ADD     W5,W4,W6
02CBC:  MOV     1B56,W4
02CBE:  MUL.UU  W4,#2,W0
02CC0:  MOV     #AA6,W4
02CC2:  ADD     W0,W4,W0
02CC4:  MOV     [W0],W7
02CC6:  MOV     W7,W4
02CC8:  MUL.UU  W4,#10,W0
02CCA:  MOV     W0,W7
02CCC:  ADD     W7,#8,W7
02CCE:  MOV     W7,W0
02CD0:  MOV     #B5A,W4
02CD2:  ADD     W0,W4,W0
02CD4:  MOV     [W0++],[W6++]
02CD6:  MOV     [W0++],[W6++]
02CD8:  MOV     AA2,W4
02CDA:  ADD     W4,#2,W4
02CDC:  MOV     W4,W5
02CDE:  MOV     W5,W4
02CE0:  MUL.UU  W4,#8,W0
02CE2:  MOV     W0,W5
02CE4:  ADD     W5,#4,W5
02CE6:  MOV     W5,W0
02CE8:  MOV     #ABA,W4
02CEA:  ADD     W0,W4,W5
02CEC:  MOV     1B56,W4
02CEE:  MUL.UU  W4,#2,W0
02CF0:  MOV     #AA6,W4
02CF2:  ADD     W0,W4,W0
02CF4:  MOV     [W0],W6
02CF6:  MOV     W6,W4
02CF8:  MUL.UU  W4,#10,W6
02CFA:  ADD     W6,#C,W6
02CFC:  MOV     W6,W0
02CFE:  MOV     #B5A,W4
02D00:  ADD     W0,W4,W0
02D02:  MOV     [W0++],[W5++]
02D04:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
02D06:  MOV     #3,W4
02D08:  MOV     W4,AA0
.................... 		                path_found = true; 
02D0A:  MOV     #1,W4
02D0C:  MOV     W4,A98
.................... 		            } 
02D0E:  GOTO    3226
.................... 		            else if (posEnd == 4) 
02D12:  MOV     1B5A,W4
02D14:  CP      W4,#4
02D16:  BRA     NZ,2DCC
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
02D18:  MOV     AA2,W4
02D1A:  MUL.UU  W4,#8,W0
02D1C:  MOV     W0,W5
02D1E:  MOV     #ABA,W4
02D20:  ADD     W5,W4,W6
02D22:  MOV     1B56,W4
02D24:  MUL.UU  W4,#2,W0
02D26:  MOV     #AA6,W4
02D28:  ADD     W0,W4,W0
02D2A:  MOV     [W0],W7
02D2C:  MOV     W7,W4
02D2E:  MUL.UU  W4,#10,W0
02D30:  MOV     W0,W7
02D32:  MOV     #B5A,W4
02D34:  ADD     W7,W4,W0
02D36:  MOV     [W0++],[W6++]
02D38:  MOV     [W0++],[W6++]
02D3A:  MOV     AA2,W4
02D3C:  MUL.UU  W4,#8,W0
02D3E:  MOV     W0,W5
02D40:  ADD     W5,#4,W5
02D42:  MOV     W5,W0
02D44:  MOV     #ABA,W4
02D46:  ADD     W0,W4,W5
02D48:  MOV     1B56,W4
02D4A:  MUL.UU  W4,#2,W0
02D4C:  MOV     #AA6,W4
02D4E:  ADD     W0,W4,W0
02D50:  MOV     [W0],W6
02D52:  MOV     W6,W4
02D54:  MUL.UU  W4,#10,W6
02D56:  ADD     W6,#4,W6
02D58:  MOV     W6,W0
02D5A:  MOV     #B5A,W4
02D5C:  ADD     W0,W4,W0
02D5E:  MOV     [W0++],[W5++]
02D60:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
02D62:  MOV     AA2,W4
02D64:  ADD     W4,#1,W4
02D66:  MOV     W4,W5
02D68:  MOV     W5,W4
02D6A:  MUL.UU  W4,#8,W0
02D6C:  MOV     W0,W5
02D6E:  MOV     #ABA,W4
02D70:  ADD     W5,W4,W6
02D72:  MOV     1B56,W4
02D74:  MUL.UU  W4,#2,W0
02D76:  MOV     #AA6,W4
02D78:  ADD     W0,W4,W0
02D7A:  MOV     [W0],W7
02D7C:  MOV     W7,W4
02D7E:  MUL.UU  W4,#10,W0
02D80:  MOV     W0,W7
02D82:  MOV     1B10,W4
02D84:  MUL.UU  W4,#4,W0
02D86:  ADD     W0,W7,W0
02D88:  MOV     #B5A,W4
02D8A:  ADD     W0,W4,W0
02D8C:  MOV     [W0++],[W6++]
02D8E:  MOV     [W0++],[W6++]
02D90:  MOV     AA2,W4
02D92:  ADD     W4,#1,W4
02D94:  MOV     W4,W5
02D96:  MOV     W5,W4
02D98:  MUL.UU  W4,#8,W0
02D9A:  MOV     W0,W5
02D9C:  ADD     W5,#4,W5
02D9E:  MOV     W5,W0
02DA0:  MOV     #ABA,W4
02DA2:  ADD     W0,W4,W5
02DA4:  MOV     1B56,W4
02DA6:  MUL.UU  W4,#2,W0
02DA8:  MOV     #AA6,W4
02DAA:  ADD     W0,W4,W0
02DAC:  MOV     [W0],W6
02DAE:  MOV     W6,W4
02DB0:  MUL.UU  W4,#10,W6
02DB2:  MOV     1B12,W4
02DB4:  MUL.UU  W4,#4,W0
02DB6:  ADD     W0,W6,W0
02DB8:  MOV     #B5A,W4
02DBA:  ADD     W0,W4,W0
02DBC:  MOV     [W0++],[W5++]
02DBE:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
02DC0:  MOV     #2,W4
02DC2:  MOV     W4,AA0
.................... 		                path_found = true; 
02DC4:  MOV     #1,W4
02DC6:  MOV     W4,A98
.................... 		            } 
02DC8:  GOTO    3226
.................... 		            else if (posEnd == 5) 
02DCC:  MOV     1B5A,W4
02DCE:  CP      W4,#5
02DD0:  BRA     NZ,3054
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
02DD2:  MOV     1B56,W4
02DD4:  MUL.UU  W4,#2,W0
02DD6:  MOV     #AA6,W4
02DD8:  ADD     W0,W4,W0
02DDA:  MOV     [W0],W5
02DDC:  MOV     W5,W4
02DDE:  MUL.UU  W4,#10,W0
02DE0:  MOV     W0,W5
02DE2:  MOV     #B5A,W4
02DE4:  ADD     W5,W4,W0
02DE6:  MOV     [W0],W6
02DE8:  MOV     1B56,W4
02DEA:  MUL.UU  W4,#2,W0
02DEC:  MOV     #AA6,W4
02DEE:  ADD     W0,W4,W0
02DF0:  MOV     [W0],W7
02DF2:  MOV     W7,W4
02DF4:  MUL.UU  W4,#10,W0
02DF6:  MOV     W0,W7
02DF8:  ADD     W7,#4,W7
02DFA:  MOV     W7,W0
02DFC:  MOV     #B5A,W4
02DFE:  ADD     W0,W4,W0
02E00:  MOV     [W0],W7
02E02:  PUSH    1B4E
02E04:  POP     1B72
02E06:  PUSH    1B50
02E08:  POP     1B74
02E0A:  MOV     W6,1B76
02E0C:  MOV     W7,1B78
02E0E:  CALL    23E2
02E12:  MOV     W0,W6
02E14:  MOV     1B56,W4
02E16:  MUL.UU  W4,#2,W0
02E18:  MOV     #AA6,W4
02E1A:  ADD     W0,W4,W0
02E1C:  MOV     [W0],W7
02E1E:  MOV     W7,W4
02E20:  MUL.UU  W4,#10,W0
02E22:  MOV     W0,W7
02E24:  MOV     1B10,W4
02E26:  MUL.UU  W4,#4,W0
02E28:  ADD     W0,W7,W0
02E2A:  MOV     #B5A,W4
02E2C:  ADD     W0,W4,W0
02E2E:  MOV     [W0],W7
02E30:  MOV     1B56,W4
02E32:  MUL.UU  W4,#2,W0
02E34:  MOV     #AA6,W4
02E36:  ADD     W0,W4,W0
02E38:  MOV     [W0],W8
02E3A:  MOV     W8,W4
02E3C:  MUL.UU  W4,#10,W8
02E3E:  MOV     1B12,W4
02E40:  MUL.UU  W4,#4,W0
02E42:  ADD     W0,W8,W0
02E44:  MOV     #B5A,W4
02E46:  ADD     W0,W4,W0
02E48:  MOV     [W0],W8
02E4A:  MOV     W7,1B72
02E4C:  MOV     W8,1B74
02E4E:  PUSH    1B52
02E50:  POP     1B76
02E52:  PUSH    1B54
02E54:  POP     1B78
02E56:  CALL    23E2
02E5A:  ADD     W0,W6,W6
02E5C:  MOV     1B56,W4
02E5E:  MUL.UU  W4,#2,W0
02E60:  MOV     #AA6,W4
02E62:  ADD     W0,W4,W0
02E64:  MOV     [W0],W7
02E66:  MOV     W7,W4
02E68:  MUL.UU  W4,#10,W0
02E6A:  MOV     W0,W7
02E6C:  MOV     1B14,W4
02E6E:  MUL.UU  W4,#4,W0
02E70:  ADD     W0,W7,W0
02E72:  MOV     #B5A,W4
02E74:  ADD     W0,W4,W0
02E76:  MOV     [W0],W7
02E78:  MOV     1B56,W4
02E7A:  MUL.UU  W4,#2,W0
02E7C:  MOV     #AA6,W4
02E7E:  ADD     W0,W4,W0
02E80:  MOV     [W0],W8
02E82:  MOV     W8,W4
02E84:  MUL.UU  W4,#10,W8
02E86:  MOV     1B16,W4
02E88:  MUL.UU  W4,#4,W0
02E8A:  ADD     W0,W8,W0
02E8C:  MOV     #B5A,W4
02E8E:  ADD     W0,W4,W0
02E90:  MOV     [W0],W8
02E92:  PUSH    1B4E
02E94:  POP     1B72
02E96:  PUSH    1B50
02E98:  POP     1B74
02E9A:  MOV     W7,1B76
02E9C:  MOV     W8,1B78
02E9E:  CALL    23E2
02EA2:  MOV     W0,W7
02EA4:  MOV     1B56,W4
02EA6:  MUL.UU  W4,#2,W0
02EA8:  MOV     #AA6,W4
02EAA:  ADD     W0,W4,W0
02EAC:  MOV     [W0],W8
02EAE:  MOV     W8,W4
02EB0:  MUL.UU  W4,#10,W8
02EB2:  ADD     W8,#8,W8
02EB4:  MOV     W8,W0
02EB6:  MOV     #B5A,W4
02EB8:  ADD     W0,W4,W0
02EBA:  MOV     [W0],W8
02EBC:  MOV     1B56,W4
02EBE:  MUL.UU  W4,#2,W0
02EC0:  MOV     #AA6,W4
02EC2:  ADD     W0,W4,W0
02EC4:  MOV     [W0],W9
02EC6:  MOV     W9,W4
02EC8:  MUL.UU  W4,#10,W0
02ECA:  MOV     W0,W9
02ECC:  ADD     W9,#C,W9
02ECE:  MOV     W9,W0
02ED0:  MOV     #B5A,W4
02ED2:  ADD     W0,W4,W0
02ED4:  MOV     [W0],W9
02ED6:  MOV     W8,1B72
02ED8:  MOV     W9,1B74
02EDA:  PUSH    1B52
02EDC:  POP     1B76
02EDE:  PUSH    1B54
02EE0:  POP     1B78
02EE2:  CALL    23E2
02EE6:  ADD     W0,W7,W0
02EE8:  CP      W6,W0
02EEA:  BRA     GE,2FA0
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
02EEC:  MOV     AA2,W4
02EEE:  MUL.UU  W4,#8,W0
02EF0:  MOV     W0,W5
02EF2:  MOV     #ABA,W4
02EF4:  ADD     W5,W4,W6
02EF6:  MOV     1B56,W4
02EF8:  MUL.UU  W4,#2,W0
02EFA:  MOV     #AA6,W4
02EFC:  ADD     W0,W4,W0
02EFE:  MOV     [W0],W7
02F00:  MOV     W7,W4
02F02:  MUL.UU  W4,#10,W0
02F04:  MOV     W0,W7
02F06:  MOV     1B14,W4
02F08:  MUL.UU  W4,#4,W0
02F0A:  ADD     W0,W7,W0
02F0C:  MOV     #B5A,W4
02F0E:  ADD     W0,W4,W0
02F10:  MOV     [W0++],[W6++]
02F12:  MOV     [W0++],[W6++]
02F14:  MOV     AA2,W4
02F16:  MUL.UU  W4,#8,W0
02F18:  MOV     W0,W5
02F1A:  ADD     W5,#4,W5
02F1C:  MOV     W5,W0
02F1E:  MOV     #ABA,W4
02F20:  ADD     W0,W4,W5
02F22:  MOV     1B56,W4
02F24:  MUL.UU  W4,#2,W0
02F26:  MOV     #AA6,W4
02F28:  ADD     W0,W4,W0
02F2A:  MOV     [W0],W6
02F2C:  MOV     W6,W4
02F2E:  MUL.UU  W4,#10,W6
02F30:  MOV     1B16,W4
02F32:  MUL.UU  W4,#4,W0
02F34:  ADD     W0,W6,W0
02F36:  MOV     #B5A,W4
02F38:  ADD     W0,W4,W0
02F3A:  MOV     [W0++],[W5++]
02F3C:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
02F3E:  MOV     AA2,W4
02F40:  ADD     W4,#1,W4
02F42:  MOV     W4,W5
02F44:  MOV     W5,W4
02F46:  MUL.UU  W4,#8,W0
02F48:  MOV     W0,W5
02F4A:  MOV     #ABA,W4
02F4C:  ADD     W5,W4,W6
02F4E:  MOV     1B56,W4
02F50:  MUL.UU  W4,#2,W0
02F52:  MOV     #AA6,W4
02F54:  ADD     W0,W4,W0
02F56:  MOV     [W0],W7
02F58:  MOV     W7,W4
02F5A:  MUL.UU  W4,#10,W0
02F5C:  MOV     W0,W7
02F5E:  ADD     W7,#8,W7
02F60:  MOV     W7,W0
02F62:  MOV     #B5A,W4
02F64:  ADD     W0,W4,W0
02F66:  MOV     [W0++],[W6++]
02F68:  MOV     [W0++],[W6++]
02F6A:  MOV     AA2,W4
02F6C:  ADD     W4,#1,W4
02F6E:  MOV     W4,W5
02F70:  MOV     W5,W4
02F72:  MUL.UU  W4,#8,W0
02F74:  MOV     W0,W5
02F76:  ADD     W5,#4,W5
02F78:  MOV     W5,W0
02F7A:  MOV     #ABA,W4
02F7C:  ADD     W0,W4,W5
02F7E:  MOV     1B56,W4
02F80:  MUL.UU  W4,#2,W0
02F82:  MOV     #AA6,W4
02F84:  ADD     W0,W4,W0
02F86:  MOV     [W0],W6
02F88:  MOV     W6,W4
02F8A:  MUL.UU  W4,#10,W6
02F8C:  ADD     W6,#C,W6
02F8E:  MOV     W6,W0
02F90:  MOV     #B5A,W4
02F92:  ADD     W0,W4,W0
02F94:  MOV     [W0++],[W5++]
02F96:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
02F98:  MOV     #2,W4
02F9A:  MOV     W4,AA0
.................... 		                } 
02F9C:  GOTO    304C
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
02FA0:  MOV     AA2,W4
02FA2:  MUL.UU  W4,#8,W0
02FA4:  MOV     W0,W5
02FA6:  MOV     #ABA,W4
02FA8:  ADD     W5,W4,W6
02FAA:  MOV     1B56,W4
02FAC:  MUL.UU  W4,#2,W0
02FAE:  MOV     #AA6,W4
02FB0:  ADD     W0,W4,W0
02FB2:  MOV     [W0],W7
02FB4:  MOV     W7,W4
02FB6:  MUL.UU  W4,#10,W0
02FB8:  MOV     W0,W7
02FBA:  MOV     #B5A,W4
02FBC:  ADD     W7,W4,W0
02FBE:  MOV     [W0++],[W6++]
02FC0:  MOV     [W0++],[W6++]
02FC2:  MOV     AA2,W4
02FC4:  MUL.UU  W4,#8,W0
02FC6:  MOV     W0,W5
02FC8:  ADD     W5,#4,W5
02FCA:  MOV     W5,W0
02FCC:  MOV     #ABA,W4
02FCE:  ADD     W0,W4,W5
02FD0:  MOV     1B56,W4
02FD2:  MUL.UU  W4,#2,W0
02FD4:  MOV     #AA6,W4
02FD6:  ADD     W0,W4,W0
02FD8:  MOV     [W0],W6
02FDA:  MOV     W6,W4
02FDC:  MUL.UU  W4,#10,W6
02FDE:  ADD     W6,#4,W6
02FE0:  MOV     W6,W0
02FE2:  MOV     #B5A,W4
02FE4:  ADD     W0,W4,W0
02FE6:  MOV     [W0++],[W5++]
02FE8:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3];		                     
02FEA:  MOV     AA2,W4
02FEC:  ADD     W4,#1,W4
02FEE:  MOV     W4,W5
02FF0:  MOV     W5,W4
02FF2:  MUL.UU  W4,#8,W0
02FF4:  MOV     W0,W5
02FF6:  MOV     #ABA,W4
02FF8:  ADD     W5,W4,W6
02FFA:  MOV     1B56,W4
02FFC:  MUL.UU  W4,#2,W0
02FFE:  MOV     #AA6,W4
03000:  ADD     W0,W4,W0
03002:  MOV     [W0],W7
03004:  MOV     W7,W4
03006:  MUL.UU  W4,#10,W0
03008:  MOV     W0,W7
0300A:  MOV     1B10,W4
0300C:  MUL.UU  W4,#4,W0
0300E:  ADD     W0,W7,W0
03010:  MOV     #B5A,W4
03012:  ADD     W0,W4,W0
03014:  MOV     [W0++],[W6++]
03016:  MOV     [W0++],[W6++]
03018:  MOV     AA2,W4
0301A:  ADD     W4,#1,W4
0301C:  MOV     W4,W5
0301E:  MOV     W5,W4
03020:  MUL.UU  W4,#8,W0
03022:  MOV     W0,W5
03024:  ADD     W5,#4,W5
03026:  MOV     W5,W0
03028:  MOV     #ABA,W4
0302A:  ADD     W0,W4,W5
0302C:  MOV     1B56,W4
0302E:  MUL.UU  W4,#2,W0
03030:  MOV     #AA6,W4
03032:  ADD     W0,W4,W0
03034:  MOV     [W0],W6
03036:  MOV     W6,W4
03038:  MUL.UU  W4,#10,W6
0303A:  MOV     1B12,W4
0303C:  MUL.UU  W4,#4,W0
0303E:  ADD     W0,W6,W0
03040:  MOV     #B5A,W4
03042:  ADD     W0,W4,W0
03044:  MOV     [W0++],[W5++]
03046:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03048:  MOV     #2,W4
0304A:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
0304C:  MOV     #1,W4
0304E:  MOV     W4,A98
.................... 		            } 
03050:  GOTO    3226
.................... 		            else if (posEnd == 6) 
03054:  MOV     1B5A,W4
03056:  CP      W4,#6
03058:  BRA     NZ,3112
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0305A:  MOV     AA2,W4
0305C:  MUL.UU  W4,#8,W0
0305E:  MOV     W0,W5
03060:  MOV     #ABA,W4
03062:  ADD     W5,W4,W6
03064:  MOV     1B56,W4
03066:  MUL.UU  W4,#2,W0
03068:  MOV     #AA6,W4
0306A:  ADD     W0,W4,W0
0306C:  MOV     [W0],W7
0306E:  MOV     W7,W4
03070:  MUL.UU  W4,#10,W0
03072:  MOV     W0,W7
03074:  MOV     1B14,W4
03076:  MUL.UU  W4,#4,W0
03078:  ADD     W0,W7,W0
0307A:  MOV     #B5A,W4
0307C:  ADD     W0,W4,W0
0307E:  MOV     [W0++],[W6++]
03080:  MOV     [W0++],[W6++]
03082:  MOV     AA2,W4
03084:  MUL.UU  W4,#8,W0
03086:  MOV     W0,W5
03088:  ADD     W5,#4,W5
0308A:  MOV     W5,W0
0308C:  MOV     #ABA,W4
0308E:  ADD     W0,W4,W5
03090:  MOV     1B56,W4
03092:  MUL.UU  W4,#2,W0
03094:  MOV     #AA6,W4
03096:  ADD     W0,W4,W0
03098:  MOV     [W0],W6
0309A:  MOV     W6,W4
0309C:  MUL.UU  W4,#10,W6
0309E:  MOV     1B16,W4
030A0:  MUL.UU  W4,#4,W0
030A2:  ADD     W0,W6,W0
030A4:  MOV     #B5A,W4
030A6:  ADD     W0,W4,W0
030A8:  MOV     [W0++],[W5++]
030AA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
030AC:  MOV     AA2,W4
030AE:  ADD     W4,#1,W4
030B0:  MOV     W4,W5
030B2:  MOV     W5,W4
030B4:  MUL.UU  W4,#8,W0
030B6:  MOV     W0,W5
030B8:  MOV     #ABA,W4
030BA:  ADD     W5,W4,W6
030BC:  MOV     1B56,W4
030BE:  MUL.UU  W4,#2,W0
030C0:  MOV     #AA6,W4
030C2:  ADD     W0,W4,W0
030C4:  MOV     [W0],W7
030C6:  MOV     W7,W4
030C8:  MUL.UU  W4,#10,W0
030CA:  MOV     W0,W7
030CC:  ADD     W7,#8,W7
030CE:  MOV     W7,W0
030D0:  MOV     #B5A,W4
030D2:  ADD     W0,W4,W0
030D4:  MOV     [W0++],[W6++]
030D6:  MOV     [W0++],[W6++]
030D8:  MOV     AA2,W4
030DA:  ADD     W4,#1,W4
030DC:  MOV     W4,W5
030DE:  MOV     W5,W4
030E0:  MUL.UU  W4,#8,W0
030E2:  MOV     W0,W5
030E4:  ADD     W5,#4,W5
030E6:  MOV     W5,W0
030E8:  MOV     #ABA,W4
030EA:  ADD     W0,W4,W5
030EC:  MOV     1B56,W4
030EE:  MUL.UU  W4,#2,W0
030F0:  MOV     #AA6,W4
030F2:  ADD     W0,W4,W0
030F4:  MOV     [W0],W6
030F6:  MOV     W6,W4
030F8:  MUL.UU  W4,#10,W6
030FA:  ADD     W6,#C,W6
030FC:  MOV     W6,W0
030FE:  MOV     #B5A,W4
03100:  ADD     W0,W4,W0
03102:  MOV     [W0++],[W5++]
03104:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03106:  MOV     #2,W4
03108:  MOV     W4,AA0
.................... 		                path_found = true; 
0310A:  MOV     #1,W4
0310C:  MOV     W4,A98
.................... 		            } 
0310E:  GOTO    3226
.................... 		            else if(posEnd == 7) 
03112:  MOV     1B5A,W4
03114:  CP      W4,#7
03116:  BRA     NZ,3226
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03118:  MOV     AA2,W4
0311A:  MUL.UU  W4,#8,W0
0311C:  MOV     W0,W5
0311E:  MOV     #ABA,W4
03120:  ADD     W5,W4,W6
03122:  MOV     1B56,W4
03124:  MUL.UU  W4,#2,W0
03126:  MOV     #AA6,W4
03128:  ADD     W0,W4,W0
0312A:  MOV     [W0],W7
0312C:  MOV     W7,W4
0312E:  MUL.UU  W4,#10,W0
03130:  MOV     W0,W7
03132:  MOV     1B14,W4
03134:  MUL.UU  W4,#4,W0
03136:  ADD     W0,W7,W0
03138:  MOV     #B5A,W4
0313A:  ADD     W0,W4,W0
0313C:  MOV     [W0++],[W6++]
0313E:  MOV     [W0++],[W6++]
03140:  MOV     AA2,W4
03142:  MUL.UU  W4,#8,W0
03144:  MOV     W0,W5
03146:  ADD     W5,#4,W5
03148:  MOV     W5,W0
0314A:  MOV     #ABA,W4
0314C:  ADD     W0,W4,W5
0314E:  MOV     1B56,W4
03150:  MUL.UU  W4,#2,W0
03152:  MOV     #AA6,W4
03154:  ADD     W0,W4,W0
03156:  MOV     [W0],W6
03158:  MOV     W6,W4
0315A:  MUL.UU  W4,#10,W6
0315C:  MOV     1B16,W4
0315E:  MUL.UU  W4,#4,W0
03160:  ADD     W0,W6,W0
03162:  MOV     #B5A,W4
03164:  ADD     W0,W4,W0
03166:  MOV     [W0++],[W5++]
03168:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0316A:  MOV     AA2,W4
0316C:  ADD     W4,#1,W4
0316E:  MOV     W4,W5
03170:  MOV     W5,W4
03172:  MUL.UU  W4,#8,W0
03174:  MOV     W0,W5
03176:  MOV     #ABA,W4
03178:  ADD     W5,W4,W6
0317A:  MOV     1B56,W4
0317C:  MUL.UU  W4,#2,W0
0317E:  MOV     #AA6,W4
03180:  ADD     W0,W4,W0
03182:  MOV     [W0],W7
03184:  MOV     W7,W4
03186:  MUL.UU  W4,#10,W0
03188:  MOV     W0,W7
0318A:  ADD     W7,#8,W7
0318C:  MOV     W7,W0
0318E:  MOV     #B5A,W4
03190:  ADD     W0,W4,W0
03192:  MOV     [W0++],[W6++]
03194:  MOV     [W0++],[W6++]
03196:  MOV     AA2,W4
03198:  ADD     W4,#1,W4
0319A:  MOV     W4,W5
0319C:  MOV     W5,W4
0319E:  MUL.UU  W4,#8,W0
031A0:  MOV     W0,W5
031A2:  ADD     W5,#4,W5
031A4:  MOV     W5,W0
031A6:  MOV     #ABA,W4
031A8:  ADD     W0,W4,W5
031AA:  MOV     1B56,W4
031AC:  MUL.UU  W4,#2,W0
031AE:  MOV     #AA6,W4
031B0:  ADD     W0,W4,W0
031B2:  MOV     [W0],W6
031B4:  MOV     W6,W4
031B6:  MUL.UU  W4,#10,W6
031B8:  ADD     W6,#C,W6
031BA:  MOV     W6,W0
031BC:  MOV     #B5A,W4
031BE:  ADD     W0,W4,W0
031C0:  MOV     [W0++],[W5++]
031C2:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y3]; 
031C4:  MOV     AA2,W4
031C6:  ADD     W4,#2,W4
031C8:  MOV     W4,W5
031CA:  MOV     W5,W4
031CC:  MUL.UU  W4,#8,W0
031CE:  MOV     W0,W5
031D0:  MOV     #ABA,W4
031D2:  ADD     W5,W4,W6
031D4:  MOV     1B56,W4
031D6:  MUL.UU  W4,#2,W0
031D8:  MOV     #AA6,W4
031DA:  ADD     W0,W4,W0
031DC:  MOV     [W0],W7
031DE:  MOV     W7,W4
031E0:  MUL.UU  W4,#10,W0
031E2:  MOV     W0,W7
031E4:  MOV     1B10,W4
031E6:  MUL.UU  W4,#4,W0
031E8:  ADD     W0,W7,W0
031EA:  MOV     #B5A,W4
031EC:  ADD     W0,W4,W0
031EE:  MOV     [W0++],[W6++]
031F0:  MOV     [W0++],[W6++]
031F2:  MOV     AA2,W4
031F4:  ADD     W4,#2,W4
031F6:  MOV     W4,W5
031F8:  MOV     W5,W4
031FA:  MUL.UU  W4,#8,W0
031FC:  MOV     W0,W5
031FE:  ADD     W5,#4,W5
03200:  MOV     W5,W0
03202:  MOV     #ABA,W4
03204:  ADD     W0,W4,W5
03206:  MOV     1B56,W4
03208:  MUL.UU  W4,#2,W0
0320A:  MOV     #AA6,W4
0320C:  ADD     W0,W4,W0
0320E:  MOV     [W0],W6
03210:  MOV     W6,W4
03212:  MUL.UU  W4,#10,W6
03214:  MOV     1B12,W4
03216:  MUL.UU  W4,#4,W0
03218:  ADD     W0,W6,W0
0321A:  MOV     #B5A,W4
0321C:  ADD     W0,W4,W0
0321E:  MOV     [W0++],[W5++]
03220:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
03222:  MOV     #3,W4
03224:  MOV     W4,AA0
.................... 		            } 
.................... 	        	} 
03226:  GOTO    357A
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 3 || posEnd == 4) 
0322A:  MOV     1B5A,W4
0322C:  CP      W4,#3
0322E:  BRA     Z,3236
03230:  MOV     1B5A,W4
03232:  CP      W4,#4
03234:  BRA     NZ,3294
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03236:  MOV     AA2,W4
03238:  MUL.UU  W4,#8,W0
0323A:  MOV     W0,W5
0323C:  MOV     #ABA,W4
0323E:  ADD     W5,W4,W6
03240:  MOV     1B56,W4
03242:  MUL.UU  W4,#2,W0
03244:  MOV     #AA6,W4
03246:  ADD     W0,W4,W0
03248:  MOV     [W0],W7
0324A:  MOV     W7,W4
0324C:  MUL.UU  W4,#10,W0
0324E:  MOV     W0,W7
03250:  MOV     1B14,W4
03252:  MUL.UU  W4,#4,W0
03254:  ADD     W0,W7,W0
03256:  MOV     #B5A,W4
03258:  ADD     W0,W4,W0
0325A:  MOV     [W0++],[W6++]
0325C:  MOV     [W0++],[W6++]
0325E:  MOV     AA2,W4
03260:  MUL.UU  W4,#8,W0
03262:  MOV     W0,W5
03264:  ADD     W5,#4,W5
03266:  MOV     W5,W0
03268:  MOV     #ABA,W4
0326A:  ADD     W0,W4,W5
0326C:  MOV     1B56,W4
0326E:  MUL.UU  W4,#2,W0
03270:  MOV     #AA6,W4
03272:  ADD     W0,W4,W0
03274:  MOV     [W0],W6
03276:  MOV     W6,W4
03278:  MUL.UU  W4,#10,W6
0327A:  MOV     1B16,W4
0327C:  MUL.UU  W4,#4,W0
0327E:  ADD     W0,W6,W0
03280:  MOV     #B5A,W4
03282:  ADD     W0,W4,W0
03284:  MOV     [W0++],[W5++]
03286:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03288:  MOV     #1,W4
0328A:  MOV     W4,AA0
.................... 		                path_found = true; 
0328C:  MOV     #1,W4
0328E:  MOV     W4,A98
.................... 		            } 
03290:  GOTO    357A
.................... 		            else if (posEnd == 5) 
03294:  MOV     1B5A,W4
03296:  CP      W4,#5
03298:  BRA     NZ,351C
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
0329A:  MOV     1B56,W4
0329C:  MUL.UU  W4,#2,W0
0329E:  MOV     #AA6,W4
032A0:  ADD     W0,W4,W0
032A2:  MOV     [W0],W5
032A4:  MOV     W5,W4
032A6:  MUL.UU  W4,#10,W0
032A8:  MOV     W0,W5
032AA:  MOV     #B5A,W4
032AC:  ADD     W5,W4,W0
032AE:  MOV     [W0],W6
032B0:  MOV     1B56,W4
032B2:  MUL.UU  W4,#2,W0
032B4:  MOV     #AA6,W4
032B6:  ADD     W0,W4,W0
032B8:  MOV     [W0],W7
032BA:  MOV     W7,W4
032BC:  MUL.UU  W4,#10,W0
032BE:  MOV     W0,W7
032C0:  ADD     W7,#4,W7
032C2:  MOV     W7,W0
032C4:  MOV     #B5A,W4
032C6:  ADD     W0,W4,W0
032C8:  MOV     [W0],W7
032CA:  PUSH    1B4E
032CC:  POP     1B72
032CE:  PUSH    1B50
032D0:  POP     1B74
032D2:  MOV     W6,1B76
032D4:  MOV     W7,1B78
032D6:  CALL    23E2
032DA:  MOV     W0,W6
032DC:  MOV     1B56,W4
032DE:  MUL.UU  W4,#2,W0
032E0:  MOV     #AA6,W4
032E2:  ADD     W0,W4,W0
032E4:  MOV     [W0],W7
032E6:  MOV     W7,W4
032E8:  MUL.UU  W4,#10,W0
032EA:  MOV     W0,W7
032EC:  MOV     1B10,W4
032EE:  MUL.UU  W4,#4,W0
032F0:  ADD     W0,W7,W0
032F2:  MOV     #B5A,W4
032F4:  ADD     W0,W4,W0
032F6:  MOV     [W0],W7
032F8:  MOV     1B56,W4
032FA:  MUL.UU  W4,#2,W0
032FC:  MOV     #AA6,W4
032FE:  ADD     W0,W4,W0
03300:  MOV     [W0],W8
03302:  MOV     W8,W4
03304:  MUL.UU  W4,#10,W8
03306:  MOV     1B12,W4
03308:  MUL.UU  W4,#4,W0
0330A:  ADD     W0,W8,W0
0330C:  MOV     #B5A,W4
0330E:  ADD     W0,W4,W0
03310:  MOV     [W0],W8
03312:  MOV     W7,1B72
03314:  MOV     W8,1B74
03316:  PUSH    1B52
03318:  POP     1B76
0331A:  PUSH    1B54
0331C:  POP     1B78
0331E:  CALL    23E2
03322:  ADD     W0,W6,W6
03324:  MOV     1B56,W4
03326:  MUL.UU  W4,#2,W0
03328:  MOV     #AA6,W4
0332A:  ADD     W0,W4,W0
0332C:  MOV     [W0],W7
0332E:  MOV     W7,W4
03330:  MUL.UU  W4,#10,W0
03332:  MOV     W0,W7
03334:  MOV     1B14,W4
03336:  MUL.UU  W4,#4,W0
03338:  ADD     W0,W7,W0
0333A:  MOV     #B5A,W4
0333C:  ADD     W0,W4,W0
0333E:  MOV     [W0],W7
03340:  MOV     1B56,W4
03342:  MUL.UU  W4,#2,W0
03344:  MOV     #AA6,W4
03346:  ADD     W0,W4,W0
03348:  MOV     [W0],W8
0334A:  MOV     W8,W4
0334C:  MUL.UU  W4,#10,W8
0334E:  MOV     1B16,W4
03350:  MUL.UU  W4,#4,W0
03352:  ADD     W0,W8,W0
03354:  MOV     #B5A,W4
03356:  ADD     W0,W4,W0
03358:  MOV     [W0],W8
0335A:  PUSH    1B4E
0335C:  POP     1B72
0335E:  PUSH    1B50
03360:  POP     1B74
03362:  MOV     W7,1B76
03364:  MOV     W8,1B78
03366:  CALL    23E2
0336A:  MOV     W0,W7
0336C:  MOV     1B56,W4
0336E:  MUL.UU  W4,#2,W0
03370:  MOV     #AA6,W4
03372:  ADD     W0,W4,W0
03374:  MOV     [W0],W8
03376:  MOV     W8,W4
03378:  MUL.UU  W4,#10,W8
0337A:  ADD     W8,#8,W8
0337C:  MOV     W8,W0
0337E:  MOV     #B5A,W4
03380:  ADD     W0,W4,W0
03382:  MOV     [W0],W8
03384:  MOV     1B56,W4
03386:  MUL.UU  W4,#2,W0
03388:  MOV     #AA6,W4
0338A:  ADD     W0,W4,W0
0338C:  MOV     [W0],W9
0338E:  MOV     W9,W4
03390:  MUL.UU  W4,#10,W0
03392:  MOV     W0,W9
03394:  ADD     W9,#C,W9
03396:  MOV     W9,W0
03398:  MOV     #B5A,W4
0339A:  ADD     W0,W4,W0
0339C:  MOV     [W0],W9
0339E:  MOV     W8,1B72
033A0:  MOV     W9,1B74
033A2:  PUSH    1B52
033A4:  POP     1B76
033A6:  PUSH    1B54
033A8:  POP     1B78
033AA:  CALL    23E2
033AE:  ADD     W0,W7,W0
033B0:  CP      W6,W0
033B2:  BRA     GE,3464
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
033B4:  MOV     AA2,W4
033B6:  MUL.UU  W4,#8,W0
033B8:  MOV     W0,W5
033BA:  MOV     #ABA,W4
033BC:  ADD     W5,W4,W6
033BE:  MOV     1B56,W4
033C0:  MUL.UU  W4,#2,W0
033C2:  MOV     #AA6,W4
033C4:  ADD     W0,W4,W0
033C6:  MOV     [W0],W7
033C8:  MOV     W7,W4
033CA:  MUL.UU  W4,#10,W0
033CC:  MOV     W0,W7
033CE:  MOV     #B5A,W4
033D0:  ADD     W7,W4,W0
033D2:  MOV     [W0++],[W6++]
033D4:  MOV     [W0++],[W6++]
033D6:  MOV     AA2,W4
033D8:  MUL.UU  W4,#8,W0
033DA:  MOV     W0,W5
033DC:  ADD     W5,#4,W5
033DE:  MOV     W5,W0
033E0:  MOV     #ABA,W4
033E2:  ADD     W0,W4,W5
033E4:  MOV     1B56,W4
033E6:  MUL.UU  W4,#2,W0
033E8:  MOV     #AA6,W4
033EA:  ADD     W0,W4,W0
033EC:  MOV     [W0],W6
033EE:  MOV     W6,W4
033F0:  MUL.UU  W4,#10,W6
033F2:  ADD     W6,#4,W6
033F4:  MOV     W6,W0
033F6:  MOV     #B5A,W4
033F8:  ADD     W0,W4,W0
033FA:  MOV     [W0++],[W5++]
033FC:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
033FE:  MOV     AA2,W4
03400:  ADD     W4,#1,W4
03402:  MOV     W4,W5
03404:  MOV     W5,W4
03406:  MUL.UU  W4,#8,W0
03408:  MOV     W0,W5
0340A:  MOV     #ABA,W4
0340C:  ADD     W5,W4,W6
0340E:  MOV     1B56,W4
03410:  MUL.UU  W4,#2,W0
03412:  MOV     #AA6,W4
03414:  ADD     W0,W4,W0
03416:  MOV     [W0],W7
03418:  MOV     W7,W4
0341A:  MUL.UU  W4,#10,W0
0341C:  MOV     W0,W7
0341E:  MOV     1B10,W4
03420:  MUL.UU  W4,#4,W0
03422:  ADD     W0,W7,W0
03424:  MOV     #B5A,W4
03426:  ADD     W0,W4,W0
03428:  MOV     [W0++],[W6++]
0342A:  MOV     [W0++],[W6++]
0342C:  MOV     AA2,W4
0342E:  ADD     W4,#1,W4
03430:  MOV     W4,W5
03432:  MOV     W5,W4
03434:  MUL.UU  W4,#8,W0
03436:  MOV     W0,W5
03438:  ADD     W5,#4,W5
0343A:  MOV     W5,W0
0343C:  MOV     #ABA,W4
0343E:  ADD     W0,W4,W5
03440:  MOV     1B56,W4
03442:  MUL.UU  W4,#2,W0
03444:  MOV     #AA6,W4
03446:  ADD     W0,W4,W0
03448:  MOV     [W0],W6
0344A:  MOV     W6,W4
0344C:  MUL.UU  W4,#10,W6
0344E:  MOV     1B12,W4
03450:  MUL.UU  W4,#4,W0
03452:  ADD     W0,W6,W0
03454:  MOV     #B5A,W4
03456:  ADD     W0,W4,W0
03458:  MOV     [W0++],[W5++]
0345A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
0345C:  MOV     #2,W4
0345E:  MOV     W4,AA0
.................... 		                } 
03460:  GOTO    3514
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03464:  MOV     AA2,W4
03466:  MUL.UU  W4,#8,W0
03468:  MOV     W0,W5
0346A:  MOV     #ABA,W4
0346C:  ADD     W5,W4,W6
0346E:  MOV     1B56,W4
03470:  MUL.UU  W4,#2,W0
03472:  MOV     #AA6,W4
03474:  ADD     W0,W4,W0
03476:  MOV     [W0],W7
03478:  MOV     W7,W4
0347A:  MUL.UU  W4,#10,W0
0347C:  MOV     W0,W7
0347E:  MOV     1B14,W4
03480:  MUL.UU  W4,#4,W0
03482:  ADD     W0,W7,W0
03484:  MOV     #B5A,W4
03486:  ADD     W0,W4,W0
03488:  MOV     [W0++],[W6++]
0348A:  MOV     [W0++],[W6++]
0348C:  MOV     AA2,W4
0348E:  MUL.UU  W4,#8,W0
03490:  MOV     W0,W5
03492:  ADD     W5,#4,W5
03494:  MOV     W5,W0
03496:  MOV     #ABA,W4
03498:  ADD     W0,W4,W5
0349A:  MOV     1B56,W4
0349C:  MUL.UU  W4,#2,W0
0349E:  MOV     #AA6,W4
034A0:  ADD     W0,W4,W0
034A2:  MOV     [W0],W6
034A4:  MOV     W6,W4
034A6:  MUL.UU  W4,#10,W6
034A8:  MOV     1B16,W4
034AA:  MUL.UU  W4,#4,W0
034AC:  ADD     W0,W6,W0
034AE:  MOV     #B5A,W4
034B0:  ADD     W0,W4,W0
034B2:  MOV     [W0++],[W5++]
034B4:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
034B6:  MOV     AA2,W4
034B8:  ADD     W4,#1,W4
034BA:  MOV     W4,W5
034BC:  MOV     W5,W4
034BE:  MUL.UU  W4,#8,W0
034C0:  MOV     W0,W5
034C2:  MOV     #ABA,W4
034C4:  ADD     W5,W4,W6
034C6:  MOV     1B56,W4
034C8:  MUL.UU  W4,#2,W0
034CA:  MOV     #AA6,W4
034CC:  ADD     W0,W4,W0
034CE:  MOV     [W0],W7
034D0:  MOV     W7,W4
034D2:  MUL.UU  W4,#10,W0
034D4:  MOV     W0,W7
034D6:  ADD     W7,#8,W7
034D8:  MOV     W7,W0
034DA:  MOV     #B5A,W4
034DC:  ADD     W0,W4,W0
034DE:  MOV     [W0++],[W6++]
034E0:  MOV     [W0++],[W6++]
034E2:  MOV     AA2,W4
034E4:  ADD     W4,#1,W4
034E6:  MOV     W4,W5
034E8:  MOV     W5,W4
034EA:  MUL.UU  W4,#8,W0
034EC:  MOV     W0,W5
034EE:  ADD     W5,#4,W5
034F0:  MOV     W5,W0
034F2:  MOV     #ABA,W4
034F4:  ADD     W0,W4,W5
034F6:  MOV     1B56,W4
034F8:  MUL.UU  W4,#2,W0
034FA:  MOV     #AA6,W4
034FC:  ADD     W0,W4,W0
034FE:  MOV     [W0],W6
03500:  MOV     W6,W4
03502:  MUL.UU  W4,#10,W6
03504:  ADD     W6,#C,W6
03506:  MOV     W6,W0
03508:  MOV     #B5A,W4
0350A:  ADD     W0,W4,W0
0350C:  MOV     [W0++],[W5++]
0350E:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03510:  MOV     #2,W4
03512:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
03514:  MOV     #1,W4
03516:  MOV     W4,A98
.................... 		            } 
03518:  GOTO    357A
.................... 		            else if (posEnd == 6 || posEnd == 7) 
0351C:  MOV     1B5A,W4
0351E:  CP      W4,#6
03520:  BRA     Z,3528
03522:  MOV     1B5A,W4
03524:  CP      W4,#7
03526:  BRA     NZ,357A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03528:  MOV     AA2,W4
0352A:  MUL.UU  W4,#8,W0
0352C:  MOV     W0,W5
0352E:  MOV     #ABA,W4
03530:  ADD     W5,W4,W6
03532:  MOV     1B56,W4
03534:  MUL.UU  W4,#2,W0
03536:  MOV     #AA6,W4
03538:  ADD     W0,W4,W0
0353A:  MOV     [W0],W7
0353C:  MOV     W7,W4
0353E:  MUL.UU  W4,#10,W0
03540:  MOV     W0,W7
03542:  MOV     #B5A,W4
03544:  ADD     W7,W4,W0
03546:  MOV     [W0++],[W6++]
03548:  MOV     [W0++],[W6++]
0354A:  MOV     AA2,W4
0354C:  MUL.UU  W4,#8,W0
0354E:  MOV     W0,W5
03550:  ADD     W5,#4,W5
03552:  MOV     W5,W0
03554:  MOV     #ABA,W4
03556:  ADD     W0,W4,W5
03558:  MOV     1B56,W4
0355A:  MUL.UU  W4,#2,W0
0355C:  MOV     #AA6,W4
0355E:  ADD     W0,W4,W0
03560:  MOV     [W0],W6
03562:  MOV     W6,W4
03564:  MUL.UU  W4,#10,W6
03566:  ADD     W6,#4,W6
03568:  MOV     W6,W0
0356A:  MOV     #B5A,W4
0356C:  ADD     W0,W4,W0
0356E:  MOV     [W0++],[W5++]
03570:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03572:  MOV     #1,W4
03574:  MOV     W4,AA0
.................... 		                path_found = true; 
03576:  MOV     #1,W4
03578:  MOV     W4,A98
.................... 		            } 
.................... 	            }	 
.................... 	            break; 
0357A:  GOTO    6324
....................  
.................... 	        case 2: 
....................  
.................... 	        	if(path_opposite) 
0357E:  CP0     A9C
03580:  BRA     Z,3862
.................... 	        	{ 
.................... 	        		if (posEnd == 5) 
03582:  MOV     1B5A,W4
03584:  CP      W4,#5
03586:  BRA     NZ,35E2
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03588:  MOV     AA2,W4
0358A:  MUL.UU  W4,#8,W0
0358C:  MOV     W0,W5
0358E:  MOV     #ABA,W4
03590:  ADD     W5,W4,W6
03592:  MOV     1B56,W4
03594:  MUL.UU  W4,#2,W0
03596:  MOV     #AA6,W4
03598:  ADD     W0,W4,W0
0359A:  MOV     [W0],W7
0359C:  MOV     W7,W4
0359E:  MUL.UU  W4,#10,W0
035A0:  MOV     W0,W7
035A2:  ADD     W7,#8,W7
035A4:  MOV     W7,W0
035A6:  MOV     #B5A,W4
035A8:  ADD     W0,W4,W0
035AA:  MOV     [W0++],[W6++]
035AC:  MOV     [W0++],[W6++]
035AE:  MOV     AA2,W4
035B0:  MUL.UU  W4,#8,W0
035B2:  MOV     W0,W5
035B4:  ADD     W5,#4,W5
035B6:  MOV     W5,W0
035B8:  MOV     #ABA,W4
035BA:  ADD     W0,W4,W5
035BC:  MOV     1B56,W4
035BE:  MUL.UU  W4,#2,W0
035C0:  MOV     #AA6,W4
035C2:  ADD     W0,W4,W0
035C4:  MOV     [W0],W6
035C6:  MOV     W6,W4
035C8:  MUL.UU  W4,#10,W6
035CA:  ADD     W6,#C,W6
035CC:  MOV     W6,W0
035CE:  MOV     #B5A,W4
035D0:  ADD     W0,W4,W0
035D2:  MOV     [W0++],[W5++]
035D4:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
035D6:  MOV     #1,W4
035D8:  MOV     W4,AA0
.................... 		                path_found = true; 
035DA:  MOV     #1,W4
035DC:  MOV     W4,A98
.................... 		            } 
035DE:  GOTO    385E
.................... 		            else if (posEnd == 6) 
035E2:  MOV     1B5A,W4
035E4:  CP      W4,#6
035E6:  BRA     NZ,37A4
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
035E8:  MOV     1B56,W4
035EA:  MUL.UU  W4,#2,W0
035EC:  MOV     #AA6,W4
035EE:  ADD     W0,W4,W0
035F0:  MOV     [W0],W5
035F2:  MOV     W5,W4
035F4:  MUL.UU  W4,#10,W0
035F6:  MOV     W0,W5
035F8:  MOV     #B5A,W4
035FA:  ADD     W5,W4,W0
035FC:  MOV     [W0],W6
035FE:  MOV     1B56,W4
03600:  MUL.UU  W4,#2,W0
03602:  MOV     #AA6,W4
03604:  ADD     W0,W4,W0
03606:  MOV     [W0],W7
03608:  MOV     W7,W4
0360A:  MUL.UU  W4,#10,W0
0360C:  MOV     W0,W7
0360E:  ADD     W7,#4,W7
03610:  MOV     W7,W0
03612:  MOV     #B5A,W4
03614:  ADD     W0,W4,W0
03616:  MOV     [W0],W7
03618:  PUSH    1B4E
0361A:  POP     1B72
0361C:  PUSH    1B50
0361E:  POP     1B74
03620:  MOV     W6,1B76
03622:  MOV     W7,1B78
03624:  CALL    23E2
03628:  MOV     W0,W6
0362A:  MOV     1B56,W4
0362C:  MUL.UU  W4,#2,W0
0362E:  MOV     #AA6,W4
03630:  ADD     W0,W4,W0
03632:  MOV     [W0],W7
03634:  MOV     W7,W4
03636:  MUL.UU  W4,#10,W0
03638:  MOV     W0,W7
0363A:  MOV     #B5A,W4
0363C:  ADD     W7,W4,W0
0363E:  MOV     [W0],W8
03640:  MOV     1B56,W4
03642:  MUL.UU  W4,#2,W0
03644:  MOV     #AA6,W4
03646:  ADD     W0,W4,W0
03648:  MOV     [W0],W9
0364A:  MOV     W9,W4
0364C:  MUL.UU  W4,#10,W0
0364E:  MOV     W0,W9
03650:  ADD     W9,#4,W9
03652:  MOV     W9,W0
03654:  MOV     #B5A,W4
03656:  ADD     W0,W4,W0
03658:  MOV     [W0],W9
0365A:  MOV     W8,1B72
0365C:  MOV     W9,1B74
0365E:  PUSH    1B52
03660:  POP     1B76
03662:  PUSH    1B54
03664:  POP     1B78
03666:  CALL    23E2
0366A:  ADD     W0,W6,W6
0366C:  MOV     1B56,W4
0366E:  MUL.UU  W4,#2,W0
03670:  MOV     #AA6,W4
03672:  ADD     W0,W4,W0
03674:  MOV     [W0],W8
03676:  MOV     W8,W4
03678:  MUL.UU  W4,#10,W8
0367A:  ADD     W8,#8,W8
0367C:  MOV     W8,W0
0367E:  MOV     #B5A,W4
03680:  ADD     W0,W4,W0
03682:  MOV     [W0],W8
03684:  MOV     1B56,W4
03686:  MUL.UU  W4,#2,W0
03688:  MOV     #AA6,W4
0368A:  ADD     W0,W4,W0
0368C:  MOV     [W0],W9
0368E:  MOV     W9,W4
03690:  MUL.UU  W4,#10,W0
03692:  MOV     W0,W9
03694:  ADD     W9,#C,W9
03696:  MOV     W9,W0
03698:  MOV     #B5A,W4
0369A:  ADD     W0,W4,W0
0369C:  MOV     [W0],W9
0369E:  PUSH    1B4E
036A0:  POP     1B72
036A2:  PUSH    1B50
036A4:  POP     1B74
036A6:  MOV     W8,1B76
036A8:  MOV     W9,1B78
036AA:  CALL    23E2
036AE:  MOV     W0,W8
036B0:  MOV     1B56,W4
036B2:  MUL.UU  W4,#2,W0
036B4:  MOV     #AA6,W4
036B6:  ADD     W0,W4,W0
036B8:  MOV     [W0],W9
036BA:  MOV     W9,W4
036BC:  MUL.UU  W4,#10,W0
036BE:  MOV     W0,W9
036C0:  ADD     W9,#8,W9
036C2:  MOV     W9,W0
036C4:  MOV     #B5A,W4
036C6:  ADD     W0,W4,W0
036C8:  MOV     [W0],W9
036CA:  MOV     1B56,W4
036CC:  MUL.UU  W4,#2,W0
036CE:  MOV     #AA6,W4
036D0:  ADD     W0,W4,W0
036D2:  MOV     [W0],W10
036D4:  MOV     W10,W4
036D6:  MUL.UU  W4,#10,W10
036D8:  ADD     W10,#C,W10
036DA:  MOV     W10,W0
036DC:  MOV     #B5A,W4
036DE:  ADD     W0,W4,W0
036E0:  MOV     [W0],W10
036E2:  MOV     W9,1B72
036E4:  MOV     W10,1B74
036E6:  PUSH    1B52
036E8:  POP     1B76
036EA:  PUSH    1B54
036EC:  POP     1B78
036EE:  CALL    23E2
036F2:  ADD     W0,W8,W0
036F4:  CP      W6,W0
036F6:  BRA     GE,374E
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
036F8:  MOV     AA2,W4
036FA:  MUL.UU  W4,#8,W0
036FC:  MOV     W0,W5
036FE:  MOV     #ABA,W4
03700:  ADD     W5,W4,W6
03702:  MOV     1B56,W4
03704:  MUL.UU  W4,#2,W0
03706:  MOV     #AA6,W4
03708:  ADD     W0,W4,W0
0370A:  MOV     [W0],W7
0370C:  MOV     W7,W4
0370E:  MUL.UU  W4,#10,W0
03710:  MOV     W0,W7
03712:  ADD     W7,#8,W7
03714:  MOV     W7,W0
03716:  MOV     #B5A,W4
03718:  ADD     W0,W4,W0
0371A:  MOV     [W0++],[W6++]
0371C:  MOV     [W0++],[W6++]
0371E:  MOV     AA2,W4
03720:  MUL.UU  W4,#8,W0
03722:  MOV     W0,W5
03724:  ADD     W5,#4,W5
03726:  MOV     W5,W0
03728:  MOV     #ABA,W4
0372A:  ADD     W0,W4,W5
0372C:  MOV     1B56,W4
0372E:  MUL.UU  W4,#2,W0
03730:  MOV     #AA6,W4
03732:  ADD     W0,W4,W0
03734:  MOV     [W0],W6
03736:  MOV     W6,W4
03738:  MUL.UU  W4,#10,W6
0373A:  ADD     W6,#C,W6
0373C:  MOV     W6,W0
0373E:  MOV     #B5A,W4
03740:  ADD     W0,W4,W0
03742:  MOV     [W0++],[W5++]
03744:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03746:  MOV     #1,W4
03748:  MOV     W4,AA0
.................... 		                } 
0374A:  GOTO    379C
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0374E:  MOV     AA2,W4
03750:  MUL.UU  W4,#8,W0
03752:  MOV     W0,W5
03754:  MOV     #ABA,W4
03756:  ADD     W5,W4,W6
03758:  MOV     1B56,W4
0375A:  MUL.UU  W4,#2,W0
0375C:  MOV     #AA6,W4
0375E:  ADD     W0,W4,W0
03760:  MOV     [W0],W7
03762:  MOV     W7,W4
03764:  MUL.UU  W4,#10,W0
03766:  MOV     W0,W7
03768:  MOV     #B5A,W4
0376A:  ADD     W7,W4,W0
0376C:  MOV     [W0++],[W6++]
0376E:  MOV     [W0++],[W6++]
03770:  MOV     AA2,W4
03772:  MUL.UU  W4,#8,W0
03774:  MOV     W0,W5
03776:  ADD     W5,#4,W5
03778:  MOV     W5,W0
0377A:  MOV     #ABA,W4
0377C:  ADD     W0,W4,W5
0377E:  MOV     1B56,W4
03780:  MUL.UU  W4,#2,W0
03782:  MOV     #AA6,W4
03784:  ADD     W0,W4,W0
03786:  MOV     [W0],W6
03788:  MOV     W6,W4
0378A:  MUL.UU  W4,#10,W6
0378C:  ADD     W6,#4,W6
0378E:  MOV     W6,W0
03790:  MOV     #B5A,W4
03792:  ADD     W0,W4,W0
03794:  MOV     [W0++],[W5++]
03796:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03798:  MOV     #1,W4
0379A:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
0379C:  MOV     #1,W4
0379E:  MOV     W4,A98
.................... 		            } 
037A0:  GOTO    385E
.................... 		            else if (posEnd == 7) 
037A4:  MOV     1B5A,W4
037A6:  CP      W4,#7
037A8:  BRA     NZ,385E
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
037AA:  MOV     AA2,W4
037AC:  MUL.UU  W4,#8,W0
037AE:  MOV     W0,W5
037B0:  MOV     #ABA,W4
037B2:  ADD     W5,W4,W6
037B4:  MOV     1B56,W4
037B6:  MUL.UU  W4,#2,W0
037B8:  MOV     #AA6,W4
037BA:  ADD     W0,W4,W0
037BC:  MOV     [W0],W7
037BE:  MOV     W7,W4
037C0:  MUL.UU  W4,#10,W0
037C2:  MOV     W0,W7
037C4:  ADD     W7,#8,W7
037C6:  MOV     W7,W0
037C8:  MOV     #B5A,W4
037CA:  ADD     W0,W4,W0
037CC:  MOV     [W0++],[W6++]
037CE:  MOV     [W0++],[W6++]
037D0:  MOV     AA2,W4
037D2:  MUL.UU  W4,#8,W0
037D4:  MOV     W0,W5
037D6:  ADD     W5,#4,W5
037D8:  MOV     W5,W0
037DA:  MOV     #ABA,W4
037DC:  ADD     W0,W4,W5
037DE:  MOV     1B56,W4
037E0:  MUL.UU  W4,#2,W0
037E2:  MOV     #AA6,W4
037E4:  ADD     W0,W4,W0
037E6:  MOV     [W0],W6
037E8:  MOV     W6,W4
037EA:  MUL.UU  W4,#10,W6
037EC:  ADD     W6,#C,W6
037EE:  MOV     W6,W0
037F0:  MOV     #B5A,W4
037F2:  ADD     W0,W4,W0
037F4:  MOV     [W0++],[W5++]
037F6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
037F8:  MOV     AA2,W4
037FA:  ADD     W4,#1,W4
037FC:  MOV     W4,W5
037FE:  MOV     W5,W4
03800:  MUL.UU  W4,#8,W0
03802:  MOV     W0,W5
03804:  MOV     #ABA,W4
03806:  ADD     W5,W4,W6
03808:  MOV     1B56,W4
0380A:  MUL.UU  W4,#2,W0
0380C:  MOV     #AA6,W4
0380E:  ADD     W0,W4,W0
03810:  MOV     [W0],W7
03812:  MOV     W7,W4
03814:  MUL.UU  W4,#10,W0
03816:  MOV     W0,W7
03818:  MOV     1B10,W4
0381A:  MUL.UU  W4,#4,W0
0381C:  ADD     W0,W7,W0
0381E:  MOV     #B5A,W4
03820:  ADD     W0,W4,W0
03822:  MOV     [W0++],[W6++]
03824:  MOV     [W0++],[W6++]
03826:  MOV     AA2,W4
03828:  ADD     W4,#1,W4
0382A:  MOV     W4,W5
0382C:  MOV     W5,W4
0382E:  MUL.UU  W4,#8,W0
03830:  MOV     W0,W5
03832:  ADD     W5,#4,W5
03834:  MOV     W5,W0
03836:  MOV     #ABA,W4
03838:  ADD     W0,W4,W5
0383A:  MOV     1B56,W4
0383C:  MUL.UU  W4,#2,W0
0383E:  MOV     #AA6,W4
03840:  ADD     W0,W4,W0
03842:  MOV     [W0],W6
03844:  MOV     W6,W4
03846:  MUL.UU  W4,#10,W6
03848:  MOV     1B12,W4
0384A:  MUL.UU  W4,#4,W0
0384C:  ADD     W0,W6,W0
0384E:  MOV     #B5A,W4
03850:  ADD     W0,W4,W0
03852:  MOV     [W0++],[W5++]
03854:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03856:  MOV     #2,W4
03858:  MOV     W4,AA0
.................... 		                path_found = true; 
0385A:  MOV     #1,W4
0385C:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
0385E:  GOTO    3ADC
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 5) 
03862:  MOV     1B5A,W4
03864:  CP      W4,#5
03866:  BRA     NZ,38C2
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03868:  MOV     AA2,W4
0386A:  MUL.UU  W4,#8,W0
0386C:  MOV     W0,W5
0386E:  MOV     #ABA,W4
03870:  ADD     W5,W4,W6
03872:  MOV     1B56,W4
03874:  MUL.UU  W4,#2,W0
03876:  MOV     #AA6,W4
03878:  ADD     W0,W4,W0
0387A:  MOV     [W0],W7
0387C:  MOV     W7,W4
0387E:  MUL.UU  W4,#10,W0
03880:  MOV     W0,W7
03882:  ADD     W7,#8,W7
03884:  MOV     W7,W0
03886:  MOV     #B5A,W4
03888:  ADD     W0,W4,W0
0388A:  MOV     [W0++],[W6++]
0388C:  MOV     [W0++],[W6++]
0388E:  MOV     AA2,W4
03890:  MUL.UU  W4,#8,W0
03892:  MOV     W0,W5
03894:  ADD     W5,#4,W5
03896:  MOV     W5,W0
03898:  MOV     #ABA,W4
0389A:  ADD     W0,W4,W5
0389C:  MOV     1B56,W4
0389E:  MUL.UU  W4,#2,W0
038A0:  MOV     #AA6,W4
038A2:  ADD     W0,W4,W0
038A4:  MOV     [W0],W6
038A6:  MOV     W6,W4
038A8:  MUL.UU  W4,#10,W6
038AA:  ADD     W6,#C,W6
038AC:  MOV     W6,W0
038AE:  MOV     #B5A,W4
038B0:  ADD     W0,W4,W0
038B2:  MOV     [W0++],[W5++]
038B4:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
038B6:  MOV     #1,W4
038B8:  MOV     W4,AA0
.................... 		                path_found = true; 
038BA:  MOV     #1,W4
038BC:  MOV     W4,A98
.................... 		            } 
038BE:  GOTO    3ADC
.................... 		            else if (posEnd == 6) 
038C2:  MOV     1B5A,W4
038C4:  CP      W4,#6
038C6:  BRA     NZ,3A84
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
038C8:  MOV     1B56,W4
038CA:  MUL.UU  W4,#2,W0
038CC:  MOV     #AA6,W4
038CE:  ADD     W0,W4,W0
038D0:  MOV     [W0],W5
038D2:  MOV     W5,W4
038D4:  MUL.UU  W4,#10,W0
038D6:  MOV     W0,W5
038D8:  MOV     #B5A,W4
038DA:  ADD     W5,W4,W0
038DC:  MOV     [W0],W6
038DE:  MOV     1B56,W4
038E0:  MUL.UU  W4,#2,W0
038E2:  MOV     #AA6,W4
038E4:  ADD     W0,W4,W0
038E6:  MOV     [W0],W7
038E8:  MOV     W7,W4
038EA:  MUL.UU  W4,#10,W0
038EC:  MOV     W0,W7
038EE:  ADD     W7,#4,W7
038F0:  MOV     W7,W0
038F2:  MOV     #B5A,W4
038F4:  ADD     W0,W4,W0
038F6:  MOV     [W0],W7
038F8:  PUSH    1B4E
038FA:  POP     1B72
038FC:  PUSH    1B50
038FE:  POP     1B74
03900:  MOV     W6,1B76
03902:  MOV     W7,1B78
03904:  CALL    23E2
03908:  MOV     W0,W6
0390A:  MOV     1B56,W4
0390C:  MUL.UU  W4,#2,W0
0390E:  MOV     #AA6,W4
03910:  ADD     W0,W4,W0
03912:  MOV     [W0],W7
03914:  MOV     W7,W4
03916:  MUL.UU  W4,#10,W0
03918:  MOV     W0,W7
0391A:  MOV     #B5A,W4
0391C:  ADD     W7,W4,W0
0391E:  MOV     [W0],W8
03920:  MOV     1B56,W4
03922:  MUL.UU  W4,#2,W0
03924:  MOV     #AA6,W4
03926:  ADD     W0,W4,W0
03928:  MOV     [W0],W9
0392A:  MOV     W9,W4
0392C:  MUL.UU  W4,#10,W0
0392E:  MOV     W0,W9
03930:  ADD     W9,#4,W9
03932:  MOV     W9,W0
03934:  MOV     #B5A,W4
03936:  ADD     W0,W4,W0
03938:  MOV     [W0],W9
0393A:  MOV     W8,1B72
0393C:  MOV     W9,1B74
0393E:  PUSH    1B52
03940:  POP     1B76
03942:  PUSH    1B54
03944:  POP     1B78
03946:  CALL    23E2
0394A:  ADD     W0,W6,W6
0394C:  MOV     1B56,W4
0394E:  MUL.UU  W4,#2,W0
03950:  MOV     #AA6,W4
03952:  ADD     W0,W4,W0
03954:  MOV     [W0],W8
03956:  MOV     W8,W4
03958:  MUL.UU  W4,#10,W8
0395A:  ADD     W8,#8,W8
0395C:  MOV     W8,W0
0395E:  MOV     #B5A,W4
03960:  ADD     W0,W4,W0
03962:  MOV     [W0],W8
03964:  MOV     1B56,W4
03966:  MUL.UU  W4,#2,W0
03968:  MOV     #AA6,W4
0396A:  ADD     W0,W4,W0
0396C:  MOV     [W0],W9
0396E:  MOV     W9,W4
03970:  MUL.UU  W4,#10,W0
03972:  MOV     W0,W9
03974:  ADD     W9,#C,W9
03976:  MOV     W9,W0
03978:  MOV     #B5A,W4
0397A:  ADD     W0,W4,W0
0397C:  MOV     [W0],W9
0397E:  PUSH    1B4E
03980:  POP     1B72
03982:  PUSH    1B50
03984:  POP     1B74
03986:  MOV     W8,1B76
03988:  MOV     W9,1B78
0398A:  CALL    23E2
0398E:  MOV     W0,W8
03990:  MOV     1B56,W4
03992:  MUL.UU  W4,#2,W0
03994:  MOV     #AA6,W4
03996:  ADD     W0,W4,W0
03998:  MOV     [W0],W9
0399A:  MOV     W9,W4
0399C:  MUL.UU  W4,#10,W0
0399E:  MOV     W0,W9
039A0:  ADD     W9,#8,W9
039A2:  MOV     W9,W0
039A4:  MOV     #B5A,W4
039A6:  ADD     W0,W4,W0
039A8:  MOV     [W0],W9
039AA:  MOV     1B56,W4
039AC:  MUL.UU  W4,#2,W0
039AE:  MOV     #AA6,W4
039B0:  ADD     W0,W4,W0
039B2:  MOV     [W0],W10
039B4:  MOV     W10,W4
039B6:  MUL.UU  W4,#10,W10
039B8:  ADD     W10,#C,W10
039BA:  MOV     W10,W0
039BC:  MOV     #B5A,W4
039BE:  ADD     W0,W4,W0
039C0:  MOV     [W0],W10
039C2:  MOV     W9,1B72
039C4:  MOV     W10,1B74
039C6:  PUSH    1B52
039C8:  POP     1B76
039CA:  PUSH    1B54
039CC:  POP     1B78
039CE:  CALL    23E2
039D2:  ADD     W0,W8,W0
039D4:  CP      W6,W0
039D6:  BRA     GE,3A2A
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
039D8:  MOV     AA2,W4
039DA:  MUL.UU  W4,#8,W0
039DC:  MOV     W0,W5
039DE:  MOV     #ABA,W4
039E0:  ADD     W5,W4,W6
039E2:  MOV     1B56,W4
039E4:  MUL.UU  W4,#2,W0
039E6:  MOV     #AA6,W4
039E8:  ADD     W0,W4,W0
039EA:  MOV     [W0],W7
039EC:  MOV     W7,W4
039EE:  MUL.UU  W4,#10,W0
039F0:  MOV     W0,W7
039F2:  MOV     #B5A,W4
039F4:  ADD     W7,W4,W0
039F6:  MOV     [W0++],[W6++]
039F8:  MOV     [W0++],[W6++]
039FA:  MOV     AA2,W4
039FC:  MUL.UU  W4,#8,W0
039FE:  MOV     W0,W5
03A00:  ADD     W5,#4,W5
03A02:  MOV     W5,W0
03A04:  MOV     #ABA,W4
03A06:  ADD     W0,W4,W5
03A08:  MOV     1B56,W4
03A0A:  MUL.UU  W4,#2,W0
03A0C:  MOV     #AA6,W4
03A0E:  ADD     W0,W4,W0
03A10:  MOV     [W0],W6
03A12:  MOV     W6,W4
03A14:  MUL.UU  W4,#10,W6
03A16:  ADD     W6,#4,W6
03A18:  MOV     W6,W0
03A1A:  MOV     #B5A,W4
03A1C:  ADD     W0,W4,W0
03A1E:  MOV     [W0++],[W5++]
03A20:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03A22:  MOV     #1,W4
03A24:  MOV     W4,AA0
.................... 		                } 
03A26:  GOTO    3A7C
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03A2A:  MOV     AA2,W4
03A2C:  MUL.UU  W4,#8,W0
03A2E:  MOV     W0,W5
03A30:  MOV     #ABA,W4
03A32:  ADD     W5,W4,W6
03A34:  MOV     1B56,W4
03A36:  MUL.UU  W4,#2,W0
03A38:  MOV     #AA6,W4
03A3A:  ADD     W0,W4,W0
03A3C:  MOV     [W0],W7
03A3E:  MOV     W7,W4
03A40:  MUL.UU  W4,#10,W0
03A42:  MOV     W0,W7
03A44:  ADD     W7,#8,W7
03A46:  MOV     W7,W0
03A48:  MOV     #B5A,W4
03A4A:  ADD     W0,W4,W0
03A4C:  MOV     [W0++],[W6++]
03A4E:  MOV     [W0++],[W6++]
03A50:  MOV     AA2,W4
03A52:  MUL.UU  W4,#8,W0
03A54:  MOV     W0,W5
03A56:  ADD     W5,#4,W5
03A58:  MOV     W5,W0
03A5A:  MOV     #ABA,W4
03A5C:  ADD     W0,W4,W5
03A5E:  MOV     1B56,W4
03A60:  MUL.UU  W4,#2,W0
03A62:  MOV     #AA6,W4
03A64:  ADD     W0,W4,W0
03A66:  MOV     [W0],W6
03A68:  MOV     W6,W4
03A6A:  MUL.UU  W4,#10,W6
03A6C:  ADD     W6,#C,W6
03A6E:  MOV     W6,W0
03A70:  MOV     #B5A,W4
03A72:  ADD     W0,W4,W0
03A74:  MOV     [W0++],[W5++]
03A76:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03A78:  MOV     #1,W4
03A7A:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
03A7C:  MOV     #1,W4
03A7E:  MOV     W4,A98
.................... 		            } 
03A80:  GOTO    3ADC
.................... 		            else if (posEnd == 7) 
03A84:  MOV     1B5A,W4
03A86:  CP      W4,#7
03A88:  BRA     NZ,3ADC
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03A8A:  MOV     AA2,W4
03A8C:  MUL.UU  W4,#8,W0
03A8E:  MOV     W0,W5
03A90:  MOV     #ABA,W4
03A92:  ADD     W5,W4,W6
03A94:  MOV     1B56,W4
03A96:  MUL.UU  W4,#2,W0
03A98:  MOV     #AA6,W4
03A9A:  ADD     W0,W4,W0
03A9C:  MOV     [W0],W7
03A9E:  MOV     W7,W4
03AA0:  MUL.UU  W4,#10,W0
03AA2:  MOV     W0,W7
03AA4:  MOV     #B5A,W4
03AA6:  ADD     W7,W4,W0
03AA8:  MOV     [W0++],[W6++]
03AAA:  MOV     [W0++],[W6++]
03AAC:  MOV     AA2,W4
03AAE:  MUL.UU  W4,#8,W0
03AB0:  MOV     W0,W5
03AB2:  ADD     W5,#4,W5
03AB4:  MOV     W5,W0
03AB6:  MOV     #ABA,W4
03AB8:  ADD     W0,W4,W5
03ABA:  MOV     1B56,W4
03ABC:  MUL.UU  W4,#2,W0
03ABE:  MOV     #AA6,W4
03AC0:  ADD     W0,W4,W0
03AC2:  MOV     [W0],W6
03AC4:  MOV     W6,W4
03AC6:  MUL.UU  W4,#10,W6
03AC8:  ADD     W6,#4,W6
03ACA:  MOV     W6,W0
03ACC:  MOV     #B5A,W4
03ACE:  ADD     W0,W4,W0
03AD0:  MOV     [W0++],[W5++]
03AD2:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03AD4:  MOV     #1,W4
03AD6:  MOV     W4,AA0
.................... 		                path_found = true; 
03AD8:  MOV     #1,W4
03ADA:  MOV     W4,A98
.................... 		            } 
.................... 		        } 
....................  
.................... 	            break; 
03ADC:  GOTO    6324
....................  
.................... 	        case 3: 
....................  
.................... 	        	if(path_opposite) 
03AE0:  CP0     A9C
03AE2:  BRA     Z,410A
.................... 	        	{ 
.................... 	        		if(posEnd == 5) 
03AE4:  MOV     1B5A,W4
03AE6:  CP      W4,#5
03AE8:  BRA     NZ,3BFC
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03AEA:  MOV     AA2,W4
03AEC:  MUL.UU  W4,#8,W0
03AEE:  MOV     W0,W5
03AF0:  MOV     #ABA,W4
03AF2:  ADD     W5,W4,W6
03AF4:  MOV     1B56,W4
03AF6:  MUL.UU  W4,#2,W0
03AF8:  MOV     #AA6,W4
03AFA:  ADD     W0,W4,W0
03AFC:  MOV     [W0],W7
03AFE:  MOV     W7,W4
03B00:  MUL.UU  W4,#10,W0
03B02:  MOV     W0,W7
03B04:  MOV     1B14,W4
03B06:  MUL.UU  W4,#4,W0
03B08:  ADD     W0,W7,W0
03B0A:  MOV     #B5A,W4
03B0C:  ADD     W0,W4,W0
03B0E:  MOV     [W0++],[W6++]
03B10:  MOV     [W0++],[W6++]
03B12:  MOV     AA2,W4
03B14:  MUL.UU  W4,#8,W0
03B16:  MOV     W0,W5
03B18:  ADD     W5,#4,W5
03B1A:  MOV     W5,W0
03B1C:  MOV     #ABA,W4
03B1E:  ADD     W0,W4,W5
03B20:  MOV     1B56,W4
03B22:  MUL.UU  W4,#2,W0
03B24:  MOV     #AA6,W4
03B26:  ADD     W0,W4,W0
03B28:  MOV     [W0],W6
03B2A:  MOV     W6,W4
03B2C:  MUL.UU  W4,#10,W6
03B2E:  MOV     1B16,W4
03B30:  MUL.UU  W4,#4,W0
03B32:  ADD     W0,W6,W0
03B34:  MOV     #B5A,W4
03B36:  ADD     W0,W4,W0
03B38:  MOV     [W0++],[W5++]
03B3A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03B3C:  MOV     AA2,W4
03B3E:  ADD     W4,#1,W4
03B40:  MOV     W4,W5
03B42:  MOV     W5,W4
03B44:  MUL.UU  W4,#8,W0
03B46:  MOV     W0,W5
03B48:  MOV     #ABA,W4
03B4A:  ADD     W5,W4,W6
03B4C:  MOV     1B56,W4
03B4E:  MUL.UU  W4,#2,W0
03B50:  MOV     #AA6,W4
03B52:  ADD     W0,W4,W0
03B54:  MOV     [W0],W7
03B56:  MOV     W7,W4
03B58:  MUL.UU  W4,#10,W0
03B5A:  MOV     W0,W7
03B5C:  MOV     #B5A,W4
03B5E:  ADD     W7,W4,W0
03B60:  MOV     [W0++],[W6++]
03B62:  MOV     [W0++],[W6++]
03B64:  MOV     AA2,W4
03B66:  ADD     W4,#1,W4
03B68:  MOV     W4,W5
03B6A:  MOV     W5,W4
03B6C:  MUL.UU  W4,#8,W0
03B6E:  MOV     W0,W5
03B70:  ADD     W5,#4,W5
03B72:  MOV     W5,W0
03B74:  MOV     #ABA,W4
03B76:  ADD     W0,W4,W5
03B78:  MOV     1B56,W4
03B7A:  MUL.UU  W4,#2,W0
03B7C:  MOV     #AA6,W4
03B7E:  ADD     W0,W4,W0
03B80:  MOV     [W0],W6
03B82:  MOV     W6,W4
03B84:  MUL.UU  W4,#10,W6
03B86:  ADD     W6,#4,W6
03B88:  MOV     W6,W0
03B8A:  MOV     #B5A,W4
03B8C:  ADD     W0,W4,W0
03B8E:  MOV     [W0++],[W5++]
03B90:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03B92:  MOV     AA2,W4
03B94:  ADD     W4,#2,W4
03B96:  MOV     W4,W5
03B98:  MOV     W5,W4
03B9A:  MUL.UU  W4,#8,W0
03B9C:  MOV     W0,W5
03B9E:  MOV     #ABA,W4
03BA0:  ADD     W5,W4,W6
03BA2:  MOV     1B56,W4
03BA4:  MUL.UU  W4,#2,W0
03BA6:  MOV     #AA6,W4
03BA8:  ADD     W0,W4,W0
03BAA:  MOV     [W0],W7
03BAC:  MOV     W7,W4
03BAE:  MUL.UU  W4,#10,W0
03BB0:  MOV     W0,W7
03BB2:  MOV     1B10,W4
03BB4:  MUL.UU  W4,#4,W0
03BB6:  ADD     W0,W7,W0
03BB8:  MOV     #B5A,W4
03BBA:  ADD     W0,W4,W0
03BBC:  MOV     [W0++],[W6++]
03BBE:  MOV     [W0++],[W6++]
03BC0:  MOV     AA2,W4
03BC2:  ADD     W4,#2,W4
03BC4:  MOV     W4,W5
03BC6:  MOV     W5,W4
03BC8:  MUL.UU  W4,#8,W0
03BCA:  MOV     W0,W5
03BCC:  ADD     W5,#4,W5
03BCE:  MOV     W5,W0
03BD0:  MOV     #ABA,W4
03BD2:  ADD     W0,W4,W5
03BD4:  MOV     1B56,W4
03BD6:  MUL.UU  W4,#2,W0
03BD8:  MOV     #AA6,W4
03BDA:  ADD     W0,W4,W0
03BDC:  MOV     [W0],W6
03BDE:  MOV     W6,W4
03BE0:  MUL.UU  W4,#10,W6
03BE2:  MOV     1B12,W4
03BE4:  MUL.UU  W4,#4,W0
03BE6:  ADD     W0,W6,W0
03BE8:  MOV     #B5A,W4
03BEA:  ADD     W0,W4,W0
03BEC:  MOV     [W0++],[W5++]
03BEE:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
03BF0:  MOV     #3,W4
03BF2:  MOV     W4,AA0
.................... 		                path_found = true; 
03BF4:  MOV     #1,W4
03BF6:  MOV     W4,A98
.................... 		            } 
03BF8:  GOTO    4106
.................... 		            else if (posEnd == 6) 
03BFC:  MOV     1B5A,W4
03BFE:  CP      W4,#6
03C00:  BRA     NZ,3CB6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03C02:  MOV     AA2,W4
03C04:  MUL.UU  W4,#8,W0
03C06:  MOV     W0,W5
03C08:  MOV     #ABA,W4
03C0A:  ADD     W5,W4,W6
03C0C:  MOV     1B56,W4
03C0E:  MUL.UU  W4,#2,W0
03C10:  MOV     #AA6,W4
03C12:  ADD     W0,W4,W0
03C14:  MOV     [W0],W7
03C16:  MOV     W7,W4
03C18:  MUL.UU  W4,#10,W0
03C1A:  MOV     W0,W7
03C1C:  MOV     1B14,W4
03C1E:  MUL.UU  W4,#4,W0
03C20:  ADD     W0,W7,W0
03C22:  MOV     #B5A,W4
03C24:  ADD     W0,W4,W0
03C26:  MOV     [W0++],[W6++]
03C28:  MOV     [W0++],[W6++]
03C2A:  MOV     AA2,W4
03C2C:  MUL.UU  W4,#8,W0
03C2E:  MOV     W0,W5
03C30:  ADD     W5,#4,W5
03C32:  MOV     W5,W0
03C34:  MOV     #ABA,W4
03C36:  ADD     W0,W4,W5
03C38:  MOV     1B56,W4
03C3A:  MUL.UU  W4,#2,W0
03C3C:  MOV     #AA6,W4
03C3E:  ADD     W0,W4,W0
03C40:  MOV     [W0],W6
03C42:  MOV     W6,W4
03C44:  MUL.UU  W4,#10,W6
03C46:  MOV     1B16,W4
03C48:  MUL.UU  W4,#4,W0
03C4A:  ADD     W0,W6,W0
03C4C:  MOV     #B5A,W4
03C4E:  ADD     W0,W4,W0
03C50:  MOV     [W0++],[W5++]
03C52:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03C54:  MOV     AA2,W4
03C56:  ADD     W4,#1,W4
03C58:  MOV     W4,W5
03C5A:  MOV     W5,W4
03C5C:  MUL.UU  W4,#8,W0
03C5E:  MOV     W0,W5
03C60:  MOV     #ABA,W4
03C62:  ADD     W5,W4,W6
03C64:  MOV     1B56,W4
03C66:  MUL.UU  W4,#2,W0
03C68:  MOV     #AA6,W4
03C6A:  ADD     W0,W4,W0
03C6C:  MOV     [W0],W7
03C6E:  MOV     W7,W4
03C70:  MUL.UU  W4,#10,W0
03C72:  MOV     W0,W7
03C74:  MOV     #B5A,W4
03C76:  ADD     W7,W4,W0
03C78:  MOV     [W0++],[W6++]
03C7A:  MOV     [W0++],[W6++]
03C7C:  MOV     AA2,W4
03C7E:  ADD     W4,#1,W4
03C80:  MOV     W4,W5
03C82:  MOV     W5,W4
03C84:  MUL.UU  W4,#8,W0
03C86:  MOV     W0,W5
03C88:  ADD     W5,#4,W5
03C8A:  MOV     W5,W0
03C8C:  MOV     #ABA,W4
03C8E:  ADD     W0,W4,W5
03C90:  MOV     1B56,W4
03C92:  MUL.UU  W4,#2,W0
03C94:  MOV     #AA6,W4
03C96:  ADD     W0,W4,W0
03C98:  MOV     [W0],W6
03C9A:  MOV     W6,W4
03C9C:  MUL.UU  W4,#10,W6
03C9E:  ADD     W6,#4,W6
03CA0:  MOV     W6,W0
03CA2:  MOV     #B5A,W4
03CA4:  ADD     W0,W4,W0
03CA6:  MOV     [W0++],[W5++]
03CA8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03CAA:  MOV     #2,W4
03CAC:  MOV     W4,AA0
.................... 		                path_found = true; 
03CAE:  MOV     #1,W4
03CB0:  MOV     W4,A98
.................... 		            } 
03CB2:  GOTO    4106
.................... 		            else if (posEnd == 7) 
03CB6:  MOV     1B5A,W4
03CB8:  CP      W4,#7
03CBA:  BRA     NZ,3F3A
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
03CBC:  MOV     1B56,W4
03CBE:  MUL.UU  W4,#2,W0
03CC0:  MOV     #AA6,W4
03CC2:  ADD     W0,W4,W0
03CC4:  MOV     [W0],W5
03CC6:  MOV     W5,W4
03CC8:  MUL.UU  W4,#10,W0
03CCA:  MOV     W0,W5
03CCC:  MOV     1B14,W4
03CCE:  MUL.UU  W4,#4,W0
03CD0:  ADD     W0,W5,W0
03CD2:  MOV     #B5A,W4
03CD4:  ADD     W0,W4,W0
03CD6:  MOV     [W0],W5
03CD8:  MOV     1B56,W4
03CDA:  MUL.UU  W4,#2,W0
03CDC:  MOV     #AA6,W4
03CDE:  ADD     W0,W4,W0
03CE0:  MOV     [W0],W6
03CE2:  MOV     W6,W4
03CE4:  MUL.UU  W4,#10,W6
03CE6:  MOV     1B16,W4
03CE8:  MUL.UU  W4,#4,W0
03CEA:  ADD     W0,W6,W0
03CEC:  MOV     #B5A,W4
03CEE:  ADD     W0,W4,W0
03CF0:  MOV     [W0],W6
03CF2:  PUSH    1B4E
03CF4:  POP     1B72
03CF6:  PUSH    1B50
03CF8:  POP     1B74
03CFA:  MOV     W5,1B76
03CFC:  MOV     W6,1B78
03CFE:  CALL    23E2
03D02:  MOV     W0,W5
03D04:  MOV     1B56,W4
03D06:  MUL.UU  W4,#2,W0
03D08:  MOV     #AA6,W4
03D0A:  ADD     W0,W4,W0
03D0C:  MOV     [W0],W6
03D0E:  MOV     W6,W4
03D10:  MUL.UU  W4,#10,W6
03D12:  MOV     #B5A,W4
03D14:  ADD     W6,W4,W0
03D16:  MOV     [W0],W7
03D18:  MOV     1B56,W4
03D1A:  MUL.UU  W4,#2,W0
03D1C:  MOV     #AA6,W4
03D1E:  ADD     W0,W4,W0
03D20:  MOV     [W0],W8
03D22:  MOV     W8,W4
03D24:  MUL.UU  W4,#10,W8
03D26:  ADD     W8,#4,W8
03D28:  MOV     W8,W0
03D2A:  MOV     #B5A,W4
03D2C:  ADD     W0,W4,W0
03D2E:  MOV     [W0],W8
03D30:  MOV     W7,1B72
03D32:  MOV     W8,1B74
03D34:  PUSH    1B52
03D36:  POP     1B76
03D38:  PUSH    1B54
03D3A:  POP     1B78
03D3C:  CALL    23E2
03D40:  ADD     W0,W5,W5
03D42:  MOV     1B56,W4
03D44:  MUL.UU  W4,#2,W0
03D46:  MOV     #AA6,W4
03D48:  ADD     W0,W4,W0
03D4A:  MOV     [W0],W7
03D4C:  MOV     W7,W4
03D4E:  MUL.UU  W4,#10,W0
03D50:  MOV     W0,W7
03D52:  ADD     W7,#8,W7
03D54:  MOV     W7,W0
03D56:  MOV     #B5A,W4
03D58:  ADD     W0,W4,W0
03D5A:  MOV     [W0],W7
03D5C:  MOV     1B56,W4
03D5E:  MUL.UU  W4,#2,W0
03D60:  MOV     #AA6,W4
03D62:  ADD     W0,W4,W0
03D64:  MOV     [W0],W8
03D66:  MOV     W8,W4
03D68:  MUL.UU  W4,#10,W8
03D6A:  ADD     W8,#C,W8
03D6C:  MOV     W8,W0
03D6E:  MOV     #B5A,W4
03D70:  ADD     W0,W4,W0
03D72:  MOV     [W0],W8
03D74:  PUSH    1B4E
03D76:  POP     1B72
03D78:  PUSH    1B50
03D7A:  POP     1B74
03D7C:  MOV     W7,1B76
03D7E:  MOV     W8,1B78
03D80:  CALL    23E2
03D84:  MOV     W0,W7
03D86:  MOV     1B56,W4
03D88:  MUL.UU  W4,#2,W0
03D8A:  MOV     #AA6,W4
03D8C:  ADD     W0,W4,W0
03D8E:  MOV     [W0],W8
03D90:  MOV     W8,W4
03D92:  MUL.UU  W4,#10,W8
03D94:  MOV     1B10,W4
03D96:  MUL.UU  W4,#4,W0
03D98:  ADD     W0,W8,W0
03D9A:  MOV     #B5A,W4
03D9C:  ADD     W0,W4,W0
03D9E:  MOV     [W0],W8
03DA0:  MOV     1B56,W4
03DA2:  MUL.UU  W4,#2,W0
03DA4:  MOV     #AA6,W4
03DA6:  ADD     W0,W4,W0
03DA8:  MOV     [W0],W9
03DAA:  MOV     W9,W4
03DAC:  MUL.UU  W4,#10,W0
03DAE:  MOV     W0,W9
03DB0:  MOV     1B12,W4
03DB2:  MUL.UU  W4,#4,W0
03DB4:  ADD     W0,W9,W0
03DB6:  MOV     #B5A,W4
03DB8:  ADD     W0,W4,W0
03DBA:  MOV     [W0],W9
03DBC:  MOV     W8,1B72
03DBE:  MOV     W9,1B74
03DC0:  PUSH    1B52
03DC2:  POP     1B76
03DC4:  PUSH    1B54
03DC6:  POP     1B78
03DC8:  CALL    23E2
03DCC:  ADD     W0,W7,W0
03DCE:  CP      W5,W0
03DD0:  BRA     GE,3E86
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03DD2:  MOV     AA2,W4
03DD4:  MUL.UU  W4,#8,W0
03DD6:  MOV     W0,W5
03DD8:  MOV     #ABA,W4
03DDA:  ADD     W5,W4,W6
03DDC:  MOV     1B56,W4
03DDE:  MUL.UU  W4,#2,W0
03DE0:  MOV     #AA6,W4
03DE2:  ADD     W0,W4,W0
03DE4:  MOV     [W0],W7
03DE6:  MOV     W7,W4
03DE8:  MUL.UU  W4,#10,W0
03DEA:  MOV     W0,W7
03DEC:  ADD     W7,#8,W7
03DEE:  MOV     W7,W0
03DF0:  MOV     #B5A,W4
03DF2:  ADD     W0,W4,W0
03DF4:  MOV     [W0++],[W6++]
03DF6:  MOV     [W0++],[W6++]
03DF8:  MOV     AA2,W4
03DFA:  MUL.UU  W4,#8,W0
03DFC:  MOV     W0,W5
03DFE:  ADD     W5,#4,W5
03E00:  MOV     W5,W0
03E02:  MOV     #ABA,W4
03E04:  ADD     W0,W4,W5
03E06:  MOV     1B56,W4
03E08:  MUL.UU  W4,#2,W0
03E0A:  MOV     #AA6,W4
03E0C:  ADD     W0,W4,W0
03E0E:  MOV     [W0],W6
03E10:  MOV     W6,W4
03E12:  MUL.UU  W4,#10,W6
03E14:  ADD     W6,#C,W6
03E16:  MOV     W6,W0
03E18:  MOV     #B5A,W4
03E1A:  ADD     W0,W4,W0
03E1C:  MOV     [W0++],[W5++]
03E1E:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03E20:  MOV     AA2,W4
03E22:  ADD     W4,#1,W4
03E24:  MOV     W4,W5
03E26:  MOV     W5,W4
03E28:  MUL.UU  W4,#8,W0
03E2A:  MOV     W0,W5
03E2C:  MOV     #ABA,W4
03E2E:  ADD     W5,W4,W6
03E30:  MOV     1B56,W4
03E32:  MUL.UU  W4,#2,W0
03E34:  MOV     #AA6,W4
03E36:  ADD     W0,W4,W0
03E38:  MOV     [W0],W7
03E3A:  MOV     W7,W4
03E3C:  MUL.UU  W4,#10,W0
03E3E:  MOV     W0,W7
03E40:  MOV     1B10,W4
03E42:  MUL.UU  W4,#4,W0
03E44:  ADD     W0,W7,W0
03E46:  MOV     #B5A,W4
03E48:  ADD     W0,W4,W0
03E4A:  MOV     [W0++],[W6++]
03E4C:  MOV     [W0++],[W6++]
03E4E:  MOV     AA2,W4
03E50:  ADD     W4,#1,W4
03E52:  MOV     W4,W5
03E54:  MOV     W5,W4
03E56:  MUL.UU  W4,#8,W0
03E58:  MOV     W0,W5
03E5A:  ADD     W5,#4,W5
03E5C:  MOV     W5,W0
03E5E:  MOV     #ABA,W4
03E60:  ADD     W0,W4,W5
03E62:  MOV     1B56,W4
03E64:  MUL.UU  W4,#2,W0
03E66:  MOV     #AA6,W4
03E68:  ADD     W0,W4,W0
03E6A:  MOV     [W0],W6
03E6C:  MOV     W6,W4
03E6E:  MUL.UU  W4,#10,W6
03E70:  MOV     1B12,W4
03E72:  MUL.UU  W4,#4,W0
03E74:  ADD     W0,W6,W0
03E76:  MOV     #B5A,W4
03E78:  ADD     W0,W4,W0
03E7A:  MOV     [W0++],[W5++]
03E7C:  MOV     [W0++],[W5++]
.................... 		                     
.................... 		                    relay_point_number = 2; 
03E7E:  MOV     #2,W4
03E80:  MOV     W4,AA0
.................... 		                } 
03E82:  GOTO    3F32
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03E86:  MOV     AA2,W4
03E88:  MUL.UU  W4,#8,W0
03E8A:  MOV     W0,W5
03E8C:  MOV     #ABA,W4
03E8E:  ADD     W5,W4,W6
03E90:  MOV     1B56,W4
03E92:  MUL.UU  W4,#2,W0
03E94:  MOV     #AA6,W4
03E96:  ADD     W0,W4,W0
03E98:  MOV     [W0],W7
03E9A:  MOV     W7,W4
03E9C:  MUL.UU  W4,#10,W0
03E9E:  MOV     W0,W7
03EA0:  MOV     1B14,W4
03EA2:  MUL.UU  W4,#4,W0
03EA4:  ADD     W0,W7,W0
03EA6:  MOV     #B5A,W4
03EA8:  ADD     W0,W4,W0
03EAA:  MOV     [W0++],[W6++]
03EAC:  MOV     [W0++],[W6++]
03EAE:  MOV     AA2,W4
03EB0:  MUL.UU  W4,#8,W0
03EB2:  MOV     W0,W5
03EB4:  ADD     W5,#4,W5
03EB6:  MOV     W5,W0
03EB8:  MOV     #ABA,W4
03EBA:  ADD     W0,W4,W5
03EBC:  MOV     1B56,W4
03EBE:  MUL.UU  W4,#2,W0
03EC0:  MOV     #AA6,W4
03EC2:  ADD     W0,W4,W0
03EC4:  MOV     [W0],W6
03EC6:  MOV     W6,W4
03EC8:  MUL.UU  W4,#10,W6
03ECA:  MOV     1B16,W4
03ECC:  MUL.UU  W4,#4,W0
03ECE:  ADD     W0,W6,W0
03ED0:  MOV     #B5A,W4
03ED2:  ADD     W0,W4,W0
03ED4:  MOV     [W0++],[W5++]
03ED6:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03ED8:  MOV     AA2,W4
03EDA:  ADD     W4,#1,W4
03EDC:  MOV     W4,W5
03EDE:  MOV     W5,W4
03EE0:  MUL.UU  W4,#8,W0
03EE2:  MOV     W0,W5
03EE4:  MOV     #ABA,W4
03EE6:  ADD     W5,W4,W6
03EE8:  MOV     1B56,W4
03EEA:  MUL.UU  W4,#2,W0
03EEC:  MOV     #AA6,W4
03EEE:  ADD     W0,W4,W0
03EF0:  MOV     [W0],W7
03EF2:  MOV     W7,W4
03EF4:  MUL.UU  W4,#10,W0
03EF6:  MOV     W0,W7
03EF8:  MOV     #B5A,W4
03EFA:  ADD     W7,W4,W0
03EFC:  MOV     [W0++],[W6++]
03EFE:  MOV     [W0++],[W6++]
03F00:  MOV     AA2,W4
03F02:  ADD     W4,#1,W4
03F04:  MOV     W4,W5
03F06:  MOV     W5,W4
03F08:  MUL.UU  W4,#8,W0
03F0A:  MOV     W0,W5
03F0C:  ADD     W5,#4,W5
03F0E:  MOV     W5,W0
03F10:  MOV     #ABA,W4
03F12:  ADD     W0,W4,W5
03F14:  MOV     1B56,W4
03F16:  MUL.UU  W4,#2,W0
03F18:  MOV     #AA6,W4
03F1A:  ADD     W0,W4,W0
03F1C:  MOV     [W0],W6
03F1E:  MOV     W6,W4
03F20:  MUL.UU  W4,#10,W6
03F22:  ADD     W6,#4,W6
03F24:  MOV     W6,W0
03F26:  MOV     #B5A,W4
03F28:  ADD     W0,W4,W0
03F2A:  MOV     [W0++],[W5++]
03F2C:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03F2E:  MOV     #2,W4
03F30:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
03F32:  MOV     #1,W4
03F34:  MOV     W4,A98
.................... 		            } 
03F36:  GOTO    4106
.................... 		            else if (posEnd == 0) 
03F3A:  CP0     1B5A
03F3C:  BRA     NZ,3FF6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03F3E:  MOV     AA2,W4
03F40:  MUL.UU  W4,#8,W0
03F42:  MOV     W0,W5
03F44:  MOV     #ABA,W4
03F46:  ADD     W5,W4,W6
03F48:  MOV     1B56,W4
03F4A:  MUL.UU  W4,#2,W0
03F4C:  MOV     #AA6,W4
03F4E:  ADD     W0,W4,W0
03F50:  MOV     [W0],W7
03F52:  MOV     W7,W4
03F54:  MUL.UU  W4,#10,W0
03F56:  MOV     W0,W7
03F58:  ADD     W7,#8,W7
03F5A:  MOV     W7,W0
03F5C:  MOV     #B5A,W4
03F5E:  ADD     W0,W4,W0
03F60:  MOV     [W0++],[W6++]
03F62:  MOV     [W0++],[W6++]
03F64:  MOV     AA2,W4
03F66:  MUL.UU  W4,#8,W0
03F68:  MOV     W0,W5
03F6A:  ADD     W5,#4,W5
03F6C:  MOV     W5,W0
03F6E:  MOV     #ABA,W4
03F70:  ADD     W0,W4,W5
03F72:  MOV     1B56,W4
03F74:  MUL.UU  W4,#2,W0
03F76:  MOV     #AA6,W4
03F78:  ADD     W0,W4,W0
03F7A:  MOV     [W0],W6
03F7C:  MOV     W6,W4
03F7E:  MUL.UU  W4,#10,W6
03F80:  ADD     W6,#C,W6
03F82:  MOV     W6,W0
03F84:  MOV     #B5A,W4
03F86:  ADD     W0,W4,W0
03F88:  MOV     [W0++],[W5++]
03F8A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03F8C:  MOV     AA2,W4
03F8E:  ADD     W4,#1,W4
03F90:  MOV     W4,W5
03F92:  MOV     W5,W4
03F94:  MUL.UU  W4,#8,W0
03F96:  MOV     W0,W5
03F98:  MOV     #ABA,W4
03F9A:  ADD     W5,W4,W6
03F9C:  MOV     1B56,W4
03F9E:  MUL.UU  W4,#2,W0
03FA0:  MOV     #AA6,W4
03FA2:  ADD     W0,W4,W0
03FA4:  MOV     [W0],W7
03FA6:  MOV     W7,W4
03FA8:  MUL.UU  W4,#10,W0
03FAA:  MOV     W0,W7
03FAC:  MOV     1B10,W4
03FAE:  MUL.UU  W4,#4,W0
03FB0:  ADD     W0,W7,W0
03FB2:  MOV     #B5A,W4
03FB4:  ADD     W0,W4,W0
03FB6:  MOV     [W0++],[W6++]
03FB8:  MOV     [W0++],[W6++]
03FBA:  MOV     AA2,W4
03FBC:  ADD     W4,#1,W4
03FBE:  MOV     W4,W5
03FC0:  MOV     W5,W4
03FC2:  MUL.UU  W4,#8,W0
03FC4:  MOV     W0,W5
03FC6:  ADD     W5,#4,W5
03FC8:  MOV     W5,W0
03FCA:  MOV     #ABA,W4
03FCC:  ADD     W0,W4,W5
03FCE:  MOV     1B56,W4
03FD0:  MUL.UU  W4,#2,W0
03FD2:  MOV     #AA6,W4
03FD4:  ADD     W0,W4,W0
03FD6:  MOV     [W0],W6
03FD8:  MOV     W6,W4
03FDA:  MUL.UU  W4,#10,W6
03FDC:  MOV     1B12,W4
03FDE:  MUL.UU  W4,#4,W0
03FE0:  ADD     W0,W6,W0
03FE2:  MOV     #B5A,W4
03FE4:  ADD     W0,W4,W0
03FE6:  MOV     [W0++],[W5++]
03FE8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03FEA:  MOV     #2,W4
03FEC:  MOV     W4,AA0
.................... 		                path_found = true; 
03FEE:  MOV     #1,W4
03FF0:  MOV     W4,A98
.................... 		            } 
03FF2:  GOTO    4106
.................... 		            else if (posEnd == 1) 
03FF6:  MOV     1B5A,W4
03FF8:  CP      W4,#1
03FFA:  BRA     NZ,4106
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03FFC:  MOV     AA2,W4
03FFE:  MUL.UU  W4,#8,W0
04000:  MOV     W0,W5
04002:  MOV     #ABA,W4
04004:  ADD     W5,W4,W6
04006:  MOV     1B56,W4
04008:  MUL.UU  W4,#2,W0
0400A:  MOV     #AA6,W4
0400C:  ADD     W0,W4,W0
0400E:  MOV     [W0],W7
04010:  MOV     W7,W4
04012:  MUL.UU  W4,#10,W0
04014:  MOV     W0,W7
04016:  ADD     W7,#8,W7
04018:  MOV     W7,W0
0401A:  MOV     #B5A,W4
0401C:  ADD     W0,W4,W0
0401E:  MOV     [W0++],[W6++]
04020:  MOV     [W0++],[W6++]
04022:  MOV     AA2,W4
04024:  MUL.UU  W4,#8,W0
04026:  MOV     W0,W5
04028:  ADD     W5,#4,W5
0402A:  MOV     W5,W0
0402C:  MOV     #ABA,W4
0402E:  ADD     W0,W4,W5
04030:  MOV     1B56,W4
04032:  MUL.UU  W4,#2,W0
04034:  MOV     #AA6,W4
04036:  ADD     W0,W4,W0
04038:  MOV     [W0],W6
0403A:  MOV     W6,W4
0403C:  MUL.UU  W4,#10,W6
0403E:  ADD     W6,#C,W6
04040:  MOV     W6,W0
04042:  MOV     #B5A,W4
04044:  ADD     W0,W4,W0
04046:  MOV     [W0++],[W5++]
04048:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0404A:  MOV     AA2,W4
0404C:  ADD     W4,#1,W4
0404E:  MOV     W4,W5
04050:  MOV     W5,W4
04052:  MUL.UU  W4,#8,W0
04054:  MOV     W0,W5
04056:  MOV     #ABA,W4
04058:  ADD     W5,W4,W6
0405A:  MOV     1B56,W4
0405C:  MUL.UU  W4,#2,W0
0405E:  MOV     #AA6,W4
04060:  ADD     W0,W4,W0
04062:  MOV     [W0],W7
04064:  MOV     W7,W4
04066:  MUL.UU  W4,#10,W0
04068:  MOV     W0,W7
0406A:  MOV     1B10,W4
0406C:  MUL.UU  W4,#4,W0
0406E:  ADD     W0,W7,W0
04070:  MOV     #B5A,W4
04072:  ADD     W0,W4,W0
04074:  MOV     [W0++],[W6++]
04076:  MOV     [W0++],[W6++]
04078:  MOV     AA2,W4
0407A:  ADD     W4,#1,W4
0407C:  MOV     W4,W5
0407E:  MOV     W5,W4
04080:  MUL.UU  W4,#8,W0
04082:  MOV     W0,W5
04084:  ADD     W5,#4,W5
04086:  MOV     W5,W0
04088:  MOV     #ABA,W4
0408A:  ADD     W0,W4,W5
0408C:  MOV     1B56,W4
0408E:  MUL.UU  W4,#2,W0
04090:  MOV     #AA6,W4
04092:  ADD     W0,W4,W0
04094:  MOV     [W0],W6
04096:  MOV     W6,W4
04098:  MUL.UU  W4,#10,W6
0409A:  MOV     1B12,W4
0409C:  MUL.UU  W4,#4,W0
0409E:  ADD     W0,W6,W0
040A0:  MOV     #B5A,W4
040A2:  ADD     W0,W4,W0
040A4:  MOV     [W0++],[W5++]
040A6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y1]; 
040A8:  MOV     AA2,W4
040AA:  ADD     W4,#2,W4
040AC:  MOV     W4,W5
040AE:  MOV     W5,W4
040B0:  MUL.UU  W4,#8,W0
040B2:  MOV     W0,W5
040B4:  MOV     #ABA,W4
040B6:  ADD     W5,W4,W6
040B8:  MOV     1B56,W4
040BA:  MUL.UU  W4,#2,W0
040BC:  MOV     #AA6,W4
040BE:  ADD     W0,W4,W0
040C0:  MOV     [W0],W7
040C2:  MOV     W7,W4
040C4:  MUL.UU  W4,#10,W0
040C6:  MOV     W0,W7
040C8:  MOV     #B5A,W4
040CA:  ADD     W7,W4,W0
040CC:  MOV     [W0++],[W6++]
040CE:  MOV     [W0++],[W6++]
040D0:  MOV     AA2,W4
040D2:  ADD     W4,#2,W4
040D4:  MOV     W4,W5
040D6:  MOV     W5,W4
040D8:  MUL.UU  W4,#8,W0
040DA:  MOV     W0,W5
040DC:  ADD     W5,#4,W5
040DE:  MOV     W5,W0
040E0:  MOV     #ABA,W4
040E2:  ADD     W0,W4,W5
040E4:  MOV     1B56,W4
040E6:  MUL.UU  W4,#2,W0
040E8:  MOV     #AA6,W4
040EA:  ADD     W0,W4,W0
040EC:  MOV     [W0],W6
040EE:  MOV     W6,W4
040F0:  MUL.UU  W4,#10,W6
040F2:  ADD     W6,#4,W6
040F4:  MOV     W6,W0
040F6:  MOV     #B5A,W4
040F8:  ADD     W0,W4,W0
040FA:  MOV     [W0++],[W5++]
040FC:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
040FE:  MOV     #3,W4
04100:  MOV     W4,AA0
.................... 		                path_found = true; 
04102:  MOV     #1,W4
04104:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
04106:  GOTO    4458
.................... 	        	else 
.................... 	        	{ 
.................... 	        		if(posEnd == 5 || posEnd == 6) 
0410A:  MOV     1B5A,W4
0410C:  CP      W4,#5
0410E:  BRA     Z,4116
04110:  MOV     1B5A,W4
04112:  CP      W4,#6
04114:  BRA     NZ,4170
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04116:  MOV     AA2,W4
04118:  MUL.UU  W4,#8,W0
0411A:  MOV     W0,W5
0411C:  MOV     #ABA,W4
0411E:  ADD     W5,W4,W6
04120:  MOV     1B56,W4
04122:  MUL.UU  W4,#2,W0
04124:  MOV     #AA6,W4
04126:  ADD     W0,W4,W0
04128:  MOV     [W0],W7
0412A:  MOV     W7,W4
0412C:  MUL.UU  W4,#10,W0
0412E:  MOV     W0,W7
04130:  ADD     W7,#8,W7
04132:  MOV     W7,W0
04134:  MOV     #B5A,W4
04136:  ADD     W0,W4,W0
04138:  MOV     [W0++],[W6++]
0413A:  MOV     [W0++],[W6++]
0413C:  MOV     AA2,W4
0413E:  MUL.UU  W4,#8,W0
04140:  MOV     W0,W5
04142:  ADD     W5,#4,W5
04144:  MOV     W5,W0
04146:  MOV     #ABA,W4
04148:  ADD     W0,W4,W5
0414A:  MOV     1B56,W4
0414C:  MUL.UU  W4,#2,W0
0414E:  MOV     #AA6,W4
04150:  ADD     W0,W4,W0
04152:  MOV     [W0],W6
04154:  MOV     W6,W4
04156:  MUL.UU  W4,#10,W6
04158:  ADD     W6,#C,W6
0415A:  MOV     W6,W0
0415C:  MOV     #B5A,W4
0415E:  ADD     W0,W4,W0
04160:  MOV     [W0++],[W5++]
04162:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
04164:  MOV     #1,W4
04166:  MOV     W4,AA0
.................... 		                path_found = true; 
04168:  MOV     #1,W4
0416A:  MOV     W4,A98
.................... 		            } 
0416C:  GOTO    4458
.................... 		            else if (posEnd == 7) 
04170:  MOV     1B5A,W4
04172:  CP      W4,#7
04174:  BRA     NZ,43F4
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
04176:  MOV     1B56,W4
04178:  MUL.UU  W4,#2,W0
0417A:  MOV     #AA6,W4
0417C:  ADD     W0,W4,W0
0417E:  MOV     [W0],W5
04180:  MOV     W5,W4
04182:  MUL.UU  W4,#10,W0
04184:  MOV     W0,W5
04186:  MOV     1B14,W4
04188:  MUL.UU  W4,#4,W0
0418A:  ADD     W0,W5,W0
0418C:  MOV     #B5A,W4
0418E:  ADD     W0,W4,W0
04190:  MOV     [W0],W5
04192:  MOV     1B56,W4
04194:  MUL.UU  W4,#2,W0
04196:  MOV     #AA6,W4
04198:  ADD     W0,W4,W0
0419A:  MOV     [W0],W6
0419C:  MOV     W6,W4
0419E:  MUL.UU  W4,#10,W6
041A0:  MOV     1B16,W4
041A2:  MUL.UU  W4,#4,W0
041A4:  ADD     W0,W6,W0
041A6:  MOV     #B5A,W4
041A8:  ADD     W0,W4,W0
041AA:  MOV     [W0],W6
041AC:  PUSH    1B4E
041AE:  POP     1B72
041B0:  PUSH    1B50
041B2:  POP     1B74
041B4:  MOV     W5,1B76
041B6:  MOV     W6,1B78
041B8:  CALL    23E2
041BC:  MOV     W0,W5
041BE:  MOV     1B56,W4
041C0:  MUL.UU  W4,#2,W0
041C2:  MOV     #AA6,W4
041C4:  ADD     W0,W4,W0
041C6:  MOV     [W0],W6
041C8:  MOV     W6,W4
041CA:  MUL.UU  W4,#10,W6
041CC:  MOV     #B5A,W4
041CE:  ADD     W6,W4,W0
041D0:  MOV     [W0],W7
041D2:  MOV     1B56,W4
041D4:  MUL.UU  W4,#2,W0
041D6:  MOV     #AA6,W4
041D8:  ADD     W0,W4,W0
041DA:  MOV     [W0],W8
041DC:  MOV     W8,W4
041DE:  MUL.UU  W4,#10,W8
041E0:  ADD     W8,#4,W8
041E2:  MOV     W8,W0
041E4:  MOV     #B5A,W4
041E6:  ADD     W0,W4,W0
041E8:  MOV     [W0],W8
041EA:  MOV     W7,1B72
041EC:  MOV     W8,1B74
041EE:  PUSH    1B52
041F0:  POP     1B76
041F2:  PUSH    1B54
041F4:  POP     1B78
041F6:  CALL    23E2
041FA:  ADD     W0,W5,W5
041FC:  MOV     1B56,W4
041FE:  MUL.UU  W4,#2,W0
04200:  MOV     #AA6,W4
04202:  ADD     W0,W4,W0
04204:  MOV     [W0],W7
04206:  MOV     W7,W4
04208:  MUL.UU  W4,#10,W0
0420A:  MOV     W0,W7
0420C:  ADD     W7,#8,W7
0420E:  MOV     W7,W0
04210:  MOV     #B5A,W4
04212:  ADD     W0,W4,W0
04214:  MOV     [W0],W7
04216:  MOV     1B56,W4
04218:  MUL.UU  W4,#2,W0
0421A:  MOV     #AA6,W4
0421C:  ADD     W0,W4,W0
0421E:  MOV     [W0],W8
04220:  MOV     W8,W4
04222:  MUL.UU  W4,#10,W8
04224:  ADD     W8,#C,W8
04226:  MOV     W8,W0
04228:  MOV     #B5A,W4
0422A:  ADD     W0,W4,W0
0422C:  MOV     [W0],W8
0422E:  PUSH    1B4E
04230:  POP     1B72
04232:  PUSH    1B50
04234:  POP     1B74
04236:  MOV     W7,1B76
04238:  MOV     W8,1B78
0423A:  CALL    23E2
0423E:  MOV     W0,W7
04240:  MOV     1B56,W4
04242:  MUL.UU  W4,#2,W0
04244:  MOV     #AA6,W4
04246:  ADD     W0,W4,W0
04248:  MOV     [W0],W8
0424A:  MOV     W8,W4
0424C:  MUL.UU  W4,#10,W8
0424E:  MOV     1B10,W4
04250:  MUL.UU  W4,#4,W0
04252:  ADD     W0,W8,W0
04254:  MOV     #B5A,W4
04256:  ADD     W0,W4,W0
04258:  MOV     [W0],W8
0425A:  MOV     1B56,W4
0425C:  MUL.UU  W4,#2,W0
0425E:  MOV     #AA6,W4
04260:  ADD     W0,W4,W0
04262:  MOV     [W0],W9
04264:  MOV     W9,W4
04266:  MUL.UU  W4,#10,W0
04268:  MOV     W0,W9
0426A:  MOV     1B12,W4
0426C:  MUL.UU  W4,#4,W0
0426E:  ADD     W0,W9,W0
04270:  MOV     #B5A,W4
04272:  ADD     W0,W4,W0
04274:  MOV     [W0],W9
04276:  MOV     W8,1B72
04278:  MOV     W9,1B74
0427A:  PUSH    1B52
0427C:  POP     1B76
0427E:  PUSH    1B54
04280:  POP     1B78
04282:  CALL    23E2
04286:  ADD     W0,W7,W0
04288:  CP      W5,W0
0428A:  BRA     GE,433C
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0428C:  MOV     AA2,W4
0428E:  MUL.UU  W4,#8,W0
04290:  MOV     W0,W5
04292:  MOV     #ABA,W4
04294:  ADD     W5,W4,W6
04296:  MOV     1B56,W4
04298:  MUL.UU  W4,#2,W0
0429A:  MOV     #AA6,W4
0429C:  ADD     W0,W4,W0
0429E:  MOV     [W0],W7
042A0:  MOV     W7,W4
042A2:  MUL.UU  W4,#10,W0
042A4:  MOV     W0,W7
042A6:  MOV     1B14,W4
042A8:  MUL.UU  W4,#4,W0
042AA:  ADD     W0,W7,W0
042AC:  MOV     #B5A,W4
042AE:  ADD     W0,W4,W0
042B0:  MOV     [W0++],[W6++]
042B2:  MOV     [W0++],[W6++]
042B4:  MOV     AA2,W4
042B6:  MUL.UU  W4,#8,W0
042B8:  MOV     W0,W5
042BA:  ADD     W5,#4,W5
042BC:  MOV     W5,W0
042BE:  MOV     #ABA,W4
042C0:  ADD     W0,W4,W5
042C2:  MOV     1B56,W4
042C4:  MUL.UU  W4,#2,W0
042C6:  MOV     #AA6,W4
042C8:  ADD     W0,W4,W0
042CA:  MOV     [W0],W6
042CC:  MOV     W6,W4
042CE:  MUL.UU  W4,#10,W6
042D0:  MOV     1B16,W4
042D2:  MUL.UU  W4,#4,W0
042D4:  ADD     W0,W6,W0
042D6:  MOV     #B5A,W4
042D8:  ADD     W0,W4,W0
042DA:  MOV     [W0++],[W5++]
042DC:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
042DE:  MOV     AA2,W4
042E0:  ADD     W4,#1,W4
042E2:  MOV     W4,W5
042E4:  MOV     W5,W4
042E6:  MUL.UU  W4,#8,W0
042E8:  MOV     W0,W5
042EA:  MOV     #ABA,W4
042EC:  ADD     W5,W4,W6
042EE:  MOV     1B56,W4
042F0:  MUL.UU  W4,#2,W0
042F2:  MOV     #AA6,W4
042F4:  ADD     W0,W4,W0
042F6:  MOV     [W0],W7
042F8:  MOV     W7,W4
042FA:  MUL.UU  W4,#10,W0
042FC:  MOV     W0,W7
042FE:  MOV     #B5A,W4
04300:  ADD     W7,W4,W0
04302:  MOV     [W0++],[W6++]
04304:  MOV     [W0++],[W6++]
04306:  MOV     AA2,W4
04308:  ADD     W4,#1,W4
0430A:  MOV     W4,W5
0430C:  MOV     W5,W4
0430E:  MUL.UU  W4,#8,W0
04310:  MOV     W0,W5
04312:  ADD     W5,#4,W5
04314:  MOV     W5,W0
04316:  MOV     #ABA,W4
04318:  ADD     W0,W4,W5
0431A:  MOV     1B56,W4
0431C:  MUL.UU  W4,#2,W0
0431E:  MOV     #AA6,W4
04320:  ADD     W0,W4,W0
04322:  MOV     [W0],W6
04324:  MOV     W6,W4
04326:  MUL.UU  W4,#10,W6
04328:  ADD     W6,#4,W6
0432A:  MOV     W6,W0
0432C:  MOV     #B5A,W4
0432E:  ADD     W0,W4,W0
04330:  MOV     [W0++],[W5++]
04332:  MOV     [W0++],[W5++]
.................... 		                     
.................... 		                    relay_point_number = 2; 
04334:  MOV     #2,W4
04336:  MOV     W4,AA0
.................... 		                } 
04338:  GOTO    43EC
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0433C:  MOV     AA2,W4
0433E:  MUL.UU  W4,#8,W0
04340:  MOV     W0,W5
04342:  MOV     #ABA,W4
04344:  ADD     W5,W4,W6
04346:  MOV     1B56,W4
04348:  MUL.UU  W4,#2,W0
0434A:  MOV     #AA6,W4
0434C:  ADD     W0,W4,W0
0434E:  MOV     [W0],W7
04350:  MOV     W7,W4
04352:  MUL.UU  W4,#10,W0
04354:  MOV     W0,W7
04356:  ADD     W7,#8,W7
04358:  MOV     W7,W0
0435A:  MOV     #B5A,W4
0435C:  ADD     W0,W4,W0
0435E:  MOV     [W0++],[W6++]
04360:  MOV     [W0++],[W6++]
04362:  MOV     AA2,W4
04364:  MUL.UU  W4,#8,W0
04366:  MOV     W0,W5
04368:  ADD     W5,#4,W5
0436A:  MOV     W5,W0
0436C:  MOV     #ABA,W4
0436E:  ADD     W0,W4,W5
04370:  MOV     1B56,W4
04372:  MUL.UU  W4,#2,W0
04374:  MOV     #AA6,W4
04376:  ADD     W0,W4,W0
04378:  MOV     [W0],W6
0437A:  MOV     W6,W4
0437C:  MUL.UU  W4,#10,W6
0437E:  ADD     W6,#C,W6
04380:  MOV     W6,W0
04382:  MOV     #B5A,W4
04384:  ADD     W0,W4,W0
04386:  MOV     [W0++],[W5++]
04388:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0438A:  MOV     AA2,W4
0438C:  ADD     W4,#1,W4
0438E:  MOV     W4,W5
04390:  MOV     W5,W4
04392:  MUL.UU  W4,#8,W0
04394:  MOV     W0,W5
04396:  MOV     #ABA,W4
04398:  ADD     W5,W4,W6
0439A:  MOV     1B56,W4
0439C:  MUL.UU  W4,#2,W0
0439E:  MOV     #AA6,W4
043A0:  ADD     W0,W4,W0
043A2:  MOV     [W0],W7
043A4:  MOV     W7,W4
043A6:  MUL.UU  W4,#10,W0
043A8:  MOV     W0,W7
043AA:  MOV     1B10,W4
043AC:  MUL.UU  W4,#4,W0
043AE:  ADD     W0,W7,W0
043B0:  MOV     #B5A,W4
043B2:  ADD     W0,W4,W0
043B4:  MOV     [W0++],[W6++]
043B6:  MOV     [W0++],[W6++]
043B8:  MOV     AA2,W4
043BA:  ADD     W4,#1,W4
043BC:  MOV     W4,W5
043BE:  MOV     W5,W4
043C0:  MUL.UU  W4,#8,W0
043C2:  MOV     W0,W5
043C4:  ADD     W5,#4,W5
043C6:  MOV     W5,W0
043C8:  MOV     #ABA,W4
043CA:  ADD     W0,W4,W5
043CC:  MOV     1B56,W4
043CE:  MUL.UU  W4,#2,W0
043D0:  MOV     #AA6,W4
043D2:  ADD     W0,W4,W0
043D4:  MOV     [W0],W6
043D6:  MOV     W6,W4
043D8:  MUL.UU  W4,#10,W6
043DA:  MOV     1B12,W4
043DC:  MUL.UU  W4,#4,W0
043DE:  ADD     W0,W6,W0
043E0:  MOV     #B5A,W4
043E2:  ADD     W0,W4,W0
043E4:  MOV     [W0++],[W5++]
043E6:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
043E8:  MOV     #2,W4
043EA:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
043EC:  MOV     #1,W4
043EE:  MOV     W4,A98
.................... 		            } 
043F0:  GOTO    4458
.................... 		            else if (posEnd == 0 || posEnd == 1) 
043F4:  CP0     1B5A
043F6:  BRA     Z,43FE
043F8:  MOV     1B5A,W4
043FA:  CP      W4,#1
043FC:  BRA     NZ,4458
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
043FE:  MOV     AA2,W4
04400:  MUL.UU  W4,#8,W0
04402:  MOV     W0,W5
04404:  MOV     #ABA,W4
04406:  ADD     W5,W4,W6
04408:  MOV     1B56,W4
0440A:  MUL.UU  W4,#2,W0
0440C:  MOV     #AA6,W4
0440E:  ADD     W0,W4,W0
04410:  MOV     [W0],W7
04412:  MOV     W7,W4
04414:  MUL.UU  W4,#10,W0
04416:  MOV     W0,W7
04418:  MOV     1B14,W4
0441A:  MUL.UU  W4,#4,W0
0441C:  ADD     W0,W7,W0
0441E:  MOV     #B5A,W4
04420:  ADD     W0,W4,W0
04422:  MOV     [W0++],[W6++]
04424:  MOV     [W0++],[W6++]
04426:  MOV     AA2,W4
04428:  MUL.UU  W4,#8,W0
0442A:  MOV     W0,W5
0442C:  ADD     W5,#4,W5
0442E:  MOV     W5,W0
04430:  MOV     #ABA,W4
04432:  ADD     W0,W4,W5
04434:  MOV     1B56,W4
04436:  MUL.UU  W4,#2,W0
04438:  MOV     #AA6,W4
0443A:  ADD     W0,W4,W0
0443C:  MOV     [W0],W6
0443E:  MOV     W6,W4
04440:  MUL.UU  W4,#10,W6
04442:  MOV     1B16,W4
04444:  MUL.UU  W4,#4,W0
04446:  ADD     W0,W6,W0
04448:  MOV     #B5A,W4
0444A:  ADD     W0,W4,W0
0444C:  MOV     [W0++],[W5++]
0444E:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
04450:  MOV     #1,W4
04452:  MOV     W4,AA0
.................... 		                path_found = true; 
04454:  MOV     #1,W4
04456:  MOV     W4,A98
.................... 		            } 
.................... 		             
.................... 	        	} 
.................... 	             
.................... 	             
....................  
.................... 	            break; 
04458:  GOTO    6324
....................  
.................... 	        case 4: 
....................  
.................... 	        	if(path_opposite) 
0445C:  CP0     A9C
0445E:  BRA     Z,47B4
.................... 	        	{ 
.................... 	        		if (posEnd == 7) 
04460:  MOV     1B5A,W4
04462:  CP      W4,#7
04464:  BRA     NZ,451A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04466:  MOV     AA2,W4
04468:  MUL.UU  W4,#8,W0
0446A:  MOV     W0,W5
0446C:  MOV     #ABA,W4
0446E:  ADD     W5,W4,W6
04470:  MOV     1B56,W4
04472:  MUL.UU  W4,#2,W0
04474:  MOV     #AA6,W4
04476:  ADD     W0,W4,W0
04478:  MOV     [W0],W7
0447A:  MOV     W7,W4
0447C:  MUL.UU  W4,#10,W0
0447E:  MOV     W0,W7
04480:  MOV     1B14,W4
04482:  MUL.UU  W4,#4,W0
04484:  ADD     W0,W7,W0
04486:  MOV     #B5A,W4
04488:  ADD     W0,W4,W0
0448A:  MOV     [W0++],[W6++]
0448C:  MOV     [W0++],[W6++]
0448E:  MOV     AA2,W4
04490:  MUL.UU  W4,#8,W0
04492:  MOV     W0,W5
04494:  ADD     W5,#4,W5
04496:  MOV     W5,W0
04498:  MOV     #ABA,W4
0449A:  ADD     W0,W4,W5
0449C:  MOV     1B56,W4
0449E:  MUL.UU  W4,#2,W0
044A0:  MOV     #AA6,W4
044A2:  ADD     W0,W4,W0
044A4:  MOV     [W0],W6
044A6:  MOV     W6,W4
044A8:  MUL.UU  W4,#10,W6
044AA:  MOV     1B16,W4
044AC:  MUL.UU  W4,#4,W0
044AE:  ADD     W0,W6,W0
044B0:  MOV     #B5A,W4
044B2:  ADD     W0,W4,W0
044B4:  MOV     [W0++],[W5++]
044B6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
044B8:  MOV     AA2,W4
044BA:  ADD     W4,#1,W4
044BC:  MOV     W4,W5
044BE:  MOV     W5,W4
044C0:  MUL.UU  W4,#8,W0
044C2:  MOV     W0,W5
044C4:  MOV     #ABA,W4
044C6:  ADD     W5,W4,W6
044C8:  MOV     1B56,W4
044CA:  MUL.UU  W4,#2,W0
044CC:  MOV     #AA6,W4
044CE:  ADD     W0,W4,W0
044D0:  MOV     [W0],W7
044D2:  MOV     W7,W4
044D4:  MUL.UU  W4,#10,W0
044D6:  MOV     W0,W7
044D8:  MOV     #B5A,W4
044DA:  ADD     W7,W4,W0
044DC:  MOV     [W0++],[W6++]
044DE:  MOV     [W0++],[W6++]
044E0:  MOV     AA2,W4
044E2:  ADD     W4,#1,W4
044E4:  MOV     W4,W5
044E6:  MOV     W5,W4
044E8:  MUL.UU  W4,#8,W0
044EA:  MOV     W0,W5
044EC:  ADD     W5,#4,W5
044EE:  MOV     W5,W0
044F0:  MOV     #ABA,W4
044F2:  ADD     W0,W4,W5
044F4:  MOV     1B56,W4
044F6:  MUL.UU  W4,#2,W0
044F8:  MOV     #AA6,W4
044FA:  ADD     W0,W4,W0
044FC:  MOV     [W0],W6
044FE:  MOV     W6,W4
04500:  MUL.UU  W4,#10,W6
04502:  ADD     W6,#4,W6
04504:  MOV     W6,W0
04506:  MOV     #B5A,W4
04508:  ADD     W0,W4,W0
0450A:  MOV     [W0++],[W5++]
0450C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0450E:  MOV     #2,W4
04510:  MOV     W4,AA0
.................... 		                path_found = true; 
04512:  MOV     #1,W4
04514:  MOV     W4,A98
.................... 		            } 
04516:  GOTO    47B0
.................... 		            else if (posEnd == 0) 
0451A:  CP0     1B5A
0451C:  BRA     NZ,46FA
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
0451E:  MOV     1B56,W4
04520:  MUL.UU  W4,#2,W0
04522:  MOV     #AA6,W4
04524:  ADD     W0,W4,W0
04526:  MOV     [W0],W5
04528:  MOV     W5,W4
0452A:  MUL.UU  W4,#10,W0
0452C:  MOV     W0,W5
0452E:  MOV     1B14,W4
04530:  MUL.UU  W4,#4,W0
04532:  ADD     W0,W5,W0
04534:  MOV     #B5A,W4
04536:  ADD     W0,W4,W0
04538:  MOV     [W0],W5
0453A:  MOV     1B56,W4
0453C:  MUL.UU  W4,#2,W0
0453E:  MOV     #AA6,W4
04540:  ADD     W0,W4,W0
04542:  MOV     [W0],W6
04544:  MOV     W6,W4
04546:  MUL.UU  W4,#10,W6
04548:  MOV     1B16,W4
0454A:  MUL.UU  W4,#4,W0
0454C:  ADD     W0,W6,W0
0454E:  MOV     #B5A,W4
04550:  ADD     W0,W4,W0
04552:  MOV     [W0],W6
04554:  PUSH    1B4E
04556:  POP     1B72
04558:  PUSH    1B50
0455A:  POP     1B74
0455C:  MOV     W5,1B76
0455E:  MOV     W6,1B78
04560:  CALL    23E2
04564:  MOV     W0,W5
04566:  MOV     1B56,W4
04568:  MUL.UU  W4,#2,W0
0456A:  MOV     #AA6,W4
0456C:  ADD     W0,W4,W0
0456E:  MOV     [W0],W6
04570:  MOV     W6,W4
04572:  MUL.UU  W4,#10,W6
04574:  MOV     1B14,W4
04576:  MUL.UU  W4,#4,W0
04578:  ADD     W0,W6,W0
0457A:  MOV     #B5A,W4
0457C:  ADD     W0,W4,W0
0457E:  MOV     [W0],W6
04580:  MOV     1B56,W4
04582:  MUL.UU  W4,#2,W0
04584:  MOV     #AA6,W4
04586:  ADD     W0,W4,W0
04588:  MOV     [W0],W7
0458A:  MOV     W7,W4
0458C:  MUL.UU  W4,#10,W0
0458E:  MOV     W0,W7
04590:  MOV     1B16,W4
04592:  MUL.UU  W4,#4,W0
04594:  ADD     W0,W7,W0
04596:  MOV     #B5A,W4
04598:  ADD     W0,W4,W0
0459A:  MOV     [W0],W7
0459C:  MOV     W6,1B72
0459E:  MOV     W7,1B74
045A0:  PUSH    1B52
045A2:  POP     1B76
045A4:  PUSH    1B54
045A6:  POP     1B78
045A8:  CALL    23E2
045AC:  ADD     W0,W5,W5
045AE:  MOV     1B56,W4
045B0:  MUL.UU  W4,#2,W0
045B2:  MOV     #AA6,W4
045B4:  ADD     W0,W4,W0
045B6:  MOV     [W0],W6
045B8:  MOV     W6,W4
045BA:  MUL.UU  W4,#10,W6
045BC:  MOV     1B10,W4
045BE:  MUL.UU  W4,#4,W0
045C0:  ADD     W0,W6,W0
045C2:  MOV     #B5A,W4
045C4:  ADD     W0,W4,W0
045C6:  MOV     [W0],W6
045C8:  MOV     1B56,W4
045CA:  MUL.UU  W4,#2,W0
045CC:  MOV     #AA6,W4
045CE:  ADD     W0,W4,W0
045D0:  MOV     [W0],W7
045D2:  MOV     W7,W4
045D4:  MUL.UU  W4,#10,W0
045D6:  MOV     W0,W7
045D8:  MOV     1B12,W4
045DA:  MUL.UU  W4,#4,W0
045DC:  ADD     W0,W7,W0
045DE:  MOV     #B5A,W4
045E0:  ADD     W0,W4,W0
045E2:  MOV     [W0],W7
045E4:  PUSH    1B4E
045E6:  POP     1B72
045E8:  PUSH    1B50
045EA:  POP     1B74
045EC:  MOV     W6,1B76
045EE:  MOV     W7,1B78
045F0:  CALL    23E2
045F4:  MOV     W0,W6
045F6:  MOV     1B56,W4
045F8:  MUL.UU  W4,#2,W0
045FA:  MOV     #AA6,W4
045FC:  ADD     W0,W4,W0
045FE:  MOV     [W0],W7
04600:  MOV     W7,W4
04602:  MUL.UU  W4,#10,W0
04604:  MOV     W0,W7
04606:  MOV     1B10,W4
04608:  MUL.UU  W4,#4,W0
0460A:  ADD     W0,W7,W0
0460C:  MOV     #B5A,W4
0460E:  ADD     W0,W4,W0
04610:  MOV     [W0],W7
04612:  MOV     1B56,W4
04614:  MUL.UU  W4,#2,W0
04616:  MOV     #AA6,W4
04618:  ADD     W0,W4,W0
0461A:  MOV     [W0],W8
0461C:  MOV     W8,W4
0461E:  MUL.UU  W4,#10,W8
04620:  MOV     1B12,W4
04622:  MUL.UU  W4,#4,W0
04624:  ADD     W0,W8,W0
04626:  MOV     #B5A,W4
04628:  ADD     W0,W4,W0
0462A:  MOV     [W0],W8
0462C:  MOV     W7,1B72
0462E:  MOV     W8,1B74
04630:  PUSH    1B52
04632:  POP     1B76
04634:  PUSH    1B54
04636:  POP     1B78
04638:  CALL    23E2
0463C:  ADD     W0,W6,W0
0463E:  CP      W5,W0
04640:  BRA     GE,469C
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04642:  MOV     AA2,W4
04644:  MUL.UU  W4,#8,W0
04646:  MOV     W0,W5
04648:  MOV     #ABA,W4
0464A:  ADD     W5,W4,W6
0464C:  MOV     1B56,W4
0464E:  MUL.UU  W4,#2,W0
04650:  MOV     #AA6,W4
04652:  ADD     W0,W4,W0
04654:  MOV     [W0],W7
04656:  MOV     W7,W4
04658:  MUL.UU  W4,#10,W0
0465A:  MOV     W0,W7
0465C:  MOV     1B10,W4
0465E:  MUL.UU  W4,#4,W0
04660:  ADD     W0,W7,W0
04662:  MOV     #B5A,W4
04664:  ADD     W0,W4,W0
04666:  MOV     [W0++],[W6++]
04668:  MOV     [W0++],[W6++]
0466A:  MOV     AA2,W4
0466C:  MUL.UU  W4,#8,W0
0466E:  MOV     W0,W5
04670:  ADD     W5,#4,W5
04672:  MOV     W5,W0
04674:  MOV     #ABA,W4
04676:  ADD     W0,W4,W5
04678:  MOV     1B56,W4
0467A:  MUL.UU  W4,#2,W0
0467C:  MOV     #AA6,W4
0467E:  ADD     W0,W4,W0
04680:  MOV     [W0],W6
04682:  MOV     W6,W4
04684:  MUL.UU  W4,#10,W6
04686:  MOV     1B12,W4
04688:  MUL.UU  W4,#4,W0
0468A:  ADD     W0,W6,W0
0468C:  MOV     #B5A,W4
0468E:  ADD     W0,W4,W0
04690:  MOV     [W0++],[W5++]
04692:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
04694:  MOV     #1,W4
04696:  MOV     W4,AA0
.................... 		                } 
04698:  GOTO    46F2
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0469C:  MOV     AA2,W4
0469E:  MUL.UU  W4,#8,W0
046A0:  MOV     W0,W5
046A2:  MOV     #ABA,W4
046A4:  ADD     W5,W4,W6
046A6:  MOV     1B56,W4
046A8:  MUL.UU  W4,#2,W0
046AA:  MOV     #AA6,W4
046AC:  ADD     W0,W4,W0
046AE:  MOV     [W0],W7
046B0:  MOV     W7,W4
046B2:  MUL.UU  W4,#10,W0
046B4:  MOV     W0,W7
046B6:  MOV     1B14,W4
046B8:  MUL.UU  W4,#4,W0
046BA:  ADD     W0,W7,W0
046BC:  MOV     #B5A,W4
046BE:  ADD     W0,W4,W0
046C0:  MOV     [W0++],[W6++]
046C2:  MOV     [W0++],[W6++]
046C4:  MOV     AA2,W4
046C6:  MUL.UU  W4,#8,W0
046C8:  MOV     W0,W5
046CA:  ADD     W5,#4,W5
046CC:  MOV     W5,W0
046CE:  MOV     #ABA,W4
046D0:  ADD     W0,W4,W5
046D2:  MOV     1B56,W4
046D4:  MUL.UU  W4,#2,W0
046D6:  MOV     #AA6,W4
046D8:  ADD     W0,W4,W0
046DA:  MOV     [W0],W6
046DC:  MOV     W6,W4
046DE:  MUL.UU  W4,#10,W6
046E0:  MOV     1B16,W4
046E2:  MUL.UU  W4,#4,W0
046E4:  ADD     W0,W6,W0
046E6:  MOV     #B5A,W4
046E8:  ADD     W0,W4,W0
046EA:  MOV     [W0++],[W5++]
046EC:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
046EE:  MOV     #1,W4
046F0:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
046F2:  MOV     #1,W4
046F4:  MOV     W4,A98
.................... 		            } 
046F6:  GOTO    47B0
.................... 		            else if (posEnd == 1) 
046FA:  MOV     1B5A,W4
046FC:  CP      W4,#1
046FE:  BRA     NZ,47B0
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04700:  MOV     AA2,W4
04702:  MUL.UU  W4,#8,W0
04704:  MOV     W0,W5
04706:  MOV     #ABA,W4
04708:  ADD     W5,W4,W6
0470A:  MOV     1B56,W4
0470C:  MUL.UU  W4,#2,W0
0470E:  MOV     #AA6,W4
04710:  ADD     W0,W4,W0
04712:  MOV     [W0],W7
04714:  MOV     W7,W4
04716:  MUL.UU  W4,#10,W0
04718:  MOV     W0,W7
0471A:  MOV     1B10,W4
0471C:  MUL.UU  W4,#4,W0
0471E:  ADD     W0,W7,W0
04720:  MOV     #B5A,W4
04722:  ADD     W0,W4,W0
04724:  MOV     [W0++],[W6++]
04726:  MOV     [W0++],[W6++]
04728:  MOV     AA2,W4
0472A:  MUL.UU  W4,#8,W0
0472C:  MOV     W0,W5
0472E:  ADD     W5,#4,W5
04730:  MOV     W5,W0
04732:  MOV     #ABA,W4
04734:  ADD     W0,W4,W5
04736:  MOV     1B56,W4
04738:  MUL.UU  W4,#2,W0
0473A:  MOV     #AA6,W4
0473C:  ADD     W0,W4,W0
0473E:  MOV     [W0],W6
04740:  MOV     W6,W4
04742:  MUL.UU  W4,#10,W6
04744:  MOV     1B12,W4
04746:  MUL.UU  W4,#4,W0
04748:  ADD     W0,W6,W0
0474A:  MOV     #B5A,W4
0474C:  ADD     W0,W4,W0
0474E:  MOV     [W0++],[W5++]
04750:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04752:  MOV     AA2,W4
04754:  ADD     W4,#1,W4
04756:  MOV     W4,W5
04758:  MOV     W5,W4
0475A:  MUL.UU  W4,#8,W0
0475C:  MOV     W0,W5
0475E:  MOV     #ABA,W4
04760:  ADD     W5,W4,W6
04762:  MOV     1B56,W4
04764:  MUL.UU  W4,#2,W0
04766:  MOV     #AA6,W4
04768:  ADD     W0,W4,W0
0476A:  MOV     [W0],W7
0476C:  MOV     W7,W4
0476E:  MUL.UU  W4,#10,W0
04770:  MOV     W0,W7
04772:  MOV     #B5A,W4
04774:  ADD     W7,W4,W0
04776:  MOV     [W0++],[W6++]
04778:  MOV     [W0++],[W6++]
0477A:  MOV     AA2,W4
0477C:  ADD     W4,#1,W4
0477E:  MOV     W4,W5
04780:  MOV     W5,W4
04782:  MUL.UU  W4,#8,W0
04784:  MOV     W0,W5
04786:  ADD     W5,#4,W5
04788:  MOV     W5,W0
0478A:  MOV     #ABA,W4
0478C:  ADD     W0,W4,W5
0478E:  MOV     1B56,W4
04790:  MUL.UU  W4,#2,W0
04792:  MOV     #AA6,W4
04794:  ADD     W0,W4,W0
04796:  MOV     [W0],W6
04798:  MOV     W6,W4
0479A:  MUL.UU  W4,#10,W6
0479C:  ADD     W6,#4,W6
0479E:  MOV     W6,W0
047A0:  MOV     #B5A,W4
047A2:  ADD     W0,W4,W0
047A4:  MOV     [W0++],[W5++]
047A6:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
047A8:  MOV     #2,W4
047AA:  MOV     W4,AA0
.................... 		                path_found = true; 
047AC:  MOV     #1,W4
047AE:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
047B0:  GOTO    4A58
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 7) 
047B4:  MOV     1B5A,W4
047B6:  CP      W4,#7
047B8:  BRA     NZ,4818
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
047BA:  MOV     AA2,W4
047BC:  MUL.UU  W4,#8,W0
047BE:  MOV     W0,W5
047C0:  MOV     #ABA,W4
047C2:  ADD     W5,W4,W6
047C4:  MOV     1B56,W4
047C6:  MUL.UU  W4,#2,W0
047C8:  MOV     #AA6,W4
047CA:  ADD     W0,W4,W0
047CC:  MOV     [W0],W7
047CE:  MOV     W7,W4
047D0:  MUL.UU  W4,#10,W0
047D2:  MOV     W0,W7
047D4:  MOV     1B10,W4
047D6:  MUL.UU  W4,#4,W0
047D8:  ADD     W0,W7,W0
047DA:  MOV     #B5A,W4
047DC:  ADD     W0,W4,W0
047DE:  MOV     [W0++],[W6++]
047E0:  MOV     [W0++],[W6++]
047E2:  MOV     AA2,W4
047E4:  MUL.UU  W4,#8,W0
047E6:  MOV     W0,W5
047E8:  ADD     W5,#4,W5
047EA:  MOV     W5,W0
047EC:  MOV     #ABA,W4
047EE:  ADD     W0,W4,W5
047F0:  MOV     1B56,W4
047F2:  MUL.UU  W4,#2,W0
047F4:  MOV     #AA6,W4
047F6:  ADD     W0,W4,W0
047F8:  MOV     [W0],W6
047FA:  MOV     W6,W4
047FC:  MUL.UU  W4,#10,W6
047FE:  MOV     1B12,W4
04800:  MUL.UU  W4,#4,W0
04802:  ADD     W0,W6,W0
04804:  MOV     #B5A,W4
04806:  ADD     W0,W4,W0
04808:  MOV     [W0++],[W5++]
0480A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0480C:  MOV     #1,W4
0480E:  MOV     W4,AA0
.................... 		                path_found = true; 
04810:  MOV     #1,W4
04812:  MOV     W4,A98
.................... 		            } 
04814:  GOTO    4A58
.................... 		            else if (posEnd == 0) 
04818:  CP0     1B5A
0481A:  BRA     NZ,49F8
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
0481C:  MOV     1B56,W4
0481E:  MUL.UU  W4,#2,W0
04820:  MOV     #AA6,W4
04822:  ADD     W0,W4,W0
04824:  MOV     [W0],W5
04826:  MOV     W5,W4
04828:  MUL.UU  W4,#10,W0
0482A:  MOV     W0,W5
0482C:  MOV     1B14,W4
0482E:  MUL.UU  W4,#4,W0
04830:  ADD     W0,W5,W0
04832:  MOV     #B5A,W4
04834:  ADD     W0,W4,W0
04836:  MOV     [W0],W5
04838:  MOV     1B56,W4
0483A:  MUL.UU  W4,#2,W0
0483C:  MOV     #AA6,W4
0483E:  ADD     W0,W4,W0
04840:  MOV     [W0],W6
04842:  MOV     W6,W4
04844:  MUL.UU  W4,#10,W6
04846:  MOV     1B16,W4
04848:  MUL.UU  W4,#4,W0
0484A:  ADD     W0,W6,W0
0484C:  MOV     #B5A,W4
0484E:  ADD     W0,W4,W0
04850:  MOV     [W0],W6
04852:  PUSH    1B4E
04854:  POP     1B72
04856:  PUSH    1B50
04858:  POP     1B74
0485A:  MOV     W5,1B76
0485C:  MOV     W6,1B78
0485E:  CALL    23E2
04862:  MOV     W0,W5
04864:  MOV     1B56,W4
04866:  MUL.UU  W4,#2,W0
04868:  MOV     #AA6,W4
0486A:  ADD     W0,W4,W0
0486C:  MOV     [W0],W6
0486E:  MOV     W6,W4
04870:  MUL.UU  W4,#10,W6
04872:  MOV     1B14,W4
04874:  MUL.UU  W4,#4,W0
04876:  ADD     W0,W6,W0
04878:  MOV     #B5A,W4
0487A:  ADD     W0,W4,W0
0487C:  MOV     [W0],W6
0487E:  MOV     1B56,W4
04880:  MUL.UU  W4,#2,W0
04882:  MOV     #AA6,W4
04884:  ADD     W0,W4,W0
04886:  MOV     [W0],W7
04888:  MOV     W7,W4
0488A:  MUL.UU  W4,#10,W0
0488C:  MOV     W0,W7
0488E:  MOV     1B16,W4
04890:  MUL.UU  W4,#4,W0
04892:  ADD     W0,W7,W0
04894:  MOV     #B5A,W4
04896:  ADD     W0,W4,W0
04898:  MOV     [W0],W7
0489A:  MOV     W6,1B72
0489C:  MOV     W7,1B74
0489E:  PUSH    1B52
048A0:  POP     1B76
048A2:  PUSH    1B54
048A4:  POP     1B78
048A6:  CALL    23E2
048AA:  ADD     W0,W5,W5
048AC:  MOV     1B56,W4
048AE:  MUL.UU  W4,#2,W0
048B0:  MOV     #AA6,W4
048B2:  ADD     W0,W4,W0
048B4:  MOV     [W0],W6
048B6:  MOV     W6,W4
048B8:  MUL.UU  W4,#10,W6
048BA:  MOV     1B10,W4
048BC:  MUL.UU  W4,#4,W0
048BE:  ADD     W0,W6,W0
048C0:  MOV     #B5A,W4
048C2:  ADD     W0,W4,W0
048C4:  MOV     [W0],W6
048C6:  MOV     1B56,W4
048C8:  MUL.UU  W4,#2,W0
048CA:  MOV     #AA6,W4
048CC:  ADD     W0,W4,W0
048CE:  MOV     [W0],W7
048D0:  MOV     W7,W4
048D2:  MUL.UU  W4,#10,W0
048D4:  MOV     W0,W7
048D6:  MOV     1B12,W4
048D8:  MUL.UU  W4,#4,W0
048DA:  ADD     W0,W7,W0
048DC:  MOV     #B5A,W4
048DE:  ADD     W0,W4,W0
048E0:  MOV     [W0],W7
048E2:  PUSH    1B4E
048E4:  POP     1B72
048E6:  PUSH    1B50
048E8:  POP     1B74
048EA:  MOV     W6,1B76
048EC:  MOV     W7,1B78
048EE:  CALL    23E2
048F2:  MOV     W0,W6
048F4:  MOV     1B56,W4
048F6:  MUL.UU  W4,#2,W0
048F8:  MOV     #AA6,W4
048FA:  ADD     W0,W4,W0
048FC:  MOV     [W0],W7
048FE:  MOV     W7,W4
04900:  MUL.UU  W4,#10,W0
04902:  MOV     W0,W7
04904:  MOV     1B10,W4
04906:  MUL.UU  W4,#4,W0
04908:  ADD     W0,W7,W0
0490A:  MOV     #B5A,W4
0490C:  ADD     W0,W4,W0
0490E:  MOV     [W0],W7
04910:  MOV     1B56,W4
04912:  MUL.UU  W4,#2,W0
04914:  MOV     #AA6,W4
04916:  ADD     W0,W4,W0
04918:  MOV     [W0],W8
0491A:  MOV     W8,W4
0491C:  MUL.UU  W4,#10,W8
0491E:  MOV     1B12,W4
04920:  MUL.UU  W4,#4,W0
04922:  ADD     W0,W8,W0
04924:  MOV     #B5A,W4
04926:  ADD     W0,W4,W0
04928:  MOV     [W0],W8
0492A:  MOV     W7,1B72
0492C:  MOV     W8,1B74
0492E:  PUSH    1B52
04930:  POP     1B76
04932:  PUSH    1B54
04934:  POP     1B78
04936:  CALL    23E2
0493A:  ADD     W0,W6,W0
0493C:  CP      W5,W0
0493E:  BRA     GE,499A
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04940:  MOV     AA2,W4
04942:  MUL.UU  W4,#8,W0
04944:  MOV     W0,W5
04946:  MOV     #ABA,W4
04948:  ADD     W5,W4,W6
0494A:  MOV     1B56,W4
0494C:  MUL.UU  W4,#2,W0
0494E:  MOV     #AA6,W4
04950:  ADD     W0,W4,W0
04952:  MOV     [W0],W7
04954:  MOV     W7,W4
04956:  MUL.UU  W4,#10,W0
04958:  MOV     W0,W7
0495A:  MOV     1B14,W4
0495C:  MUL.UU  W4,#4,W0
0495E:  ADD     W0,W7,W0
04960:  MOV     #B5A,W4
04962:  ADD     W0,W4,W0
04964:  MOV     [W0++],[W6++]
04966:  MOV     [W0++],[W6++]
04968:  MOV     AA2,W4
0496A:  MUL.UU  W4,#8,W0
0496C:  MOV     W0,W5
0496E:  ADD     W5,#4,W5
04970:  MOV     W5,W0
04972:  MOV     #ABA,W4
04974:  ADD     W0,W4,W5
04976:  MOV     1B56,W4
04978:  MUL.UU  W4,#2,W0
0497A:  MOV     #AA6,W4
0497C:  ADD     W0,W4,W0
0497E:  MOV     [W0],W6
04980:  MOV     W6,W4
04982:  MUL.UU  W4,#10,W6
04984:  MOV     1B16,W4
04986:  MUL.UU  W4,#4,W0
04988:  ADD     W0,W6,W0
0498A:  MOV     #B5A,W4
0498C:  ADD     W0,W4,W0
0498E:  MOV     [W0++],[W5++]
04990:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
04992:  MOV     #1,W4
04994:  MOV     W4,AA0
.................... 		                } 
04996:  GOTO    49F0
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0499A:  MOV     AA2,W4
0499C:  MUL.UU  W4,#8,W0
0499E:  MOV     W0,W5
049A0:  MOV     #ABA,W4
049A2:  ADD     W5,W4,W6
049A4:  MOV     1B56,W4
049A6:  MUL.UU  W4,#2,W0
049A8:  MOV     #AA6,W4
049AA:  ADD     W0,W4,W0
049AC:  MOV     [W0],W7
049AE:  MOV     W7,W4
049B0:  MUL.UU  W4,#10,W0
049B2:  MOV     W0,W7
049B4:  MOV     1B10,W4
049B6:  MUL.UU  W4,#4,W0
049B8:  ADD     W0,W7,W0
049BA:  MOV     #B5A,W4
049BC:  ADD     W0,W4,W0
049BE:  MOV     [W0++],[W6++]
049C0:  MOV     [W0++],[W6++]
049C2:  MOV     AA2,W4
049C4:  MUL.UU  W4,#8,W0
049C6:  MOV     W0,W5
049C8:  ADD     W5,#4,W5
049CA:  MOV     W5,W0
049CC:  MOV     #ABA,W4
049CE:  ADD     W0,W4,W5
049D0:  MOV     1B56,W4
049D2:  MUL.UU  W4,#2,W0
049D4:  MOV     #AA6,W4
049D6:  ADD     W0,W4,W0
049D8:  MOV     [W0],W6
049DA:  MOV     W6,W4
049DC:  MUL.UU  W4,#10,W6
049DE:  MOV     1B12,W4
049E0:  MUL.UU  W4,#4,W0
049E2:  ADD     W0,W6,W0
049E4:  MOV     #B5A,W4
049E6:  ADD     W0,W4,W0
049E8:  MOV     [W0++],[W5++]
049EA:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
049EC:  MOV     #1,W4
049EE:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
049F0:  MOV     #1,W4
049F2:  MOV     W4,A98
.................... 		            } 
049F4:  GOTO    4A58
.................... 		            else if (posEnd == 1) 
049F8:  MOV     1B5A,W4
049FA:  CP      W4,#1
049FC:  BRA     NZ,4A58
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
049FE:  MOV     AA2,W4
04A00:  MUL.UU  W4,#8,W0
04A02:  MOV     W0,W5
04A04:  MOV     #ABA,W4
04A06:  ADD     W5,W4,W6
04A08:  MOV     1B56,W4
04A0A:  MUL.UU  W4,#2,W0
04A0C:  MOV     #AA6,W4
04A0E:  ADD     W0,W4,W0
04A10:  MOV     [W0],W7
04A12:  MOV     W7,W4
04A14:  MUL.UU  W4,#10,W0
04A16:  MOV     W0,W7
04A18:  MOV     1B14,W4
04A1A:  MUL.UU  W4,#4,W0
04A1C:  ADD     W0,W7,W0
04A1E:  MOV     #B5A,W4
04A20:  ADD     W0,W4,W0
04A22:  MOV     [W0++],[W6++]
04A24:  MOV     [W0++],[W6++]
04A26:  MOV     AA2,W4
04A28:  MUL.UU  W4,#8,W0
04A2A:  MOV     W0,W5
04A2C:  ADD     W5,#4,W5
04A2E:  MOV     W5,W0
04A30:  MOV     #ABA,W4
04A32:  ADD     W0,W4,W5
04A34:  MOV     1B56,W4
04A36:  MUL.UU  W4,#2,W0
04A38:  MOV     #AA6,W4
04A3A:  ADD     W0,W4,W0
04A3C:  MOV     [W0],W6
04A3E:  MOV     W6,W4
04A40:  MUL.UU  W4,#10,W6
04A42:  MOV     1B16,W4
04A44:  MUL.UU  W4,#4,W0
04A46:  ADD     W0,W6,W0
04A48:  MOV     #B5A,W4
04A4A:  ADD     W0,W4,W0
04A4C:  MOV     [W0++],[W5++]
04A4E:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
04A50:  MOV     #1,W4
04A52:  MOV     W4,AA0
.................... 		                path_found = true; 
04A54:  MOV     #1,W4
04A56:  MOV     W4,A98
.................... 		            } 
.................... 		        } 
.................... 	            break; 
04A58:  GOTO    6324
....................  
.................... 	        case 5: 
....................  
.................... 	        	if(path_opposite) 
04A5C:  CP0     A9C
04A5E:  BRA     Z,5086
.................... 	        	{ 
.................... 	        		if (posEnd == 2) 
04A60:  MOV     1B5A,W4
04A62:  CP      W4,#2
04A64:  BRA     NZ,4B1A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04A66:  MOV     AA2,W4
04A68:  MUL.UU  W4,#8,W0
04A6A:  MOV     W0,W5
04A6C:  MOV     #ABA,W4
04A6E:  ADD     W5,W4,W6
04A70:  MOV     1B56,W4
04A72:  MUL.UU  W4,#2,W0
04A74:  MOV     #AA6,W4
04A76:  ADD     W0,W4,W0
04A78:  MOV     [W0],W7
04A7A:  MOV     W7,W4
04A7C:  MUL.UU  W4,#10,W0
04A7E:  MOV     W0,W7
04A80:  MOV     1B10,W4
04A82:  MUL.UU  W4,#4,W0
04A84:  ADD     W0,W7,W0
04A86:  MOV     #B5A,W4
04A88:  ADD     W0,W4,W0
04A8A:  MOV     [W0++],[W6++]
04A8C:  MOV     [W0++],[W6++]
04A8E:  MOV     AA2,W4
04A90:  MUL.UU  W4,#8,W0
04A92:  MOV     W0,W5
04A94:  ADD     W5,#4,W5
04A96:  MOV     W5,W0
04A98:  MOV     #ABA,W4
04A9A:  ADD     W0,W4,W5
04A9C:  MOV     1B56,W4
04A9E:  MUL.UU  W4,#2,W0
04AA0:  MOV     #AA6,W4
04AA2:  ADD     W0,W4,W0
04AA4:  MOV     [W0],W6
04AA6:  MOV     W6,W4
04AA8:  MUL.UU  W4,#10,W6
04AAA:  MOV     1B12,W4
04AAC:  MUL.UU  W4,#4,W0
04AAE:  ADD     W0,W6,W0
04AB0:  MOV     #B5A,W4
04AB2:  ADD     W0,W4,W0
04AB4:  MOV     [W0++],[W5++]
04AB6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04AB8:  MOV     AA2,W4
04ABA:  ADD     W4,#1,W4
04ABC:  MOV     W4,W5
04ABE:  MOV     W5,W4
04AC0:  MUL.UU  W4,#8,W0
04AC2:  MOV     W0,W5
04AC4:  MOV     #ABA,W4
04AC6:  ADD     W5,W4,W6
04AC8:  MOV     1B56,W4
04ACA:  MUL.UU  W4,#2,W0
04ACC:  MOV     #AA6,W4
04ACE:  ADD     W0,W4,W0
04AD0:  MOV     [W0],W7
04AD2:  MOV     W7,W4
04AD4:  MUL.UU  W4,#10,W0
04AD6:  MOV     W0,W7
04AD8:  MOV     #B5A,W4
04ADA:  ADD     W7,W4,W0
04ADC:  MOV     [W0++],[W6++]
04ADE:  MOV     [W0++],[W6++]
04AE0:  MOV     AA2,W4
04AE2:  ADD     W4,#1,W4
04AE4:  MOV     W4,W5
04AE6:  MOV     W5,W4
04AE8:  MUL.UU  W4,#8,W0
04AEA:  MOV     W0,W5
04AEC:  ADD     W5,#4,W5
04AEE:  MOV     W5,W0
04AF0:  MOV     #ABA,W4
04AF2:  ADD     W0,W4,W5
04AF4:  MOV     1B56,W4
04AF6:  MUL.UU  W4,#2,W0
04AF8:  MOV     #AA6,W4
04AFA:  ADD     W0,W4,W0
04AFC:  MOV     [W0],W6
04AFE:  MOV     W6,W4
04B00:  MUL.UU  W4,#10,W6
04B02:  ADD     W6,#4,W6
04B04:  MOV     W6,W0
04B06:  MOV     #B5A,W4
04B08:  ADD     W0,W4,W0
04B0A:  MOV     [W0++],[W5++]
04B0C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
04B0E:  MOV     #2,W4
04B10:  MOV     W4,AA0
.................... 		                path_found = true; 
04B12:  MOV     #1,W4
04B14:  MOV     W4,A98
.................... 		            } 
04B16:  GOTO    5082
.................... 		            else if (posEnd == 3) 
04B1A:  MOV     1B5A,W4
04B1C:  CP      W4,#3
04B1E:  BRA     NZ,4C32
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04B20:  MOV     AA2,W4
04B22:  MUL.UU  W4,#8,W0
04B24:  MOV     W0,W5
04B26:  MOV     #ABA,W4
04B28:  ADD     W5,W4,W6
04B2A:  MOV     1B56,W4
04B2C:  MUL.UU  W4,#2,W0
04B2E:  MOV     #AA6,W4
04B30:  ADD     W0,W4,W0
04B32:  MOV     [W0],W7
04B34:  MOV     W7,W4
04B36:  MUL.UU  W4,#10,W0
04B38:  MOV     W0,W7
04B3A:  MOV     1B10,W4
04B3C:  MUL.UU  W4,#4,W0
04B3E:  ADD     W0,W7,W0
04B40:  MOV     #B5A,W4
04B42:  ADD     W0,W4,W0
04B44:  MOV     [W0++],[W6++]
04B46:  MOV     [W0++],[W6++]
04B48:  MOV     AA2,W4
04B4A:  MUL.UU  W4,#8,W0
04B4C:  MOV     W0,W5
04B4E:  ADD     W5,#4,W5
04B50:  MOV     W5,W0
04B52:  MOV     #ABA,W4
04B54:  ADD     W0,W4,W5
04B56:  MOV     1B56,W4
04B58:  MUL.UU  W4,#2,W0
04B5A:  MOV     #AA6,W4
04B5C:  ADD     W0,W4,W0
04B5E:  MOV     [W0],W6
04B60:  MOV     W6,W4
04B62:  MUL.UU  W4,#10,W6
04B64:  MOV     1B12,W4
04B66:  MUL.UU  W4,#4,W0
04B68:  ADD     W0,W6,W0
04B6A:  MOV     #B5A,W4
04B6C:  ADD     W0,W4,W0
04B6E:  MOV     [W0++],[W5++]
04B70:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04B72:  MOV     AA2,W4
04B74:  ADD     W4,#1,W4
04B76:  MOV     W4,W5
04B78:  MOV     W5,W4
04B7A:  MUL.UU  W4,#8,W0
04B7C:  MOV     W0,W5
04B7E:  MOV     #ABA,W4
04B80:  ADD     W5,W4,W6
04B82:  MOV     1B56,W4
04B84:  MUL.UU  W4,#2,W0
04B86:  MOV     #AA6,W4
04B88:  ADD     W0,W4,W0
04B8A:  MOV     [W0],W7
04B8C:  MOV     W7,W4
04B8E:  MUL.UU  W4,#10,W0
04B90:  MOV     W0,W7
04B92:  MOV     #B5A,W4
04B94:  ADD     W7,W4,W0
04B96:  MOV     [W0++],[W6++]
04B98:  MOV     [W0++],[W6++]
04B9A:  MOV     AA2,W4
04B9C:  ADD     W4,#1,W4
04B9E:  MOV     W4,W5
04BA0:  MOV     W5,W4
04BA2:  MUL.UU  W4,#8,W0
04BA4:  MOV     W0,W5
04BA6:  ADD     W5,#4,W5
04BA8:  MOV     W5,W0
04BAA:  MOV     #ABA,W4
04BAC:  ADD     W0,W4,W5
04BAE:  MOV     1B56,W4
04BB0:  MUL.UU  W4,#2,W0
04BB2:  MOV     #AA6,W4
04BB4:  ADD     W0,W4,W0
04BB6:  MOV     [W0],W6
04BB8:  MOV     W6,W4
04BBA:  MUL.UU  W4,#10,W6
04BBC:  ADD     W6,#4,W6
04BBE:  MOV     W6,W0
04BC0:  MOV     #B5A,W4
04BC2:  ADD     W0,W4,W0
04BC4:  MOV     [W0++],[W5++]
04BC6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04BC8:  MOV     AA2,W4
04BCA:  ADD     W4,#2,W4
04BCC:  MOV     W4,W5
04BCE:  MOV     W5,W4
04BD0:  MUL.UU  W4,#8,W0
04BD2:  MOV     W0,W5
04BD4:  MOV     #ABA,W4
04BD6:  ADD     W5,W4,W6
04BD8:  MOV     1B56,W4
04BDA:  MUL.UU  W4,#2,W0
04BDC:  MOV     #AA6,W4
04BDE:  ADD     W0,W4,W0
04BE0:  MOV     [W0],W7
04BE2:  MOV     W7,W4
04BE4:  MUL.UU  W4,#10,W0
04BE6:  MOV     W0,W7
04BE8:  MOV     1B14,W4
04BEA:  MUL.UU  W4,#4,W0
04BEC:  ADD     W0,W7,W0
04BEE:  MOV     #B5A,W4
04BF0:  ADD     W0,W4,W0
04BF2:  MOV     [W0++],[W6++]
04BF4:  MOV     [W0++],[W6++]
04BF6:  MOV     AA2,W4
04BF8:  ADD     W4,#2,W4
04BFA:  MOV     W4,W5
04BFC:  MOV     W5,W4
04BFE:  MUL.UU  W4,#8,W0
04C00:  MOV     W0,W5
04C02:  ADD     W5,#4,W5
04C04:  MOV     W5,W0
04C06:  MOV     #ABA,W4
04C08:  ADD     W0,W4,W5
04C0A:  MOV     1B56,W4
04C0C:  MUL.UU  W4,#2,W0
04C0E:  MOV     #AA6,W4
04C10:  ADD     W0,W4,W0
04C12:  MOV     [W0],W6
04C14:  MOV     W6,W4
04C16:  MUL.UU  W4,#10,W6
04C18:  MOV     1B16,W4
04C1A:  MUL.UU  W4,#4,W0
04C1C:  ADD     W0,W6,W0
04C1E:  MOV     #B5A,W4
04C20:  ADD     W0,W4,W0
04C22:  MOV     [W0++],[W5++]
04C24:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
04C26:  MOV     #3,W4
04C28:  MOV     W4,AA0
.................... 		                path_found = true; 
04C2A:  MOV     #1,W4
04C2C:  MOV     W4,A98
.................... 		            } 
04C2E:  GOTO    5082
.................... 		            else if (posEnd == 1) 
04C32:  MOV     1B5A,W4
04C34:  CP      W4,#1
04C36:  BRA     NZ,4EB6
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
04C38:  MOV     1B56,W4
04C3A:  MUL.UU  W4,#2,W0
04C3C:  MOV     #AA6,W4
04C3E:  ADD     W0,W4,W0
04C40:  MOV     [W0],W5
04C42:  MOV     W5,W4
04C44:  MUL.UU  W4,#10,W0
04C46:  MOV     W0,W5
04C48:  MOV     1B10,W4
04C4A:  MUL.UU  W4,#4,W0
04C4C:  ADD     W0,W5,W0
04C4E:  MOV     #B5A,W4
04C50:  ADD     W0,W4,W0
04C52:  MOV     [W0],W5
04C54:  MOV     1B56,W4
04C56:  MUL.UU  W4,#2,W0
04C58:  MOV     #AA6,W4
04C5A:  ADD     W0,W4,W0
04C5C:  MOV     [W0],W6
04C5E:  MOV     W6,W4
04C60:  MUL.UU  W4,#10,W6
04C62:  MOV     1B12,W4
04C64:  MUL.UU  W4,#4,W0
04C66:  ADD     W0,W6,W0
04C68:  MOV     #B5A,W4
04C6A:  ADD     W0,W4,W0
04C6C:  MOV     [W0],W6
04C6E:  PUSH    1B4E
04C70:  POP     1B72
04C72:  PUSH    1B50
04C74:  POP     1B74
04C76:  MOV     W5,1B76
04C78:  MOV     W6,1B78
04C7A:  CALL    23E2
04C7E:  MOV     W0,W5
04C80:  MOV     1B56,W4
04C82:  MUL.UU  W4,#2,W0
04C84:  MOV     #AA6,W4
04C86:  ADD     W0,W4,W0
04C88:  MOV     [W0],W6
04C8A:  MOV     W6,W4
04C8C:  MUL.UU  W4,#10,W6
04C8E:  MOV     #B5A,W4
04C90:  ADD     W6,W4,W0
04C92:  MOV     [W0],W7
04C94:  MOV     1B56,W4
04C96:  MUL.UU  W4,#2,W0
04C98:  MOV     #AA6,W4
04C9A:  ADD     W0,W4,W0
04C9C:  MOV     [W0],W8
04C9E:  MOV     W8,W4
04CA0:  MUL.UU  W4,#10,W8
04CA2:  ADD     W8,#4,W8
04CA4:  MOV     W8,W0
04CA6:  MOV     #B5A,W4
04CA8:  ADD     W0,W4,W0
04CAA:  MOV     [W0],W8
04CAC:  MOV     W7,1B72
04CAE:  MOV     W8,1B74
04CB0:  PUSH    1B52
04CB2:  POP     1B76
04CB4:  PUSH    1B54
04CB6:  POP     1B78
04CB8:  CALL    23E2
04CBC:  ADD     W0,W5,W5
04CBE:  MOV     1B56,W4
04CC0:  MUL.UU  W4,#2,W0
04CC2:  MOV     #AA6,W4
04CC4:  ADD     W0,W4,W0
04CC6:  MOV     [W0],W7
04CC8:  MOV     W7,W4
04CCA:  MUL.UU  W4,#10,W0
04CCC:  MOV     W0,W7
04CCE:  ADD     W7,#8,W7
04CD0:  MOV     W7,W0
04CD2:  MOV     #B5A,W4
04CD4:  ADD     W0,W4,W0
04CD6:  MOV     [W0],W7
04CD8:  MOV     1B56,W4
04CDA:  MUL.UU  W4,#2,W0
04CDC:  MOV     #AA6,W4
04CDE:  ADD     W0,W4,W0
04CE0:  MOV     [W0],W8
04CE2:  MOV     W8,W4
04CE4:  MUL.UU  W4,#10,W8
04CE6:  ADD     W8,#C,W8
04CE8:  MOV     W8,W0
04CEA:  MOV     #B5A,W4
04CEC:  ADD     W0,W4,W0
04CEE:  MOV     [W0],W8
04CF0:  PUSH    1B4E
04CF2:  POP     1B72
04CF4:  PUSH    1B50
04CF6:  POP     1B74
04CF8:  MOV     W7,1B76
04CFA:  MOV     W8,1B78
04CFC:  CALL    23E2
04D00:  MOV     W0,W7
04D02:  MOV     1B56,W4
04D04:  MUL.UU  W4,#2,W0
04D06:  MOV     #AA6,W4
04D08:  ADD     W0,W4,W0
04D0A:  MOV     [W0],W8
04D0C:  MOV     W8,W4
04D0E:  MUL.UU  W4,#10,W8
04D10:  MOV     1B14,W4
04D12:  MUL.UU  W4,#4,W0
04D14:  ADD     W0,W8,W0
04D16:  MOV     #B5A,W4
04D18:  ADD     W0,W4,W0
04D1A:  MOV     [W0],W8
04D1C:  MOV     1B56,W4
04D1E:  MUL.UU  W4,#2,W0
04D20:  MOV     #AA6,W4
04D22:  ADD     W0,W4,W0
04D24:  MOV     [W0],W9
04D26:  MOV     W9,W4
04D28:  MUL.UU  W4,#10,W0
04D2A:  MOV     W0,W9
04D2C:  MOV     1B16,W4
04D2E:  MUL.UU  W4,#4,W0
04D30:  ADD     W0,W9,W0
04D32:  MOV     #B5A,W4
04D34:  ADD     W0,W4,W0
04D36:  MOV     [W0],W9
04D38:  MOV     W8,1B72
04D3A:  MOV     W9,1B74
04D3C:  PUSH    1B52
04D3E:  POP     1B76
04D40:  PUSH    1B54
04D42:  POP     1B78
04D44:  CALL    23E2
04D48:  ADD     W0,W7,W0
04D4A:  CP      W5,W0
04D4C:  BRA     GE,4E02
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04D4E:  MOV     AA2,W4
04D50:  MUL.UU  W4,#8,W0
04D52:  MOV     W0,W5
04D54:  MOV     #ABA,W4
04D56:  ADD     W5,W4,W6
04D58:  MOV     1B56,W4
04D5A:  MUL.UU  W4,#2,W0
04D5C:  MOV     #AA6,W4
04D5E:  ADD     W0,W4,W0
04D60:  MOV     [W0],W7
04D62:  MOV     W7,W4
04D64:  MUL.UU  W4,#10,W0
04D66:  MOV     W0,W7
04D68:  ADD     W7,#8,W7
04D6A:  MOV     W7,W0
04D6C:  MOV     #B5A,W4
04D6E:  ADD     W0,W4,W0
04D70:  MOV     [W0++],[W6++]
04D72:  MOV     [W0++],[W6++]
04D74:  MOV     AA2,W4
04D76:  MUL.UU  W4,#8,W0
04D78:  MOV     W0,W5
04D7A:  ADD     W5,#4,W5
04D7C:  MOV     W5,W0
04D7E:  MOV     #ABA,W4
04D80:  ADD     W0,W4,W5
04D82:  MOV     1B56,W4
04D84:  MUL.UU  W4,#2,W0
04D86:  MOV     #AA6,W4
04D88:  ADD     W0,W4,W0
04D8A:  MOV     [W0],W6
04D8C:  MOV     W6,W4
04D8E:  MUL.UU  W4,#10,W6
04D90:  ADD     W6,#C,W6
04D92:  MOV     W6,W0
04D94:  MOV     #B5A,W4
04D96:  ADD     W0,W4,W0
04D98:  MOV     [W0++],[W5++]
04D9A:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04D9C:  MOV     AA2,W4
04D9E:  ADD     W4,#1,W4
04DA0:  MOV     W4,W5
04DA2:  MOV     W5,W4
04DA4:  MUL.UU  W4,#8,W0
04DA6:  MOV     W0,W5
04DA8:  MOV     #ABA,W4
04DAA:  ADD     W5,W4,W6
04DAC:  MOV     1B56,W4
04DAE:  MUL.UU  W4,#2,W0
04DB0:  MOV     #AA6,W4
04DB2:  ADD     W0,W4,W0
04DB4:  MOV     [W0],W7
04DB6:  MOV     W7,W4
04DB8:  MUL.UU  W4,#10,W0
04DBA:  MOV     W0,W7
04DBC:  MOV     1B14,W4
04DBE:  MUL.UU  W4,#4,W0
04DC0:  ADD     W0,W7,W0
04DC2:  MOV     #B5A,W4
04DC4:  ADD     W0,W4,W0
04DC6:  MOV     [W0++],[W6++]
04DC8:  MOV     [W0++],[W6++]
04DCA:  MOV     AA2,W4
04DCC:  ADD     W4,#1,W4
04DCE:  MOV     W4,W5
04DD0:  MOV     W5,W4
04DD2:  MUL.UU  W4,#8,W0
04DD4:  MOV     W0,W5
04DD6:  ADD     W5,#4,W5
04DD8:  MOV     W5,W0
04DDA:  MOV     #ABA,W4
04DDC:  ADD     W0,W4,W5
04DDE:  MOV     1B56,W4
04DE0:  MUL.UU  W4,#2,W0
04DE2:  MOV     #AA6,W4
04DE4:  ADD     W0,W4,W0
04DE6:  MOV     [W0],W6
04DE8:  MOV     W6,W4
04DEA:  MUL.UU  W4,#10,W6
04DEC:  MOV     1B16,W4
04DEE:  MUL.UU  W4,#4,W0
04DF0:  ADD     W0,W6,W0
04DF2:  MOV     #B5A,W4
04DF4:  ADD     W0,W4,W0
04DF6:  MOV     [W0++],[W5++]
04DF8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
04DFA:  MOV     #2,W4
04DFC:  MOV     W4,AA0
.................... 		                } 
04DFE:  GOTO    4EAE
.................... 		                else 
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3];  
04E02:  MOV     AA2,W4
04E04:  MUL.UU  W4,#8,W0
04E06:  MOV     W0,W5
04E08:  MOV     #ABA,W4
04E0A:  ADD     W5,W4,W6
04E0C:  MOV     1B56,W4
04E0E:  MUL.UU  W4,#2,W0
04E10:  MOV     #AA6,W4
04E12:  ADD     W0,W4,W0
04E14:  MOV     [W0],W7
04E16:  MOV     W7,W4
04E18:  MUL.UU  W4,#10,W0
04E1A:  MOV     W0,W7
04E1C:  MOV     1B10,W4
04E1E:  MUL.UU  W4,#4,W0
04E20:  ADD     W0,W7,W0
04E22:  MOV     #B5A,W4
04E24:  ADD     W0,W4,W0
04E26:  MOV     [W0++],[W6++]
04E28:  MOV     [W0++],[W6++]
04E2A:  MOV     AA2,W4
04E2C:  MUL.UU  W4,#8,W0
04E2E:  MOV     W0,W5
04E30:  ADD     W5,#4,W5
04E32:  MOV     W5,W0
04E34:  MOV     #ABA,W4
04E36:  ADD     W0,W4,W5
04E38:  MOV     1B56,W4
04E3A:  MUL.UU  W4,#2,W0
04E3C:  MOV     #AA6,W4
04E3E:  ADD     W0,W4,W0
04E40:  MOV     [W0],W6
04E42:  MOV     W6,W4
04E44:  MUL.UU  W4,#10,W6
04E46:  MOV     1B12,W4
04E48:  MUL.UU  W4,#4,W0
04E4A:  ADD     W0,W6,W0
04E4C:  MOV     #B5A,W4
04E4E:  ADD     W0,W4,W0
04E50:  MOV     [W0++],[W5++]
04E52:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04E54:  MOV     AA2,W4
04E56:  ADD     W4,#1,W4
04E58:  MOV     W4,W5
04E5A:  MOV     W5,W4
04E5C:  MUL.UU  W4,#8,W0
04E5E:  MOV     W0,W5
04E60:  MOV     #ABA,W4
04E62:  ADD     W5,W4,W6
04E64:  MOV     1B56,W4
04E66:  MUL.UU  W4,#2,W0
04E68:  MOV     #AA6,W4
04E6A:  ADD     W0,W4,W0
04E6C:  MOV     [W0],W7
04E6E:  MOV     W7,W4
04E70:  MUL.UU  W4,#10,W0
04E72:  MOV     W0,W7
04E74:  MOV     #B5A,W4
04E76:  ADD     W7,W4,W0
04E78:  MOV     [W0++],[W6++]
04E7A:  MOV     [W0++],[W6++]
04E7C:  MOV     AA2,W4
04E7E:  ADD     W4,#1,W4
04E80:  MOV     W4,W5
04E82:  MOV     W5,W4
04E84:  MUL.UU  W4,#8,W0
04E86:  MOV     W0,W5
04E88:  ADD     W5,#4,W5
04E8A:  MOV     W5,W0
04E8C:  MOV     #ABA,W4
04E8E:  ADD     W0,W4,W5
04E90:  MOV     1B56,W4
04E92:  MUL.UU  W4,#2,W0
04E94:  MOV     #AA6,W4
04E96:  ADD     W0,W4,W0
04E98:  MOV     [W0],W6
04E9A:  MOV     W6,W4
04E9C:  MUL.UU  W4,#10,W6
04E9E:  ADD     W6,#4,W6
04EA0:  MOV     W6,W0
04EA2:  MOV     #B5A,W4
04EA4:  ADD     W0,W4,W0
04EA6:  MOV     [W0++],[W5++]
04EA8:  MOV     [W0++],[W5++]
.................... 		                      
.................... 		                    relay_point_number = 2; 
04EAA:  MOV     #2,W4
04EAC:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
04EAE:  MOV     #1,W4
04EB0:  MOV     W4,A98
.................... 		            } 
04EB2:  GOTO    5082
.................... 		            else if (posEnd == 7) 
04EB6:  MOV     1B5A,W4
04EB8:  CP      W4,#7
04EBA:  BRA     NZ,4FCA
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04EBC:  MOV     AA2,W4
04EBE:  MUL.UU  W4,#8,W0
04EC0:  MOV     W0,W5
04EC2:  MOV     #ABA,W4
04EC4:  ADD     W5,W4,W6
04EC6:  MOV     1B56,W4
04EC8:  MUL.UU  W4,#2,W0
04ECA:  MOV     #AA6,W4
04ECC:  ADD     W0,W4,W0
04ECE:  MOV     [W0],W7
04ED0:  MOV     W7,W4
04ED2:  MUL.UU  W4,#10,W0
04ED4:  MOV     W0,W7
04ED6:  ADD     W7,#8,W7
04ED8:  MOV     W7,W0
04EDA:  MOV     #B5A,W4
04EDC:  ADD     W0,W4,W0
04EDE:  MOV     [W0++],[W6++]
04EE0:  MOV     [W0++],[W6++]
04EE2:  MOV     AA2,W4
04EE4:  MUL.UU  W4,#8,W0
04EE6:  MOV     W0,W5
04EE8:  ADD     W5,#4,W5
04EEA:  MOV     W5,W0
04EEC:  MOV     #ABA,W4
04EEE:  ADD     W0,W4,W5
04EF0:  MOV     1B56,W4
04EF2:  MUL.UU  W4,#2,W0
04EF4:  MOV     #AA6,W4
04EF6:  ADD     W0,W4,W0
04EF8:  MOV     [W0],W6
04EFA:  MOV     W6,W4
04EFC:  MUL.UU  W4,#10,W6
04EFE:  ADD     W6,#C,W6
04F00:  MOV     W6,W0
04F02:  MOV     #B5A,W4
04F04:  ADD     W0,W4,W0
04F06:  MOV     [W0++],[W5++]
04F08:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04F0A:  MOV     AA2,W4
04F0C:  ADD     W4,#1,W4
04F0E:  MOV     W4,W5
04F10:  MOV     W5,W4
04F12:  MUL.UU  W4,#8,W0
04F14:  MOV     W0,W5
04F16:  MOV     #ABA,W4
04F18:  ADD     W5,W4,W6
04F1A:  MOV     1B56,W4
04F1C:  MUL.UU  W4,#2,W0
04F1E:  MOV     #AA6,W4
04F20:  ADD     W0,W4,W0
04F22:  MOV     [W0],W7
04F24:  MOV     W7,W4
04F26:  MUL.UU  W4,#10,W0
04F28:  MOV     W0,W7
04F2A:  MOV     1B14,W4
04F2C:  MUL.UU  W4,#4,W0
04F2E:  ADD     W0,W7,W0
04F30:  MOV     #B5A,W4
04F32:  ADD     W0,W4,W0
04F34:  MOV     [W0++],[W6++]
04F36:  MOV     [W0++],[W6++]
04F38:  MOV     AA2,W4
04F3A:  ADD     W4,#1,W4
04F3C:  MOV     W4,W5
04F3E:  MOV     W5,W4
04F40:  MUL.UU  W4,#8,W0
04F42:  MOV     W0,W5
04F44:  ADD     W5,#4,W5
04F46:  MOV     W5,W0
04F48:  MOV     #ABA,W4
04F4A:  ADD     W0,W4,W5
04F4C:  MOV     1B56,W4
04F4E:  MUL.UU  W4,#2,W0
04F50:  MOV     #AA6,W4
04F52:  ADD     W0,W4,W0
04F54:  MOV     [W0],W6
04F56:  MOV     W6,W4
04F58:  MUL.UU  W4,#10,W6
04F5A:  MOV     1B16,W4
04F5C:  MUL.UU  W4,#4,W0
04F5E:  ADD     W0,W6,W0
04F60:  MOV     #B5A,W4
04F62:  ADD     W0,W4,W0
04F64:  MOV     [W0++],[W5++]
04F66:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04F68:  MOV     AA2,W4
04F6A:  ADD     W4,#2,W4
04F6C:  MOV     W4,W5
04F6E:  MOV     W5,W4
04F70:  MUL.UU  W4,#8,W0
04F72:  MOV     W0,W5
04F74:  MOV     #ABA,W4
04F76:  ADD     W5,W4,W6
04F78:  MOV     1B56,W4
04F7A:  MUL.UU  W4,#2,W0
04F7C:  MOV     #AA6,W4
04F7E:  ADD     W0,W4,W0
04F80:  MOV     [W0],W7
04F82:  MOV     W7,W4
04F84:  MUL.UU  W4,#10,W0
04F86:  MOV     W0,W7
04F88:  MOV     #B5A,W4
04F8A:  ADD     W7,W4,W0
04F8C:  MOV     [W0++],[W6++]
04F8E:  MOV     [W0++],[W6++]
04F90:  MOV     AA2,W4
04F92:  ADD     W4,#2,W4
04F94:  MOV     W4,W5
04F96:  MOV     W5,W4
04F98:  MUL.UU  W4,#8,W0
04F9A:  MOV     W0,W5
04F9C:  ADD     W5,#4,W5
04F9E:  MOV     W5,W0
04FA0:  MOV     #ABA,W4
04FA2:  ADD     W0,W4,W5
04FA4:  MOV     1B56,W4
04FA6:  MUL.UU  W4,#2,W0
04FA8:  MOV     #AA6,W4
04FAA:  ADD     W0,W4,W0
04FAC:  MOV     [W0],W6
04FAE:  MOV     W6,W4
04FB0:  MUL.UU  W4,#10,W6
04FB2:  ADD     W6,#4,W6
04FB4:  MOV     W6,W0
04FB6:  MOV     #B5A,W4
04FB8:  ADD     W0,W4,W0
04FBA:  MOV     [W0++],[W5++]
04FBC:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
04FBE:  MOV     #3,W4
04FC0:  MOV     W4,AA0
.................... 		                path_found = true; 
04FC2:  MOV     #1,W4
04FC4:  MOV     W4,A98
.................... 		            } 
04FC6:  GOTO    5082
.................... 		            else if(posEnd == 0) 
04FCA:  CP0     1B5A
04FCC:  BRA     NZ,5082
.................... 		            { 
.................... 						PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04FCE:  MOV     AA2,W4
04FD0:  MUL.UU  W4,#8,W0
04FD2:  MOV     W0,W5
04FD4:  MOV     #ABA,W4
04FD6:  ADD     W5,W4,W6
04FD8:  MOV     1B56,W4
04FDA:  MUL.UU  W4,#2,W0
04FDC:  MOV     #AA6,W4
04FDE:  ADD     W0,W4,W0
04FE0:  MOV     [W0],W7
04FE2:  MOV     W7,W4
04FE4:  MUL.UU  W4,#10,W0
04FE6:  MOV     W0,W7
04FE8:  ADD     W7,#8,W7
04FEA:  MOV     W7,W0
04FEC:  MOV     #B5A,W4
04FEE:  ADD     W0,W4,W0
04FF0:  MOV     [W0++],[W6++]
04FF2:  MOV     [W0++],[W6++]
04FF4:  MOV     AA2,W4
04FF6:  MUL.UU  W4,#8,W0
04FF8:  MOV     W0,W5
04FFA:  ADD     W5,#4,W5
04FFC:  MOV     W5,W0
04FFE:  MOV     #ABA,W4
05000:  ADD     W0,W4,W5
05002:  MOV     1B56,W4
05004:  MUL.UU  W4,#2,W0
05006:  MOV     #AA6,W4
05008:  ADD     W0,W4,W0
0500A:  MOV     [W0],W6
0500C:  MOV     W6,W4
0500E:  MUL.UU  W4,#10,W6
05010:  ADD     W6,#C,W6
05012:  MOV     W6,W0
05014:  MOV     #B5A,W4
05016:  ADD     W0,W4,W0
05018:  MOV     [W0++],[W5++]
0501A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0501C:  MOV     AA2,W4
0501E:  ADD     W4,#1,W4
05020:  MOV     W4,W5
05022:  MOV     W5,W4
05024:  MUL.UU  W4,#8,W0
05026:  MOV     W0,W5
05028:  MOV     #ABA,W4
0502A:  ADD     W5,W4,W6
0502C:  MOV     1B56,W4
0502E:  MUL.UU  W4,#2,W0
05030:  MOV     #AA6,W4
05032:  ADD     W0,W4,W0
05034:  MOV     [W0],W7
05036:  MOV     W7,W4
05038:  MUL.UU  W4,#10,W0
0503A:  MOV     W0,W7
0503C:  MOV     1B14,W4
0503E:  MUL.UU  W4,#4,W0
05040:  ADD     W0,W7,W0
05042:  MOV     #B5A,W4
05044:  ADD     W0,W4,W0
05046:  MOV     [W0++],[W6++]
05048:  MOV     [W0++],[W6++]
0504A:  MOV     AA2,W4
0504C:  ADD     W4,#1,W4
0504E:  MOV     W4,W5
05050:  MOV     W5,W4
05052:  MUL.UU  W4,#8,W0
05054:  MOV     W0,W5
05056:  ADD     W5,#4,W5
05058:  MOV     W5,W0
0505A:  MOV     #ABA,W4
0505C:  ADD     W0,W4,W5
0505E:  MOV     1B56,W4
05060:  MUL.UU  W4,#2,W0
05062:  MOV     #AA6,W4
05064:  ADD     W0,W4,W0
05066:  MOV     [W0],W6
05068:  MOV     W6,W4
0506A:  MUL.UU  W4,#10,W6
0506C:  MOV     1B16,W4
0506E:  MUL.UU  W4,#4,W0
05070:  ADD     W0,W6,W0
05072:  MOV     #B5A,W4
05074:  ADD     W0,W4,W0
05076:  MOV     [W0++],[W5++]
05078:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0507A:  MOV     #2,W4
0507C:  MOV     W4,AA0
.................... 		                path_found = true; 
0507E:  MOV     #1,W4
05080:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
05082:  GOTO    53D4
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 2 || posEnd == 3) 
05086:  MOV     1B5A,W4
05088:  CP      W4,#2
0508A:  BRA     Z,5092
0508C:  MOV     1B5A,W4
0508E:  CP      W4,#3
05090:  BRA     NZ,50EC
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05092:  MOV     AA2,W4
05094:  MUL.UU  W4,#8,W0
05096:  MOV     W0,W5
05098:  MOV     #ABA,W4
0509A:  ADD     W5,W4,W6
0509C:  MOV     1B56,W4
0509E:  MUL.UU  W4,#2,W0
050A0:  MOV     #AA6,W4
050A2:  ADD     W0,W4,W0
050A4:  MOV     [W0],W7
050A6:  MOV     W7,W4
050A8:  MUL.UU  W4,#10,W0
050AA:  MOV     W0,W7
050AC:  ADD     W7,#8,W7
050AE:  MOV     W7,W0
050B0:  MOV     #B5A,W4
050B2:  ADD     W0,W4,W0
050B4:  MOV     [W0++],[W6++]
050B6:  MOV     [W0++],[W6++]
050B8:  MOV     AA2,W4
050BA:  MUL.UU  W4,#8,W0
050BC:  MOV     W0,W5
050BE:  ADD     W5,#4,W5
050C0:  MOV     W5,W0
050C2:  MOV     #ABA,W4
050C4:  ADD     W0,W4,W5
050C6:  MOV     1B56,W4
050C8:  MUL.UU  W4,#2,W0
050CA:  MOV     #AA6,W4
050CC:  ADD     W0,W4,W0
050CE:  MOV     [W0],W6
050D0:  MOV     W6,W4
050D2:  MUL.UU  W4,#10,W6
050D4:  ADD     W6,#C,W6
050D6:  MOV     W6,W0
050D8:  MOV     #B5A,W4
050DA:  ADD     W0,W4,W0
050DC:  MOV     [W0++],[W5++]
050DE:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
050E0:  MOV     #1,W4
050E2:  MOV     W4,AA0
.................... 		                path_found = true; 
050E4:  MOV     #1,W4
050E6:  MOV     W4,A98
.................... 		            } 
050E8:  GOTO    53D4
.................... 		            else if (posEnd == 1) 
050EC:  MOV     1B5A,W4
050EE:  CP      W4,#1
050F0:  BRA     NZ,5370
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
050F2:  MOV     1B56,W4
050F4:  MUL.UU  W4,#2,W0
050F6:  MOV     #AA6,W4
050F8:  ADD     W0,W4,W0
050FA:  MOV     [W0],W5
050FC:  MOV     W5,W4
050FE:  MUL.UU  W4,#10,W0
05100:  MOV     W0,W5
05102:  MOV     1B10,W4
05104:  MUL.UU  W4,#4,W0
05106:  ADD     W0,W5,W0
05108:  MOV     #B5A,W4
0510A:  ADD     W0,W4,W0
0510C:  MOV     [W0],W5
0510E:  MOV     1B56,W4
05110:  MUL.UU  W4,#2,W0
05112:  MOV     #AA6,W4
05114:  ADD     W0,W4,W0
05116:  MOV     [W0],W6
05118:  MOV     W6,W4
0511A:  MUL.UU  W4,#10,W6
0511C:  MOV     1B12,W4
0511E:  MUL.UU  W4,#4,W0
05120:  ADD     W0,W6,W0
05122:  MOV     #B5A,W4
05124:  ADD     W0,W4,W0
05126:  MOV     [W0],W6
05128:  PUSH    1B4E
0512A:  POP     1B72
0512C:  PUSH    1B50
0512E:  POP     1B74
05130:  MOV     W5,1B76
05132:  MOV     W6,1B78
05134:  CALL    23E2
05138:  MOV     W0,W5
0513A:  MOV     1B56,W4
0513C:  MUL.UU  W4,#2,W0
0513E:  MOV     #AA6,W4
05140:  ADD     W0,W4,W0
05142:  MOV     [W0],W6
05144:  MOV     W6,W4
05146:  MUL.UU  W4,#10,W6
05148:  MOV     #B5A,W4
0514A:  ADD     W6,W4,W0
0514C:  MOV     [W0],W7
0514E:  MOV     1B56,W4
05150:  MUL.UU  W4,#2,W0
05152:  MOV     #AA6,W4
05154:  ADD     W0,W4,W0
05156:  MOV     [W0],W8
05158:  MOV     W8,W4
0515A:  MUL.UU  W4,#10,W8
0515C:  ADD     W8,#4,W8
0515E:  MOV     W8,W0
05160:  MOV     #B5A,W4
05162:  ADD     W0,W4,W0
05164:  MOV     [W0],W8
05166:  MOV     W7,1B72
05168:  MOV     W8,1B74
0516A:  PUSH    1B52
0516C:  POP     1B76
0516E:  PUSH    1B54
05170:  POP     1B78
05172:  CALL    23E2
05176:  ADD     W0,W5,W5
05178:  MOV     1B56,W4
0517A:  MUL.UU  W4,#2,W0
0517C:  MOV     #AA6,W4
0517E:  ADD     W0,W4,W0
05180:  MOV     [W0],W7
05182:  MOV     W7,W4
05184:  MUL.UU  W4,#10,W0
05186:  MOV     W0,W7
05188:  ADD     W7,#8,W7
0518A:  MOV     W7,W0
0518C:  MOV     #B5A,W4
0518E:  ADD     W0,W4,W0
05190:  MOV     [W0],W7
05192:  MOV     1B56,W4
05194:  MUL.UU  W4,#2,W0
05196:  MOV     #AA6,W4
05198:  ADD     W0,W4,W0
0519A:  MOV     [W0],W8
0519C:  MOV     W8,W4
0519E:  MUL.UU  W4,#10,W8
051A0:  ADD     W8,#C,W8
051A2:  MOV     W8,W0
051A4:  MOV     #B5A,W4
051A6:  ADD     W0,W4,W0
051A8:  MOV     [W0],W8
051AA:  PUSH    1B4E
051AC:  POP     1B72
051AE:  PUSH    1B50
051B0:  POP     1B74
051B2:  MOV     W7,1B76
051B4:  MOV     W8,1B78
051B6:  CALL    23E2
051BA:  MOV     W0,W7
051BC:  MOV     1B56,W4
051BE:  MUL.UU  W4,#2,W0
051C0:  MOV     #AA6,W4
051C2:  ADD     W0,W4,W0
051C4:  MOV     [W0],W8
051C6:  MOV     W8,W4
051C8:  MUL.UU  W4,#10,W8
051CA:  MOV     1B14,W4
051CC:  MUL.UU  W4,#4,W0
051CE:  ADD     W0,W8,W0
051D0:  MOV     #B5A,W4
051D2:  ADD     W0,W4,W0
051D4:  MOV     [W0],W8
051D6:  MOV     1B56,W4
051D8:  MUL.UU  W4,#2,W0
051DA:  MOV     #AA6,W4
051DC:  ADD     W0,W4,W0
051DE:  MOV     [W0],W9
051E0:  MOV     W9,W4
051E2:  MUL.UU  W4,#10,W0
051E4:  MOV     W0,W9
051E6:  MOV     1B16,W4
051E8:  MUL.UU  W4,#4,W0
051EA:  ADD     W0,W9,W0
051EC:  MOV     #B5A,W4
051EE:  ADD     W0,W4,W0
051F0:  MOV     [W0],W9
051F2:  MOV     W8,1B72
051F4:  MOV     W9,1B74
051F6:  PUSH    1B52
051F8:  POP     1B76
051FA:  PUSH    1B54
051FC:  POP     1B78
051FE:  CALL    23E2
05202:  ADD     W0,W7,W0
05204:  CP      W5,W0
05206:  BRA     GE,52B8
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3];  
05208:  MOV     AA2,W4
0520A:  MUL.UU  W4,#8,W0
0520C:  MOV     W0,W5
0520E:  MOV     #ABA,W4
05210:  ADD     W5,W4,W6
05212:  MOV     1B56,W4
05214:  MUL.UU  W4,#2,W0
05216:  MOV     #AA6,W4
05218:  ADD     W0,W4,W0
0521A:  MOV     [W0],W7
0521C:  MOV     W7,W4
0521E:  MUL.UU  W4,#10,W0
05220:  MOV     W0,W7
05222:  MOV     1B10,W4
05224:  MUL.UU  W4,#4,W0
05226:  ADD     W0,W7,W0
05228:  MOV     #B5A,W4
0522A:  ADD     W0,W4,W0
0522C:  MOV     [W0++],[W6++]
0522E:  MOV     [W0++],[W6++]
05230:  MOV     AA2,W4
05232:  MUL.UU  W4,#8,W0
05234:  MOV     W0,W5
05236:  ADD     W5,#4,W5
05238:  MOV     W5,W0
0523A:  MOV     #ABA,W4
0523C:  ADD     W0,W4,W5
0523E:  MOV     1B56,W4
05240:  MUL.UU  W4,#2,W0
05242:  MOV     #AA6,W4
05244:  ADD     W0,W4,W0
05246:  MOV     [W0],W6
05248:  MOV     W6,W4
0524A:  MUL.UU  W4,#10,W6
0524C:  MOV     1B12,W4
0524E:  MUL.UU  W4,#4,W0
05250:  ADD     W0,W6,W0
05252:  MOV     #B5A,W4
05254:  ADD     W0,W4,W0
05256:  MOV     [W0++],[W5++]
05258:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0525A:  MOV     AA2,W4
0525C:  ADD     W4,#1,W4
0525E:  MOV     W4,W5
05260:  MOV     W5,W4
05262:  MUL.UU  W4,#8,W0
05264:  MOV     W0,W5
05266:  MOV     #ABA,W4
05268:  ADD     W5,W4,W6
0526A:  MOV     1B56,W4
0526C:  MUL.UU  W4,#2,W0
0526E:  MOV     #AA6,W4
05270:  ADD     W0,W4,W0
05272:  MOV     [W0],W7
05274:  MOV     W7,W4
05276:  MUL.UU  W4,#10,W0
05278:  MOV     W0,W7
0527A:  MOV     #B5A,W4
0527C:  ADD     W7,W4,W0
0527E:  MOV     [W0++],[W6++]
05280:  MOV     [W0++],[W6++]
05282:  MOV     AA2,W4
05284:  ADD     W4,#1,W4
05286:  MOV     W4,W5
05288:  MOV     W5,W4
0528A:  MUL.UU  W4,#8,W0
0528C:  MOV     W0,W5
0528E:  ADD     W5,#4,W5
05290:  MOV     W5,W0
05292:  MOV     #ABA,W4
05294:  ADD     W0,W4,W5
05296:  MOV     1B56,W4
05298:  MUL.UU  W4,#2,W0
0529A:  MOV     #AA6,W4
0529C:  ADD     W0,W4,W0
0529E:  MOV     [W0],W6
052A0:  MOV     W6,W4
052A2:  MUL.UU  W4,#10,W6
052A4:  ADD     W6,#4,W6
052A6:  MOV     W6,W0
052A8:  MOV     #B5A,W4
052AA:  ADD     W0,W4,W0
052AC:  MOV     [W0++],[W5++]
052AE:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
052B0:  MOV     #2,W4
052B2:  MOV     W4,AA0
.................... 		                } 
052B4:  GOTO    5368
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
052B8:  MOV     AA2,W4
052BA:  MUL.UU  W4,#8,W0
052BC:  MOV     W0,W5
052BE:  MOV     #ABA,W4
052C0:  ADD     W5,W4,W6
052C2:  MOV     1B56,W4
052C4:  MUL.UU  W4,#2,W0
052C6:  MOV     #AA6,W4
052C8:  ADD     W0,W4,W0
052CA:  MOV     [W0],W7
052CC:  MOV     W7,W4
052CE:  MUL.UU  W4,#10,W0
052D0:  MOV     W0,W7
052D2:  ADD     W7,#8,W7
052D4:  MOV     W7,W0
052D6:  MOV     #B5A,W4
052D8:  ADD     W0,W4,W0
052DA:  MOV     [W0++],[W6++]
052DC:  MOV     [W0++],[W6++]
052DE:  MOV     AA2,W4
052E0:  MUL.UU  W4,#8,W0
052E2:  MOV     W0,W5
052E4:  ADD     W5,#4,W5
052E6:  MOV     W5,W0
052E8:  MOV     #ABA,W4
052EA:  ADD     W0,W4,W5
052EC:  MOV     1B56,W4
052EE:  MUL.UU  W4,#2,W0
052F0:  MOV     #AA6,W4
052F2:  ADD     W0,W4,W0
052F4:  MOV     [W0],W6
052F6:  MOV     W6,W4
052F8:  MUL.UU  W4,#10,W6
052FA:  ADD     W6,#C,W6
052FC:  MOV     W6,W0
052FE:  MOV     #B5A,W4
05300:  ADD     W0,W4,W0
05302:  MOV     [W0++],[W5++]
05304:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2];  
05306:  MOV     AA2,W4
05308:  ADD     W4,#1,W4
0530A:  MOV     W4,W5
0530C:  MOV     W5,W4
0530E:  MUL.UU  W4,#8,W0
05310:  MOV     W0,W5
05312:  MOV     #ABA,W4
05314:  ADD     W5,W4,W6
05316:  MOV     1B56,W4
05318:  MUL.UU  W4,#2,W0
0531A:  MOV     #AA6,W4
0531C:  ADD     W0,W4,W0
0531E:  MOV     [W0],W7
05320:  MOV     W7,W4
05322:  MUL.UU  W4,#10,W0
05324:  MOV     W0,W7
05326:  MOV     1B14,W4
05328:  MUL.UU  W4,#4,W0
0532A:  ADD     W0,W7,W0
0532C:  MOV     #B5A,W4
0532E:  ADD     W0,W4,W0
05330:  MOV     [W0++],[W6++]
05332:  MOV     [W0++],[W6++]
05334:  MOV     AA2,W4
05336:  ADD     W4,#1,W4
05338:  MOV     W4,W5
0533A:  MOV     W5,W4
0533C:  MUL.UU  W4,#8,W0
0533E:  MOV     W0,W5
05340:  ADD     W5,#4,W5
05342:  MOV     W5,W0
05344:  MOV     #ABA,W4
05346:  ADD     W0,W4,W5
05348:  MOV     1B56,W4
0534A:  MUL.UU  W4,#2,W0
0534C:  MOV     #AA6,W4
0534E:  ADD     W0,W4,W0
05350:  MOV     [W0],W6
05352:  MOV     W6,W4
05354:  MUL.UU  W4,#10,W6
05356:  MOV     1B16,W4
05358:  MUL.UU  W4,#4,W0
0535A:  ADD     W0,W6,W0
0535C:  MOV     #B5A,W4
0535E:  ADD     W0,W4,W0
05360:  MOV     [W0++],[W5++]
05362:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
05364:  MOV     #2,W4
05366:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
05368:  MOV     #1,W4
0536A:  MOV     W4,A98
.................... 		            } 
0536C:  GOTO    53D4
.................... 		            else if (posEnd == 7 || posEnd == 0) 
05370:  MOV     1B5A,W4
05372:  CP      W4,#7
05374:  BRA     Z,537A
05376:  CP0     1B5A
05378:  BRA     NZ,53D4
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0537A:  MOV     AA2,W4
0537C:  MUL.UU  W4,#8,W0
0537E:  MOV     W0,W5
05380:  MOV     #ABA,W4
05382:  ADD     W5,W4,W6
05384:  MOV     1B56,W4
05386:  MUL.UU  W4,#2,W0
05388:  MOV     #AA6,W4
0538A:  ADD     W0,W4,W0
0538C:  MOV     [W0],W7
0538E:  MOV     W7,W4
05390:  MUL.UU  W4,#10,W0
05392:  MOV     W0,W7
05394:  MOV     1B10,W4
05396:  MUL.UU  W4,#4,W0
05398:  ADD     W0,W7,W0
0539A:  MOV     #B5A,W4
0539C:  ADD     W0,W4,W0
0539E:  MOV     [W0++],[W6++]
053A0:  MOV     [W0++],[W6++]
053A2:  MOV     AA2,W4
053A4:  MUL.UU  W4,#8,W0
053A6:  MOV     W0,W5
053A8:  ADD     W5,#4,W5
053AA:  MOV     W5,W0
053AC:  MOV     #ABA,W4
053AE:  ADD     W0,W4,W5
053B0:  MOV     1B56,W4
053B2:  MUL.UU  W4,#2,W0
053B4:  MOV     #AA6,W4
053B6:  ADD     W0,W4,W0
053B8:  MOV     [W0],W6
053BA:  MOV     W6,W4
053BC:  MUL.UU  W4,#10,W6
053BE:  MOV     1B12,W4
053C0:  MUL.UU  W4,#4,W0
053C2:  ADD     W0,W6,W0
053C4:  MOV     #B5A,W4
053C6:  ADD     W0,W4,W0
053C8:  MOV     [W0++],[W5++]
053CA:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
053CC:  MOV     #1,W4
053CE:  MOV     W4,AA0
.................... 		                path_found = true; 
053D0:  MOV     #1,W4
053D2:  MOV     W4,A98
.................... 		            } 
.................... 				} 
.................... 	            break; 
053D4:  GOTO    6324
....................  
.................... 	        case 6: 
....................  
.................... 	        	if(path_opposite) 
053D8:  CP0     A9C
053DA:  BRA     Z,5716
.................... 	        	{ 
....................         			 
.................... 	                if (posEnd == 3) 
053DC:  MOV     1B5A,W4
053DE:  CP      W4,#3
053E0:  BRA     NZ,5496
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
053E2:  MOV     AA2,W4
053E4:  MUL.UU  W4,#8,W0
053E6:  MOV     W0,W5
053E8:  MOV     #ABA,W4
053EA:  ADD     W5,W4,W6
053EC:  MOV     1B56,W4
053EE:  MUL.UU  W4,#2,W0
053F0:  MOV     #AA6,W4
053F2:  ADD     W0,W4,W0
053F4:  MOV     [W0],W7
053F6:  MOV     W7,W4
053F8:  MUL.UU  W4,#10,W0
053FA:  MOV     W0,W7
053FC:  MOV     #B5A,W4
053FE:  ADD     W7,W4,W0
05400:  MOV     [W0++],[W6++]
05402:  MOV     [W0++],[W6++]
05404:  MOV     AA2,W4
05406:  MUL.UU  W4,#8,W0
05408:  MOV     W0,W5
0540A:  ADD     W5,#4,W5
0540C:  MOV     W5,W0
0540E:  MOV     #ABA,W4
05410:  ADD     W0,W4,W5
05412:  MOV     1B56,W4
05414:  MUL.UU  W4,#2,W0
05416:  MOV     #AA6,W4
05418:  ADD     W0,W4,W0
0541A:  MOV     [W0],W6
0541C:  MOV     W6,W4
0541E:  MUL.UU  W4,#10,W6
05420:  ADD     W6,#4,W6
05422:  MOV     W6,W0
05424:  MOV     #B5A,W4
05426:  ADD     W0,W4,W0
05428:  MOV     [W0++],[W5++]
0542A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0542C:  MOV     AA2,W4
0542E:  ADD     W4,#1,W4
05430:  MOV     W4,W5
05432:  MOV     W5,W4
05434:  MUL.UU  W4,#8,W0
05436:  MOV     W0,W5
05438:  MOV     #ABA,W4
0543A:  ADD     W5,W4,W6
0543C:  MOV     1B56,W4
0543E:  MUL.UU  W4,#2,W0
05440:  MOV     #AA6,W4
05442:  ADD     W0,W4,W0
05444:  MOV     [W0],W7
05446:  MOV     W7,W4
05448:  MUL.UU  W4,#10,W0
0544A:  MOV     W0,W7
0544C:  MOV     1B14,W4
0544E:  MUL.UU  W4,#4,W0
05450:  ADD     W0,W7,W0
05452:  MOV     #B5A,W4
05454:  ADD     W0,W4,W0
05456:  MOV     [W0++],[W6++]
05458:  MOV     [W0++],[W6++]
0545A:  MOV     AA2,W4
0545C:  ADD     W4,#1,W4
0545E:  MOV     W4,W5
05460:  MOV     W5,W4
05462:  MUL.UU  W4,#8,W0
05464:  MOV     W0,W5
05466:  ADD     W5,#4,W5
05468:  MOV     W5,W0
0546A:  MOV     #ABA,W4
0546C:  ADD     W0,W4,W5
0546E:  MOV     1B56,W4
05470:  MUL.UU  W4,#2,W0
05472:  MOV     #AA6,W4
05474:  ADD     W0,W4,W0
05476:  MOV     [W0],W6
05478:  MOV     W6,W4
0547A:  MUL.UU  W4,#10,W6
0547C:  MOV     1B16,W4
0547E:  MUL.UU  W4,#4,W0
05480:  ADD     W0,W6,W0
05482:  MOV     #B5A,W4
05484:  ADD     W0,W4,W0
05486:  MOV     [W0++],[W5++]
05488:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0548A:  MOV     #2,W4
0548C:  MOV     W4,AA0
.................... 		                path_found = true; 
0548E:  MOV     #1,W4
05490:  MOV     W4,A98
.................... 		            } 
05492:  GOTO    5712
.................... 		            else if (posEnd == 2) 
05496:  MOV     1B5A,W4
05498:  CP      W4,#2
0549A:  BRA     NZ,5658
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
0549C:  MOV     1B56,W4
0549E:  MUL.UU  W4,#2,W0
054A0:  MOV     #AA6,W4
054A2:  ADD     W0,W4,W0
054A4:  MOV     [W0],W5
054A6:  MOV     W5,W4
054A8:  MUL.UU  W4,#10,W0
054AA:  MOV     W0,W5
054AC:  MOV     #B5A,W4
054AE:  ADD     W5,W4,W0
054B0:  MOV     [W0],W6
054B2:  MOV     1B56,W4
054B4:  MUL.UU  W4,#2,W0
054B6:  MOV     #AA6,W4
054B8:  ADD     W0,W4,W0
054BA:  MOV     [W0],W7
054BC:  MOV     W7,W4
054BE:  MUL.UU  W4,#10,W0
054C0:  MOV     W0,W7
054C2:  ADD     W7,#4,W7
054C4:  MOV     W7,W0
054C6:  MOV     #B5A,W4
054C8:  ADD     W0,W4,W0
054CA:  MOV     [W0],W7
054CC:  PUSH    1B4E
054CE:  POP     1B72
054D0:  PUSH    1B50
054D2:  POP     1B74
054D4:  MOV     W6,1B76
054D6:  MOV     W7,1B78
054D8:  CALL    23E2
054DC:  MOV     W0,W6
054DE:  MOV     1B56,W4
054E0:  MUL.UU  W4,#2,W0
054E2:  MOV     #AA6,W4
054E4:  ADD     W0,W4,W0
054E6:  MOV     [W0],W7
054E8:  MOV     W7,W4
054EA:  MUL.UU  W4,#10,W0
054EC:  MOV     W0,W7
054EE:  MOV     #B5A,W4
054F0:  ADD     W7,W4,W0
054F2:  MOV     [W0],W8
054F4:  MOV     1B56,W4
054F6:  MUL.UU  W4,#2,W0
054F8:  MOV     #AA6,W4
054FA:  ADD     W0,W4,W0
054FC:  MOV     [W0],W9
054FE:  MOV     W9,W4
05500:  MUL.UU  W4,#10,W0
05502:  MOV     W0,W9
05504:  ADD     W9,#4,W9
05506:  MOV     W9,W0
05508:  MOV     #B5A,W4
0550A:  ADD     W0,W4,W0
0550C:  MOV     [W0],W9
0550E:  MOV     W8,1B72
05510:  MOV     W9,1B74
05512:  PUSH    1B52
05514:  POP     1B76
05516:  PUSH    1B54
05518:  POP     1B78
0551A:  CALL    23E2
0551E:  ADD     W0,W6,W6
05520:  MOV     1B56,W4
05522:  MUL.UU  W4,#2,W0
05524:  MOV     #AA6,W4
05526:  ADD     W0,W4,W0
05528:  MOV     [W0],W8
0552A:  MOV     W8,W4
0552C:  MUL.UU  W4,#10,W8
0552E:  ADD     W8,#8,W8
05530:  MOV     W8,W0
05532:  MOV     #B5A,W4
05534:  ADD     W0,W4,W0
05536:  MOV     [W0],W8
05538:  MOV     1B56,W4
0553A:  MUL.UU  W4,#2,W0
0553C:  MOV     #AA6,W4
0553E:  ADD     W0,W4,W0
05540:  MOV     [W0],W9
05542:  MOV     W9,W4
05544:  MUL.UU  W4,#10,W0
05546:  MOV     W0,W9
05548:  ADD     W9,#C,W9
0554A:  MOV     W9,W0
0554C:  MOV     #B5A,W4
0554E:  ADD     W0,W4,W0
05550:  MOV     [W0],W9
05552:  PUSH    1B4E
05554:  POP     1B72
05556:  PUSH    1B50
05558:  POP     1B74
0555A:  MOV     W8,1B76
0555C:  MOV     W9,1B78
0555E:  CALL    23E2
05562:  MOV     W0,W8
05564:  MOV     1B56,W4
05566:  MUL.UU  W4,#2,W0
05568:  MOV     #AA6,W4
0556A:  ADD     W0,W4,W0
0556C:  MOV     [W0],W9
0556E:  MOV     W9,W4
05570:  MUL.UU  W4,#10,W0
05572:  MOV     W0,W9
05574:  ADD     W9,#8,W9
05576:  MOV     W9,W0
05578:  MOV     #B5A,W4
0557A:  ADD     W0,W4,W0
0557C:  MOV     [W0],W9
0557E:  MOV     1B56,W4
05580:  MUL.UU  W4,#2,W0
05582:  MOV     #AA6,W4
05584:  ADD     W0,W4,W0
05586:  MOV     [W0],W10
05588:  MOV     W10,W4
0558A:  MUL.UU  W4,#10,W10
0558C:  ADD     W10,#C,W10
0558E:  MOV     W10,W0
05590:  MOV     #B5A,W4
05592:  ADD     W0,W4,W0
05594:  MOV     [W0],W10
05596:  MOV     W9,1B72
05598:  MOV     W10,1B74
0559A:  PUSH    1B52
0559C:  POP     1B76
0559E:  PUSH    1B54
055A0:  POP     1B78
055A2:  CALL    23E2
055A6:  ADD     W0,W8,W0
055A8:  CP      W6,W0
055AA:  BRA     GE,5602
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
055AC:  MOV     AA2,W4
055AE:  MUL.UU  W4,#8,W0
055B0:  MOV     W0,W5
055B2:  MOV     #ABA,W4
055B4:  ADD     W5,W4,W6
055B6:  MOV     1B56,W4
055B8:  MUL.UU  W4,#2,W0
055BA:  MOV     #AA6,W4
055BC:  ADD     W0,W4,W0
055BE:  MOV     [W0],W7
055C0:  MOV     W7,W4
055C2:  MUL.UU  W4,#10,W0
055C4:  MOV     W0,W7
055C6:  ADD     W7,#8,W7
055C8:  MOV     W7,W0
055CA:  MOV     #B5A,W4
055CC:  ADD     W0,W4,W0
055CE:  MOV     [W0++],[W6++]
055D0:  MOV     [W0++],[W6++]
055D2:  MOV     AA2,W4
055D4:  MUL.UU  W4,#8,W0
055D6:  MOV     W0,W5
055D8:  ADD     W5,#4,W5
055DA:  MOV     W5,W0
055DC:  MOV     #ABA,W4
055DE:  ADD     W0,W4,W5
055E0:  MOV     1B56,W4
055E2:  MUL.UU  W4,#2,W0
055E4:  MOV     #AA6,W4
055E6:  ADD     W0,W4,W0
055E8:  MOV     [W0],W6
055EA:  MOV     W6,W4
055EC:  MUL.UU  W4,#10,W6
055EE:  ADD     W6,#C,W6
055F0:  MOV     W6,W0
055F2:  MOV     #B5A,W4
055F4:  ADD     W0,W4,W0
055F6:  MOV     [W0++],[W5++]
055F8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
055FA:  MOV     #1,W4
055FC:  MOV     W4,AA0
.................... 		                } 
055FE:  GOTO    5650
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05602:  MOV     AA2,W4
05604:  MUL.UU  W4,#8,W0
05606:  MOV     W0,W5
05608:  MOV     #ABA,W4
0560A:  ADD     W5,W4,W6
0560C:  MOV     1B56,W4
0560E:  MUL.UU  W4,#2,W0
05610:  MOV     #AA6,W4
05612:  ADD     W0,W4,W0
05614:  MOV     [W0],W7
05616:  MOV     W7,W4
05618:  MUL.UU  W4,#10,W0
0561A:  MOV     W0,W7
0561C:  MOV     #B5A,W4
0561E:  ADD     W7,W4,W0
05620:  MOV     [W0++],[W6++]
05622:  MOV     [W0++],[W6++]
05624:  MOV     AA2,W4
05626:  MUL.UU  W4,#8,W0
05628:  MOV     W0,W5
0562A:  ADD     W5,#4,W5
0562C:  MOV     W5,W0
0562E:  MOV     #ABA,W4
05630:  ADD     W0,W4,W5
05632:  MOV     1B56,W4
05634:  MUL.UU  W4,#2,W0
05636:  MOV     #AA6,W4
05638:  ADD     W0,W4,W0
0563A:  MOV     [W0],W6
0563C:  MOV     W6,W4
0563E:  MUL.UU  W4,#10,W6
05640:  ADD     W6,#4,W6
05642:  MOV     W6,W0
05644:  MOV     #B5A,W4
05646:  ADD     W0,W4,W0
05648:  MOV     [W0++],[W5++]
0564A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0564C:  MOV     #1,W4
0564E:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
05650:  MOV     #1,W4
05652:  MOV     W4,A98
.................... 		            } 
05654:  GOTO    5712
.................... 		            else if (posEnd == 1) 
05658:  MOV     1B5A,W4
0565A:  CP      W4,#1
0565C:  BRA     NZ,5712
.................... 		            { 
.................... 						PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0565E:  MOV     AA2,W4
05660:  MUL.UU  W4,#8,W0
05662:  MOV     W0,W5
05664:  MOV     #ABA,W4
05666:  ADD     W5,W4,W6
05668:  MOV     1B56,W4
0566A:  MUL.UU  W4,#2,W0
0566C:  MOV     #AA6,W4
0566E:  ADD     W0,W4,W0
05670:  MOV     [W0],W7
05672:  MOV     W7,W4
05674:  MUL.UU  W4,#10,W0
05676:  MOV     W0,W7
05678:  ADD     W7,#8,W7
0567A:  MOV     W7,W0
0567C:  MOV     #B5A,W4
0567E:  ADD     W0,W4,W0
05680:  MOV     [W0++],[W6++]
05682:  MOV     [W0++],[W6++]
05684:  MOV     AA2,W4
05686:  MUL.UU  W4,#8,W0
05688:  MOV     W0,W5
0568A:  ADD     W5,#4,W5
0568C:  MOV     W5,W0
0568E:  MOV     #ABA,W4
05690:  ADD     W0,W4,W5
05692:  MOV     1B56,W4
05694:  MUL.UU  W4,#2,W0
05696:  MOV     #AA6,W4
05698:  ADD     W0,W4,W0
0569A:  MOV     [W0],W6
0569C:  MOV     W6,W4
0569E:  MUL.UU  W4,#10,W6
056A0:  ADD     W6,#C,W6
056A2:  MOV     W6,W0
056A4:  MOV     #B5A,W4
056A6:  ADD     W0,W4,W0
056A8:  MOV     [W0++],[W5++]
056AA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
056AC:  MOV     AA2,W4
056AE:  ADD     W4,#1,W4
056B0:  MOV     W4,W5
056B2:  MOV     W5,W4
056B4:  MUL.UU  W4,#8,W0
056B6:  MOV     W0,W5
056B8:  MOV     #ABA,W4
056BA:  ADD     W5,W4,W6
056BC:  MOV     1B56,W4
056BE:  MUL.UU  W4,#2,W0
056C0:  MOV     #AA6,W4
056C2:  ADD     W0,W4,W0
056C4:  MOV     [W0],W7
056C6:  MOV     W7,W4
056C8:  MUL.UU  W4,#10,W0
056CA:  MOV     W0,W7
056CC:  MOV     1B14,W4
056CE:  MUL.UU  W4,#4,W0
056D0:  ADD     W0,W7,W0
056D2:  MOV     #B5A,W4
056D4:  ADD     W0,W4,W0
056D6:  MOV     [W0++],[W6++]
056D8:  MOV     [W0++],[W6++]
056DA:  MOV     AA2,W4
056DC:  ADD     W4,#1,W4
056DE:  MOV     W4,W5
056E0:  MOV     W5,W4
056E2:  MUL.UU  W4,#8,W0
056E4:  MOV     W0,W5
056E6:  ADD     W5,#4,W5
056E8:  MOV     W5,W0
056EA:  MOV     #ABA,W4
056EC:  ADD     W0,W4,W5
056EE:  MOV     1B56,W4
056F0:  MUL.UU  W4,#2,W0
056F2:  MOV     #AA6,W4
056F4:  ADD     W0,W4,W0
056F6:  MOV     [W0],W6
056F8:  MOV     W6,W4
056FA:  MUL.UU  W4,#10,W6
056FC:  MOV     1B16,W4
056FE:  MUL.UU  W4,#4,W0
05700:  ADD     W0,W6,W0
05702:  MOV     #B5A,W4
05704:  ADD     W0,W4,W0
05706:  MOV     [W0++],[W5++]
05708:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0570A:  MOV     #2,W4
0570C:  MOV     W4,AA0
.................... 		                path_found = true; 
0570E:  MOV     #1,W4
05710:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
05712:  GOTO    5990
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 3) 
05716:  MOV     1B5A,W4
05718:  CP      W4,#3
0571A:  BRA     NZ,5776
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0571C:  MOV     AA2,W4
0571E:  MUL.UU  W4,#8,W0
05720:  MOV     W0,W5
05722:  MOV     #ABA,W4
05724:  ADD     W5,W4,W6
05726:  MOV     1B56,W4
05728:  MUL.UU  W4,#2,W0
0572A:  MOV     #AA6,W4
0572C:  ADD     W0,W4,W0
0572E:  MOV     [W0],W7
05730:  MOV     W7,W4
05732:  MUL.UU  W4,#10,W0
05734:  MOV     W0,W7
05736:  ADD     W7,#8,W7
05738:  MOV     W7,W0
0573A:  MOV     #B5A,W4
0573C:  ADD     W0,W4,W0
0573E:  MOV     [W0++],[W6++]
05740:  MOV     [W0++],[W6++]
05742:  MOV     AA2,W4
05744:  MUL.UU  W4,#8,W0
05746:  MOV     W0,W5
05748:  ADD     W5,#4,W5
0574A:  MOV     W5,W0
0574C:  MOV     #ABA,W4
0574E:  ADD     W0,W4,W5
05750:  MOV     1B56,W4
05752:  MUL.UU  W4,#2,W0
05754:  MOV     #AA6,W4
05756:  ADD     W0,W4,W0
05758:  MOV     [W0],W6
0575A:  MOV     W6,W4
0575C:  MUL.UU  W4,#10,W6
0575E:  ADD     W6,#C,W6
05760:  MOV     W6,W0
05762:  MOV     #B5A,W4
05764:  ADD     W0,W4,W0
05766:  MOV     [W0++],[W5++]
05768:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0576A:  MOV     #1,W4
0576C:  MOV     W4,AA0
.................... 		                path_found = true; 
0576E:  MOV     #1,W4
05770:  MOV     W4,A98
.................... 		            } 
05772:  GOTO    5990
.................... 		            else if (posEnd == 2) 
05776:  MOV     1B5A,W4
05778:  CP      W4,#2
0577A:  BRA     NZ,5938
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
0577C:  MOV     1B56,W4
0577E:  MUL.UU  W4,#2,W0
05780:  MOV     #AA6,W4
05782:  ADD     W0,W4,W0
05784:  MOV     [W0],W5
05786:  MOV     W5,W4
05788:  MUL.UU  W4,#10,W0
0578A:  MOV     W0,W5
0578C:  MOV     #B5A,W4
0578E:  ADD     W5,W4,W0
05790:  MOV     [W0],W6
05792:  MOV     1B56,W4
05794:  MUL.UU  W4,#2,W0
05796:  MOV     #AA6,W4
05798:  ADD     W0,W4,W0
0579A:  MOV     [W0],W7
0579C:  MOV     W7,W4
0579E:  MUL.UU  W4,#10,W0
057A0:  MOV     W0,W7
057A2:  ADD     W7,#4,W7
057A4:  MOV     W7,W0
057A6:  MOV     #B5A,W4
057A8:  ADD     W0,W4,W0
057AA:  MOV     [W0],W7
057AC:  PUSH    1B4E
057AE:  POP     1B72
057B0:  PUSH    1B50
057B2:  POP     1B74
057B4:  MOV     W6,1B76
057B6:  MOV     W7,1B78
057B8:  CALL    23E2
057BC:  MOV     W0,W6
057BE:  MOV     1B56,W4
057C0:  MUL.UU  W4,#2,W0
057C2:  MOV     #AA6,W4
057C4:  ADD     W0,W4,W0
057C6:  MOV     [W0],W7
057C8:  MOV     W7,W4
057CA:  MUL.UU  W4,#10,W0
057CC:  MOV     W0,W7
057CE:  MOV     #B5A,W4
057D0:  ADD     W7,W4,W0
057D2:  MOV     [W0],W8
057D4:  MOV     1B56,W4
057D6:  MUL.UU  W4,#2,W0
057D8:  MOV     #AA6,W4
057DA:  ADD     W0,W4,W0
057DC:  MOV     [W0],W9
057DE:  MOV     W9,W4
057E0:  MUL.UU  W4,#10,W0
057E2:  MOV     W0,W9
057E4:  ADD     W9,#4,W9
057E6:  MOV     W9,W0
057E8:  MOV     #B5A,W4
057EA:  ADD     W0,W4,W0
057EC:  MOV     [W0],W9
057EE:  MOV     W8,1B72
057F0:  MOV     W9,1B74
057F2:  PUSH    1B52
057F4:  POP     1B76
057F6:  PUSH    1B54
057F8:  POP     1B78
057FA:  CALL    23E2
057FE:  ADD     W0,W6,W6
05800:  MOV     1B56,W4
05802:  MUL.UU  W4,#2,W0
05804:  MOV     #AA6,W4
05806:  ADD     W0,W4,W0
05808:  MOV     [W0],W8
0580A:  MOV     W8,W4
0580C:  MUL.UU  W4,#10,W8
0580E:  ADD     W8,#8,W8
05810:  MOV     W8,W0
05812:  MOV     #B5A,W4
05814:  ADD     W0,W4,W0
05816:  MOV     [W0],W8
05818:  MOV     1B56,W4
0581A:  MUL.UU  W4,#2,W0
0581C:  MOV     #AA6,W4
0581E:  ADD     W0,W4,W0
05820:  MOV     [W0],W9
05822:  MOV     W9,W4
05824:  MUL.UU  W4,#10,W0
05826:  MOV     W0,W9
05828:  ADD     W9,#C,W9
0582A:  MOV     W9,W0
0582C:  MOV     #B5A,W4
0582E:  ADD     W0,W4,W0
05830:  MOV     [W0],W9
05832:  PUSH    1B4E
05834:  POP     1B72
05836:  PUSH    1B50
05838:  POP     1B74
0583A:  MOV     W8,1B76
0583C:  MOV     W9,1B78
0583E:  CALL    23E2
05842:  MOV     W0,W8
05844:  MOV     1B56,W4
05846:  MUL.UU  W4,#2,W0
05848:  MOV     #AA6,W4
0584A:  ADD     W0,W4,W0
0584C:  MOV     [W0],W9
0584E:  MOV     W9,W4
05850:  MUL.UU  W4,#10,W0
05852:  MOV     W0,W9
05854:  ADD     W9,#8,W9
05856:  MOV     W9,W0
05858:  MOV     #B5A,W4
0585A:  ADD     W0,W4,W0
0585C:  MOV     [W0],W9
0585E:  MOV     1B56,W4
05860:  MUL.UU  W4,#2,W0
05862:  MOV     #AA6,W4
05864:  ADD     W0,W4,W0
05866:  MOV     [W0],W10
05868:  MOV     W10,W4
0586A:  MUL.UU  W4,#10,W10
0586C:  ADD     W10,#C,W10
0586E:  MOV     W10,W0
05870:  MOV     #B5A,W4
05872:  ADD     W0,W4,W0
05874:  MOV     [W0],W10
05876:  MOV     W9,1B72
05878:  MOV     W10,1B74
0587A:  PUSH    1B52
0587C:  POP     1B76
0587E:  PUSH    1B54
05880:  POP     1B78
05882:  CALL    23E2
05886:  ADD     W0,W8,W0
05888:  CP      W6,W0
0588A:  BRA     GE,58DE
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0588C:  MOV     AA2,W4
0588E:  MUL.UU  W4,#8,W0
05890:  MOV     W0,W5
05892:  MOV     #ABA,W4
05894:  ADD     W5,W4,W6
05896:  MOV     1B56,W4
05898:  MUL.UU  W4,#2,W0
0589A:  MOV     #AA6,W4
0589C:  ADD     W0,W4,W0
0589E:  MOV     [W0],W7
058A0:  MOV     W7,W4
058A2:  MUL.UU  W4,#10,W0
058A4:  MOV     W0,W7
058A6:  MOV     #B5A,W4
058A8:  ADD     W7,W4,W0
058AA:  MOV     [W0++],[W6++]
058AC:  MOV     [W0++],[W6++]
058AE:  MOV     AA2,W4
058B0:  MUL.UU  W4,#8,W0
058B2:  MOV     W0,W5
058B4:  ADD     W5,#4,W5
058B6:  MOV     W5,W0
058B8:  MOV     #ABA,W4
058BA:  ADD     W0,W4,W5
058BC:  MOV     1B56,W4
058BE:  MUL.UU  W4,#2,W0
058C0:  MOV     #AA6,W4
058C2:  ADD     W0,W4,W0
058C4:  MOV     [W0],W6
058C6:  MOV     W6,W4
058C8:  MUL.UU  W4,#10,W6
058CA:  ADD     W6,#4,W6
058CC:  MOV     W6,W0
058CE:  MOV     #B5A,W4
058D0:  ADD     W0,W4,W0
058D2:  MOV     [W0++],[W5++]
058D4:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
058D6:  MOV     #1,W4
058D8:  MOV     W4,AA0
.................... 		                } 
058DA:  GOTO    5930
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
058DE:  MOV     AA2,W4
058E0:  MUL.UU  W4,#8,W0
058E2:  MOV     W0,W5
058E4:  MOV     #ABA,W4
058E6:  ADD     W5,W4,W6
058E8:  MOV     1B56,W4
058EA:  MUL.UU  W4,#2,W0
058EC:  MOV     #AA6,W4
058EE:  ADD     W0,W4,W0
058F0:  MOV     [W0],W7
058F2:  MOV     W7,W4
058F4:  MUL.UU  W4,#10,W0
058F6:  MOV     W0,W7
058F8:  ADD     W7,#8,W7
058FA:  MOV     W7,W0
058FC:  MOV     #B5A,W4
058FE:  ADD     W0,W4,W0
05900:  MOV     [W0++],[W6++]
05902:  MOV     [W0++],[W6++]
05904:  MOV     AA2,W4
05906:  MUL.UU  W4,#8,W0
05908:  MOV     W0,W5
0590A:  ADD     W5,#4,W5
0590C:  MOV     W5,W0
0590E:  MOV     #ABA,W4
05910:  ADD     W0,W4,W5
05912:  MOV     1B56,W4
05914:  MUL.UU  W4,#2,W0
05916:  MOV     #AA6,W4
05918:  ADD     W0,W4,W0
0591A:  MOV     [W0],W6
0591C:  MOV     W6,W4
0591E:  MUL.UU  W4,#10,W6
05920:  ADD     W6,#C,W6
05922:  MOV     W6,W0
05924:  MOV     #B5A,W4
05926:  ADD     W0,W4,W0
05928:  MOV     [W0++],[W5++]
0592A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0592C:  MOV     #1,W4
0592E:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
05930:  MOV     #1,W4
05932:  MOV     W4,A98
.................... 		            } 
05934:  GOTO    5990
.................... 		            else if (posEnd == 1) 
05938:  MOV     1B5A,W4
0593A:  CP      W4,#1
0593C:  BRA     NZ,5990
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0593E:  MOV     AA2,W4
05940:  MUL.UU  W4,#8,W0
05942:  MOV     W0,W5
05944:  MOV     #ABA,W4
05946:  ADD     W5,W4,W6
05948:  MOV     1B56,W4
0594A:  MUL.UU  W4,#2,W0
0594C:  MOV     #AA6,W4
0594E:  ADD     W0,W4,W0
05950:  MOV     [W0],W7
05952:  MOV     W7,W4
05954:  MUL.UU  W4,#10,W0
05956:  MOV     W0,W7
05958:  MOV     #B5A,W4
0595A:  ADD     W7,W4,W0
0595C:  MOV     [W0++],[W6++]
0595E:  MOV     [W0++],[W6++]
05960:  MOV     AA2,W4
05962:  MUL.UU  W4,#8,W0
05964:  MOV     W0,W5
05966:  ADD     W5,#4,W5
05968:  MOV     W5,W0
0596A:  MOV     #ABA,W4
0596C:  ADD     W0,W4,W5
0596E:  MOV     1B56,W4
05970:  MUL.UU  W4,#2,W0
05972:  MOV     #AA6,W4
05974:  ADD     W0,W4,W0
05976:  MOV     [W0],W6
05978:  MOV     W6,W4
0597A:  MUL.UU  W4,#10,W6
0597C:  ADD     W6,#4,W6
0597E:  MOV     W6,W0
05980:  MOV     #B5A,W4
05982:  ADD     W0,W4,W0
05984:  MOV     [W0++],[W5++]
05986:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
05988:  MOV     #1,W4
0598A:  MOV     W4,AA0
.................... 		                path_found = true; 
0598C:  MOV     #1,W4
0598E:  MOV     W4,A98
.................... 		            } 
.................... 	            } 
.................... 	            break; 
05990:  GOTO    6324
....................  
.................... 	        case 7: 
....................  
.................... 	        	if(path_opposite) 
05994:  CP0     A9C
05996:  BRA     Z,5FC4
.................... 	        	{ 
.................... 	        		if (posEnd == 5) 
05998:  MOV     1B5A,W4
0599A:  CP      W4,#5
0599C:  BRA     NZ,5AA8
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0599E:  MOV     AA2,W4
059A0:  MUL.UU  W4,#8,W0
059A2:  MOV     W0,W5
059A4:  MOV     #ABA,W4
059A6:  ADD     W5,W4,W6
059A8:  MOV     1B56,W4
059AA:  MUL.UU  W4,#2,W0
059AC:  MOV     #AA6,W4
059AE:  ADD     W0,W4,W0
059B0:  MOV     [W0],W7
059B2:  MOV     W7,W4
059B4:  MUL.UU  W4,#10,W0
059B6:  MOV     W0,W7
059B8:  MOV     #B5A,W4
059BA:  ADD     W7,W4,W0
059BC:  MOV     [W0++],[W6++]
059BE:  MOV     [W0++],[W6++]
059C0:  MOV     AA2,W4
059C2:  MUL.UU  W4,#8,W0
059C4:  MOV     W0,W5
059C6:  ADD     W5,#4,W5
059C8:  MOV     W5,W0
059CA:  MOV     #ABA,W4
059CC:  ADD     W0,W4,W5
059CE:  MOV     1B56,W4
059D0:  MUL.UU  W4,#2,W0
059D2:  MOV     #AA6,W4
059D4:  ADD     W0,W4,W0
059D6:  MOV     [W0],W6
059D8:  MOV     W6,W4
059DA:  MUL.UU  W4,#10,W6
059DC:  ADD     W6,#4,W6
059DE:  MOV     W6,W0
059E0:  MOV     #B5A,W4
059E2:  ADD     W0,W4,W0
059E4:  MOV     [W0++],[W5++]
059E6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
059E8:  MOV     AA2,W4
059EA:  ADD     W4,#1,W4
059EC:  MOV     W4,W5
059EE:  MOV     W5,W4
059F0:  MUL.UU  W4,#8,W0
059F2:  MOV     W0,W5
059F4:  MOV     #ABA,W4
059F6:  ADD     W5,W4,W6
059F8:  MOV     1B56,W4
059FA:  MUL.UU  W4,#2,W0
059FC:  MOV     #AA6,W4
059FE:  ADD     W0,W4,W0
05A00:  MOV     [W0],W7
05A02:  MOV     W7,W4
05A04:  MUL.UU  W4,#10,W0
05A06:  MOV     W0,W7
05A08:  MOV     1B14,W4
05A0A:  MUL.UU  W4,#4,W0
05A0C:  ADD     W0,W7,W0
05A0E:  MOV     #B5A,W4
05A10:  ADD     W0,W4,W0
05A12:  MOV     [W0++],[W6++]
05A14:  MOV     [W0++],[W6++]
05A16:  MOV     AA2,W4
05A18:  ADD     W4,#1,W4
05A1A:  MOV     W4,W5
05A1C:  MOV     W5,W4
05A1E:  MUL.UU  W4,#8,W0
05A20:  MOV     W0,W5
05A22:  ADD     W5,#4,W5
05A24:  MOV     W5,W0
05A26:  MOV     #ABA,W4
05A28:  ADD     W0,W4,W5
05A2A:  MOV     1B56,W4
05A2C:  MUL.UU  W4,#2,W0
05A2E:  MOV     #AA6,W4
05A30:  ADD     W0,W4,W0
05A32:  MOV     [W0],W6
05A34:  MOV     W6,W4
05A36:  MUL.UU  W4,#10,W6
05A38:  MOV     1B16,W4
05A3A:  MUL.UU  W4,#4,W0
05A3C:  ADD     W0,W6,W0
05A3E:  MOV     #B5A,W4
05A40:  ADD     W0,W4,W0
05A42:  MOV     [W0++],[W5++]
05A44:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05A46:  MOV     AA2,W4
05A48:  ADD     W4,#2,W4
05A4A:  MOV     W4,W5
05A4C:  MOV     W5,W4
05A4E:  MUL.UU  W4,#8,W0
05A50:  MOV     W0,W5
05A52:  MOV     #ABA,W4
05A54:  ADD     W5,W4,W6
05A56:  MOV     1B56,W4
05A58:  MUL.UU  W4,#2,W0
05A5A:  MOV     #AA6,W4
05A5C:  ADD     W0,W4,W0
05A5E:  MOV     [W0],W7
05A60:  MOV     W7,W4
05A62:  MUL.UU  W4,#10,W0
05A64:  MOV     W0,W7
05A66:  ADD     W7,#8,W7
05A68:  MOV     W7,W0
05A6A:  MOV     #B5A,W4
05A6C:  ADD     W0,W4,W0
05A6E:  MOV     [W0++],[W6++]
05A70:  MOV     [W0++],[W6++]
05A72:  MOV     AA2,W4
05A74:  ADD     W4,#2,W4
05A76:  MOV     W4,W5
05A78:  MOV     W5,W4
05A7A:  MUL.UU  W4,#8,W0
05A7C:  MOV     W0,W5
05A7E:  ADD     W5,#4,W5
05A80:  MOV     W5,W0
05A82:  MOV     #ABA,W4
05A84:  ADD     W0,W4,W5
05A86:  MOV     1B56,W4
05A88:  MUL.UU  W4,#2,W0
05A8A:  MOV     #AA6,W4
05A8C:  ADD     W0,W4,W0
05A8E:  MOV     [W0],W6
05A90:  MOV     W6,W4
05A92:  MUL.UU  W4,#10,W6
05A94:  ADD     W6,#C,W6
05A96:  MOV     W6,W0
05A98:  MOV     #B5A,W4
05A9A:  ADD     W0,W4,W0
05A9C:  MOV     [W0++],[W5++]
05A9E:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
05AA0:  MOV     #3,W4
05AA2:  MOV     W4,AA0
.................... 		                path_found = true; 
05AA4:  MOV     #1,W4
05AA6:  MOV     W4,A98
.................... 		            } 
.................... 		            if (posEnd == 4) 
05AA8:  MOV     1B5A,W4
05AAA:  CP      W4,#4
05AAC:  BRA     NZ,5B62
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05AAE:  MOV     AA2,W4
05AB0:  MUL.UU  W4,#8,W0
05AB2:  MOV     W0,W5
05AB4:  MOV     #ABA,W4
05AB6:  ADD     W5,W4,W6
05AB8:  MOV     1B56,W4
05ABA:  MUL.UU  W4,#2,W0
05ABC:  MOV     #AA6,W4
05ABE:  ADD     W0,W4,W0
05AC0:  MOV     [W0],W7
05AC2:  MOV     W7,W4
05AC4:  MUL.UU  W4,#10,W0
05AC6:  MOV     W0,W7
05AC8:  MOV     #B5A,W4
05ACA:  ADD     W7,W4,W0
05ACC:  MOV     [W0++],[W6++]
05ACE:  MOV     [W0++],[W6++]
05AD0:  MOV     AA2,W4
05AD2:  MUL.UU  W4,#8,W0
05AD4:  MOV     W0,W5
05AD6:  ADD     W5,#4,W5
05AD8:  MOV     W5,W0
05ADA:  MOV     #ABA,W4
05ADC:  ADD     W0,W4,W5
05ADE:  MOV     1B56,W4
05AE0:  MUL.UU  W4,#2,W0
05AE2:  MOV     #AA6,W4
05AE4:  ADD     W0,W4,W0
05AE6:  MOV     [W0],W6
05AE8:  MOV     W6,W4
05AEA:  MUL.UU  W4,#10,W6
05AEC:  ADD     W6,#4,W6
05AEE:  MOV     W6,W0
05AF0:  MOV     #B5A,W4
05AF2:  ADD     W0,W4,W0
05AF4:  MOV     [W0++],[W5++]
05AF6:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05AF8:  MOV     AA2,W4
05AFA:  ADD     W4,#1,W4
05AFC:  MOV     W4,W5
05AFE:  MOV     W5,W4
05B00:  MUL.UU  W4,#8,W0
05B02:  MOV     W0,W5
05B04:  MOV     #ABA,W4
05B06:  ADD     W5,W4,W6
05B08:  MOV     1B56,W4
05B0A:  MUL.UU  W4,#2,W0
05B0C:  MOV     #AA6,W4
05B0E:  ADD     W0,W4,W0
05B10:  MOV     [W0],W7
05B12:  MOV     W7,W4
05B14:  MUL.UU  W4,#10,W0
05B16:  MOV     W0,W7
05B18:  MOV     1B14,W4
05B1A:  MUL.UU  W4,#4,W0
05B1C:  ADD     W0,W7,W0
05B1E:  MOV     #B5A,W4
05B20:  ADD     W0,W4,W0
05B22:  MOV     [W0++],[W6++]
05B24:  MOV     [W0++],[W6++]
05B26:  MOV     AA2,W4
05B28:  ADD     W4,#1,W4
05B2A:  MOV     W4,W5
05B2C:  MOV     W5,W4
05B2E:  MUL.UU  W4,#8,W0
05B30:  MOV     W0,W5
05B32:  ADD     W5,#4,W5
05B34:  MOV     W5,W0
05B36:  MOV     #ABA,W4
05B38:  ADD     W0,W4,W5
05B3A:  MOV     1B56,W4
05B3C:  MUL.UU  W4,#2,W0
05B3E:  MOV     #AA6,W4
05B40:  ADD     W0,W4,W0
05B42:  MOV     [W0],W6
05B44:  MOV     W6,W4
05B46:  MUL.UU  W4,#10,W6
05B48:  MOV     1B16,W4
05B4A:  MUL.UU  W4,#4,W0
05B4C:  ADD     W0,W6,W0
05B4E:  MOV     #B5A,W4
05B50:  ADD     W0,W4,W0
05B52:  MOV     [W0++],[W5++]
05B54:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
05B56:  MOV     #2,W4
05B58:  MOV     W4,AA0
.................... 		                path_found = true; 
05B5A:  MOV     #1,W4
05B5C:  MOV     W4,A98
.................... 		            } 
05B5E:  GOTO    5FC0
.................... 		            else if (posEnd == 3) 
05B62:  MOV     1B5A,W4
05B64:  CP      W4,#3
05B66:  BRA     NZ,5DEA
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
05B68:  MOV     1B56,W4
05B6A:  MUL.UU  W4,#2,W0
05B6C:  MOV     #AA6,W4
05B6E:  ADD     W0,W4,W0
05B70:  MOV     [W0],W5
05B72:  MOV     W5,W4
05B74:  MUL.UU  W4,#10,W0
05B76:  MOV     W0,W5
05B78:  MOV     #B5A,W4
05B7A:  ADD     W5,W4,W0
05B7C:  MOV     [W0],W6
05B7E:  MOV     1B56,W4
05B80:  MUL.UU  W4,#2,W0
05B82:  MOV     #AA6,W4
05B84:  ADD     W0,W4,W0
05B86:  MOV     [W0],W7
05B88:  MOV     W7,W4
05B8A:  MUL.UU  W4,#10,W0
05B8C:  MOV     W0,W7
05B8E:  ADD     W7,#4,W7
05B90:  MOV     W7,W0
05B92:  MOV     #B5A,W4
05B94:  ADD     W0,W4,W0
05B96:  MOV     [W0],W7
05B98:  PUSH    1B4E
05B9A:  POP     1B72
05B9C:  PUSH    1B50
05B9E:  POP     1B74
05BA0:  MOV     W6,1B76
05BA2:  MOV     W7,1B78
05BA4:  CALL    23E2
05BA8:  MOV     W0,W6
05BAA:  MOV     1B56,W4
05BAC:  MUL.UU  W4,#2,W0
05BAE:  MOV     #AA6,W4
05BB0:  ADD     W0,W4,W0
05BB2:  MOV     [W0],W7
05BB4:  MOV     W7,W4
05BB6:  MUL.UU  W4,#10,W0
05BB8:  MOV     W0,W7
05BBA:  MOV     1B14,W4
05BBC:  MUL.UU  W4,#4,W0
05BBE:  ADD     W0,W7,W0
05BC0:  MOV     #B5A,W4
05BC2:  ADD     W0,W4,W0
05BC4:  MOV     [W0],W7
05BC6:  MOV     1B56,W4
05BC8:  MUL.UU  W4,#2,W0
05BCA:  MOV     #AA6,W4
05BCC:  ADD     W0,W4,W0
05BCE:  MOV     [W0],W8
05BD0:  MOV     W8,W4
05BD2:  MUL.UU  W4,#10,W8
05BD4:  MOV     1B16,W4
05BD6:  MUL.UU  W4,#4,W0
05BD8:  ADD     W0,W8,W0
05BDA:  MOV     #B5A,W4
05BDC:  ADD     W0,W4,W0
05BDE:  MOV     [W0],W8
05BE0:  MOV     W7,1B72
05BE2:  MOV     W8,1B74
05BE4:  PUSH    1B52
05BE6:  POP     1B76
05BE8:  PUSH    1B54
05BEA:  POP     1B78
05BEC:  CALL    23E2
05BF0:  ADD     W0,W6,W6
05BF2:  MOV     1B56,W4
05BF4:  MUL.UU  W4,#2,W0
05BF6:  MOV     #AA6,W4
05BF8:  ADD     W0,W4,W0
05BFA:  MOV     [W0],W7
05BFC:  MOV     W7,W4
05BFE:  MUL.UU  W4,#10,W0
05C00:  MOV     W0,W7
05C02:  MOV     1B10,W4
05C04:  MUL.UU  W4,#4,W0
05C06:  ADD     W0,W7,W0
05C08:  MOV     #B5A,W4
05C0A:  ADD     W0,W4,W0
05C0C:  MOV     [W0],W7
05C0E:  MOV     1B56,W4
05C10:  MUL.UU  W4,#2,W0
05C12:  MOV     #AA6,W4
05C14:  ADD     W0,W4,W0
05C16:  MOV     [W0],W8
05C18:  MOV     W8,W4
05C1A:  MUL.UU  W4,#10,W8
05C1C:  MOV     1B12,W4
05C1E:  MUL.UU  W4,#4,W0
05C20:  ADD     W0,W8,W0
05C22:  MOV     #B5A,W4
05C24:  ADD     W0,W4,W0
05C26:  MOV     [W0],W8
05C28:  PUSH    1B4E
05C2A:  POP     1B72
05C2C:  PUSH    1B50
05C2E:  POP     1B74
05C30:  MOV     W7,1B76
05C32:  MOV     W8,1B78
05C34:  CALL    23E2
05C38:  MOV     W0,W7
05C3A:  MOV     1B56,W4
05C3C:  MUL.UU  W4,#2,W0
05C3E:  MOV     #AA6,W4
05C40:  ADD     W0,W4,W0
05C42:  MOV     [W0],W8
05C44:  MOV     W8,W4
05C46:  MUL.UU  W4,#10,W8
05C48:  ADD     W8,#8,W8
05C4A:  MOV     W8,W0
05C4C:  MOV     #B5A,W4
05C4E:  ADD     W0,W4,W0
05C50:  MOV     [W0],W8
05C52:  MOV     1B56,W4
05C54:  MUL.UU  W4,#2,W0
05C56:  MOV     #AA6,W4
05C58:  ADD     W0,W4,W0
05C5A:  MOV     [W0],W9
05C5C:  MOV     W9,W4
05C5E:  MUL.UU  W4,#10,W0
05C60:  MOV     W0,W9
05C62:  ADD     W9,#C,W9
05C64:  MOV     W9,W0
05C66:  MOV     #B5A,W4
05C68:  ADD     W0,W4,W0
05C6A:  MOV     [W0],W9
05C6C:  MOV     W8,1B72
05C6E:  MOV     W9,1B74
05C70:  PUSH    1B52
05C72:  POP     1B76
05C74:  PUSH    1B54
05C76:  POP     1B78
05C78:  CALL    23E2
05C7C:  ADD     W0,W7,W0
05C7E:  CP      W6,W0
05C80:  BRA     GE,5D36
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05C82:  MOV     AA2,W4
05C84:  MUL.UU  W4,#8,W0
05C86:  MOV     W0,W5
05C88:  MOV     #ABA,W4
05C8A:  ADD     W5,W4,W6
05C8C:  MOV     1B56,W4
05C8E:  MUL.UU  W4,#2,W0
05C90:  MOV     #AA6,W4
05C92:  ADD     W0,W4,W0
05C94:  MOV     [W0],W7
05C96:  MOV     W7,W4
05C98:  MUL.UU  W4,#10,W0
05C9A:  MOV     W0,W7
05C9C:  MOV     1B10,W4
05C9E:  MUL.UU  W4,#4,W0
05CA0:  ADD     W0,W7,W0
05CA2:  MOV     #B5A,W4
05CA4:  ADD     W0,W4,W0
05CA6:  MOV     [W0++],[W6++]
05CA8:  MOV     [W0++],[W6++]
05CAA:  MOV     AA2,W4
05CAC:  MUL.UU  W4,#8,W0
05CAE:  MOV     W0,W5
05CB0:  ADD     W5,#4,W5
05CB2:  MOV     W5,W0
05CB4:  MOV     #ABA,W4
05CB6:  ADD     W0,W4,W5
05CB8:  MOV     1B56,W4
05CBA:  MUL.UU  W4,#2,W0
05CBC:  MOV     #AA6,W4
05CBE:  ADD     W0,W4,W0
05CC0:  MOV     [W0],W6
05CC2:  MOV     W6,W4
05CC4:  MUL.UU  W4,#10,W6
05CC6:  MOV     1B12,W4
05CC8:  MUL.UU  W4,#4,W0
05CCA:  ADD     W0,W6,W0
05CCC:  MOV     #B5A,W4
05CCE:  ADD     W0,W4,W0
05CD0:  MOV     [W0++],[W5++]
05CD2:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05CD4:  MOV     AA2,W4
05CD6:  ADD     W4,#1,W4
05CD8:  MOV     W4,W5
05CDA:  MOV     W5,W4
05CDC:  MUL.UU  W4,#8,W0
05CDE:  MOV     W0,W5
05CE0:  MOV     #ABA,W4
05CE2:  ADD     W5,W4,W6
05CE4:  MOV     1B56,W4
05CE6:  MUL.UU  W4,#2,W0
05CE8:  MOV     #AA6,W4
05CEA:  ADD     W0,W4,W0
05CEC:  MOV     [W0],W7
05CEE:  MOV     W7,W4
05CF0:  MUL.UU  W4,#10,W0
05CF2:  MOV     W0,W7
05CF4:  ADD     W7,#8,W7
05CF6:  MOV     W7,W0
05CF8:  MOV     #B5A,W4
05CFA:  ADD     W0,W4,W0
05CFC:  MOV     [W0++],[W6++]
05CFE:  MOV     [W0++],[W6++]
05D00:  MOV     AA2,W4
05D02:  ADD     W4,#1,W4
05D04:  MOV     W4,W5
05D06:  MOV     W5,W4
05D08:  MUL.UU  W4,#8,W0
05D0A:  MOV     W0,W5
05D0C:  ADD     W5,#4,W5
05D0E:  MOV     W5,W0
05D10:  MOV     #ABA,W4
05D12:  ADD     W0,W4,W5
05D14:  MOV     1B56,W4
05D16:  MUL.UU  W4,#2,W0
05D18:  MOV     #AA6,W4
05D1A:  ADD     W0,W4,W0
05D1C:  MOV     [W0],W6
05D1E:  MOV     W6,W4
05D20:  MUL.UU  W4,#10,W6
05D22:  ADD     W6,#C,W6
05D24:  MOV     W6,W0
05D26:  MOV     #B5A,W4
05D28:  ADD     W0,W4,W0
05D2A:  MOV     [W0++],[W5++]
05D2C:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
05D2E:  MOV     #2,W4
05D30:  MOV     W4,AA0
.................... 		                } 
05D32:  GOTO    5DE2
.................... 		                else 
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05D36:  MOV     AA2,W4
05D38:  MUL.UU  W4,#8,W0
05D3A:  MOV     W0,W5
05D3C:  MOV     #ABA,W4
05D3E:  ADD     W5,W4,W6
05D40:  MOV     1B56,W4
05D42:  MUL.UU  W4,#2,W0
05D44:  MOV     #AA6,W4
05D46:  ADD     W0,W4,W0
05D48:  MOV     [W0],W7
05D4A:  MOV     W7,W4
05D4C:  MUL.UU  W4,#10,W0
05D4E:  MOV     W0,W7
05D50:  MOV     #B5A,W4
05D52:  ADD     W7,W4,W0
05D54:  MOV     [W0++],[W6++]
05D56:  MOV     [W0++],[W6++]
05D58:  MOV     AA2,W4
05D5A:  MUL.UU  W4,#8,W0
05D5C:  MOV     W0,W5
05D5E:  ADD     W5,#4,W5
05D60:  MOV     W5,W0
05D62:  MOV     #ABA,W4
05D64:  ADD     W0,W4,W5
05D66:  MOV     1B56,W4
05D68:  MUL.UU  W4,#2,W0
05D6A:  MOV     #AA6,W4
05D6C:  ADD     W0,W4,W0
05D6E:  MOV     [W0],W6
05D70:  MOV     W6,W4
05D72:  MUL.UU  W4,#10,W6
05D74:  ADD     W6,#4,W6
05D76:  MOV     W6,W0
05D78:  MOV     #B5A,W4
05D7A:  ADD     W0,W4,W0
05D7C:  MOV     [W0++],[W5++]
05D7E:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05D80:  MOV     AA2,W4
05D82:  ADD     W4,#1,W4
05D84:  MOV     W4,W5
05D86:  MOV     W5,W4
05D88:  MUL.UU  W4,#8,W0
05D8A:  MOV     W0,W5
05D8C:  MOV     #ABA,W4
05D8E:  ADD     W5,W4,W6
05D90:  MOV     1B56,W4
05D92:  MUL.UU  W4,#2,W0
05D94:  MOV     #AA6,W4
05D96:  ADD     W0,W4,W0
05D98:  MOV     [W0],W7
05D9A:  MOV     W7,W4
05D9C:  MUL.UU  W4,#10,W0
05D9E:  MOV     W0,W7
05DA0:  MOV     1B14,W4
05DA2:  MUL.UU  W4,#4,W0
05DA4:  ADD     W0,W7,W0
05DA6:  MOV     #B5A,W4
05DA8:  ADD     W0,W4,W0
05DAA:  MOV     [W0++],[W6++]
05DAC:  MOV     [W0++],[W6++]
05DAE:  MOV     AA2,W4
05DB0:  ADD     W4,#1,W4
05DB2:  MOV     W4,W5
05DB4:  MOV     W5,W4
05DB6:  MUL.UU  W4,#8,W0
05DB8:  MOV     W0,W5
05DBA:  ADD     W5,#4,W5
05DBC:  MOV     W5,W0
05DBE:  MOV     #ABA,W4
05DC0:  ADD     W0,W4,W5
05DC2:  MOV     1B56,W4
05DC4:  MUL.UU  W4,#2,W0
05DC6:  MOV     #AA6,W4
05DC8:  ADD     W0,W4,W0
05DCA:  MOV     [W0],W6
05DCC:  MOV     W6,W4
05DCE:  MUL.UU  W4,#10,W6
05DD0:  MOV     1B16,W4
05DD2:  MUL.UU  W4,#4,W0
05DD4:  ADD     W0,W6,W0
05DD6:  MOV     #B5A,W4
05DD8:  ADD     W0,W4,W0
05DDA:  MOV     [W0++],[W5++]
05DDC:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
05DDE:  MOV     #2,W4
05DE0:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
05DE2:  MOV     #1,W4
05DE4:  MOV     W4,A98
.................... 		            } 
05DE6:  GOTO    5FC0
.................... 		            else if (posEnd == 2) 
05DEA:  MOV     1B5A,W4
05DEC:  CP      W4,#2
05DEE:  BRA     NZ,5EA8
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05DF0:  MOV     AA2,W4
05DF2:  MUL.UU  W4,#8,W0
05DF4:  MOV     W0,W5
05DF6:  MOV     #ABA,W4
05DF8:  ADD     W5,W4,W6
05DFA:  MOV     1B56,W4
05DFC:  MUL.UU  W4,#2,W0
05DFE:  MOV     #AA6,W4
05E00:  ADD     W0,W4,W0
05E02:  MOV     [W0],W7
05E04:  MOV     W7,W4
05E06:  MUL.UU  W4,#10,W0
05E08:  MOV     W0,W7
05E0A:  MOV     1B10,W4
05E0C:  MUL.UU  W4,#4,W0
05E0E:  ADD     W0,W7,W0
05E10:  MOV     #B5A,W4
05E12:  ADD     W0,W4,W0
05E14:  MOV     [W0++],[W6++]
05E16:  MOV     [W0++],[W6++]
05E18:  MOV     AA2,W4
05E1A:  MUL.UU  W4,#8,W0
05E1C:  MOV     W0,W5
05E1E:  ADD     W5,#4,W5
05E20:  MOV     W5,W0
05E22:  MOV     #ABA,W4
05E24:  ADD     W0,W4,W5
05E26:  MOV     1B56,W4
05E28:  MUL.UU  W4,#2,W0
05E2A:  MOV     #AA6,W4
05E2C:  ADD     W0,W4,W0
05E2E:  MOV     [W0],W6
05E30:  MOV     W6,W4
05E32:  MUL.UU  W4,#10,W6
05E34:  MOV     1B12,W4
05E36:  MUL.UU  W4,#4,W0
05E38:  ADD     W0,W6,W0
05E3A:  MOV     #B5A,W4
05E3C:  ADD     W0,W4,W0
05E3E:  MOV     [W0++],[W5++]
05E40:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05E42:  MOV     AA2,W4
05E44:  ADD     W4,#1,W4
05E46:  MOV     W4,W5
05E48:  MOV     W5,W4
05E4A:  MUL.UU  W4,#8,W0
05E4C:  MOV     W0,W5
05E4E:  MOV     #ABA,W4
05E50:  ADD     W5,W4,W6
05E52:  MOV     1B56,W4
05E54:  MUL.UU  W4,#2,W0
05E56:  MOV     #AA6,W4
05E58:  ADD     W0,W4,W0
05E5A:  MOV     [W0],W7
05E5C:  MOV     W7,W4
05E5E:  MUL.UU  W4,#10,W0
05E60:  MOV     W0,W7
05E62:  ADD     W7,#8,W7
05E64:  MOV     W7,W0
05E66:  MOV     #B5A,W4
05E68:  ADD     W0,W4,W0
05E6A:  MOV     [W0++],[W6++]
05E6C:  MOV     [W0++],[W6++]
05E6E:  MOV     AA2,W4
05E70:  ADD     W4,#1,W4
05E72:  MOV     W4,W5
05E74:  MOV     W5,W4
05E76:  MUL.UU  W4,#8,W0
05E78:  MOV     W0,W5
05E7A:  ADD     W5,#4,W5
05E7C:  MOV     W5,W0
05E7E:  MOV     #ABA,W4
05E80:  ADD     W0,W4,W5
05E82:  MOV     1B56,W4
05E84:  MUL.UU  W4,#2,W0
05E86:  MOV     #AA6,W4
05E88:  ADD     W0,W4,W0
05E8A:  MOV     [W0],W6
05E8C:  MOV     W6,W4
05E8E:  MUL.UU  W4,#10,W6
05E90:  ADD     W6,#C,W6
05E92:  MOV     W6,W0
05E94:  MOV     #B5A,W4
05E96:  ADD     W0,W4,W0
05E98:  MOV     [W0++],[W5++]
05E9A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
05E9C:  MOV     #2,W4
05E9E:  MOV     W4,AA0
.................... 		                path_found = true; 
05EA0:  MOV     #1,W4
05EA2:  MOV     W4,A98
.................... 		            } 
05EA4:  GOTO    5FC0
.................... 		            else if (posEnd == 1) 
05EA8:  MOV     1B5A,W4
05EAA:  CP      W4,#1
05EAC:  BRA     NZ,5FC0
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05EAE:  MOV     AA2,W4
05EB0:  MUL.UU  W4,#8,W0
05EB2:  MOV     W0,W5
05EB4:  MOV     #ABA,W4
05EB6:  ADD     W5,W4,W6
05EB8:  MOV     1B56,W4
05EBA:  MUL.UU  W4,#2,W0
05EBC:  MOV     #AA6,W4
05EBE:  ADD     W0,W4,W0
05EC0:  MOV     [W0],W7
05EC2:  MOV     W7,W4
05EC4:  MUL.UU  W4,#10,W0
05EC6:  MOV     W0,W7
05EC8:  MOV     1B10,W4
05ECA:  MUL.UU  W4,#4,W0
05ECC:  ADD     W0,W7,W0
05ECE:  MOV     #B5A,W4
05ED0:  ADD     W0,W4,W0
05ED2:  MOV     [W0++],[W6++]
05ED4:  MOV     [W0++],[W6++]
05ED6:  MOV     AA2,W4
05ED8:  MUL.UU  W4,#8,W0
05EDA:  MOV     W0,W5
05EDC:  ADD     W5,#4,W5
05EDE:  MOV     W5,W0
05EE0:  MOV     #ABA,W4
05EE2:  ADD     W0,W4,W5
05EE4:  MOV     1B56,W4
05EE6:  MUL.UU  W4,#2,W0
05EE8:  MOV     #AA6,W4
05EEA:  ADD     W0,W4,W0
05EEC:  MOV     [W0],W6
05EEE:  MOV     W6,W4
05EF0:  MUL.UU  W4,#10,W6
05EF2:  MOV     1B12,W4
05EF4:  MUL.UU  W4,#4,W0
05EF6:  ADD     W0,W6,W0
05EF8:  MOV     #B5A,W4
05EFA:  ADD     W0,W4,W0
05EFC:  MOV     [W0++],[W5++]
05EFE:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05F00:  MOV     AA2,W4
05F02:  ADD     W4,#1,W4
05F04:  MOV     W4,W5
05F06:  MOV     W5,W4
05F08:  MUL.UU  W4,#8,W0
05F0A:  MOV     W0,W5
05F0C:  MOV     #ABA,W4
05F0E:  ADD     W5,W4,W6
05F10:  MOV     1B56,W4
05F12:  MUL.UU  W4,#2,W0
05F14:  MOV     #AA6,W4
05F16:  ADD     W0,W4,W0
05F18:  MOV     [W0],W7
05F1A:  MOV     W7,W4
05F1C:  MUL.UU  W4,#10,W0
05F1E:  MOV     W0,W7
05F20:  ADD     W7,#8,W7
05F22:  MOV     W7,W0
05F24:  MOV     #B5A,W4
05F26:  ADD     W0,W4,W0
05F28:  MOV     [W0++],[W6++]
05F2A:  MOV     [W0++],[W6++]
05F2C:  MOV     AA2,W4
05F2E:  ADD     W4,#1,W4
05F30:  MOV     W4,W5
05F32:  MOV     W5,W4
05F34:  MUL.UU  W4,#8,W0
05F36:  MOV     W0,W5
05F38:  ADD     W5,#4,W5
05F3A:  MOV     W5,W0
05F3C:  MOV     #ABA,W4
05F3E:  ADD     W0,W4,W5
05F40:  MOV     1B56,W4
05F42:  MUL.UU  W4,#2,W0
05F44:  MOV     #AA6,W4
05F46:  ADD     W0,W4,W0
05F48:  MOV     [W0],W6
05F4A:  MOV     W6,W4
05F4C:  MUL.UU  W4,#10,W6
05F4E:  ADD     W6,#C,W6
05F50:  MOV     W6,W0
05F52:  MOV     #B5A,W4
05F54:  ADD     W0,W4,W0
05F56:  MOV     [W0++],[W5++]
05F58:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05F5A:  MOV     AA2,W4
05F5C:  ADD     W4,#2,W4
05F5E:  MOV     W4,W5
05F60:  MOV     W5,W4
05F62:  MUL.UU  W4,#8,W0
05F64:  MOV     W0,W5
05F66:  MOV     #ABA,W4
05F68:  ADD     W5,W4,W6
05F6A:  MOV     1B56,W4
05F6C:  MUL.UU  W4,#2,W0
05F6E:  MOV     #AA6,W4
05F70:  ADD     W0,W4,W0
05F72:  MOV     [W0],W7
05F74:  MOV     W7,W4
05F76:  MUL.UU  W4,#10,W0
05F78:  MOV     W0,W7
05F7A:  MOV     1B14,W4
05F7C:  MUL.UU  W4,#4,W0
05F7E:  ADD     W0,W7,W0
05F80:  MOV     #B5A,W4
05F82:  ADD     W0,W4,W0
05F84:  MOV     [W0++],[W6++]
05F86:  MOV     [W0++],[W6++]
05F88:  MOV     AA2,W4
05F8A:  ADD     W4,#2,W4
05F8C:  MOV     W4,W5
05F8E:  MOV     W5,W4
05F90:  MUL.UU  W4,#8,W0
05F92:  MOV     W0,W5
05F94:  ADD     W5,#4,W5
05F96:  MOV     W5,W0
05F98:  MOV     #ABA,W4
05F9A:  ADD     W0,W4,W5
05F9C:  MOV     1B56,W4
05F9E:  MUL.UU  W4,#2,W0
05FA0:  MOV     #AA6,W4
05FA2:  ADD     W0,W4,W0
05FA4:  MOV     [W0],W6
05FA6:  MOV     W6,W4
05FA8:  MUL.UU  W4,#10,W6
05FAA:  MOV     1B16,W4
05FAC:  MUL.UU  W4,#4,W0
05FAE:  ADD     W0,W6,W0
05FB0:  MOV     #B5A,W4
05FB2:  ADD     W0,W4,W0
05FB4:  MOV     [W0++],[W5++]
05FB6:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
05FB8:  MOV     #3,W4
05FBA:  MOV     W4,AA0
.................... 		                path_found = true; 
05FBC:  MOV     #1,W4
05FBE:  MOV     W4,A98
.................... 		            } 
.................... 	        	} 
05FC0:  GOTO    6314
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 5 || posEnd == 4) 
05FC4:  MOV     1B5A,W4
05FC6:  CP      W4,#5
05FC8:  BRA     Z,5FD0
05FCA:  MOV     1B5A,W4
05FCC:  CP      W4,#4
05FCE:  BRA     NZ,602E
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05FD0:  MOV     AA2,W4
05FD2:  MUL.UU  W4,#8,W0
05FD4:  MOV     W0,W5
05FD6:  MOV     #ABA,W4
05FD8:  ADD     W5,W4,W6
05FDA:  MOV     1B56,W4
05FDC:  MUL.UU  W4,#2,W0
05FDE:  MOV     #AA6,W4
05FE0:  ADD     W0,W4,W0
05FE2:  MOV     [W0],W7
05FE4:  MOV     W7,W4
05FE6:  MUL.UU  W4,#10,W0
05FE8:  MOV     W0,W7
05FEA:  MOV     1B10,W4
05FEC:  MUL.UU  W4,#4,W0
05FEE:  ADD     W0,W7,W0
05FF0:  MOV     #B5A,W4
05FF2:  ADD     W0,W4,W0
05FF4:  MOV     [W0++],[W6++]
05FF6:  MOV     [W0++],[W6++]
05FF8:  MOV     AA2,W4
05FFA:  MUL.UU  W4,#8,W0
05FFC:  MOV     W0,W5
05FFE:  ADD     W5,#4,W5
06000:  MOV     W5,W0
06002:  MOV     #ABA,W4
06004:  ADD     W0,W4,W5
06006:  MOV     1B56,W4
06008:  MUL.UU  W4,#2,W0
0600A:  MOV     #AA6,W4
0600C:  ADD     W0,W4,W0
0600E:  MOV     [W0],W6
06010:  MOV     W6,W4
06012:  MUL.UU  W4,#10,W6
06014:  MOV     1B12,W4
06016:  MUL.UU  W4,#4,W0
06018:  ADD     W0,W6,W0
0601A:  MOV     #B5A,W4
0601C:  ADD     W0,W4,W0
0601E:  MOV     [W0++],[W5++]
06020:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
06022:  MOV     #1,W4
06024:  MOV     W4,AA0
.................... 		                path_found = true; 
06026:  MOV     #1,W4
06028:  MOV     W4,A98
.................... 		            } 
0602A:  GOTO    6314
.................... 		            else if (posEnd == 3) 
0602E:  MOV     1B5A,W4
06030:  CP      W4,#3
06032:  BRA     NZ,62B6
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
06034:  MOV     1B56,W4
06036:  MUL.UU  W4,#2,W0
06038:  MOV     #AA6,W4
0603A:  ADD     W0,W4,W0
0603C:  MOV     [W0],W5
0603E:  MOV     W5,W4
06040:  MUL.UU  W4,#10,W0
06042:  MOV     W0,W5
06044:  MOV     #B5A,W4
06046:  ADD     W5,W4,W0
06048:  MOV     [W0],W6
0604A:  MOV     1B56,W4
0604C:  MUL.UU  W4,#2,W0
0604E:  MOV     #AA6,W4
06050:  ADD     W0,W4,W0
06052:  MOV     [W0],W7
06054:  MOV     W7,W4
06056:  MUL.UU  W4,#10,W0
06058:  MOV     W0,W7
0605A:  ADD     W7,#4,W7
0605C:  MOV     W7,W0
0605E:  MOV     #B5A,W4
06060:  ADD     W0,W4,W0
06062:  MOV     [W0],W7
06064:  PUSH    1B4E
06066:  POP     1B72
06068:  PUSH    1B50
0606A:  POP     1B74
0606C:  MOV     W6,1B76
0606E:  MOV     W7,1B78
06070:  CALL    23E2
06074:  MOV     W0,W6
06076:  MOV     1B56,W4
06078:  MUL.UU  W4,#2,W0
0607A:  MOV     #AA6,W4
0607C:  ADD     W0,W4,W0
0607E:  MOV     [W0],W7
06080:  MOV     W7,W4
06082:  MUL.UU  W4,#10,W0
06084:  MOV     W0,W7
06086:  MOV     1B14,W4
06088:  MUL.UU  W4,#4,W0
0608A:  ADD     W0,W7,W0
0608C:  MOV     #B5A,W4
0608E:  ADD     W0,W4,W0
06090:  MOV     [W0],W7
06092:  MOV     1B56,W4
06094:  MUL.UU  W4,#2,W0
06096:  MOV     #AA6,W4
06098:  ADD     W0,W4,W0
0609A:  MOV     [W0],W8
0609C:  MOV     W8,W4
0609E:  MUL.UU  W4,#10,W8
060A0:  MOV     1B16,W4
060A2:  MUL.UU  W4,#4,W0
060A4:  ADD     W0,W8,W0
060A6:  MOV     #B5A,W4
060A8:  ADD     W0,W4,W0
060AA:  MOV     [W0],W8
060AC:  MOV     W7,1B72
060AE:  MOV     W8,1B74
060B0:  PUSH    1B52
060B2:  POP     1B76
060B4:  PUSH    1B54
060B6:  POP     1B78
060B8:  CALL    23E2
060BC:  ADD     W0,W6,W6
060BE:  MOV     1B56,W4
060C0:  MUL.UU  W4,#2,W0
060C2:  MOV     #AA6,W4
060C4:  ADD     W0,W4,W0
060C6:  MOV     [W0],W7
060C8:  MOV     W7,W4
060CA:  MUL.UU  W4,#10,W0
060CC:  MOV     W0,W7
060CE:  MOV     1B10,W4
060D0:  MUL.UU  W4,#4,W0
060D2:  ADD     W0,W7,W0
060D4:  MOV     #B5A,W4
060D6:  ADD     W0,W4,W0
060D8:  MOV     [W0],W7
060DA:  MOV     1B56,W4
060DC:  MUL.UU  W4,#2,W0
060DE:  MOV     #AA6,W4
060E0:  ADD     W0,W4,W0
060E2:  MOV     [W0],W8
060E4:  MOV     W8,W4
060E6:  MUL.UU  W4,#10,W8
060E8:  MOV     1B12,W4
060EA:  MUL.UU  W4,#4,W0
060EC:  ADD     W0,W8,W0
060EE:  MOV     #B5A,W4
060F0:  ADD     W0,W4,W0
060F2:  MOV     [W0],W8
060F4:  PUSH    1B4E
060F6:  POP     1B72
060F8:  PUSH    1B50
060FA:  POP     1B74
060FC:  MOV     W7,1B76
060FE:  MOV     W8,1B78
06100:  CALL    23E2
06104:  MOV     W0,W7
06106:  MOV     1B56,W4
06108:  MUL.UU  W4,#2,W0
0610A:  MOV     #AA6,W4
0610C:  ADD     W0,W4,W0
0610E:  MOV     [W0],W8
06110:  MOV     W8,W4
06112:  MUL.UU  W4,#10,W8
06114:  ADD     W8,#8,W8
06116:  MOV     W8,W0
06118:  MOV     #B5A,W4
0611A:  ADD     W0,W4,W0
0611C:  MOV     [W0],W8
0611E:  MOV     1B56,W4
06120:  MUL.UU  W4,#2,W0
06122:  MOV     #AA6,W4
06124:  ADD     W0,W4,W0
06126:  MOV     [W0],W9
06128:  MOV     W9,W4
0612A:  MUL.UU  W4,#10,W0
0612C:  MOV     W0,W9
0612E:  ADD     W9,#C,W9
06130:  MOV     W9,W0
06132:  MOV     #B5A,W4
06134:  ADD     W0,W4,W0
06136:  MOV     [W0],W9
06138:  MOV     W8,1B72
0613A:  MOV     W9,1B74
0613C:  PUSH    1B52
0613E:  POP     1B76
06140:  PUSH    1B54
06142:  POP     1B78
06144:  CALL    23E2
06148:  ADD     W0,W7,W0
0614A:  CP      W6,W0
0614C:  BRA     GE,61FE
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0614E:  MOV     AA2,W4
06150:  MUL.UU  W4,#8,W0
06152:  MOV     W0,W5
06154:  MOV     #ABA,W4
06156:  ADD     W5,W4,W6
06158:  MOV     1B56,W4
0615A:  MUL.UU  W4,#2,W0
0615C:  MOV     #AA6,W4
0615E:  ADD     W0,W4,W0
06160:  MOV     [W0],W7
06162:  MOV     W7,W4
06164:  MUL.UU  W4,#10,W0
06166:  MOV     W0,W7
06168:  MOV     #B5A,W4
0616A:  ADD     W7,W4,W0
0616C:  MOV     [W0++],[W6++]
0616E:  MOV     [W0++],[W6++]
06170:  MOV     AA2,W4
06172:  MUL.UU  W4,#8,W0
06174:  MOV     W0,W5
06176:  ADD     W5,#4,W5
06178:  MOV     W5,W0
0617A:  MOV     #ABA,W4
0617C:  ADD     W0,W4,W5
0617E:  MOV     1B56,W4
06180:  MUL.UU  W4,#2,W0
06182:  MOV     #AA6,W4
06184:  ADD     W0,W4,W0
06186:  MOV     [W0],W6
06188:  MOV     W6,W4
0618A:  MUL.UU  W4,#10,W6
0618C:  ADD     W6,#4,W6
0618E:  MOV     W6,W0
06190:  MOV     #B5A,W4
06192:  ADD     W0,W4,W0
06194:  MOV     [W0++],[W5++]
06196:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
06198:  MOV     AA2,W4
0619A:  ADD     W4,#1,W4
0619C:  MOV     W4,W5
0619E:  MOV     W5,W4
061A0:  MUL.UU  W4,#8,W0
061A2:  MOV     W0,W5
061A4:  MOV     #ABA,W4
061A6:  ADD     W5,W4,W6
061A8:  MOV     1B56,W4
061AA:  MUL.UU  W4,#2,W0
061AC:  MOV     #AA6,W4
061AE:  ADD     W0,W4,W0
061B0:  MOV     [W0],W7
061B2:  MOV     W7,W4
061B4:  MUL.UU  W4,#10,W0
061B6:  MOV     W0,W7
061B8:  MOV     1B14,W4
061BA:  MUL.UU  W4,#4,W0
061BC:  ADD     W0,W7,W0
061BE:  MOV     #B5A,W4
061C0:  ADD     W0,W4,W0
061C2:  MOV     [W0++],[W6++]
061C4:  MOV     [W0++],[W6++]
061C6:  MOV     AA2,W4
061C8:  ADD     W4,#1,W4
061CA:  MOV     W4,W5
061CC:  MOV     W5,W4
061CE:  MUL.UU  W4,#8,W0
061D0:  MOV     W0,W5
061D2:  ADD     W5,#4,W5
061D4:  MOV     W5,W0
061D6:  MOV     #ABA,W4
061D8:  ADD     W0,W4,W5
061DA:  MOV     1B56,W4
061DC:  MUL.UU  W4,#2,W0
061DE:  MOV     #AA6,W4
061E0:  ADD     W0,W4,W0
061E2:  MOV     [W0],W6
061E4:  MOV     W6,W4
061E6:  MUL.UU  W4,#10,W6
061E8:  MOV     1B16,W4
061EA:  MUL.UU  W4,#4,W0
061EC:  ADD     W0,W6,W0
061EE:  MOV     #B5A,W4
061F0:  ADD     W0,W4,W0
061F2:  MOV     [W0++],[W5++]
061F4:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
061F6:  MOV     #2,W4
061F8:  MOV     W4,AA0
.................... 		                } 
061FA:  GOTO    62AE
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
061FE:  MOV     AA2,W4
06200:  MUL.UU  W4,#8,W0
06202:  MOV     W0,W5
06204:  MOV     #ABA,W4
06206:  ADD     W5,W4,W6
06208:  MOV     1B56,W4
0620A:  MUL.UU  W4,#2,W0
0620C:  MOV     #AA6,W4
0620E:  ADD     W0,W4,W0
06210:  MOV     [W0],W7
06212:  MOV     W7,W4
06214:  MUL.UU  W4,#10,W0
06216:  MOV     W0,W7
06218:  MOV     1B10,W4
0621A:  MUL.UU  W4,#4,W0
0621C:  ADD     W0,W7,W0
0621E:  MOV     #B5A,W4
06220:  ADD     W0,W4,W0
06222:  MOV     [W0++],[W6++]
06224:  MOV     [W0++],[W6++]
06226:  MOV     AA2,W4
06228:  MUL.UU  W4,#8,W0
0622A:  MOV     W0,W5
0622C:  ADD     W5,#4,W5
0622E:  MOV     W5,W0
06230:  MOV     #ABA,W4
06232:  ADD     W0,W4,W5
06234:  MOV     1B56,W4
06236:  MUL.UU  W4,#2,W0
06238:  MOV     #AA6,W4
0623A:  ADD     W0,W4,W0
0623C:  MOV     [W0],W6
0623E:  MOV     W6,W4
06240:  MUL.UU  W4,#10,W6
06242:  MOV     1B12,W4
06244:  MUL.UU  W4,#4,W0
06246:  ADD     W0,W6,W0
06248:  MOV     #B5A,W4
0624A:  ADD     W0,W4,W0
0624C:  MOV     [W0++],[W5++]
0624E:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
06250:  MOV     AA2,W4
06252:  ADD     W4,#1,W4
06254:  MOV     W4,W5
06256:  MOV     W5,W4
06258:  MUL.UU  W4,#8,W0
0625A:  MOV     W0,W5
0625C:  MOV     #ABA,W4
0625E:  ADD     W5,W4,W6
06260:  MOV     1B56,W4
06262:  MUL.UU  W4,#2,W0
06264:  MOV     #AA6,W4
06266:  ADD     W0,W4,W0
06268:  MOV     [W0],W7
0626A:  MOV     W7,W4
0626C:  MUL.UU  W4,#10,W0
0626E:  MOV     W0,W7
06270:  ADD     W7,#8,W7
06272:  MOV     W7,W0
06274:  MOV     #B5A,W4
06276:  ADD     W0,W4,W0
06278:  MOV     [W0++],[W6++]
0627A:  MOV     [W0++],[W6++]
0627C:  MOV     AA2,W4
0627E:  ADD     W4,#1,W4
06280:  MOV     W4,W5
06282:  MOV     W5,W4
06284:  MUL.UU  W4,#8,W0
06286:  MOV     W0,W5
06288:  ADD     W5,#4,W5
0628A:  MOV     W5,W0
0628C:  MOV     #ABA,W4
0628E:  ADD     W0,W4,W5
06290:  MOV     1B56,W4
06292:  MUL.UU  W4,#2,W0
06294:  MOV     #AA6,W4
06296:  ADD     W0,W4,W0
06298:  MOV     [W0],W6
0629A:  MOV     W6,W4
0629C:  MUL.UU  W4,#10,W6
0629E:  ADD     W6,#C,W6
062A0:  MOV     W6,W0
062A2:  MOV     #B5A,W4
062A4:  ADD     W0,W4,W0
062A6:  MOV     [W0++],[W5++]
062A8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
062AA:  MOV     #2,W4
062AC:  MOV     W4,AA0
.................... 		                } 
.................... 		                path_found = true; 
062AE:  MOV     #1,W4
062B0:  MOV     W4,A98
.................... 		            } 
062B2:  GOTO    6314
.................... 		            else if (posEnd == 2 || posEnd == 1) 
062B6:  MOV     1B5A,W4
062B8:  CP      W4,#2
062BA:  BRA     Z,62C2
062BC:  MOV     1B5A,W4
062BE:  CP      W4,#1
062C0:  BRA     NZ,6314
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
062C2:  MOV     AA2,W4
062C4:  MUL.UU  W4,#8,W0
062C6:  MOV     W0,W5
062C8:  MOV     #ABA,W4
062CA:  ADD     W5,W4,W6
062CC:  MOV     1B56,W4
062CE:  MUL.UU  W4,#2,W0
062D0:  MOV     #AA6,W4
062D2:  ADD     W0,W4,W0
062D4:  MOV     [W0],W7
062D6:  MOV     W7,W4
062D8:  MUL.UU  W4,#10,W0
062DA:  MOV     W0,W7
062DC:  MOV     #B5A,W4
062DE:  ADD     W7,W4,W0
062E0:  MOV     [W0++],[W6++]
062E2:  MOV     [W0++],[W6++]
062E4:  MOV     AA2,W4
062E6:  MUL.UU  W4,#8,W0
062E8:  MOV     W0,W5
062EA:  ADD     W5,#4,W5
062EC:  MOV     W5,W0
062EE:  MOV     #ABA,W4
062F0:  ADD     W0,W4,W5
062F2:  MOV     1B56,W4
062F4:  MUL.UU  W4,#2,W0
062F6:  MOV     #AA6,W4
062F8:  ADD     W0,W4,W0
062FA:  MOV     [W0],W6
062FC:  MOV     W6,W4
062FE:  MUL.UU  W4,#10,W6
06300:  ADD     W6,#4,W6
06302:  MOV     W6,W0
06304:  MOV     #B5A,W4
06306:  ADD     W0,W4,W0
06308:  MOV     [W0++],[W5++]
0630A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0630C:  MOV     #1,W4
0630E:  MOV     W4,AA0
.................... 		                path_found = true; 
06310:  MOV     #1,W4
06312:  MOV     W4,A98
.................... 		            } 
.................... 		        } 
....................  
.................... 	            break; 
06314:  GOTO    6324
....................  
.................... 	        case 8: 
....................  
.................... 	            path_found = false; 
06318:  CLR     A98
....................  
.................... 	            break; 
0631A:  GOTO    6324
....................  
.................... 	        default: 
.................... 	            path_found = false; 
0631E:  CLR     A98
.................... 	            break; 
06320:  GOTO    6324
.................... 	    } 
....................  
.................... 	    i_rel = i_rel + relay_point_number;     
06324:  MOV     AA2,W0
06326:  ADD     AA0,W0
06328:  MOV     W0,AA2
....................     } 
0632A:  MOV     #14,W5
0632C:  REPEAT  #4
0632E:  MOV     [--W15],[W5--]
06330:  MOV     [--W15],W5
06332:  RETURN  
....................   
.................... } 
....................  
....................  
.................... #endif  
....................  
....................  
.................... #endif  
....................  
....................  
....................  
....................  
.................... //******************************************************************************** 
.................... //*  Mains 
.................... //**************************************************************************************************** 
.................... void main(void) 
*
09808:  MOV     #2000,W15
0980A:  MOV     #27FF,W0
0980C:  MOV     W0,20
0980E:  NOP     
09810:  MOV     #7444,W0
09812:  MOV     W0,94
09814:  MOV     #4744,W0
09816:  MOV     W0,96
09818:  BSET.B  81.7
0981A:  BCLR.B  2E4.3
0981C:  BCLR.B  2E4.2
0981E:  BCLR.B  2E8.2
09820:  BCLR.B  2E8.3
09822:  BSET.B  207.7
09824:  BSET.B  207.5
09826:  BSET.B  206.6
09828:  BCLR.B  207.3
0982A:  BSET.B  206.7
0982C:  BCLR.B  207.0
0982E:  BSET.B  207.1
09830:  BCLR.B  207.2
09832:  CLR     20A
09834:  MOV     #C2,W4
09836:  MOV     W4,204
09838:  MOV     #8000,W4
0983A:  MOV     W4,216
0983C:  MOV     #400,W4
0983E:  MOV     W4,218
09840:  MOV     #A,W4
09842:  MOV     W4,21E
09844:  BCLR.B  221.7
09846:  BCLR.B  2DF.0
09848:  BSET.B  2DE.7
0984A:  BCLR.B  2DE.6
0984C:  BCLR.B  220.6
0984E:  MOV     #134,W4
09850:  MOV     W4,222
09852:  BSET.B  221.7
09854:  BCLR.B  85A.0
09856:  BCLR.B  85A.1
09858:  BCLR.B  85A.2
0985A:  BCLR.B  85A.3
0985C:  BCLR.B  85A.4
0985E:  BCLR.B  85A.5
09860:  BCLR.B  85A.6
09862:  BCLR.B  85A.7
09864:  BCLR.B  85B.0
09866:  BCLR.B  85B.1
09868:  BCLR.B  85B.2
0986A:  BCLR.B  85B.3
0986C:  BCLR.B  85B.4
0986E:  CLR     85C
09870:  CLR     85E
09872:  CLR     860
09874:  CLR     862
09876:  CLR     864
09878:  CLR     866
0987A:  CLR     868
0987C:  CLR     86A
0987E:  CLR.B   86C
09880:  CLR.B   86D
09882:  CLR.B   86E
09884:  MOV.B   #4,W0L
09886:  MOV.B   W0L,86F
09888:  CLR.B   870
0988A:  CLR.B   871
0988C:  CLR.B   872
0988E:  MOV.B   #1,W0L
09890:  MOV.B   W0L,873
09892:  MOV.B   #1,W0L
09894:  MOV.B   W0L,874
09896:  CLR     876
09898:  CLR     878
0989A:  BSET.B  85B.5
0989C:  CLR.B   875
0989E:  CLR.B   87A
098A0:  CLR.B   87B
098A2:  CLR.B   87C
098A4:  CLR.B   87D
098A6:  BCLR.B  85B.6
098A8:  BCLR.B  85B.7
098AA:  MOV     #BB8,W4
098AC:  MOV     W4,87E
098AE:  CLR.B   880
098B0:  CLR.B   881
098B2:  CLR     A96
098B4:  CLR     A98
098B6:  CLR     A9A
098B8:  CLR     A9C
098BA:  CLR     A9E
098BC:  CLR     AA0
098BE:  CLR     AA2
098C0:  CLR     AA4
098C2:  MOV     #3E8,W4
098C4:  MOV     W4,C1A
098C6:  MOV.B   #A,W0L
098C8:  MOV.B   W0L,A95
098CA:  CLR     C1C
098CC:  CLR     C1E
098CE:  CLR     C20
098D0:  CLR     C22
098D2:  BCLR.B  C24.0
098D4:  CLR     14AE
098D6:  CLR     14B0
098D8:  CLR     14B2
098DA:  CLR     14B4
098DC:  CLR     14B6
098DE:  CLR     14B8
098E0:  CLR     14BA
098E2:  CLR     14BC
098E4:  CLR     14BE
098E6:  CLR     14C0
098E8:  CLR     14C2
098EA:  CLR     14C4
098EC:  MOV.B   #14,W0L
098EE:  MOV.B   W0L,C25
098F0:  MOV.B   #5,W0L
098F2:  MOV.B   W0L,14C6
098F4:  MOV     #2,W4
098F6:  MOV     W4,14C8
098F8:  CLR     14CA
098FA:  MOV.B   #3,W0L
098FC:  MOV.B   W0L,14C7
098FE:  MOV     #C8,W4
09900:  MOV     W4,14CC
09902:  BCLR.B  C24.1
09904:  BCLR.B  C24.2
09906:  CLR     14CE
09908:  CLR     14D0
0990A:  MOV     #999A,W4
0990C:  MOV     W4,1592
0990E:  MOV     #9999,W4
09910:  MOV     W4,1594
09912:  MOV     #9999,W4
09914:  MOV     W4,1596
09916:  MOV     #3FF9,W4
09918:  MOV     W4,1598
0991A:  MOV     #64,W4
0991C:  MOV     W4,159A
0991E:  CLR     159E
09920:  CLR     15A0
09922:  CLR     15A2
09924:  CLR     15A4
09926:  CLR     15A6
09928:  CLR     15A8
0992A:  CLR     15AA
0992C:  CLR     15AC
0992E:  CLR     15AE
09930:  CLR     15B0
09932:  CLR     15B2
09934:  CLR     15B4
09936:  MOV     #B851,W4
09938:  MOV     W4,15B6
0993A:  MOV     #851E,W4
0993C:  MOV     W4,15B8
0993E:  MOV     #51EB,W4
09940:  MOV     W4,15BA
09942:  MOV     #400B,W4
09944:  MOV     W4,15BC
09946:  CLR     15BE
09948:  CLR     15C0
0994A:  MOV     #8800,W4
0994C:  MOV     W4,15C2
0994E:  MOV     #40B3,W4
09950:  MOV     W4,15C4
09952:  MOV     #6DDB,W4
09954:  MOV     W4,15C6
09956:  MOV     #9A17,W4
09958:  MOV     W4,15C8
0995A:  MOV     #84EB,W4
0995C:  MOV     W4,15CA
0995E:  MOV     #403B,W4
09960:  MOV     W4,15CC
09962:  MOV     15BE,W0
09964:  MOV     15C0,W1
09966:  MOV     15C2,W2
09968:  MOV     15C4,W3
0996A:  MOV     #0,W4
0996C:  MOV     #0,W5
0996E:  MOV     #0,W6
09970:  MOV     #4010,W7
09972:  CALL    BCA
09976:  MOV     W0,W5
09978:  MOV     W1,W6
0997A:  MOV     W2,W7
0997C:  MOV     W3,W8
0997E:  MOV     W5,[W15++]
09980:  MOV     W6,[W15++]
09982:  MOV     W7,[W15++]
09984:  MOV     15B6,W0
09986:  MOV     15B8,W1
09988:  MOV     15BA,W2
0998A:  MOV     15BC,W3
0998C:  MOV     #2D18,W4
0998E:  MOV     #5444,W5
09990:  MOV     #21FB,W6
09992:  MOV     #4009,W7
09994:  CALL    BCA
09998:  MOV     [--W15],W7
0999A:  MOV     [--W15],W6
0999C:  MOV     [--W15],W5
0999E:  MOV     W5,[W15++]
099A0:  MOV     W6,[W15++]
099A2:  MOV     W7,[W15++]
099A4:  MOV     W0,W4
099A6:  MOV     W5,W0
099A8:  MOV     W1,W5
099AA:  MOV     W6,W1
099AC:  MOV     W2,W6
099AE:  MOV     W7,W2
099B0:  MOV     W3,W7
099B2:  MOV     W8,W3
099B4:  CALL    CDA
099B8:  MOV     [--W15],W7
099BA:  MOV     [--W15],W6
099BC:  MOV     [--W15],W5
099BE:  MOV     W0,15CE
099C0:  MOV     W1,15D0
099C2:  MOV     W2,15D2
099C4:  MOV     W3,15D4
099C6:  MOV     #9D39,W4
099C8:  MOV     W4,15D6
099CA:  MOV     #A252,W4
099CC:  MOV     W4,15D8
099CE:  MOV     #DF46,W4
099D0:  MOV     W4,15DA
099D2:  MOV     #3F91,W4
099D4:  MOV     W4,15DC
099D6:  CLR.B   15DE
099D8:  CLR.B   15DF
099DA:  CLR     15E0
099DC:  CLR     15E2
099DE:  CLR     15E4
099E0:  CLR     15E6
099E2:  CLR     15E8
099E4:  CLR     15EA
099E6:  CLR     15EC
099E8:  CLR     15EE
099EA:  CLR     15F0
099EC:  CLR     15F2
099EE:  BCLR.B  C24.3
099F0:  MOV     #7D0,W4
099F2:  MOV     W4,15F6
099F4:  MOV     #4B0,W4
099F6:  MOV     W4,15F8
099F8:  BCLR.B  C24.6
099FA:  CLR     15FA
099FC:  CLR     15FC
099FE:  CLR.B   15F5
09A00:  BCLR.B  C24.7
09A02:  MOV.B   #3,W0L
09A04:  MOV.B   W0L,15FE
09A06:  CLR.B   15FF
09A08:  CLR     1600
09A0A:  MOV     #F2A,W4
09A0C:  MOV     W4,1602
09A0E:  MOV     #8000,W4
09A10:  MOV     W4,20C
09A12:  MOV     #400,W4
09A14:  MOV     W4,20E
09A16:  MOV     #A,W4
09A18:  MOV     W4,214
09A1A:  BCLR.B  1604.0
09A1C:  BCLR.B  1604.1
09A1E:  CLR.B   1605
09A20:  CLR.B   1706
09A22:  BCLR.B  1604.2
09A24:  CLR.B   1707
09A26:  CLR     1B10
09A28:  MOV     #3,W4
09A2A:  MOV     W4,1B12
09A2C:  MOV     #2,W4
09A2E:  MOV     W4,1B14
09A30:  MOV     #1,W4
09A32:  MOV     W4,1B16
09A34:  CLR     1B30
09A36:  BCLR.B  1604.3
09A38:  SETM    2A8
09A3A:  BRA     9AE8
09A3C:  DATA    C2,00,08
09A3E:  DATA    82,00,C1
09A40:  DATA    60,0A,BA
09A42:  DATA    00,80,01
09A44:  DATA    0C,24,00
09A46:  DATA    C8,88,0C
09A48:  DATA    26,00,C0
09A4A:  DATA    06,14,D2
09A4C:  DATA    00,00,4B
09A4E:  DATA    F0,3F,5C
09A50:  DATA    0A,58,F6
09A52:  DATA    3B,8F,00
09A54:  DATA    C0,3C,8B
09A56:  DATA    28,AC,3C
09A58:  DATA    BE,F6,3F
09A5A:  DATA    D2,D5,44
09A5C:  DATA    16,8C,15
09A5E:  DATA    D7,BF,69
09A60:  DATA    00,5A,2E
09A62:  DATA    1B,87,99
09A64:  DATA    3F,9A,5F
09A66:  DATA    AD,4B,91
09A68:  DATA    E4,01,C0
09A6A:  DATA    5D,11,2F
09A6C:  DATA    92,E4,81
09A6E:  DATA    FB,3F,38
09A70:  DATA    DA,91,80
09A72:  DATA    9D,C5,E0
09A74:  DATA    BF,6F,12
09A76:  DATA    C0,B4,C3
09A78:  DATA    09,AB,3F
09A7A:  DATA    6B,C1,03
09A7C:  DATA    4E,C1,B5
09A7E:  DATA    45,BF,F7
09A80:  DATA    40,05,FF
09A82:  DATA    00,5C,EF
09A84:  DATA    3F,F3,A3
09A86:  DATA    E2,F7,D7
09A88:  DATA    FF,01,40
09A8A:  DATA    C0,B4,FF
09A8C:  DATA    05,3C,58
09A8E:  DATA    FC,3F,3B
09A90:  DATA    D3,C0,B5
09A92:  DATA    BA,8C,E2
09A94:  DATA    3F,39,D3
09A96:  DATA    C7,3D,41
09A98:  DATA    79,B2,3F
09A9A:  DATA    87,0D,3C
09A9C:  DATA    50,D0,AF
09A9E:  DATA    62,3F,30
09AA0:  DATA    4B,8D,A2
09AA2:  DATA    82,AA,04
09AA4:  DATA    40,09,A0
09AA6:  DATA    40,4A,05
09AA8:  DATA    76,03,40
09AAA:  DATA    EC,9E,37
09AAC:  DATA    88,A6,44
09AAE:  DATA    F0,3F,8F
09AB0:  DATA    12,8D,29
09AB2:  DATA    9A,5B,C7
09AB4:  DATA    3F,0E,E0
09AB6:  DATA    80,7C,A1
09AB8:  DATA    D8,86,3F
09ABA:  DATA    29,4B,FB
09ABC:  DATA    95,C2,37
09ABE:  DATA    1A,3F,00
09AC0:  DATA    00,80,01
09AC2:  DATA    15,F4,00
09AC4:  DATA    C1,00,16
09AC6:  DATA    06,00,C4
09AC8:  DATA    08,17,08
09ACA:  DATA    00,00,00
09ACC:  INC     W2,W2
09ACE:  CP      W2,#1
09AD0:  BRA     NZ,9ADA
09AD2:  TBLRDL  [W1],W3
09AD4:  TBLRDH  [W1++],W4
09AD6:  MOV.B   6,W0L
09AD8:  RETURN  
09ADA:  CP      W2,#2
09ADC:  BRA     NZ,9AE2
09ADE:  MOV.B   7,W0L
09AE0:  RETURN  
09AE2:  MOV.B   8,W0L
09AE4:  CLR     W2
09AE6:  RETURN  
09AE8:  MOV     #0,W6
09AEA:  MOV     #0,W0
09AEC:  MOV     W0,32
09AEE:  MOV     #9A3C,W0
09AF0:  MOV     W0,W1
09AF2:  CLR     W2
09AF4:  CALL    9ACC
09AF8:  MOV.B   W0L,B
09AFA:  CALL    9ACC
09AFE:  MOV.B   W0L,A
09B00:  CP0     W5
09B02:  BRA     Z,9B36
09B04:  BTSS    W5.F
09B06:  BRA     9B16
09B08:  CALL    9ACC
09B0C:  MOV.B   W0L,D
09B0E:  CALL    9ACC
09B12:  MOV.B   W0L,C
09B14:  BCLR    W5.F
09B16:  BTSS    W5.E
09B18:  BRA     9B2A
09B1A:  BCLR    W5.E
09B1C:  DEC     W5,W5
09B1E:  CALL    9ACC
09B22:  MOV.B   W0L,W7L
09B24:  REPEAT  W5
09B26:  MOV.B   W7L,[W6++]
09B28:  BRA     9AF4
09B2A:  CALL    9ACC
09B2E:  MOV.B   W0L,[W6++]
09B30:  DEC     W5,W5
09B32:  BRA     NZ,9B2A
09B34:  BRA     9AF4
.................... { 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////	INITIALISATION DE TOUS LES MODULES	//////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 		// Initialisation du dsPIC 
.................... 	__Init_dsPIC();	 
09B36:  CALL    DF6
.................... 	__Init_UART(); 
09B3A:  CALL    E48
.................... 	//__Init_pos(); 
.................... 					 
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 			// Configuration de la balise 
.................... 	Balise_config_plage(0, 12, 14);	// En avanant 
09B3E:  CLR.B   1B3A
09B40:  MOV.B   #C,W0L
09B42:  MOV.B   W0L,1B3B
09B44:  MOV.B   #E,W0L
09B46:  MOV.B   W0L,1B3C
09B48:  CALL    E64
.................... 	delay_ms(100); 
09B4C:  MOV     #64,W0
09B4E:  CALL    DE2
.................... 	Balise_config_plage(1, 4, 6); // En reculant 
09B52:  MOV.B   #1,W0L
09B54:  MOV.B   W0L,1B3A
09B56:  MOV.B   #4,W0L
09B58:  MOV.B   W0L,1B3B
09B5A:  MOV.B   #6,W0L
09B5C:  MOV.B   W0L,1B3C
09B5E:  CALL    E64
.................... 	delay_ms(100); 
09B62:  MOV     #64,W0
09B64:  CALL    DE2
....................  
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 		// Set la base 
.................... 		// On n'affiche pas l'erreur ici car si on dbranche le driver de dplacement 
.................... 		// pour envoyer les objectifs, cela bloquerait le systme 
.................... //	unsigned int8 ToSetBase=0; 
....................  
.................... 	LED3 = 1; 
09B68:  BSET.B  2D0.3
.................... 	 
.................... 	if(_TEAM==0) 
09B6A:  BTSC.B  2C2.7
09B6C:  BRA     9B76
.................... 	{ 
.................... 		//_LDT1=0; 
.................... 		//_LDT2=1; 
.................... 		Team=0; 
09B6E:  BCLR.B  85B.4
.................... 		LED3 = 0; 
09B70:  BCLR.B  2D0.3
.................... 		 
.................... 	} 
09B72:  GOTO    9B7E
.................... 	else if(_TEAM==1) 
09B76:  BTSS.B  2C2.7
09B78:  BRA     9B7E
.................... 	{ 
.................... 		//_LDT2=0; 
.................... 		//_LDT1=1; 
.................... 		Team=1; 
09B7A:  BSET.B  85B.4
.................... 		LED3 = 1; 
09B7C:  BSET.B  2D0.3
.................... 	}	 
.................... 	 
.................... 	delay_ms(500); 
09B7E:  MOV     #1F4,W0
09B80:  CALL    DE2
.................... 	 
.................... 	fprintf(ROBOTEQ,"!MG\r"); 
09B84:  MOV     #0,W1
09B86:  MOV     W1,W0
09B88:  CLR.B   1
09B8A:  CALL    3F6
09B8E:  INC     W1,W1
09B90:  BTSC.B  219.1
09B92:  BRA     9B90
09B94:  MOV     W0,21A
09B96:  MOV     #3,W0
09B98:  CPSGT   W1,W0
09B9A:  BRA     9B86
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 			 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	/////////////////////////////////	PROGRAMME PRINCIPAL	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	int1 action_ok1 = 0; 
.................... 	int1 action_ok2 = 0; 
.................... 	int1 action_ok3 = 0; 
.................... 	int1 Module_inplace = 0; 
09B9C:  BCLR.B  1B32.0
09B9E:  BCLR.B  1B32.1
09BA0:  BCLR.B  1B32.2
09BA2:  BCLR.B  1B32.3
.................... 	 
.................... 	LED1 = 1; 
09BA4:  BSET.B  2D0.1
.................... 	delay_ms(200); 
09BA6:  MOV     #C8,W0
09BA8:  CALL    DE2
.................... 	LED1 = 0; 
09BAC:  BCLR.B  2D0.1
.................... 	LED2 = 1; 
09BAE:  BSET.B  2D0.2
.................... 	delay_ms(200); 
09BB0:  MOV     #C8,W0
09BB2:  CALL    DE2
.................... 	LED2 = 0; 
09BB6:  BCLR.B  2D0.2
.................... 	LED3 = 1; 
09BB8:  BSET.B  2D0.3
.................... 	delay_ms(200); 
09BBA:  MOV     #C8,W0
09BBC:  CALL    DE2
.................... 	LED3 = 0; 
09BC0:  BCLR.B  2D0.3
.................... 	delay_ms(200); 
09BC2:  MOV     #C8,W0
09BC4:  CALL    DE2
.................... 	LED3 = 1; 
09BC8:  BSET.B  2D0.3
.................... 	delay_ms(200); 
09BCA:  MOV     #C8,W0
09BCC:  CALL    DE2
.................... 	LED3 = 0; 
09BD0:  BCLR.B  2D0.3
.................... 	LED2 = 1; 
09BD2:  BSET.B  2D0.2
.................... 	delay_ms(200); 
09BD4:  MOV     #C8,W0
09BD6:  CALL    DE2
.................... 	LED2 = 0; 
09BDA:  BCLR.B  2D0.2
.................... 	LED1 = 1; 
09BDC:  BSET.B  2D0.1
.................... 	delay_ms(200); 
09BDE:  MOV     #C8,W0
09BE0:  CALL    DE2
.................... 	LED1 = 0; 
09BE4:  BCLR.B  2D0.1
.................... 	delay_ms(180); 
09BE6:  MOV     #B4,W0
09BE8:  CALL    DE2
....................  	 
....................   		 
.................... 	while(1) 
.................... 	{		 
.................... 		switch(Etat_rob) 
09BEC:  MOV.B   87B,W0L
09BEE:  CLR.B   1
09BF0:  XOR     #0,W0
09BF2:  BRA     Z,9C16
09BF4:  XOR     #1,W0
09BF6:  BRA     Z,9CCA
09BF8:  XOR     #3,W0
09BFA:  BRA     Z,9CCE
09BFC:  XOR     #1,W0
09BFE:  BRA     Z,9D72
09C00:  XOR     #7,W0
09C02:  BRA     Z,9DAC
09C04:  XOR     #1,W0
09C06:  BRA     Z,9DFA
09C08:  XOR     #3,W0
09C0A:  BRA     Z,9E50
09C0C:  XOR     #1,W0
09C0E:  BRA     Z,9F04
09C10:  XOR     #F,W0
09C12:  BRA     Z,9FC6
09C14:  BRA     A034
.................... 		{ 
.................... 			case Init: 
.................... 			 
.................... 				if(!_DEMA && flag_started == 0) 
09C16:  BTSC.B  2C2.6
09C18:  BRA     9C2A
09C1A:  BTSC.B  85A.4
09C1C:  BRA     9C2A
.................... 				{ 
.................... 					LED3 = 1; 
09C1E:  BSET.B  2D0.3
.................... 					LED2 = 0; 
09C20:  BCLR.B  2D0.2
.................... 					LED1 = 0; 
09C22:  BCLR.B  2D0.1
.................... 					flag_started = 1; 
09C24:  BSET.B  85A.4
.................... 				} 
09C26:  GOTO    9CC6
.................... 					 
.................... 				else if(_DEMA && flag_started == 0) 
09C2A:  BTSS.B  2C2.6
09C2C:  BRA     9C4E
09C2E:  BTSC.B  85A.4
09C30:  BRA     9C4E
.................... 				{ 
.................... 					LED1 = 1; 
09C32:  BSET.B  2D0.1
.................... 					LED2 = 1; 
09C34:  BSET.B  2D0.2
.................... 					LED3 = 1; 
09C36:  BSET.B  2D0.3
.................... 					 
.................... 					delay_ms(200); 
09C38:  MOV     #C8,W0
09C3A:  CALL    DE2
.................... 					 
.................... 					LED1 = 0; 
09C3E:  BCLR.B  2D0.1
.................... 					LED2 = 0; 
09C40:  BCLR.B  2D0.2
.................... 					LED3 = 0; 
09C42:  BCLR.B  2D0.3
.................... 					 
.................... 					delay_ms(200); 
09C44:  MOV     #C8,W0
09C46:  CALL    DE2
.................... 				} 
09C4A:  GOTO    9CC6
.................... 				 
.................... 				else if(NbreObjectifs > 0 && _DEMA  && !flag_end && flag_started == 1)//si on a des objectifs et qu'il sont charger 
09C4E:  CP0     14CE
09C50:  BRA     Z,9C8E
09C52:  BTSS.B  2C2.6
09C54:  BRA     9C8E
09C56:  BTSC.B  85B.0
09C58:  BRA     9C8E
09C5A:  BTSS.B  85A.4
09C5C:  BRA     9C8E
.................... 				{ 
.................... 					LED3 = 0; 
09C5E:  BCLR.B  2D0.3
.................... 					LED2 = 0; 
09C60:  BCLR.B  2D0.2
.................... 					LED1 = 1; 
09C62:  BSET.B  2D0.1
.................... 					 
.................... 					if(BeginTimeMS==0)  
09C64:  CP0     864
09C66:  BRA     NZ,9C74
09C68:  CP0     866
09C6A:  BRA     NZ,9C74
.................... 					{ 
.................... 						BeginTimeMS = RealTimeMS; 
09C6C:  PUSH    860
09C6E:  POP     864
09C70:  PUSH    862
09C72:  POP     866
.................... 						//delay_ms(1000);  
.................... 					} 
.................... 					__LoadObj(NoObj,NoPts);//on mets l'objectifs dans des variables 
09C74:  MOV.B   873,W0L
09C76:  MOV.B   W0L,1B3C
09C78:  CLR.B   1B3D
09C7A:  MOV.B   874,W0L
09C7C:  MOV.B   W0L,1B3E
09C7E:  CLR.B   1B3F
09C80:  CALL    EAE
.................... 					Etat_rob = Check_ZI;//on change d'etat 
09C84:  MOV.B   #2,W0L
09C86:  MOV.B   W0L,87B
.................... 					Depl_send = 0;			 
09C88:  BCLR.B  85B.6
.................... 				} 
09C8A:  GOTO    9CC6
.................... 				else if(NbreObjectifs == 0 && !_DEMA  && !flag_end && flag_started == 1) 
09C8E:  CP0     14CE
09C90:  BRA     NZ,9CB0
09C92:  BTSC.B  2C2.6
09C94:  BRA     9CB0
09C96:  BTSC.B  85B.0
09C98:  BRA     9CB0
09C9A:  BTSS.B  85A.4
09C9C:  BRA     9CB0
.................... 				{ 
.................... 					LED3 = 0; 
09C9E:  BCLR.B  2D0.3
.................... 					LED2 = 1; 
09CA0:  BSET.B  2D0.2
.................... 					LED1 = 0; 
09CA2:  BCLR.B  2D0.1
.................... 					__ReadObjectifs();	 
09CA4:  CALL    105E
.................... 					__ReadZones_Interdites(); 
09CA8:  CALL    1162
.................... 				} 
09CAC:  GOTO    9CC6
.................... 				else if(!_DEMA && NbreObjectifs != 0 && flag_started == 1) 
09CB0:  BTSC.B  2C2.6
09CB2:  BRA     9CC6
09CB4:  CP0     14CE
09CB6:  BRA     Z,9CC6
09CB8:  BTSS.B  85A.4
09CBA:  BRA     9CC6
.................... 				{		 
.................... 					LED3 = 0; 
09CBC:  BCLR.B  2D0.3
.................... 					LED2 = 1; 
09CBE:  BSET.B  2D0.2
.................... 					LED1 = 1;		 
09CC0:  BSET.B  2D0.1
.................... 					__Init_pos();	 
09CC2:  CALL    13F8
....................  
.................... 					//Envoi de l'initialisation l'arduino pour lui indiquer de quel ct on joue 
.................... 					 
.................... 					//data_to_transmit[0] = Team; 
.................... 					//Write_cmd_arduino(100,1, &data_to_transmit );				 
.................... 				} 
.................... 						 
.................... 					 
.................... 					 
.................... 				break; 
09CC6:  GOTO    A038
....................  
....................  
.................... 			 
.................... 			case Choose_objectif: 
....................  
.................... 				/* 
.................... 				static int obj_todo = 0; //L'objectif qu'on regarde si on peut le faire 
....................  
.................... 				obj_todo++; //On passe  l'objectif suivant 
.................... 				__LoadObj(obj_todo, 1); //On rcupre les donnes de l'objectif dans les variables 
....................  
.................... 				if(oTime < (TimeLimit - GameTimeS) && !obj_done && !obj_notcontinuable) 
.................... 				{ 
.................... 					Etat_rob = Check_ZI; 
.................... 				} 
....................  
.................... 				if (obj_todo >= (NbreObjectifs))  
.................... 				{ 
.................... 					obj_todo = 0; 
.................... 					Etat_rob = Wait_end; 
.................... 				} 
.................... 				*/ 
.................... 				break; 
09CCA:  GOTO    A038
.................... 				 
....................  
.................... 			case Check_ZI: 
....................  
.................... 				if(checkPath()) 
09CCE:  CALL    16D8
09CD2:  CP0     W0
09CD4:  BRA     Z,9CDE
.................... 				{ 
.................... 					Etat_rob = Send_depl_action; 
09CD6:  MOV.B   #3,W0L
09CD8:  MOV.B   W0L,87B
.................... 				} 
09CDA:  GOTO    9D6E
.................... 				else 
.................... 				{ 
.................... 					//On met le point de dpart dans la premire case du tableau 
.................... 					i_rel = 0; 
09CDE:  CLR     AA2
.................... 					PtsRelai[i_rel][X] = Pos_x;  
09CE0:  MOV     AA2,W4
09CE2:  MUL.UU  W4,#8,W0
09CE4:  MOV     W0,W5
09CE6:  MOV     #ABA,W4
09CE8:  ADD     W5,W4,W6
09CEA:  MOV     15A0,W0
09CEC:  CLR     W1
09CEE:  BTSC    W0.F
09CF0:  SETM    W1
09CF2:  MOV     #0,W4
09CF4:  MOV     [W4++],[W6++]
09CF6:  MOV     [W4++],[W6++]
.................... 					PtsRelai[i_rel][Y] = Pos_y;  
09CF8:  MOV     AA2,W4
09CFA:  MUL.UU  W4,#8,W0
09CFC:  MOV     W0,W5
09CFE:  ADD     W5,#4,W5
09D00:  MOV     W5,W0
09D02:  MOV     #ABA,W4
09D04:  ADD     W0,W4,W5
09D06:  MOV     15A2,W0
09D08:  CLR     W1
09D0A:  BTSC    W0.F
09D0C:  SETM    W1
09D0E:  MOV     #0,W4
09D10:  MOV     [W4++],[W5++]
09D12:  MOV     [W4++],[W5++]
.................... 					i_rel++; 
09D14:  INC     0AA2
.................... 					 
.................... 					findPath(); 
09D16:  CALL    6484
.................... 					 
.................... 					i_rel++; 
09D1A:  INC     0AA2
.................... 					PtsRelai[i_rel-1][X] = oXp;  
09D1C:  MOV     AA2,W4
09D1E:  SUB     W4,#1,W5
09D20:  MOV     W5,W4
09D22:  MUL.UU  W4,#8,W0
09D24:  MOV     W0,W5
09D26:  MOV     #ABA,W4
09D28:  ADD     W5,W4,W6
09D2A:  MOV     14AE,W0
09D2C:  CLR     W1
09D2E:  BTSC    W0.F
09D30:  SETM    W1
09D32:  MOV     #0,W4
09D34:  MOV     [W4++],[W6++]
09D36:  MOV     [W4++],[W6++]
.................... 					PtsRelai[i_rel-1][Y] = oYp;  
09D38:  MOV     AA2,W4
09D3A:  SUB     W4,#1,W5
09D3C:  MOV     W5,W4
09D3E:  MUL.UU  W4,#8,W0
09D40:  MOV     W0,W5
09D42:  ADD     W5,#4,W5
09D44:  MOV     W5,W0
09D46:  MOV     #ABA,W4
09D48:  ADD     W0,W4,W5
09D4A:  MOV     14B0,W0
09D4C:  CLR     W1
09D4E:  BTSC    W0.F
09D50:  SETM    W1
09D52:  MOV     #0,W4
09D54:  MOV     [W4++],[W5++]
09D56:  MOV     [W4++],[W5++]
.................... 					i_depl = 1; 
09D58:  MOV     #1,W4
09D5A:  MOV     W4,AA4
.................... 					 
.................... 					if(path_impossible == 1) 
09D5C:  MOV     A9A,W4
09D5E:  CP      W4,#1
09D60:  BRA     NZ,9D6A
.................... 			        { 
.................... 				        __Stop(); 
09D62:  CALL    6334
.................... 				    }  
09D66:  GOTO    9D6E
.................... 				    else 
.................... 				    { 
.................... 					    Etat_rob = Send_depl_action_ZI; 
09D6A:  MOV.B   #4,W0L
09D6C:  MOV.B   W0L,87B
.................... 					}  
.................... 					 
.................... 				} 
....................  
.................... 				break; 
09D6E:  GOTO    A038
....................  
.................... 			case Send_depl_action: 
....................  
.................... 				if(!Depl_send && !flag_end)//si le deplacement n'as pas ete envoye 
09D72:  BTSC.B  85B.6
09D74:  BRA     9D82
09D76:  BTSC.B  85B.0
09D78:  BRA     9D82
.................... 				{ 
.................... 					__DeplToDo(oType);//envoie le dplacment 
09D7A:  MOV.B   14B2,W0L
09D7C:  MOV.B   W0L,1B3A
09D7E:  CALL    8858
.................... 				} 
.................... 				if(!Action_send && !flag_end)//si l'action n'a pas ete envoyee 
09D82:  BTSC.B  C24.0
09D84:  BRA     9D94
09D86:  BTSC.B  85B.0
09D88:  BRA     9D94
.................... 				{ 
.................... 					flag_action_done = 0; 
09D8A:  BCLR.B  C24.2
.................... 					__Action_Writting(obj_Action);//envoie l'action 
09D8C:  MOV.B   14BA,W0L
09D8E:  MOV.B   W0L,1B3A
09D90:  CALL    8AC2
.................... 				} 
.................... 				if(/*flag_action_done &&*/ Depl_send && Action_send && !flag_end)//si tout a ete envoye 
09D94:  BTSS.B  85B.6
09D96:  BRA     9DA8
09D98:  BTSS.B  C24.0
09D9A:  BRA     9DA8
09D9C:  BTSC.B  85B.0
09D9E:  BRA     9DA8
.................... 				{ 
.................... 					Depl_send = 0; 
09DA0:  BCLR.B  85B.6
.................... 					Action_send = 0; 
09DA2:  BCLR.B  C24.0
.................... 					Etat_rob = Depl_action_process; 
09DA4:  MOV.B   #5,W0L
09DA6:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
09DA8:  GOTO    A038
....................  
....................  
.................... 			case Send_depl_action_ZI: 
....................  
.................... 				//__Check_commande_atteint(); 
.................... 				 
.................... 				if(!Action_send)//si l'action n'a pas ete envoyee 
09DAC:  BTSC.B  C24.0
09DAE:  BRA     9DBA
.................... 				{ 
.................... 					flag_action_done = 0; 
09DB0:  BCLR.B  C24.2
.................... 					__Action_Writting(obj_Action);//envoie l'action 
09DB2:  MOV.B   14BA,W0L
09DB4:  MOV.B   W0L,1B3A
09DB6:  CALL    8AC2
.................... 				} 
....................  
.................... 				//Si le dplacement n'a pas encore t envoy 
.................... 				if(!Depl_send) 
09DBA:  BTSC.B  85B.6
09DBC:  BRA     9DE2
.................... 				{ 
.................... 					//On l'envoie 
.................... 					__PaP(PtsRelai[i_depl][X], PtsRelai[i_depl][Y]); 
09DBE:  MOV     AA4,W4
09DC0:  MUL.UU  W4,#8,W0
09DC2:  MOV     W0,W5
09DC4:  MOV     #ABA,W4
09DC6:  ADD     W5,W4,W0
09DC8:  MOV     [W0],W6
09DCA:  MOV     AA4,W4
09DCC:  MUL.UU  W4,#8,W0
09DCE:  MOV     W0,W7
09DD0:  ADD     W7,#4,W7
09DD2:  MOV     W7,W0
09DD4:  MOV     #ABA,W4
09DD6:  ADD     W0,W4,W0
09DD8:  MOV     [W0],W7
09DDA:  MOV     W6,1B40
09DDC:  MOV     W7,1B42
09DDE:  CALL    76A6
.................... 				} 
....................  
.................... 				//Si tout a t envoy 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
09DE2:  BTSS.B  85B.6
09DE4:  BRA     9DF6
09DE6:  BTSS.B  C24.0
09DE8:  BRA     9DF6
09DEA:  BTSC.B  85B.0
09DEC:  BRA     9DF6
.................... 				{ 
.................... 					Depl_send = 0; 
09DEE:  BCLR.B  85B.6
.................... 					Action_send = 0; 
09DF0:  BCLR.B  C24.0
.................... 					Etat_rob = Depl_action_process_ZI; 
09DF2:  MOV.B   #6,W0L
09DF4:  MOV.B   W0L,87B
.................... 				} 
....................  
.................... 				break; 
09DF6:  GOTO    A038
....................  
.................... 			case Depl_action_process : 
....................  
.................... 				__Check_commande_atteint(); 
09DFA:  CALL    73AA
.................... 				Check_action_done(); 
09DFE:  CALL    8B34
.................... 				 
.................... 				if(flag_depl_ok/* && flag_action_done*/ && Check && !flag_end && !_Detected)//on attend que tout soit fini 
09E02:  BTSS.B  85A.7
09E04:  BRA     9E4C
09E06:  BTSS.B  85B.5
09E08:  BRA     9E4C
09E0A:  BTSC.B  85B.0
09E0C:  BRA     9E4C
09E0E:  BTSC.B  85B.1
09E10:  BRA     9E4C
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
09E12:  MOV     872,W4
09E14:  LSR     W4,#8,W4
09E16:  CP.B    W4L,#1
09E18:  BRA     NZ,9E26
09E1A:  MOV     874,W4
09E1C:  CP.B    W4L,#1
09E1E:  BRA     NZ,9E26
09E20:  MOV     #3E8,W0
09E22:  CALL    DE2
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
09E26:  MOV     15A0,W0
09E28:  ADD     159C,W0
09E2A:  MOV     W0,15A0
.................... 					Pos_y += Dist_y; 
09E2C:  MOV     15A2,W0
09E2E:  ADD     159E,W0
09E30:  MOV     W0,15A2
.................... 					 
.................... 	 
.................... 					Dist_x=0; 
09E32:  CLR     159C
.................... 					Dist_y=0; 
09E34:  CLR     159E
.................... 					Dorient = 0; 
09E36:  CLR     15A6
09E38:  CLR     15A8
09E3A:  CLR     15AA
09E3C:  CLR     15AC
.................... 					balise_on = 0; 
09E3E:  BCLR.B  85B.2
.................... 					flag_depl_ok = 0; 
09E40:  BCLR.B  85A.7
.................... 					action_ok1 = 0; 
09E42:  BCLR.B  1B32.0
.................... 					action_ok2 = 0; 
09E44:  BCLR.B  1B32.1
.................... 					action_ok3 = 0; 
09E46:  BCLR.B  1B32.2
.................... 					Etat_rob = Switch_end_obj; 
09E48:  MOV.B   #7,W0L
09E4A:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
09E4C:  GOTO    A038
....................  
.................... 			case Depl_action_process_ZI: 
....................  
.................... 				__Check_commande_atteint(); 
09E50:  CALL    73AA
.................... 				Check_action_done(); 
09E54:  CALL    8B34
.................... 				 
.................... 				if(flag_depl_ok && flag_action_done && Check && !flag_end && !_Detected)//on attend que tout soit fini 
09E58:  BTSS.B  85A.7
09E5A:  BRA     9F00
09E5C:  BTSS.B  C24.2
09E5E:  BRA     9F00
09E60:  BTSS.B  85B.5
09E62:  BRA     9F00
09E64:  BTSC.B  85B.0
09E66:  BRA     9F00
09E68:  BTSC.B  85B.1
09E6A:  BRA     9F00
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
09E6C:  MOV     872,W4
09E6E:  LSR     W4,#8,W4
09E70:  CP.B    W4L,#1
09E72:  BRA     NZ,9E80
09E74:  MOV     874,W4
09E76:  CP.B    W4L,#1
09E78:  BRA     NZ,9E80
09E7A:  MOV     #3E8,W0
09E7C:  CALL    DE2
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
09E80:  MOV     15A0,W0
09E82:  ADD     159C,W0
09E84:  MOV     W0,15A0
.................... 					Pos_y += Dist_y; 
09E86:  MOV     15A2,W0
09E88:  ADD     159E,W0
09E8A:  MOV     W0,15A2
.................... 					 
.................... 	 
.................... 					Dist_x=0; 
09E8C:  CLR     159C
.................... 					Dist_y=0; 
09E8E:  CLR     159E
.................... 					Dorient = 0; 
09E90:  CLR     15A6
09E92:  CLR     15A8
09E94:  CLR     15AA
09E96:  CLR     15AC
.................... 					balise_on = 0; 
09E98:  BCLR.B  85B.2
.................... 					flag_depl_ok = 0; 
09E9A:  BCLR.B  85A.7
.................... 					action_ok1 = 0; 
09E9C:  BCLR.B  1B32.0
.................... 					action_ok2 = 0; 
09E9E:  BCLR.B  1B32.1
.................... 					action_ok3 = 0; 
09EA0:  BCLR.B  1B32.2
.................... 					 
.................... 					i_depl++; 
09EA2:  INC     0AA4
.................... 					 
.................... 					if(i_depl >= i_rel)//si tout a ete envoye 
09EA4:  MOV     AA2,W0
09EA6:  MOV     AA4,W4
09EA8:  CP      W4,W0
09EAA:  BRA     LT,9EFC
.................... 					{ 
.................... 						Depl_send = 0; 
09EAC:  BCLR.B  85B.6
.................... 						Action_send = 0; 
09EAE:  BCLR.B  C24.0
.................... 						int i; 
.................... 						for(i = 0; i < 10; i++) 
09EB0:  CLR     1B34
09EB2:  MOV     1B34,W4
09EB4:  CP      W4,#A
09EB6:  BRA     GE,9EF2
.................... 						{ 
.................... 							PtsRelai[i][0] = 0; 
09EB8:  MOV     1B34,W4
09EBA:  MUL.UU  W4,#8,W0
09EBC:  MOV     W0,W5
09EBE:  MOV     #ABA,W4
09EC0:  ADD     W5,W4,W6
09EC2:  CLR.B   [W6]
09EC4:  MOV.B   #0,W0L
09EC6:  MOV.B   W0L,[W6+#1]
09EC8:  MOV.B   #0,W0L
09ECA:  MOV.B   W0L,[W6+#2]
09ECC:  MOV.B   #0,W0L
09ECE:  MOV.B   W0L,[W6+#3]
.................... 							PtsRelai[i][1] = 0; 
09ED0:  MOV     1B34,W4
09ED2:  MUL.UU  W4,#8,W0
09ED4:  MOV     W0,W5
09ED6:  ADD     W5,#4,W5
09ED8:  MOV     W5,W0
09EDA:  MOV     #ABA,W4
09EDC:  ADD     W0,W4,W5
09EDE:  CLR.B   [W5]
09EE0:  MOV.B   #0,W0L
09EE2:  MOV.B   W0L,[W5+#1]
09EE4:  MOV.B   #0,W0L
09EE6:  MOV.B   W0L,[W5+#2]
09EE8:  MOV.B   #0,W0L
09EEA:  MOV.B   W0L,[W5+#3]
09EEC:  INC     1B34
09EEE:  GOTO    9EB2
.................... 						}	 
.................... 						path_opposite = 0; 
09EF2:  CLR     A9C
.................... 						Etat_rob = Switch_end_obj; 
09EF4:  MOV.B   #7,W0L
09EF6:  MOV.B   W0L,87B
.................... 					} 
09EF8:  GOTO    9F00
.................... 					else 
.................... 					{ 
.................... 					 Etat_rob = Send_depl_action_ZI; 
09EFC:  MOV.B   #4,W0L
09EFE:  MOV.B   W0L,87B
.................... 					}	 
.................... 					 
.................... 				} 
.................... 				break;	 
09F00:  GOTO    A038
....................  
.................... 			 
.................... 			case Switch_end_obj: 
.................... 			 
.................... 				if(keep_obj==0)  
09F04:  CP0     14C4
09F06:  BRA     NZ,9F22
.................... 				{ 
.................... 					TabObjectifs[NoObj][1][8] = 0; // mise de la ponderation a 0 --> on le remploie plus 
09F08:  MOV.B   873,W0L
09F0A:  CLR.B   1
09F0C:  MOV     #138,W4
09F0E:  MUL.UU  W0,W4,W0
09F10:  MOV     W0,W5
09F12:  ADD     W5,#18,W5
09F14:  ADD     W5,#10,W5
09F16:  MOV     W5,W0
09F18:  MOV     #C26,W4
09F1A:  ADD     W0,W4,W5
09F1C:  CLR.B   [W5]
09F1E:  MOV.B   #0,W0L
09F20:  MOV.B   W0L,[W5+#1]
.................... 				} 
.................... 			 	if(Obj_end)//si fini l'objectifs,passe a l'obj suivant 
09F22:  CP0     14C0
09F24:  BRA     Z,9F88
.................... 				{ 
.................... 					if(Next_obj!=0) // 0--> passe a l'obj suivant, sinon va a l'obj marquer 
09F26:  CP0     14C2
09F28:  BRA     Z,9F4E
.................... 					{ 
.................... 						last_obj = NoObj; 
09F2A:  MOV.B   873,W0L
09F2C:  MOV.B   W0L,876
09F2E:  CLR.B   877
09F30:  CLR     878
.................... 						NoObj = Next_Obj; 
09F32:  MOV.B   14C2,W0L
09F34:  MOV.B   W0L,873
.................... 						NoPts = 1; 
09F36:  MOV.B   #1,W0L
09F38:  MOV.B   W0L,874
.................... 						__LoadObj(NoObj,NoPts);//charge le nouveau pts						 
09F3A:  MOV.B   873,W0L
09F3C:  MOV.B   W0L,1B3C
09F3E:  CLR.B   1B3D
09F40:  MOV.B   874,W0L
09F42:  MOV.B   W0L,1B3E
09F44:  CLR.B   1B3F
09F46:  CALL    EAE
.................... 					} 
09F4A:  GOTO    9F84
.................... 					else 
.................... 					{ 
.................... 						last_obj = NoObj; 
09F4E:  MOV.B   873,W0L
09F50:  MOV.B   W0L,876
09F52:  CLR.B   877
09F54:  CLR     878
.................... 						do //prochain objectifs avec pondration de 10 
.................... 						{ 
.................... 							//__Afficheur_7segments(4); 
.................... 							NoObj++; // on passe a l'objectifs suivant 
09F56:  INC.B   0873
.................... 							NoPts=1; // on reprend au premier pts 
09F58:  MOV.B   #1,W0L
09F5A:  MOV.B   W0L,874
.................... 							if(NoObj == 10) 
09F5C:  MOV     872,W4
09F5E:  LSR     W4,#8,W4
09F60:  CP.B    W4L,#A
09F62:  BRA     NZ,9F6E
.................... 							{ 
.................... 								Flag_end = 1; 
09F64:  BSET.B  85B.0
.................... 								Ponderation = 10; 
09F66:  MOV     #A,W4
09F68:  MOV     W4,14BE
.................... 							} 
09F6A:  GOTO    9F7E
.................... 							else __LoadObj(NoObj,NoPts);//charge le nouveau pts 
09F6E:  MOV.B   873,W0L
09F70:  MOV.B   W0L,1B3C
09F72:  CLR.B   1B3D
09F74:  MOV.B   874,W0L
09F76:  MOV.B   W0L,1B3E
09F78:  CLR.B   1B3F
09F7A:  CALL    EAE
.................... 	 
.................... 						}while(Ponderation!=10); 
09F7E:  MOV     14BE,W4
09F80:  CP      W4,#A
09F82:  BRA     NZ,9F56
....................  
.................... 					} 
.................... 				} 
09F84:  GOTO    9FAC
.................... 				else 
.................... 				{ 
.................... 					if(Pt_commun==1) NoPts+=2; // skip le pts droite 
09F88:  MOV     14BC,W4
09F8A:  CP      W4,#1
09F8C:  BRA     NZ,9F9A
09F8E:  MOV     874,W4
09F90:  ADD.B   W4L,#2,W4L
09F92:  MOV.B   W4L,W0L
09F94:  MOV.B   W0L,874
09F96:  GOTO    9F9C
.................... 					else NoPts++; // passe au pt suivant suivant																 
09F9A:  INC.B   0874
.................... 					__LoadObj(NoObj,NoPts);//charge le nouveau pts 
09F9C:  MOV.B   873,W0L
09F9E:  MOV.B   W0L,1B3C
09FA0:  CLR.B   1B3D
09FA2:  MOV.B   874,W0L
09FA4:  MOV.B   W0L,1B3E
09FA6:  CLR.B   1B3F
09FA8:  CALL    EAE
.................... 				}	 
.................... 				if(Pt_commun!=0)//si point pas symetrique 
09FAC:  CP0     14BC
09FAE:  BRA     Z,9FBC
.................... 				{ 
.................... 					if(Team)//pt droite 
09FB0:  BTSS.B  85B.4
09FB2:  BRA     9FBC
.................... 					{ 
.................... 						if(Pt_commun==1) NoPts++; // passe  l'obj suivant (pt droite) 
09FB4:  MOV     14BC,W4
09FB6:  CP      W4,#1
09FB8:  BRA     NZ,9FBC
09FBA:  INC.B   0874
.................... 					} 
.................... 				} 
.................... 				 
.................... 				if(!Flag_end) Etat_rob = Init; 
09FBC:  BTSC.B  85B.0
09FBE:  BRA     9FC2
09FC0:  CLR.B   87B
.................... 				break; 
09FC2:  GOTO    A038
....................  
.................... 			case Wait_end: //case wait 
.................... 				if(flag_error) //erreur --> clignotement 7 segments 
09FC6:  BTSS.B  85B.3
09FC8:  BRA     9FDA
.................... 				{ 
.................... 					LED1 = 1; 
09FCA:  BSET.B  2D0.1
.................... 					 
.................... 					delay_ms(200); 
09FCC:  MOV     #C8,W0
09FCE:  CALL    DE2
.................... 					 
.................... 					LED1 = 0; 
09FD2:  BCLR.B  2D0.1
.................... 					 
.................... 					delay_ms(200); 
09FD4:  MOV     #C8,W0
09FD6:  CALL    DE2
.................... 				} 
.................... 				if(flagGameEnd) 
09FDA:  BTSS.B  85A.0
09FDC:  BRA     A030
.................... 				{ 
.................... 					LED1 = 1; 
09FDE:  BSET.B  2D0.1
.................... 					delay_ms(200); 
09FE0:  MOV     #C8,W0
09FE2:  CALL    DE2
.................... 					LED1 = 0; 
09FE6:  BCLR.B  2D0.1
.................... 					LED2 = 1; 
09FE8:  BSET.B  2D0.2
.................... 					delay_ms(200); 
09FEA:  MOV     #C8,W0
09FEC:  CALL    DE2
.................... 					LED2 = 0; 
09FF0:  BCLR.B  2D0.2
.................... 					LED3 = 1; 
09FF2:  BSET.B  2D0.3
.................... 					delay_ms(200); 
09FF4:  MOV     #C8,W0
09FF6:  CALL    DE2
.................... 					LED3 = 0; 
09FFA:  BCLR.B  2D0.3
.................... 					delay_ms(200); 
09FFC:  MOV     #C8,W0
09FFE:  CALL    DE2
.................... 					LED3 = 1; 
0A002:  BSET.B  2D0.3
.................... 					delay_ms(200); 
0A004:  MOV     #C8,W0
0A006:  CALL    DE2
.................... 					LED3 = 0; 
0A00A:  BCLR.B  2D0.3
.................... 					LED2 = 1; 
0A00C:  BSET.B  2D0.2
.................... 					delay_ms(200); 
0A00E:  MOV     #C8,W0
0A010:  CALL    DE2
.................... 					LED2 = 0; 
0A014:  BCLR.B  2D0.2
.................... 					LED1 = 1; 
0A016:  BSET.B  2D0.1
.................... 					delay_ms(200); 
0A018:  MOV     #C8,W0
0A01A:  CALL    DE2
.................... 					LED1 = 0; 
0A01E:  BCLR.B  2D0.1
.................... 					delay_ms(180); 
0A020:  MOV     #B4,W0
0A022:  CALL    DE2
.................... 					 
.................... 					// Desactive tout le reste 
.................... 					disable_interrupts(INTR_GLOBAL); 
0A026:  BCLR.B  81.7
0A028:  MOV     #E0,W4
0A02A:  MOV     W4,42
0A02C:  BSET.B  81.7
.................... 					flagGameEnd=0;			 
0A02E:  BCLR.B  85A.0
.................... 				}				 
.................... 				break;			 
0A030:  GOTO    A038
.................... 			default: 
.................... 			 
.................... 				break; 
0A034:  GOTO    A038
.................... 		} 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
....................  
....................         //////////////////////////////////////////////////////////////////////////////////// 
.................... 		////////////////////////	ACTION PARALLELES	//////////////////////////////////// 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
.................... 		 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        BALISE          ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(flagBaliseCheck && !flag_end && balise_on && !flag_error) 
0A038:  BTSS.B  85A.2
0A03A:  BRA     A1D4
0A03C:  BTSC.B  85B.0
0A03E:  BRA     A1D4
0A040:  BTSS.B  85B.2
0A042:  BRA     A1D4
0A044:  BTSC.B  85B.3
0A046:  BRA     A1D4
....................       	{ 
....................         	Value_bal = Check_balise(); 			//Recuperation de la valeur de la bailse 
0A048:  CALL    8B80
0A04C:  MOV.B   W0L,871
....................         	tempo_bal++; 							//temporisation de la balise, d'une fois detecte, il faut passer 4  tempo bal = 4 pour continuer 
0A04E:  INC.B   0872
.................... 	        if(Value_bal>=MAX_VALUE_DETECT_BALISE) 	//si adversaire trop proche 
0A050:  MOV.B   14C7,W0L
0A052:  MOV     870,W4
0A054:  LSR     W4,#8,W4
0A056:  CP.B    W4L,W0L
0A058:  BRA     NC,A160
.................... 	        {    
.................... 	       		tempo_bal = 0;						//remise a 0 de la tempo 
0A05A:  CLR.B   872
....................            		////__Afficheur_7segments(44); 
.................... 	           	LED1,LED2,LED3 = 1; 
0A05C:  BSET.B  2D0.3
.................... 	           	_Detected = 1;						//indique que l'on a detecte l'adversaire 
0A05E:  BSET.B  85B.1
.................... 	         
.................... 	            /////////////////// Arret du robot /////////////////////////////////////// 
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 9000_^MDEC 2 9000\r");	//rampe de dec. plus raide  
0A060:  MOV     #0,W1
0A062:  MOV     W1,W0
0A064:  CLR.B   1
0A066:  CALL    408
0A06A:  INC     W1,W1
0A06C:  BTSC.B  219.1
0A06E:  BRA     A06C
0A070:  MOV     W0,21A
0A072:  MOV     #19,W0
0A074:  CPSGT   W1,W0
0A076:  BRA     A062
.................... 	            delay_ms(20); 
0A078:  MOV     #14,W0
0A07A:  CALL    DE2
.................... 	            fprintf(ROBOTEQ,"!S 1 0_!S 2 0\r");				//vitesse du robot a 0 --> il va freiner 
0A07E:  MOV     #0,W1
0A080:  MOV     W1,W0
0A082:  CLR.B   1
0A084:  CALL    430
0A088:  INC     W1,W1
0A08A:  BTSC.B  219.1
0A08C:  BRA     A08A
0A08E:  MOV     W0,21A
0A090:  MOV     #D,W0
0A092:  CPSGT   W1,W0
0A094:  BRA     A080
....................  
.................... 	            if(Time_detected==0) // recuperation du temps de la detection 
0A096:  CP0.B   86E
0A098:  BRA     NZ,A0A2
.................... 	            { 
.................... 	               Time_detected = GameTimeS; 
0A09A:  MOV.B   86D,W0L
0A09C:  MOV.B   W0L,86E
.................... 	            } 
0A09E:  GOTO    A15C
.................... 	            else if(((GameTimeS - Time_detected) >= TIME_tempo_dectected))//on attend 6s 
0A0A2:  MOV     86C,W4
0A0A4:  LSR     W4,#8,W4
0A0A6:  MOV     86E,W3
0A0A8:  SUB.B   W4L,W3L,W0L
0A0AA:  MOV     86E,W4
0A0AC:  LSR     W4,#8,W4
0A0AE:  CP.B    W4L,W0L
0A0B0:  BRA     GTU,A15C
.................... 	            {  
.................... 	            	 
.................... 	            	__actual_pos();// actualisation de la Pos xy  
0A0B2:  CALL    8BC0
....................     				 
....................     				/////////////////// effacer l'ordre en cours  ///////////////////  
....................                   	fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
0A0B6:  MOV     #0,W1
0A0B8:  MOV     W1,W0
0A0BA:  CLR.B   1
0A0BC:  CALL    136
0A0C0:  INC     W1,W1
0A0C2:  BTSC.B  219.1
0A0C4:  BRA     A0C2
0A0C6:  MOV     W0,21A
0A0C8:  MOV     #13,W0
0A0CA:  CPSGT   W1,W0
0A0CC:  BRA     A0B8
....................                   	delay_ms(10); 
0A0CE:  MOV     #A,W0
0A0D0:  CALL    DE2
....................                   	fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
0A0D4:  MOV     #0,W1
0A0D6:  MOV     W1,W0
0A0D8:  CLR.B   1
0A0DA:  CALL    158
0A0DE:  INC     W1,W1
0A0E0:  BTSC.B  219.1
0A0E2:  BRA     A0E0
0A0E4:  MOV     W0,21A
0A0E6:  MOV     #13,W0
0A0E8:  CPSGT   W1,W0
0A0EA:  BRA     A0D6
.................... 	                  	 
.................... 					if(checkPath()) 
0A0EC:  CALL    16D8
0A0F0:  CP0     W0
0A0F2:  BRA     Z,A0FC
.................... 					{ 
.................... 						////__Afficheur_7segments(0); 
.................... 						__Stop(); 
0A0F4:  CALL    6334
.................... 					} 
0A0F8:  GOTO    A15C
.................... 					else 
.................... 					{ 
.................... 						 
.................... 	                  	 
.................... 	                  	_Detected = 0; 
0A0FC:  BCLR.B  85B.1
.................... 		                balise_on = 0; 
0A0FE:  BCLR.B  85B.2
.................... 		                Dist_x = 0; 
0A100:  CLR     159C
.................... 		                Dist_y = 0; 
0A102:  CLR     159E
.................... 		                Dorient = 0;  
0A104:  CLR     15A6
0A106:  CLR     15A8
0A108:  CLR     15AA
0A10A:  CLR     15AC
.................... 		                Time_detected=0; 
0A10C:  CLR.B   86E
.................... 		                 
.................... 		                Depl_send = 0; 
0A10E:  BCLR.B  85B.6
.................... 						Action_send = 0; 
0A110:  BCLR.B  C24.0
.................... 						int i; 
.................... 						for(i = 0; i < 10; i++) 
0A112:  CLR     1B36
0A114:  MOV     1B36,W4
0A116:  CP      W4,#A
0A118:  BRA     GE,A154
.................... 						{ 
.................... 							PtsRelai[i][0] = 0; 
0A11A:  MOV     1B36,W4
0A11C:  MUL.UU  W4,#8,W0
0A11E:  MOV     W0,W5
0A120:  MOV     #ABA,W4
0A122:  ADD     W5,W4,W6
0A124:  CLR.B   [W6]
0A126:  MOV.B   #0,W0L
0A128:  MOV.B   W0L,[W6+#1]
0A12A:  MOV.B   #0,W0L
0A12C:  MOV.B   W0L,[W6+#2]
0A12E:  MOV.B   #0,W0L
0A130:  MOV.B   W0L,[W6+#3]
.................... 							PtsRelai[i][1] = 0; 
0A132:  MOV     1B36,W4
0A134:  MUL.UU  W4,#8,W0
0A136:  MOV     W0,W5
0A138:  ADD     W5,#4,W5
0A13A:  MOV     W5,W0
0A13C:  MOV     #ABA,W4
0A13E:  ADD     W0,W4,W5
0A140:  CLR.B   [W5]
0A142:  MOV.B   #0,W0L
0A144:  MOV.B   W0L,[W5+#1]
0A146:  MOV.B   #0,W0L
0A148:  MOV.B   W0L,[W5+#2]
0A14A:  MOV.B   #0,W0L
0A14C:  MOV.B   W0L,[W5+#3]
0A14E:  INC     1B36
0A150:  GOTO    A114
.................... 						} 
.................... 	                  	 
.................... 	                  	path_impossible = 1; 
0A154:  MOV     #1,W4
0A156:  MOV     W4,A9A
.................... 	                  	 
.................... 	                  	Etat_rob = Check_ZI; 
0A158:  MOV.B   #2,W0L
0A15A:  MOV.B   W0L,87B
.................... 	                  	 
.................... 	                  	 
.................... 					} 
....................       
.................... 	            	/* 
.................... 	                if(TabObjectifs[(NoObj+1)][1][8]!=10 && TabObjectifs[(NoObj+1)][1][8]!=0)//si obj suivant pond entre 1 et 9 --> on switch l'obj 
.................... 	                { 
.................... 	                   /////////////////// actualisation position x,y /////////////////// 
.................... 	                  __actual_pos();// actualisation de la Pos xy  
....................  
.................... 	                   /////////////////// effacer l'ordre en cours  ///////////////////  
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
.................... 	                  delay_ms(10); 
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
....................  
.................... 	                   /////////////////// Passage a l'obj suivant  /////////////////// 
.................... 	                  NoObj++; // passage a l'objectif suivant 
.................... 	                  NoPts = 1; // on demarre par le premier pts 
.................... 	                  __LoadObj(NoObj,NoPts);//charge le nouveau pts 
.................... 	                
.................... 	                  if(Pt_commun!=0)//si point pas symetrique 
.................... 	                  { 
.................... 	                  if(Team)//pt droite 
.................... 	                  { 
.................... 	                     if(Pt_commun==1) NoPts++; // passe  l'obj suivant (pt droite) 
.................... 	                  } 
.................... 	                  } 
.................... 	                  Etat_rob = Init; // on recommence le programme 
.................... 	                  _Detected = 0; 
.................... 	                  balise_on = 0; 
.................... 	                  Dist_x = 0; 
.................... 	                  Dist_y = 0; 
.................... 	                  Dorient = 0;  
.................... 	                  _LED2,_LED3,_LED4 = 0; 
.................... 	                  Time_detected=0; 
.................... 	                } 
.................... 	                */ 
....................  
.................... 	            } 
.................... 	        } 
0A15C:  GOTO    A1D0
.................... 	        else if(_Detected && tempo_bal == 4) // si detecte et que l'adv n'est plus la  
0A160:  BTSS.B  85B.1
0A162:  BRA     A1D0
0A164:  MOV     872,W4
0A166:  CP.B    W4L,#4
0A168:  BRA     NZ,A1D0
.................... 	        { 
.................... 	             /////////////////// Reprise de l'ordre  ///////////////////          
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 6000_^MDEC 2 6000\r");//on reprend le dernier ordre    
0A16A:  MOV     #0,W1
0A16C:  MOV     W1,W0
0A16E:  CLR.B   1
0A170:  CALL    44C
0A174:  INC     W1,W1
0A176:  BTSC.B  219.1
0A178:  BRA     A176
0A17A:  MOV     W0,21A
0A17C:  MOV     #19,W0
0A17E:  CPSGT   W1,W0
0A180:  BRA     A16C
.................... 	            fprintf(ROBOTEQ,"!S 1 %u_!S 2 %u\r",oVitMax,oVitMax); 
0A182:  MOV     #0,W1
0A184:  MOV     W1,W0
0A186:  CLR.B   1
0A188:  CALL    474
0A18C:  INC     W1,W1
0A18E:  BTSC.B  219.1
0A190:  BRA     A18E
0A192:  MOV     W0,21A
0A194:  MOV     #4,W0
0A196:  CPSGT   W1,W0
0A198:  BRA     A184
0A19A:  MOV     14B8,W0
0A19C:  MOV     #0,W4
0A19E:  CALL    6888
0A1A2:  MOV     #7,W1
0A1A4:  MOV     W1,W0
0A1A6:  CLR.B   1
0A1A8:  CALL    474
0A1AC:  INC     W1,W1
0A1AE:  BTSC.B  219.1
0A1B0:  BRA     A1AE
0A1B2:  MOV     W0,21A
0A1B4:  MOV     #C,W0
0A1B6:  CPSGT   W1,W0
0A1B8:  BRA     A1A4
0A1BA:  MOV     14B8,W0
0A1BC:  MOV     #0,W4
0A1BE:  CALL    6888
0A1C2:  BTSC.B  219.1
0A1C4:  BRA     A1C2
0A1C6:  MOV     #D,W4
0A1C8:  MOV     W4,21A
....................  
.................... 	            Time_detected = 0;  
0A1CA:  CLR.B   86E
.................... 	            LED1=0; 
0A1CC:  BCLR.B  2D0.1
.................... 	            _Detected = 0; 
0A1CE:  BCLR.B  85B.1
....................              
.................... 	        } 
.................... 	        LED1=!LED1;  
0A1D0:  BTG.B   2D0.1
.................... 	        flagBaliseCheck = 0; 
0A1D2:  BCLR.B  85A.2
.................... 	    }    
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        UART            ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(PCh_flagUARTReadyToDecode) __UART_Decode(TabDecoded); 
0A1D4:  BTSS.B  1604.0
0A1D6:  BRA     A1E0
0A1D8:  MOV     #1708,W4
0A1DA:  MOV     W4,1B3A
0A1DC:  CALL    947E
....................  
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        Fin du prog.    ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if((Flag_end || flagTimeOut || flag_error) && !IsPassedTimeOut) 
0A1E0:  BTSC.B  85B.0
0A1E2:  BRA     A1EC
0A1E4:  BTSC.B  85A.1
0A1E6:  BRA     A1EC
0A1E8:  BTSS.B  85B.3
0A1EA:  BRA     A20E
0A1EC:  BTSC.B  85A.6
0A1EE:  BRA     A20E
.................... 		{ 
.................... 			////__Afficheur_7segments(points); 
....................  
.................... 			IsPassedTimeOut=1; 
0A1F0:  BSET.B  85A.6
.................... 			// arret moteurs 
.................... 			fprintf(ROBOTEQ, "!EX \r");  
0A1F2:  MOV     #0,W1
0A1F4:  MOV     W1,W0
0A1F6:  CLR.B   1
0A1F8:  CALL    492
0A1FC:  INC     W1,W1
0A1FE:  BTSC.B  219.1
0A200:  BRA     A1FE
0A202:  MOV     W0,21A
0A204:  MOV     #4,W0
0A206:  CPSGT   W1,W0
0A208:  BRA     A1F4
.................... 			 
.................... 			Etat_rob = Wait_end; 
0A20A:  MOV.B   #8,W0L
0A20C:  MOV.B   W0L,87B
.................... 		} 
0A20E:  GOTO    9BEC
.................... 		 
.................... 	} 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /** 
.................... * \fn void TIMER1_isr(void) 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 19.10.2015 
.................... * 
.................... * \brief Met  jour la pose, gre le profil trapzodal et le PID 
.................... *		 S'active chaque 1 [ms] 
.................... * 
.................... */ 
.................... #INT_TIMER1 HIGH 
.................... void TIMER1_isr(void) 
*
00AB2:  PUSH    42
00AB4:  PUSH    36
00AB6:  PUSH    32
00AB8:  MOV     W0,[W15++]
00ABA:  MOV     #2,W0
00ABC:  REPEAT  #C
00ABE:  MOV     [W0++],[W15++]
*
0A212:  BRA     A212
.................... { 
.................... 	// Compte le temps rel 
.................... 	RealTimeMS ++; 
*
00AC0:  INC     0860
00AC2:  BTSC.B  42.1
00AC4:  INC     0862
.................... 	// Temps de jeu 
.................... 	if(BeginTimeMS!=0) 
00AC6:  CP0     864
00AC8:  BRA     NZ,ACE
00ACA:  CP0     866
00ACC:  BRA     Z,AFA
.................... 	{ 
.................... 		GameTimeMS=RealTimeMS-BeginTimeMS; 
00ACE:  MOV     860,W4
00AD0:  MOV     864,W3
00AD2:  SUB     W4,W3,W0
00AD4:  MOV     W0,868
00AD6:  MOV     862,W4
00AD8:  MOV     866,W3
00ADA:  SUBB    W4,W3,W0
00ADC:  MOV     W0,86A
.................... 		if(GameTimeMS%1000==0)GameTimeS++; 
00ADE:  BSET.B  43.0
00AE0:  MOV     868,W0
00AE2:  MOV     86A,W1
00AE4:  MOV     #3E8,W2
00AE6:  MOV     #0,W3
00AE8:  CALL    A5E
00AEC:  MOV     W0,W5
00AEE:  MOV     W1,W6
00AF0:  CP0     W5
00AF2:  BRA     NZ,AFA
00AF4:  CP0     W6
00AF6:  BRA     NZ,AFA
00AF8:  INC.B   086D
.................... 	}	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	//////////////////////////////////	TASK GIVER	//////////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Balise  checker 
.................... 	if(GameTimeS == 92) FlagGameEnd = 1;  
00AFA:  MOV     86C,W4
00AFC:  LSR     W4,#8,W4
00AFE:  XOR.B   #5C,W4L
00B00:  BRA     NZ,B04
00B02:  BSET.B  85A.0
.................... 	if(BeginTimeMS!=0 && GameTimeMS%TIME_TO_CHECK_BAL==0) 
00B04:  CP0     864
00B06:  BRA     NZ,B0C
00B08:  CP0     866
00B0A:  BRA     Z,B28
00B0C:  BSET.B  43.0
00B0E:  MOV     868,W0
00B10:  MOV     86A,W1
00B12:  MOV     14CC,W2
00B14:  MOV     #0,W3
00B16:  CALL    A5E
00B1A:  MOV     W0,W5
00B1C:  MOV     W1,W6
00B1E:  CP0     W5
00B20:  BRA     NZ,B28
00B22:  CP0     W6
00B24:  BRA     NZ,B28
.................... 	{ 
.................... 		// Check Balise 
.................... 		flagBaliseCheck=1; 
00B26:  BSET.B  85A.2
.................... 	} 
.................... 	if(BeginTimeMS!=0 && GameTimeMS%500==0)ToDisplay=!ToDisplay; 
00B28:  CP0     864
00B2A:  BRA     NZ,B30
00B2C:  CP0     866
00B2E:  BRA     Z,B4C
00B30:  BSET.B  43.0
00B32:  MOV     868,W0
00B34:  MOV     86A,W1
00B36:  MOV     #1F4,W2
00B38:  MOV     #0,W3
00B3A:  CALL    A5E
00B3E:  MOV     W0,W5
00B40:  MOV     W1,W6
00B42:  CP0     W5
00B44:  BRA     NZ,B4C
00B46:  CP0     W6
00B48:  BRA     NZ,B4C
00B4A:  BTG.B   85A.5
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////	WATCHDOG INTERRUPTS	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// WD Times 
.................... 	static unsigned int16 UART_WD_TIME=0; 
.................... 	 
.................... 	// Watchdog UART, rinitialise la capture 
.................... 	if(PCh_flagUARTWatchdog==1) 
00B4C:  BTSS.B  1604.1
00B4E:  BRA     B6A
.................... 	{ 
.................... 		UART_WD_TIME++; 
00B50:  INC     1B30
.................... 		if(UART_WD_TIME>=UART_WD_DELAY) 
00B52:  MOV.B   C25,W0L
00B54:  CLR.B   1
00B56:  MOV     1B30,W4
00B58:  CP      W4,W0
00B5A:  BRA     NC,B66
.................... 		{ 
.................... 			// Reset UART 
.................... 			ToDoUART = 0; 
00B5C:  CLR.B   1706
.................... 			PosTabToDecode=0; 
00B5E:  CLR.B   1605
.................... 			UARTToSendBack=0; 
00B60:  CLR.B   1707
.................... 			UARTWaitResp=0; 
00B62:  BCLR.B  1604.2
.................... 			// Desactive le watchdog UART 
.................... 			PCh_flagUARTWatchdog = 0; 
00B64:  BCLR.B  1604.1
.................... 		} 
.................... 	} 
00B66:  GOTO    B6C
.................... 	else UART_WD_TIME=0; 
00B6A:  CLR     1B30
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////		PROGRAM END		//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Aprs 1min30, on arrte les lments essentiels 
.................... 	if(BeginTimeMS!=0 && GameTimeS>=98) 
00B6C:  CP0     864
00B6E:  BRA     NZ,B74
00B70:  CP0     866
00B72:  BRA     Z,B80
00B74:  MOV     86C,W4
00B76:  LSR     W4,#8,W4
00B78:  MOV     #62,W3
00B7A:  CP.B    W3L,W4L
00B7C:  BRA     GTU,B80
.................... 	{ 
.................... 		flagTimeOut=1; 
00B7E:  BSET.B  85A.1
.................... 	} 
.................... 	// Aprs la fin de jeu, on ouvre le parasol  
.................... 	if(BeginTimeMS!=0 && GameTimeS>=92) 
00B80:  CP0     864
00B82:  BRA     NZ,B88
00B84:  CP0     866
00B86:  BRA     Z,B92
00B88:  MOV     86C,W4
00B8A:  LSR     W4,#8,W4
00B8C:  MOV     #5C,W3
00B8E:  CP.B    W3L,W4L
00B90:  BRA     GTU,B92
.................... 	{ 
.................... 		//flagGameEnd=1; 
.................... 	}	 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... //// Timer de clignotement d'erreur. //// 
.................... //////////////////////////////////////// 
00B92:  BCLR.B  84.3
00B94:  MOV     #1A,W0
00B96:  REPEAT  #C
00B98:  MOV     [--W15],[W0--]
00B9A:  MOV     [--W15],W0
00B9C:  POP     32
00B9E:  POP     36
00BA0:  POP     42
00BA2:  RETFIE  
.................... #INT_TIMER3 
.................... void TIMER3_isr(void) 
00BA4:  PUSH    42
00BA6:  PUSH    36
00BA8:  PUSH    32
00BAA:  MOV     W0,[W15++]
00BAC:  MOV     #2,W0
00BAE:  REPEAT  #C
00BB0:  MOV     [W0++],[W15++]
.................... { 
.................... 	static int1 On_Off_Error = 0; 
.................... 	 
.................... 	// Si doit afficher une erreur 
.................... 	if(flagError) 
00BB2:  BTSS.B  85A.3
00BB4:  BRA     BB8
.................... 	{ 
.................... 	//	//__Afficheur_7segments(NO_ERROR,On_Off_Error); 
.................... 		On_Off_Error =! On_Off_Error; 
00BB6:  BTG.B   1604.3
.................... 	}	 
00BB8:  BCLR.B  84.7
00BBA:  MOV     #1A,W0
00BBC:  REPEAT  #C
00BBE:  MOV     [--W15],[W0--]
00BC0:  MOV     [--W15],W0
00BC2:  POP     32
00BC4:  POP     36
00BC6:  POP     42
00BC8:  RETFIE  
.................... }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

Configuration Fuses:
   Word  1L: C712   HS2_PLL8
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 8030   NOPUT BORRES NOBROWNOUT MCLR
          H: FF00  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: FF00  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: FF00  
   Word  6L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  7L: 4003   ICSP1 DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
