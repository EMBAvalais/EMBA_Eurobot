CCS PCD C Compiler, Version 5.016, 13176               11-janv.-19 11:25

               Filename:   N:\Années\2019 - Atom Factory\Programmation\Grand Robot\GrandRobot26102018\Code\main.lst

               ROM used:   46762 bytes (48%)
                           Largest free fragment is 32768
               RAM used:   6904 (85%) at main() level
                           7528 (93%) worst case
               Stack size: 2048

*
00000:  GOTO    AC20
*
0001A:  DATA    E2,0A,00
*
00020:  DATA    84,05,00
00022:  DATA    D4,0B,00
*
00026:  DATA    08,09,00
*
00044:  DATA    AA,05,00
.................... /* 
.................... ==================================================================================================                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /*==================================================================================================== 
.................... =											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy				  												== 
.................... ===  Date				: 8.6.2017																	== 
.................... ===  Nom du programme 	: InterfaceRoboteQ.mcp (fichier main.c)										== 
.................... ===  Version 			: V2.0.0.0.0																== 
.................... =====================================================================================================*/ 
....................  
.................... #include <30F6014A.h> 
.................... //////////// Standard Header file for the DSPIC30F6014A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device DSPIC30F6014A 
*
00100:  CLR     32
00102:  MOV     #10C,W3
00104:  ADD     W3,W0,W0
00106:  TBLRDL.B[W0],W0L
00108:  CLR.B   1
0010A:  RETURN  
0010C:  DATA    3F,44,00
0010E:  DATA    52,0D,00
00110:  DATA    00,00,00
00112:  CLR     32
00114:  MOV     #11E,W3
00116:  ADD     W3,W0,W0
00118:  TBLRDL.B[W0],W0L
0011A:  CLR.B   1
0011C:  RETURN  
0011E:  DATA    3F,41,00
00120:  DATA    20,31,00
00122:  DATA    0D,00,00
00124:  CLR     32
00126:  MOV     #130,W3
00128:  ADD     W3,W0,W0
0012A:  TBLRDL.B[W0],W0L
0012C:  CLR.B   1
0012E:  RETURN  
00130:  DATA    3F,41,00
00132:  DATA    20,32,00
00134:  DATA    0D,00,00
00136:  CLR     32
00138:  MOV     #142,W3
0013A:  ADD     W3,W0,W0
0013C:  TBLRDL.B[W0],W0L
0013E:  CLR.B   1
00140:  RETURN  
00142:  DATA    5E,4D,00
00144:  DATA    4D,4F,00
00146:  DATA    44,20,00
00148:  DATA    31,20,00
0014A:  DATA    30,5F,00
0014C:  DATA    5E,4D,00
0014E:  DATA    4D,4F,00
00150:  DATA    44,20,00
00152:  DATA    32,20,00
00154:  DATA    30,0D,00
00156:  DATA    00,00,00
00158:  CLR     32
0015A:  MOV     #164,W3
0015C:  ADD     W3,W0,W0
0015E:  TBLRDL.B[W0],W0L
00160:  CLR.B   1
00162:  RETURN  
00164:  DATA    5E,4D,00
00166:  DATA    4D,4F,00
00168:  DATA    44,20,00
0016A:  DATA    31,20,00
0016C:  DATA    33,5F,00
0016E:  DATA    5E,4D,00
00170:  DATA    4D,4F,00
00172:  DATA    44,20,00
00174:  DATA    32,20,00
00176:  DATA    33,0D,00
00178:  DATA    00,00,00
0017A:  CLR     32
0017C:  MOV     #186,W3
0017E:  ADD     W3,W0,W0
00180:  TBLRDL.B[W0],W0L
00182:  CLR.B   1
00184:  RETURN  
00186:  DATA    21,53,00
00188:  DATA    20,31,00
0018A:  DATA    20,25,00
0018C:  DATA    30,34,00
0018E:  DATA    75,5F,00
00190:  DATA    21,53,00
00192:  DATA    20,32,00
00194:  DATA    20,25,00
00196:  DATA    30,34,00
00198:  DATA    75,20,00
0019A:  DATA    0D,00,00
0019C:  CLR     32
0019E:  MOV     #1A8,W3
001A0:  ADD     W3,W0,W0
001A2:  TBLRDL.B[W0],W0L
001A4:  CLR.B   1
001A6:  RETURN  
001A8:  DATA    21,50,00
001AA:  DATA    52,20,00
001AC:  DATA    31,20,00
001AE:  DATA    25,64,00
001B0:  DATA    5F,21,00
001B2:  DATA    50,52,00
001B4:  DATA    20,32,00
001B6:  DATA    20,25,00
001B8:  DATA    64,20,00
001BA:  DATA    0D,00,00
001BC:  CLR     32
001BE:  MOV     #1C8,W3
001C0:  ADD     W3,W0,W0
001C2:  TBLRDL.B[W0],W0L
001C4:  CLR.B   1
001C6:  RETURN  
001C8:  DATA    21,53,00
001CA:  DATA    20,31,00
001CC:  DATA    20,31,00
001CE:  DATA    30,30,00
001D0:  DATA    5F,21,00
001D2:  DATA    53,20,00
001D4:  DATA    32,20,00
001D6:  DATA    31,30,00
001D8:  DATA    30,0D,00
001DA:  DATA    00,00,00
001DC:  CLR     32
001DE:  MOV     #1E8,W3
001E0:  ADD     W3,W0,W0
001E2:  TBLRDL.B[W0],W0L
001E4:  CLR.B   1
001E6:  RETURN  
001E8:  DATA    21,50,00
001EA:  DATA    52,20,00
001EC:  DATA    31,20,00
001EE:  DATA    31,5F,00
001F0:  DATA    21,50,00
001F2:  DATA    52,20,00
001F4:  DATA    32,20,00
001F6:  DATA    31,0D,00
001F8:  DATA    00,00,00
001FA:  CLR     32
001FC:  MOV     #206,W3
001FE:  ADD     W3,W0,W0
00200:  TBLRDL.B[W0],W0L
00202:  CLR.B   1
00204:  RETURN  
00206:  DATA    21,50,00
00208:  DATA    52,20,00
0020A:  DATA    31,20,00
0020C:  DATA    25,30,00
0020E:  DATA    37,64,00
00210:  DATA    5F,21,00
00212:  DATA    50,52,00
00214:  DATA    20,32,00
00216:  DATA    20,25,00
00218:  DATA    30,37,00
0021A:  DATA    64,20,00
0021C:  DATA    0D,00,00
0021E:  CLR     32
00220:  MOV     #22A,W3
00222:  ADD     W3,W0,W0
00224:  TBLRDL.B[W0],W0L
00226:  CLR.B   1
00228:  RETURN  
0022A:  DATA    21,4D,00
0022C:  DATA    53,20,00
0022E:  DATA    31,0D,00
00230:  DATA    00,00,00
00232:  CLR     32
00234:  MOV     #23E,W3
00236:  ADD     W3,W0,W0
00238:  TBLRDL.B[W0],W0L
0023A:  CLR.B   1
0023C:  RETURN  
0023E:  DATA    21,4D,00
00240:  DATA    53,20,00
00242:  DATA    32,0D,00
00244:  DATA    00,00,00
00246:  CLR     32
00248:  MOV     #252,W3
0024A:  ADD     W3,W0,W0
0024C:  TBLRDL.B[W0],W0L
0024E:  CLR.B   1
00250:  RETURN  
00252:  DATA    52,45,00
00254:  DATA    53,45,00
00256:  DATA    54,20,00
00258:  DATA    33,32,00
0025A:  DATA    31,36,00
0025C:  DATA    35,34,00
0025E:  DATA    39,38,00
00260:  DATA    37,20,00
00262:  DATA    0D,00,00
00264:  CLR     32
00266:  MOV     #270,W3
00268:  ADD     W3,W0,W0
0026A:  TBLRDL.B[W0],W0L
0026C:  CLR.B   1
0026E:  RETURN  
00270:  DATA    7E,4B,00
00272:  DATA    50,20,00
00274:  DATA    31,20,00
00276:  DATA    0D,00,00
00278:  CLR     32
0027A:  MOV     #284,W3
0027C:  ADD     W3,W0,W0
0027E:  TBLRDL.B[W0],W0L
00280:  CLR.B   1
00282:  RETURN  
00284:  DATA    7E,4B,00
00286:  DATA    49,20,00
00288:  DATA    31,20,00
0028A:  DATA    0D,00,00
0028C:  CLR     32
0028E:  MOV     #298,W3
00290:  ADD     W3,W0,W0
00292:  TBLRDL.B[W0],W0L
00294:  CLR.B   1
00296:  RETURN  
00298:  DATA    7E,4B,00
0029A:  DATA    44,20,00
0029C:  DATA    31,20,00
0029E:  DATA    0D,00,00
002A0:  CLR     32
002A2:  MOV     #2AC,W3
002A4:  ADD     W3,W0,W0
002A6:  TBLRDL.B[W0],W0L
002A8:  CLR.B   1
002AA:  RETURN  
002AC:  DATA    7E,4B,00
002AE:  DATA    50,20,00
002B0:  DATA    32,20,00
002B2:  DATA    0D,00,00
002B4:  CLR     32
002B6:  MOV     #2C0,W3
002B8:  ADD     W3,W0,W0
002BA:  TBLRDL.B[W0],W0L
002BC:  CLR.B   1
002BE:  RETURN  
002C0:  DATA    7E,4B,00
002C2:  DATA    49,20,00
002C4:  DATA    32,20,00
002C6:  DATA    0D,00,00
002C8:  CLR     32
002CA:  MOV     #2D4,W3
002CC:  ADD     W3,W0,W0
002CE:  TBLRDL.B[W0],W0L
002D0:  CLR.B   1
002D2:  RETURN  
002D4:  DATA    7E,4B,00
002D6:  DATA    44,20,00
002D8:  DATA    32,20,00
002DA:  DATA    0D,00,00
002DC:  CLR     32
002DE:  MOV     #2E8,W3
002E0:  ADD     W3,W0,W0
002E2:  TBLRDL.B[W0],W0L
002E4:  CLR.B   1
002E6:  RETURN  
002E8:  DATA    7E,4D,00
002EA:  DATA    41,43,00
002EC:  DATA    20,31,00
002EE:  DATA    20,0D,00
002F0:  DATA    00,00,00
002F2:  CLR     32
002F4:  MOV     #2FE,W3
002F6:  ADD     W3,W0,W0
002F8:  TBLRDL.B[W0],W0L
002FA:  CLR.B   1
002FC:  RETURN  
002FE:  DATA    7E,4D,00
00300:  DATA    44,45,00
00302:  DATA    43,20,00
00304:  DATA    31,20,00
00306:  DATA    0D,00,00
00308:  CLR     32
0030A:  MOV     #314,W3
0030C:  ADD     W3,W0,W0
0030E:  TBLRDL.B[W0],W0L
00310:  CLR.B   1
00312:  RETURN  
00314:  DATA    7E,4D,00
00316:  DATA    41,43,00
00318:  DATA    20,32,00
0031A:  DATA    20,0D,00
0031C:  DATA    00,00,00
0031E:  CLR     32
00320:  MOV     #32A,W3
00322:  ADD     W3,W0,W0
00324:  TBLRDL.B[W0],W0L
00326:  CLR.B   1
00328:  RETURN  
0032A:  DATA    7E,4D,00
0032C:  DATA    44,45,00
0032E:  DATA    43,20,00
00330:  DATA    32,20,00
00332:  DATA    0D,00,00
00334:  CLR     32
00336:  MOV     #26,W3
00338:  SUB     W0,W3,W3
0033A:  BRA     C,346
0033C:  MOV     #350,W3
0033E:  ADD     W3,W0,W0
00340:  TBLRDL.B[W0],W0L
00342:  CLR.B   1
00344:  RETURN  
00346:  MOV     #350,W0
00348:  ADD     W3,W3,W3
0034A:  ADD     W3,W0,W3
0034C:  TBLRDH  [W3],W0
0034E:  RETURN  
00350:  DATA    5E,4B,49
00352:  DATA    50,20,20
00354:  DATA    31,20,32
00356:  DATA    25,75,20
00358:  DATA    5F,5E,25
0035A:  DATA    4B,49,75
0035C:  DATA    20,31,5F
0035E:  DATA    20,25,5E
00360:  DATA    75,5F,4B
00362:  DATA    5E,4B,44
00364:  DATA    44,20,20
00366:  DATA    31,20,32
00368:  DATA    25,75,20
0036A:  DATA    5F,5E,25
0036C:  DATA    4B,50,75
0036E:  DATA    20,32,20
00370:  DATA    20,25,0D
00372:  DATA    75,5F,00
00374:  DATA    5E,4B,00
00376:  CLR     32
00378:  MOV     #1E,W3
0037A:  SUB     W0,W3,W3
0037C:  BRA     C,388
0037E:  MOV     #392,W3
00380:  ADD     W3,W0,W0
00382:  TBLRDL.B[W0],W0L
00384:  CLR.B   1
00386:  RETURN  
00388:  MOV     #392,W0
0038A:  ADD     W3,W3,W3
0038C:  ADD     W3,W0,W3
0038E:  TBLRDH  [W3],W0
00390:  RETURN  
00392:  DATA    5E,4D,5F
00394:  DATA    41,43,5E
00396:  DATA    20,31,4D
00398:  DATA    20,25,44
0039A:  DATA    75,5F,45
0039C:  DATA    5E,4D,43
0039E:  DATA    44,45,20
003A0:  DATA    43,20,32
003A2:  DATA    31,20,20
003A4:  DATA    25,75,25
003A6:  DATA    5F,5E,75
003A8:  DATA    4D,41,20
003AA:  DATA    43,20,0D
003AC:  DATA    32,20,00
003AE:  DATA    25,75,00
003B0:  CLR     32
003B2:  MOV     #3BC,W3
003B4:  ADD     W3,W0,W0
003B6:  TBLRDL.B[W0],W0L
003B8:  CLR.B   1
003BA:  RETURN  
003BC:  DATA    45,45,00
003BE:  DATA    53,41,00
003C0:  DATA    56,20,00
003C2:  DATA    0D,00,00
003C4:  CLR     32
003C6:  MOV     #3D0,W3
003C8:  ADD     W3,W0,W0
003CA:  TBLRDL.B[W0],W0L
003CC:  CLR.B   1
003CE:  RETURN  
003D0:  DATA    21,53,00
003D2:  DATA    20,31,00
003D4:  DATA    20,25,00
003D6:  DATA    30,37,00
003D8:  DATA    64,5F,00
003DA:  DATA    21,53,00
003DC:  DATA    20,32,00
003DE:  DATA    20,25,00
003E0:  DATA    30,37,00
003E2:  DATA    64,20,00
003E4:  DATA    0D,00,00
003E6:  CLR     32
003E8:  MOV     #3F2,W3
003EA:  ADD     W3,W0,W0
003EC:  TBLRDL.B[W0],W0L
003EE:  CLR.B   1
003F0:  RETURN  
003F2:  DATA    43,61,00
003F4:  DATA    72,74,00
003F6:  DATA    65,20,00
003F8:  DATA    50,72,00
003FA:  DATA    69,6E,00
003FC:  DATA    63,69,00
003FE:  DATA    70,61,00
00400:  DATA    6C,65,00
00402:  DATA    20,3A,00
00404:  DATA    20,43,00
00406:  DATA    6F,6D,00
00408:  DATA    6D,61,00
0040A:  DATA    6E,64,00
0040C:  DATA    65,20,00
0040E:  DATA    49,6E,00
00410:  DATA    63,6F,00
00412:  DATA    6E,6E,00
00414:  DATA    75,65,00
00416:  DATA    0D,00,00
00418:  CLR     32
0041A:  MOV     #424,W3
0041C:  ADD     W3,W0,W0
0041E:  TBLRDL.B[W0],W0L
00420:  CLR.B   1
00422:  RETURN  
00424:  DATA    21,4D,00
00426:  DATA    47,0D,00
00428:  DATA    00,00,00
0042A:  CLR     32
0042C:  MOV     #436,W3
0042E:  ADD     W3,W0,W0
00430:  TBLRDL.B[W0],W0L
00432:  CLR.B   1
00434:  RETURN  
00436:  DATA    5E,4D,00
00438:  DATA    44,45,00
0043A:  DATA    43,20,00
0043C:  DATA    31,20,00
0043E:  DATA    39,30,00
00440:  DATA    30,30,00
00442:  DATA    5F,5E,00
00444:  DATA    4D,44,00
00446:  DATA    45,43,00
00448:  DATA    20,32,00
0044A:  DATA    20,39,00
0044C:  DATA    30,30,00
0044E:  DATA    30,0D,00
00450:  DATA    00,00,00
00452:  CLR     32
00454:  MOV     #45E,W3
00456:  ADD     W3,W0,W0
00458:  TBLRDL.B[W0],W0L
0045A:  CLR.B   1
0045C:  RETURN  
0045E:  DATA    21,53,00
00460:  DATA    20,31,00
00462:  DATA    20,30,00
00464:  DATA    5F,21,00
00466:  DATA    53,20,00
00468:  DATA    32,20,00
0046A:  DATA    30,0D,00
0046C:  DATA    00,00,00
0046E:  CLR     32
00470:  MOV     #47A,W3
00472:  ADD     W3,W0,W0
00474:  TBLRDL.B[W0],W0L
00476:  CLR.B   1
00478:  RETURN  
0047A:  DATA    5E,4D,00
0047C:  DATA    44,45,00
0047E:  DATA    43,20,00
00480:  DATA    31,20,00
00482:  DATA    36,30,00
00484:  DATA    30,30,00
00486:  DATA    5F,5E,00
00488:  DATA    4D,44,00
0048A:  DATA    45,43,00
0048C:  DATA    20,32,00
0048E:  DATA    20,36,00
00490:  DATA    30,30,00
00492:  DATA    30,0D,00
00494:  DATA    00,00,00
00496:  CLR     32
00498:  MOV     #4A2,W3
0049A:  ADD     W3,W0,W0
0049C:  TBLRDL.B[W0],W0L
0049E:  CLR.B   1
004A0:  RETURN  
004A2:  DATA    21,53,00
004A4:  DATA    20,31,00
004A6:  DATA    20,25,00
004A8:  DATA    75,5F,00
004AA:  DATA    21,53,00
004AC:  DATA    20,32,00
004AE:  DATA    20,25,00
004B0:  DATA    75,0D,00
004B2:  DATA    00,00,00
004B4:  CLR     32
004B6:  MOV     #4C0,W3
004B8:  ADD     W3,W0,W0
004BA:  TBLRDL.B[W0],W0L
004BC:  CLR.B   1
004BE:  RETURN  
004C0:  DATA    21,45,00
004C2:  DATA    58,20,00
004C4:  DATA    0D,00,00
*
00654:  MOV     W5,[W15++]
00656:  MOV     #C,W5
00658:  REPEAT  #3
0065A:  MOV     [W5++],[W15++]
0065C:  MUL.UU  W0,W2,W4
0065E:  BTSS    W3.F
00660:  BRA     666
00662:  MUL.SS  W0,W3,W6
00664:  BRA     668
00666:  MUL.UU  W0,W3,W6
00668:  BCLR.B  42.0
0066A:  ADD     W6,W5,W5
0066C:  ADDC    W7,#0,W8
0066E:  BTSS    W1.F
00670:  BRA     676
00672:  MUL.SS  W1,W2,W6
00674:  BRA     678
00676:  MUL.UU  W1,W2,W6
00678:  ADDC    W6,W5,W5
0067A:  ADDC    W7,W8,W8
0067C:  ADDC    #0,W9
0067E:  MUL.SS  W1,W3,W6
00680:  ADDC    W6,W8,W8
00682:  ADDC    W9,W7,W7
00684:  MOV     W7,W3
00686:  MOV     W8,W2
00688:  MOV     W5,W1
0068A:  MOV     W4,W0
0068C:  MOV     #12,W5
0068E:  REPEAT  #3
00690:  MOV     [--W15],[W5--]
00692:  MOV     [--W15],W5
00694:  RETURN  
*
00A8E:  MOV     W5,[W15++]
00A90:  MOV     #C,W5
00A92:  REPEAT  #3
00A94:  MOV     [W5++],[W15++]
00A96:  MOV     #0,W9
00A98:  BTSC.B  43.0
00A9A:  MOV     #1,W9
00A9C:  MOV     W9,[W15++]
00A9E:  CLR     W4
00AA0:  CLR     W5
00AA2:  CLR     W6
00AA4:  CLR     W7
00AA6:  XOR     W2,W3,W8
00AA8:  BRA     Z,ACC
00AAA:  MOV     #20,W8
00AAC:  BCLR.B  42.0
00AAE:  RLC     W0,W0
00AB0:  RLC     W1,W1
00AB2:  RLC     W4,W4
00AB4:  RLC     W5,W5
00AB6:  CP      W5,W3
00AB8:  BRA     NZ,ABC
00ABA:  CPB     W4,W2
00ABC:  BRA     NC,AC4
00ABE:  SUB     W4,W2,W4
00AC0:  SUBB    W5,W3,W5
00AC2:  BSET.B  42.0
00AC4:  RLC     W6,W6
00AC6:  RLC     W7,W7
00AC8:  DEC     W8,W8
00ACA:  BRA     NZ,AAC
00ACC:  MOV     W7,W1
00ACE:  MOV     W6,W0
00AD0:  MOV     [--W15],W9
00AD2:  CP0     W9
00AD4:  BRA     Z,AD8
00AD6:  MOV.D   W4,W0
00AD8:  MOV     #12,W5
00ADA:  REPEAT  #3
00ADC:  MOV     [--W15],[W5--]
00ADE:  MOV     [--W15],W5
00AE0:  RETURN  
*
00BFA:  MOV     W8,[W15++]
00BFC:  MOV     #12,W8
00BFE:  REPEAT  #4
00C00:  MOV     [W8++],[W15++]
00C02:  CLR     W11
00C04:  MUL.UU  W12,#0,W12
00C06:  MOV     W3,W8
00C08:  MOV     W7,W9
00C0A:  MOV     #7FF,W10
00C0C:  BCLR.B  42.0
00C0E:  BCLR.B  42.1
00C10:  ASR     W8,#4,W8
00C12:  AND     W10,W8,W8
00C14:  CP0     W8
00C16:  BRA     Z,CFA
00C18:  BCLR.B  42.0
00C1A:  BCLR.B  42.1
00C1C:  ASR     W9,#4,W9
00C1E:  AND     W10,W9,W9
00C20:  CP0     W9
00C22:  BRA     Z,CFA
00C24:  ADD     W9,W8,W8
00C26:  BTSC    W9.B
00C28:  BRA     C32
00C2A:  SUB     #3FF,W8
00C2C:  BRA     Z,CFA
00C2E:  BRA     NC,CFA
00C30:  BRA     C38
00C32:  MOV     #401,W10
00C34:  ADD.B   W10L,W5L,W5L
00C36:  BRA     C,CFA
00C38:  XOR     W3,W7,W13
00C3A:  BCLR.B  42.0
00C3C:  BCLR.B  42.1
00C3E:  AND     #F,W3
00C40:  BSET    W3.4
00C42:  AND     #F,W7
00C44:  BSET    W7.4
00C46:  MOV     W8,[W15++]
00C48:  MUL.UU  W4,W1,W8
00C4A:  MUL.UU  W5,W0,W10
00C4C:  ADD     W8,W10,W10
00C4E:  ADDC    W9,W11,W11
00C50:  ADDC    #0,W12
00C52:  MUL.UU  W4,W2,W8
00C54:  ADD     W8,W11,W11
00C56:  ADDC    W9,W12,W12
00C58:  MUL.UU  W5,W1,W8
00C5A:  CLR     W10
00C5C:  ADD     W8,W11,W11
00C5E:  ADDC    W9,W12,W12
00C60:  ADDC    #0,W10
00C62:  MUL.UU  W6,W0,W8
00C64:  ADD     W8,W11,W11
00C66:  ADDC    W9,W12,W12
00C68:  ADDC    #0,W10
00C6A:  CLR     W11
00C6C:  MUL.UU  W4,W3,W8
00C6E:  ADD     W8,W12,W12
00C70:  ADDC    W9,W10,W10
00C72:  ADDC    #0,W11
00C74:  MUL.UU  W5,W2,W8
00C76:  ADD     W8,W12,W12
00C78:  ADDC    W9,W10,W10
00C7A:  ADDC    #0,W11
00C7C:  MUL.UU  W6,W1,W8
00C7E:  ADD     W8,W12,W12
00C80:  ADDC    W9,W10,W10
00C82:  ADDC    #0,W11
00C84:  MUL.UU  W7,W0,W8
00C86:  ADD     W8,W12,W12
00C88:  ADDC    W9,W10,W10
00C8A:  ADDC    #0,W11
00C8C:  MOV     W12,W0
00C8E:  CLR     W12
00C90:  MUL.UU  W5,W3,W8
00C92:  ADD     W8,W10,W10
00C94:  ADDC    W9,W11,W11
00C96:  ADDC    #0,W12
00C98:  MUL.UU  W6,W2,W8
00C9A:  ADD     W8,W10,W10
00C9C:  ADDC    W9,W11,W11
00C9E:  ADDC    #0,W12
00CA0:  MUL.UU  W6,W3,W8
00CA2:  ADD     W8,W11,W11
00CA4:  ADDC    W9,W12,W12
00CA6:  MUL.UU  W7,W1,W8
00CA8:  ADD     W8,W10,W10
00CAA:  ADDC    W9,W11,W11
00CAC:  ADDC    #0,W12
00CAE:  MUL.UU  W7,W2,W8
00CB0:  ADD     W8,W11,W11
00CB2:  ADDC    W9,W12,W12
00CB4:  MUL.UU  W7,W3,W8
00CB6:  ADD     W8,W12,W12
00CB8:  MOV     W10,W1
00CBA:  MOV     W11,W2
00CBC:  MOV     W12,W3
00CBE:  MOV     #5,W4
00CC0:  BCLR.B  42.0
00CC2:  RRC     W3,W3
00CC4:  RRC     W2,W2
00CC6:  RRC     W1,W1
00CC8:  RRC     W0,W0
00CCA:  DEC     W4,W4
00CCC:  BRA     NZ,CC0
00CCE:  MOV     [--W15],W8
00CD0:  INC     W8,W8
00CD2:  IOR      W0,  W1,W6
00CD4:  BRA     Z,CD8
00CD6:  BRA     CDC
00CD8:  IOR      W2,  W3,W6
00CDA:  BRA     Z,CEC
00CDC:  BTSC    W3.4
00CDE:  BRA     CEC
00CE0:  BCLR.B  42.0
00CE2:  RLC     W0,W0
00CE4:  RLC     W1,W1
00CE6:  RLC     W2,W2
00CE8:  RLC     W3,W3
00CEA:  DEC     W8,W8
00CEC:  SL      W8,#4,W8
00CEE:  BCLR    W3.F
00CF0:  BTSC    W13.F
00CF2:  BSET    W3.F
00CF4:  BCLR    W3.4
00CF6:  XOR     W8,W3,W3
00CF8:  BRA     D00
00CFA:  MUL.UU  W0,#0,W0
00CFC:  MUL.UU  W0,#0,W2
00CFE:  BRA     D00
00D00:  MOV     #1A,W8
00D02:  REPEAT  #4
00D04:  MOV     [--W15],[W8--]
00D06:  MOV     [--W15],W8
00D08:  RETURN  
00D0A:  MOV     W8,[W15++]
00D0C:  MOV     #12,W8
00D0E:  REPEAT  #4
00D10:  MOV     [W8++],[W15++]
00D12:  XOR     W3,W7,W13
00D14:  MOV     W3,W8
00D16:  MOV     W7,W9
00D18:  MOV     #7FF,W10
00D1A:  BCLR.B  42.0
00D1C:  BCLR.B  42.1
00D1E:  ASR     W8,#4,W8
00D20:  AND     W10,W8,W8
00D22:  CP0     W8
00D24:  BRA     Z,DFE
00D26:  BCLR.B  42.0
00D28:  BCLR.B  42.1
00D2A:  ASR     W9,#4,W9
00D2C:  AND     W10,W9,W9
00D2E:  CP0     W9
00D30:  BRA     Z,DFE
00D32:  CLR     W10
00D34:  SUB     W8,W9,W12
00D36:  BRA     NC,D3E
00D38:  ADD     #3FF,W12
00D3A:  BRA     C,DFE
00D3C:  BRA     D46
00D3E:  MOV     #401,W11
00D40:  SUB     W12,W11,W12
00D42:  BRA     NC,DFE
00D44:  BRA     Z,DFE
00D46:  CLR     W8
00D48:  CLR     W9
00D4A:  CLR     W10
00D4C:  CLR     W11
00D4E:  AND     #1F,W3
00D50:  BSET    W3.4
00D52:  AND     #1F,W7
00D54:  BSET    W7.4
00D56:  MOV     W12,[W15++]
00D58:  MOV     #36,W12
00D5A:  SUB     W0,W4,W0
00D5C:  SUBB    W1,W5,W1
00D5E:  SUBB    W2,W6,W2
00D60:  SUBB    W3,W7,W3
00D62:  BRA     N,D68
00D64:  BRA     C,D72
00D66:  BRA     NZ,D74
00D68:  ADD     W0,W4,W0
00D6A:  ADDC    W1,W5,W1
00D6C:  ADDC    W2,W6,W2
00D6E:  ADDC    W3,W7,W3
00D70:  BRA     D74
00D72:  BSET    W8.0
00D74:  DEC     W12,W12
00D76:  BRA     Z,D8E
00D78:  BCLR.B  42.0
00D7A:  RLC     W0,W0
00D7C:  RLC     W1,W1
00D7E:  RLC     W2,W2
00D80:  RLC     W3,W3
00D82:  BCLR.B  42.0
00D84:  RLC     W8,W8
00D86:  RLC     W9,W9
00D88:  RLC     W10,W10
00D8A:  RLC     W11,W11
00D8C:  BRA     D5A
00D8E:  MOV     [--W15],W12
00D90:  BTSC    W11.5
00D92:  BRA     D96
00D94:  BRA     DA2
00D96:  BCLR.B  42.0
00D98:  RRC     W11,W11
00D9A:  RRC     W10,W10
00D9C:  RRC     W9,W9
00D9E:  RRC     W8,W8
00DA0:  BRA     DA8
00DA2:  DEC     W12,W12
00DA4:  BCLR.B  42.0
00DA6:  BRA     Z,DFE
00DA8:  BTSC.B  42.0
00DAA:  BRA     DBE
00DAC:  RLC     W0,W0
00DAE:  RLC     W1,W1
00DB0:  RLC     W2,W2
00DB2:  RLC     W3,W3
00DB4:  SUB     W0,W4,W4
00DB6:  SUBB    W1,W5,W5
00DB8:  SUBB    W2,W6,W6
00DBA:  SUBB    W3,W7,W7
00DBC:  BRA     NC,DE8
00DBE:  INC     W8,W8
00DC0:  BRA     NZ,DE8
00DC2:  INC     W9,W9
00DC4:  BRA     NZ,DE8
00DC6:  INC     W10,W10
00DC8:  BRA     NZ,DE8
00DCA:  INC     W11,W11
00DCC:  BRA     NZ,DE8
00DCE:  INC     W12,W12
00DD0:  BRA     Z,DFE
00DD2:  BRA     DE8
00DD4:  DEC     W12,W12
00DD6:  BRA     Z,DFE
00DD8:  BTSC    W11.4
00DDA:  BRA     DE8
00DDC:  BCLR.B  42.0
00DDE:  RLC     W8,W8
00DE0:  RLC     W9,W9
00DE2:  RLC     W10,W10
00DE4:  RLC     W11,W11
00DE6:  BRA     DD8
00DE8:  SL      W12,#4,W12
00DEA:  BCLR.B  42.0
00DEC:  BCLR    W12.F
00DEE:  BTSC    W13.F
00DF0:  BSET    W12.F
00DF2:  BCLR    W11.4
00DF4:  XOR     W12,W11,W3
00DF6:  MOV     W10,W2
00DF8:  MOV     W9,W1
00DFA:  MOV     W8,W0
00DFC:  BRA     E08
00DFE:  MOV     #0,W0
00E00:  MOV     #0,W1
00E02:  MOV     #0,W2
00E04:  MOV     #0,W3
00E06:  BRA     E08
00E08:  MOV     #1A,W8
00E0A:  REPEAT  #4
00E0C:  MOV     [--W15],[W8--]
00E0E:  MOV     [--W15],W8
00E10:  RETURN  
*
01A5C:  MOV     #F000,W1
01A5E:  ADD     W1,W3,W3
01A60:  MOV     #7F,W1
01A62:  ADDC    W1,#0,W1
01A64:  MOV     W1,32
01A66:  BCLR    W5.0
01A68:  CP0     W5
01A6A:  BRA     Z,1A72
01A6C:  TBLRDL  [W3++],[W4++]
01A6E:  DEC2    W5,W5
01A70:  BRA     NZ,1A6A
01A72:  RETURN  
*
01D68:  MOV     W5,[W15++]
01D6A:  MOV     #C,W5
01D6C:  REPEAT  #3
01D6E:  MOV     [W5++],[W15++]
01D70:  MOV     W0,W4
01D72:  MOV     W1,W5
01D74:  MOV     W2,W6
01D76:  MOV     W3,W7
01D78:  CLR     W0
01D7A:  CLR     W1
01D7C:  CLR     W2
01D7E:  CLR     W3
01D80:  BCLR    W8.0
01D82:  BTSS    W7.F
01D84:  BRA     1D90
01D86:  BSET    W8.0
01D88:  NEG     W4,W4
01D8A:  COM     W5,W5
01D8C:  COM     W6,W6
01D8E:  COM     W7,W7
01D90:  IOR      W4,  W5,W9
01D92:  BRA     NZ,1D98
01D94:  IOR      W6,  W7,W9
01D96:  BRA     Z,1DC2
01D98:  MOV     #473,W9
01D9A:  BTSC    W3.4
01D9C:  BRA     1DB4
01D9E:  BCLR.B  42.0
01DA0:  RLC     W4,W4
01DA2:  RLC     W5,W5
01DA4:  RLC     W6,W6
01DA6:  RLC     W7,W7
01DA8:  RLC     W0,W0
01DAA:  RLC     W1,W1
01DAC:  RLC     W2,W2
01DAE:  RLC     W3,W3
01DB0:  DEC     W9,W9
01DB2:  BRA     NZ,1D9A
01DB4:  SL      W9,#4,W9
01DB6:  BCLR.B  42.0
01DB8:  BCLR    W9.F
01DBA:  BCLR    W3.4
01DBC:  XOR     W9,W3,W3
01DBE:  BTSC    W8.0
01DC0:  BSET    W3.F
01DC2:  MOV     #12,W5
01DC4:  REPEAT  #3
01DC6:  MOV     [--W15],[W5--]
01DC8:  MOV     [--W15],W5
01DCA:  RETURN  
*
01E76:  MOV     W5,[W15++]
01E78:  MOV     #C,W5
01E7A:  REPEAT  #3
01E7C:  MOV     [W5++],[W15++]
01E7E:  MOV     #0,W9
01E80:  BTSC.B  43.0
01E82:  MOV     #1,W9
01E84:  MOV     W9,[W15++]
01E86:  XOR     W1,W3,W9
01E88:  BTSS    W1.F
01E8A:  BRA     1E92
01E8C:  COM     W1,W1
01E8E:  NEG     W0,W0
01E90:  ADDC    W1,#0,W1
01E92:  BTSS    W3.F
01E94:  BRA     1E9C
01E96:  COM     W3,W3
01E98:  NEG     W2,W2
01E9A:  ADDC    W3,#0,W3
01E9C:  XOR     W2,W3,W4
01E9E:  BRA     Z,1ECA
01EA0:  CLR     W4
01EA2:  CLR     W5
01EA4:  CLR     W6
01EA6:  CLR     W7
01EA8:  MOV     #20,W8
01EAA:  BCLR.B  42.0
01EAC:  RLC     W0,W0
01EAE:  RLC     W1,W1
01EB0:  RLC     W4,W4
01EB2:  RLC     W5,W5
01EB4:  CP      W5,W3
01EB6:  BRA     NZ,1EBA
01EB8:  CPB     W4,W2
01EBA:  BRA     NC,1EC2
01EBC:  SUB     W4,W2,W4
01EBE:  SUBB    W5,W3,W5
01EC0:  BSET.B  42.0
01EC2:  RLC     W6,W6
01EC4:  RLC     W7,W7
01EC6:  DEC     W8,W8
01EC8:  BRA     NZ,1EAA
01ECA:  BTSS    W9.F
01ECC:  BRA     1EDC
01ECE:  NEG     W6,W0
01ED0:  BRA     Z,1ED4
01ED2:  BRA     NZ,1ED8
01ED4:  NEG     W7,W1
01ED6:  BRA     1EE2
01ED8:  COM     W7,W1
01EDA:  BRA     1EE2
01EDC:  MOV     W7,W1
01EDE:  MOV     W6,W0
01EE0:  BRA     1EE2
01EE2:  MOV     [--W15],W9
01EE4:  CP0     W9
01EE6:  BRA     Z,1EEA
01EE8:  MOV.D   W4,W0
01EEA:  MOV     #12,W5
01EEC:  REPEAT  #3
01EEE:  MOV     [--W15],[W5--]
01EF0:  MOV     [--W15],W5
01EF2:  RETURN  
*
021A0:  MOV     W5,[W15++]
021A2:  MOV     W6,[W15++]
021A4:  MOV     #8E,W1
021A6:  BCLR    W6.0
021A8:  BTSS    W0.F
021AA:  BRA     21B2
021AC:  BSET    W6.0
021AE:  NEG     W0,W0
021B0:  BRA     21B2
021B2:  CP0     W0
021B4:  BRA     Z,21DE
021B6:  BTSC    W0.F
021B8:  BRA     21C2
021BA:  BCLR.B  42.0
021BC:  RLC     W0,W0
021BE:  DEC     W1,W1
021C0:  BRA     21B6
021C2:  SWAP    W1
021C4:  BCLR.B  42.0
021C6:  RRC     W1,W1
021C8:  BCLR    W0.F
021CA:  SWAP    W0
021CC:  XOR.B   W0L,W1L,W1L
021CE:  AND.B   #0,W0L
021D0:  BTSC    W6.0
021D2:  BSET    W1.F
021D4:  BRA     21E4
021D6:  MOV.B   W1L,W0L
021D8:  BSET    W1.7
021DA:  AND.B   #0,W1L
021DC:  BRA     21E4
021DE:  CLR     W0
021E0:  CLR     W1
021E2:  BRA     21E4
021E4:  MOV     [--W15],W6
021E6:  MOV     [--W15],W5
021E8:  RETURN  
021EA:  MOV     W5,[W15++]
021EC:  MOV     W6,[W15++]
021EE:  MOV     W7,[W15++]
021F0:  XOR     W1,W3,W4
021F2:  BTSS    W4.F
021F4:  BRA     2202
021F6:  BCLR.B  42.0
021F8:  BCLR.B  42.1
021FA:  BTSS    W1.F
021FC:  BRA     224A
021FE:  BSET.B  42.0
02200:  BRA     224A
02202:  MOV     W1,W4
02204:  MOV     W0,W5
02206:  MOV     W3,W6
02208:  MOV     W2,W7
0220A:  RLC     W1,W1
0220C:  SWAP    W1
0220E:  RLC     W3,W3
02210:  SWAP    W3
02212:  SUB.B   W3L,W1L,W1L
02214:  BRA     Z,2220
02216:  BTSS    W4.F
02218:  BRA     224A
0221A:  MOV     #1,W0
0221C:  XOR.B   42
0221E:  BRA     224A
02220:  MOV.B   W4L,W1L
02222:  MOV.B   W6L,W3L
02224:  BCLR    W1.7
02226:  BCLR    W3.7
02228:  SUB.B   W3L,W1L,W1L
0222A:  BRA     Z,2236
0222C:  BTSS    W4.F
0222E:  BRA     224A
02230:  MOV     #1,W0
02232:  XOR.B   42
02234:  BRA     224A
02236:  SUB     W7,W5,W1
02238:  BRA     Z,2244
0223A:  BTSS    W4.F
0223C:  BRA     224A
0223E:  MOV     #1,W0
02240:  XOR.B   42
02242:  BRA     224A
02244:  BCLR.B  42.0
02246:  BRA     224A
02248:  BRA     224A
0224A:  MOV     [--W15],W7
0224C:  MOV     [--W15],W6
0224E:  MOV     [--W15],W5
02250:  RETURN  
02252:  MOV     W5,[W15++]
02254:  MOV     #C,W5
02256:  REPEAT  #4
02258:  MOV     [W5++],[W15++]
0225A:  CLR     W9
0225C:  XOR     W1,W3,W9
0225E:  MOV     W1,W6
02260:  MOV     W0,W5
02262:  MOV     W3,W8
02264:  MOV     W2,W7
02266:  RLC     W1,W1
02268:  SWAP    W1
0226A:  ZE      W1,W1
0226C:  CP0     W1
0226E:  BRA     Z,230C
02270:  RLC     W3,W3
02272:  SWAP    W3
02274:  ZE      W3,W3
02276:  CP0     W3
02278:  BRA     Z,230C
0227A:  CLR     W0
0227C:  SUB.B   W1L,W3L,W0L
0227E:  BRA     NC,2286
02280:  ADD.B   #7F,W0L
02282:  BRA     C,230C
02284:  BRA     228C
02286:  SUB.B   #81,W0L
02288:  BRA     NC,230C
0228A:  BRA     Z,230C
0228C:  MOV     W5,W1
0228E:  MOV     W6,W2
02290:  BSET    W2.7
02292:  AND     #FF,W2
02294:  AND     #FF,W8
02296:  BSET    W8.7
02298:  MOV     #19,W10
0229A:  CLR     W3
0229C:  CLR     W4
0229E:  SUB     W1,W7,W1
022A0:  SUBB    W2,W8,W2
022A2:  BRA     N,22A8
022A4:  BRA     C,22AE
022A6:  BRA     NZ,22B0
022A8:  ADD     W1,W7,W1
022AA:  ADDC    W2,W8,W2
022AC:  BRA     22B0
022AE:  BSET    W4.0
022B0:  DEC     W10,W10
022B2:  BRA     Z,22C2
022B4:  BCLR.B  42.0
022B6:  RLC     W1,W1
022B8:  RLC     W2,W2
022BA:  BCLR.B  42.0
022BC:  RLC     W4,W4
022BE:  RLC     W3,W3
022C0:  BRA     229E
022C2:  CLR     W10
022C4:  BTSC    W3.8
022C6:  BRA     22CA
022C8:  BRA     22D6
022CA:  BCLR.B  42.0
022CC:  RRC     W3,W3
022CE:  BCLR    W3.7
022D0:  RRC     W4,W4
022D2:  RLC     W10,W10
022D4:  BRA     22DA
022D6:  DEC     W0,W0
022D8:  BRA     Z,230C
022DA:  BTSC    W10.F
022DC:  BRA     NC,22E8
022DE:  RLC     W1,W1
022E0:  RLC     W2,W2
022E2:  SUB     W1,W7,W1
022E4:  SUBB    W2,W8,W2
022E6:  BRA     NC,22FA
022E8:  INC     W4,W4
022EA:  BRA     NZ,22FA
022EC:  INC     W3,W3
022EE:  BRA     NZ,22FA
022F0:  INC     W0,W0
022F2:  BRA     Z,230C
022F4:  BRA     22FA
022F6:  DEC     W0,W0
022F8:  BRA     Z,230C
022FA:  SWAP    W0
022FC:  RRC     W0,W1
022FE:  BSET    W1.F
02300:  BTSS    W9.F
02302:  BCLR    W1.F
02304:  BCLR    W3.7
02306:  XOR.B   W3L,W1L,W1L
02308:  MOV     W4,W0
0230A:  BRA     2312
0230C:  MOV     #0,W0
0230E:  MOV     #0,W1
02310:  BRA     2312
02312:  MOV     #14,W5
02314:  REPEAT  #4
02316:  MOV     [--W15],[W5--]
02318:  MOV     [--W15],W5
0231A:  RETURN  
0231C:  MOV     W0,W2
0231E:  MOV     W1,W3
02320:  MOV.B   W1L,W0L
02322:  SWAP    W0
02324:  BSET    W0.F
02326:  RLC     W1,W1
02328:  SWAP    W1
0232A:  ZE      W1,W1
0232C:  MOV     #8E,W4
0232E:  SUB.B   W4L,W1L,W1L
02330:  BRA     Z,233E
02332:  CP0     W0
02334:  BRA     Z,233E
02336:  BCLR.B  42.0
02338:  RRC     W0,W0
0233A:  DEC     W1,W1
0233C:  BRA     NZ,2332
0233E:  BTSS    W3.F
02340:  BRA     2346
02342:  NEG     W0,W0
02344:  BRA     2346
02346:  RETURN  
02348:  MOV     W5,[W15++]
0234A:  MOV     W6,[W15++]
0234C:  MOV     #8E,W1
0234E:  CP0     W0
02350:  BRA     Z,2376
02352:  BTSC    W0.F
02354:  BRA     235E
02356:  BCLR.B  42.0
02358:  RLC     W0,W0
0235A:  DEC     W1,W1
0235C:  BRA     2352
0235E:  SWAP    W1
02360:  BCLR.B  42.0
02362:  RRC     W1,W1
02364:  BCLR    W0.F
02366:  SWAP    W0
02368:  XOR.B   W0L,W1L,W1L
0236A:  AND.B   #0,W0L
0236C:  BRA     237C
0236E:  MOV.B   W1L,W0L
02370:  BSET    W1.7
02372:  AND.B   #0,W1L
02374:  BRA     237C
02376:  CLR     W0
02378:  CLR     W1
0237A:  BRA     237C
0237C:  MOV     [--W15],W6
0237E:  MOV     [--W15],W5
02380:  RETURN  
02382:  MOV     W5,[W15++]
02384:  MOV     #C,W5
02386:  REPEAT  #4
02388:  MOV     [W5++],[W15++]
0238A:  MOV     W0,W4
0238C:  MOV     W1,W5
0238E:  MOV     W3,W7
02390:  MOV     W2,W6
02392:  BCLR.B  42.0
02394:  BCLR.B  42.1
02396:  RLC     W1,W1
02398:  SWAP    W1
0239A:  AND     #FF,W1
0239C:  CP0     W1
0239E:  BRA     Z,2436
023A0:  BCLR.B  42.0
023A2:  BCLR.B  42.1
023A4:  RLC     W3,W3
023A6:  SWAP    W3
023A8:  AND     #FF,W3
023AA:  CP0     W3
023AC:  BRA     Z,2436
023AE:  ZE      W0,W0
023B0:  ADD.B   W3L,W1L,W0L
023B2:  BRA     C,23BC
023B4:  SUB     #7F,W0
023B6:  BRA     Z,2436
023B8:  BRA     NC,2436
023BA:  BRA     23C0
023BC:  ADD.B   #81,W0L
023BE:  BRA     C,2436
023C0:  XOR     W5,W7,W10
023C2:  BCLR.B  42.0
023C4:  BCLR.B  42.1
023C6:  AND     #FF,W5
023C8:  BSET    W5.7
023CA:  BCLR.B  42.0
023CC:  AND     #FF,W7
023CE:  BSET    W7.7
023D0:  MUL.UU  W4,W6,W2
023D2:  MUL.UU  W5,W6,W8
023D4:  ADDC    W8,W3,W3
023D6:  MOV     W9,W1
023D8:  BTSC.B  42.0
023DA:  INC     W1,W1
023DC:  BCLR.B  42.0
023DE:  MUL.UU  W7,W4,W8
023E0:  ADDC    W8,W3,W3
023E2:  ADDC    W9,W1,W1
023E4:  MUL.UU  W5,W7,W8
023E6:  ADDC    W8,W1,W1
023E8:  INC     W0,W0
023EA:  CP0     W1
023EC:  BTSC.B  42.1
023EE:  BRA     23F2
023F0:  BRA     23F8
023F2:  CP0     W3
023F4:  BTSC.B  42.1
023F6:  BRA     2402
023F8:  BTSC    W1.F
023FA:  BRA     2402
023FC:  RLC     W3,W3
023FE:  RLC     W1,W1
02400:  DEC     W0,W0
02402:  MOV     W1,W2
02404:  BCLR.B  42.0
02406:  BTSS    W3.7
02408:  BRA     241C
0240A:  MOV     #FF00,W7
0240C:  AND     W3,W7,W3
0240E:  ADD     #100,W3
02410:  ADDC    W2,#0,W2
02412:  CP0     W2
02414:  BRA     NZ,241C
02416:  CP0     W3
02418:  BRA     NZ,241C
0241A:  INC     W0,W0
0241C:  SWAP    W0
0241E:  BCLR.B  42.0
02420:  BCLR.B  42.1
02422:  RRC     W0,W1
02424:  BTSC    W10.F
02426:  BSET    W1.F
02428:  BCLR    W2.F
0242A:  SWAP    W2
0242C:  XOR.B   W2L,W1L,W1L
0242E:  SWAP    W3
02430:  MOV.B   W3L,W2L
02432:  MOV     W2,W0
02434:  BRA     243C
02436:  MOV     #0,W0
02438:  MOV     #0,W1
0243A:  BRA     243C
0243C:  MOV     #14,W5
0243E:  REPEAT  #4
02440:  MOV     [--W15],[W5--]
02442:  MOV     [--W15],W5
02444:  RETURN  
02446:  MOV     W5,[W15++]
02448:  MOV     #C,W5
0244A:  REPEAT  #3
0244C:  MOV     [W5++],[W15++]
0244E:  CLR     W9
02450:  MOV     #8000,W8
02452:  BTSC.B  43.0
02454:  XOR     W8,W3,W3
02456:  CP0     W0
02458:  BRA     NZ,2460
0245A:  MOV     #7FFF,W10
0245C:  AND     W1,W10,W10
0245E:  BTSS.B  42.1
02460:  MOV     W1,W10
02462:  XOR     W3,W10,W11
02464:  MOV     W1,W6
02466:  MOV     W3,W7
02468:  MOV     W3,W12
0246A:  BCLR.B  42.1
0246C:  BCLR.B  42.0
0246E:  RLC     W6,W6
02470:  SWAP    W6
02472:  AND     #FF,W6
02474:  CP0     W6
02476:  BRA     Z,25BA
02478:  BCLR.B  42.1
0247A:  BCLR.B  42.0
0247C:  RLC     W7,W7
0247E:  SWAP    W7
02480:  AND     #FF,W7
02482:  CP0     W7
02484:  BRA     Z,25C4
02486:  BCLR.B  42.1
02488:  BCLR.B  42.0
0248A:  CP      W7,W6
0248C:  BRA     Z,25C6
0248E:  BRA     N,25D6
02490:  BCLR    W9.0
02492:  BSET    W9.1
02494:  SUB     W7,W6,W8
02496:  MOV     W7,W6
02498:  AND     #FF,W1
0249A:  BSET    W1.7
0249C:  AND     #FF,W3
0249E:  BSET    W3.7
024A0:  MOV     #28,W7
024A2:  CP      W7,W8
024A4:  BRA     N,24C8
024A6:  BCLR.B  42.1
024A8:  BCLR.B  42.0
024AA:  RRC     W1,W1
024AC:  RRC     W0,W0
024AE:  DEC     W8,W8
024B0:  BRA     NZ,24A6
024B2:  BRA     24CE
024B4:  MOV     #28,W7
024B6:  CP      W7,W8
024B8:  BRA     N,24CC
024BA:  BCLR.B  42.1
024BC:  BCLR.B  42.0
024BE:  RRC     W3,W3
024C0:  RRC     W2,W2
024C2:  DEC     W8,W8
024C4:  BRA     NZ,24BA
024C6:  BRA     24E6
024C8:  MOV     W2,W0
024CA:  MOV     W3,W1
024CC:  BRA     2554
024CE:  BTSS    W11.F
024D0:  BRA     24F4
024D2:  BTSC    W9.4
024D4:  MOV     W12,W11
024D6:  NEG     W0,W0
024D8:  BRA     Z,24DE
024DA:  COM.B   W1L,W1L
024DC:  BRA     24E0
024DE:  NEG     W1,W1
024E0:  BTSC    W9.4
024E2:  BRA     253A
024E4:  BRA     24F4
024E6:  BTSS    W11.F
024E8:  BRA     24F4
024EA:  NEG     W2,W2
024EC:  BRA     Z,24F2
024EE:  COM.B   W3L,W3L
024F0:  BRA     24F4
024F2:  NEG     W3,W3
024F4:  AND     #FF,W5
024F6:  BCLR.B  42.1
024F8:  BCLR.B  42.0
024FA:  ADD     W0,W2,W0
024FC:  ADDC.B  W1L,W3L,W1L
024FE:  BTSC.B  42.0
02500:  BSET    W9.3
02502:  BTSC    W9.0
02504:  BRA     2518
02506:  BTSC    W9.1
02508:  BRA     250C
0250A:  BRA     2522
0250C:  BTSC    W11.F
0250E:  BRA     253A
02510:  BTSC    W9.3
02512:  BRA     2566
02514:  BSET    W9.6
02516:  BRA     2554
02518:  BTSC    W11.F
0251A:  BRA     253A
0251C:  BTSC    W9.3
0251E:  BRA     2566
02520:  BRA     2554
02522:  BCLR    W9.2
02524:  BTSC    W11.F
02526:  BRA     2530
02528:  MOV     W10,W11
0252A:  BTSC    W9.3
0252C:  BRA     2566
0252E:  BRA     259C
02530:  BSET    W9.4
02532:  XOR.B   #80,W1L
02534:  BTSC    W1.7
02536:  BRA     24D2
02538:  MOV     W10,W11
0253A:  AND     #FF,W1
0253C:  IOR      W0,  W1,W7
0253E:  BRA     Z,2554
02540:  BTSC    W1.7
02542:  BRA     2554
02544:  BCLR.B  42.1
02546:  BCLR.B  42.0
02548:  RLC     W0,W0
0254A:  RLC     W1,W1
0254C:  DEC     W6,W6
0254E:  BTSC.B  42.1
02550:  BRA     25B4
02552:  BRA     2540
02554:  BTSC    W9.0
02556:  MOV     W10,W11
02558:  BTSC    W9.1
0255A:  MOV     W12,W11
0255C:  BTSS    W9.5
0255E:  BRA     2594
02560:  BTSC    W10.F
02562:  BSET    W0.8
02564:  BRA     259C
02566:  BSET.B  42.0
02568:  RRC.B   W1L,W1L
0256A:  RRC     W0,W0
0256C:  BTSC.B  42.0
0256E:  BSET    W9.5
02570:  INC     W6,W6
02572:  BRA     Z,25B4
02574:  BTSS    W9.5
02576:  BRA     2588
02578:  INC     W0,W0
0257A:  BRA     NZ,2588
0257C:  INC.B   W1L,W1L
0257E:  BRA     NZ,2588
02580:  RRC.B   W1L,W1L
02582:  RRC     W0,W0
02584:  INC     W6,W6
02586:  BRA     Z,25B4
02588:  BTSC    W9.0
0258A:  MOV     W10,W11
0258C:  BTSC    W9.1
0258E:  MOV     W12,W11
02590:  BTSC.B  42.1
02592:  BRA     25B4
02594:  BTSC    W9.6
02596:  MOV     W10,W11
02598:  BTSC    W9.7
0259A:  MOV     W12,W11
0259C:  IOR      W0,  W1,W2
0259E:  BRA     Z,25E6
025A0:  BCLR    W1.7
025A2:  SWAP    W6
025A4:  BCLR.B  42.1
025A6:  BCLR.B  42.0
025A8:  RRC     W6,W6
025AA:  XOR     W6,W1,W1
025AC:  BSET    W1.F
025AE:  BTSS    W11.F
025B0:  BCLR    W1.F
025B2:  BRA     25E6
025B4:  MOV     #0,W0
025B6:  MOV     #0,W1
025B8:  BRA     25E6
025BA:  BTSC    W10.F
025BC:  XOR     W8,W3,W3
025BE:  MOV     W2,W0
025C0:  MOV     W3,W1
025C2:  BRA     25E6
025C4:  BRA     25E6
025C6:  AND     #FF,W3
025C8:  BSET    W3.7
025CA:  AND     #FF,W1
025CC:  BSET    W1.7
025CE:  BTSC    W11.F
025D0:  BCLR    W3.7
025D2:  BSET    W9.2
025D4:  BRA     24E6
025D6:  SUB     W6,W7,W8
025D8:  AND     #FF,W1
025DA:  BSET    W1.7
025DC:  AND     #FF,W3
025DE:  BSET    W3.7
025E0:  BCLR    W9.1
025E2:  BSET    W9.0
025E4:  BRA     24B4
025E6:  MOV     #12,W5
025E8:  REPEAT  #3
025EA:  MOV     [--W15],[W5--]
025EC:  MOV     [--W15],W5
025EE:  RETURN  
*
06F0A:  MOV     W8,[W15++]
06F0C:  MOV     #12,W8
06F0E:  REPEAT  #4
06F10:  MOV     [W8++],[W15++]
06F12:  MOV     #8000,W8
06F14:  BTSC.B  43.0
06F16:  XOR     W8,W7,W7
06F18:  CP0     W0
06F1A:  BRA     NZ,6F2A
06F1C:  CP0     W1
06F1E:  BRA     NZ,6F2A
06F20:  CP0     W2
06F22:  BRA     NZ,6F2A
06F24:  MOV     #7FFF,W10
06F26:  AND     W3,W10,W10
06F28:  BTSS.B  42.1
06F2A:  MOV     W3,W10
06F2C:  XOR     W7,W10,W11
06F2E:  MOV     W3,W8
06F30:  MOV     W7,W9
06F32:  MOV     W7,W12
06F34:  MOV     #7FF,W13
06F36:  BCLR.B  42.1
06F38:  BCLR.B  42.0
06F3A:  ASR     W8,#4,W8
06F3C:  AND     W13,W8,W8
06F3E:  CP0     W8
06F40:  BRA     Z,70BA
06F42:  BCLR.B  42.1
06F44:  BCLR.B  42.0
06F46:  ASR     W9,#4,W9
06F48:  AND     W13,W9,W9
06F4A:  CP0     W9
06F4C:  BRA     Z,70CA
06F4E:  CLR     W13
06F50:  BCLR.B  42.1
06F52:  BCLR.B  42.0
06F54:  CP      W9,W8
06F56:  BRA     Z,70CC
06F58:  BRA     N,70DC
06F5A:  BCLR    W13.0
06F5C:  BSET    W13.1
06F5E:  SUB     W9,W8,W8
06F60:  AND     #F,W3
06F62:  BSET    W3.4
06F64:  AND     #F,W7
06F66:  BSET    W7.4
06F68:  SUB     #34,W8
06F6A:  BRA     NN,6F98
06F6C:  ADD     #34,W8
06F6E:  BCLR.B  42.1
06F70:  BCLR.B  42.0
06F72:  RRC     W3,W3
06F74:  RRC     W2,W2
06F76:  RRC     W1,W1
06F78:  RRC     W0,W0
06F7A:  DEC     W8,W8
06F7C:  BRA     NZ,6F6E
06F7E:  BRA     6FA8
06F80:  SUB     #34,W8
06F82:  BRA     NN,6FA2
06F84:  ADD     #34,W8
06F86:  BCLR.B  42.1
06F88:  BCLR.B  42.0
06F8A:  RRC     W7,W7
06F8C:  RRC     W6,W6
06F8E:  RRC     W5,W5
06F90:  RRC     W4,W4
06F92:  DEC     W8,W8
06F94:  BRA     NZ,6F86
06F96:  BRA     6FCE
06F98:  MOV     W4,W0
06F9A:  MOV     W5,W1
06F9C:  MOV     W6,W2
06F9E:  MOV     W7,W3
06FA0:  XOR     W11,W12,W12
06FA2:  BTSC    W12.F
06FA4:  BTG     W11.F
06FA6:  BRA     709A
06FA8:  BTSS    W11.F
06FAA:  BRA     6FEA
06FAC:  BTSC    W13.4
06FAE:  MOV     W12,W11
06FB0:  COM     W0,W0
06FB2:  COM     W1,W1
06FB4:  COM     W2,W2
06FB6:  COM.B   W3L,W3L
06FB8:  AND.B   #1F,W3L
06FBA:  INC     W0,W0
06FBC:  BRA     NZ,6FC8
06FBE:  INC     W1,W1
06FC0:  BRA     NZ,6FC8
06FC2:  INC     W2,W2
06FC4:  BRA     NZ,6FC8
06FC6:  INC.B   W3L,W3L
06FC8:  BTSC    W13.4
06FCA:  BRA     7030
06FCC:  BRA     6FEA
06FCE:  BTSS    W11.F
06FD0:  BRA     6FEA
06FD2:  COM     W4,W4
06FD4:  COM     W5,W5
06FD6:  COM     W6,W6
06FD8:  COM.B   W7L,W7L
06FDA:  AND.B   #1F,W7L
06FDC:  INC     W4,W4
06FDE:  BRA     NZ,6FEA
06FE0:  INC     W5,W5
06FE2:  BRA     NZ,6FEA
06FE4:  INC     W6,W6
06FE6:  BRA     NZ,6FEA
06FE8:  INC.B   W7L,W7L
06FEA:  BCLR.B  42.1
06FEC:  BCLR.B  42.0
06FEE:  ADD     W0,W4,W0
06FF0:  ADDC    W1,W5,W1
06FF2:  ADDC    W2,W6,W2
06FF4:  ADDC.B  W3L,W7L,W3L
06FF6:  BTSC    W3.5
06FF8:  BSET    W13.3
06FFA:  BTSC    W13.0
06FFC:  BRA     7010
06FFE:  BTSC    W13.1
07000:  BRA     7004
07002:  BRA     701A
07004:  BTSC    W11.F
07006:  BRA     7030
07008:  BTSC    W13.3
0700A:  BRA     705E
0700C:  BSET    W13.6
0700E:  BRA     7052
07010:  BTSC    W11.F
07012:  BRA     7030
07014:  BTSC    W13.3
07016:  BRA     705E
07018:  BRA     7052
0701A:  BTSC    W11.F
0701C:  BRA     7026
0701E:  MOV     W10,W11
07020:  BTSC    W13.3
07022:  BRA     705E
07024:  BRA     709A
07026:  BSET    W13.4
07028:  XOR.B   #10,W3L
0702A:  BTSC    W3.4
0702C:  BRA     6FAC
0702E:  MOV     W10,W11
07030:  AND     #1F,W3
07032:  IOR      W3,  W2,W8
07034:  BRA     NZ,703A
07036:  IOR      W1,  W0,W8
07038:  BRA     Z,7052
0703A:  BTSC    W3.4
0703C:  BRA     7052
0703E:  BCLR.B  42.1
07040:  BCLR.B  42.0
07042:  RLC     W0,W0
07044:  RLC     W1,W1
07046:  RLC     W2,W2
07048:  RLC     W3,W3
0704A:  DEC     W9,W9
0704C:  BTSC.B  42.1
0704E:  BRA     70B4
07050:  BRA     703A
07052:  BTSC    W13.0
07054:  MOV     W10,W11
07056:  BTSC    W13.1
07058:  MOV     W12,W11
0705A:  BTSS    W13.5
0705C:  BRA     709A
0705E:  BCLR.B  42.0
07060:  RRC.B   W3L,W3L
07062:  RRC     W2,W2
07064:  RRC     W1,W1
07066:  RRC     W0,W0
07068:  BTSC.B  42.0
0706A:  BSET    W13.5
0706C:  INC     W9,W9
0706E:  BTSC.B  42.1
07070:  BRA     70B4
07072:  BTSS    W13.5
07074:  BRA     7092
07076:  INC     W0,W0
07078:  BRA     NZ,7092
0707A:  INC     W1,W1
0707C:  BRA     NZ,7092
0707E:  INC     W2,W2
07080:  BRA     NZ,7092
07082:  INC     W3,W3
07084:  BRA     NZ,7092
07086:  RRC.B   W3L,W3L
07088:  RRC     W2,W2
0708A:  RRC     W1,W1
0708C:  RRC     W0,W0
0708E:  INC     W9,W9
07090:  BRA     Z,70B4
07092:  BTSC    W13.0
07094:  MOV     W10,W11
07096:  BTSC    W13.1
07098:  MOV     W12,W11
0709A:  IOR      W0,  W1,W4
0709C:  BRA     NZ,70A2
0709E:  IOR      W2,  W3,W4
070A0:  BRA     Z,70EE
070A2:  BCLR    W3.4
070A4:  BCLR.B  42.1
070A6:  BCLR.B  42.0
070A8:  SL      W9,#4,W9
070AA:  XOR     W9,W3,W3
070AC:  BSET    W3.F
070AE:  BTSS    W11.F
070B0:  BCLR    W3.F
070B2:  BRA     70EE
070B4:  MUL.UU  W0,#0,W0
070B6:  MUL.UU  W2,#0,W2
070B8:  BRA     70EE
070BA:  MOV     #8000,W8
070BC:  BTSC    W10.F
070BE:  XOR     W8,W7,W7
070C0:  MOV     W5,W1
070C2:  MOV     W4,W0
070C4:  MOV     W6,W2
070C6:  MOV     W7,W3
070C8:  BRA     70EE
070CA:  BRA     70EE
070CC:  AND     #F,W7
070CE:  BSET    W7.4
070D0:  AND     #F,W3
070D2:  BSET    W3.4
070D4:  BTSC    W11.F
070D6:  BCLR    W7.4
070D8:  BSET    W13.2
070DA:  BRA     6FCE
070DC:  AND     #F,W3
070DE:  BSET    W3.4
070E0:  AND     #F,W7
070E2:  BSET    W7.4
070E4:  SUB     W8,W9,W8
070E6:  ADD     W8,W9,W9
070E8:  BCLR    W13.1
070EA:  BSET    W13.0
070EC:  BRA     6F80
070EE:  MOV     #1A,W8
070F0:  REPEAT  #4
070F2:  MOV     [--W15],[W8--]
070F4:  MOV     [--W15],W8
070F6:  RETURN  
070F8:  MOV     W8,[W15++]
070FA:  MOV     W9,[W15++]
070FC:  MOV     W10,[W15++]
070FE:  XOR     W3,W7,W9
07100:  BTSS    W9.F
07102:  BRA     7110
07104:  BCLR.B  42.0
07106:  BCLR.B  42.1
07108:  BTSS    W3.F
0710A:  BRA     7174
0710C:  BSET.B  42.0
0710E:  BRA     7174
07110:  MOV     #7FF,W10
07112:  MOV     W3,W8
07114:  MOV     W7,W9
07116:  ASR     W8,#4,W8
07118:  AND     W10,W8,W8
0711A:  ASR     W9,#4,W9
0711C:  AND     W10,W9,W9
0711E:  SUB     W9,W8,W10
07120:  BRA     Z,712C
07122:  BTSS    W3.F
07124:  BRA     7174
07126:  MOV     #1,W0
07128:  XOR.B   42
0712A:  BRA     7174
0712C:  MOV     W3,W8
0712E:  MOV     W7,W9
07130:  AND     #1F,W3
07132:  AND     #1F,W7
07134:  BCLR    W3.4
07136:  BCLR    W7.4
07138:  SUB.B   W7L,W3L,W10L
0713A:  BRA     Z,7146
0713C:  BTSS    W8.F
0713E:  BRA     7174
07140:  MOV     #1,W0
07142:  XOR.B   42
07144:  BRA     7174
07146:  SUB     W6,W2,W10
07148:  BRA     Z,7154
0714A:  BTSS    W8.F
0714C:  BRA     7174
0714E:  MOV     #1,W0
07150:  XOR.B   42
07152:  BRA     7174
07154:  SUB     W5,W1,W10
07156:  BRA     Z,7162
07158:  BTSS    W8.F
0715A:  BRA     7174
0715C:  MOV     #1,W0
0715E:  XOR.B   42
07160:  BRA     7174
07162:  SUB     W4,W0,W10
07164:  BRA     Z,7170
07166:  BTSS    W8.F
07168:  BRA     7174
0716A:  MOV     #1,W0
0716C:  XOR.B   42
0716E:  BRA     7174
07170:  BCLR.B  42.0
07172:  BRA     7174
07174:  MOV     [--W15],W10
07176:  MOV     [--W15],W9
07178:  MOV     [--W15],W8
0717A:  RETURN  
0717C:  MOV     W5,[W15++]
0717E:  MOV     W6,[W15++]
07180:  MOV     W3,W4
07182:  MOV     W3,W6
07184:  BCLR.B  42.0
07186:  ASR     W4,#4,W4
07188:  MOV     #7FF,W5
0718A:  AND     W5,W4,W4
0718C:  BRA     NZ,7194
0718E:  MUL.UU  W0,#0,W0
07190:  CLR     W2
07192:  BRA     71BA
07194:  SUB     #380,W4
07196:  AND     #F,W3
07198:  MOV     #3,W7
0719A:  BCLR.B  42.0
0719C:  RLC     W0,W0
0719E:  RLC     W1,W1
071A0:  RLC     W2,W2
071A2:  RLC     W3,W3
071A4:  DEC     W7,W7
071A6:  BRA     NZ,719A
071A8:  MOV     W1,W0
071AA:  MOV     W2,W1
071AC:  BCLR    W3.7
071AE:  SWAP    W4
071B0:  BCLR.B  42.0
071B2:  RRC     W4,W4
071B4:  BTSC    W6.F
071B6:  BSET    W4.F
071B8:  XOR     W4,W3,W2
071BA:  MOV     [--W15],W6
071BC:  MOV     [--W15],W5
071BE:  RETURN  
071C0:  MOV     W5,[W15++]
071C2:  MOV     W1,W5
071C4:  MOV     W0,W2
071C6:  MOV     #B6,W4
071C8:  RLC     W1,W1
071CA:  SWAP    W1
071CC:  AND     #FF,W1
071CE:  SUB.B   W4L,W1L,W4L
071D0:  MOV.B   W5L,W3L
071D2:  BSET    W3.7
071D4:  AND     #FF,W3
071D6:  CLR     W0
071D8:  CLR     W1
071DA:  CP      W4,#1F
071DC:  BRA     N,71FC
071DE:  BCLR.B  42.0
071E0:  RRC     W3,W3
071E2:  RRC     W2,W2
071E4:  RRC     W1,W1
071E6:  RRC     W0,W0
071E8:  DEC     W4,W4
071EA:  BRA     NZ,71DE
071EC:  BTSS    W5.F
071EE:  BRA     71FC
071F0:  NEG     W0,W0
071F2:  BRA     Z,71F8
071F4:  COM     W1,W1
071F6:  BRA     71FC
071F8:  NEG     W1,W1
071FA:  BRA     71FC
071FC:  MOV     [--W15],W5
071FE:  RETURN  
*
0725C:  MOV     W5,[W15++]
0725E:  MOV     #C,W5
07260:  REPEAT  #3
07262:  MOV     [W5++],[W15++]
07264:  MOV     W0,W7
07266:  MOV     W4,W9
07268:  BCLR    W4.F
0726A:  CP0     W4
0726C:  BRA     NZ,727A
0726E:  BTSC    W9.F
07270:  BRA     7276
07272:  MOV     #0,W5
07274:  BRA     7294
07276:  MOV     #0,W5
07278:  BRA     7294
0727A:  SUB.B   W4L,#6,W5L
0727C:  BRA     NC,7292
0727E:  MOV     #30,W0
07280:  BTSS    W9.F
07282:  MOV     #20,W0
07284:  BTSC.B  219.1
07286:  BRA     7284
07288:  MOV     W0,21A
0728A:  DEC     W5,W5
0728C:  BRA     NN,7284
0728E:  MOV     #5,W5
07290:  BRA     7294
07292:  MOV     W4,W5
07294:  MOV     #6,W4
07296:  BSET    W5.E
07298:  BTSC    W9.F
0729A:  BSET    W5.F
0729C:  MOV     #2710,W8
0729E:  REPEAT  #11
072A0:  DIV.U   W7,W8
072A2:  CALL    72D6
072A6:  MOV     W1,W7
072A8:  MOV     #3E8,W8
072AA:  REPEAT  #11
072AC:  DIV.U   W7,W8
072AE:  CALL    72D6
072B2:  MOV     W1,W7
072B4:  MOV     #64,W8
072B6:  REPEAT  #11
072B8:  DIV.U   W7,W8
072BA:  CALL    72D6
072BE:  MOV     W1,W7
072C0:  MOV     #A,W8
072C2:  REPEAT  #11
072C4:  DIV.U   W7,W8
072C6:  CALL    72D6
072CA:  MOV     #30,W0
072CC:  ADD.B   W1L,W0L,W0L
072CE:  BTSC.B  219.1
072D0:  BRA     72CE
072D2:  MOV     W0,21A
072D4:  BRA     7304
072D6:  MOV     #30,W6
072D8:  CP0     W0
072DA:  BRA     NZ,72F8
072DC:  BTSS    W5.E
072DE:  BRA     72FA
072E0:  DEC     W4,W4
072E2:  CP.B    W4L,W5L
072E4:  BRA     Z,72EA
072E6:  BTSC.B  42.0
072E8:  RETURN  
072EA:  CP0     W0
072EC:  BRA     NZ,72F8
072EE:  BTSS    W5.E
072F0:  BRA     72FA
072F2:  BTSS    W5.F
072F4:  MOV     #20,W6
072F6:  BRA     72FA
072F8:  BCLR    W5.E
072FA:  ADD.B   W6L,W0L,W0L
072FC:  BTSC.B  219.1
072FE:  BRA     72FC
07300:  MOV     W0,21A
07302:  RETURN  
07304:  MOV     #12,W5
07306:  REPEAT  #3
07308:  MOV     [--W15],[W5--]
0730A:  MOV     [--W15],W5
0730C:  RETURN  
0730E:  MOV     W6,[W15++]
07310:  MOV     W7,[W15++]
07312:  MOV     W8,[W15++]
07314:  MOV     W9,[W15++]
07316:  CLR     W4
07318:  CLR     W5
0731A:  CLR     W6
0731C:  CLR     W7
0731E:  XOR     W2,W3,W8
07320:  BRA     Z,7344
07322:  MOV     #20,W8
07324:  BCLR.B  42.0
07326:  RLC     W0,W0
07328:  RLC     W1,W1
0732A:  RLC     W4,W4
0732C:  RLC     W5,W5
0732E:  CP      W5,W3
07330:  BRA     NZ,7334
07332:  CPB     W4,W2
07334:  BRA     NC,733C
07336:  SUB     W4,W2,W4
07338:  SUBB    W5,W3,W5
0733A:  BSET.B  42.0
0733C:  RLC     W6,W6
0733E:  RLC     W7,W7
07340:  DEC     W8,W8
07342:  BRA     NZ,7324
07344:  MOV     W7,W1
07346:  MOV     W6,W0
07348:  MOV     [--W15],W9
0734A:  MOV     [--W15],W8
0734C:  MOV     [--W15],W7
0734E:  MOV     [--W15],W6
07350:  RETURN  
07352:  MOV     W5,[W15++]
07354:  MOV     #C,W5
07356:  REPEAT  #7
07358:  MOV     [W5++],[W15++]
0735A:  BTSS    W1.F
0735C:  BRA     736C
0735E:  NEG     W0,W0
07360:  BRA     Z,7364
07362:  BRA     NZ,7368
07364:  NEG     W1,W1
07366:  BRA     736A
07368:  COM     W1,W1
0736A:  BSET    W4.8
0736C:  CLR     W5
0736E:  MOV     W0,W6
07370:  MOV     W1,W7
07372:  MOV     W4,W12
07374:  BCLR    W4.F
07376:  CP0.B   W4L
07378:  BRA     NZ,737C
0737A:  BRA     73AC
0737C:  SUB.B   W4L,#B,W5L
0737E:  BRA     NC,73AC
07380:  SUB.B   W4L,W5L,W4L
07382:  BTSS    W12.F
07384:  BRA     739C
07386:  BTSS    W4.8
07388:  BRA     7398
0738A:  MOV     #2D,W0
0738C:  BTSC.B  219.1
0738E:  BRA     738C
07390:  MOV     W0,21A
07392:  BCLR    W4.8
07394:  DEC     W5,W5
07396:  BRA     N,73AC
07398:  MOV     #30,W0
0739A:  BRA     739E
0739C:  MOV     #20,W0
0739E:  BTSC.B  219.1
073A0:  BRA     739E
073A2:  MOV     W0,21A
073A4:  DEC     W5,W5
073A6:  BRA     NN,739E
073A8:  BTSC    W4.8
073AA:  DEC.B   W4L,W4L
073AC:  MOV     #E,W8
073AE:  MOV     #0,W9
073B0:  LNK     #10
073B2:  MOV     W12,[W14+W8]
073B4:  DEC2    W8,W8
073B6:  BRA     NN,73B2
073B8:  MOV     W4,W5
073BA:  MOV     #A,W4
073BC:  BTSC    W5.8
073BE:  INC     W4,W4
073C0:  BSET    W5.E
073C2:  BTSC    W12.F
073C4:  BSET    W5.F
073C6:  CP0.B   W5L
073C8:  BRA     Z,73CC
073CA:  DEC.B   W5L,W5L
073CC:  MOV     W4,[W14]
073CE:  MOV     W5,[W14+#2]
073D0:  MOV     W6,W0
073D2:  MOV     W7,W1
073D4:  MOV     #CA00,W2
073D6:  MOV     #3B9A,W3
073D8:  MOV     #2710,W8
073DA:  BCLR    W13.F
073DC:  BCLR.B  43.0
073DE:  CALL    730E
073E2:  BTG     W13.F
073E4:  BTSC    W13.F
073E6:  BRA     73F6
073E8:  MOV     W0,[W14+#8]
073EA:  MOV     W1,[W14+#A]
073EC:  MOV     W0,W2
073EE:  MOV     W1,W3
073F0:  MOV     [W14+#4],W0
073F2:  MOV     [W14+#6],W1
073F4:  BRA     73DC
073F6:  MOV     W2,[W14+#8]
073F8:  MOV     W3,[W14+#A]
073FA:  MOV     W4,[W14+#4]
073FC:  MOV     W5,[W14+#6]
073FE:  MOV     [W14],W4
07400:  MOV     [W14+#2],W5
07402:  MOV     #30,W6
07404:  CP0     W0
07406:  BRA     NZ,742A
07408:  BTSS    W5.E
0740A:  BRA     742E
0740C:  DEC     W4,W4
0740E:  MOV     W4,[W14]
07410:  CP0     W4
07412:  BRA     Z,742E
07414:  CP.B    W4L,W5L
07416:  BRA     Z,741C
07418:  BTSC.B  42.0
0741A:  BRA     744C
0741C:  BTSS    W5.F
0741E:  BRA     7426
07420:  BTSS    W5.8
07422:  BRA     7444
07424:  BRA     7434
07426:  MOV     #20,W6
07428:  BRA     7444
0742A:  BCLR    W5.E
0742C:  MOV     W5,[W14+#2]
0742E:  MOV     [W14+#2],W5
07430:  BTSS    W5.8
07432:  BRA     7444
07434:  BCLR    W5.8
07436:  MOV     W5,[W14+#2]
07438:  MOV     W0,W10
0743A:  MOV     #2D,W0
0743C:  BTSC.B  219.1
0743E:  BRA     743C
07440:  MOV     W0,21A
07442:  MOV     W10,W0
07444:  ADD.B   W6L,W0L,W0L
07446:  BTSC.B  219.1
07448:  BRA     7446
0744A:  MOV     W0,21A
0744C:  MOV     [W14+#8],W0
0744E:  MOV     [W14+#A],W1
07450:  MOV     #A,W2
07452:  CLR     W3
07454:  CP      W0,#1
07456:  BRA     Z,745A
07458:  BRA     73DC
0745A:  ULNK    
0745C:  MOV     #1A,W5
0745E:  REPEAT  #7
07460:  MOV     [--W15],[W5--]
07462:  MOV     [--W15],W5
07464:  RETURN  
*
078C8:  MOV     W5,[W15++]
078CA:  MOV     #C,W5
078CC:  REPEAT  #5
078CE:  MOV     [W5++],[W15++]
078D0:  MOV     W3,W8
078D2:  MOV     W2,W7
078D4:  MOV     W1,W6
078D6:  MOV     W0,W5
078D8:  MOV     W3,W9
078DA:  MOV     #473,W11
078DC:  ASR     W3,#4,W3
078DE:  MOV     #7FF,W10
078E0:  AND     W10,W3,W3
078E2:  SUB     W11,W3,W11
078E4:  AND     #1F,W8
078E6:  BSET    W8.4
078E8:  CLR     W0
078EA:  CLR     W1
078EC:  CLR     W2
078EE:  CLR     W3
078F0:  BCLR.B  42.0
078F2:  RRC     W8,W8
078F4:  RRC     W7,W7
078F6:  RRC     W6,W6
078F8:  RRC     W5,W5
078FA:  RRC     W3,W3
078FC:  RRC     W2,W2
078FE:  RRC     W1,W1
07900:  RRC     W0,W0
07902:  DEC     W11,W11
07904:  BRA     NZ,78F0
07906:  BTSS    W9.F
07908:  BRA     7914
0790A:  NEG     W0,W0
0790C:  COM     W1,W1
0790E:  COM     W2,W2
07910:  COM     W3,W3
07912:  BRA     7914
07914:  MOV     #16,W5
07916:  REPEAT  #5
07918:  MOV     [--W15],[W5--]
0791A:  MOV     [--W15],W5
0791C:  RETURN  
*
08830:  MOV     W5,[W15++]
08832:  MOV     W2,W3
08834:  MOV     W2,W5
08836:  BCLR.B  42.0
08838:  RLC     W3,W3
0883A:  SWAP    W3
0883C:  AND     #FF,W3
0883E:  BRA     NZ,8846
08840:  MUL.UU  W0,#0,W0
08842:  MUL.UU  W2,#0,W2
08844:  BRA     8872
08846:  ADD     #380,W3
08848:  AND     #7F,W2
0884A:  MOV     #3,W6
0884C:  CLR     W4
0884E:  BCLR.B  42.0
08850:  RRC     W2,W2
08852:  RRC     W1,W1
08854:  RRC     W0,W0
08856:  BTSC.B  42.0
08858:  INC     W4,W4
0885A:  DEC     W6,W6
0885C:  BRA     NZ,884E
0885E:  BCLR    W2.7
08860:  SL      W3,#4,W3
08862:  BCLR    W3.F
08864:  BTSC    W5.F
08866:  BSET    W3.F
08868:  XOR     W2,W3,W3
0886A:  MOV     W1,W2
0886C:  MOV     W0,W1
0886E:  ADD     W4,W1,W1
08870:  CLR     W0
08872:  MOV     [--W15],W5
08874:  RETURN  
08876:  MOV     W12,[W15++]
08878:  MOV     W13,[W15++]
0887A:  CLR     W8
0887C:  CLR     W9
0887E:  CLR     W10
08880:  CLR     W11
08882:  CLR     W12
08884:  CLR     W13
08886:  MOV     #E,W8
08888:  MOV     #0,W9
0888A:  LNK     #10
0888C:  MOV     W12,[W14+W8]
0888E:  DEC2    W8,W8
08890:  BRA     NN,888C
08892:  XOR     W4,W5,W8
08894:  BRA     NZ,889A
08896:  XOR     W6,W7,W8
08898:  BRA     Z,88F8
0889A:  CLR     W8
0889C:  MOV     #40,W13
0889E:  MOV     #40,W13
088A0:  BCLR.B  42.0
088A2:  RLC     W0,W0
088A4:  RLC     W1,W1
088A6:  RLC     W2,W2
088A8:  RLC     W3,W3
088AA:  RLC     W8,W8
088AC:  RLC     W9,W9
088AE:  RLC     W10,W10
088B0:  RLC     W11,W11
088B2:  CP      W11,W7
088B4:  BRA     NZ,88C0
088B6:  CPB     W10,W6
088B8:  BRA     NZ,88C0
088BA:  CPB     W9,W5
088BC:  BRA     NZ,88C0
088BE:  CPB     W8,W4
088C0:  BRA     NC,88CC
088C2:  SUB     W8,W4,W8
088C4:  SUBB    W9,W5,W9
088C6:  SUBB    W10,W6,W10
088C8:  SUBB    W11,W7,W11
088CA:  BSET.B  42.0
088CC:  MOV     W8,[W14]
088CE:  MOV     W9,[W14+#2]
088D0:  MOV     W10,[W14+#4]
088D2:  MOV     W11,[W14+#6]
088D4:  MOV     [W14+#8],W8
088D6:  MOV     [W14+#A],W9
088D8:  MOV     [W14+#C],W10
088DA:  MOV     [W14+#E],W11
088DC:  RLC     W8,W8
088DE:  RLC     W9,W9
088E0:  RLC     W10,W10
088E2:  RLC     W11,W11
088E4:  MOV     W8,[W14+#8]
088E6:  MOV     W9,[W14+#A]
088E8:  MOV     W10,[W14+#C]
088EA:  MOV     W11,[W14+#E]
088EC:  MOV     [W14],W8
088EE:  MOV     [W14+#2],W9
088F0:  MOV     [W14+#4],W10
088F2:  MOV     [W14+#6],W11
088F4:  DEC     W13,W13
088F6:  BRA     NZ,88A0
088F8:  MOV     [W14+#8],W0
088FA:  MOV     [W14+#A],W1
088FC:  MOV     [W14+#C],W2
088FE:  MOV     [W14+#E],W3
08900:  ULNK    
08902:  BRA     8904
08904:  MOV     [--W15],W13
08906:  MOV     [--W15],W12
08908:  RETURN  
0890A:  MOV     W5,[W15++]
0890C:  MOV     #C,W5
0890E:  REPEAT  #5
08910:  MOV     [W5++],[W15++]
08912:  BTSS    W3.F
08914:  BRA     8926
08916:  COM     W1,W1
08918:  COM     W2,W2
0891A:  COM     W3,W3
0891C:  NEG     W0,W0
0891E:  ADDC    W1,#0,W1
08920:  ADDC    W2,#0,W2
08922:  ADDC    W3,#0,W3
08924:  BSET    W4.8
08926:  MOV     W0,W6
08928:  MOV     W4,W12
0892A:  BCLR    W4.F
0892C:  CP0     W4
0892E:  BRA     NZ,8932
08930:  BRA     8962
08932:  SUB.B   W4L,#14,W5L
08934:  BRA     NC,8962
08936:  SUB.B   W4L,W5L,W4L
08938:  BTSS    W12.F
0893A:  BRA     8952
0893C:  BTSS    W4.8
0893E:  BRA     894E
08940:  MOV     #2D,W0
08942:  BTSC.B  219.1
08944:  BRA     8942
08946:  MOV     W0,21A
08948:  BCLR    W4.8
0894A:  DEC     W5,W5
0894C:  BRA     N,8962
0894E:  MOV     #30,W0
08950:  BRA     8954
08952:  MOV     #20,W0
08954:  BTSC.B  219.1
08956:  BRA     8954
08958:  MOV     W0,21A
0895A:  DEC     W5,W5
0895C:  BRA     NN,8954
0895E:  BTSC    W4.8
08960:  DEC.B   W4L,W4L
08962:  MOV     #E,W8
08964:  MOV     #0,W9
08966:  LNK     #16
08968:  MOV     W12,[W14+W8]
0896A:  DEC2    W8,W8
0896C:  BRA     NN,8968
0896E:  MOV     W4,W5
08970:  MOV     #13,W4
08972:  BTSC    W5.8
08974:  INC     W4,W4
08976:  BSET    W5.E
08978:  BTSC    W12.F
0897A:  BSET    W5.F
0897C:  CP0.B   W5L
0897E:  BRA     Z,8982
08980:  DEC.B   W5L,W5L
08982:  MOV     W4,[W14]
08984:  MOV     W5,[W14+#2]
08986:  MOV     W6,W0
08988:  CLR     W4
0898A:  MOV     #A764,W5
0898C:  MOV     #B6B3,W6
0898E:  MOV     #DE0,W7
08990:  BCLR    W13.F
08992:  MOV     W13,[W14+#14]
08994:  CALL    8876
08998:  MOV     [W14+#14],W13
0899A:  BTG     W13.F
0899C:  MOV     W13,[W14+#14]
0899E:  BTSC    W13.F
089A0:  BRA     89BC
089A2:  MOV     W0,[W14+#C]
089A4:  MOV     W1,[W14+#E]
089A6:  MOV     W2,[W14+#10]
089A8:  MOV     W3,[W14+#12]
089AA:  MOV     W0,W4
089AC:  MOV     W1,W5
089AE:  MOV     W2,W6
089B0:  MOV     W3,W7
089B2:  MOV     [W14+#4],W0
089B4:  MOV     [W14+#6],W1
089B6:  MOV     [W14+#8],W2
089B8:  MOV     [W14+#A],W3
089BA:  BRA     8994
089BC:  MOV     W4,[W14+#C]
089BE:  MOV     W5,[W14+#E]
089C0:  MOV     W6,[W14+#10]
089C2:  MOV     W7,[W14+#12]
089C4:  MOV     W8,[W14+#4]
089C6:  MOV     W9,[W14+#6]
089C8:  MOV     W10,[W14+#8]
089CA:  MOV     W11,[W14+#A]
089CC:  MOV     [W14],W4
089CE:  MOV     [W14+#2],W5
089D0:  MOV     #30,W6
089D2:  CP0     W0
089D4:  BRA     NZ,89F8
089D6:  BTSS    W5.E
089D8:  BRA     89FC
089DA:  DEC     W4,W4
089DC:  MOV     W4,[W14]
089DE:  CP0     W4
089E0:  BRA     Z,89FC
089E2:  CP.B    W4L,W5L
089E4:  BRA     Z,89EA
089E6:  BTSC.B  42.0
089E8:  BRA     8A18
089EA:  BTSS    W5.F
089EC:  BRA     89F4
089EE:  BTSS    W5.8
089F0:  BRA     8A10
089F2:  BRA     8A00
089F4:  MOV     #20,W6
089F6:  BRA     8A10
089F8:  BCLR    W5.E
089FA:  MOV     W5,[W14+#2]
089FC:  BTSS    W5.8
089FE:  BRA     8A10
08A00:  BCLR    W5.8
08A02:  MOV     W5,[W14+#2]
08A04:  MOV     W0,W10
08A06:  MOV     #2D,W0
08A08:  BTSC.B  219.1
08A0A:  BRA     8A08
08A0C:  MOV     W0,21A
08A0E:  MOV     W10,W0
08A10:  ADD.B   W6L,W0L,W0L
08A12:  BTSC.B  219.1
08A14:  BRA     8A12
08A16:  MOV     W0,21A
08A18:  MOV     [W14+#C],W0
08A1A:  MOV     [W14+#E],W1
08A1C:  MOV     [W14+#10],W2
08A1E:  MOV     [W14+#12],W3
08A20:  MOV     #A,W4
08A22:  CLR     W5
08A24:  MUL.UU  W6,#0,W6
08A26:  CP      W0,#1
08A28:  BRA     Z,8A2C
08A2A:  BRA     8994
08A2C:  ULNK    
08A2E:  MOV     #16,W5
08A30:  REPEAT  #5
08A32:  MOV     [--W15],[W5--]
08A34:  MOV     [--W15],W5
08A36:  RETURN  
08A38:  MOV     W5,[W15++]
08A3A:  MOV     #C,W5
08A3C:  REPEAT  #3
08A3E:  MOV     [W5++],[W15++]
08A40:  MOV     W0,W4
08A42:  MOV     W1,W5
08A44:  MOV     W2,W6
08A46:  MOV     W3,W7
08A48:  CLR     W0
08A4A:  CLR     W1
08A4C:  CLR     W2
08A4E:  CLR     W3
08A50:  BCLR    W8.0
08A52:  BTSS    W7.F
08A54:  BRA     8A60
08A56:  BSET    W8.0
08A58:  NEG     W4,W4
08A5A:  COM     W5,W5
08A5C:  COM     W6,W6
08A5E:  COM     W7,W7
08A60:  IOR      W4,  W5,W9
08A62:  BRA     NZ,8A68
08A64:  IOR      W6,  W7,W9
08A66:  BRA     Z,8A92
08A68:  MOV     #473,W9
08A6A:  BTSC    W3.4
08A6C:  BRA     8A84
08A6E:  BCLR.B  42.0
08A70:  RLC     W4,W4
08A72:  RLC     W5,W5
08A74:  RLC     W6,W6
08A76:  RLC     W7,W7
08A78:  RLC     W0,W0
08A7A:  RLC     W1,W1
08A7C:  RLC     W2,W2
08A7E:  RLC     W3,W3
08A80:  DEC     W9,W9
08A82:  BRA     NZ,8A6A
08A84:  SL      W9,#4,W9
08A86:  BCLR.B  42.0
08A88:  BCLR    W9.F
08A8A:  BCLR    W3.4
08A8C:  XOR     W9,W3,W3
08A8E:  BTSC    W8.0
08A90:  BSET    W3.F
08A92:  MOV     #12,W5
08A94:  REPEAT  #3
08A96:  MOV     [--W15],[W5--]
08A98:  MOV     [--W15],W5
08A9A:  RETURN  
*
08B4C:  MOV     W5,[W15++]
08B4E:  MOV     #C,W5
08B50:  REPEAT  #5
08B52:  MOV     [W5++],[W15++]
08B54:  MOV     W3,W8
08B56:  MOV     W2,W7
08B58:  MOV     W1,W6
08B5A:  MOV     W0,W5
08B5C:  MOV     W3,W9
08B5E:  MOV     #473,W11
08B60:  ASR     W3,#4,W3
08B62:  MOV     #7FF,W10
08B64:  AND     W10,W3,W3
08B66:  SUB     W11,W3,W11
08B68:  AND     #1F,W8
08B6A:  BSET    W8.4
08B6C:  CLR     W0
08B6E:  CLR     W1
08B70:  CLR     W2
08B72:  CLR     W3
08B74:  BCLR.B  42.0
08B76:  RRC     W8,W8
08B78:  RRC     W7,W7
08B7A:  RRC     W6,W6
08B7C:  RRC     W5,W5
08B7E:  RRC     W3,W3
08B80:  RRC     W2,W2
08B82:  RRC     W1,W1
08B84:  RRC     W0,W0
08B86:  DEC     W11,W11
08B88:  BRA     NZ,8B74
08B8A:  BTSS    W9.F
08B8C:  BRA     8B98
08B8E:  NEG     W0,W0
08B90:  COM     W1,W1
08B92:  COM     W2,W2
08B94:  COM     W3,W3
08B96:  BRA     8B98
08B98:  MOV     #16,W5
08B9A:  REPEAT  #5
08B9C:  MOV     [--W15],[W5--]
08B9E:  MOV     [--W15],W5
08BA0:  RETURN  
*
09594:  MOV     W5,[W15++]
09596:  MOV     #C,W5
09598:  REPEAT  #3
0959A:  MOV     [W5++],[W15++]
0959C:  BTSS    W0.F
0959E:  BRA     95B8
095A0:  NEG     W0,W0
095A2:  BSET    W4.8
095A4:  BTSS    W4.F
095A6:  BRA     95B8
095A8:  MOV     W0,[W15++]
095AA:  MOV     #2D,W0
095AC:  BTSC.B  219.1
095AE:  BRA     95AC
095B0:  MOV     W0,21A
095B2:  MOV     [--W15],W0
095B4:  BCLR    W4.8
095B6:  DEC.B   0008
095B8:  CLR     W5
095BA:  MOV     W0,W7
095BC:  MOV     W4,W9
095BE:  BCLR    W4.F
095C0:  CP0.B   W4L
095C2:  BRA     NZ,95D0
095C4:  BTSC    W9.F
095C6:  BRA     95CC
095C8:  MOV     #0,W5
095CA:  BRA     95EA
095CC:  MOV     #0,W5
095CE:  BRA     95EA
095D0:  SUB.B   W4L,#6,W5L
095D2:  BRA     NC,95E8
095D4:  MOV     #30,W0
095D6:  BTSS    W9.F
095D8:  MOV     #20,W0
095DA:  BTSC.B  219.1
095DC:  BRA     95DA
095DE:  MOV     W0,21A
095E0:  DEC     W5,W5
095E2:  BRA     NN,95DA
095E4:  MOV     #5,W5
095E6:  BRA     95EA
095E8:  MOV     W4,W5
095EA:  MOV     #6,W4
095EC:  BTSC    W5.8
095EE:  INC     W4,W4
095F0:  BSET    W5.E
095F2:  BTSC    W9.F
095F4:  BSET    W5.F
095F6:  MOV     #2710,W8
095F8:  REPEAT  #11
095FA:  DIV.U   W7,W8
095FC:  CALL    9640
09600:  MOV     W1,W7
09602:  MOV     #3E8,W8
09604:  REPEAT  #11
09606:  DIV.U   W7,W8
09608:  CALL    9640
0960C:  MOV     W1,W7
0960E:  MOV     #64,W8
09610:  REPEAT  #11
09612:  DIV.U   W7,W8
09614:  CALL    9640
09618:  MOV     W1,W7
0961A:  MOV     #A,W8
0961C:  REPEAT  #11
0961E:  DIV.U   W7,W8
09620:  CALL    9640
09624:  BTSS    W9.8
09626:  BRA     9632
09628:  MOV     #2D,W0
0962A:  BTSC.B  219.1
0962C:  BRA     962A
0962E:  MOV     W0,21A
09630:  BCLR    W9.8
09632:  MOV     #30,W0
09634:  ADD.B   W1L,W0L,W0L
09636:  MOV     W0,2A
09638:  BTSC.B  219.1
0963A:  BRA     9638
0963C:  MOV     W0,21A
0963E:  BRA     9680
09640:  MOV     #30,W6
09642:  CP0     W0
09644:  BRA     NZ,9662
09646:  BTSS    W5.E
09648:  BRA     9676
0964A:  DEC     W4,W4
0964C:  CP.B    W4L,W5L
0964E:  BRA     Z,9654
09650:  BTSC.B  42.0
09652:  RETURN  
09654:  CP0     W0
09656:  BRA     NZ,9662
09658:  BTSS    W5.E
0965A:  BRA     9676
0965C:  BTSS    W5.F
0965E:  MOV     #20,W6
09660:  BRA     9676
09662:  BCLR    W5.E
09664:  BTSS    W9.8
09666:  BRA     9676
09668:  MOV     W0,W10
0966A:  MOV     #2D,W0
0966C:  BTSC.B  219.1
0966E:  BRA     966C
09670:  MOV     W0,21A
09672:  BCLR    W9.8
09674:  MOV     W10,W0
09676:  ADD.B   W6L,W0L,W0L
09678:  BTSC.B  219.1
0967A:  BRA     9678
0967C:  MOV     W0,21A
0967E:  RETURN  
09680:  MOV     #12,W5
09682:  REPEAT  #3
09684:  MOV     [--W15],[W5--]
09686:  MOV     [--W15],W5
09688:  RETURN  
*
0A41A:  PUSH    42
0A41C:  MOV     W0,[W15++]
0A41E:  BCLR.B  81.7
0A420:  MOV     42,W4
0A422:  IOR     #E0,W4
0A424:  MOV     W4,42
0A426:  BSET.B  81.7
0A428:  MOV     W1,760
0A42A:  MOV     #55,W4
0A42C:  MOV     W4,766
0A42E:  MOV     #AA,W4
0A430:  MOV     W4,766
0A432:  BSET.B  761.7
0A434:  NOP     
0A436:  NOP     
0A438:  BTSC.B  761.7
0A43A:  BRA     A438
0A43C:  MOV     [--W15],W0
0A43E:  BCLR.B  81.7
0A440:  POP     42
0A442:  BSET.B  81.7
0A444:  RETURN  
0A446:  MOV     W1,[W15++]
0A448:  MOV     #F000,W1
0A44A:  ADD     W1,W0,W0
0A44C:  CLR     W1
0A44E:  MOV     #7F,W1
0A450:  ADDC    W1,#0,W1
0A452:  MOV     W1,32
0A454:  MOV     [--W15],W1
0A456:  BCLR    W2.0
0A458:  CP0     W2
0A45A:  BRA     Z,A47E
0A45C:  TBLWTL  [W1],[W0]
0A45E:  MOV     W1,[W15++]
0A460:  MOV     #4044,W1
0A462:  CALL    A41A
0A466:  MOV     [--W15],W1
0A468:  TBLWTL  [W1++],[W0]
0A46A:  INC2    W0,W0
0A46C:  BRA     NZ,A470
0A46E:  INC     0032
0A470:  MOV     W1,[W15++]
0A472:  MOV     #4004,W1
0A474:  CALL    A41A
0A478:  MOV     [--W15],W1
0A47A:  DEC2    W2,W2
0A47C:  BRA     NZ,A45C
0A47E:  RETURN  
....................  
.................... #list 
....................  
.................... #include "DSPIC30F_registers.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... #word WREG0 = 0x000 
.................... #word WREG1 = 0x002 
.................... #word WREG2 = 0x004 
.................... #word WREG3 = 0x006 
.................... #word WREG4 = 0x008 
.................... #word WREG5 = 0x00A 
.................... #word WREG6 = 0x00C 
.................... #word WREG7 = 0x00E 
.................... #word WREG8 = 0x010 
.................... #word WREG9 = 0x012 
.................... #word WREG10 = 0x014 
.................... #word WREG11 = 0x016 
.................... #word WREG12 = 0x018 
.................... #word WREG13 = 0x01A 
.................... #word WREG14 = 0x01C 
.................... #word WREG15 = 0x01E 
.................... #word SPLIM = 0x020 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x022 
.................... #word ACCA = 0x022 
.................... #word ACCAH = 0x024 
.................... #word ACCAU = 0x026 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x028 
.................... #word ACCB = 0x028 
.................... #word ACCBH = 0x02A 
.................... #word ACCBU = 0x02C 
.................... #word PC = 0x02E 
.................... #word PCH = 0x02E 
.................... #word PC = 0x02E 
.................... #word PCH = 0x030 
.................... #word TBLPAG = 0x032 
.................... #word PSVPAG = 0x034 
.................... #word RCOUNT = 0x036 
.................... #word DCOUNT = 0x038 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03A 
.................... #word DOSTART = 0x03A 
.................... #word DOSTARTH = 0x03C 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x03E 
.................... #word DOEND = 0x03E 
.................... #word DOENDH = 0x040 
.................... #word SR = 0x042 
.................... #word CORCON = 0x044 
.................... #word MODCON = 0x046 
.................... #word XMODSRT = 0x048 
.................... #word XMODEND = 0x04A 
.................... #word YMODSRT = 0x04C 
.................... #word YMODEND = 0x04E 
.................... #word XBREV = 0x050 
.................... #word DISICNT = 0x052 
.................... #word INTCON1 = 0x080 
.................... #word INTCON2 = 0x082 
.................... #word IFS0 = 0x084 
.................... #word IFS1 = 0x086 
.................... #word IFS2 = 0x088 
.................... #word IEC0 = 0x08C 
.................... #word IEC1 = 0x08E 
.................... #word IEC2 = 0x090 
.................... #word IPC0 = 0x094 
.................... #word IPC1 = 0x096 
.................... #word IPC2 = 0x098 
.................... #word IPC3 = 0x09A 
.................... #word IPC4 = 0x09C 
.................... #word IPC5 = 0x09E 
.................... #word IPC6 = 0x0A0 
.................... #word IPC7 = 0x0A2 
.................... #word IPC8 = 0x0A4 
.................... #word IPC9 = 0x0A6 
.................... #word IPC10 = 0x0A8 
.................... #word INTREG = 0x0B0 
.................... #word CNEN1 = 0x0C0 
.................... #word CNEN2 = 0x0C2 
.................... #word CNPU1 = 0x0C4 
.................... #word CNPU2 = 0x0C6 
.................... #word TMR1 = 0x100 
.................... #word PR1 = 0x102 
.................... #word T1CON = 0x104 
.................... #word TMR2 = 0x106 
.................... #word TMR3HLD = 0x108 
.................... #word TMR3 = 0x10A 
.................... #word PR2 = 0x10C 
.................... #word PR3 = 0x10E 
.................... #word T2CON = 0x110 
.................... #word T3CON = 0x112 
.................... #word TMR4 = 0x114 
.................... #word TMR5HLD = 0x116 
.................... #word TMR5 = 0x118 
.................... #word PR4 = 0x11A 
.................... #word PR5 = 0x11C 
.................... #word T4CON = 0x11E 
.................... #word T5CON = 0x120 
.................... #word IC1BUF = 0x140 
.................... #word IC1CON = 0x142 
.................... #word IC2BUF = 0x144 
.................... #word IC2CON = 0x146 
.................... #word IC3BUF = 0x148 
.................... #word IC3CON = 0x14A 
.................... #word IC4BUF = 0x14C 
.................... #word IC4CON = 0x14E 
.................... #word IC5BUF = 0x150 
.................... #word IC5CON = 0x152 
.................... #word IC6BUF = 0x154 
.................... #word IC6CON = 0x156 
.................... #word IC7BUF = 0x158 
.................... #word IC7CON = 0x15A 
.................... #word IC8BUF = 0x15C 
.................... #word IC8CON = 0x15E 
.................... #word OC1RS = 0x180 
.................... #word OC1R = 0x182 
.................... #word OC1CON = 0x184 
.................... #word OC2RS = 0x186 
.................... #word OC2R = 0x188 
.................... #word OC2CON = 0x18A 
.................... #word OC3RS = 0x18C 
.................... #word OC3R = 0x18E 
.................... #word OC3CON = 0x190 
.................... #word OC4RS = 0x192 
.................... #word OC4R = 0x194 
.................... #word OC4CON = 0x196 
.................... #word OC5RS = 0x198 
.................... #word OC5R = 0x19A 
.................... #word OC5CON = 0x19C 
.................... #word OC6RS = 0x19E 
.................... #word OC6R = 0x1A0 
.................... #word OC6CON = 0x1A2 
.................... #word OC7RS = 0x1A4 
.................... #word OC7R = 0x1A6 
.................... #word OC7CON = 0x1A8 
.................... #word OC8RS = 0x1AA 
.................... #word OC8R = 0x1AC 
.................... #word OC8CON = 0x1AE 
.................... #word I2CRCV = 0x200 
.................... #word I2CTRN = 0x202 
.................... #word I2CBRG = 0x204 
.................... #word I2CCON = 0x206 
.................... #word I2CSTAT = 0x208 
.................... #word I2CADD = 0x20A 
.................... #word U1MODE = 0x20C 
.................... #word U1STA = 0x20E 
.................... #word U1TXREG = 0x210 
.................... #word U1RXREG = 0x212 
.................... #word U1BRG = 0x214 
.................... #word U2MODE = 0x216 
.................... #word U2STA = 0x218 
.................... #word U2TXREG = 0x21A 
.................... #word U2RXREG = 0x21C 
.................... #word U2BRG = 0x21E 
.................... #word SPI1STAT = 0x220 
.................... #word SPI1CON = 0x222 
.................... #word SPI1BUF = 0x224 
.................... #word SPI2STAT = 0x226 
.................... #word SPI2CON = 0x228 
.................... #word SPI2BUF = 0x22A 
.................... #word DCICON1 = 0x240 
.................... #word DCICON2 = 0x242 
.................... #word DCICON3 = 0x244 
.................... #word DCISTAT = 0x246 
.................... #word TSCON = 0x248 
.................... #word RSCON = 0x24C 
.................... #word RXBUF0 = 0x250 
.................... #word RXBUF1 = 0x252 
.................... #word RXBUF2 = 0x254 
.................... #word RXBUF3 = 0x256 
.................... #word TXBUF0 = 0x258 
.................... #word TXBUF1 = 0x25A 
.................... #word TXBUF2 = 0x25C 
.................... #word TXBUF3 = 0x25E 
.................... #word ADCBUF0 = 0x280 
.................... #word ADCBUF1 = 0x282 
.................... #word ADCBUF2 = 0x284 
.................... #word ADCBUF3 = 0x286 
.................... #word ADCBUF4 = 0x288 
.................... #word ADCBUF5 = 0x28A 
.................... #word ADCBUF6 = 0x28C 
.................... #word ADCBUF7 = 0x28E 
.................... #word ADCBUF8 = 0x290 
.................... #word ADCBUF9 = 0x292 
.................... #word ADCBUFA = 0x294 
.................... #word ADCBUFB = 0x296 
.................... #word ADCBUFC = 0x298 
.................... #word ADCBUFD = 0x29A 
.................... #word ADCBUFE = 0x29C 
.................... #word ADCBUFF = 0x29E 
.................... #word ADCON1 = 0x2A0 
.................... #word ADCON2 = 0x2A2 
.................... #word ADCON3 = 0x2A4 
.................... #word ADCHS = 0x2A6 
.................... #word ADPCFG = 0x2A8 
.................... #word ADCSSL = 0x2AA 
.................... #word TRISA = 0x2C0 
.................... #word PORTA = 0x2C2 
.................... #word LATA = 0x2C4 
.................... #word TRISB = 0x2C6 
.................... #word PORTB = 0x2C8 
.................... #word LATB = 0x2CA 
.................... #word TRISC = 0x2CC 
.................... #word PORTC = 0x2CE 
.................... #word LATC = 0x2D0 
.................... #word TRISD = 0x2D2 
.................... #word PORTD = 0x2D4 
.................... #word LATD = 0x2D6 
.................... #word TRISF = 0x2DE 
.................... #word PORTF = 0x2E0 
.................... #word LATF = 0x2E2 
.................... #word TRISG = 0x2E4 
.................... #word PORTG = 0x2E6 
.................... #word LATG = 0x2E8 
.................... #word C1RXF0SID = 0x300 
.................... #word C1RXF0EIDH = 0x302 
.................... #word C1RXF0EIDL = 0x304 
.................... #word C1RXF1SID = 0x308 
.................... #word C1RXF1EIDH = 0x30A 
.................... #word C1RXF1EIDL = 0x30C 
.................... #word C1RXF2SID = 0x310 
.................... #word C1RXF2EIDH = 0x312 
.................... #word C1RXF2EIDL = 0x314 
.................... #word C1RXF3SID = 0x318 
.................... #word C1RXF3EIDH = 0x31A 
.................... #word C1RXF3EIDL = 0x31C 
.................... #word C1RXF4SID = 0x320 
.................... #word C1RXF4EIDH = 0x322 
.................... #word C1RXF4EIDL = 0x324 
.................... #word C1RXF5SID = 0x328 
.................... #word C1RXF5EIDH = 0x32A 
.................... #word C1RXF5EIDL = 0x32C 
.................... #word C1RXM0SID = 0x330 
.................... #word C1RXM0EIDH = 0x332 
.................... #word C1RXM0EIDL = 0x334 
.................... #word C1RXM1SID = 0x338 
.................... #word C1RXM1EIDH = 0x33A 
.................... #word C1RXM1EIDL = 0x33C 
.................... #word C1TX2SID = 0x340 
.................... #word C1TX2EID = 0x342 
.................... #word C1TX2DLC = 0x344 
.................... #word C1TX2B1 = 0x346 
.................... #word C1TX2B2 = 0x348 
.................... #word C1TX2B3 = 0x34A 
.................... #word C1TX2B4 = 0x34C 
.................... #word C1TX2CON = 0x34E 
.................... #word C1TX1SID = 0x350 
.................... #word C1TX1EID = 0x352 
.................... #word C1TX1DLC = 0x354 
.................... #word C1TX1B1 = 0x356 
.................... #word C1TX1B2 = 0x358 
.................... #word C1TX1B3 = 0x35A 
.................... #word C1TX1B4 = 0x35C 
.................... #word C1TX1CON = 0x35E 
.................... #word C1TX0SID = 0x360 
.................... #word C1TX0EID = 0x362 
.................... #word C1TX0DLC = 0x364 
.................... #word C1TX0B1 = 0x366 
.................... #word C1TX0B2 = 0x368 
.................... #word C1TX0B3 = 0x36A 
.................... #word C1TX0B4 = 0x36C 
.................... #word C1TX0CON = 0x36E 
.................... #word C1RX1SID = 0x370 
.................... #word C1RX1EID = 0x372 
.................... #word C1RX1DLC = 0x374 
.................... #word C1RX1B1 = 0x376 
.................... #word C1RX1B2 = 0x378 
.................... #word C1RX1B3 = 0x37A 
.................... #word C1RX1B4 = 0x37C 
.................... #word C1RX1CON = 0x37E 
.................... #word C1RX0SID = 0x380 
.................... #word C1RX0EID = 0x382 
.................... #word C1RX0DLC = 0x384 
.................... #word C1RX0B1 = 0x386 
.................... #word C1RX0B2 = 0x388 
.................... #word C1RX0B3 = 0x38A 
.................... #word C1RX0B4 = 0x38C 
.................... #word C1RX0CON = 0x38E 
.................... #word C1CTRL = 0x390 
.................... #word C1CFG1 = 0x392 
.................... #word C1CFG2 = 0x394 
.................... #word C1INTF = 0x396 
.................... #word C1INTE = 0x398 
.................... #word C1EC = 0x39A 
.................... #word C2RXF0SID = 0x3C0 
.................... #word C2RXF0EIDH = 0x3C2 
.................... #word C2RXF0EIDL = 0x3C4 
.................... #word C2RXF1SID = 0x3C8 
.................... #word C2RXF1EIDH = 0x3CA 
.................... #word C2RXF1EIDL = 0x3CC 
.................... #word C2RXF2SID = 0x3D0 
.................... #word C2RXF2EIDH = 0x3D2 
.................... #word C2RXF2EIDL = 0x3D4 
.................... #word C2RXF3SID = 0x3D8 
.................... #word C2RXF3EIDH = 0x3DA 
.................... #word C2RXF3EIDL = 0x3DC 
.................... #word C2RXF4SID = 0x3E0 
.................... #word C2RXF4EIDH = 0x3E2 
.................... #word C2RXF4EIDL = 0x3E4 
.................... #word C2RXF5SID = 0x3E8 
.................... #word C2RXF5EIDH = 0x3EA 
.................... #word C2RXF5EIDL = 0x3EC 
.................... #word C2RXM0SID = 0x3F0 
.................... #word C2RXM0EIDH = 0x3F2 
.................... #word C2RXM0EIDL = 0x3F4 
.................... #word C2RXM1SID = 0x3F8 
.................... #word C2RXM1EIDH = 0x3FA 
.................... #word C2RXM1EIDL = 0x3FC 
.................... #word C2TX2SID = 0x400 
.................... #word C2TX2EID = 0x402 
.................... #word C2TX2DLC = 0x404 
.................... #word C2TX2B1 = 0x406 
.................... #word C2TX2B2 = 0x408 
.................... #word C2TX2B3 = 0x40A 
.................... #word C2TX2B4 = 0x40C 
.................... #word C2TX2CON = 0x40E 
.................... #word C2TX1SID = 0x410 
.................... #word C2TX1EID = 0x412 
.................... #word C2TX1DLC = 0x414 
.................... #word C2TX1B1 = 0x416 
.................... #word C2TX1B2 = 0x418 
.................... #word C2TX1B3 = 0x41A 
.................... #word C2TX1B4 = 0x41C 
.................... #word C2TX1CON = 0x41E 
.................... #word C2TX0SID = 0x420 
.................... #word C2TX0EID = 0x422 
.................... #word C2TX0DLC = 0x424 
.................... #word C2TX0B1 = 0x426 
.................... #word C2TX0B2 = 0x428 
.................... #word C2TX0B3 = 0x42A 
.................... #word C2TX0B4 = 0x42C 
.................... #word C2TX0CON = 0x42E 
.................... #word C2RX1SID = 0x430 
.................... #word C2RX1EID = 0x432 
.................... #word C2RX1DLC = 0x434 
.................... #word C2RX1B1 = 0x436 
.................... #word C2RX1B2 = 0x438 
.................... #word C2RX1B3 = 0x43A 
.................... #word C2RX1B4 = 0x43C 
.................... #word C2RX1CON = 0x43E 
.................... #word C2RX0SID = 0x440 
.................... #word C2RX0EID = 0x442 
.................... #word C2RX0DLC = 0x444 
.................... #word C2RX0B1 = 0x446 
.................... #word C2RX0B2 = 0x448 
.................... #word C2RX0B3 = 0x44A 
.................... #word C2RX0B4 = 0x44C 
.................... #word C2RX0CON = 0x44E 
.................... #word C2CTRL = 0x450 
.................... #word C2CFG1 = 0x452 
.................... #word C2CFG2 = 0x454 
.................... #word C2INTF = 0x456 
.................... #word C2INTE = 0x458 
.................... #word C2EC = 0x45A 
.................... #word RCON = 0x740 
.................... #word OSCCON = 0x742 
.................... #word OSCTUN = 0x744 
.................... #word NVMCON = 0x760 
.................... #word NVMADR = 0x762 
.................... #word NVMADRU = 0x764 
.................... #word NVMKEY = 0x766 
.................... #word PMD1 = 0x770 
.................... #word PMD2 = 0x772 
....................  
....................  
.................... // Fuses 
.................... #fuses NOWDT, HS2_PLL8, NOPUT, NOPROTECT, DEBUG, NOBROWNOUT, NOWRTÃÂ  
.................... #device ICD=TRUE 
.................... // DÃÂ©finit la vitesse du quartz (prendre en compte si PLL employÃÂ©e) 
.................... #use delay(clock=80000000) 
*
00EBE:  CP0     W0
00EC0:  BTSC.B  42.1
00EC2:  BRA     ED0
00EC4:  REPEAT  #E1B
00EC6:  NOP     
00EC8:  REPEAT  #3FFE
00ECA:  NOP     
00ECC:  DEC     W0,W0
00ECE:  BRA     NZ,EC4
00ED0:  RETURN  
.................... // Config IIC 
.................... #use i2c(master,force_hw,slow,I2C1) 
*
00E12:  MOV     #FFFF,W0
00E14:  BTSS.B  208.3
00E16:  BRA     E22
00E18:  BTSC.B  209.6
00E1A:  BRA     E18
00E1C:  MOV     W1,202
00E1E:  BTSC.B  209.6
00E20:  BRA     E1E
00E22:  MOV     #0,W0
00E24:  BTSC.B  209.7
00E26:  INC     W0,W0
00E28:  RETURN  
*
012B8:  MOV     #FFFF,W0
012BA:  BTSS.B  208.3
012BC:  BRA     12E0
012BE:  MOV     206,W2
012C0:  AND     W2,#1F,W2
012C2:  BRA     NZ,12BE
012C4:  BSET.B  206.3
012C6:  BTSC    W1.0
012C8:  BCLR.B  206.5
012CA:  BTSS    W1.0
012CC:  BSET.B  206.5
012CE:  MOV     206,W2
012D0:  AND     W2,#1F,W2
012D2:  BRA     NZ,12CE
012D4:  BSET.B  206.4
012D6:  BTSS.B  208.1
012D8:  BRA     12D6
012DA:  MOV     200,W0
012DC:  BTSC.B  208.6
012DE:  BCLR.B  208.6
012E0:  RETURN  
.................... #build(stack=2048) 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,STREAM=ROBOTEQ) // Pour pouvoir utiliser le RS232/2 
....................  
....................  
.................... // Variables utiles (globales) 
.................... int1 flagGameEnd=0,flagTimeOut=0;	// DÃÂ©finit si le temps est dÃÂ©passÃÂ© 
.................... int1 flagBaliseCheck=0;				// DÃÂ©finit si adversaire dÃÂ©tectÃÂ© 
.................... int1 flagError=0; 					// Si une erreur doit ÃÂªtre affichÃÂ©e 
.................... //int1 HasBegun = 0;				// Permet de savoir si le jeu ÃÂ  dÃÂ©marrer 
.................... int1 ToDisplay=0; 
.................... int1 IsPassedTimeOut=0; 
.................... int1 flag_depl_ok = 0; 
.................... int1 flag_end = 0; 
.................... int1 _Detected = 0;  
.................... int1 balise_on = 0; 
.................... int1 flag_error = 0;  
.................... int1 Team=0; 
.................... signed int32 ActualPosition = 0; 
.................... unsigned int8 value_balise=0;	// Valeur de la balise en dÃÂ©tection 
.................... unsigned int32 RealTimeMS=0,BeginTimeMS=0,GameTimeMS=0; 
.................... unsigned int8 GameTimeS=0;	// Temps de jeu 
.................... unsigned int8 Time_detected = 0; 
.................... unsigned int8 TIME_tempo_dectected = 4; 
.................... unsigned int8 No_erreur = 0;  
.................... unsigned int8 Value_bal = 0;  
.................... unsigned int8 Tempo_bal = 0 ;  
....................  
....................  
.................... unsigned int8 NoObj = 1; 
.................... unsigned int8 NoPts = 1; 
.................... unsigned int32 last_obj = 0; 
....................  
.................... int1 Check = 1; 
.................... unsigned int8 points = 0; 
.................... unsigned int8 solution = 0; 
....................  
....................  
.................... // DÃÂ©finit les constantes ASCII, comme il n'a pas l'air de les prendre ... 
.................... enum{NUL,SOH,STX,ETX,EOT,ENQ,ACK,BEL,BS,TAB,LF,VT,FF,CR,SO,SI,DLE,DC1,DC2,DC3,DC4,NAK,SYN,ETB,CAN,EM,SUB,ESC,FS,GS,RS,US,SPACE}; 
.................... enum{Init, Choose_objectif, Check_ZI, Send_depl_action, Send_depl_action_ZI, Depl_action_process, Depl_action_process_ZI,Switch_end_obj,Wait_end} Etat_rob = Init; 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... #define BalSensitivity 4 
.................... #define MARGE 360 
.................... #define SIZE_TABLE_X 3000 
.................... #define SIZE_TABLE_Y 2000 
.................... 	 
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Inclusion des fichiers sources 
.................... #include "driver_moteur.c" 
.................... //========================================================================================== 
.................... //																							 
.................... //						EMVs - Fonctions pour DRIVER MOTEUR MAXON 											 
.................... //						--------------------------												 
.................... //																							 
.................... //========================================================================================= 
.................... //	Développé par:		: Carrupt Aurélien    												 
.................... //						: Duay Daniel    												 
.................... //  Date				: 15.03.2013															 
.................... //  Date de modif.		: 14.02.2017															 
.................... //  Nom de la lib	 	: driver_moteur.c													 
.................... //  Version 			: V2.1																 
.................... //========================================================================================= 
.................... // Description :																			 
.................... //=============																			 
.................... //	Ce code contient les fonctions qui permettent au master de communiquer avec le driver  	 
.................... //	de moteur V3.0																			 
.................... //   
.................... //======================================================================================== 
.................... //DIRECTIVES DE PRECOMPILATIONS 
.................... //======================================================================================== 
....................  
.................... #DEFINE DRV_MODE_COURANT 0		// !!!!!!  NON IMPLEMENTE !!!!!   régulation en mode courant  
.................... #DEFINE DRV_MODE_VITESSE 1		// régulation en mode vitesse  
.................... #DEFINE DRV_MODE_NON_REGUL 2	// mode régulation désactivée  
.................... #DEFINE DRV_STOP 0				// Arrêt du moteur et arrêt d'urgence 
.................... #DEFINE DRV_RESET 1				// Reset du driver 
....................  
.................... #DEFINE DRV_ARRET_COURANT 0					// Arret en courant  
.................... #DEFINE DRV_ARRET_POSITION_ABSOLUE 1		// Arret en position absoulue 
.................... #DEFINE DRV_ARRET_POSITION_RELATIVE 2		// Arret en position relative 
.................... #DEFINE DRV_ARRET_TEMPS 3					// Arret en position temps  
.................... 			 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: go_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer un ordre de déplacement au moteur		 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					direction :			sens de rotation du moteur (int8) -> 0 ou 1																			 
.................... //					mode_regulation : 	!!!!!!  NON IMPLEMENTE !!!!!  DRV_MODE_COURANT (int8) -> régulation en courant ->paramètre_1 = valeur du courant qu'on souhaite maintenir [mA] (int16) 
.................... //										DRV_MODE_VITESSE (int8) -> régulation en vitesse  ->paramètre_1 = valeur de vitesse qu'on souhaite maintenir [impulse/s] (int16) 
.................... //										DRV_MODE_NON_REGUL (int8) -> régulation désactivée ->paramètre_1 = valeur de la PWM 0-100 en %  (int16) 
.................... //					mode_d'arret 	: 	DRV_ARRET_POSITION_ABSOLUE (int8)	-> 	parametre_2 = position a atteindre [impulse] (int32)																			   
.................... //										DRV_ARRET_POSITION_RELATIVE (int8)	->	parametre_2 = nombre d'impulsion d'encodeur a effectuer [impulse] (int32) 
.................... //										DRV_ARRET_TEMPS (int8)				->	parametre_2 = temps du parcours [ms] (int32) 
.................... //										DRV_ARRET_COURANT (int8)			->	parametre_2 = valeur du courant d'arrêt souhaité [mA] (int32)								 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 go_driver_moteur(int8 adresse_driver, int8 direction, int8 mode_regulation, int16 parametre_1, int8 mode_arret, signed int32 parametre_2) 
*
010FE:  MOV     W5,[W15++]
01100:  MOV     W6,[W15++]
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
.................... 	int8 config; 
.................... 	 
.................... 	 
.................... 	config = ((mode_regulation & 0b00000111)<<5) + ((direction & 0b00000001)<<4) + (mode_arret & 0b00000111); 
01102:  MOV.B   1B62,W0L
01104:  SE      W0,W0
01106:  AND     W0,#7,W5
01108:  SL      W5,#5,W5
0110A:  MOV.B   1B61,W0L
0110C:  SE      W0,W0
0110E:  AND     W0,#1,W6
01110:  SL      W6,#4,W0
01112:  ADD     W0,W5,W5
01114:  MOV.B   1B63,W0L
01116:  SE      W0,W0
01118:  AND     W0,#7,W0
0111A:  ADD     W0,W5,W0
0111C:  MOV.B   W0L,1B70
.................... 	val1 = make8(parametre_1, 0); 
0111E:  MOV.B   1B64,W0L
01120:  MOV.B   W0L,1B6A
.................... 	val2 = make8(parametre_1, 1); 
01122:  MOV.B   1B65,W0L
01124:  MOV.B   W0L,1B6B
.................... 	val3 = make8(parametre_2, 0); 
01126:  MOV.B   1B66,W0L
01128:  MOV.B   W0L,1B6C
.................... 	val4 = make8(parametre_2, 1); 
0112A:  MOV.B   1B67,W0L
0112C:  MOV.B   W0L,1B6D
.................... 	val5 = make8(parametre_2, 2); 
0112E:  MOV.B   1B68,W0L
01130:  MOV.B   W0L,1B6E
.................... 	val6 = make8(parametre_2, 3); 
01132:  MOV.B   1B69,W0L
01134:  MOV.B   W0L,1B6F
.................... 	 
.................... 	i2c_start(); 
01136:  BTSS.B  208.3
01138:  BRA     1142
0113A:  BSET.B  206.1
0113C:  BTSC.B  206.1
0113E:  BRA     113C
01140:  BRA     1148
01142:  BSET.B  206.0
01144:  BTSC.B  206.0
01146:  BRA     1144
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
01148:  MOV.B   1B60,W0L
0114A:  MOV.B   W0L,2
0114C:  CALL    E12
01150:  CP0.B   W0L
01152:  BRA     NZ,1196
.................... 	{ 
.................... 		i2c_write(0x48);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
01154:  MOV.B   #48,W1L
01156:  CALL    E12
.................... 		i2c_write(config);					//configuration 
0115A:  MOV.B   1B70,W0L
0115C:  MOV.B   W0L,2
0115E:  CALL    E12
.................... 		i2c_write(val1);					// parametre_1 
01162:  MOV.B   1B6A,W0L
01164:  MOV.B   W0L,2
01166:  CALL    E12
.................... 		i2c_write(val2); 
0116A:  MOV.B   1B6B,W0L
0116C:  MOV.B   W0L,W1L
0116E:  CALL    E12
.................... 		i2c_write(val3);					// parametre_2 
01172:  MOV.B   1B6C,W0L
01174:  MOV.B   W0L,2
01176:  CALL    E12
.................... 		i2c_write(val4); 
0117A:  MOV.B   1B6D,W0L
0117C:  MOV.B   W0L,W1L
0117E:  CALL    E12
.................... 		i2c_write(val5);					 
01182:  MOV.B   1B6E,W0L
01184:  MOV.B   W0L,2
01186:  CALL    E12
.................... 		i2c_write(val6); 
0118A:  MOV.B   1B6F,W0L
0118C:  MOV.B   W0L,W1L
0118E:  CALL    E12
.................... 	} 
01192:  GOTO    11A8
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
01196:  MOV     #1F,W0
01198:  AND     206,W0
0119A:  BRA     NZ,1196
0119C:  BSET.B  206.2
0119E:  BTSC.B  206.2
011A0:  BRA     119E
.................... 		return 2; 
011A2:  MOV.B   #2,W0L
011A4:  MOV.B   W0L,0
011A6:  BRA     11B8
.................... 	} 
.................... 	i2c_stop();	 
011A8:  MOV     #1F,W0
011AA:  AND     206,W0
011AC:  BRA     NZ,11A8
011AE:  BSET.B  206.2
011B0:  BTSC.B  206.2
011B2:  BRA     11B0
.................... 	return 1; 
011B4:  MOV.B   #1,W0L
011B6:  MOV.B   W0L,0
011B8:  MOV     [--W15],W6
011BA:  MOV     [--W15],W5
011BC:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur_pid																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les valeurs du PID du régulateur driver moteur	 	      																	 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					reg_P 			= Valeur P du régulateur (int16)  valeur en millième  ex: 1250 = 1.25 
.................... //					reg_I 			= Valeur I du régulateur (int16)			idem 
.................... //					reg_D 			= Valeur D du régulateur (int16)			idem 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur_pid(int8 adresse_driver, int16 reg_P, int16 reg_I, int16 reg_D) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6; 
....................  
.................... 	val1 = make8(reg_P, 0); 
*
00E2A:  MOV.B   1B56,W0L
00E2C:  MOV.B   W0L,1B55
.................... 	val2 = make8(reg_P, 1); 
00E2E:  MOV.B   1B57,W0L
00E30:  MOV.B   W0L,1B5C
.................... 	val3 = make8(reg_I, 0); 
00E32:  MOV.B   1B58,W0L
00E34:  MOV.B   W0L,1B5D
.................... 	val4 = make8(reg_I, 1); 
00E36:  MOV.B   1B59,W0L
00E38:  MOV.B   W0L,1B5E
.................... 	val5 = make8(reg_D, 0); 
00E3A:  MOV.B   1B5A,W0L
00E3C:  MOV.B   W0L,1B5F
.................... 	val6 = make8(reg_D, 1); 
00E3E:  MOV.B   1B5B,W0L
00E40:  MOV.B   W0L,1B60
....................  
.................... 	i2c_start(); 
00E42:  BTSS.B  208.3
00E44:  BRA     E4E
00E46:  BSET.B  206.1
00E48:  BTSC.B  206.1
00E4A:  BRA     E48
00E4C:  BRA     E54
00E4E:  BSET.B  206.0
00E50:  BTSC.B  206.0
00E52:  BRA     E50
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00E54:  MOV.B   1B54,W0L
00E56:  MOV.B   W0L,2
00E58:  CALL    E12
00E5C:  CP0.B   W0L
00E5E:  BRA     NZ,E9A
.................... 	{ 
.................... 		i2c_write(0x37);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00E60:  MOV.B   #37,W1L
00E62:  CALL    E12
.................... 		i2c_write(val1);					// parametre P 
00E66:  MOV.B   1B55,W0L
00E68:  MOV.B   W0L,W1L
00E6A:  CALL    E12
.................... 		i2c_write(val2); 
00E6E:  MOV.B   1B5C,W0L
00E70:  MOV.B   W0L,2
00E72:  CALL    E12
.................... 		i2c_write(val3);					// parametre I 
00E76:  MOV.B   1B5D,W0L
00E78:  MOV.B   W0L,W1L
00E7A:  CALL    E12
.................... 		i2c_write(val4); 
00E7E:  MOV.B   1B5E,W0L
00E80:  MOV.B   W0L,2
00E82:  CALL    E12
.................... 		i2c_write(val5);					// parametre D					 
00E86:  MOV.B   1B5F,W0L
00E88:  MOV.B   W0L,W1L
00E8A:  CALL    E12
.................... 		i2c_write(val6); 
00E8E:  MOV.B   1B60,W0L
00E90:  MOV.B   W0L,2
00E92:  CALL    E12
.................... 	} 
00E96:  GOTO    EAC
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00E9A:  MOV     #1F,W0
00E9C:  AND     206,W0
00E9E:  BRA     NZ,E9A
00EA0:  BSET.B  206.2
00EA2:  BTSC.B  206.2
00EA4:  BRA     EA2
.................... 		return 2; 
00EA6:  MOV.B   #2,W0L
00EA8:  MOV.B   W0L,0
00EAA:  BRA     EBC
.................... 	} 
.................... 	i2c_stop();	 
00EAC:  MOV     #1F,W0
00EAE:  AND     206,W0
00EB0:  BRA     NZ,EAC
00EB2:  BSET.B  206.2
00EB4:  BTSC.B  206.2
00EB6:  BRA     EB4
.................... 	return 1; 
00EB8:  MOV.B   #1,W0L
00EBA:  MOV.B   W0L,0
00EBC:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: config_driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 18.03.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet de configurer les rampes d'accélération et de décélération ainsi que le courant max du moteur 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver (int8) 
.................... //					acceleration 	= valeur d'accélération en imp./sec (int16) 
.................... //					deceleration 	= valeur de décélération en imp./sec (int16)  
.................... //					courant_max 	= Valeur du courant max en mA (int16) 
.................... //					impuls_tour		= Impulsion par tour de moteur après le réducteur -> encodeur * réducteur 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 config_driver_moteur(int8 adresse_driver, int16 acceleration, int16 deceleration, int16 courant_max, int16 impuls_tour) 
.................... { 
.................... 	int8 val1, val2, val3, val4, val5, val6, val7, val8; 
....................  
.................... 	val1 = make8(acceleration, 0); 
*
00ED2:  MOV.B   1B56,W0L
00ED4:  MOV.B   W0L,1B55
.................... 	val2 = make8(acceleration, 1); 
00ED6:  MOV.B   1B57,W0L
00ED8:  MOV.B   W0L,1B5E
.................... 	val3 = make8(deceleration, 0); 
00EDA:  MOV.B   1B58,W0L
00EDC:  MOV.B   W0L,1B5F
.................... 	val4 = make8(deceleration, 1); 
00EDE:  MOV.B   1B59,W0L
00EE0:  MOV.B   W0L,1B60
.................... 	val5 = make8(courant_max, 0); 
00EE2:  MOV.B   1B5A,W0L
00EE4:  MOV.B   W0L,1B61
.................... 	val6 = make8(courant_max, 1); 
00EE6:  MOV.B   1B5B,W0L
00EE8:  MOV.B   W0L,1B62
.................... 	val7 = make8(impuls_tour, 0); 
00EEA:  MOV.B   1B5C,W0L
00EEC:  MOV.B   W0L,1B63
.................... 	val8 = make8(impuls_tour, 1); 
00EEE:  MOV.B   1B5D,W0L
00EF0:  MOV.B   W0L,1B64
....................  
.................... 	i2c_start(); 
00EF2:  BTSS.B  208.3
00EF4:  BRA     EFE
00EF6:  BSET.B  206.1
00EF8:  BTSC.B  206.1
00EFA:  BRA     EF8
00EFC:  BRA     F04
00EFE:  BSET.B  206.0
00F00:  BTSC.B  206.0
00F02:  BRA     F00
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
00F04:  MOV.B   1B54,W0L
00F06:  MOV.B   W0L,2
00F08:  CALL    E12
00F0C:  CP0.B   W0L
00F0E:  BRA     NZ,F5A
.................... 	{ 
.................... 		i2c_write(0x29);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
00F10:  MOV.B   #29,W1L
00F12:  CALL    E12
.................... 		i2c_write(val1);					// accélération 
00F16:  MOV.B   1B55,W0L
00F18:  MOV.B   W0L,W1L
00F1A:  CALL    E12
.................... 		i2c_write(val2); 
00F1E:  MOV.B   1B5E,W0L
00F20:  MOV.B   W0L,2
00F22:  CALL    E12
.................... 		i2c_write(val3);					// décélération 
00F26:  MOV.B   1B5F,W0L
00F28:  MOV.B   W0L,W1L
00F2A:  CALL    E12
.................... 		i2c_write(val4); 
00F2E:  MOV.B   1B60,W0L
00F30:  MOV.B   W0L,2
00F32:  CALL    E12
.................... 		i2c_write(val5);					// courant max					 
00F36:  MOV.B   1B61,W0L
00F38:  MOV.B   W0L,W1L
00F3A:  CALL    E12
.................... 		i2c_write(val6); 
00F3E:  MOV.B   1B62,W0L
00F40:  MOV.B   W0L,2
00F42:  CALL    E12
.................... 		i2c_write(val7);					// impulsion par tour					 
00F46:  MOV.B   1B63,W0L
00F48:  MOV.B   W0L,W1L
00F4A:  CALL    E12
.................... 		i2c_write(val8); 
00F4E:  MOV.B   1B64,W0L
00F50:  MOV.B   W0L,2
00F52:  CALL    E12
.................... 	} 
00F56:  GOTO    F6C
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
00F5A:  MOV     #1F,W0
00F5C:  AND     206,W0
00F5E:  BRA     NZ,F5A
00F60:  BSET.B  206.2
00F62:  BTSC.B  206.2
00F64:  BRA     F62
.................... 		return 2; 
00F66:  MOV.B   #2,W0L
00F68:  MOV.B   W0L,0
00F6A:  BRA     F7C
.................... 	} 
.................... 	i2c_stop();	 
00F6C:  MOV     #1F,W0
00F6E:  AND     206,W0
00F70:  BRA     NZ,F6C
00F72:  BSET.B  206.2
00F74:  BTSC.B  206.2
00F76:  BRA     F74
.................... 	return 1; 
00F78:  MOV.B   #1,W0L
00F7A:  MOV.B   W0L,0
00F7C:  RETURN  
.................... } 
....................  
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: driver_moteur																																 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Duay Daniel 
.................... //						:     												 
.................... //  Date				: 09.05.2015															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:  	Permet d'envoyer des ordres courts direct comme d'arrêter le moteur même s'il n'a pas fini l'ordre précédent ou reset le driver 
.................... // paramètres 	:  	adresse_driver 	= Adresse I2C du driver	(int8) 
.................... //					ordre		 	= ordre à effectuer (stop = 0, reset = 1) (int8) 
.................... // retourne 	:  retourne le status du driver											 
.................... //				   0-> non utilisé																 
.................... //				   1-> OK : ordre transmis														 
.................... //				   2-> not ready  (le slave ne répond pas)															 
.................... //=================================================================================================================================================================================================== 
.................... unsigned int8 driver_moteur(int8 adresse_driver, int8 ordre) 
*
011BE:  MOV     W5,[W15++]
.................... { 
.................... 	i2c_start(); 
011C0:  BTSS.B  208.3
011C2:  BRA     11CC
011C4:  BSET.B  206.1
011C6:  BTSC.B  206.1
011C8:  BRA     11C6
011CA:  BRA     11D2
011CC:  BSET.B  206.0
011CE:  BTSC.B  206.0
011D0:  BRA     11CE
.................... 	if(!i2c_write(adresse_driver))			//ADRESSE 
011D2:  MOV.B   1B5C,W0L
011D4:  MOV.B   W0L,2
011D6:  CALL    E12
011DA:  CP0.B   W0L
011DC:  BRA     NZ,11F2
.................... 	{ 
.................... 		i2c_write(((ordre << 4) & 0b00010000) + 0x01);					//Type de commande (4 bits high) et nombre de donnée (4 bits low)  
011DE:  MOV     1B5C,W5
011E0:  LSR     W5,#8,W5
011E2:  SL      W5,#4,W5
011E4:  AND     W5,#10,W5
011E6:  ADD     W5,#1,W5
011E8:  MOV.B   W5L,W1L
011EA:  CALL    E12
.................... 	} 
011EE:  GOTO    1204
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
011F2:  MOV     #1F,W0
011F4:  AND     206,W0
011F6:  BRA     NZ,11F2
011F8:  BSET.B  206.2
011FA:  BTSC.B  206.2
011FC:  BRA     11FA
.................... 		return 2; 
011FE:  MOV.B   #2,W0L
01200:  MOV.B   W0L,0
01202:  BRA     1214
.................... 	} 
.................... 	i2c_stop();	 
01204:  MOV     #1F,W0
01206:  AND     206,W0
01208:  BRA     NZ,1204
0120A:  BSET.B  206.2
0120C:  BTSC.B  206.2
0120E:  BRA     120C
.................... 	return 1; 
01210:  MOV.B   #1,W0L
01212:  MOV.B   W0L,0
01214:  MOV     [--W15],W5
01216:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_driver_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  Permet de lire l'état du driver								      	 
.................... == paramètre 	:  Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  retourne le status du driver											 
.................... ==				   0-> Arret  (le driver a fini tout traitement et attend le prochain ordre)	 
.................... ==				   1-> Marche (le driver est entrain d'exécuter l'ordre)													 
.................... ==				   2-> Surcharge (le driver a dépassé la limite de courant max. défini par l'utilisateur)															 
.................... ==				   3-> Erreur PONT-H (Température IC trop élevée, courant trop élevé) 
.................... ==				   4-> BUSY (le slave est entrain de traiter la prochaine commande) 
.................... ==				   5-> not ready  (le slave ne répond pas)															 
.................... /*===================================================================================================================================================================================================*/ 
.................... unsigned int8 read_driver_moteur(int8 adresse_driver) 
*
012E2:  MOV     W5,[W15++]
012E4:  CLR.B   1B6B
012E6:  CLR.B   1B6C
.................... { 
.................... 	int8 driver_etat=0; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
012E8:  BTSS.B  208.3
012EA:  BRA     12F4
012EC:  BSET.B  206.1
012EE:  BTSC.B  206.1
012F0:  BRA     12EE
012F2:  BRA     12FA
012F4:  BSET.B  206.0
012F6:  BTSC.B  206.0
012F8:  BRA     12F6
.................... 	ack = i2c_write(adresse_driver+1); 
012FA:  MOV.B   1B6A,W0L
012FC:  SE      W0,W0
012FE:  ADD     W0,#1,W0
01300:  MOV     W0,W5
01302:  MOV.B   W5L,W1L
01304:  CALL    E12
01308:  MOV.B   W0L,1B6C
.................... 	if(ack == 0) 
0130A:  MOV.B   1B6C,W0L
0130C:  SE      W0,W0
0130E:  CP0     W0
01310:  BRA     NZ,1322
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
01312:  MOV     #0,W1
01314:  MOV     W1,[W15++]
01316:  MOV     [--W15],W1
01318:  CALL    12B8
0131C:  MOV.B   W0L,1B6B
.................... 	} 
0131E:  GOTO    1326
.................... 	else driver_etat = 5; 
01322:  MOV.B   #5,W0L
01324:  MOV.B   W0L,1B6B
....................  
.................... 	i2c_stop(); 
01326:  MOV     #1F,W0
01328:  AND     206,W0
0132A:  BRA     NZ,1326
0132C:  BSET.B  206.2
0132E:  BTSC.B  206.2
01330:  BRA     132E
.................... 	return driver_etat; 
01332:  MOV.B   1B6B,W0L
01334:  MOV     [--W15],W5
01336:  RETURN  
.................... } 
....................  
....................  
.................... /*==================================================================================================================================================================================================== 
.................... == Fonction 	: read_pos_moteur	 														 
.................... == Créateur 	: Duay Daniel																	 
.................... ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... == Description 	:  	Permet de lire la valeur du capteur incrémental du moteur 
.................... ==					Attention n'utiliser cette fonction seulement quand le moteur est à l'arrêt, sinon il y a un risque de faire planter la communication I2C						      	 
.................... == paramètre 	:  	Prend l'adresse du driver a atteindre 								 
.................... == retourne 	:  	signed 32bits -> la valeur actuel du capteur incrémental du moteur 
.................... ==					2147483647 -> interdiction de lire la position pendant un mouvement 
.................... ==					2147483648 -> not ready  (le slave ne répond pas)  
.................... ==				    
.................... /*===================================================================================================================================================================================================*/ 
.................... signed int32 read_pos_moteur(int8 adresse_driver) 
*
0138C:  MOV     W5,[W15++]
0138E:  CLR.B   1B5D
.................... { 
.................... 	int8 ack=0; 
.................... 	unsigned int8 buffer[4]; 
.................... 	signed int32 pos_value; 
....................  
.................... 	if (read_driver_moteur(adresse_driver) != 1) 
01390:  MOV.B   1B5C,W0L
01392:  MOV.B   W0L,1B6A
01394:  CALL    12E2
01398:  CP.B    W0L,#1
0139A:  BRA     Z,142A
.................... 		{ 
.................... 			i2c_start(); 
0139C:  BTSS.B  208.3
0139E:  BRA     13A8
013A0:  BSET.B  206.1
013A2:  BTSC.B  206.1
013A4:  BRA     13A2
013A6:  BRA     13AE
013A8:  BSET.B  206.0
013AA:  BTSC.B  206.0
013AC:  BRA     13AA
.................... 			ack = i2c_write(adresse_driver+1); 
013AE:  MOV.B   1B5C,W0L
013B0:  SE      W0,W0
013B2:  ADD     W0,#1,W0
013B4:  MOV     W0,W5
013B6:  MOV.B   W5L,W1L
013B8:  CALL    E12
013BC:  MOV.B   W0L,1B5D
.................... 			if(ack == 0) 
013BE:  MOV.B   1B5D,W0L
013C0:  SE      W0,W0
013C2:  CP0     W0
013C4:  BRA     NZ,1414
.................... 			{ 
.................... 				i2c_read(1); 
013C6:  MOV     #1,W1
013C8:  MOV     W1,[W15++]
013CA:  MOV     [--W15],W1
013CC:  CALL    12B8
.................... 				buffer[0]=i2c_read(1); 
013D0:  MOV     #1,W1
013D2:  MOV     W1,[W15++]
013D4:  MOV     [--W15],W1
013D6:  CALL    12B8
013DA:  MOV.B   W0L,1B5E
.................... 				buffer[1]=i2c_read(1); 
013DC:  MOV     #1,W1
013DE:  MOV     W1,[W15++]
013E0:  MOV     [--W15],W1
013E2:  CALL    12B8
013E6:  MOV.B   W0L,1B5F
.................... 				buffer[2]=i2c_read(1); 
013E8:  MOV     #1,W1
013EA:  MOV     W1,[W15++]
013EC:  MOV     [--W15],W1
013EE:  CALL    12B8
013F2:  MOV.B   W0L,1B60
.................... 				buffer[3]=i2c_read(0); 
013F4:  MOV     #0,W1
013F6:  MOV     W1,[W15++]
013F8:  MOV     [--W15],W1
013FA:  CALL    12B8
013FE:  MOV.B   W0L,1B61
.................... 				pos_value = make32(buffer[3],buffer[2],buffer[1],buffer[0]); 
01400:  MOV.B   1B61,W0L
01402:  MOV.B   W0L,1B65
01404:  MOV.B   1B60,W0L
01406:  MOV.B   W0L,1B64
01408:  MOV.B   1B5F,W0L
0140A:  MOV.B   W0L,1B63
0140C:  MOV.B   1B5E,W0L
0140E:  MOV.B   W0L,1B62
.................... 			} 
01410:  GOTO    141A
.................... 			else pos_value = 2147483648; 
01414:  CLR     1B62
01416:  MOV     #8000,W4
01418:  MOV     W4,1B64
.................... 		 
.................... 			i2c_stop(); 
0141A:  MOV     #1F,W0
0141C:  AND     206,W0
0141E:  BRA     NZ,141A
01420:  BSET.B  206.2
01422:  BTSC.B  206.2
01424:  BRA     1422
.................... 		} 
01426:  GOTO    1430
.................... 	else pos_value = 2147483647; 
0142A:  SETM    1B62
0142C:  MOV     #7FFF,W4
0142E:  MOV     W4,1B64
....................  
.................... 	return pos_value; 
01430:  MOV     1B62,W0
01432:  MOV     1B64,W1
01434:  MOV     [--W15],W5
01436:  RETURN  
.................... }	 
.................... 	 
.................... //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- 
....................  
.................... #include "Com_balises.c" 
.................... #ifndef Com_balises 
.................... #define Com_balises 
.................... 	 
.................... void Balise_config_plage(int8 no_plage, int8 deb_plage, int8 fin_plage) 
.................... {	 
.................... 	i2c_start(); 
*
01032:  BTSS.B  208.3
01034:  BRA     103E
01036:  BSET.B  206.1
01038:  BTSC.B  206.1
0103A:  BRA     1038
0103C:  BRA     1044
0103E:  BSET.B  206.0
01040:  BTSC.B  206.0
01042:  BRA     1040
.................... 	i2c_write(0x20);			// adresse de la balise 
01044:  MOV.B   #20,W1L
01046:  CALL    E12
.................... 	i2c_write(0x10);			// instruction de config 
0104A:  MOV.B   #10,W1L
0104C:  CALL    E12
.................... 	i2c_write(no_plage); 
01050:  MOV.B   1B54,W0L
01052:  MOV.B   W0L,2
01054:  CALL    E12
.................... 	i2c_write(deb_plage); 
01058:  MOV.B   1B55,W0L
0105A:  MOV.B   W0L,W1L
0105C:  CALL    E12
.................... 	i2c_write(fin_plage); 
01060:  MOV.B   1B56,W0L
01062:  MOV.B   W0L,2
01064:  CALL    E12
.................... 	i2c_write('@');				// fin de la communication 
01068:  MOV.B   #40,W1L
0106A:  CALL    E12
.................... 	i2c_stop(); 
0106E:  MOV     #1F,W0
01070:  AND     206,W0
01072:  BRA     NZ,106E
01074:  BSET.B  206.2
01076:  BTSC.B  206.2
01078:  BRA     1076
0107A:  RETURN  
.................... } 
....................  
.................... void Balise_set_plage(int8 select_plage) 
.................... { 
.................... 	i2c_start(); 
*
08040:  BTSS.B  208.3
08042:  BRA     804C
08044:  BSET.B  206.1
08046:  BTSC.B  206.1
08048:  BRA     8046
0804A:  BRA     8052
0804C:  BSET.B  206.0
0804E:  BTSC.B  206.0
08050:  BRA     804E
.................... 	i2c_write(0x20);			// adresse de la balise 
08052:  MOV.B   #20,W1L
08054:  CALL    E12
.................... 	i2c_write(0x80);			// instruction de set 
08058:  MOV.B   #80,W1L
0805A:  CALL    E12
.................... 	i2c_write(select_plage); 
0805E:  MOV.B   1BB0,W0L
08060:  MOV.B   W0L,2
08062:  CALL    E12
.................... 	i2c_write('@');				// fin de la communication 
08066:  MOV.B   #40,W1L
08068:  CALL    E12
.................... 	i2c_stop();	 
0806C:  MOV     #1F,W0
0806E:  AND     206,W0
08070:  BRA     NZ,806C
08072:  BSET.B  206.2
08074:  BTSC.B  206.2
08076:  BRA     8074
08078:  RETURN  
.................... } 
....................  
.................... unsigned int8 Check_balise(void) 
.................... { 
.................... 	static unsigned int8 ack_balise=0; 
....................  
.................... 	i2c_start(); 
*
09FC6:  BTSS.B  208.3
09FC8:  BRA     9FD2
09FCA:  BSET.B  206.1
09FCC:  BTSC.B  206.1
09FCE:  BRA     9FCC
09FD0:  BRA     9FD8
09FD2:  BSET.B  206.0
09FD4:  BTSC.B  206.0
09FD6:  BRA     9FD4
.................... 	ack_balise=i2c_write(0x21);			// adresse de balise en lecture 
09FD8:  MOV.B   #21,W1L
09FDA:  CALL    E12
09FDE:  MOV.B   W0L,87C
.................... 	if(ack_balise==0) 
09FE0:  CP0.B   87C
09FE2:  BRA     NZ,9FF4
.................... 	{					// si elle est dÃ©tectÃ©e - demander sa lecture 
.................... 		delay_us(30); 
09FE4:  REPEAT  #256
09FE6:  NOP     
.................... 		value_balise=i2c_read(0); 
09FE8:  MOV     #0,W1
09FEA:  MOV     W1,[W15++]
09FEC:  MOV     [--W15],W1
09FEE:  CALL    12B8
09FF2:  MOV.B   W0L,860
.................... 	} 
.................... 	i2c_stop(); 
09FF4:  MOV     #1F,W0
09FF6:  AND     206,W0
09FF8:  BRA     NZ,9FF4
09FFA:  BSET.B  206.2
09FFC:  BTSC.B  206.2
09FFE:  BRA     9FFC
....................  
.................... 	return value_balise; 
0A000:  MOV.B   860,W0L
0A002:  MOV.B   W0L,0
0A004:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Init.h" 
.................... /*()_() 
....................   (o.o) 
....................   (.)(.)*/ 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 05.03.2015																== 
.................... ===  Nom du programme 	: InterfaceRoboteQuC.mcp													== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Fonctions d'initialisation du dsPIC30F6014A.				    								== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Init 
.................... #define ___Init 
....................  
.................... //**************************************************************************************************** 
.................... //*  Défintion des bits 
.................... //*  ! Utiliser LATx pour des sorties et PORTx pour des entrées lorsque commandes succintes rapides. ! 
.................... //**************************************************************************************************** 
.................... #bit _LED1 = LATC.1			//--| 
.................... #bit _LED2 = LATC.2			//	| 
.................... #bit _LED3 = LATC.3			//	|- LEDs 
.................... #bit _LED4 = LATC.4			//	| 
....................  
.................... #bit _DEMA = PORTA.10		//--| 
.................... #bit _TEAM = PORTA.12		//	| 
.................... #bit _Capdist = PORTA.13		//	|- Digital Inputs 
.................... #bit _Dig4 = PORTA.6		//	| 
.................... #bit _ZeroPoint = PORTA.7		//  | 
.................... #bit _Dig6 = PORTA.9		//	| 
....................  
.................... #bit _Out1 = LATD.0 		//--| 
.................... #bit _Out2 = LATD.1	    //	| 
.................... #bit _Out3 = LATD.2 	 	//	| 
.................... #bit _Out4 = LATD.3 		//	|- Outputs 
.................... #bit _SERV = LATD.4		//	| 
.................... #bit _LDT1 = LATD.5 		//	| 
.................... #bit _LDT2 = LATD.6		//  | 
.................... #bit _Out8 = LATD.7		//	| 
....................  
.................... #bit _Tim1On = T1CON.15 
.................... #bit _Tim2On = T2CON.15 
.................... #bit _Tim3On = T3CON.15 
....................  
.................... #bit _I2CEN = I2CCON.15 
.................... #bit _GCEN = I2CCON.7 
....................  
.................... #bit _En_Diz = PORTB.10 
.................... #bit _EN_Uni = PORTB.11 
....................  
....................  
.................... enum{STOP,CHARGE_OBJ,DRIVER_GO,OBJ_PERSO,DRIVER_DONE,OBJ_DONE,WAIT}State=STOP; 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    __Init_dsPIC 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    30.01.2015 
.................... //  Statut :    Fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Config. et initialisation du dsPIC30F6014A. 
.................... //	Paramètre(s): / 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Init_dsPIC(void) 
.................... { 
.................... 	//------------------------------------------------------------------------------ 
.................... 	// Configuration des I/O 
.................... 	TRISA = 0b0011011011000000;		// RA6,7,9,10,12,13 : Digital Input 
*
00F7E:  MOV     #36C0,W4
00F80:  MOV     W4,2C0
.................... 	PORTA=0; 
00F82:  CLR     2C2
.................... 	TRISB = 0b0000000000111100;		// RB2-5: Analog Input 
00F84:  MOV     #3C,W4
00F86:  MOV     W4,2C6
.................... 	PORTB=0; 
00F88:  CLR     2C8
.................... 	TRISC = 0b0000000000000000;		// RC1-4: LEDs 
00F8A:  CLR     2CC
.................... 	PORTC=0; 
00F8C:  CLR     2CE
.................... 	TRISD = 0b0000000011110000;		// RD0-7: Outputs  // 2018 RD4 à RD7 utilisé en entrée 
00F8E:  MOV     #F0,W4
00F90:  MOV     W4,2D2
.................... 	PORTD=0; 
00F92:  CLR     2D4
.................... 	TRISF = 0b0000000000010100;		// RF2-5: Rx1, Tx1, Rx2, Tx2 
00F94:  MOV     #14,W4
00F96:  MOV     W4,2DE
.................... 	PORTF=0; 
00F98:  CLR     2E0
.................... 	TRISG = 0b0000000000001100;		// RG2-3: SCL-SDA 
00F9A:  MOV     #C,W4
00F9C:  MOV     W4,2E4
.................... 	PORTG=0;  
00F9E:  CLR     2E6
....................  
....................  
.................... // configuration de l'I2C 
.................... 	I2CCON = 0x800f;//LAISSER, SINON L'I2C PLANTE 
00FA0:  MOV     #800F,W4
00FA2:  MOV     W4,206
.................... //	_GCEN=0; 
.................... //	_I2CEN=1; 
.................... 	 
.................... 	// Temps de jeu 
.................... 	// Set le timer1 à 1 [ms] 
.................... 	setup_timer1(TMR_INTERNAL,0x4E20);	 
00FA4:  CLR     104
00FA6:  MOV     #4E20,W4
00FA8:  MOV     W4,102
00FAA:  MOV     #8000,W4
00FAC:  MOV     W4,104
....................  
.................... 	// Capture balise 
.................... 	// Set le timer3 avec la fréquence interne, incrément chaque 64 instructions, jusque 31250 => 100 [ms] 
.................... 	setup_timer3(TMR_INTERNAL | TMR_DIV_BY_64, 31250); 
00FAE:  CLR     112
00FB0:  MOV     #7A12,W4
00FB2:  MOV     W4,10E
00FB4:  MOV     #8020,W4
00FB6:  MOV     W4,112
.................... 	 
.................... 	// Autorise le timer1 
.................... 	enable_interrupts(INT_TIMER1); 
00FB8:  BSET.B  8C.3
.................... 	// Autorise le timer3 
.................... 	enable_interrupts(INT_TIMER3); 
00FBA:  BSET.B  8C.7
.................... 	// Interruptions RS232 
.................... 	enable_interrupts(INT_RDA2);	// Réception RS232/1 
00FBC:  BSET.B  8F.0
.................... 	// Autorise les interruptions globalement 
.................... 	enable_interrupts(INTR_GLOBAL); 
00FBE:  BCLR.B  81.7
00FC0:  CLR     42
00FC2:  BSET.B  81.7
.................... 	 
.................... 	config_driver_moteur_pid(0xC0, 200, 1, 0); 
00FC4:  MOV.B   #C0,W0L
00FC6:  MOV.B   W0L,1B54
00FC8:  MOV     #C8,W4
00FCA:  MOV     W4,1B56
00FCC:  MOV     #1,W4
00FCE:  MOV     W4,1B58
00FD0:  CLR     1B5A
00FD2:  CALL    E2A
.................... 	config_driver_moteur_pid(0xC2, 200, 1, 0); 
00FD6:  MOV.B   #C2,W0L
00FD8:  MOV.B   W0L,1B54
00FDA:  MOV     #C8,W4
00FDC:  MOV     W4,1B56
00FDE:  MOV     #1,W4
00FE0:  MOV     W4,1B58
00FE2:  CLR     1B5A
00FE4:  CALL    E2A
.................... 	delay_ms(10); 
00FE8:  MOV     #A,W0
00FEA:  CALL    EBE
.................... 	 
.................... 	config_driver_moteur(0xC0, 5000, 5000, 2000,88064);//moteur cremaillere 
00FEE:  MOV.B   #C0,W0L
00FF0:  MOV.B   W0L,1B54
00FF2:  MOV     #1388,W4
00FF4:  MOV     W4,1B56
00FF6:  MOV     #1388,W4
00FF8:  MOV     W4,1B58
00FFA:  MOV     #7D0,W4
00FFC:  MOV     W4,1B5A
00FFE:  MOV     #5800,W4
01000:  MOV     W4,1B5C
01002:  CALL    ED2
.................... 	config_driver_moteur(0xC2, 5000, 5000, 2000,11776);//moteur couronne 
01006:  MOV.B   #C2,W0L
01008:  MOV.B   W0L,1B54
0100A:  MOV     #1388,W4
0100C:  MOV     W4,1B56
0100E:  MOV     #1388,W4
01010:  MOV     W4,1B58
01012:  MOV     #7D0,W4
01014:  MOV     W4,1B5A
01016:  MOV     #2E00,W4
01018:  MOV     W4,1B5C
0101A:  CALL    ED2
.................... 	delay_ms(10); 
0101E:  MOV     #A,W0
01020:  CALL    EBE
.................... 	 
.................... 	return; 
01024:  RETURN  
.................... 	 
.................... } 
.................... 	 
.................... #endif 
....................  
.................... #include "data/___data.h" 
.................... /* 
.................... * \file ___data.h 
.................... * \brief Data pour le robot. 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.03.2016 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___data_H 
.................... #define ___data_H 
....................  
.................... 	 
.................... 	int1 Depl_send = 0; 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 	////////// Gestion erreurs 
.................... 	int1 Base = 0; 
.................... 	int16 TableWidth =3000; 
.................... 	unsigned int8 NbreZone_check = 0; 
.................... 	char RoboteQ_receiveBuffer[256]={};			// Buffer des donnÃÂ©es reÃÂ§ues 
.................... 	unsigned int8 TabSentRS232[256]={0}; 
....................  
....................  
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	//														ZONES INTERDITES 
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	 
.................... 	int intersection_found = 0; 
.................... 	int path_found = 0; 
.................... 	int path_impossible = 0; 
.................... 	int path_opposite = 0; 
.................... 	int path_tooclose = 0; 
.................... 	 
.................... 	int relay_point_number = 0; 
.................... 	int i_rel = 0; 
.................... 	int i_depl = 0; 
....................  
.................... 	int TabIntersection[10]; 
.................... 	 
.................... 	long PtsRelai[20][2] = {0}; 
....................  
.................... 	//Tableau contenant les zone interdites. Chaque zone contient {x1, y1, x4, y4} 
.................... 	//zones interdites Ã©crites directement dans le code. !! Mettre en commentaire si on les lit depuis le PC !! 
.................... 	//long TabZones[10][4] = {{100,900,1200,1200}, {500,500,1200,560}, {0,0,0,0}, {0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}}; 
.................... 	long TabZones[10][4] = {{0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}, {0,0,0,0}}; 
.................... 	long TabZonesPC[][8] = {0}; 
....................  
.................... 	//---------------------------------------------------------------------------------------------------------------------------------------------------------- 
.................... 	 
.................... 	unsigned int16 TIME_SURCHAUFFE_MS = 1000; 
.................... 	unsigned int8 Erreur_max_surchauffe = 10; 
.................... 	unsigned int32 Time_ejection = 0; 
.................... 	unsigned int32 Time_ejection_toDo = 0; 
.................... 	int1 Action_send = 0;	 
....................  
.................... 	signed int16 TabObjectifs[7][13][12] = {0}; 
....................  
.................... 	// Objectif en cours 
.................... 	signed int16 oXp=0,oYp=0,oType=0,oAvAr=0,oCoteTourn=0,oVitMax=0,Obj_Action = 0,Pt_commun = 0,Ponderation = 0,Obj_end = 0,Next_obj = 0,keep_obj = 0;	 
.................... 	 
.................... 	 
.................... 	////////// UART 
.................... 	unsigned int8 UART_WD_DELAY = 20;	// DÃ©lai du watchdog UART, en [ms]; par pas de 1 [ms] 
.................... 	unsigned int8 UART_NBR_REP_NAK = 5;	// Combien de fois maximum il faut rÃ©pÃ©ter une commande si le rÃ©cepteur n'a pas compris  
.................... 	// Adresse UART du driver 
.................... 	unsigned int32 UART_ADDR = 2; 
.................... 	 
.................... 	////////// IIC 
.................... 	// Combien de fois maximum il faut rÃ©pÃ©ter une commande si le rÃ©cepteur n'a pas compris 
.................... //	unsigned int8 IIC_NBR_REP_NAK = 5;	 
.................... 	// Combien de fois on rÃ©Ã©ssaie un envoie 
.................... //	unsigned int8 IIC_NBR_REP_ENV = 5; 
....................  	//Adresse IIC du driver 
.................... //	unsigned int8 DRIVER_IIC_ADR = 0x50; 
.................... //	unsigned int8 TabToSendIIC[60]={0}; 
....................  
.................... 	 
.................... 	////////// Balise ///////// 
.................... 	unsigned int8 MAX_VALUE_DETECT_BALISE = 3; // Valeur maximum pour la dÃ©tection de l'adversaire (action trig si <=) 
.................... 	unsigned int16 TIME_TO_CHECK_BAL=200;	// Temps avant chaque check balise 
....................  
.................... 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  
.................... // Mise en marche/arrÃªt 
.................... int1 flagMarche = 0; 
....................  
.................... // Pour le nombre d'objectifs dÃ©jÃ  enregistrÃ©s 
.................... unsigned int16 NbreObjectifs = 0; 
.................... 	// Pour connaÃ®tre le prochain objectif Ã  atteindre 
.................... unsigned int16 NextObj = 0; 
....................  
.................... ////PC 
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
*
025F0:  MOV     W5,[W15++]
025F2:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
025F4:  BCLR.B  1BE5.0
....................    y = x; 
025F6:  PUSH    1BE0
025F8:  POP     1BE6
025FA:  PUSH    1BE2
025FC:  POP     1BE8
....................  
....................    if (x < 0) 
025FE:  MOV     1BE0,W0
02600:  MOV     1BE2,W1
02602:  MOV     #0,W2
02604:  MOV     #0,W3
02606:  CALL    21EA
0260A:  BRA     NC,2618
....................    { 
....................       s = 1; 
0260C:  BSET.B  1BE5.0
....................       y = -y; 
0260E:  MOV     #1BE6,W0
02610:  MOV     #1BE6,W1
02612:  REPEAT  #3
02614:  MOV     [W0++],[W1++]
02616:  BTG.B   1BE9.7
....................    } 
....................  
....................    if (y <= 32768.0) 
02618:  MOV     1BE6,W0
0261A:  MOV     1BE8,W1
0261C:  MOV     #0,W2
0261E:  MOV     #4700,W3
02620:  CALL    21EA
02624:  BRA     C,2628
02626:  BRA     NZ,263C
....................       res = (float32)(unsigned int16)y; 
02628:  MOV     1BE6,W0
0262A:  MOV     1BE8,W1
0262C:  CALL    231C
02630:  CALL    2348
02634:  MOV     W0,1BEA
02636:  MOV     W1,1BEC
02638:  GOTO    26D0
....................  
....................  else if (y < 10000000.0) 
0263C:  MOV     1BE6,W0
0263E:  MOV     1BE8,W1
02640:  MOV     #9680,W2
02642:  MOV     #4B18,W3
02644:  CALL    21EA
02648:  BRA     NC,26C8
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
0264A:  MOV     1BE6,W0
0264C:  MOV     1BE8,W1
0264E:  MOV     #0,W2
02650:  MOV     #3800,W3
02652:  CALL    2382
02656:  CALL    231C
0265A:  MOV     W0,1BEE
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
0265C:  MOV     1BE6,W0
0265E:  MOV     1BE8,W1
02660:  MOV     #0,W2
02662:  MOV     #3800,W3
02664:  CALL    2382
02668:  MOV     W0,W5
0266A:  MOV     W1,W6
0266C:  MOV     1BEE,W0
0266E:  CALL    2348
02672:  BSET.B  43.0
02674:  MOV     W0,W2
02676:  MOV     W1,W3
02678:  MOV     W5,W0
0267A:  MOV     W6,W1
0267C:  CALL    2446
02680:  MOV     W0,W2
02682:  MOV     W1,W3
02684:  MOV     #0,W0
02686:  MOV     #4700,W1
02688:  CALL    2382
0268C:  MOV     W0,1BE6
0268E:  MOV     W1,1BE8
....................       res = 32768.0*(float32)l; 
02690:  MOV     1BEE,W0
02692:  CALL    2348
02696:  MOV     W0,W2
02698:  MOV     W1,W3
0269A:  MOV     #0,W0
0269C:  MOV     #4700,W1
0269E:  CALL    2382
026A2:  MOV     W0,1BEA
026A4:  MOV     W1,1BEC
....................       res += (float32)(unsigned int16)y; 
026A6:  MOV     1BE6,W0
026A8:  MOV     1BE8,W1
026AA:  CALL    231C
026AE:  CALL    2348
026B2:  BCLR.B  43.0
026B4:  MOV     W0,W2
026B6:  MOV     W1,W3
026B8:  MOV     1BEA,W0
026BA:  MOV     1BEC,W1
026BC:  CALL    2446
026C0:  MOV     W0,1BEA
026C2:  MOV     W1,1BEC
....................    } 
026C4:  GOTO    26D0
....................  
....................  else 
....................   res = y; 
026C8:  PUSH    1BE6
026CA:  POP     1BEA
026CC:  PUSH    1BE8
026CE:  POP     1BEC
....................  
....................  y = y - (float32)(unsigned int16)y; 
026D0:  MOV     1BE6,W0
026D2:  MOV     1BE8,W1
026D4:  CALL    231C
026D8:  CALL    2348
026DC:  BSET.B  43.0
026DE:  MOV     W0,W2
026E0:  MOV     W1,W3
026E2:  MOV     1BE6,W0
026E4:  MOV     1BE8,W1
026E6:  CALL    2446
026EA:  MOV     W0,1BE6
026EC:  MOV     W1,1BE8
....................  
....................  if (s) 
026EE:  BTSS.B  1BE5.0
026F0:  BRA     26FC
....................   res = -res; 
026F2:  MOV     #1BEA,W0
026F4:  MOV     #1BEA,W1
026F6:  REPEAT  #3
026F8:  MOV     [W0++],[W1++]
026FA:  BTG.B   1BED.7
....................  
....................  if (y != 0) 
026FC:  MOV     1BE6,W0
026FE:  MOV     1BE8,W1
02700:  MOV     #0,W2
02702:  MOV     #0,W3
02704:  CALL    21EA
02708:  BRA     Z,2740
....................  { 
....................   if (s == 1 && n == 0) 
0270A:  BTSS.B  1BE5.0
0270C:  BRA     2724
0270E:  CP0.B   1BE4
02710:  BRA     NZ,2724
....................    res -= 1.0; 
02712:  BSET.B  43.0
02714:  MOV     1BEA,W0
02716:  MOV     1BEC,W1
02718:  MOV     #0,W2
0271A:  MOV     #3F80,W3
0271C:  CALL    2446
02720:  MOV     W0,1BEA
02722:  MOV     W1,1BEC
....................  
....................   if (s == 0 && n == 1) 
02724:  BTSC.B  1BE5.0
02726:  BRA     2740
02728:  MOV     1BE4,W4
0272A:  CP.B    W4L,#1
0272C:  BRA     NZ,2740
....................    res += 1.0; 
0272E:  BCLR.B  43.0
02730:  MOV     1BEA,W0
02732:  MOV     1BEC,W1
02734:  MOV     #0,W2
02736:  MOV     #3F80,W3
02738:  CALL    2446
0273C:  MOV     W0,1BEA
0273E:  MOV     W1,1BEC
....................  } 
....................  if (x == 0) 
02740:  MOV     1BE0,W0
02742:  MOV     1BE2,W1
02744:  MOV     #0,W2
02746:  MOV     #0,W3
02748:  CALL    21EA
0274C:  BRA     NZ,2752
....................     res = 0; 
0274E:  CLR     1BEA
02750:  CLR     1BEC
....................  
....................  return (res); 
02752:  MOV     1BEA,W0
02754:  MOV     1BEC,W1
02756:  MOV     [--W15],W6
02758:  MOV     [--W15],W5
0275A:  RETURN  
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
*
02770:  CLR.B   1BE4
02772:  PUSH    1BD4
02774:  POP     1BE0
02776:  PUSH    1BD6
02778:  POP     1BE2
0277A:  CALL    25F0
0277E:  MOV.D   W0,W0
02780:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
*
0275C:  MOV.B   #1,W0L
0275E:  MOV.B   W0L,1BE4
02760:  PUSH    1BD4
02762:  POP     1BE0
02764:  PUSH    1BD6
02766:  POP     1BE2
02768:  CALL    25F0
0276C:  MOV.D   W0,W0
0276E:  RETURN  
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
*
02782:  MOV     W5,[W15++]
02784:  MOV     W6,[W15++]
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
02786:  MOV     1BBE,W0
02788:  MOV     1BC0,W1
0278A:  MOV     #0,W2
0278C:  MOV     #0,W3
0278E:  CALL    21EA
02792:  BRA     Z,280C
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
02794:  MOV     1BBA,W0
02796:  MOV     1BBC,W1
02798:  MOV     1BBE,W2
0279A:  MOV     1BC0,W3
0279C:  CALL    2252
027A0:  MOV     W0,W5
027A2:  MOV     W1,W6
027A4:  MOV     W5,W0
027A6:  MOV     W6,W1
027A8:  MOV     #0,W2
027AA:  MOV     #0,W3
027AC:  CALL    21EA
027B0:  BRA     NC,27CE
027B2:  MOV     1BBA,W0
027B4:  MOV     1BBC,W1
027B6:  MOV     1BBE,W2
027B8:  MOV     1BC0,W3
027BA:  CALL    2252
027BE:  MOV     W0,W5
027C0:  MOV     W1,W6
027C2:  MOV     W5,1BD4
027C4:  MOV     W6,1BD6
027C6:  CALL    275C
027CA:  GOTO    27E6
027CE:  MOV     1BBA,W0
027D0:  MOV     1BBC,W1
027D2:  MOV     1BBE,W2
027D4:  MOV     1BC0,W3
027D6:  CALL    2252
027DA:  MOV     W0,W5
027DC:  MOV     W1,W6
027DE:  MOV     W5,1BD4
027E0:  MOV     W6,1BD6
027E2:  CALL    2770
027E6:  MOV     W0,1BC2
027E8:  MOV     W1,1BC4
....................       return(x-(i*y)); 
027EA:  MOV     1BC2,W0
027EC:  MOV     1BC4,W1
027EE:  MOV     1BBE,W2
027F0:  MOV     1BC0,W3
027F2:  CALL    2382
027F6:  BSET.B  43.0
027F8:  MOV     W0,W2
027FA:  MOV     W1,W3
027FC:  MOV     1BBA,W0
027FE:  MOV     1BBC,W1
02800:  CALL    2446
02804:  MOV.D   W0,W0
02806:  BRA     280C
....................    } 
02808:  GOTO    280C
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
0280C:  MOV     [--W15],W6
0280E:  MOV     [--W15],W5
02810:  RETURN  
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
*
029C4:  MOV     W5,[W15++]
029C6:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
029C8:  MOV     1BBA,W0
029CA:  MOV     1BBC,W1
029CC:  MOV     #AA3B,W2
029CE:  MOV     #3FB8,W3
029D0:  CALL    2382
029D4:  CALL    231C
029D8:  MOV.B   W0L,1BCB
....................    s = 0; 
029DA:  BCLR.B  1BCC.0
....................    y = x; 
029DC:  PUSH    1BBA
029DE:  POP     1BBE
029E0:  PUSH    1BBC
029E2:  POP     1BC0
....................  
....................    if (x < 0) 
029E4:  MOV     1BBA,W0
029E6:  MOV     1BBC,W1
029E8:  MOV     #0,W2
029EA:  MOV     #0,W3
029EC:  CALL    21EA
029F0:  BRA     NC,2A08
....................    { 
....................       s = 1; 
029F2:  BSET.B  1BCC.0
....................       n = -n; 
029F4:  MOV     #0,W4
029F6:  MOV     1BCA,W3
029F8:  LSR     W3,#8,W3
029FA:  SUB.B   W4L,W3L,W0L
029FC:  MOV.B   W0L,1BCB
....................       y = -y; 
029FE:  MOV     #1BBE,W0
02A00:  MOV     #1BBE,W1
02A02:  REPEAT  #3
02A04:  MOV     [W0++],[W1++]
02A06:  BTG.B   1BC1.7
....................    } 
....................  
....................    res = 0.0; 
02A08:  CLR     1BC2
02A0A:  CLR     1BC4
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
02A0C:  MOV.B   1BCB,W0L
02A0E:  SE      W0,W0
02A10:  ADD     #7F,W0
02A12:  MOV.B   W0L,1BCA
....................    if(bit_test(data1,0)) 
02A14:  BTSS.B  1BCA.0
02A16:  BRA     2A26
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
02A18:  MOV     #1BC2,W5
02A1A:  ADD     W5,#2,W5
02A1C:  MOV     W5,W0
02A1E:  MOV     W0,W5
02A20:  MOV.B   [W5],W4L
02A22:  IOR.B   #80,W4L
02A24:  MOV.B   W4L,[W5+#0]
....................    rotate_right(&data1,1); 
02A26:  MOV     #1BCA,W1
02A28:  RRNC.B  [W1],[W1--]
....................    bit_clear(data1,7); 
02A2A:  MOV     #1BCA,W4
02A2C:  BCLR    [W4].7
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
02A2E:  MOV     #1BC2,W5
02A30:  ADD     W5,#3,W5
02A32:  MOV     W5,W0
02A34:  MOV     W0,W5
02A36:  MOV     1BCA,W0
02A38:  MOV.B   W0L,[W5+#0]
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
02A3A:  MOV     1BBE,W0
02A3C:  MOV     1BC0,W1
02A3E:  MOV     #AA3B,W2
02A40:  MOV     #3FB8,W3
02A42:  CALL    2382
02A46:  MOV     W0,W5
02A48:  MOV     W1,W6
02A4A:  MOV.B   1BCB,W0L
02A4C:  SE      W0,W0
02A4E:  CALL    21A0
02A52:  BSET.B  43.0
02A54:  MOV     W0,W2
02A56:  MOV     W1,W3
02A58:  MOV     W5,W0
02A5A:  MOV     W6,W1
02A5C:  CALL    2446
02A60:  MOV     W0,1BBE
02A62:  MOV     W1,1BC0
....................  
....................    r = pe[0]*y + pe[1]; 
02A64:  MOV     #887C,W0
02A66:  MOV     #3959,W1
02A68:  MOV     1BBE,W2
02A6A:  MOV     1BC0,W3
02A6C:  CALL    2382
02A70:  MOV     W0,W5
02A72:  MOV     W1,W6
02A74:  BCLR.B  43.0
02A76:  MOV     W5,W0
02A78:  MOV     W6,W1
02A7A:  MOV     #97E0,W2
02A7C:  MOV     #3AA6,W3
02A7E:  CALL    2446
02A82:  MOV     W0,1BC6
02A84:  MOV     W1,1BC8
....................    r = r*y + pe[2]; 
02A86:  MOV     1BC6,W0
02A88:  MOV     1BC8,W1
02A8A:  MOV     1BBE,W2
02A8C:  MOV     1BC0,W3
02A8E:  CALL    2382
02A92:  MOV     W0,W5
02A94:  MOV     W1,W6
02A96:  BCLR.B  43.0
02A98:  MOV     W5,W0
02A9A:  MOV     W6,W1
02A9C:  MOV     #1DC4,W2
02A9E:  MOV     #3C1E,W3
02AA0:  CALL    2446
02AA4:  MOV     W0,1BC6
02AA6:  MOV     W1,1BC8
....................    r = r*y + pe[3]; 
02AA8:  MOV     1BC6,W0
02AAA:  MOV     1BC8,W1
02AAC:  MOV     1BBE,W2
02AAE:  MOV     1BC0,W3
02AB0:  CALL    2382
02AB4:  MOV     W0,W5
02AB6:  MOV     W1,W6
02AB8:  BCLR.B  43.0
02ABA:  MOV     W5,W0
02ABC:  MOV     W6,W1
02ABE:  MOV     #505E,W2
02AC0:  MOV     #3D63,W3
02AC2:  CALL    2446
02AC6:  MOV     W0,1BC6
02AC8:  MOV     W1,1BC8
....................    r = r*y + pe[4]; 
02ACA:  MOV     1BC6,W0
02ACC:  MOV     1BC8,W1
02ACE:  MOV     1BBE,W2
02AD0:  MOV     1BC0,W3
02AD2:  CALL    2382
02AD6:  MOV     W0,W5
02AD8:  MOV     W1,W6
02ADA:  BCLR.B  43.0
02ADC:  MOV     W5,W0
02ADE:  MOV     W6,W1
02AE0:  MOV     #FE1A,W2
02AE2:  MOV     #3E75,W3
02AE4:  CALL    2446
02AE8:  MOV     W0,1BC6
02AEA:  MOV     W1,1BC8
....................    r = r*y + pe[5]; 
02AEC:  MOV     1BC6,W0
02AEE:  MOV     1BC8,W1
02AF0:  MOV     1BBE,W2
02AF2:  MOV     1BC0,W3
02AF4:  CALL    2382
02AF8:  MOV     W0,W5
02AFA:  MOV     W1,W6
02AFC:  BCLR.B  43.0
02AFE:  MOV     W5,W0
02B00:  MOV     W6,W1
02B02:  MOV     #7218,W2
02B04:  MOV     #3F31,W3
02B06:  CALL    2446
02B0A:  MOV     W0,1BC6
02B0C:  MOV     W1,1BC8
....................  
....................    res = res*(1.0 + y*r); 
02B0E:  MOV     1BBE,W0
02B10:  MOV     1BC0,W1
02B12:  MOV     1BC6,W2
02B14:  MOV     1BC8,W3
02B16:  CALL    2382
02B1A:  BCLR.B  43.0
02B1C:  MOV     W0,W2
02B1E:  MOV     W1,W3
02B20:  MOV     #0,W0
02B22:  MOV     #3F80,W1
02B24:  CALL    2446
02B28:  MOV     W0,W2
02B2A:  MOV     W1,W3
02B2C:  MOV     1BC2,W0
02B2E:  MOV     1BC4,W1
02B30:  CALL    2382
02B34:  MOV     W0,1BC2
02B36:  MOV     W1,1BC4
....................  
....................    if (s) 
02B38:  BTSS.B  1BCC.0
02B3A:  BRA     2B4C
....................       res = 1.0/res; 
02B3C:  MOV     #0,W0
02B3E:  MOV     #3F80,W1
02B40:  MOV     1BC2,W2
02B42:  MOV     1BC4,W3
02B44:  CALL    2252
02B48:  MOV     W0,1BC2
02B4A:  MOV     W1,1BC4
....................    return(res); 
02B4C:  MOV     1BC2,W0
02B4E:  MOV     1BC4,W1
02B50:  MOV     [--W15],W6
02B52:  MOV     [--W15],W5
02B54:  RETURN  
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
*
02812:  MOV     W5,[W15++]
02814:  MOV     W6,[W15++]
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
02816:  PUSH    1BBA
02818:  POP     1BBE
0281A:  PUSH    1BBC
0281C:  POP     1BC0
....................  
....................    if (y != 1.0) 
0281E:  MOV     1BBE,W0
02820:  MOV     1BC0,W1
02822:  MOV     #0,W2
02824:  MOV     #3F80,W3
02826:  CALL    21EA
0282A:  BRA     Z,29B6
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
0282C:  MOV     #1BBE,W5
0282E:  ADD     W5,#3,W5
02830:  MOV     W5,W0
02832:  MOV     W0,[W15++]
02834:  MOV.B   [W0],W0L
02836:  MOV.B   W0L,1BCF
02838:  MOV     [--W15],W0
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
0283A:  MOV     #1BBE,W5
0283C:  ADD     W5,#3,W5
0283E:  MOV     W5,W0
02840:  MOV     W0,W5
02842:  MOV.B   #3F,W0L
02844:  MOV.B   W0L,[W5]
....................    data1 = *(((unsigned int8 *)(&y))+2); 
02846:  MOV     #1BBE,W5
02848:  ADD     W5,#2,W5
0284A:  MOV     W5,W0
0284C:  MOV     1BCE,W4
0284E:  MOV.B   [W0+#0],W4L
02850:  MOV     W4,1BCE
....................    bit_clear(data1,7); 
02852:  MOV     #1BCE,W4
02854:  BCLR    [W4].7
....................    *(((unsigned int8 *)(&y))+2) = data1; 
02856:  MOV     #1BBE,W5
02858:  ADD     W5,#2,W5
0285A:  MOV     W5,W0
0285C:  MOV     W0,W5
0285E:  MOV     1BCE,W0
02860:  MOV.B   W0L,[W5+#0]
....................    if(bit_test(data2,7)) 
02862:  BTSS.B  1BCF.7
02864:  BRA     2874
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
02866:  MOV     #1BBE,W5
02868:  ADD     W5,#3,W5
0286A:  MOV     W5,W0
0286C:  MOV     W0,W5
0286E:  MOV.B   [W5],W4L
02870:  IOR.B   #80,W4L
02872:  MOV.B   W4L,[W5+#0]
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
02874:  BSET.B  43.0
02876:  MOV     1BBE,W0
02878:  MOV     1BC0,W1
0287A:  MOV     #0,W2
0287C:  MOV     #3F80,W3
0287E:  CALL    2446
02882:  MOV     W0,W5
02884:  MOV     W1,W6
02886:  BCLR.B  43.0
02888:  MOV     1BBE,W0
0288A:  MOV     1BC0,W1
0288C:  MOV     #0,W2
0288E:  MOV     #3F80,W3
02890:  CALL    2446
02894:  MOV     W0,W2
02896:  MOV     W1,W3
02898:  MOV     W5,W0
0289A:  MOV     W6,W1
0289C:  CALL    2252
028A0:  MOV     W0,1BBE
028A2:  MOV     W1,1BC0
....................  
....................       y2=y*y; 
028A4:  MOV     1BBE,W0
028A6:  MOV     1BC0,W1
028A8:  MOV     1BBE,W2
028AA:  MOV     1BC0,W3
028AC:  CALL    2382
028B0:  MOV     W0,1BCA
028B2:  MOV     W1,1BCC
....................  
....................       res = pl[0]*y2 + pl[1]; 
028B4:  MOV     #4799,W0
028B6:  MOV     #BF8A,W1
028B8:  MOV     1BCA,W2
028BA:  MOV     1BCC,W3
028BC:  CALL    2382
028C0:  MOV     W0,W5
028C2:  MOV     W1,W6
028C4:  BCLR.B  43.0
028C6:  MOV     W5,W0
028C8:  MOV     W6,W1
028CA:  MOV     #0,W2
028CC:  MOV     #4000,W3
028CE:  CALL    2446
028D2:  MOV     W0,1BC2
028D4:  MOV     W1,1BC4
....................  
....................       r = ql[0]*y2 + ql[1]; 
028D6:  MOV     #F34C,W0
028D8:  MOV     #3DBA,W1
028DA:  MOV     1BCA,W2
028DC:  MOV     1BCC,W3
028DE:  CALL    2382
028E2:  MOV     W0,W5
028E4:  MOV     W1,W6
028E6:  BCLR.B  43.0
028E8:  MOV     W5,W0
028EA:  MOV     W6,W1
028EC:  MOV     #9D2B,W2
028EE:  MOV     #BF5F,W3
028F0:  CALL    2446
028F4:  MOV     W0,1BC6
028F6:  MOV     W1,1BC8
....................       r = r*y2 + 1.0; 
028F8:  MOV     1BC6,W0
028FA:  MOV     1BC8,W1
028FC:  MOV     1BCA,W2
028FE:  MOV     1BCC,W3
02900:  CALL    2382
02904:  MOV     W0,W5
02906:  MOV     W1,W6
02908:  BCLR.B  43.0
0290A:  MOV     W5,W0
0290C:  MOV     W6,W1
0290E:  MOV     #0,W2
02910:  MOV     #3F80,W3
02912:  CALL    2446
02916:  MOV     W0,1BC6
02918:  MOV     W1,1BC8
....................  
....................       res = y*res/r; 
0291A:  MOV     1BBE,W0
0291C:  MOV     1BC0,W1
0291E:  MOV     1BC2,W2
02920:  MOV     1BC4,W3
02922:  CALL    2382
02926:  MOV     W0,W5
02928:  MOV     W1,W6
0292A:  MOV     W5,W0
0292C:  MOV     W6,W1
0292E:  MOV     1BC6,W2
02930:  MOV     1BC8,W3
02932:  CALL    2252
02936:  MOV     W0,1BC2
02938:  MOV     W1,1BC4
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
0293A:  MOV     #1BBA,W5
0293C:  ADD     W5,#3,W5
0293E:  MOV     W5,W0
02940:  MOV     1BCE,W4
02942:  MOV.B   [W0+#0],W4L
02944:  MOV     W4,1BCE
....................     rotate_left(&data1,1); 
02946:  MOV     #1BCE,W1
02948:  RLNC.B  [W1],[W1++]
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
0294A:  MOV     #1BBA,W5
0294C:  ADD     W5,#2,W5
0294E:  MOV     W5,W0
02950:  MOV     W0,[W15++]
02952:  MOV.B   [W0],W0L
02954:  MOV.B   W0L,1BCF
02956:  MOV     [--W15],W0
....................     if(bit_test (data2,7)) 
02958:  BTSS.B  1BCF.7
0295A:  BRA     2960
....................       bit_set(data1,0); 
0295C:  MOV     #1BCE,W4
0295E:  BSET    [W4].0
....................     n = data1 - 0x7E; 
02960:  MOV     1BCE,W4
02962:  CLR.B   9
02964:  MOV     #7E,W3
02966:  SUB     W4,W3,W0
02968:  MOV.B   W0L,1BD0
.................... #endif 
....................  
....................       if (n<0)  
0296A:  MOV.B   1BD0,W0L
0296C:  SE      W0,W0
0296E:  CP      W0,#0
02970:  BRA     GE,2988
....................          r = -(float32)-n; 
02972:  MOV     #0,W4
02974:  MOV     1BD0,W3
02976:  SUB.B   W4L,W3L,W0L
02978:  SE      W0,W0
0297A:  CALL    21A0
0297E:  MOV     W0,1BC6
02980:  MOV     W1,1BC8
02982:  BTG.B   1BC9.7
02984:  GOTO    2994
....................       else 
....................          r = (float32)n; 
02988:  MOV.B   1BD0,W0L
0298A:  SE      W0,W0
0298C:  CALL    21A0
02990:  MOV     W0,1BC6
02992:  MOV     W1,1BC8
....................  
....................       res += r*LN2; 
02994:  MOV     1BC6,W0
02996:  MOV     1BC8,W1
02998:  MOV     #7218,W2
0299A:  MOV     #3F31,W3
0299C:  CALL    2382
029A0:  BCLR.B  43.0
029A2:  MOV     W0,W2
029A4:  MOV     W1,W3
029A6:  MOV     1BC2,W0
029A8:  MOV     1BC4,W1
029AA:  CALL    2446
029AE:  MOV     W0,1BC2
029B0:  MOV     W1,1BC4
....................    } 
029B2:  GOTO    29BA
....................  
....................    else 
....................       res = 0.0; 
029B6:  CLR     1BC2
029B8:  CLR     1BC4
....................  
....................    return(res); 
029BA:  MOV     1BC2,W0
029BC:  MOV     1BC4,W1
029BE:  MOV     [--W15],W6
029C0:  MOV     [--W15],W5
029C2:  RETURN  
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
*
02B56:  MOV     W5,[W15++]
02B58:  MOV     W6,[W15++]
02B5A:  MOV     W7,[W15++]
02B5C:  MOV     W8,[W15++]
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
02B5E:  MOV     1BA6,W0
02B60:  MOV     1BA8,W1
02B62:  MOV     #0,W2
02B64:  MOV     #0,W3
02B66:  CALL    21EA
02B6A:  BRA     NC,2C1C
02B6C:  PUSH    1BAA
02B6E:  POP     1BBA
02B70:  PUSH    1BAC
02B72:  POP     1BBC
02B74:  CLR     1BBE
02B76:  MOV     #3F80,W4
02B78:  MOV     W4,1BC0
02B7A:  CALL    2782
02B7E:  MOV     W0,W7
02B80:  MOV     W1,W8
02B82:  MOV     W7,W0
02B84:  MOV     W8,W1
02B86:  MOV     #0,W2
02B88:  MOV     #0,W3
02B8A:  CALL    21EA
02B8E:  BRA     NZ,2C1C
....................       if(fmod(y, 2) == 0) { 
02B90:  PUSH    1BAA
02B92:  POP     1BBA
02B94:  PUSH    1BAC
02B96:  POP     1BBC
02B98:  CLR     1BBE
02B9A:  MOV     #4000,W4
02B9C:  MOV     W4,1BC0
02B9E:  CALL    2782
02BA2:  MOV     W0,W7
02BA4:  MOV     W1,W8
02BA6:  MOV     W7,W0
02BA8:  MOV     W8,W1
02BAA:  MOV     #0,W2
02BAC:  MOV     #0,W3
02BAE:  CALL    21EA
02BB2:  BRA     NZ,2BE6
....................          return (exp(log(-x) * y)); 
02BB4:  MOV     1BA6,W5
02BB6:  MOV     1BA8,W6
02BB8:  BTG     W6.F
02BBA:  MOV     W5,1BBA
02BBC:  MOV     W6,1BBC
02BBE:  CALL    2812
02BC2:  MOV     W0,W5
02BC4:  MOV     W1,W6
02BC6:  MOV     W5,W0
02BC8:  MOV     W6,W1
02BCA:  MOV     1BAA,W2
02BCC:  MOV     1BAC,W3
02BCE:  CALL    2382
02BD2:  MOV     W0,W5
02BD4:  MOV     W1,W6
02BD6:  MOV     W5,1BBA
02BD8:  MOV     W6,1BBC
02BDA:  CALL    29C4
02BDE:  MOV.D   W0,W0
02BE0:  BRA     2CA2
....................       } else { 
02BE2:  GOTO    2C18
....................          return (-exp(log(-x) * y)); 
02BE6:  MOV     1BA6,W5
02BE8:  MOV     1BA8,W6
02BEA:  BTG     W6.F
02BEC:  MOV     W5,1BBA
02BEE:  MOV     W6,1BBC
02BF0:  CALL    2812
02BF4:  MOV     W0,W5
02BF6:  MOV     W1,W6
02BF8:  MOV     W5,W0
02BFA:  MOV     W6,W1
02BFC:  MOV     1BAA,W2
02BFE:  MOV     1BAC,W3
02C00:  CALL    2382
02C04:  MOV     W0,W5
02C06:  MOV     W1,W6
02C08:  MOV     W5,1BBA
02C0A:  MOV     W6,1BBC
02C0C:  CALL    29C4
02C10:  MOV.D   W0,W0
02C12:  BTG     W1.F
02C14:  MOV.D   W0,W0
02C16:  BRA     2CA2
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
02C18:  GOTO    2CA2
02C1C:  MOV     1BA6,W0
02C1E:  MOV     1BA8,W1
02C20:  MOV     #0,W2
02C22:  MOV     #0,W3
02C24:  CALL    21EA
02C28:  BRA     NC,2C58
02C2A:  PUSH    1BAA
02C2C:  POP     1BBA
02C2E:  PUSH    1BAC
02C30:  POP     1BBC
02C32:  CLR     1BBE
02C34:  MOV     #3F80,W4
02C36:  MOV     W4,1BC0
02C38:  CALL    2782
02C3C:  MOV     W0,W7
02C3E:  MOV     W1,W8
02C40:  MOV     W7,W0
02C42:  MOV     W8,W1
02C44:  MOV     #0,W2
02C46:  MOV     #0,W3
02C48:  CALL    21EA
02C4C:  BRA     Z,2C58
....................       return 0; 
02C4E:  MOV     #0,W0
02C50:  MOV     #0,W1
02C52:  BRA     2CA2
....................    } else { 
02C54:  GOTO    2CA2
....................       if(x != 0 || 0 >= y) { 
02C58:  MOV     1BA6,W0
02C5A:  MOV     1BA8,W1
02C5C:  MOV     #0,W2
02C5E:  MOV     #0,W3
02C60:  CALL    21EA
02C64:  BRA     NZ,2C76
02C66:  MOV     1BAA,W0
02C68:  MOV     1BAC,W1
02C6A:  MOV     #0,W2
02C6C:  MOV     #0,W3
02C6E:  CALL    21EA
02C72:  BRA     C,2C76
02C74:  BRA     NZ,2CA2
....................          return (exp(log(x) * y)); 
02C76:  PUSH    1BA6
02C78:  POP     1BBA
02C7A:  PUSH    1BA8
02C7C:  POP     1BBC
02C7E:  CALL    2812
02C82:  MOV     W0,W5
02C84:  MOV     W1,W6
02C86:  MOV     W5,W0
02C88:  MOV     W6,W1
02C8A:  MOV     1BAA,W2
02C8C:  MOV     1BAC,W3
02C8E:  CALL    2382
02C92:  MOV     W0,W5
02C94:  MOV     W1,W6
02C96:  MOV     W5,1BBA
02C98:  MOV     W6,1BBC
02C9A:  CALL    29C4
02C9E:  MOV.D   W0,W0
02CA0:  BRA     2CA2
....................       } 
....................    } 
02CA2:  MOV     [--W15],W8
02CA4:  MOV     [--W15],W7
02CA6:  MOV     [--W15],W6
02CA8:  MOV     [--W15],W5
02CAA:  RETURN  
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
02CAC:  MOV     W5,[W15++]
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
02CAE:  MOV     1BA2,W0
02CB0:  MOV     1BA4,W1
02CB2:  MOV     #0,W2
02CB4:  MOV     #0,W3
02CB6:  CALL    21EA
02CBA:  BRA     C,2CBE
02CBC:  BRA     NZ,2CC4
....................       return(0.0); 
02CBE:  MOV     #0,W0
02CC0:  MOV     #0,W1
02CC2:  BRA     2DB2
....................  
....................    y=x; 
02CC4:  PUSH    1BA2
02CC6:  POP     1BA6
02CC8:  PUSH    1BA4
02CCA:  POP     1BA8
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
02CCC:  MOV     #1BA6,W5
02CCE:  ADD     W5,#3,W5
02CD0:  MOV     W5,1BB2
....................     data1 = *(((unsigned int8 *)(&y))+3); 
02CD2:  MOV     #1BA6,W5
02CD4:  ADD     W5,#3,W5
02CD6:  MOV     W5,W0
02CD8:  MOV     1BAE,W4
02CDA:  MOV.B   [W0+#0],W4L
02CDC:  MOV     W4,1BAE
02CDE:  CLR.B   1BAF
....................     data2 = *(((unsigned int8 *)(&y))+2); 
02CE0:  MOV     #1BA6,W5
02CE2:  ADD     W5,#2,W5
02CE4:  MOV     W5,W0
02CE6:  MOV     1BB0,W4
02CE8:  MOV.B   [W0+#0],W4L
02CEA:  MOV     W4,1BB0
02CEC:  CLR.B   1BB1
....................     rotate_left(&data1,1);     
02CEE:  MOV     #1BAE,W1
02CF0:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7))     
02CF2:  BTSS.B  1BB0.7
02CF4:  BRA     2CFA
....................        bit_set(data1,0);     
02CF6:  MOV     #1BAE,W4
02CF8:  BSET    [W4].0
....................     data1 = ((data1+127) >>1); 
02CFA:  MOV     #7F,W4
02CFC:  MOV     1BAE,W3
02CFE:  ADD     W3,W4,W5
02D00:  MOV     W5,1BAE
02D02:  LSR     1BAE
....................     bit_clear(data2,7); 
02D04:  MOV     #1BB0,W4
02D06:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
02D08:  BTSS.B  1BAE.0
02D0A:  BRA     2D10
....................        bit_set(data2,7); 
02D0C:  MOV     #1BB0,W4
02D0E:  BSET    [W4].7
....................     data1 = data1 >>1; 
02D10:  LSR     1BAE
....................     *(((unsigned int8 *)(&y))+3) = data1; 
02D12:  MOV     #1BA6,W5
02D14:  ADD     W5,#3,W5
02D16:  MOV     W5,W0
02D18:  MOV     W0,W5
02D1A:  MOV     1BAE,W0
02D1C:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
02D1E:  MOV     #1BA6,W5
02D20:  ADD     W5,#2,W5
02D22:  MOV     W5,W0
02D24:  MOV     W0,W5
02D26:  MOV     1BB0,W0
02D28:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
02D2A:  PUSH    1BA6
02D2C:  POP     1BAA
02D2E:  PUSH    1BA8
02D30:  POP     1BAC
....................       y+=(x/y); 
02D32:  MOV     1BA2,W0
02D34:  MOV     1BA4,W1
02D36:  MOV     1BA6,W2
02D38:  MOV     1BA8,W3
02D3A:  CALL    2252
02D3E:  BCLR.B  43.0
02D40:  MOV     W0,W2
02D42:  MOV     W1,W3
02D44:  MOV     1BA6,W0
02D46:  MOV     1BA8,W1
02D48:  CALL    2446
02D4C:  MOV     W0,1BA6
02D4E:  MOV     W1,1BA8
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
02D50:  MOV     #1BA6,W5
02D52:  ADD     W5,#3,W5
02D54:  MOV     W5,W0
02D56:  MOV     1BAE,W4
02D58:  MOV.B   [W0+#0],W4L
02D5A:  MOV     W4,1BAE
02D5C:  CLR.B   1BAF
....................     data2 = *(((unsigned int8 *)(&y))+2); 
02D5E:  MOV     #1BA6,W5
02D60:  ADD     W5,#2,W5
02D62:  MOV     W5,W0
02D64:  MOV     1BB0,W4
02D66:  MOV.B   [W0+#0],W4L
02D68:  MOV     W4,1BB0
02D6A:  CLR.B   1BB1
....................     rotate_left(&data1,1); 
02D6C:  MOV     #1BAE,W1
02D6E:  RLNC.B  [W1],[W1++]
....................     if(bit_test(data2,7)) 
02D70:  BTSS.B  1BB0.7
02D72:  BRA     2D78
....................        bit_set(data1,0);     
02D74:  MOV     #1BAE,W4
02D76:  BSET    [W4].0
....................     data1--; 
02D78:  DEC     1BAE
....................     bit_clear(data2,7); 
02D7A:  MOV     #1BB0,W4
02D7C:  BCLR    [W4].7
....................     if(bit_test(data1,0)) 
02D7E:  BTSS.B  1BAE.0
02D80:  BRA     2D86
....................        bit_set(data2,7); 
02D82:  MOV     #1BB0,W4
02D84:  BSET    [W4].7
....................     data1 = data1 >>1; 
02D86:  LSR     1BAE
....................     *(((unsigned int8 *)(&y))+3) = data1; 
02D88:  MOV     #1BA6,W5
02D8A:  ADD     W5,#3,W5
02D8C:  MOV     W5,W0
02D8E:  MOV     W0,W5
02D90:  MOV     1BAE,W0
02D92:  MOV.B   W0L,[W5+#0]
....................     *(((unsigned int8 *)(&y))+2) = data2; 
02D94:  MOV     #1BA6,W5
02D96:  ADD     W5,#2,W5
02D98:  MOV     W5,W0
02D9A:  MOV     W0,W5
02D9C:  MOV     1BB0,W0
02D9E:  MOV.B   W0L,[W5+#0]
....................      
....................   #endif 
....................    } while(res != y); 
02DA0:  MOV     1BAA,W0
02DA2:  MOV     1BAC,W1
02DA4:  MOV     1BA6,W2
02DA6:  MOV     1BA8,W3
02DA8:  CALL    21EA
02DAC:  BRA     NZ,2D2A
....................  
....................    return(res); 
02DAE:  MOV     1BAA,W0
02DB0:  MOV     1BAC,W1
02DB2:  MOV     [--W15],W5
02DB4:  RETURN  
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
*
077AA:  MOV     W5,[W15++]
077AC:  MOV     W6,[W15++]
077AE:  MOV     W7,[W15++]
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
077B0:  MOV     1C1E,W0
077B2:  MOV     1C20,W1
077B4:  MOV     1C22,W2
077B6:  MOV     1C24,W3
077B8:  MOV     #0,W4
077BA:  MOV     #0,W5
077BC:  MOV     #0,W6
077BE:  MOV     #0,W7
077C0:  CALL    70F8
077C4:  BRA     C,77C8
077C6:  BRA     NZ,77D2
....................       return(0.0); 
077C8:  MOV     #0,W0
077CA:  MOV     #0,W1
077CC:  MOV     #0,W2
077CE:  MOV     #0,W3
077D0:  BRA     78C0
....................  
....................    y=x; 
077D2:  PUSH    1C1E
077D4:  POP     1C26
077D6:  PUSH    1C20
077D8:  POP     1C28
077DA:  PUSH    1C22
077DC:  POP     1C2A
077DE:  PUSH    1C24
077E0:  POP     1C2C
....................    p= (((unsigned int16 *)(&y))+3); 
077E2:  MOV     #1C26,W5
077E4:  ADD     W5,#6,W5
077E6:  MOV     W5,1C36
....................    temp1 = *p; 
077E8:  MOV     1C36,W0
077EA:  MOV     [W0],[W15++]
077EC:  POP     1C38
....................    temp2 = *p; 
077EE:  MOV     1C36,W0
077F0:  MOV     [W0],[W15++]
077F2:  POP     1C3A
....................    bit_clear(temp1,15); 
077F4:  MOV     #1C38,W4
077F6:  BCLR    [W4].F
....................    temp1 = (temp1>>4)+1023; 
077F8:  MOV     1C38,W5
077FA:  LSR     W5,#4,W5
077FC:  MOV     #3FF,W4
077FE:  ADD     W5,W4,W0
07800:  MOV     W0,1C38
....................    temp1 = temp1 >> 1; 
07802:  LSR     1C38
....................    temp1 = (temp1<<4) & 0xFFF0; 
07804:  MOV     1C38,W5
07806:  SL      W5,#4,W5
07808:  MOV     #FFF0,W0
0780A:  AND     W0,W5,W0
0780C:  MOV     W0,1C38
....................    if(bit_test(temp2,15)) 
0780E:  BTSS.B  1C3B.7
07810:  BRA     7816
....................       bit_set(temp1,15); 
07812:  MOV     #1C38,W4
07814:  BSET    [W4].F
....................    temp2 = temp2 & 0x000F; 
07816:  MOV     1C3A,W0
07818:  AND     W0,#F,W0
0781A:  MOV     W0,1C3A
....................    temp1 ^= temp2; 
0781C:  MOV     1C3A,W0
0781E:  XOR     1C38
....................     
....................    (*p) = temp1; 
07820:  MOV     1C36,W5
07822:  MOV     1C38,W4
07824:  MOV     W4,[W5+#0]
....................     
....................    do { 
....................       res=y; 
07826:  PUSH    1C26
07828:  POP     1C2E
0782A:  PUSH    1C28
0782C:  POP     1C30
0782E:  PUSH    1C2A
07830:  POP     1C32
07832:  PUSH    1C2C
07834:  POP     1C34
....................       y+=(x/y); 
07836:  MOV     1C1E,W0
07838:  MOV     1C20,W1
0783A:  MOV     1C22,W2
0783C:  MOV     1C24,W3
0783E:  MOV     1C26,W4
07840:  MOV     1C28,W5
07842:  MOV     1C2A,W6
07844:  MOV     1C2C,W7
07846:  CALL    D0A
0784A:  BCLR.B  43.0
0784C:  MOV     W0,W4
0784E:  MOV     W1,W5
07850:  MOV     W2,W6
07852:  MOV     W3,W7
07854:  MOV     1C26,W0
07856:  MOV     1C28,W1
07858:  MOV     1C2A,W2
0785A:  MOV     1C2C,W3
0785C:  CALL    6F0A
07860:  MOV     W0,1C26
07862:  MOV     W1,1C28
07864:  MOV     W2,1C2A
07866:  MOV     W3,1C2C
....................      temp1 = *p; 
07868:  MOV     1C36,W0
0786A:  MOV     [W0],[W15++]
0786C:  POP     1C38
....................      temp2 = *p; 
0786E:  MOV     1C36,W0
07870:  MOV     [W0],[W15++]
07872:  POP     1C3A
....................      bit_clear(temp1,15); 
07874:  MOV     #1C38,W4
07876:  BCLR    [W4].F
....................      temp1 = (temp1>>4); 
07878:  MOV     1C38,W0
0787A:  LSR     W0,#4,W0
0787C:  MOV     W0,1C38
....................      temp1--; 
0787E:  DEC     1C38
....................      temp1 = (temp1<<4) & 0xFFF0; 
07880:  MOV     1C38,W5
07882:  SL      W5,#4,W5
07884:  MOV     #FFF0,W0
07886:  AND     W0,W5,W0
07888:  MOV     W0,1C38
....................      if(bit_test(temp2,15)) 
0788A:  BTSS.B  1C3B.7
0788C:  BRA     7892
....................         bit_set(temp1,15); 
0788E:  MOV     #1C38,W4
07890:  BSET    [W4].F
....................      temp2 = temp2 & 0x000F; 
07892:  MOV     1C3A,W0
07894:  AND     W0,#F,W0
07896:  MOV     W0,1C3A
....................      temp1 ^= temp2; 
07898:  MOV     1C3A,W0
0789A:  XOR     1C38
....................      (*p) = temp1; 
0789C:  MOV     1C36,W5
0789E:  MOV     1C38,W4
078A0:  MOV     W4,[W5+#0]
....................  
....................    } while(res != y); 
078A2:  MOV     1C2E,W0
078A4:  MOV     1C30,W1
078A6:  MOV     1C32,W2
078A8:  MOV     1C34,W3
078AA:  MOV     1C26,W4
078AC:  MOV     1C28,W5
078AE:  MOV     1C2A,W6
078B0:  MOV     1C2C,W7
078B2:  CALL    70F8
078B6:  BRA     NZ,7826
....................  
....................    return(res); 
078B8:  MOV     1C2E,W0
078BA:  MOV     1C30,W1
078BC:  MOV     1C32,W2
078BE:  MOV     1C34,W3
078C0:  MOV     [--W15],W7
078C2:  MOV     [--W15],W6
078C4:  MOV     [--W15],W5
078C6:  RETURN  
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
*
08BA2:  MOV     W5,[W15++]
08BA4:  MOV     W6,[W15++]
08BA6:  MOV     W7,[W15++]
08BA8:  MOV     W8,[W15++]
08BAA:  CLR     1BAE
08BAC:  CLR     1BB0
08BAE:  CLR     1BB2
08BB0:  MOV     #3FF0,W4
08BB2:  MOV     W4,1BB4
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
08BB4:  MOV     #FF1F,W4
08BB6:  MOV     W4,1BC0
08BB8:  SETM    1BC2
08BBA:  SETM    1BC4
08BBC:  MOV     #BFDF,W4
08BBE:  MOV     W4,1BC6
08BC0:  MOV     #1C35,W4
08BC2:  MOV     W4,1BC8
08BC4:  MOV     #5555,W4
08BC6:  MOV     W4,1BCA
08BC8:  MOV     #5555,W4
08BCA:  MOV     W4,1BCC
08BCC:  MOV     #3FA5,W4
08BCE:  MOV     W4,1BCE
08BD0:  MOV     #3F1C,W4
08BD2:  MOV     W4,1BD0
08BD4:  MOV     #16A7,W4
08BD6:  MOV     W4,1BD2
08BD8:  MOV     #C16C,W4
08BDA:  MOV     W4,1BD4
08BDC:  MOV     #BF56,W4
08BDE:  MOV     W4,1BD6
08BE0:  MOV     #F3E6,W4
08BE2:  MOV     W4,1BD8
08BE4:  MOV     #D65,W4
08BE6:  MOV     W4,1BDA
08BE8:  MOV     #1A0,W4
08BEA:  MOV     W4,1BDC
08BEC:  MOV     #3EFA,W4
08BEE:  MOV     W4,1BDE
08BF0:  MOV     #A3E,W4
08BF2:  MOV     W4,1BE0
08BF4:  MOV     #3931,W4
08BF6:  MOV     W4,1BE2
08BF8:  MOV     #7E4C,W4
08BFA:  MOV     W4,1BE4
08BFC:  MOV     #BE92,W4
08BFE:  MOV     W4,1BE6
08C00:  MOV     #DDFB,W4
08C02:  MOV     W4,1BE8
08C04:  MOV     #2B77,W4
08C06:  MOV     W4,1BEA
08C08:  MOV     #EDB1,W4
08C0A:  MOV     W4,1BEC
08C0C:  MOV     #3E21,W4
08C0E:  MOV     W4,1BEE
08C10:  MOV     #6FCC,W4
08C12:  MOV     W4,1BF0
08C14:  MOV     #8FF7,W4
08C16:  MOV     W4,1BF2
08C18:  MOV     #C610,W4
08C1A:  MOV     W4,1BF4
08C1C:  MOV     #BDA8,W4
08C1E:  MOV     W4,1BF6
08C20:  MOV     #124C,W4
08C22:  MOV     W4,1BF8
08C24:  MOV     #8E1C,W4
08C26:  MOV     W4,1BFA
08C28:  MOV     #3AF9,W4
08C2A:  MOV     W4,1BFC
08C2C:  MOV     #3CF3,W4
08C2E:  MOV     W4,1BFE
08C30:  MOV     #7676,W4
08C32:  MOV     W4,1C00
08C34:  MOV     #350F,W4
08C36:  MOV     W4,1C02
08C38:  MOV     #C0DE,W4
08C3A:  MOV     W4,1C04
08C3C:  MOV     #3CF0,W4
08C3E:  MOV     W4,1C06
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
08C40:  MOV     1B96,W0
08C42:  MOV     1B98,W1
08C44:  MOV     1B9A,W2
08C46:  MOV     1B9C,W3
08C48:  MOV     #0,W4
08C4A:  MOV     #0,W5
08C4C:  MOV     #0,W6
08C4E:  MOV     #0,W7
08C50:  CALL    70F8
08C54:  BRA     NC,8C60
08C56:  MOV     #1B96,W0
08C58:  MOV     #1B96,W1
08C5A:  REPEAT  #7
08C5C:  MOV     [W0++],[W1++]
08C5E:  BTG.B   1B9D.7
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
08C60:  MOV     1B96,W0
08C62:  MOV     1B98,W1
08C64:  MOV     1B9A,W2
08C66:  MOV     1B9C,W3
08C68:  MOV     #C884,W4
08C6A:  MOV     #6DC9,W5
08C6C:  MOV     #5F30,W6
08C6E:  MOV     #3FE4,W7
08C70:  CALL    BFA
08C74:  CALL    8B4C
08C78:  MOV.B   W0L,1BB6
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
08C7A:  MOV     1B96,W0
08C7C:  MOV     1B98,W1
08C7E:  MOV     1B9A,W2
08C80:  MOV     1B9C,W3
08C82:  MOV     #C884,W4
08C84:  MOV     #6DC9,W5
08C86:  MOV     #5F30,W6
08C88:  MOV     #3FE4,W7
08C8A:  CALL    BFA
08C8E:  MOV     W0,W5
08C90:  MOV     W1,W6
08C92:  MOV     W2,W7
08C94:  MOV     W3,W8
08C96:  MOV     #0,W1
08C98:  MOV     #0,W2
08C9A:  MOV     #0,W3
08C9C:  MOV.B   1BB6,W0L
08C9E:  CLR.B   1
08CA0:  CALL    8A38
08CA4:  BSET.B  43.0
08CA6:  MOV     W5,[W15++]
08CA8:  MOV     W6,[W15++]
08CAA:  MOV     W7,[W15++]
08CAC:  MOV     W0,W4
08CAE:  MOV     W5,W0
08CB0:  MOV     W1,W5
08CB2:  MOV     W6,W1
08CB4:  MOV     W2,W6
08CB6:  MOV     W7,W2
08CB8:  MOV     W3,W7
08CBA:  MOV     W8,W3
08CBC:  CALL    6F0A
08CC0:  MOV     [--W15],W7
08CC2:  MOV     [--W15],W6
08CC4:  MOV     [--W15],W5
08CC6:  MOV     W0,1BB8
08CC8:  MOV     W1,1BBA
08CCA:  MOV     W2,1BBC
08CCC:  MOV     W3,1BBE
....................    quad = quad % 4;                    // quadrant (0 to 3) 
08CCE:  MOV.B   1BB6,W0L
08CD0:  AND.B   W0L,#3,W0L
08CD2:  MOV.B   W0L,1BB6
....................  
....................    if (quad == 0 || quad == 2) 
08CD4:  CP0.B   1BB6
08CD6:  BRA     Z,8CDE
08CD8:  MOV     1BB6,W4
08CDA:  CP.B    W4L,#2
08CDC:  BRA     NZ,8CFE
....................       t = frac * PI_DIV_BY_TWO; 
08CDE:  MOV     1BB8,W0
08CE0:  MOV     1BBA,W1
08CE2:  MOV     1BBC,W2
08CE4:  MOV     1BBE,W3
08CE6:  MOV     #2D18,W4
08CE8:  MOV     #5444,W5
08CEA:  MOV     #21FB,W6
08CEC:  MOV     #3FF9,W7
08CEE:  CALL    BFA
08CF2:  MOV     W0,1BA6
08CF4:  MOV     W1,1BA8
08CF6:  MOV     W2,1BAA
08CF8:  MOV     W3,1BAC
08CFA:  GOTO    8D94
....................    else if (quad == 1) 
08CFE:  MOV     1BB6,W4
08D00:  CP.B    W4L,#1
08D02:  BRA     NZ,8D4E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
08D04:  BSET.B  43.0
08D06:  MOV     #0,W0
08D08:  MOV     #0,W1
08D0A:  MOV     #0,W2
08D0C:  MOV     #3FF0,W3
08D0E:  MOV     1BB8,W4
08D10:  MOV     1BBA,W5
08D12:  MOV     1BBC,W6
08D14:  MOV     1BBE,W7
08D16:  CALL    6F0A
08D1A:  MOV     W0,W5
08D1C:  MOV     W1,W6
08D1E:  MOV     W2,W7
08D20:  MOV     W3,W8
08D22:  MOV     W5,[W15++]
08D24:  MOV     W6,[W15++]
08D26:  MOV     W7,[W15++]
08D28:  MOV     W5,W0
08D2A:  MOV     W6,W1
08D2C:  MOV     W7,W2
08D2E:  MOV     W8,W3
08D30:  MOV     #2D18,W4
08D32:  MOV     #5444,W5
08D34:  MOV     #21FB,W6
08D36:  MOV     #3FF9,W7
08D38:  CALL    BFA
08D3C:  MOV     [--W15],W7
08D3E:  MOV     [--W15],W6
08D40:  MOV     [--W15],W5
08D42:  MOV     W0,1BA6
08D44:  MOV     W1,1BA8
08D46:  MOV     W2,1BAA
08D48:  MOV     W3,1BAC
08D4A:  GOTO    8D94
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
08D4E:  BSET.B  43.0
08D50:  MOV     1BB8,W0
08D52:  MOV     1BBA,W1
08D54:  MOV     1BBC,W2
08D56:  MOV     1BBE,W3
08D58:  MOV     #0,W4
08D5A:  MOV     #0,W5
08D5C:  MOV     #0,W6
08D5E:  MOV     #3FF0,W7
08D60:  CALL    6F0A
08D64:  MOV     W0,W5
08D66:  MOV     W1,W6
08D68:  MOV     W2,W7
08D6A:  MOV     W3,W8
08D6C:  MOV     W5,[W15++]
08D6E:  MOV     W6,[W15++]
08D70:  MOV     W7,[W15++]
08D72:  MOV     W5,W0
08D74:  MOV     W6,W1
08D76:  MOV     W7,W2
08D78:  MOV     W8,W3
08D7A:  MOV     #2D18,W4
08D7C:  MOV     #5444,W5
08D7E:  MOV     #21FB,W6
08D80:  MOV     #3FF9,W7
08D82:  CALL    BFA
08D86:  MOV     [--W15],W7
08D88:  MOV     [--W15],W6
08D8A:  MOV     [--W15],W5
08D8C:  MOV     W0,1BA6
08D8E:  MOV     W1,1BA8
08D90:  MOV     W2,1BAA
08D92:  MOV     W3,1BAC
....................  
....................    y = 1.0; 
08D94:  CLR     1B9E
08D96:  CLR     1BA0
08D98:  CLR     1BA2
08D9A:  MOV     #3FF0,W4
08D9C:  MOV     W4,1BA4
....................    t = t * t; 
08D9E:  MOV     1BA6,W0
08DA0:  MOV     1BA8,W1
08DA2:  MOV     1BAA,W2
08DA4:  MOV     1BAC,W3
08DA6:  MOV     1BA6,W4
08DA8:  MOV     1BA8,W5
08DAA:  MOV     1BAA,W6
08DAC:  MOV     1BAC,W7
08DAE:  CALL    BFA
08DB2:  MOV     W0,1BA6
08DB4:  MOV     W1,1BA8
08DB6:  MOV     W2,1BAA
08DB8:  MOV     W3,1BAC
....................    for (i = 0; i <= 8; i++) 
08DBA:  CLR.B   1BB7
08DBC:  MOV     1BB6,W4
08DBE:  LSR     W4,#8,W4
08DC0:  CP.B    W4L,#8
08DC2:  BRA     GTU,8E34
....................    { 
....................       t2 = t2 * t; 
08DC4:  MOV     1BAE,W0
08DC6:  MOV     1BB0,W1
08DC8:  MOV     1BB2,W2
08DCA:  MOV     1BB4,W3
08DCC:  MOV     1BA6,W4
08DCE:  MOV     1BA8,W5
08DD0:  MOV     1BAA,W6
08DD2:  MOV     1BAC,W7
08DD4:  CALL    BFA
08DD8:  MOV     W0,1BAE
08DDA:  MOV     W1,1BB0
08DDC:  MOV     W2,1BB2
08DDE:  MOV     W3,1BB4
....................       y = y + p_64[i] * t2; 
08DE0:  MOV.B   1BB7,W0L
08DE2:  CLR.B   1
08DE4:  SL      W0,#3,W0
08DE6:  MOV     #1BC0,W4
08DE8:  ADD     W0,W4,W0
08DEA:  MOV     #A,W4
08DEC:  REPEAT  #3
08DEE:  MOV     [W0++],[W4++]
08DF0:  MOV     W5,[W15++]
08DF2:  MOV     W6,[W15++]
08DF4:  MOV     W7,[W15++]
08DF6:  MOV     W5,W0
08DF8:  MOV     W6,W1
08DFA:  MOV     W7,W2
08DFC:  MOV     W8,W3
08DFE:  MOV     1BAE,W4
08E00:  MOV     1BB0,W5
08E02:  MOV     1BB2,W6
08E04:  MOV     1BB4,W7
08E06:  CALL    BFA
08E0A:  MOV     [--W15],W7
08E0C:  MOV     [--W15],W6
08E0E:  MOV     [--W15],W5
08E10:  BCLR.B  43.0
08E12:  MOV     W0,W4
08E14:  MOV     W1,W5
08E16:  MOV     W2,W6
08E18:  MOV     W3,W7
08E1A:  MOV     1B9E,W0
08E1C:  MOV     1BA0,W1
08E1E:  MOV     1BA2,W2
08E20:  MOV     1BA4,W3
08E22:  CALL    6F0A
08E26:  MOV     W0,1B9E
08E28:  MOV     W1,1BA0
08E2A:  MOV     W2,1BA2
08E2C:  MOV     W3,1BA4
08E2E:  INC.B   1BB7
08E30:  GOTO    8DBC
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
08E34:  MOV     1BB6,W4
08E36:  CP.B    W4L,#2
08E38:  BRA     Z,8E40
08E3A:  MOV     1BB6,W4
08E3C:  CP.B    W4L,#1
08E3E:  BRA     NZ,8E4A
....................       y = -y;  // correct sign 
08E40:  MOV     #1B9E,W0
08E42:  MOV     #1B9E,W1
08E44:  REPEAT  #7
08E46:  MOV     [W0++],[W1++]
08E48:  BTG.B   1BA5.7
....................  
....................    return (y); 
08E4A:  MOV     1B9E,W0
08E4C:  MOV     1BA0,W1
08E4E:  MOV     1BA2,W2
08E50:  MOV     1BA4,W3
08E52:  MOV     [--W15],W8
08E54:  MOV     [--W15],W7
08E56:  MOV     [--W15],W6
08E58:  MOV     [--W15],W5
08E5A:  RETURN  
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
08E5C:  MOV     W5,[W15++]
08E5E:  MOV     W6,[W15++]
08E60:  MOV     W7,[W15++]
08E62:  MOV     W8,[W15++]
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
08E64:  BSET.B  43.0
08E66:  MOV     1B7C,W0
08E68:  MOV     1B7E,W1
08E6A:  MOV     1B80,W2
08E6C:  MOV     1B82,W3
08E6E:  MOV     #2D18,W4
08E70:  MOV     #5444,W5
08E72:  MOV     #21FB,W6
08E74:  MOV     #3FF9,W7
08E76:  CALL    6F0A
08E7A:  MOV     W0,W5
08E7C:  MOV     W1,W6
08E7E:  MOV     W2,W7
08E80:  MOV     W3,W8
08E82:  MOV     W5,1B96
08E84:  MOV     W6,1B98
08E86:  MOV     W7,1B9A
08E88:  MOV     W8,1B9C
08E8A:  CALL    8BA2
08E8E:  MOV     [--W15],W8
08E90:  MOV     [--W15],W7
08E92:  MOV     [--W15],W6
08E94:  MOV     [--W15],W5
08E96:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
*
0791E:  MOV     W5,[W15++]
07920:  MOV     W6,[W15++]
07922:  MOV     W7,[W15++]
07924:  MOV     W8,[W15++]
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
07926:  BCLR.B  1BE3.0
....................    y = x; 
07928:  PUSH    1BDA
0792A:  POP     1BE4
0792C:  PUSH    1BDC
0792E:  POP     1BE6
07930:  PUSH    1BDE
07932:  POP     1BE8
07934:  PUSH    1BE0
07936:  POP     1BEA
....................  
....................    if (x < 0) 
07938:  MOV     1BDA,W0
0793A:  MOV     1BDC,W1
0793C:  MOV     1BDE,W2
0793E:  MOV     1BE0,W3
07940:  MOV     #0,W4
07942:  MOV     #0,W5
07944:  MOV     #0,W6
07946:  MOV     #0,W7
07948:  CALL    70F8
0794C:  BRA     NC,795A
....................    { 
....................       s = 1; 
0794E:  BSET.B  1BE3.0
....................       y = -y; 
07950:  MOV     #1BE4,W0
07952:  MOV     #1BE4,W1
07954:  REPEAT  #7
07956:  MOV     [W0++],[W1++]
07958:  BTG.B   1BEB.7
....................    } 
....................  
....................    if (y > 0.5) 
0795A:  MOV     #0,W0
0795C:  MOV     #0,W1
0795E:  MOV     #0,W2
07960:  MOV     #3FE0,W3
07962:  MOV     1BE4,W4
07964:  MOV     1BE6,W5
07966:  MOV     1BE8,W6
07968:  MOV     1BEA,W7
0796A:  CALL    70F8
0796E:  BRA     NC,79D2
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
07970:  BSET.B  43.0
07972:  MOV     #0,W0
07974:  MOV     #0,W1
07976:  MOV     #0,W2
07978:  MOV     #3FF0,W3
0797A:  MOV     1BE4,W4
0797C:  MOV     1BE6,W5
0797E:  MOV     1BE8,W6
07980:  MOV     1BEA,W7
07982:  CALL    6F0A
07986:  MOV     W0,W5
07988:  MOV     W1,W6
0798A:  MOV     W2,W7
0798C:  MOV     W3,W8
0798E:  MOV     W5,[W15++]
07990:  MOV     W6,[W15++]
07992:  MOV     W7,[W15++]
07994:  MOV     W5,W0
07996:  MOV     W6,W1
07998:  MOV     W7,W2
0799A:  MOV     W8,W3
0799C:  MOV     #0,W4
0799E:  MOV     #0,W5
079A0:  MOV     #0,W6
079A2:  MOV     #3FE0,W7
079A4:  CALL    BFA
079A8:  MOV     [--W15],W7
079AA:  MOV     [--W15],W6
079AC:  MOV     [--W15],W5
079AE:  MOV     W0,W5
079B0:  MOV     W1,W6
079B2:  MOV     W2,W7
079B4:  MOV     W3,W8
079B6:  MOV     W5,1C1E
079B8:  MOV     W6,1C20
079BA:  MOV     W7,1C22
079BC:  MOV     W8,1C24
079BE:  CALL    77AA
079C2:  MOV     W0,1BE4
079C4:  MOV     W1,1BE6
079C6:  MOV     W2,1BE8
079C8:  MOV     W3,1BEA
....................       n += 2; 
079CA:  MOV     1BE2,W4
079CC:  ADD.B   W4L,#2,W4L
079CE:  MOV.B   W4L,W0L
079D0:  MOV.B   W0L,1BE2
....................    } 
....................  
....................    y2=y*y; 
079D2:  MOV     1BE4,W0
079D4:  MOV     1BE6,W1
079D6:  MOV     1BE8,W2
079D8:  MOV     1BEA,W3
079DA:  MOV     1BE4,W4
079DC:  MOV     1BE6,W5
079DE:  MOV     1BE8,W6
079E0:  MOV     1BEA,W7
079E2:  CALL    BFA
079E6:  MOV     W0,1BFC
079E8:  MOV     W1,1BFE
079EA:  MOV     W2,1C00
079EC:  MOV     W3,1C02
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
079EE:  MOV     14DE,W0
079F0:  MOV     14E0,W1
079F2:  MOV     14E2,W2
079F4:  MOV     14E4,W3
079F6:  MOV     1BFC,W4
079F8:  MOV     1BFE,W5
079FA:  MOV     1C00,W6
079FC:  MOV     1C02,W7
079FE:  CALL    BFA
07A02:  MOV     W0,W5
07A04:  MOV     W1,W6
07A06:  MOV     W2,W7
07A08:  MOV     W3,W8
07A0A:  BCLR.B  43.0
07A0C:  MOV     W5,[W15++]
07A0E:  MOV     W6,[W15++]
07A10:  MOV     W7,[W15++]
07A12:  MOV     W5,W0
07A14:  MOV     W6,W1
07A16:  MOV     W7,W2
07A18:  MOV     W8,W3
07A1A:  MOV     14D6,W4
07A1C:  MOV     14D8,W5
07A1E:  MOV     14DA,W6
07A20:  MOV     14DC,W7
07A22:  CALL    6F0A
07A26:  MOV     [--W15],W7
07A28:  MOV     [--W15],W6
07A2A:  MOV     [--W15],W5
07A2C:  MOV     W0,1BEC
07A2E:  MOV     W1,1BEE
07A30:  MOV     W2,1BF0
07A32:  MOV     W3,1BF2
....................    res = res*y2 + pas_64[2]; 
07A34:  MOV     1BEC,W0
07A36:  MOV     1BEE,W1
07A38:  MOV     1BF0,W2
07A3A:  MOV     1BF2,W3
07A3C:  MOV     1BFC,W4
07A3E:  MOV     1BFE,W5
07A40:  MOV     1C00,W6
07A42:  MOV     1C02,W7
07A44:  CALL    BFA
07A48:  MOV     W0,W5
07A4A:  MOV     W1,W6
07A4C:  MOV     W2,W7
07A4E:  MOV     W3,W8
07A50:  BCLR.B  43.0
07A52:  MOV     W5,[W15++]
07A54:  MOV     W6,[W15++]
07A56:  MOV     W7,[W15++]
07A58:  MOV     W5,W0
07A5A:  MOV     W6,W1
07A5C:  MOV     W7,W2
07A5E:  MOV     W8,W3
07A60:  MOV     14CE,W4
07A62:  MOV     14D0,W5
07A64:  MOV     14D2,W6
07A66:  MOV     14D4,W7
07A68:  CALL    6F0A
07A6C:  MOV     [--W15],W7
07A6E:  MOV     [--W15],W6
07A70:  MOV     [--W15],W5
07A72:  MOV     W0,1BEC
07A74:  MOV     W1,1BEE
07A76:  MOV     W2,1BF0
07A78:  MOV     W3,1BF2
....................    res = res*y2 + pas_64[1]; 
07A7A:  MOV     1BEC,W0
07A7C:  MOV     1BEE,W1
07A7E:  MOV     1BF0,W2
07A80:  MOV     1BF2,W3
07A82:  MOV     1BFC,W4
07A84:  MOV     1BFE,W5
07A86:  MOV     1C00,W6
07A88:  MOV     1C02,W7
07A8A:  CALL    BFA
07A8E:  MOV     W0,W5
07A90:  MOV     W1,W6
07A92:  MOV     W2,W7
07A94:  MOV     W3,W8
07A96:  BCLR.B  43.0
07A98:  MOV     W5,[W15++]
07A9A:  MOV     W6,[W15++]
07A9C:  MOV     W7,[W15++]
07A9E:  MOV     W5,W0
07AA0:  MOV     W6,W1
07AA2:  MOV     W7,W2
07AA4:  MOV     W8,W3
07AA6:  MOV     14C6,W4
07AA8:  MOV     14C8,W5
07AAA:  MOV     14CA,W6
07AAC:  MOV     14CC,W7
07AAE:  CALL    6F0A
07AB2:  MOV     [--W15],W7
07AB4:  MOV     [--W15],W6
07AB6:  MOV     [--W15],W5
07AB8:  MOV     W0,1BEC
07ABA:  MOV     W1,1BEE
07ABC:  MOV     W2,1BF0
07ABE:  MOV     W3,1BF2
....................    res = res*y2 + pas_64[0]; 
07AC0:  MOV     1BEC,W0
07AC2:  MOV     1BEE,W1
07AC4:  MOV     1BF0,W2
07AC6:  MOV     1BF2,W3
07AC8:  MOV     1BFC,W4
07ACA:  MOV     1BFE,W5
07ACC:  MOV     1C00,W6
07ACE:  MOV     1C02,W7
07AD0:  CALL    BFA
07AD4:  MOV     W0,W5
07AD6:  MOV     W1,W6
07AD8:  MOV     W2,W7
07ADA:  MOV     W3,W8
07ADC:  BCLR.B  43.0
07ADE:  MOV     W5,[W15++]
07AE0:  MOV     W6,[W15++]
07AE2:  MOV     W7,[W15++]
07AE4:  MOV     W5,W0
07AE6:  MOV     W6,W1
07AE8:  MOV     W7,W2
07AEA:  MOV     W8,W3
07AEC:  MOV     14BE,W4
07AEE:  MOV     14C0,W5
07AF0:  MOV     14C2,W6
07AF2:  MOV     14C4,W7
07AF4:  CALL    6F0A
07AF8:  MOV     [--W15],W7
07AFA:  MOV     [--W15],W6
07AFC:  MOV     [--W15],W5
07AFE:  MOV     W0,1BEC
07B00:  MOV     W1,1BEE
07B02:  MOV     W2,1BF0
07B04:  MOV     W3,1BF2
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
07B06:  MOV     1506,W0
07B08:  MOV     1508,W1
07B0A:  MOV     150A,W2
07B0C:  MOV     150C,W3
07B0E:  MOV     1BFC,W4
07B10:  MOV     1BFE,W5
07B12:  MOV     1C00,W6
07B14:  MOV     1C02,W7
07B16:  CALL    BFA
07B1A:  MOV     W0,W5
07B1C:  MOV     W1,W6
07B1E:  MOV     W2,W7
07B20:  MOV     W3,W8
07B22:  BCLR.B  43.0
07B24:  MOV     W5,[W15++]
07B26:  MOV     W6,[W15++]
07B28:  MOV     W7,[W15++]
07B2A:  MOV     W5,W0
07B2C:  MOV     W6,W1
07B2E:  MOV     W7,W2
07B30:  MOV     W8,W3
07B32:  MOV     14FE,W4
07B34:  MOV     1500,W5
07B36:  MOV     1502,W6
07B38:  MOV     1504,W7
07B3A:  CALL    6F0A
07B3E:  MOV     [--W15],W7
07B40:  MOV     [--W15],W6
07B42:  MOV     [--W15],W5
07B44:  MOV     W0,1BF4
07B46:  MOV     W1,1BF6
07B48:  MOV     W2,1BF8
07B4A:  MOV     W3,1BFA
....................    r = r*y2 + qas_64[2]; 
07B4C:  MOV     1BF4,W0
07B4E:  MOV     1BF6,W1
07B50:  MOV     1BF8,W2
07B52:  MOV     1BFA,W3
07B54:  MOV     1BFC,W4
07B56:  MOV     1BFE,W5
07B58:  MOV     1C00,W6
07B5A:  MOV     1C02,W7
07B5C:  CALL    BFA
07B60:  MOV     W0,W5
07B62:  MOV     W1,W6
07B64:  MOV     W2,W7
07B66:  MOV     W3,W8
07B68:  BCLR.B  43.0
07B6A:  MOV     W5,[W15++]
07B6C:  MOV     W6,[W15++]
07B6E:  MOV     W7,[W15++]
07B70:  MOV     W5,W0
07B72:  MOV     W6,W1
07B74:  MOV     W7,W2
07B76:  MOV     W8,W3
07B78:  MOV     14F6,W4
07B7A:  MOV     14F8,W5
07B7C:  MOV     14FA,W6
07B7E:  MOV     14FC,W7
07B80:  CALL    6F0A
07B84:  MOV     [--W15],W7
07B86:  MOV     [--W15],W6
07B88:  MOV     [--W15],W5
07B8A:  MOV     W0,1BF4
07B8C:  MOV     W1,1BF6
07B8E:  MOV     W2,1BF8
07B90:  MOV     W3,1BFA
....................    r = r*y2 + qas_64[1]; 
07B92:  MOV     1BF4,W0
07B94:  MOV     1BF6,W1
07B96:  MOV     1BF8,W2
07B98:  MOV     1BFA,W3
07B9A:  MOV     1BFC,W4
07B9C:  MOV     1BFE,W5
07B9E:  MOV     1C00,W6
07BA0:  MOV     1C02,W7
07BA2:  CALL    BFA
07BA6:  MOV     W0,W5
07BA8:  MOV     W1,W6
07BAA:  MOV     W2,W7
07BAC:  MOV     W3,W8
07BAE:  BCLR.B  43.0
07BB0:  MOV     W5,[W15++]
07BB2:  MOV     W6,[W15++]
07BB4:  MOV     W7,[W15++]
07BB6:  MOV     W5,W0
07BB8:  MOV     W6,W1
07BBA:  MOV     W7,W2
07BBC:  MOV     W8,W3
07BBE:  MOV     14EE,W4
07BC0:  MOV     14F0,W5
07BC2:  MOV     14F2,W6
07BC4:  MOV     14F4,W7
07BC6:  CALL    6F0A
07BCA:  MOV     [--W15],W7
07BCC:  MOV     [--W15],W6
07BCE:  MOV     [--W15],W5
07BD0:  MOV     W0,1BF4
07BD2:  MOV     W1,1BF6
07BD4:  MOV     W2,1BF8
07BD6:  MOV     W3,1BFA
....................    r = r*y2 + qas_64[0]; 
07BD8:  MOV     1BF4,W0
07BDA:  MOV     1BF6,W1
07BDC:  MOV     1BF8,W2
07BDE:  MOV     1BFA,W3
07BE0:  MOV     1BFC,W4
07BE2:  MOV     1BFE,W5
07BE4:  MOV     1C00,W6
07BE6:  MOV     1C02,W7
07BE8:  CALL    BFA
07BEC:  MOV     W0,W5
07BEE:  MOV     W1,W6
07BF0:  MOV     W2,W7
07BF2:  MOV     W3,W8
07BF4:  BCLR.B  43.0
07BF6:  MOV     W5,[W15++]
07BF8:  MOV     W6,[W15++]
07BFA:  MOV     W7,[W15++]
07BFC:  MOV     W5,W0
07BFE:  MOV     W6,W1
07C00:  MOV     W7,W2
07C02:  MOV     W8,W3
07C04:  MOV     14E6,W4
07C06:  MOV     14E8,W5
07C08:  MOV     14EA,W6
07C0A:  MOV     14EC,W7
07C0C:  CALL    6F0A
07C10:  MOV     [--W15],W7
07C12:  MOV     [--W15],W6
07C14:  MOV     [--W15],W5
07C16:  MOV     W0,1BF4
07C18:  MOV     W1,1BF6
07C1A:  MOV     W2,1BF8
07C1C:  MOV     W3,1BFA
....................    r = r*y2 + 1.0; 
07C1E:  MOV     1BF4,W0
07C20:  MOV     1BF6,W1
07C22:  MOV     1BF8,W2
07C24:  MOV     1BFA,W3
07C26:  MOV     1BFC,W4
07C28:  MOV     1BFE,W5
07C2A:  MOV     1C00,W6
07C2C:  MOV     1C02,W7
07C2E:  CALL    BFA
07C32:  MOV     W0,W5
07C34:  MOV     W1,W6
07C36:  MOV     W2,W7
07C38:  MOV     W3,W8
07C3A:  BCLR.B  43.0
07C3C:  MOV     W5,[W15++]
07C3E:  MOV     W6,[W15++]
07C40:  MOV     W7,[W15++]
07C42:  MOV     W5,W0
07C44:  MOV     W6,W1
07C46:  MOV     W7,W2
07C48:  MOV     W8,W3
07C4A:  MOV     #0,W4
07C4C:  MOV     #0,W5
07C4E:  MOV     #0,W6
07C50:  MOV     #3FF0,W7
07C52:  CALL    6F0A
07C56:  MOV     [--W15],W7
07C58:  MOV     [--W15],W6
07C5A:  MOV     [--W15],W5
07C5C:  MOV     W0,1BF4
07C5E:  MOV     W1,1BF6
07C60:  MOV     W2,1BF8
07C62:  MOV     W3,1BFA
....................  
....................    res = y*res/r; 
07C64:  MOV     1BE4,W0
07C66:  MOV     1BE6,W1
07C68:  MOV     1BE8,W2
07C6A:  MOV     1BEA,W3
07C6C:  MOV     1BEC,W4
07C6E:  MOV     1BEE,W5
07C70:  MOV     1BF0,W6
07C72:  MOV     1BF2,W7
07C74:  CALL    BFA
07C78:  MOV     W0,W5
07C7A:  MOV     W1,W6
07C7C:  MOV     W2,W7
07C7E:  MOV     W3,W8
07C80:  MOV     W5,[W15++]
07C82:  MOV     W6,[W15++]
07C84:  MOV     W7,[W15++]
07C86:  MOV     W5,W0
07C88:  MOV     W6,W1
07C8A:  MOV     W7,W2
07C8C:  MOV     W8,W3
07C8E:  MOV     1BF4,W4
07C90:  MOV     1BF6,W5
07C92:  MOV     1BF8,W6
07C94:  MOV     1BFA,W7
07C96:  CALL    D0A
07C9A:  MOV     [--W15],W7
07C9C:  MOV     [--W15],W6
07C9E:  MOV     [--W15],W5
07CA0:  MOV     W0,1BEC
07CA2:  MOV     W1,1BEE
07CA4:  MOV     W2,1BF0
07CA6:  MOV     W3,1BF2
....................  
....................    if (n & 2)     // |x| > 0.5 
07CA8:  MOV.B   1BE2,W0L
07CAA:  CLR.B   1
07CAC:  AND     W0,#2,W0
07CAE:  CP0     W0
07CB0:  BRA     Z,7CE4
....................       res = PI_DIV_BY_TWO - 2.0*res; 
07CB2:  MOV     #0,W0
07CB4:  MOV     #0,W1
07CB6:  MOV     #0,W2
07CB8:  MOV     #4000,W3
07CBA:  MOV     1BEC,W4
07CBC:  MOV     1BEE,W5
07CBE:  MOV     1BF0,W6
07CC0:  MOV     1BF2,W7
07CC2:  CALL    BFA
07CC6:  BSET.B  43.0
07CC8:  MOV     W0,W4
07CCA:  MOV     W1,W5
07CCC:  MOV     W2,W6
07CCE:  MOV     W3,W7
07CD0:  MOV     #2D18,W0
07CD2:  MOV     #5444,W1
07CD4:  MOV     #21FB,W2
07CD6:  MOV     #3FF9,W3
07CD8:  CALL    6F0A
07CDC:  MOV     W0,1BEC
07CDE:  MOV     W1,1BEE
07CE0:  MOV     W2,1BF0
07CE2:  MOV     W3,1BF2
....................    if (s) 
07CE4:  BTSS.B  1BE3.0
07CE6:  BRA     7CF2
....................       res = -res; 
07CE8:  MOV     #1BEC,W0
07CEA:  MOV     #1BEC,W1
07CEC:  REPEAT  #7
07CEE:  MOV     [W0++],[W1++]
07CF0:  BTG.B   1BF3.7
....................    if (n & 1)           // take arccos 
07CF2:  MOV.B   1BE2,W0L
07CF4:  CLR.B   1
07CF6:  AND     W0,#1,W0
07CF8:  CP0     W0
07CFA:  BRA     Z,7D1A
....................       res = PI_DIV_BY_TWO - res; 
07CFC:  BSET.B  43.0
07CFE:  MOV     #2D18,W0
07D00:  MOV     #5444,W1
07D02:  MOV     #21FB,W2
07D04:  MOV     #3FF9,W3
07D06:  MOV     1BEC,W4
07D08:  MOV     1BEE,W5
07D0A:  MOV     1BF0,W6
07D0C:  MOV     1BF2,W7
07D0E:  CALL    6F0A
07D12:  MOV     W0,1BEC
07D14:  MOV     W1,1BEE
07D16:  MOV     W2,1BF0
07D18:  MOV     W3,1BF2
....................  
....................    return(res); 
07D1A:  MOV     1BEC,W0
07D1C:  MOV     1BEE,W1
07D1E:  MOV     1BF0,W2
07D20:  MOV     1BF2,W3
07D22:  MOV     [--W15],W8
07D24:  MOV     [--W15],W7
07D26:  MOV     [--W15],W6
07D28:  MOV     [--W15],W5
07D2A:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
07D2C:  CLR.B   1BE2
07D2E:  PUSH    1BBA
07D30:  POP     1BDA
07D32:  PUSH    1BBC
07D34:  POP     1BDC
07D36:  PUSH    1BBE
07D38:  POP     1BDE
07D3A:  PUSH    1BC0
07D3C:  POP     1BE0
07D3E:  CALL    791E
07D42:  MOV     W0,1BC2
07D44:  MOV     W1,1BC4
07D46:  MOV     W2,1BC6
07D48:  MOV     W3,1BC8
....................    return(r); 
07D4A:  MOV     1BC2,W0
07D4C:  MOV     1BC4,W1
07D4E:  MOV     1BC6,W2
07D50:  MOV     1BC8,W3
07D52:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
07D54:  MOV.B   #1,W0L
07D56:  MOV.B   W0L,1BE2
07D58:  PUSH    1BBA
07D5A:  POP     1BDA
07D5C:  PUSH    1BBC
07D5E:  POP     1BDC
07D60:  PUSH    1BBE
07D62:  POP     1BDE
07D64:  PUSH    1BC0
07D66:  POP     1BE0
07D68:  CALL    791E
07D6C:  MOV     W0,1BC2
07D6E:  MOV     W1,1BC4
07D70:  MOV     W2,1BC6
07D72:  MOV     W3,1BC8
....................    return(r); 
07D74:  MOV     1BC2,W0
07D76:  MOV     1BC4,W1
07D78:  MOV     1BC6,W2
07D7A:  MOV     1BC8,W3
07D7C:  RETURN  
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
*
00696:  MOV     W5,[W15++]
00698:  MOV     W6,[W15++]
0069A:  MOV     W7,[W15++]
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
0069C:  CLR     1DB6
....................    sign = 0; 
0069E:  CLR     1DB2
....................    base = 10; 
006A0:  MOV     #A,W4
006A2:  MOV     W4,1DB4
....................    result = 0; 
006A4:  CLR     1DAE
006A6:  CLR     1DB0
....................  
....................    if (!s) 
006A8:  CP0     1DAC
006AA:  BRA     NZ,6B2
....................       return 0; 
006AC:  MOV     #0,W0
006AE:  MOV     #0,W1
006B0:  BRA     884
....................    c = s[index++]; 
006B2:  MOV     1DB6,W0
006B4:  INC     1DB6
006B6:  MOV     W0,W5
006B8:  MOV     W5,W0
006BA:  ADD     1DAC,W0
006BC:  MOV     1DB8,W4
006BE:  MOV.B   [W0+#0],W4L
006C0:  MOV     W4,1DB8
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
006C2:  MOV     1DB8,W4
006C4:  XOR.B   #2D,W4L
006C6:  BRA     NZ,6E0
....................    { 
....................       sign = 1;         // Set the sign to negative 
006C8:  MOV     #1,W4
006CA:  MOV     W4,1DB2
....................       c = s[index++]; 
006CC:  MOV     1DB6,W0
006CE:  INC     1DB6
006D0:  MOV     W0,W5
006D2:  MOV     W5,W0
006D4:  ADD     1DAC,W0
006D6:  MOV     1DB8,W4
006D8:  MOV.B   [W0+#0],W4L
006DA:  MOV     W4,1DB8
....................    } 
006DC:  GOTO    6F6
....................    else if (c == '+') 
006E0:  MOV     1DB8,W4
006E2:  XOR.B   #2B,W4L
006E4:  BRA     NZ,6F6
....................    { 
....................       c = s[index++]; 
006E6:  MOV     1DB6,W0
006E8:  INC     1DB6
006EA:  MOV     W0,W5
006EC:  MOV     W5,W0
006EE:  ADD     1DAC,W0
006F0:  MOV     1DB8,W4
006F2:  MOV.B   [W0+#0],W4L
006F4:  MOV     W4,1DB8
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
006F6:  MOV     1DB8,W4
006F8:  MOV     #30,W3
006FA:  CP.B    W3L,W4L
006FC:  BRA     GT,864
006FE:  MOV     1DB8,W4
00700:  MOV     #39,W3
00702:  CP.B    W3L,W4L
00704:  BRA     LT,864
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
00706:  MOV     1DB8,W4
00708:  XOR.B   #30,W4L
0070A:  BRA     NZ,736
0070C:  MOV     1DB6,W0
0070E:  ADD     1DAC,W0
00710:  MOV.B   [W0],W4L
00712:  XOR.B   #78,W4L
00714:  BRA     Z,720
00716:  MOV     1DB6,W0
00718:  ADD     1DAC,W0
0071A:  MOV.B   [W0],W4L
0071C:  XOR.B   #58,W4L
0071E:  BRA     NZ,736
....................       { 
....................          base = 16; 
00720:  MOV     #10,W4
00722:  MOV     W4,1DB4
....................          index++; 
00724:  INC     1DB6
....................          c = s[index++]; 
00726:  MOV     1DB6,W0
00728:  INC     1DB6
0072A:  MOV     W0,W5
0072C:  MOV     W5,W0
0072E:  ADD     1DAC,W0
00730:  MOV     1DB8,W4
00732:  MOV.B   [W0+#0],W4L
00734:  MOV     W4,1DB8
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
00736:  MOV     1DB4,W4
00738:  CP      W4,#A
0073A:  BRA     NZ,78C
....................       { 
....................          while (c >= '0' && c <= '9') 
0073C:  MOV     1DB8,W4
0073E:  MOV     #30,W3
00740:  CP.B    W3L,W4L
00742:  BRA     GT,788
00744:  MOV     1DB8,W4
00746:  MOV     #39,W3
00748:  CP.B    W3L,W4L
0074A:  BRA     LT,788
....................          { 
....................             result = 10*result + (c - '0'); 
0074C:  MOV     #A,W0
0074E:  MOV     #0,W1
00750:  MOV     1DAE,W2
00752:  MOV     1DB0,W3
00754:  CALL    654
00758:  MOV     W0,W5
0075A:  MOV     W1,W6
0075C:  MOV     1DB8,W4
0075E:  SUB.B   #30,W4L
00760:  MOV.B   W4L,W0L
00762:  MOV.B   W0L,0
00764:  SE      W0,W0
00766:  CLR     W1
00768:  BTSC    W0.F
0076A:  SETM    W1
0076C:  ADD     W0,W5,W0
0076E:  MOV     W0,1DAE
00770:  ADDC    W1,W6,W0
00772:  MOV     W0,1DB0
....................             c = s[index++]; 
00774:  MOV     1DB6,W0
00776:  INC     1DB6
00778:  MOV     W0,W5
0077A:  MOV     W5,W0
0077C:  ADD     1DAC,W0
0077E:  MOV     1DB8,W4
00780:  MOV.B   [W0+#0],W4L
00782:  MOV     W4,1DB8
00784:  GOTO    73C
....................          } 
....................       } 
00788:  GOTO    864
....................       else if (base == 16)    // The number is a hexa number 
0078C:  MOV     1DB4,W4
0078E:  CP      W4,#10
00790:  BRA     NZ,864
....................       { 
....................          c = toupper(c); 
00792:  MOV     1DB8,W4
00794:  MOV     #61,W3
00796:  CP.B    W3L,W4L
00798:  BRA     GTU,7A8
0079A:  MOV     1DB8,W4
0079C:  MOV     #7A,W3
0079E:  CP.B    W3L,W4L
007A0:  BRA     NC,7A8
007A2:  MOV.B   1DB8,W0L
007A4:  AND.B   #DF,W0L
007A6:  BRA     7AA
007A8:  MOV.B   1DB8,W0L
007AA:  MOV.B   W0L,1DB8
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
007AC:  MOV     1DB8,W4
007AE:  MOV     #30,W3
007B0:  CP.B    W3L,W4L
007B2:  BRA     GT,7BE
007B4:  MOV     1DB8,W4
007B6:  MOV     #39,W3
007B8:  CP.B    W3L,W4L
007BA:  BRA     LT,7BE
007BC:  BRA     7CE
007BE:  MOV     1DB8,W4
007C0:  MOV     #41,W3
007C2:  CP.B    W3L,W4L
007C4:  BRA     GT,864
007C6:  MOV     1DB8,W4
007C8:  MOV     #46,W3
007CA:  CP.B    W3L,W4L
007CC:  BRA     LT,864
....................          { 
....................             if (c >= '0' && c <= '9') 
007CE:  MOV     1DB8,W4
007D0:  MOV     #30,W3
007D2:  CP.B    W3L,W4L
007D4:  BRA     GT,80C
007D6:  MOV     1DB8,W4
007D8:  MOV     #39,W3
007DA:  CP.B    W3L,W4L
007DC:  BRA     LT,80C
....................                result = (result << 4) + (c - '0'); 
007DE:  MOV     #4,W4
007E0:  MOV     1DAE,W5
007E2:  MOV     1DB0,W6
007E4:  INC     W4,W4
007E6:  DEC     W4,W4
007E8:  BRA     Z,7F0
007EA:  SL      W5,W5
007EC:  RLC     W6,W6
007EE:  BRA     7E6
007F0:  MOV     1DB8,W4
007F2:  SUB.B   #30,W4L
007F4:  MOV.B   W4L,W0L
007F6:  MOV.B   W0L,0
007F8:  SE      W0,W0
007FA:  CLR     W1
007FC:  BTSC    W0.F
007FE:  SETM    W1
00800:  ADD     W0,W5,W0
00802:  MOV     W0,1DAE
00804:  ADDC    W1,W6,W0
00806:  MOV     W0,1DB0
00808:  GOTO    836
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0080C:  MOV     #4,W4
0080E:  MOV     1DAE,W5
00810:  MOV     1DB0,W6
00812:  INC     W4,W4
00814:  DEC     W4,W4
00816:  BRA     Z,81E
00818:  SL      W5,W5
0081A:  RLC     W6,W6
0081C:  BRA     814
0081E:  MOV     1DB8,W4
00820:  SUB.B   #41,W4L
00822:  MOV.B   W4L,W0L
00824:  MOV.B   W0L,0
00826:  ZE      W0,W0
00828:  CLR.B   1
0082A:  ADD     W0,#A,W0
0082C:  ADD     W0,W5,W0
0082E:  MOV     W0,1DAE
00830:  MOV     #0,W4
00832:  ADDC    W4,W6,W0
00834:  MOV     W0,1DB0
....................  
....................             c = s[index++];c = toupper(c); 
00836:  MOV     1DB6,W0
00838:  INC     1DB6
0083A:  MOV     W0,W5
0083C:  MOV     W5,W0
0083E:  ADD     1DAC,W0
00840:  MOV     1DB8,W4
00842:  MOV.B   [W0+#0],W4L
00844:  MOV     W4,1DB8
00846:  MOV     1DB8,W4
00848:  MOV     #61,W3
0084A:  CP.B    W3L,W4L
0084C:  BRA     GTU,85C
0084E:  MOV     1DB8,W4
00850:  MOV     #7A,W3
00852:  CP.B    W3L,W4L
00854:  BRA     NC,85C
00856:  MOV.B   1DB8,W0L
00858:  AND.B   #DF,W0L
0085A:  BRA     85E
0085C:  MOV.B   1DB8,W0L
0085E:  MOV.B   W0L,1DB8
00860:  GOTO    7AC
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
00864:  MOV     1DB4,W4
00866:  CP      W4,#A
00868:  BRA     NZ,880
0086A:  MOV     1DB2,W4
0086C:  CP      W4,#1
0086E:  BRA     NZ,880
....................       result = -result; 
00870:  MOV     #0,W4
00872:  MOV     1DAE,W3
00874:  SUB     W4,W3,W0
00876:  MOV     W0,1DAE
00878:  MOV     #0,W4
0087A:  MOV     1DB0,W3
0087C:  SUBB    W4,W3,W0
0087E:  MOV     W0,1DB0
....................  
....................    return(result); 
00880:  MOV     1DAE,W0
00882:  MOV     1DB0,W1
00884:  MOV     [--W15],W7
00886:  MOV     [--W15],W6
00888:  MOV     [--W15],W5
0088A:  RETURN  
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "servomoteur/servomoteur.h" 
.................... #ifndef _SERVOMOTEUR_H 
.................... #define _SERVOMOTEUR_H 
....................  
.................... // Nombre de servomoteurs (0 Ã  MAXSERVO-1) 
.................... #DEFINE MAXSERVO 1 
.................... // Valeurs min et max de l'impulsion en [100us] pour la protection des servomoteurs 
.................... #DEFINE MINSERVOPOSITION 9 
.................... #DEFINE MAXSERVOPOSITION 20 
.................... // Normalement 9 et 21 pour 900us et 2.1ms 
....................  
.................... // Structure pour la gestion des servomoteurs 
.................... struct T_Servo{ 
.................... 	int Position; 
.................... 	int Count; 
.................... 	int OpenValue; 
.................... 	int CloseValue; 
.................... }; 
....................  
.................... struct T_Servo ServoTab[MAXSERVO]; 
....................  
.................... void MoveServo(int number, int position); 
.................... void SetServo(int number, int state); 
.................... void OpenServo(int number); 
.................... void CloseServo(int number); 
.................... void CheckServo(); 
.................... void __Init_Servos(); 
....................  
.................... #include "servomoteur/servomoteur.c" 
.................... ///============================================================================================ 
.................... ///	void MoveServo(int number, int position) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de modifier la valeur de consigne (l'angle) d'un servomoteur 
.................... ///	Position défini la longueur de l'impulsion en [100us] 
.................... ///============================================================================================ 
.................... void MoveServo(int number, int position) 
*
09F90:  MOV     W5,[W15++]
09F92:  MOV     W6,[W15++]
.................... { 
.................... 	// Protection pour ne pas bloquer le servo en butée 
.................... 	if(position < MINSERVOPOSITION) 
09F94:  MOV     1B56,W4
09F96:  CP      W4,#9
09F98:  BRA     GE,9F9E
.................... 		position = MINSERVOPOSITION; 
09F9A:  MOV     #9,W4
09F9C:  MOV     W4,1B56
.................... 	 
.................... 	if (position > MAXSERVOPOSITION) 
09F9E:  MOV     1B56,W4
09FA0:  CP      W4,#14
09FA2:  BRA     LE,9FA8
.................... 		position = MAXSERVOPOSITION; 
09FA4:  MOV     #14,W4
09FA6:  MOV     W4,1B56
.................... 	// Définition de position du servomoteur 
.................... 	ServoTab[number].Position = position; 
09FA8:  MOV     1B54,W4
09FAA:  MUL.UU  W4,#8,W0
09FAC:  MOV     W0,W5
09FAE:  MOV     #1574,W4
09FB0:  ADD     W5,W4,W6
09FB2:  MOV     1B56,W4
09FB4:  MOV     W4,[W6+#0]
.................... 	 
.................... 	enable_interrupts(INT_TIMER2); 
09FB6:  BSET.B  8C.6
.................... 	delay_ms(500); 
09FB8:  MOV     #1F4,W0
09FBA:  CALL    EBE
.................... 	disable_interrupts(INT_TIMER2); 
09FBE:  BCLR.B  8C.6
09FC0:  MOV     [--W15],W6
09FC2:  MOV     [--W15],W5
09FC4:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void SetServo(int number, int state) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 13.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Permet de définir la sortie propre à chaque servomoteur 
.................... ///	output_bit() demande l'adresse du bit utilisé (par exemple avec un "#define PIN_A3 5651") 
.................... ///============================================================================================ 
.................... void SetServo(int number, int state) 
.................... { 
.................... 	switch (number) 
*
004C6:  MOV     1DBC,W0
004C8:  XOR     #0,W0
004CA:  BRA     Z,4CE
004CC:  BRA     4DE
.................... 	{ 
.................... 		case 0:		// Pour le servomoteur droit 
.................... 			output_bit(PIN_D4,state);	 
004CE:  CP0     1DBE
004D0:  BRA     NZ,4D6
004D2:  BCLR.B  2D6.4
004D4:  BRA     4D8
004D6:  BSET.B  2D6.4
004D8:  BCLR.B  2D2.4
.................... 			break; 
004DA:  GOTO    4E2
.................... 		default : 
.................... 			break; 
004DE:  GOTO    4E2
.................... 	} 
004E2:  RETURN  
.................... 	 
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void CheckServo() 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Gère la commande des servomoteurs 
.................... ///	Doit être appelé toutes les 100us 
.................... ///============================================================================================ 
.................... void CheckServo() 
004E4:  MOV     W5,[W15++]
004E6:  MOV     W6,[W15++]
.................... { 
.................... 	int i; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
004E8:  CLR     1DB8
004EA:  MOV     1DB8,W4
004EC:  CP      W4,#1
004EE:  BRA     GE,57E
.................... 	{ 
.................... 		if(ServoTab[i].Count<ServoTab[i].Position) 
004F0:  MOV     1DB8,W4
004F2:  MUL.UU  W4,#8,W0
004F4:  MOV     W0,W5
004F6:  ADD     W5,#2,W5
004F8:  MOV     W5,W0
004FA:  MOV     #1574,W4
004FC:  ADD     W0,W4,W0
004FE:  MOV     [W0],W5
00500:  MOV     1DB8,W4
00502:  MUL.UU  W4,#8,W6
00504:  MOV     #1574,W4
00506:  ADD     W6,W4,W0
00508:  MOV     W0,W4
0050A:  MOV     [W4],W0
0050C:  CP      W5,W0
0050E:  BRA     GE,530
.................... 		{ 
.................... 			// Ton 
.................... 			SetServo(i,1); 
00510:  PUSH    1DB8
00512:  POP     1DBC
00514:  MOV     #1,W4
00516:  MOV     W4,1DBE
00518:  CALL    4C6
.................... 			ServoTab[i].Count++; 
0051C:  MOV     1DB8,W4
0051E:  MUL.UU  W4,#8,W0
00520:  MOV     W0,W5
00522:  ADD     W5,#2,W5
00524:  MOV     W5,W0
00526:  MOV     #1574,W4
00528:  ADD     W0,W4,W5
0052A:  INC     [W5],[W5]
.................... 		}  
0052C:  GOTO    578
.................... 		else  
.................... 		{ 
.................... 			if(ServoTab[i].Count<197)  
00530:  MOV     1DB8,W4
00532:  MUL.UU  W4,#8,W0
00534:  MOV     W0,W5
00536:  ADD     W5,#2,W5
00538:  MOV     W5,W0
0053A:  MOV     #1574,W4
0053C:  ADD     W0,W4,W0
0053E:  MOV     [W0],W5
00540:  MOV     #C5,W4
00542:  CP      W4,W5
00544:  BRA     LE,564
.................... 			{ 
.................... 				// Toff 
.................... 				SetServo(i,0); 
00546:  PUSH    1DB8
00548:  POP     1DBC
0054A:  CLR     1DBE
0054C:  CALL    4C6
.................... 				ServoTab[i].Count++; 
00550:  MOV     1DB8,W4
00552:  MUL.UU  W4,#8,W0
00554:  MOV     W0,W5
00556:  ADD     W5,#2,W5
00558:  MOV     W5,W0
0055A:  MOV     #1574,W4
0055C:  ADD     W0,W4,W5
0055E:  INC     [W5],[W5]
.................... 			}  
00560:  GOTO    578
.................... 			else  
.................... 			{ 
.................... 				// Fin de la période 
.................... 				ServoTab[i].Count = 0; 
00564:  MOV     1DB8,W4
00566:  MUL.UU  W4,#8,W0
00568:  MOV     W0,W5
0056A:  ADD     W5,#2,W5
0056C:  MOV     W5,W0
0056E:  MOV     #1574,W4
00570:  ADD     W0,W4,W5
00572:  CLR.B   [W5]
00574:  MOV.B   #0,W0L
00576:  MOV.B   W0L,[W5+#1]
.................... 			} 
.................... 		} 
00578:  INC     1DB8
0057A:  GOTO    4EA
.................... 	} 
0057E:  MOV     [--W15],W6
00580:  MOV     [--W15],W5
00582:  RETURN  
.................... } 
....................  
.................... ///============================================================================================ 
.................... /// void OpenServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position ouverte définie avec ServoTab[x].OpenValue 
.................... ///============================================================================================ 
.................... void OpenServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].OpenValue); 
.................... } 
.................... ///============================================================================================ 
.................... /// void CloseServo(int number) 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Michel Jonathan, 16.04.2015, V1.0 
.................... ///-------------------------------------------------------------------------------------------- 
.................... ///	Déplace un servomoteur à sa position fermée définie avec ServoTab[x].CloseValue 
.................... ///============================================================================================ 
.................... void CloseServo(int number) 
.................... { 
.................... 	MoveServo(number, ServoTab[number].CloseValue); 
.................... } 
....................  
.................... ///	Initialisation de la structure des servomoteurs: 
.................... void __Init_Servos(void) 
.................... { 
.................... 	unsigned int8 i=0; 
.................... 	for (i = 0; i < MAXSERVO; i++) 
.................... 	{ 
.................... 		ServoTab[i].Position = 0; 
.................... 		ServoTab[i].Count = 0; 
.................... 	} 
....................  
.................... 	///	Configuration du TIMER2 pour 100us: 
.................... ///-------------------------------------------------------------------- 
.................... 	setup_timer2(TMR_INTERNAL, 1973); 
.................... 	// 1/((80MHz)/4)*1*2000 = 100us 
.................... 	enable_interrupts(INT_TIMER2); 
.................... } 
....................  
.................... ///	Interruption TIMER2 
.................... ///-------------------------------------------------------------------- 
.................... 	#INT_TIMER2 HIGH 
.................... 	void timer2_isr() 
00584:  PUSH    42
00586:  PUSH    36
00588:  PUSH    32
0058A:  MOV     W0,[W15++]
0058C:  MOV     #2,W0
0058E:  REPEAT  #C
00590:  MOV     [W0++],[W15++]
.................... 	{ 
.................... 		set_timer2(0); 
00592:  CLR     106
.................... 		CheckServo(); 
00594:  CALL    4E4
.................... 	} 
....................  
....................  
.................... #endif 
....................  
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS - PRINCIPE 
.................... ///==================================================================== 
.................... /// 
.................... ///	Le but est de gÃ©nÃ©rer des sorties pour la commandes de servomoteurs. 
.................... ///	Les sorties sont mises Ã  jour chaque 100us grÃ¢ce au TIMER2. 
.................... ///	Les impulsions de commande sont envoyÃ©es en continu. 
.................... /// 
.................... ///==================================================================== 
.................... /// 			COMMANDE DES SERVOMOTEURS  - UTILISATION 
.................... ///==================================================================== 
.................... /// 
.................... ///	MAXSERVO permet de dÃ©finir le nombre de servomoteurs utilisÃ©s 
.................... ///	MINSERVOPOSITION et MAXSERVOPOSITION fixent les valeurs min et max 
.................... ///	des impulsions Ã  gÃ©nÃ©rer pour la commande des servomoteurs, en 
.................... ///	gÃ©nÃ©ral on se limite Ã  900us (9) et 2.1ms (21) 
.................... /// 
.................... ///	CheckServo(): gÃ¨re la commande des servomoteurs, Ã  appeler toutes 
.................... ///	toutes les 100us 
.................... /// 
.................... ///	MoveServo(number, position): permet de modifier la valeur de consigne 
.................... ///	d'un servomoteur 
.................... /// 
.................... ///	SetServo(numer, state): utilisÃ© par CheckServo(), le switch case 
.................... ///	permet de dÃ©finir les sorties propres Ã  chaque servomoteurs. 
....................  
.................... #include "LCD/___LCD.h" 
.................... /* 
.................... * \file ___LCD.h 
.................... * \brief Gère l'afficheur LCD I2C (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_H 
00598:  BCLR.B  84.6
0059A:  MOV     #1A,W0
0059C:  REPEAT  #C
0059E:  MOV     [--W15],[W0--]
005A0:  MOV     [--W15],W0
005A2:  POP     32
005A4:  POP     36
005A6:  POP     42
005A8:  RETFIE  
.................... #define ___LCD_H 
....................  
.................... void __Init_LCD(void); // Init LCD 
.................... void __ClearLCD(void);	// Efface l'écran 
.................... void __WriteLCD(unsigned int8 _Command);	// Ecrit la commande  
.................... void __WriteCount(float64 _Value, int1 _Mode);	// Ecrit une valeur, int32 si mode = 0, float si mode = 1 
.................... void __SautLig(unsigned int8 _Lig);	// Saute d'une ligne sur l'écran 
....................  
.................... #include "LCD/___LCD.c" 
.................... /* 
.................... * \file ___LCD.c 
.................... * \brief Gère l'afficheur LCD I2C (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___LCD_C 
.................... #define ___LCD_C 
....................  
.................... void __Init_LCD(void) 
.................... { 
.................... 	// Config LCD IIC 
.................... 	i2c_start(); 
.................... 	i2c_write(0x50);	// Adresse du LCD 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x52);	// Contraste 
.................... 	i2c_write(0x24);	// 36 sur 50 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x53);	// Brightness backlight 
.................... 	i2c_write(6);		// 6 sur 8 
.................... 	i2c_write(0xFE);	// Commande 
.................... 	i2c_write(0x51);	// Efface l'écran 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __ClearLCD 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __ClearLCD(void) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Clear le LCD 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x51); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteLCD 
.................... // Ecrit ou envoi une commande au LCD. 
.................... // Prend quoi écrire. 
.................... // Ne retourne rien. 
.................... void __WriteLCD(unsigned int8 _Command) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
.................... unsigned int8 ack=i2c_write(0x50); 
.................... 	// Se connecte au LCD 
.................... 	if(ack==0) 
.................... 	// Ecrit ou envoi la comande au LCD 
.................... 	i2c_write(_Command); 
....................  
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
.................... } 
....................  
.................... // __WriteCount 
.................... // Permet d'écrire la valeur de la roue folle. 
.................... // Prend la valeur à écrire et le mode (0 = écrit. int, 1 = écrit. float tronqué) 
.................... // Ne retourne rien. 
.................... void __WriteCount(float64 _Value, int1 _Mode) 
.................... { 
.................... 	// Index d'affichage 
.................... 	unsigned int8 IAff=0, TabValue[16]; 
.................... 	 
.................... 	// Selon mode d'affichage choisi 
.................... 	// Transforme le nombre en chaîne de caractère 
.................... 	if(_Mode == 0) 
.................... 	sprintf(TabValue,"%7Ld ",(int32)_Value); 
.................... 	else	 
.................... 	sprintf(TabValue,"%6.3f ",(float64)_Value); 
.................... 		 
.................... 	// Affiche les caractères à la suite 
.................... 	while(TabValue[IAff]!=0x00) 
.................... 	{ 
.................... 		__WriteLCD(TabValue[IAff]); 
.................... 		Iaff++; 
.................... 	}	 
....................  
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... }	 
....................  
.................... // __SautLig 
.................... // Saute à la seconde ligne 
.................... // Ne prend rien. 
.................... // Ne retourne rien. 
.................... void __SautLig(unsigned int8 _Lig) 
.................... { 
.................... 	// Start l'I2C 
.................... 	i2c_start(); 
....................  
.................... 	// Se connecte au LCD 
.................... 	i2c_write(0x50); 
....................  
.................... 	// Saute à la seconde ligne 
.................... 	i2c_write(0xFE); 
.................... 	i2c_write(0x45); 
.................... 	i2c_write(_Lig); 
.................... 	// Ferme la liaison I2C 
.................... 	i2c_stop(); 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "Deplacement/___Depl.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl 
.................... #define ___Depl 
....................  
....................  
.................... /////////////////  Deplacement Progress  //////////////////////////////// 
.................... float64 amp_limit = 1.6;				 // limite de courant depl progress 
.................... unsigned int16 DIST_SECU_PROGRESS = 100; // distance de secu sur le deplacement progress en mm 
.................... 	 
.................... /////////////////  Localisation  //////////////////////////////// 
.................... signed int16 Dist_x,Dist_y=0; 
.................... signed int16 Pos_x = 0; //en mm 
.................... signed int16 Pos_y = 0;//en mm 
.................... signed int16 Orient_deg = 0; 
.................... float64 Dorient = 0;  
.................... float64 Orient = 0; 
.................... float64 DIAM_ENCO = 3.48139;	// Diamètre des encodeurs, en [cm] 
.................... float64 IMPULSES_ENCO = 5000;	// Nombre d'impulsions de l'encodeur (sans compter le x4 du QEI) 
.................... float64 ENTRAXE_ROUESFOLLES = 29.51922;//31.6006	// Entraxe entre les deux centres des roues folles, en [cm] 
....................  
.................... ///////////////// Calcul //////////////////////////////////////// 
.................... float64 COEFF_D	= (float64) (IMPULSES_ENCO*4)/(DIAM_ENCO*PI);	// Nbre de pas pour 1 [cm] 
.................... float64 CONV_DEG_RAD = (float64) (PI / 180); 
....................  
.................... ////////////////////// Gestion de la reception //////////////////////////////////// 
.................... unsigned int8 RoboteQ_receiveToProceed = 0;	// Position maximale pour la rÃ©ception 
.................... unsigned int8 RoboteQ_receiveLenght = 0;	// Longeur totale de la donnÃ©e 
.................... signed int32 Dist_Do = 0; 
....................  
.................... ///////////////////// Impulsions ////////////////////////////////////////////////// 
.................... signed int32 value_enco_g_start = 0;		//valeur enco debut deplacment 
.................... signed int32 value_enco_d_start = 0;		//valeur enco debut deplacement 
.................... signed int32 value_enco_g_end = 0;			//valeur enco fin deplacment 
.................... signed int32 value_enco_d_end = 0;			//valeur enco fin deplacement	 
....................  
....................  
.................... /////////////////  Prototype fct  //////////////////////////////// 
.................... void __Stop(); 
.................... void __DeplToDo(unsigned int8 _Command);	// 0--> turn, 1--> PaP, 2--> progress, 4-->nothing 
.................... void __Turn(signed int16 _Ang);				 
.................... void __PaP(int16 _X, int16 _Y); 
.................... void __Progress(int16 _X, int16 _Y); 
.................... void __Nothing(void); 
.................... float64 __Get_amp(int channel); 
.................... void __Init_pos(void); 
.................... void __LoadObj(unsigned int16 _Obj); // Charge les différents paramètres des objectifs selon lequel est sélectionné 
.................... float64 __Conv_Ang_4Quadr(float64 _Ang); // Convertit un angle selon le cadran de l'objectif. 
.................... void __Get_enco_value(int1 start_end); 
.................... #include "Deplacement/___Depl.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Borgeat Remy    					  										== 
.................... ===  Date				: 30.1.2017    															== 
.................... ===  Nom du programme 	: CartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Ce fichier gere les deplacement du robot														== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Depl_c 
.................... #define ___Depl_c 
....................  
.................... //********************************************************************************************************************* 
.................... // arrondi_float 
.................... // 
.................... // Cette fonction permet d'arrondir un nombre decimal en entier relatif 
.................... // 12.7863 => 13 
.................... // 14.45621 => 14  
.................... // 
.................... // Developpe par : Louis Mayencourt 
.................... // Date :          01.12.2010  
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : nombre a convertir  
.................... // return      : nombre converti 
.................... // 
.................... //********************************************************************************************************************* 
.................... signed int32 arrondi_float_signed(float nombre) 
.................... { 
.................... 	float chiffres_apres_virgule;		// contient les chiffres apres la virgule du float a convertir  
....................  
.................... // prend les chiffres apres la virgule 
.................... 	chiffres_apres_virgule = nombre-floor(nombre); 
*
07200:  PUSH    1BB6
07202:  POP     1BD4
07204:  PUSH    1BB8
07206:  POP     1BD6
07208:  CALL    2770
0720C:  BSET.B  43.0
0720E:  MOV     W0,W2
07210:  MOV     W1,W3
07212:  MOV     1BB6,W0
07214:  MOV     1BB8,W1
07216:  CALL    2446
0721A:  MOV     W0,1BBA
0721C:  MOV     W1,1BBC
....................  
.................... // test si il faut arrondir vers le bas ou le haut 
.................... 	if(chiffres_apres_virgule>=0.5) return( (signed int32)(ceil(nombre))); 
0721E:  MOV     #0,W0
07220:  MOV     #3F00,W1
07222:  MOV     1BBA,W2
07224:  MOV     1BBC,W3
07226:  CALL    21EA
0722A:  BRA     C,722E
0722C:  BRA     NZ,7246
0722E:  PUSH    1BB6
07230:  POP     1BD4
07232:  PUSH    1BB8
07234:  POP     1BD6
07236:  CALL    275C
0723A:  CALL    71C0
0723E:  MOV.D   W0,W0
07240:  BRA     725A
07242:  GOTO    725A
.................... 	else return( (signed int32)(floor(nombre))); 
07246:  PUSH    1BB6
07248:  POP     1BD4
0724A:  PUSH    1BB8
0724C:  POP     1BD6
0724E:  CALL    2770
07252:  CALL    71C0
07256:  MOV.D   W0,W0
07258:  BRA     725A
0725A:  RETURN  
.................... } 
....................  
.................... void __Affichage_Erreur(int8 nombre) 
.................... { 
.................... 	No_erreur = nombre;  
*
0102A:  MOV.B   1B5C,W0L
0102C:  MOV.B   W0L,870
.................... 	flag_error = 1;  
0102E:  BSET.B  85B.2
.................... 		// Quitte la fonction 
.................... 	return; 
01030:  RETURN  
.................... } 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Check_commande_atteint 
.................... //	Auteur :	BORREM 
.................... //	Date:	    18.2.15 
.................... //  Statut :    fonctionnel 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Check si la commande donnÃ© aux moteurs a Ã©tÃ© finie 
.................... void __Check_commande_atteint(void) 
*
07D7E:  MOV     W5,[W15++]
07D80:  MOV     W6,[W15++]
07D82:  BCLR.B  1BB0.1
.................... { 
.................... 	int1 comm_atteinte_m1,comm_atteinte_m2 = 0; 
.................... 	fprintf(ROBOTEQ,"?DR\r"); 
07D84:  MOV     #0,W1
07D86:  MOV     W1,W0
07D88:  CLR.B   1
07D8A:  CALL    100
07D8E:  INC     W1,W1
07D90:  BTSC.B  219.1
07D92:  BRA     7D90
07D94:  MOV     W0,21A
07D96:  MOV     #3,W0
07D98:  CPSGT   W1,W0
07D9A:  BRA     7D86
.................... //il renvoie DR=x:x 
.................... 	delay_ms(20); 
07D9C:  MOV     #14,W0
07D9E:  CALL    EBE
.................... //on vÃ©rifie que le premier caractÃ¨re n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] != '!' && RoboteQ_receiveBuffer[0] != '?' && RoboteQ_receiveBuffer[0] != '~' && RoboteQ_receiveBuffer[0] != '^' && RoboteQ_receiveBuffer[0] != '#') 
07DA2:  MOV     882,W4
07DA4:  XOR.B   #21,W4L
07DA6:  BRA     Z,7DCC
07DA8:  MOV     882,W4
07DAA:  XOR.B   #3F,W4L
07DAC:  BRA     Z,7DCC
07DAE:  MOV     882,W4
07DB0:  XOR.B   #7E,W4L
07DB2:  BRA     Z,7DCC
07DB4:  MOV     882,W4
07DB6:  XOR.B   #5E,W4L
07DB8:  BRA     Z,7DCC
07DBA:  MOV     882,W4
07DBC:  XOR.B   #23,W4L
07DBE:  BRA     Z,7DCC
.................... 	{ 
.................... 		comm_atteinte_m1 = RoboteQ_receiveBuffer[3]; // affectation du premier x dans la variable 
07DC0:  BCLR.B  1BB0.0
07DC2:  BTSC.B  885.0
07DC4:  BSET.B  1BB0.0
.................... 		comm_atteinte_m2 = RoboteQ_receiveBuffer[5]; // affectation du deuxiÃ¨me x dans la variable 
07DC6:  BCLR.B  1BB0.1
07DC8:  BTSC.B  887.0
07DCA:  BSET.B  1BB0.1
.................... 	} 
.................... 	if(comm_atteinte_m1 == 1 && comm_atteinte_m2== 1) // si commande des deux moteurs dini  
07DCC:  BTSS.B  1BB0.0
07DCE:  BRA     7DD6
07DD0:  BTSS.B  1BB0.1
07DD2:  BRA     7DD6
.................... 	{ 
.................... 		flag_depl_ok =1 ; // on peut passer au dÃ©placement suivant 
07DD4:  BSET.B  85A.6
.................... 	} 
07DD6:  MOV     [--W15],W6
07DD8:  MOV     [--W15],W5
07DDA:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_amp(int channel) 
.................... * \brief Recupere la valeur du courant dans les moteurs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] channel--> 1 moteur 1, 2  moteur 2  
.................... * \return Ne retourne rien 
.................... */ 
.................... float64 __Get_amp(int channel) 
*
08A9C:  MOV     W5,[W15++]
08A9E:  MOV     W6,[W15++]
08AA0:  CLR     1B7E
08AA2:  MOV.B   #2,W0L
08AA4:  MOV.B   W0L,1B80
.................... { 
.................... 	unsigned int16 ampere = 0; 
.................... 	unsigned int8 i = 2; 
.................... 	if(channel == 1) 
08AA6:  MOV     1B7C,W4
08AA8:  CP      W4,#1
08AAA:  BRA     NZ,8AC8
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 1\r"); 
08AAC:  MOV     #0,W1
08AAE:  MOV     W1,W0
08AB0:  CLR.B   1
08AB2:  CALL    112
08AB6:  INC     W1,W1
08AB8:  BTSC.B  219.1
08ABA:  BRA     8AB8
08ABC:  MOV     W0,21A
08ABE:  MOV     #4,W0
08AC0:  CPSGT   W1,W0
08AC2:  BRA     8AAE
.................... 	} 
08AC4:  GOTO    8AE0
.................... 	else 
.................... 	{ 
.................... 		fprintf(ROBOTEQ,"?A 2\r"); 
08AC8:  MOV     #0,W1
08ACA:  MOV     W1,W0
08ACC:  CLR.B   1
08ACE:  CALL    124
08AD2:  INC     W1,W1
08AD4:  BTSC.B  219.1
08AD6:  BRA     8AD4
08AD8:  MOV     W0,21A
08ADA:  MOV     #4,W0
08ADC:  CPSGT   W1,W0
08ADE:  BRA     8ACA
.................... 	}  
.................... 	//il renvoie DR=x:x 
.................... 	delay_ms(10); 
08AE0:  MOV     #A,W0
08AE2:  CALL    EBE
.................... 	//on verifie que le premier caractere n'indique pas une rÃ©pÃ©tiotion de commande 
.................... 	if(RoboteQ_receiveBuffer[0] == 'A') 
08AE6:  MOV     882,W4
08AE8:  XOR.B   #41,W4L
08AEA:  BRA     NZ,8B3C
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= '\r') 
08AEC:  MOV     1B80,W4
08AEE:  CLR.B   9
08AF0:  MOV     #882,W3
08AF2:  ADD     W4,W3,W0
08AF4:  MOV.B   [W0],W4L
08AF6:  CP.B    W4L,#D
08AF8:  BRA     Z,8B2A
.................... 		{ 
.................... 			if(RoboteQ_receiveBuffer[i]!=0x2D) // 0x2D -> signe '-' en ascii, courant neg -> on prend en abs 
08AFA:  MOV     1B80,W4
08AFC:  CLR.B   9
08AFE:  MOV     #882,W3
08B00:  ADD     W4,W3,W0
08B02:  MOV.B   [W0],W5L
08B04:  SE      W5,W5
08B06:  MOV     #2D,W4
08B08:  CP      W4,W5
08B0A:  BRA     Z,8B24
.................... 			{ 
.................... 				ampere  *= 10; 
08B0C:  MOV     1B7E,W4
08B0E:  MUL.UU  W4,#A,W0
08B10:  MOV     W0,1B7E
.................... 				ampere  += RoboteQ_receiveBuffer[i]-0x30; 
08B12:  MOV     1B80,W4
08B14:  CLR.B   9
08B16:  MOV     #882,W3
08B18:  ADD     W4,W3,W0
08B1A:  MOV.B   [W0],W5L
08B1C:  SE      W5,W5
08B1E:  MOV     #30,W4
08B20:  SUB     W5,W4,W0
08B22:  ADD     1B7E
.................... 			} 
.................... 			i++;  
08B24:  INC.B   1B80
08B26:  GOTO    8AEC
.................... 		} 
.................... 		return(ampere); 
08B2A:  MOV     1B7E,W0
08B2C:  MOV     #0,W1
08B2E:  MOV     #0,W2
08B30:  MOV     #0,W3
08B32:  CALL    8A38
08B36:  BRA     8B46
.................... 	} 
08B38:  GOTO    8B46
.................... 	else 
.................... 	{ 
.................... 		return(0); 
08B3C:  MOV     #0,W0
08B3E:  MOV     #0,W1
08B40:  MOV     #0,W2
08B42:  MOV     #0,W3
08B44:  BRA     8B46
.................... 	} 
08B46:  MOV     [--W15],W6
08B48:  MOV     [--W15],W5
08B4A:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Get_enco_value(int1 start_end) 
.................... * \brief Recupere la valeur des encodeurs du robot 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] 1 -> enco au depart, 0 -> enco a la fin 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Get_enco_value(int1 start_end) 
*
07DDC:  MOV     W5,[W15++]
07DDE:  MOV     W6,[W15++]
07DE0:  MOV.B   #2,W0L
07DE2:  MOV.B   W0L,1BB1
07DE4:  BCLR.B  1BB2.0
.................... { 
.................... 	unsigned int8 i = 2; 
.................... 	int1 flag_inverted = 0; 
.................... 	if(start_end) // si recuperation enco au depart --> on clear tout 
07DE6:  CP0.B   1BB0
07DE8:  BRA     Z,7DFA
.................... 	{ 
.................... 		value_enco_g_start = 0; 
07DEA:  CLR     15D0
07DEC:  CLR     15D2
.................... 		value_enco_d_start = 0; 
07DEE:  CLR     15D4
07DF0:  CLR     15D6
.................... 		value_enco_g_end   = 0; 
07DF2:  CLR     15D8
07DF4:  CLR     15DA
.................... 		value_enco_d_end   = 0; 
07DF6:  CLR     15DC
07DF8:  CLR     15DE
.................... 	} 
....................  
.................... 	fprintf(ROBOTEQ,"?C\r"); // on demande la valeur des encodeurs 
07DFA:  BTSC.B  219.1
07DFC:  BRA     7DFA
07DFE:  MOV     #3F,W4
07E00:  MOV     W4,21A
07E02:  BTSC.B  219.1
07E04:  BRA     7E02
07E06:  MOV     #43,W4
07E08:  MOV     W4,21A
07E0A:  BTSC.B  219.1
07E0C:  BRA     7E0A
07E0E:  MOV     #D,W4
07E10:  MOV     W4,21A
.................... 	delay_ms(20); 
07E12:  MOV     #14,W0
07E14:  CALL    EBE
.................... 	 
.................... 	if(RoboteQ_receiveBuffer[0] == 'C') // si on reçoit C=xxxx:xxxx 
07E18:  MOV     882,W4
07E1A:  XOR.B   #43,W4L
07E1C:  BRA     NZ,8008
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i]!= ':') 
07E1E:  MOV     1BB0,W4
07E20:  LSR     W4,#8,W4
07E22:  MOV     #882,W3
07E24:  ADD     W4,W3,W0
07E26:  MOV.B   [W0],W4L
07E28:  XOR.B   #3A,W4L
07E2A:  BRA     Z,7EE2
.................... 		{ 
.................... 			if(start_end) 
07E2C:  CP0.B   1BB0
07E2E:  BRA     Z,7E88
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
07E30:  MOV     1BB0,W4
07E32:  LSR     W4,#8,W4
07E34:  MOV     #882,W3
07E36:  ADD     W4,W3,W0
07E38:  MOV.B   [W0],W5L
07E3A:  SE      W5,W5
07E3C:  MOV     #2D,W4
07E3E:  CP      W4,W5
07E40:  BRA     NZ,7E48
.................... 				{ 
.................... 					flag_inverted = 1; 
07E42:  BSET.B  1BB2.0
.................... 				} 
07E44:  GOTO    7E84
07E48:  PUSH    42
07E4A:  BCLR.B  81.7
07E4C:  SETM.B  42
07E4E:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_start *= 10; 
07E50:  MOV     15D0,W0
07E52:  MOV     15D2,W1
07E54:  MOV     #A,W2
07E56:  MOV     #0,W3
07E58:  CALL    654
07E5C:  BCLR.B  81.7
07E5E:  POP     42
07E60:  BSET.B  81.7
07E62:  MOV     W0,15D0
07E64:  MOV     W1,15D2
.................... 					value_enco_g_start += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
07E66:  MOV     1BB0,W4
07E68:  LSR     W4,#8,W4
07E6A:  MOV     #882,W3
07E6C:  ADD     W4,W3,W0
07E6E:  MOV.B   [W0],W5L
07E70:  SE      W5,W5
07E72:  MOV     #30,W4
07E74:  SUB     W5,W4,W0
07E76:  CLR     W1
07E78:  BTSC    W0.F
07E7A:  SETM    W1
07E7C:  ADD     15D0
07E7E:  MOV     W1,W0
07E80:  ADDC    15D2,W0
07E82:  MOV     W0,15D2
.................... 				}				 
.................... 			} 
07E84:  GOTO    7EDC
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D) // 0x2D -> signe '-' en ascii 
07E88:  MOV     1BB0,W4
07E8A:  LSR     W4,#8,W4
07E8C:  MOV     #882,W3
07E8E:  ADD     W4,W3,W0
07E90:  MOV.B   [W0],W5L
07E92:  SE      W5,W5
07E94:  MOV     #2D,W4
07E96:  CP      W4,W5
07E98:  BRA     NZ,7EA0
.................... 				{ 
.................... 					flag_inverted = 1; 
07E9A:  BSET.B  1BB2.0
.................... 				} 
07E9C:  GOTO    7EDC
07EA0:  PUSH    42
07EA2:  BCLR.B  81.7
07EA4:  SETM.B  42
07EA6:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_g_end *= 10; 
07EA8:  MOV     15D8,W0
07EAA:  MOV     15DA,W1
07EAC:  MOV     #A,W2
07EAE:  MOV     #0,W3
07EB0:  CALL    654
07EB4:  BCLR.B  81.7
07EB6:  POP     42
07EB8:  BSET.B  81.7
07EBA:  MOV     W0,15D8
07EBC:  MOV     W1,15DA
.................... 					value_enco_g_end += RoboteQ_receiveBuffer[i]-0x30; // on met les caractere dans la variable 
07EBE:  MOV     1BB0,W4
07EC0:  LSR     W4,#8,W4
07EC2:  MOV     #882,W3
07EC4:  ADD     W4,W3,W0
07EC6:  MOV.B   [W0],W5L
07EC8:  SE      W5,W5
07ECA:  MOV     #30,W4
07ECC:  SUB     W5,W4,W0
07ECE:  CLR     W1
07ED0:  BTSC    W0.F
07ED2:  SETM    W1
07ED4:  ADD     15D8
07ED6:  MOV     W1,W0
07ED8:  ADDC    15DA,W0
07EDA:  MOV     W0,15DA
.................... 				} 
.................... 			} 
.................... 			i++; 
07EDC:  INC.B   1BB1
07EDE:  GOTO    7E1E
.................... 		} 
.................... 		if(flag_inverted) //si l'on a recu un nbre d'impulses negatifs 
07EE2:  BTSS.B  1BB2.0
07EE4:  BRA     7F12
.................... 		{ 
.................... 			if(start_end)  
07EE6:  CP0.B   1BB0
07EE8:  BRA     Z,7F00
.................... 			{ 
.................... 				value_enco_g_start = 0-value_enco_g_start; // on inverse tout 
07EEA:  MOV     #0,W4
07EEC:  MOV     15D0,W3
07EEE:  SUB     W4,W3,W0
07EF0:  MOV     W0,15D0
07EF2:  MOV     #0,W4
07EF4:  MOV     15D2,W3
07EF6:  SUBB    W4,W3,W0
07EF8:  MOV     W0,15D2
.................... 				flag_inverted = 0; 
07EFA:  BCLR.B  1BB2.0
.................... 			} 
07EFC:  GOTO    7F12
.................... 			else 
.................... 			{ 
.................... 				value_enco_g_end = 0-value_enco_g_end;	// on inverse tout 
07F00:  MOV     #0,W4
07F02:  MOV     15D8,W3
07F04:  SUB     W4,W3,W0
07F06:  MOV     W0,15D8
07F08:  MOV     #0,W4
07F0A:  MOV     15DA,W3
07F0C:  SUBB    W4,W3,W0
07F0E:  MOV     W0,15DA
.................... 				flag_inverted = 0; 
07F10:  BCLR.B  1BB2.0
.................... 			} 
.................... 		} 
.................... 		i++; 
07F12:  INC.B   1BB1
.................... 		while(RoboteQ_receiveBuffer[i]!='\r')//tant que la transmission n'est pas fini 
07F14:  MOV     1BB0,W4
07F16:  LSR     W4,#8,W4
07F18:  MOV     #882,W3
07F1A:  ADD     W4,W3,W0
07F1C:  MOV.B   [W0],W4L
07F1E:  CP.B    W4L,#D
07F20:  BRA     Z,7FD8
.................... 		{ 
.................... 			if(start_end) 
07F22:  CP0.B   1BB0
07F24:  BRA     Z,7F7E
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
07F26:  MOV     1BB0,W4
07F28:  LSR     W4,#8,W4
07F2A:  MOV     #882,W3
07F2C:  ADD     W4,W3,W0
07F2E:  MOV.B   [W0],W5L
07F30:  SE      W5,W5
07F32:  MOV     #2D,W4
07F34:  CP      W4,W5
07F36:  BRA     NZ,7F3E
.................... 				{ 
.................... 					flag_inverted = 1; 
07F38:  BSET.B  1BB2.0
.................... 				} 
07F3A:  GOTO    7F7A
07F3E:  PUSH    42
07F40:  BCLR.B  81.7
07F42:  SETM.B  42
07F44:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_start *= 10; 
07F46:  MOV     15D4,W0
07F48:  MOV     15D6,W1
07F4A:  MOV     #A,W2
07F4C:  MOV     #0,W3
07F4E:  CALL    654
07F52:  BCLR.B  81.7
07F54:  POP     42
07F56:  BSET.B  81.7
07F58:  MOV     W0,15D4
07F5A:  MOV     W1,15D6
.................... 					value_enco_d_start += RoboteQ_receiveBuffer[i]-0x30; 
07F5C:  MOV     1BB0,W4
07F5E:  LSR     W4,#8,W4
07F60:  MOV     #882,W3
07F62:  ADD     W4,W3,W0
07F64:  MOV.B   [W0],W5L
07F66:  SE      W5,W5
07F68:  MOV     #30,W4
07F6A:  SUB     W5,W4,W0
07F6C:  CLR     W1
07F6E:  BTSC    W0.F
07F70:  SETM    W1
07F72:  ADD     15D4
07F74:  MOV     W1,W0
07F76:  ADDC    15D6,W0
07F78:  MOV     W0,15D6
.................... 				} 
.................... 			} 
07F7A:  GOTO    7FD2
.................... 			else 
.................... 			{ 
.................... 				if(RoboteQ_receiveBuffer[i]==0x2D)// 0x2D -> signe '-' en ascii 
07F7E:  MOV     1BB0,W4
07F80:  LSR     W4,#8,W4
07F82:  MOV     #882,W3
07F84:  ADD     W4,W3,W0
07F86:  MOV.B   [W0],W5L
07F88:  SE      W5,W5
07F8A:  MOV     #2D,W4
07F8C:  CP      W4,W5
07F8E:  BRA     NZ,7F96
.................... 				{ 
.................... 					flag_inverted = 1; 
07F90:  BSET.B  1BB2.0
.................... 				} 
07F92:  GOTO    7FD2
07F96:  PUSH    42
07F98:  BCLR.B  81.7
07F9A:  SETM.B  42
07F9C:  BSET.B  81.7
.................... 				else 
.................... 				{ 
.................... 					value_enco_d_end *= 10; 
07F9E:  MOV     15DC,W0
07FA0:  MOV     15DE,W1
07FA2:  MOV     #A,W2
07FA4:  MOV     #0,W3
07FA6:  CALL    654
07FAA:  BCLR.B  81.7
07FAC:  POP     42
07FAE:  BSET.B  81.7
07FB0:  MOV     W0,15DC
07FB2:  MOV     W1,15DE
.................... 					value_enco_d_end += RoboteQ_receiveBuffer[i]-0x30;			 
07FB4:  MOV     1BB0,W4
07FB6:  LSR     W4,#8,W4
07FB8:  MOV     #882,W3
07FBA:  ADD     W4,W3,W0
07FBC:  MOV.B   [W0],W5L
07FBE:  SE      W5,W5
07FC0:  MOV     #30,W4
07FC2:  SUB     W5,W4,W0
07FC4:  CLR     W1
07FC6:  BTSC    W0.F
07FC8:  SETM    W1
07FCA:  ADD     15DC
07FCC:  MOV     W1,W0
07FCE:  ADDC    15DE,W0
07FD0:  MOV     W0,15DE
.................... 				} 
.................... 			} 
.................... 			i++;		 
07FD2:  INC.B   1BB1
07FD4:  GOTO    7F14
.................... 		} 
.................... 		if(flag_inverted)//si l'on a recu un nbre d'impulses negatifs 
07FD8:  BTSS.B  1BB2.0
07FDA:  BRA     8008
.................... 		{ 
.................... 			if(start_end) 
07FDC:  CP0.B   1BB0
07FDE:  BRA     Z,7FF6
.................... 			{ 
.................... 				value_enco_d_start = 0-value_enco_d_start;// on inverse tout 
07FE0:  MOV     #0,W4
07FE2:  MOV     15D4,W3
07FE4:  SUB     W4,W3,W0
07FE6:  MOV     W0,15D4
07FE8:  MOV     #0,W4
07FEA:  MOV     15D6,W3
07FEC:  SUBB    W4,W3,W0
07FEE:  MOV     W0,15D6
.................... 				flag_inverted = 0; 
07FF0:  BCLR.B  1BB2.0
.................... 			} 
07FF2:  GOTO    8008
.................... 			else 
.................... 			{ 
.................... 				value_enco_d_end = 0-value_enco_d_end;// on inverse tout 
07FF6:  MOV     #0,W4
07FF8:  MOV     15DC,W3
07FFA:  SUB     W4,W3,W0
07FFC:  MOV     W0,15DC
07FFE:  MOV     #0,W4
08000:  MOV     15DE,W3
08002:  SUBB    W4,W3,W0
08004:  MOV     W0,15DE
.................... 				flag_inverted = 0; 
08006:  BCLR.B  1BB2.0
.................... 			} 
.................... 		} 
.................... 	} 
.................... 	if(!start_end) 
08008:  CP0.B   1BB0
0800A:  BRA     NZ,803A
.................... 	{ 
.................... 		Dist_Do = ((value_enco_g_end-value_enco_g_start)+(value_enco_d_end-value_enco_d_start))/2; // calcul distance parcourue 
0800C:  MOV     15D8,W4
0800E:  MOV     15D0,W3
08010:  SUB     W4,W3,W5
08012:  MOV     15DA,W4
08014:  MOV     15D2,W3
08016:  SUBB    W4,W3,W6
08018:  MOV     15DC,W4
0801A:  MOV     15D4,W3
0801C:  SUB     W4,W3,W0
0801E:  MOV     15DE,W4
08020:  MOV     15D6,W3
08022:  SUBB    W4,W3,W1
08024:  ADD     W0,W5,W5
08026:  ADDC    W1,W6,W6
08028:  BCLR.B  43.0
0802A:  MOV     W5,W0
0802C:  MOV     W6,W1
0802E:  MOV     #2,W2
08030:  MOV     #0,W3
08032:  CALL    1E76
08036:  MOV     W0,15CC
08038:  MOV     W1,15CE
.................... 	} 
0803A:  MOV     [--W15],W6
0803C:  MOV     [--W15],W5
0803E:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Actual_pos(void) 
.................... * \brief Actualise la position xy du robot s'il doit switcher d'objectifs 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] - 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __actual_pos(void) 
*
0A006:  MOV     W5,[W15++]
0A008:  MOV     W6,[W15++]
0A00A:  MOV     W7,[W15++]
0A00C:  MOV     W8,[W15++]
0A00E:  CLR     1B54
0A010:  CLR     1B56
0A012:  CLR     1B58
0A014:  CLR     1B5A
0A016:  CLR     1B5C
0A018:  CLR     1B5E
.................... { 
.................... 	signed int32 Dist_Do_mm = 0; 
.................... 	signed int32 dx = 0; 
.................... 	signed int32 dy = 0; 
.................... 	__Get_enco_value(0); // recuperation delta x,y 
0A01A:  CLR.B   1BB0
0A01C:  CALL    7DDC
.................... 							 
.................... 	Dist_Do_mm = (signed int32)(Dist_Do/(COEFF_D/10)); 
0A020:  MOV     15BA,W0
0A022:  MOV     15BC,W1
0A024:  MOV     15BE,W2
0A026:  MOV     15C0,W3
0A028:  MOV     #0,W4
0A02A:  MOV     #0,W5
0A02C:  MOV     #0,W6
0A02E:  MOV     #4024,W7
0A030:  CALL    D0A
0A034:  MOV     W0,W5
0A036:  MOV     W1,W6
0A038:  MOV     W2,W7
0A03A:  MOV     W3,W8
0A03C:  MOV     15CC,W0
0A03E:  MOV     15CE,W1
0A040:  CLR     W3
0A042:  BTSC    W1.F
0A044:  SETM    W3
0A046:  MOV     W3,W2
0A048:  CALL    1D68
0A04C:  MOV     W5,[W15++]
0A04E:  MOV     W6,[W15++]
0A050:  MOV     W7,[W15++]
0A052:  MOV     W5,W4
0A054:  MOV     W6,W5
0A056:  MOV     W7,W6
0A058:  MOV     W8,W7
0A05A:  CALL    D0A
0A05E:  MOV     [--W15],W7
0A060:  MOV     [--W15],W6
0A062:  MOV     [--W15],W5
0A064:  CALL    78C8
0A068:  MOV     W0,1B54
0A06A:  MOV     W1,1B56
.................... 	///////////////////////// Calcul dx,dy //////////////////////////// 
.................... 	if(0 <= Orient && Orient <= PI)//entre 0 et 180deg 
0A06C:  MOV     #0,W0
0A06E:  MOV     #0,W1
0A070:  MOV     #0,W2
0A072:  MOV     #0,W3
0A074:  MOV     159A,W4
0A076:  MOV     159C,W5
0A078:  MOV     159E,W6
0A07A:  MOV     15A0,W7
0A07C:  CALL    70F8
0A080:  BRA     C,A084
0A082:  BRA     NZ,A154
0A084:  MOV     159A,W0
0A086:  MOV     159C,W1
0A088:  MOV     159E,W2
0A08A:  MOV     15A0,W3
0A08C:  MOV     #2D18,W4
0A08E:  MOV     #5444,W5
0A090:  MOV     #21FB,W6
0A092:  MOV     #4009,W7
0A094:  CALL    70F8
0A098:  BRA     C,A09C
0A09A:  BRA     NZ,A154
.................... 	{ 
.................... 		dx =  (signed int16)(cos(Orient) * Dist_Do_mm); 
0A09C:  PUSH    159A
0A09E:  POP     1B96
0A0A0:  PUSH    159C
0A0A2:  POP     1B98
0A0A4:  PUSH    159E
0A0A6:  POP     1B9A
0A0A8:  PUSH    15A0
0A0AA:  POP     1B9C
0A0AC:  CALL    8BA2
0A0B0:  MOV     W0,W5
0A0B2:  MOV     W1,W6
0A0B4:  MOV     W2,W7
0A0B6:  MOV     W3,W8
0A0B8:  MOV     1B54,W0
0A0BA:  MOV     1B56,W1
0A0BC:  CLR     W3
0A0BE:  BTSC    W1.F
0A0C0:  SETM    W3
0A0C2:  MOV     W3,W2
0A0C4:  CALL    1D68
0A0C8:  MOV     W5,[W15++]
0A0CA:  MOV     W6,[W15++]
0A0CC:  MOV     W7,[W15++]
0A0CE:  MOV     W0,W4
0A0D0:  MOV     W5,W0
0A0D2:  MOV     W1,W5
0A0D4:  MOV     W6,W1
0A0D6:  MOV     W2,W6
0A0D8:  MOV     W7,W2
0A0DA:  MOV     W3,W7
0A0DC:  MOV     W8,W3
0A0DE:  CALL    BFA
0A0E2:  MOV     [--W15],W7
0A0E4:  MOV     [--W15],W6
0A0E6:  MOV     [--W15],W5
0A0E8:  CALL    78C8
0A0EC:  CLR     W1
0A0EE:  BTSC    W0.F
0A0F0:  SETM    W1
0A0F2:  MOV     W0,1B58
0A0F4:  MOV     W1,1B5A
.................... 		dy =  (signed int16)(sin(Orient) * Dist_Do_mm);	 
0A0F6:  PUSH    159A
0A0F8:  POP     1B7C
0A0FA:  PUSH    159C
0A0FC:  POP     1B7E
0A0FE:  PUSH    159E
0A100:  POP     1B80
0A102:  PUSH    15A0
0A104:  POP     1B82
0A106:  CALL    8E5C
0A10A:  MOV     W0,W5
0A10C:  MOV     W1,W6
0A10E:  MOV     W2,W7
0A110:  MOV     W3,W8
0A112:  MOV     1B54,W0
0A114:  MOV     1B56,W1
0A116:  CLR     W3
0A118:  BTSC    W1.F
0A11A:  SETM    W3
0A11C:  MOV     W3,W2
0A11E:  CALL    1D68
0A122:  MOV     W5,[W15++]
0A124:  MOV     W6,[W15++]
0A126:  MOV     W7,[W15++]
0A128:  MOV     W0,W4
0A12A:  MOV     W5,W0
0A12C:  MOV     W1,W5
0A12E:  MOV     W6,W1
0A130:  MOV     W2,W6
0A132:  MOV     W7,W2
0A134:  MOV     W3,W7
0A136:  MOV     W8,W3
0A138:  CALL    BFA
0A13C:  MOV     [--W15],W7
0A13E:  MOV     [--W15],W6
0A140:  MOV     [--W15],W5
0A142:  CALL    78C8
0A146:  CLR     W1
0A148:  BTSC    W0.F
0A14A:  SETM    W1
0A14C:  MOV     W0,1B5C
0A14E:  MOV     W1,1B5E
.................... 	} 
0A150:  GOTO    A3EC
.................... 	else if(( (Orient>PI) && ((3*PI)/2 >= Orient)) || (Orient <= (-PI/2) && Orient > -PI))//180 et 270deg 
0A154:  MOV     #2D18,W0
0A156:  MOV     #5444,W1
0A158:  MOV     #21FB,W2
0A15A:  MOV     #4009,W3
0A15C:  MOV     159A,W4
0A15E:  MOV     159C,W5
0A160:  MOV     159E,W6
0A162:  MOV     15A0,W7
0A164:  CALL    70F8
0A168:  BRA     NC,A182
0A16A:  MOV     159A,W0
0A16C:  MOV     159C,W1
0A16E:  MOV     159E,W2
0A170:  MOV     15A0,W3
0A172:  MOV     #21D2,W4
0A174:  MOV     #7F33,W5
0A176:  MOV     #D97C,W6
0A178:  MOV     #4012,W7
0A17A:  CALL    70F8
0A17E:  BRA     C,A1B0
0A180:  BRA     Z,A1B0
0A182:  MOV     159A,W0
0A184:  MOV     159C,W1
0A186:  MOV     159E,W2
0A188:  MOV     15A0,W3
0A18A:  MOV     #2D18,W4
0A18C:  MOV     #5444,W5
0A18E:  MOV     #21FB,W6
0A190:  MOV     #BFF9,W7
0A192:  CALL    70F8
0A196:  BRA     C,A19A
0A198:  BRA     NZ,A2A4
0A19A:  MOV     #2D18,W0
0A19C:  MOV     #5444,W1
0A19E:  MOV     #21FB,W2
0A1A0:  MOV     #C009,W3
0A1A2:  MOV     159A,W4
0A1A4:  MOV     159C,W5
0A1A6:  MOV     159E,W6
0A1A8:  MOV     15A0,W7
0A1AA:  CALL    70F8
0A1AE:  BRA     NC,A2A4
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm; 
0A1B0:  MOV     #0,W4
0A1B2:  MOV     1B54,W3
0A1B4:  SUB     W4,W3,W0
0A1B6:  MOV     W0,1B54
0A1B8:  MOV     #0,W4
0A1BA:  MOV     1B56,W3
0A1BC:  SUBB    W4,W3,W0
0A1BE:  MOV     W0,1B56
.................... 		dx = (signed int16)(sin(3*(PI/2)-Orient) * Dist_Do_mm); 
0A1C0:  BSET.B  43.0
0A1C2:  MOV     #21D2,W0
0A1C4:  MOV     #7F33,W1
0A1C6:  MOV     #D97C,W2
0A1C8:  MOV     #4012,W3
0A1CA:  MOV     159A,W4
0A1CC:  MOV     159C,W5
0A1CE:  MOV     159E,W6
0A1D0:  MOV     15A0,W7
0A1D2:  CALL    6F0A
0A1D6:  MOV     W0,W5
0A1D8:  MOV     W1,W6
0A1DA:  MOV     W2,W7
0A1DC:  MOV     W3,W8
0A1DE:  MOV     W5,1B7C
0A1E0:  MOV     W6,1B7E
0A1E2:  MOV     W7,1B80
0A1E4:  MOV     W8,1B82
0A1E6:  CALL    8E5C
0A1EA:  MOV     W0,W5
0A1EC:  MOV     W1,W6
0A1EE:  MOV     W2,W7
0A1F0:  MOV     W3,W8
0A1F2:  MOV     1B54,W0
0A1F4:  MOV     1B56,W1
0A1F6:  CLR     W3
0A1F8:  BTSC    W1.F
0A1FA:  SETM    W3
0A1FC:  MOV     W3,W2
0A1FE:  CALL    1D68
0A202:  MOV     W5,[W15++]
0A204:  MOV     W6,[W15++]
0A206:  MOV     W7,[W15++]
0A208:  MOV     W0,W4
0A20A:  MOV     W5,W0
0A20C:  MOV     W1,W5
0A20E:  MOV     W6,W1
0A210:  MOV     W2,W6
0A212:  MOV     W7,W2
0A214:  MOV     W3,W7
0A216:  MOV     W8,W3
0A218:  CALL    BFA
0A21C:  MOV     [--W15],W7
0A21E:  MOV     [--W15],W6
0A220:  MOV     [--W15],W5
0A222:  CALL    78C8
0A226:  CLR     W1
0A228:  BTSC    W0.F
0A22A:  SETM    W1
0A22C:  MOV     W0,1B58
0A22E:  MOV     W1,1B5A
.................... 		dy = (signed int16)(cos(3*(PI/2)-Orient) * Dist_Do_mm); 
0A230:  BSET.B  43.0
0A232:  MOV     #21D2,W0
0A234:  MOV     #7F33,W1
0A236:  MOV     #D97C,W2
0A238:  MOV     #4012,W3
0A23A:  MOV     159A,W4
0A23C:  MOV     159C,W5
0A23E:  MOV     159E,W6
0A240:  MOV     15A0,W7
0A242:  CALL    6F0A
0A246:  MOV     W0,W5
0A248:  MOV     W1,W6
0A24A:  MOV     W2,W7
0A24C:  MOV     W3,W8
0A24E:  MOV     W5,1B96
0A250:  MOV     W6,1B98
0A252:  MOV     W7,1B9A
0A254:  MOV     W8,1B9C
0A256:  CALL    8BA2
0A25A:  MOV     W0,W5
0A25C:  MOV     W1,W6
0A25E:  MOV     W2,W7
0A260:  MOV     W3,W8
0A262:  MOV     1B54,W0
0A264:  MOV     1B56,W1
0A266:  CLR     W3
0A268:  BTSC    W1.F
0A26A:  SETM    W3
0A26C:  MOV     W3,W2
0A26E:  CALL    1D68
0A272:  MOV     W5,[W15++]
0A274:  MOV     W6,[W15++]
0A276:  MOV     W7,[W15++]
0A278:  MOV     W0,W4
0A27A:  MOV     W5,W0
0A27C:  MOV     W1,W5
0A27E:  MOV     W6,W1
0A280:  MOV     W2,W6
0A282:  MOV     W7,W2
0A284:  MOV     W3,W7
0A286:  MOV     W8,W3
0A288:  CALL    BFA
0A28C:  MOV     [--W15],W7
0A28E:  MOV     [--W15],W6
0A290:  MOV     [--W15],W5
0A292:  CALL    78C8
0A296:  CLR     W1
0A298:  BTSC    W0.F
0A29A:  SETM    W1
0A29C:  MOV     W0,1B5C
0A29E:  MOV     W1,1B5E
.................... 	} 
0A2A0:  GOTO    A3EC
.................... 	else if(((Orient>(3*PI/2)) && (Orient < (2*PI))) || (Orient < 0 && Orient > (-PI/2)))//270deg et 360deg 
0A2A4:  MOV     #21D2,W0
0A2A6:  MOV     #7F33,W1
0A2A8:  MOV     #D97C,W2
0A2AA:  MOV     #4012,W3
0A2AC:  MOV     159A,W4
0A2AE:  MOV     159C,W5
0A2B0:  MOV     159E,W6
0A2B2:  MOV     15A0,W7
0A2B4:  CALL    70F8
0A2B8:  BRA     NC,A2D0
0A2BA:  MOV     159A,W0
0A2BC:  MOV     159C,W1
0A2BE:  MOV     159E,W2
0A2C0:  MOV     15A0,W3
0A2C2:  MOV     #2D18,W4
0A2C4:  MOV     #5444,W5
0A2C6:  MOV     #21FB,W6
0A2C8:  MOV     #4019,W7
0A2CA:  CALL    70F8
0A2CE:  BRA     C,A2FC
0A2D0:  MOV     159A,W0
0A2D2:  MOV     159C,W1
0A2D4:  MOV     159E,W2
0A2D6:  MOV     15A0,W3
0A2D8:  MOV     #0,W4
0A2DA:  MOV     #0,W5
0A2DC:  MOV     #0,W6
0A2DE:  MOV     #0,W7
0A2E0:  CALL    70F8
0A2E4:  BRA     NC,A3EC
0A2E6:  MOV     #2D18,W0
0A2E8:  MOV     #5444,W1
0A2EA:  MOV     #21FB,W2
0A2EC:  MOV     #BFF9,W3
0A2EE:  MOV     159A,W4
0A2F0:  MOV     159C,W5
0A2F2:  MOV     159E,W6
0A2F4:  MOV     15A0,W7
0A2F6:  CALL    70F8
0A2FA:  BRA     NC,A3EC
.................... 	{ 
.................... 		Dist_Do_mm = 0-Dist_Do_mm;  
0A2FC:  MOV     #0,W4
0A2FE:  MOV     1B54,W3
0A300:  SUB     W4,W3,W0
0A302:  MOV     W0,1B54
0A304:  MOV     #0,W4
0A306:  MOV     1B56,W3
0A308:  SUBB    W4,W3,W0
0A30A:  MOV     W0,1B56
.................... 		dx = (signed int16)(sin(-(PI/2)-Orient) * Dist_Do_mm); 
0A30C:  BSET.B  43.0
0A30E:  MOV     #2D18,W0
0A310:  MOV     #5444,W1
0A312:  MOV     #21FB,W2
0A314:  MOV     #BFF9,W3
0A316:  MOV     159A,W4
0A318:  MOV     159C,W5
0A31A:  MOV     159E,W6
0A31C:  MOV     15A0,W7
0A31E:  CALL    6F0A
0A322:  MOV     W0,W5
0A324:  MOV     W1,W6
0A326:  MOV     W2,W7
0A328:  MOV     W3,W8
0A32A:  MOV     W5,1B7C
0A32C:  MOV     W6,1B7E
0A32E:  MOV     W7,1B80
0A330:  MOV     W8,1B82
0A332:  CALL    8E5C
0A336:  MOV     W0,W5
0A338:  MOV     W1,W6
0A33A:  MOV     W2,W7
0A33C:  MOV     W3,W8
0A33E:  MOV     1B54,W0
0A340:  MOV     1B56,W1
0A342:  CLR     W3
0A344:  BTSC    W1.F
0A346:  SETM    W3
0A348:  MOV     W3,W2
0A34A:  CALL    1D68
0A34E:  MOV     W5,[W15++]
0A350:  MOV     W6,[W15++]
0A352:  MOV     W7,[W15++]
0A354:  MOV     W0,W4
0A356:  MOV     W5,W0
0A358:  MOV     W1,W5
0A35A:  MOV     W6,W1
0A35C:  MOV     W2,W6
0A35E:  MOV     W7,W2
0A360:  MOV     W3,W7
0A362:  MOV     W8,W3
0A364:  CALL    BFA
0A368:  MOV     [--W15],W7
0A36A:  MOV     [--W15],W6
0A36C:  MOV     [--W15],W5
0A36E:  CALL    78C8
0A372:  CLR     W1
0A374:  BTSC    W0.F
0A376:  SETM    W1
0A378:  MOV     W0,1B58
0A37A:  MOV     W1,1B5A
.................... 		dy = (signed int16)(cos(-(PI/2)-Orient) * Dist_Do_mm); 
0A37C:  BSET.B  43.0
0A37E:  MOV     #2D18,W0
0A380:  MOV     #5444,W1
0A382:  MOV     #21FB,W2
0A384:  MOV     #BFF9,W3
0A386:  MOV     159A,W4
0A388:  MOV     159C,W5
0A38A:  MOV     159E,W6
0A38C:  MOV     15A0,W7
0A38E:  CALL    6F0A
0A392:  MOV     W0,W5
0A394:  MOV     W1,W6
0A396:  MOV     W2,W7
0A398:  MOV     W3,W8
0A39A:  MOV     W5,1B96
0A39C:  MOV     W6,1B98
0A39E:  MOV     W7,1B9A
0A3A0:  MOV     W8,1B9C
0A3A2:  CALL    8BA2
0A3A6:  MOV     W0,W5
0A3A8:  MOV     W1,W6
0A3AA:  MOV     W2,W7
0A3AC:  MOV     W3,W8
0A3AE:  MOV     1B54,W0
0A3B0:  MOV     1B56,W1
0A3B2:  CLR     W3
0A3B4:  BTSC    W1.F
0A3B6:  SETM    W3
0A3B8:  MOV     W3,W2
0A3BA:  CALL    1D68
0A3BE:  MOV     W5,[W15++]
0A3C0:  MOV     W6,[W15++]
0A3C2:  MOV     W7,[W15++]
0A3C4:  MOV     W0,W4
0A3C6:  MOV     W5,W0
0A3C8:  MOV     W1,W5
0A3CA:  MOV     W6,W1
0A3CC:  MOV     W2,W6
0A3CE:  MOV     W7,W2
0A3D0:  MOV     W3,W7
0A3D2:  MOV     W8,W3
0A3D4:  CALL    BFA
0A3D8:  MOV     [--W15],W7
0A3DA:  MOV     [--W15],W6
0A3DC:  MOV     [--W15],W5
0A3DE:  CALL    78C8
0A3E2:  CLR     W1
0A3E4:  BTSC    W0.F
0A3E6:  SETM    W1
0A3E8:  MOV     W0,1B5C
0A3EA:  MOV     W1,1B5E
.................... 	} 
.................... 	Pos_x = (signed int16)(Pos_x - dx); //mise a jour pos x 
0A3EC:  MOV     158C,W0
0A3EE:  CLR     W1
0A3F0:  BTSC    W0.F
0A3F2:  SETM    W1
0A3F4:  MOV     1B58,W4
0A3F6:  SUB     W0,W4,W0
0A3F8:  MOV     1B5A,W4
0A3FA:  SUBB    W1,W4,W1
0A3FC:  MOV     W0,158C
.................... 	Pos_y = (signed int16)(Pos_y - dy);	//mise a jour pos y 
0A3FE:  MOV     158E,W0
0A400:  CLR     W1
0A402:  BTSC    W0.F
0A404:  SETM    W1
0A406:  MOV     1B5C,W4
0A408:  SUB     W0,W4,W0
0A40A:  MOV     1B5E,W4
0A40C:  SUBB    W1,W4,W1
0A40E:  MOV     W0,158E
0A410:  MOV     [--W15],W8
0A412:  MOV     [--W15],W7
0A414:  MOV     [--W15],W6
0A416:  MOV     [--W15],W5
0A418:  RETURN  
.................... } 
.................... /* 
.................... 	Borgeat Rémy 
....................  
.................... 	20.2.2017 
....................  
.................... 	Initialise la postion de départ du robot. 
.................... 	Gere le cote duquel se trouve le robot 
.................... */ 
.................... void __Init_pos(void) 
*
01DCC:  MOV     W5,[W15++]
01DCE:  MOV     W6,[W15++]
01DD0:  MOV     W7,[W15++]
01DD2:  MOV     W8,[W15++]
.................... { 
.................... 	Pos_x = read_eeprom(800); 
01DD4:  MOV     #320,W3
01DD6:  MOV     #0,W4
01DD8:  MOV     #2,W5
01DDA:  CALL    1A5C
01DDE:  MOV     W0,158C
.................... 	Pos_y = read_eeprom(802); 
01DE0:  MOV     #322,W3
01DE2:  MOV     #0,W4
01DE4:  MOV     #2,W5
01DE6:  CALL    1A5C
01DEA:  MOV     W0,158E
.................... 	Orient_deg = read_eeprom(804); 
01DEC:  MOV     #324,W3
01DEE:  MOV     #0,W4
01DF0:  MOV     #2,W5
01DF2:  CALL    1A5C
01DF6:  MOV     W0,1590
....................  
.................... 	//si on est de l'autre cote du terrain 
.................... 	if(TEAM) 
01DF8:  BTSS.B  85B.3
01DFA:  BRA     1E20
.................... 	{ 
.................... 		Pos_x = TableWidth-Pos_x; 
01DFC:  MOV     87E,W4
01DFE:  MOV     158C,W3
01E00:  SUB     W4,W3,W0
01E02:  MOV     W0,158C
.................... 		if(Orient_deg<=180)Orient_deg=180-Orient_deg ; 
01E04:  MOV     1590,W4
01E06:  MOV     #B4,W3
01E08:  CP      W3,W4
01E0A:  BRA     LT,1E18
01E0C:  MOV     #B4,W4
01E0E:  MOV     1590,W3
01E10:  SUB     W4,W3,W0
01E12:  MOV     W0,1590
01E14:  GOTO    1E20
.................... 		else Orient_deg = 540 - Orient_deg ; 
01E18:  MOV     #21C,W4
01E1A:  MOV     1590,W3
01E1C:  SUB     W4,W3,W0
01E1E:  MOV     W0,1590
.................... 	}		 
.................... 	Orient = (float64)(Orient_deg*PI/180); 
01E20:  MOV     1590,W0
01E22:  CLR     W3
01E24:  BTSC    W0.F
01E26:  SETM    W3
01E28:  MOV     W3,W1
01E2A:  MOV     W3,W2
01E2C:  CALL    1D68
01E30:  MOV     #2D18,W4
01E32:  MOV     #5444,W5
01E34:  MOV     #21FB,W6
01E36:  MOV     #4009,W7
01E38:  CALL    BFA
01E3C:  MOV     W0,W5
01E3E:  MOV     W1,W6
01E40:  MOV     W2,W7
01E42:  MOV     W3,W8
01E44:  MOV     W5,[W15++]
01E46:  MOV     W6,[W15++]
01E48:  MOV     W7,[W15++]
01E4A:  MOV     W5,W0
01E4C:  MOV     W6,W1
01E4E:  MOV     W7,W2
01E50:  MOV     W8,W3
01E52:  MOV     #0,W4
01E54:  MOV     #0,W5
01E56:  MOV     #8000,W6
01E58:  MOV     #4066,W7
01E5A:  CALL    D0A
01E5E:  MOV     [--W15],W7
01E60:  MOV     [--W15],W6
01E62:  MOV     [--W15],W5
01E64:  MOV     W0,159A
01E66:  MOV     W1,159C
01E68:  MOV     W2,159E
01E6A:  MOV     W3,15A0
01E6C:  MOV     [--W15],W8
01E6E:  MOV     [--W15],W7
01E70:  MOV     [--W15],W6
01E72:  MOV     [--W15],W5
01E74:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __Action_Writting(unsigned int8 _Command) 
.................... * \brief Demande d'Ã©criture, entre 0x00 et 0x79. 
.................... * 
.................... * \author Barman Corentin / rev. Amand Axel 
.................... * \version 2.0 
.................... * \date 19.11.2015 
.................... * 
.................... * \param[in] _Command Choisit la commande Ã  effectuer 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __DeplToDo(unsigned int8 _Command) 
.................... { 
.................... 	switch(_Command) 
*
0922C:  MOV.B   1B54,W0L
0922E:  CLR.B   1
09230:  XOR     #0,W0
09232:  BRA     Z,9242
09234:  XOR     #1,W0
09236:  BRA     Z,924E
09238:  XOR     #3,W0
0923A:  BRA     Z,925E
0923C:  XOR     #1,W0
0923E:  BRA     Z,926E
09240:  BRA     9276
.................... 	{ 
.................... 		// !!! En ajoutant des types de dÃ©placement, 
.................... 		//		pensez Ã  les gÃ©rer dans __LoadObj() tout en bas du fichier. 
.................... 		//		Comme le X est par exemple utiliser pour donner un angle, 
.................... 		//		si comme un dÃ©pl. PÃ P vous faÃ®tes TailleTable - X .... 
.................... 		//		Autant dire que le robot va faire n'importe quoi ^^ 
.................... 		case 0 : 
.................... 			__Turn((signed int16) oXp);			 
09242:  PUSH    1498
09244:  POP     1B56
09246:  CALL    7466
.................... 			break; 
0924A:  GOTO    9282
.................... 		case 1 : 
.................... 			__PaP(oXp, oYp); 
0924E:  PUSH    1498
09250:  POP     1B5A
09252:  PUSH    149A
09254:  POP     1B5C
09256:  CALL    807A
.................... 			break; 
0925A:  GOTO    9282
.................... 		case 2 : 
.................... 			__Progress(oXp, oYp); //se déplace d'une certaine distance, jusqu'a ce qu'on tape dans un bord, ou que l'ordre soit fini 
0925E:  PUSH    1498
09260:  POP     1B56
09262:  PUSH    149A
09264:  POP     1B58
09266:  CALL    8E98
.................... 			break; 
0926A:  GOTO    9282
.................... 		case 3 : 
.................... 			__Nothing(); 
0926E:  CALL    9224
.................... 			break; 
09272:  GOTO    9282
.................... 		default: 
.................... 			__Affichage_erreur(4); 
09276:  MOV.B   #4,W0L
09278:  MOV.B   W0L,1B5C
0927A:  CALL    102A
.................... 			break; 
0927E:  GOTO    9282
.................... 	} 
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
09282:  RETURN  
.................... 	 
.................... 	 
.................... } 
....................  
....................  
.................... void __Stop() 
.................... { 
.................... 		 
.................... 	/////////////////// effacer l'ordre en cours  ///////////////////  
....................    	fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
*
06D08:  MOV     #0,W1
06D0A:  MOV     W1,W0
06D0C:  CLR.B   1
06D0E:  CALL    136
06D12:  INC     W1,W1
06D14:  BTSC.B  219.1
06D16:  BRA     6D14
06D18:  MOV     W0,21A
06D1A:  MOV     #13,W0
06D1C:  CPSGT   W1,W0
06D1E:  BRA     6D0A
....................    	delay_ms(10); 
06D20:  MOV     #A,W0
06D22:  CALL    EBE
....................    	fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
06D26:  MOV     #0,W1
06D28:  MOV     W1,W0
06D2A:  CLR.B   1
06D2C:  CALL    158
06D30:  INC     W1,W1
06D32:  BTSC.B  219.1
06D34:  BRA     6D32
06D36:  MOV     W0,21A
06D38:  MOV     #13,W0
06D3A:  CPSGT   W1,W0
06D3C:  BRA     6D28
....................    	 
....................    	Etat_rob = Wait_end; 
06D3E:  MOV.B   #8,W0L
06D40:  MOV.B   W0L,87B
06D42:  RETURN  
.................... }   	 
.................... /** 
.................... * \fn void __Turn(signed int16 _Ang) 
.................... * \brief Tourne sur place jusqu'a l'angle donne. 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] Angle d'arrive  
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Turn(signed int16 _Ang) 
*
07466:  MOV     W5,[W15++]
07468:  MOV     W6,[W15++]
0746A:  MOV     W7,[W15++]
0746C:  MOV     W8,[W15++]
0746E:  CLR     1B58
07470:  CLR     1B5A
07472:  CLR     1B5C
07474:  CLR     1B5E
07476:  CLR     1B60
07478:  CLR     1B62
0747A:  CLR     1B64
0747C:  CLR     1B66
0747E:  CLR     1B68
07480:  CLR     1B6A
07482:  CLR     1B6C
07484:  CLR     1B6E
07486:  CLR     1B70
07488:  CLR     1B72
.................... { 
.................... 	float64 AngToDo = 0;			 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer en nombre d'impulses 
.................... 	signed int32 impulse_g = 0; 	//impulse mot g 
.................... 	signed int32 impulse_d = 0;		//impulse mot d 
.................... 	float64 temporaire = 0; 
....................  
.................... 	// Convertit la valeur de l'angle en radian 
.................... 	AngToDo = (_Ang * CONV_DEG_RAD) - Orient ; 
0748A:  MOV     1B56,W0
0748C:  CLR     W3
0748E:  BTSC    W0.F
07490:  SETM    W3
07492:  MOV     W3,W1
07494:  MOV     W3,W2
07496:  CALL    1D68
0749A:  MOV     15C2,W4
0749C:  MOV     15C4,W5
0749E:  MOV     15C6,W6
074A0:  MOV     15C8,W7
074A2:  CALL    BFA
074A6:  MOV     W0,W5
074A8:  MOV     W1,W6
074AA:  MOV     W2,W7
074AC:  MOV     W3,W8
074AE:  BSET.B  43.0
074B0:  MOV     W5,[W15++]
074B2:  MOV     W6,[W15++]
074B4:  MOV     W7,[W15++]
074B6:  MOV     W5,W0
074B8:  MOV     W6,W1
074BA:  MOV     W7,W2
074BC:  MOV     W8,W3
074BE:  MOV     159A,W4
074C0:  MOV     159C,W5
074C2:  MOV     159E,W6
074C4:  MOV     15A0,W7
074C6:  CALL    6F0A
074CA:  MOV     [--W15],W7
074CC:  MOV     [--W15],W6
074CE:  MOV     [--W15],W5
074D0:  MOV     W0,1B58
074D2:  MOV     W1,1B5A
074D4:  MOV     W2,1B5C
074D6:  MOV     W3,1B5E
....................  
.................... 	if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
074D8:  MOV     14A0,W4
074DA:  CP      W4,#2
074DC:  BRA     NZ,7516
074DE:  MOV     #0,W0
074E0:  MOV     #0,W1
074E2:  MOV     #0,W2
074E4:  MOV     #0,W3
074E6:  MOV     1B58,W4
074E8:  MOV     1B5A,W5
074EA:  MOV     1B5C,W6
074EC:  MOV     1B5E,W7
074EE:  CALL    70F8
074F2:  BRA     NC,7516
.................... 	{ 
.................... 		AngToDo += -2 * PI; //on tourne sur la gauche 
074F4:  BCLR.B  43.0
074F6:  MOV     1B58,W0
074F8:  MOV     1B5A,W1
074FA:  MOV     1B5C,W2
074FC:  MOV     1B5E,W3
074FE:  MOV     #2D18,W4
07500:  MOV     #5444,W5
07502:  MOV     #21FB,W6
07504:  MOV     #C019,W7
07506:  CALL    6F0A
0750A:  MOV     W0,1B58
0750C:  MOV     W1,1B5A
0750E:  MOV     W2,1B5C
07510:  MOV     W3,1B5E
.................... 	}	 
07512:  GOTO    7550
.................... 	else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
07516:  MOV     14A0,W4
07518:  CP      W4,#1
0751A:  BRA     NZ,7550
0751C:  MOV     1B58,W0
0751E:  MOV     1B5A,W1
07520:  MOV     1B5C,W2
07522:  MOV     1B5E,W3
07524:  MOV     #0,W4
07526:  MOV     #0,W5
07528:  MOV     #0,W6
0752A:  MOV     #0,W7
0752C:  CALL    70F8
07530:  BRA     NC,7550
.................... 	{ 
.................... 		AngToDo += 2 * PI;//On tourne sur la droite	 
07532:  BCLR.B  43.0
07534:  MOV     1B58,W0
07536:  MOV     1B5A,W1
07538:  MOV     1B5C,W2
0753A:  MOV     1B5E,W3
0753C:  MOV     #2D18,W4
0753E:  MOV     #5444,W5
07540:  MOV     #21FB,W6
07542:  MOV     #4019,W7
07544:  CALL    6F0A
07548:  MOV     W0,1B58
0754A:  MOV     W1,1B5A
0754C:  MOV     W2,1B5C
0754E:  MOV     W3,1B5E
.................... 	} 
.................... 	 
.................... 	if(AngToDo > PI && oCoteTourn==0) // on a plus de 180Â° 
07550:  MOV     #2D18,W0
07552:  MOV     #5444,W1
07554:  MOV     #21FB,W2
07556:  MOV     #4009,W3
07558:  MOV     1B58,W4
0755A:  MOV     1B5A,W5
0755C:  MOV     1B5C,W6
0755E:  MOV     1B5E,W7
07560:  CALL    70F8
07564:  BRA     NC,758C
07566:  CP0     14A0
07568:  BRA     NZ,758C
.................... 	{ 
.................... 		AngToDo -= 2*PI; // on tourne ds l'autre sens 
0756A:  BSET.B  43.0
0756C:  MOV     1B58,W0
0756E:  MOV     1B5A,W1
07570:  MOV     1B5C,W2
07572:  MOV     1B5E,W3
07574:  MOV     #2D18,W4
07576:  MOV     #5444,W5
07578:  MOV     #21FB,W6
0757A:  MOV     #4019,W7
0757C:  CALL    6F0A
07580:  MOV     W0,1B58
07582:  MOV     W1,1B5A
07584:  MOV     W2,1B5C
07586:  MOV     W3,1B5E
.................... 	} 
07588:  GOTO    75C4
.................... 	else if(AngToDo < -PI  && oCoteTourn==0) // si on moins que -180Â°   
0758C:  MOV     1B58,W0
0758E:  MOV     1B5A,W1
07590:  MOV     1B5C,W2
07592:  MOV     1B5E,W3
07594:  MOV     #2D18,W4
07596:  MOV     #5444,W5
07598:  MOV     #21FB,W6
0759A:  MOV     #C009,W7
0759C:  CALL    70F8
075A0:  BRA     NC,75C4
075A2:  CP0     14A0
075A4:  BRA     NZ,75C4
.................... 	{ 
.................... 		AngToDo += 2 * PI; // on tourne ds l'autre sens 
075A6:  BCLR.B  43.0
075A8:  MOV     1B58,W0
075AA:  MOV     1B5A,W1
075AC:  MOV     1B5C,W2
075AE:  MOV     1B5E,W3
075B0:  MOV     #2D18,W4
075B2:  MOV     #5444,W5
075B4:  MOV     #21FB,W6
075B6:  MOV     #4019,W7
075B8:  CALL    6F0A
075BC:  MOV     W0,1B58
075BE:  MOV     W1,1B5A
075C0:  MOV     W2,1B5C
075C2:  MOV     W3,1B5E
.................... 	}	 
....................  
.................... 	if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
075C4:  MOV     #432D,W0
075C6:  MOV     #EB1C,W1
075C8:  MOV     #36E2,W2
075CA:  MOV     #BF1A,W3
075CC:  MOV     1B58,W4
075CE:  MOV     1B5A,W5
075D0:  MOV     1B5C,W6
075D2:  MOV     1B5E,W7
075D4:  CALL    70F8
075D8:  BRA     NC,75F8
075DA:  MOV     1B58,W0
075DC:  MOV     1B5A,W1
075DE:  MOV     1B5C,W2
075E0:  MOV     1B5E,W3
075E2:  MOV     #432D,W4
075E4:  MOV     #EB1C,W5
075E6:  MOV     #36E2,W6
075E8:  MOV     #3F1A,W7
075EA:  CALL    70F8
075EE:  BRA     NC,75F8
075F0:  CLR     1B58
075F2:  CLR     1B5A
075F4:  CLR     1B5C
075F6:  CLR     1B5E
.................... 	temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
075F8:  MOV     15B2,W0
075FA:  MOV     15B4,W1
075FC:  MOV     15B6,W2
075FE:  MOV     15B8,W3
07600:  MOV     15A2,W4
07602:  MOV     15A4,W5
07604:  MOV     15A6,W6
07606:  MOV     15A8,W7
07608:  CALL    D0A
0760C:  MOV     W0,W4
0760E:  MOV     W1,W5
07610:  MOV     W2,W6
07612:  MOV     W3,W7
07614:  MOV     1B58,W0
07616:  MOV     1B5A,W1
07618:  MOV     1B5C,W2
0761A:  MOV     1B5E,W3
0761C:  CALL    BFA
07620:  MOV     W0,W5
07622:  MOV     W1,W6
07624:  MOV     W2,W7
07626:  MOV     W3,W8
07628:  MOV     W5,[W15++]
0762A:  MOV     W6,[W15++]
0762C:  MOV     W7,[W15++]
0762E:  MOV     W5,W0
07630:  MOV     W6,W1
07632:  MOV     W7,W2
07634:  MOV     W8,W3
07636:  MOV     15AA,W4
07638:  MOV     15AC,W5
0763A:  MOV     15AE,W6
0763C:  MOV     15B0,W7
0763E:  CALL    BFA
07642:  MOV     [--W15],W7
07644:  MOV     [--W15],W6
07646:  MOV     [--W15],W5
07648:  MOV     W0,W5
0764A:  MOV     W1,W6
0764C:  MOV     W2,W7
0764E:  MOV     W3,W8
07650:  MOV     W5,[W15++]
07652:  MOV     W6,[W15++]
07654:  MOV     W7,[W15++]
07656:  MOV     W5,W0
07658:  MOV     W6,W1
0765A:  MOV     W7,W2
0765C:  MOV     W8,W3
0765E:  MOV     #0,W4
07660:  MOV     #0,W5
07662:  MOV     #0,W6
07664:  MOV     #4000,W7
07666:  CALL    BFA
0766A:  MOV     [--W15],W7
0766C:  MOV     [--W15],W6
0766E:  MOV     [--W15],W5
07670:  MOV     W0,W5
07672:  MOV     W1,W6
07674:  MOV     W2,W7
07676:  MOV     W3,W8
07678:  MOV     W5,[W15++]
0767A:  MOV     W6,[W15++]
0767C:  MOV     W7,[W15++]
0767E:  MOV     W5,W0
07680:  MOV     W6,W1
07682:  MOV     W7,W2
07684:  MOV     W8,W3
07686:  MOV     #2D18,W4
07688:  MOV     #5444,W5
0768A:  MOV     #21FB,W6
0768C:  MOV     #4009,W7
0768E:  CALL    D0A
07692:  MOV     [--W15],W7
07694:  MOV     [--W15],W6
07696:  MOV     [--W15],W5
07698:  MOV     W0,1B6C
0769A:  MOV     W1,1B6E
0769C:  MOV     W2,1B70
0769E:  MOV     W3,1B72
.................... 	AngToDo_int = (signed int32)(arrondi_float_signed(temporaire));	 
076A0:  MOV     1B6C,W0
076A2:  MOV     1B6E,W1
076A4:  MOV     1B70,W2
076A6:  MOV     1B72,W3
076A8:  CALL    717C
076AC:  MOV     W1,W5
076AE:  MOV     W2,W6
076B0:  MOV     W5,1BB6
076B2:  MOV     W6,1BB8
076B4:  CALL    7200
076B8:  MOV     W0,1B60
076BA:  MOV     W1,1B62
.................... 	// on envoie les donnee au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
076BC:  MOV     #0,W1
076BE:  MOV     W1,W0
076C0:  CLR.B   1
076C2:  CALL    17A
076C6:  INC     W1,W1
076C8:  BTSC.B  219.1
076CA:  BRA     76C8
076CC:  MOV     W0,21A
076CE:  MOV     #4,W0
076D0:  CPSGT   W1,W0
076D2:  BRA     76BE
076D4:  MOV     14A2,W0
076D6:  MOV     #8004,W4
076D8:  CALL    725C
076DC:  MOV     #9,W1
076DE:  MOV     W1,W0
076E0:  CLR.B   1
076E2:  CALL    17A
076E6:  INC     W1,W1
076E8:  BTSC.B  219.1
076EA:  BRA     76E8
076EC:  MOV     W0,21A
076EE:  MOV     #E,W0
076F0:  CPSGT   W1,W0
076F2:  BRA     76DE
076F4:  MOV     14A2,W0
076F6:  MOV     #8004,W4
076F8:  CALL    725C
076FC:  BTSC.B  219.1
076FE:  BRA     76FC
07700:  MOV     #20,W4
07702:  MOV     W4,21A
07704:  BTSC.B  219.1
07706:  BRA     7704
07708:  MOV     #D,W4
0770A:  MOV     W4,21A
.................... 	 
.................... 	//balise  
.................... 	balise_on = 0; 
0770C:  BCLR.B  85B.1
.................... 	 
.................... 	impulse_g = AngToDo_int; 
0770E:  PUSH    1B60
07710:  POP     1B64
07712:  PUSH    1B62
07714:  POP     1B66
.................... 	impulse_d = 0-AngToDo_int; 
07716:  MOV     #0,W4
07718:  MOV     1B60,W3
0771A:  SUB     W4,W3,W0
0771C:  MOV     W0,1B68
0771E:  MOV     #0,W4
07720:  MOV     1B62,W3
07722:  SUBB    W4,W3,W0
07724:  MOV     W0,1B6A
.................... 	fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
07726:  MOV     #0,W1
07728:  MOV     W1,W0
0772A:  CLR.B   1
0772C:  CALL    19C
07730:  INC     W1,W1
07732:  BTSC.B  219.1
07734:  BRA     7732
07736:  MOV     W0,21A
07738:  MOV     #5,W0
0773A:  CPSGT   W1,W0
0773C:  BRA     7728
0773E:  MOV     1B64,W0
07740:  MOV     1B66,W1
07742:  MOV     #0,W4
07744:  CALL    7352
07748:  MOV     #8,W1
0774A:  MOV     W1,W0
0774C:  CLR.B   1
0774E:  CALL    19C
07752:  INC     W1,W1
07754:  BTSC.B  219.1
07756:  BRA     7754
07758:  MOV     W0,21A
0775A:  MOV     #E,W0
0775C:  CPSGT   W1,W0
0775E:  BRA     774A
07760:  MOV     1B68,W0
07762:  MOV     1B6A,W1
07764:  MOV     #0,W4
07766:  CALL    7352
0776A:  BTSC.B  219.1
0776C:  BRA     776A
0776E:  MOV     #20,W4
07770:  MOV     W4,21A
07772:  BTSC.B  219.1
07774:  BRA     7772
07776:  MOV     #D,W4
07778:  MOV     W4,21A
.................... 	 
.................... 	Depl_send = 1; 
0777A:  BSET.B  85B.5
.................... 	Orient = (float64)(_Ang * CONV_DEG_RAD); // mise à jour de l'angle 
0777C:  MOV     1B56,W0
0777E:  CLR     W3
07780:  BTSC    W0.F
07782:  SETM    W3
07784:  MOV     W3,W1
07786:  MOV     W3,W2
07788:  CALL    1D68
0778C:  MOV     15C2,W4
0778E:  MOV     15C4,W5
07790:  MOV     15C6,W6
07792:  MOV     15C8,W7
07794:  CALL    BFA
07798:  MOV     W0,159A
0779A:  MOV     W1,159C
0779C:  MOV     W2,159E
0779E:  MOV     W3,15A0
077A0:  MOV     [--W15],W8
077A2:  MOV     [--W15],W7
077A4:  MOV     [--W15],W6
077A6:  MOV     [--W15],W5
077A8:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __PaP(signed int16 _X, signed int16 _Y) 
.................... * \brief Depl Pap du robot. 
.................... *		Le deplacement se fait tel que : 
.................... *			- Rotation vers le point a  atteindre 
.................... *			- Deplacement ligne droite 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param[in] coordonee x,y de la pos d'arrivee 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __PaP(signed int16 _X, signed int16 _Y) 
*
0807A:  MOV     W5,[W15++]
0807C:  MOV     #C,W5
0807E:  REPEAT  #3
08080:  MOV     [W5++],[W15++]
08082:  CLR     1B6E
08084:  CLR     1B70
08086:  CLR     1B72
08088:  CLR     1B74
0808A:  CLR     1B76
0808C:  CLR     1B78
0808E:  CLR     1B7A
08090:  CLR     1B7C
08092:  CLR     1B7E
08094:  CLR     1B80
08096:  CLR     1B82
08098:  CLR     1B84
0809A:  CLR     1B86
0809C:  CLR     1B88
0809E:  CLR     1B8A
080A0:  CLR     1B8C
080A2:  CLR     1B8E
080A4:  CLR     1B90
080A6:  CLR     1B92
080A8:  CLR     1B94
.................... { 
....................  
.................... 	float64	dx,dy,distToDo = 0;	 
.................... 	signed int32 distToDo_int = 0;	//dist a effectuer 
.................... 	signed int32 AngToDo_int = 0;	//ang a effectuer 
.................... 	signed int32 impulse_g = 0;	 	//impulse mot gauche 
.................... 	signed int32 impulse_d = 0;		//impulse mot droite 
.................... 	static int1 etat_deplacement = 0; 
.................... 	float64 AngToDo = 0; 
.................... 	float64 temporaire = 0; 
.................... 	 
.................... 	 
.................... 	dx = (_X - Pos_x) * (COEFF_D/10); //calcul deplacment en x et transformation en pas 
080AA:  MOV     1B5A,W4
080AC:  MOV     158C,W3
080AE:  SUB     W4,W3,W5
080B0:  MOV     W5,[W15++]
080B2:  MOV     15BA,W0
080B4:  MOV     15BC,W1
080B6:  MOV     15BE,W2
080B8:  MOV     15C0,W3
080BA:  MOV     #0,W4
080BC:  MOV     #0,W5
080BE:  MOV     #0,W6
080C0:  MOV     #4024,W7
080C2:  CALL    D0A
080C6:  MOV     [--W15],W5
080C8:  MOV     W0,W6
080CA:  MOV     W1,W7
080CC:  MOV     W2,W8
080CE:  MOV     W3,W9
080D0:  MOV     W5,W0
080D2:  CLR     W3
080D4:  BTSC    W0.F
080D6:  SETM    W3
080D8:  MOV     W3,W1
080DA:  MOV     W3,W2
080DC:  CALL    1D68
080E0:  MOV     W5,[W15++]
080E2:  MOV     W6,[W15++]
080E4:  MOV     W7,[W15++]
080E6:  MOV     W6,W4
080E8:  MOV     W7,W5
080EA:  MOV     W8,W6
080EC:  MOV     W9,W7
080EE:  CALL    BFA
080F2:  MOV     [--W15],W7
080F4:  MOV     [--W15],W6
080F6:  MOV     [--W15],W5
080F8:  MOV     W0,1B5E
080FA:  MOV     W1,1B60
080FC:  MOV     W2,1B62
080FE:  MOV     W3,1B64
.................... 	dy = (_Y - Pos_Y) * (COEFF_D/10); //calcul deplacment en y et transformation en pas 
08100:  MOV     1B5C,W4
08102:  MOV     158E,W3
08104:  SUB     W4,W3,W5
08106:  MOV     W5,[W15++]
08108:  MOV     15BA,W0
0810A:  MOV     15BC,W1
0810C:  MOV     15BE,W2
0810E:  MOV     15C0,W3
08110:  MOV     #0,W4
08112:  MOV     #0,W5
08114:  MOV     #0,W6
08116:  MOV     #4024,W7
08118:  CALL    D0A
0811C:  MOV     [--W15],W5
0811E:  MOV     W0,W6
08120:  MOV     W1,W7
08122:  MOV     W2,W8
08124:  MOV     W3,W9
08126:  MOV     W5,W0
08128:  CLR     W3
0812A:  BTSC    W0.F
0812C:  SETM    W3
0812E:  MOV     W3,W1
08130:  MOV     W3,W2
08132:  CALL    1D68
08136:  MOV     W5,[W15++]
08138:  MOV     W6,[W15++]
0813A:  MOV     W7,[W15++]
0813C:  MOV     W6,W4
0813E:  MOV     W7,W5
08140:  MOV     W8,W6
08142:  MOV     W9,W7
08144:  CALL    BFA
08148:  MOV     [--W15],W7
0814A:  MOV     [--W15],W6
0814C:  MOV     [--W15],W5
0814E:  MOV     W0,1B66
08150:  MOV     W1,1B68
08152:  MOV     W2,1B6A
08154:  MOV     W3,1B6C
.................... 	distToDo = sqrt((dx*dx)+(dy*dy)); //calcul de la distance 
08156:  MOV     1B5E,W0
08158:  MOV     1B60,W1
0815A:  MOV     1B62,W2
0815C:  MOV     1B64,W3
0815E:  MOV     1B5E,W4
08160:  MOV     1B60,W5
08162:  MOV     1B62,W6
08164:  MOV     1B64,W7
08166:  CALL    BFA
0816A:  MOV     W0,W5
0816C:  MOV     W1,W6
0816E:  MOV     W2,W7
08170:  MOV     W3,W8
08172:  MOV     W5,[W15++]
08174:  MOV     W6,[W15++]
08176:  MOV     W7,[W15++]
08178:  MOV     1B66,W0
0817A:  MOV     1B68,W1
0817C:  MOV     1B6A,W2
0817E:  MOV     1B6C,W3
08180:  MOV     1B66,W4
08182:  MOV     1B68,W5
08184:  MOV     1B6A,W6
08186:  MOV     1B6C,W7
08188:  CALL    BFA
0818C:  MOV     [--W15],W7
0818E:  MOV     [--W15],W6
08190:  MOV     [--W15],W5
08192:  BCLR.B  43.0
08194:  MOV     W5,[W15++]
08196:  MOV     W6,[W15++]
08198:  MOV     W7,[W15++]
0819A:  MOV     W0,W4
0819C:  MOV     W5,W0
0819E:  MOV     W1,W5
081A0:  MOV     W6,W1
081A2:  MOV     W2,W6
081A4:  MOV     W7,W2
081A6:  MOV     W3,W7
081A8:  MOV     W8,W3
081AA:  CALL    6F0A
081AE:  MOV     [--W15],W7
081B0:  MOV     [--W15],W6
081B2:  MOV     [--W15],W5
081B4:  MOV     W0,W5
081B6:  MOV     W1,W6
081B8:  MOV     W2,W7
081BA:  MOV     W3,W8
081BC:  MOV     W5,1C1E
081BE:  MOV     W6,1C20
081C0:  MOV     W7,1C22
081C2:  MOV     W8,1C24
081C4:  CALL    77AA
081C8:  MOV     W0,1B6E
081CA:  MOV     W1,1B70
081CC:  MOV     W2,1B72
081CE:  MOV     W3,1B74
.................... 	distToDo_int = distToDo ; 
081D0:  MOV     1B6E,W0
081D2:  MOV     1B70,W1
081D4:  MOV     1B72,W2
081D6:  MOV     1B74,W3
081D8:  CALL    78C8
081DC:  MOV     W0,1B76
081DE:  MOV     W1,1B78
....................  
.................... 	switch(etat_deplacement) 
081E0:  CLR     W0
081E2:  BTSC.B  14B7.1
081E4:  INC     W0,W0
081E6:  CLR.B   1
081E8:  XOR     #0,W0
081EA:  BRA     Z,81F2
081EC:  XOR     #1,W0
081EE:  BRA     Z,8706
081F0:  BRA     8826
.................... 	{ 
.................... 		case 0: // gestion de l'angle 
.................... 		 
.................... 			/////////////////////////////////////////////// 
.................... 			//////////Calcul de l'angle//////////////////// 
.................... 			/////////////////////////////////////////////// 
.................... 				if(dx >= 0) // 1er et 4eme quadrant 
081F2:  MOV     #0,W0
081F4:  MOV     #0,W1
081F6:  MOV     #0,W2
081F8:  MOV     #0,W3
081FA:  MOV     1B5E,W4
081FC:  MOV     1B60,W5
081FE:  MOV     1B62,W6
08200:  MOV     1B64,W7
08202:  CALL    70F8
08206:  BRA     C,820A
08208:  BRA     NZ,8268
.................... 				{ 
.................... 					AngToDo = asin(dy/distToDo) - Orient;	 
0820A:  MOV     1B66,W0
0820C:  MOV     1B68,W1
0820E:  MOV     1B6A,W2
08210:  MOV     1B6C,W3
08212:  MOV     1B6E,W4
08214:  MOV     1B70,W5
08216:  MOV     1B72,W6
08218:  MOV     1B74,W7
0821A:  CALL    D0A
0821E:  MOV     W0,W5
08220:  MOV     W1,W6
08222:  MOV     W2,W7
08224:  MOV     W3,W8
08226:  MOV     W5,1BBA
08228:  MOV     W6,1BBC
0822A:  MOV     W7,1BBE
0822C:  MOV     W8,1BC0
0822E:  CALL    7D2C
08232:  MOV     W0,W5
08234:  MOV     W1,W6
08236:  MOV     W2,W7
08238:  MOV     W3,W8
0823A:  BSET.B  43.0
0823C:  MOV     W5,[W15++]
0823E:  MOV     W6,[W15++]
08240:  MOV     W7,[W15++]
08242:  MOV     W5,W0
08244:  MOV     W6,W1
08246:  MOV     W7,W2
08248:  MOV     W8,W3
0824A:  MOV     159A,W4
0824C:  MOV     159C,W5
0824E:  MOV     159E,W6
08250:  MOV     15A0,W7
08252:  CALL    6F0A
08256:  MOV     [--W15],W7
08258:  MOV     [--W15],W6
0825A:  MOV     [--W15],W5
0825C:  MOV     W0,1B86
0825E:  MOV     W1,1B88
08260:  MOV     W2,1B8A
08262:  MOV     W3,1B8C
.................... 				} 
08264:  GOTO    83C4
.................... 				 
.................... 				else if(dx <= 0 && dy > 0)//2eme quandrant 
08268:  MOV     1B5E,W0
0826A:  MOV     1B60,W1
0826C:  MOV     1B62,W2
0826E:  MOV     1B64,W3
08270:  MOV     #0,W4
08272:  MOV     #0,W5
08274:  MOV     #0,W6
08276:  MOV     #0,W7
08278:  CALL    70F8
0827C:  BRA     C,8280
0827E:  BRA     NZ,82F4
08280:  MOV     #0,W0
08282:  MOV     #0,W1
08284:  MOV     #0,W2
08286:  MOV     #0,W3
08288:  MOV     1B66,W4
0828A:  MOV     1B68,W5
0828C:  MOV     1B6A,W6
0828E:  MOV     1B6C,W7
08290:  CALL    70F8
08294:  BRA     NC,82F4
.................... 				{ 
.................... 					AngToDo = acos(dx/distToDo) - Orient; 
08296:  MOV     1B5E,W0
08298:  MOV     1B60,W1
0829A:  MOV     1B62,W2
0829C:  MOV     1B64,W3
0829E:  MOV     1B6E,W4
082A0:  MOV     1B70,W5
082A2:  MOV     1B72,W6
082A4:  MOV     1B74,W7
082A6:  CALL    D0A
082AA:  MOV     W0,W5
082AC:  MOV     W1,W6
082AE:  MOV     W2,W7
082B0:  MOV     W3,W8
082B2:  MOV     W5,1BBA
082B4:  MOV     W6,1BBC
082B6:  MOV     W7,1BBE
082B8:  MOV     W8,1BC0
082BA:  CALL    7D54
082BE:  MOV     W0,W5
082C0:  MOV     W1,W6
082C2:  MOV     W2,W7
082C4:  MOV     W3,W8
082C6:  BSET.B  43.0
082C8:  MOV     W5,[W15++]
082CA:  MOV     W6,[W15++]
082CC:  MOV     W7,[W15++]
082CE:  MOV     W5,W0
082D0:  MOV     W6,W1
082D2:  MOV     W7,W2
082D4:  MOV     W8,W3
082D6:  MOV     159A,W4
082D8:  MOV     159C,W5
082DA:  MOV     159E,W6
082DC:  MOV     15A0,W7
082DE:  CALL    6F0A
082E2:  MOV     [--W15],W7
082E4:  MOV     [--W15],W6
082E6:  MOV     [--W15],W5
082E8:  MOV     W0,1B86
082EA:  MOV     W1,1B88
082EC:  MOV     W2,1B8A
082EE:  MOV     W3,1B8C
.................... 				} 
082F0:  GOTO    83C4
.................... 				 
.................... 				else if(dx < 0 && dy <= 0)//3eme quadrant 
082F4:  MOV     1B5E,W0
082F6:  MOV     1B60,W1
082F8:  MOV     1B62,W2
082FA:  MOV     1B64,W3
082FC:  MOV     #0,W4
082FE:  MOV     #0,W5
08300:  MOV     #0,W6
08302:  MOV     #0,W7
08304:  CALL    70F8
08308:  BRA     NC,83C4
0830A:  MOV     1B66,W0
0830C:  MOV     1B68,W1
0830E:  MOV     1B6A,W2
08310:  MOV     1B6C,W3
08312:  MOV     #0,W4
08314:  MOV     #0,W5
08316:  MOV     #0,W6
08318:  MOV     #0,W7
0831A:  CALL    70F8
0831E:  BRA     C,8322
08320:  BRA     NZ,83C4
.................... 				{ 
.................... 					AngToDo = asin(abs(dy)/distToDo) + PI - Orient;	 
08322:  MOV     1B66,W0
08324:  MOV     1B68,W1
08326:  MOV     1B6A,W2
08328:  MOV     1B6C,W3
0832A:  BCLR    W3.F
0832C:  MOV     W0,W5
0832E:  MOV     W1,W6
08330:  MOV     W2,W7
08332:  MOV     W3,W8
08334:  MOV     W5,[W15++]
08336:  MOV     W6,[W15++]
08338:  MOV     W7,[W15++]
0833A:  MOV     W5,W0
0833C:  MOV     W6,W1
0833E:  MOV     W7,W2
08340:  MOV     W8,W3
08342:  MOV     1B6E,W4
08344:  MOV     1B70,W5
08346:  MOV     1B72,W6
08348:  MOV     1B74,W7
0834A:  CALL    D0A
0834E:  MOV     [--W15],W7
08350:  MOV     [--W15],W6
08352:  MOV     [--W15],W5
08354:  MOV     W0,W5
08356:  MOV     W1,W6
08358:  MOV     W2,W7
0835A:  MOV     W3,W8
0835C:  MOV     W5,1BBA
0835E:  MOV     W6,1BBC
08360:  MOV     W7,1BBE
08362:  MOV     W8,1BC0
08364:  CALL    7D2C
08368:  MOV     W0,W5
0836A:  MOV     W1,W6
0836C:  MOV     W2,W7
0836E:  MOV     W3,W8
08370:  BCLR.B  43.0
08372:  MOV     W5,[W15++]
08374:  MOV     W6,[W15++]
08376:  MOV     W7,[W15++]
08378:  MOV     W5,W0
0837A:  MOV     W6,W1
0837C:  MOV     W7,W2
0837E:  MOV     W8,W3
08380:  MOV     #2D18,W4
08382:  MOV     #5444,W5
08384:  MOV     #21FB,W6
08386:  MOV     #4009,W7
08388:  CALL    6F0A
0838C:  MOV     [--W15],W7
0838E:  MOV     [--W15],W6
08390:  MOV     [--W15],W5
08392:  MOV     W0,W5
08394:  MOV     W1,W6
08396:  MOV     W2,W7
08398:  MOV     W3,W8
0839A:  BSET.B  43.0
0839C:  MOV     W5,[W15++]
0839E:  MOV     W6,[W15++]
083A0:  MOV     W7,[W15++]
083A2:  MOV     W5,W0
083A4:  MOV     W6,W1
083A6:  MOV     W7,W2
083A8:  MOV     W8,W3
083AA:  MOV     159A,W4
083AC:  MOV     159C,W5
083AE:  MOV     159E,W6
083B0:  MOV     15A0,W7
083B2:  CALL    6F0A
083B6:  MOV     [--W15],W7
083B8:  MOV     [--W15],W6
083BA:  MOV     [--W15],W5
083BC:  MOV     W0,1B86
083BE:  MOV     W1,1B88
083C0:  MOV     W2,1B8A
083C2:  MOV     W3,1B8C
.................... 				} 
.................... 				 
.................... 			//////////////////////////////////////////////// 
.................... 			////////////Gestion de l'angle////////////////// 
.................... 			//////////////////////////////////////////////// 
.................... 				if(oAvAr) 
083C4:  CP0     149E
083C6:  BRA     Z,8452
.................... 				{ 
.................... 					AngToDo += PI;	 
083C8:  BCLR.B  43.0
083CA:  MOV     1B86,W0
083CC:  MOV     1B88,W1
083CE:  MOV     1B8A,W2
083D0:  MOV     1B8C,W3
083D2:  MOV     #2D18,W4
083D4:  MOV     #5444,W5
083D6:  MOV     #21FB,W6
083D8:  MOV     #4009,W7
083DA:  CALL    6F0A
083DE:  MOV     W0,1B86
083E0:  MOV     W1,1B88
083E2:  MOV     W2,1B8A
083E4:  MOV     W3,1B8C
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
083E6:  MOV     #2D18,W0
083E8:  MOV     #5444,W1
083EA:  MOV     #21FB,W2
083EC:  MOV     #4009,W3
083EE:  MOV     1B86,W4
083F0:  MOV     1B88,W5
083F2:  MOV     1B8A,W6
083F4:  MOV     1B8C,W7
083F6:  CALL    70F8
083FA:  BRA     NC,841E
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
083FC:  BSET.B  43.0
083FE:  MOV     1B86,W0
08400:  MOV     1B88,W1
08402:  MOV     1B8A,W2
08404:  MOV     1B8C,W3
08406:  MOV     #2D18,W4
08408:  MOV     #5444,W5
0840A:  MOV     #21FB,W6
0840C:  MOV     #4019,W7
0840E:  CALL    6F0A
08412:  MOV     W0,1B86
08414:  MOV     W1,1B88
08416:  MOV     W2,1B8A
08418:  MOV     W3,1B8C
.................... 					} 
0841A:  GOTO    8452
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
0841E:  MOV     1B86,W0
08420:  MOV     1B88,W1
08422:  MOV     1B8A,W2
08424:  MOV     1B8C,W3
08426:  MOV     #2D18,W4
08428:  MOV     #5444,W5
0842A:  MOV     #21FB,W6
0842C:  MOV     #C009,W7
0842E:  CALL    70F8
08432:  BRA     NC,8452
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
08434:  BCLR.B  43.0
08436:  MOV     1B86,W0
08438:  MOV     1B88,W1
0843A:  MOV     1B8A,W2
0843C:  MOV     1B8C,W3
0843E:  MOV     #2D18,W4
08440:  MOV     #5444,W5
08442:  MOV     #21FB,W6
08444:  MOV     #4019,W7
08446:  CALL    6F0A
0844A:  MOV     W0,1B86
0844C:  MOV     W1,1B88
0844E:  MOV     W2,1B8A
08450:  MOV     W3,1B8C
.................... 					} 
.................... 				}					 
.................... 				if(oCoteTourn==2&&AngToDo>0) // on force le robot a tourner sur la droite 
08452:  MOV     14A0,W4
08454:  CP      W4,#2
08456:  BRA     NZ,8490
08458:  MOV     #0,W0
0845A:  MOV     #0,W1
0845C:  MOV     #0,W2
0845E:  MOV     #0,W3
08460:  MOV     1B86,W4
08462:  MOV     1B88,W5
08464:  MOV     1B8A,W6
08466:  MOV     1B8C,W7
08468:  CALL    70F8
0846C:  BRA     NC,8490
.................... 				{ 
.................... 					AngToDo += -2 * PI; //on tourne sur la gauche 
0846E:  BCLR.B  43.0
08470:  MOV     1B86,W0
08472:  MOV     1B88,W1
08474:  MOV     1B8A,W2
08476:  MOV     1B8C,W3
08478:  MOV     #2D18,W4
0847A:  MOV     #5444,W5
0847C:  MOV     #21FB,W6
0847E:  MOV     #C019,W7
08480:  CALL    6F0A
08484:  MOV     W0,1B86
08486:  MOV     W1,1B88
08488:  MOV     W2,1B8A
0848A:  MOV     W3,1B8C
.................... 				}	 
0848C:  GOTO    853E
.................... 				 
.................... 				else if(oCoteTourn==1&&AngToDo<0) // on force le robot Ã  tourner sur la gauche 	 
08490:  MOV     14A0,W4
08492:  CP      W4,#1
08494:  BRA     NZ,84CE
08496:  MOV     1B86,W0
08498:  MOV     1B88,W1
0849A:  MOV     1B8A,W2
0849C:  MOV     1B8C,W3
0849E:  MOV     #0,W4
084A0:  MOV     #0,W5
084A2:  MOV     #0,W6
084A4:  MOV     #0,W7
084A6:  CALL    70F8
084AA:  BRA     NC,84CE
.................... 				{ 
.................... 					AngToDo += 2 * PI;//On tourne sur la droite	 
084AC:  BCLR.B  43.0
084AE:  MOV     1B86,W0
084B0:  MOV     1B88,W1
084B2:  MOV     1B8A,W2
084B4:  MOV     1B8C,W3
084B6:  MOV     #2D18,W4
084B8:  MOV     #5444,W5
084BA:  MOV     #21FB,W6
084BC:  MOV     #4019,W7
084BE:  CALL    6F0A
084C2:  MOV     W0,1B86
084C4:  MOV     W1,1B88
084C6:  MOV     W2,1B8A
084C8:  MOV     W3,1B8C
.................... 				}				 
084CA:  GOTO    853E
.................... 				 
.................... 				else if(oCoteTourn==0) 
084CE:  CP0     14A0
084D0:  BRA     NZ,853E
.................... 				{ 
.................... 					if(AngToDo > PI) // si on a plus de 180Â° 
084D2:  MOV     #2D18,W0
084D4:  MOV     #5444,W1
084D6:  MOV     #21FB,W2
084D8:  MOV     #4009,W3
084DA:  MOV     1B86,W4
084DC:  MOV     1B88,W5
084DE:  MOV     1B8A,W6
084E0:  MOV     1B8C,W7
084E2:  CALL    70F8
084E6:  BRA     NC,850A
.................... 					{ 
.................... 						AngToDo -= 2*PI; // on tourne ds l'autre sens 
084E8:  BSET.B  43.0
084EA:  MOV     1B86,W0
084EC:  MOV     1B88,W1
084EE:  MOV     1B8A,W2
084F0:  MOV     1B8C,W3
084F2:  MOV     #2D18,W4
084F4:  MOV     #5444,W5
084F6:  MOV     #21FB,W6
084F8:  MOV     #4019,W7
084FA:  CALL    6F0A
084FE:  MOV     W0,1B86
08500:  MOV     W1,1B88
08502:  MOV     W2,1B8A
08504:  MOV     W3,1B8C
.................... 					} 
08506:  GOTO    853E
.................... 					else if(AngToDo < -PI) // si on moins que -180Â°   
0850A:  MOV     1B86,W0
0850C:  MOV     1B88,W1
0850E:  MOV     1B8A,W2
08510:  MOV     1B8C,W3
08512:  MOV     #2D18,W4
08514:  MOV     #5444,W5
08516:  MOV     #21FB,W6
08518:  MOV     #C009,W7
0851A:  CALL    70F8
0851E:  BRA     NC,853E
.................... 					{ 
.................... 						AngToDo += 2 * PI; // on tourne ds l'autre sens 
08520:  BCLR.B  43.0
08522:  MOV     1B86,W0
08524:  MOV     1B88,W1
08526:  MOV     1B8A,W2
08528:  MOV     1B8C,W3
0852A:  MOV     #2D18,W4
0852C:  MOV     #5444,W5
0852E:  MOV     #21FB,W6
08530:  MOV     #4019,W7
08532:  CALL    6F0A
08536:  MOV     W0,1B86
08538:  MOV     W1,1B88
0853A:  MOV     W2,1B8A
0853C:  MOV     W3,1B8C
.................... 					}	 
.................... 				} 
.................... 				 
.................... 			if(AngToDo>-0.0001 && AngToDo<0.0001) AngToDo = 0;// mise a 0 de l'angle, car il se peut que des erreus de calculs viennent  
0853E:  MOV     #432D,W0
08540:  MOV     #EB1C,W1
08542:  MOV     #36E2,W2
08544:  MOV     #BF1A,W3
08546:  MOV     1B86,W4
08548:  MOV     1B88,W5
0854A:  MOV     1B8A,W6
0854C:  MOV     1B8C,W7
0854E:  CALL    70F8
08552:  BRA     NC,8572
08554:  MOV     1B86,W0
08556:  MOV     1B88,W1
08558:  MOV     1B8A,W2
0855A:  MOV     1B8C,W3
0855C:  MOV     #432D,W4
0855E:  MOV     #EB1C,W5
08560:  MOV     #36E2,W6
08562:  MOV     #3F1A,W7
08564:  CALL    70F8
08568:  BRA     NC,8572
0856A:  CLR     1B86
0856C:  CLR     1B88
0856E:  CLR     1B8A
08570:  CLR     1B8C
.................... 			temporaire = (float64)((AngToDo * (ENTRAXE_ROUESFOLLES/DIAM_ENCO) * IMPULSES_ENCO * 2 / PI )) ; // on calcul le nbre d'impulse nÃ©cessaire pour la rotation 
08572:  MOV     15B2,W0
08574:  MOV     15B4,W1
08576:  MOV     15B6,W2
08578:  MOV     15B8,W3
0857A:  MOV     15A2,W4
0857C:  MOV     15A4,W5
0857E:  MOV     15A6,W6
08580:  MOV     15A8,W7
08582:  CALL    D0A
08586:  MOV     W0,W4
08588:  MOV     W1,W5
0858A:  MOV     W2,W6
0858C:  MOV     W3,W7
0858E:  MOV     1B86,W0
08590:  MOV     1B88,W1
08592:  MOV     1B8A,W2
08594:  MOV     1B8C,W3
08596:  CALL    BFA
0859A:  MOV     W0,W5
0859C:  MOV     W1,W6
0859E:  MOV     W2,W7
085A0:  MOV     W3,W8
085A2:  MOV     W5,[W15++]
085A4:  MOV     W6,[W15++]
085A6:  MOV     W7,[W15++]
085A8:  MOV     W5,W0
085AA:  MOV     W6,W1
085AC:  MOV     W7,W2
085AE:  MOV     W8,W3
085B0:  MOV     15AA,W4
085B2:  MOV     15AC,W5
085B4:  MOV     15AE,W6
085B6:  MOV     15B0,W7
085B8:  CALL    BFA
085BC:  MOV     [--W15],W7
085BE:  MOV     [--W15],W6
085C0:  MOV     [--W15],W5
085C2:  MOV     W0,W5
085C4:  MOV     W1,W6
085C6:  MOV     W2,W7
085C8:  MOV     W3,W8
085CA:  MOV     W5,[W15++]
085CC:  MOV     W6,[W15++]
085CE:  MOV     W7,[W15++]
085D0:  MOV     W5,W0
085D2:  MOV     W6,W1
085D4:  MOV     W7,W2
085D6:  MOV     W8,W3
085D8:  MOV     #0,W4
085DA:  MOV     #0,W5
085DC:  MOV     #0,W6
085DE:  MOV     #4000,W7
085E0:  CALL    BFA
085E4:  MOV     [--W15],W7
085E6:  MOV     [--W15],W6
085E8:  MOV     [--W15],W5
085EA:  MOV     W0,W5
085EC:  MOV     W1,W6
085EE:  MOV     W2,W7
085F0:  MOV     W3,W8
085F2:  MOV     W5,[W15++]
085F4:  MOV     W6,[W15++]
085F6:  MOV     W7,[W15++]
085F8:  MOV     W5,W0
085FA:  MOV     W6,W1
085FC:  MOV     W7,W2
085FE:  MOV     W8,W3
08600:  MOV     #2D18,W4
08602:  MOV     #5444,W5
08604:  MOV     #21FB,W6
08606:  MOV     #4009,W7
08608:  CALL    D0A
0860C:  MOV     [--W15],W7
0860E:  MOV     [--W15],W6
08610:  MOV     [--W15],W5
08612:  MOV     W0,1B8E
08614:  MOV     W1,1B90
08616:  MOV     W2,1B92
08618:  MOV     W3,1B94
.................... 			AngToDo_int = (signed int32)(arrondi_float_signed(temporaire)); 
0861A:  MOV     1B8E,W0
0861C:  MOV     1B90,W1
0861E:  MOV     1B92,W2
08620:  MOV     1B94,W3
08622:  CALL    717C
08626:  MOV     W1,W5
08628:  MOV     W2,W6
0862A:  MOV     W5,1BB6
0862C:  MOV     W6,1BB8
0862E:  CALL    7200
08632:  MOV     W0,1B7A
08634:  MOV     W1,1B7C
.................... 			/////////////////////////////////////////////////// 
.................... 			/////////////////Envoi de l'angle au Roboteq/////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			if(AngToDo_int != 0) 
08636:  CP0     1B7A
08638:  BRA     NZ,863E
0863A:  CP0     1B7C
0863C:  BRA     Z,86CA
.................... 			{ 
.................... 				//balise 
.................... 				balise_on = 0; //desactive la balise sur une rotation 
0863E:  BCLR.B  85B.1
.................... 				 
.................... 				fprintf(ROBOTEQ,"!S 1 100_!S 2 100\r"); 
08640:  MOV     #0,W1
08642:  MOV     W1,W0
08644:  CLR.B   1
08646:  CALL    1BC
0864A:  INC     W1,W1
0864C:  BTSC.B  219.1
0864E:  BRA     864C
08650:  MOV     W0,21A
08652:  MOV     #11,W0
08654:  CPSGT   W1,W0
08656:  BRA     8642
.................... 				// on envoie les donnee au ROBOTEQ 
.................... 							 
.................... 				impulse_g = AngToDo_int; 
08658:  PUSH    1B7A
0865A:  POP     1B7E
0865C:  PUSH    1B7C
0865E:  POP     1B80
.................... 				impulse_d = 0-AngToDo_int; 
08660:  MOV     #0,W4
08662:  MOV     1B7A,W3
08664:  SUB     W4,W3,W0
08666:  MOV     W0,1B82
08668:  MOV     #0,W4
0866A:  MOV     1B7C,W3
0866C:  SUBB    W4,W3,W0
0866E:  MOV     W0,1B84
.................... 				fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",impulse_g,impulse_d); 
08670:  MOV     #0,W1
08672:  MOV     W1,W0
08674:  CLR.B   1
08676:  CALL    19C
0867A:  INC     W1,W1
0867C:  BTSC.B  219.1
0867E:  BRA     867C
08680:  MOV     W0,21A
08682:  MOV     #5,W0
08684:  CPSGT   W1,W0
08686:  BRA     8672
08688:  MOV     1B7E,W0
0868A:  MOV     1B80,W1
0868C:  MOV     #0,W4
0868E:  CALL    7352
08692:  MOV     #8,W1
08694:  MOV     W1,W0
08696:  CLR.B   1
08698:  CALL    19C
0869C:  INC     W1,W1
0869E:  BTSC.B  219.1
086A0:  BRA     869E
086A2:  MOV     W0,21A
086A4:  MOV     #E,W0
086A6:  CPSGT   W1,W0
086A8:  BRA     8694
086AA:  MOV     1B82,W0
086AC:  MOV     1B84,W1
086AE:  MOV     #0,W4
086B0:  CALL    7352
086B4:  BTSC.B  219.1
086B6:  BRA     86B4
086B8:  MOV     #20,W4
086BA:  MOV     W4,21A
086BC:  BTSC.B  219.1
086BE:  BRA     86BC
086C0:  MOV     #D,W4
086C2:  MOV     W4,21A
.................... 				 
.................... 				etat_deplacement  = 1;	 
086C4:  BSET.B  14B7.1
.................... 			}					 
086C6:  GOTO    86E4
.................... 			else 
.................... 			{			 
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r"); 
086CA:  MOV     #0,W1
086CC:  MOV     W1,W0
086CE:  CLR.B   1
086D0:  CALL    1DC
086D4:  INC     W1,W1
086D6:  BTSC.B  219.1
086D8:  BRA     86D6
086DA:  MOV     W0,21A
086DC:  MOV     #F,W0
086DE:  CPSGT   W1,W0
086E0:  BRA     86CC
.................... 				etat_deplacement = 1; 
086E2:  BSET.B  14B7.1
.................... 			}	 
.................... 			Orient = (float64)(Orient + AngToDo);	 
086E4:  BCLR.B  43.0
086E6:  MOV     159A,W0
086E8:  MOV     159C,W1
086EA:  MOV     159E,W2
086EC:  MOV     15A0,W3
086EE:  MOV     1B86,W4
086F0:  MOV     1B88,W5
086F2:  MOV     1B8A,W6
086F4:  MOV     1B8C,W7
086F6:  CALL    6F0A
086FA:  MOV     W0,159A
086FC:  MOV     W1,159C
086FE:  MOV     W2,159E
08700:  MOV     W3,15A0
.................... 			break; 
08702:  GOTO    8826
.................... 		case 1 : // gestion de la distance 
.................... 		 
.................... 			if(distToDo!=0)//si on doit faire avancer le robot 
08706:  MOV     1B6E,W0
08708:  MOV     1B70,W1
0870A:  MOV     1B72,W2
0870C:  MOV     1B74,W3
0870E:  MOV     #0,W4
08710:  MOV     #0,W5
08712:  MOV     #0,W6
08714:  MOV     #0,W7
08716:  CALL    70F8
0871A:  BRA     Z,881E
.................... 			{		 
.................... 				__Check_commande_atteint();  
0871C:  CALL    7D7E
.................... 				__Get_enco_value(1);	//recupere la valeur des encos du pt de depart 
08720:  MOV.B   #1,W0L
08722:  MOV.B   W0L,1BB0
08724:  CALL    7DDC
.................... 				 
.................... 				if(flag_depl_ok == 1)//On attend que le deplacment precedent soit fini(angle) 
08728:  BTSS.B  85A.6
0872A:  BRA     881A
.................... 				{ 
.................... 					fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax); 
0872C:  MOV     #0,W1
0872E:  MOV     W1,W0
08730:  CLR.B   1
08732:  CALL    17A
08736:  INC     W1,W1
08738:  BTSC.B  219.1
0873A:  BRA     8738
0873C:  MOV     W0,21A
0873E:  MOV     #4,W0
08740:  CPSGT   W1,W0
08742:  BRA     872E
08744:  MOV     14A2,W0
08746:  MOV     #8004,W4
08748:  CALL    725C
0874C:  MOV     #9,W1
0874E:  MOV     W1,W0
08750:  CLR.B   1
08752:  CALL    17A
08756:  INC     W1,W1
08758:  BTSC.B  219.1
0875A:  BRA     8758
0875C:  MOV     W0,21A
0875E:  MOV     #E,W0
08760:  CPSGT   W1,W0
08762:  BRA     874E
08764:  MOV     14A2,W0
08766:  MOV     #8004,W4
08768:  CALL    725C
0876C:  BTSC.B  219.1
0876E:  BRA     876C
08770:  MOV     #20,W4
08772:  MOV     W4,21A
08774:  BTSC.B  219.1
08776:  BRA     8774
08778:  MOV     #D,W4
0877A:  MOV     W4,21A
.................... 					 
.................... 					flag_depl_ok = 0; 
0877C:  BCLR.B  85A.6
.................... 					 
.................... 					if(oAvAr)//si on recule 
0877E:  CP0     149E
08780:  BRA     Z,879E
.................... 					{		 
.................... 						Balise_set_plage(1);//plage à l'arriere du robot						 
08782:  MOV.B   #1,W0L
08784:  MOV.B   W0L,1BB0
08786:  CALL    8040
.................... 						distToDo_int = 0 - distToDo_int; //impulse negative --> recule 
0878A:  MOV     #0,W4
0878C:  MOV     1B76,W3
0878E:  SUB     W4,W3,W0
08790:  MOV     W0,1B76
08792:  MOV     #0,W4
08794:  MOV     1B78,W3
08796:  SUBB    W4,W3,W0
08798:  MOV     W0,1B78
.................... 					} 
0879A:  GOTO    87A4
.................... 					else  
.................... 					{ 
.................... 						Balise_set_plage(0);//plage à l'avant du robot 
0879E:  CLR.B   1BB0
087A0:  CALL    8040
.................... 					} 
.................... 					//balise	 
.................... 					balise_on = 1; // active la balise sur un depl 
087A4:  BSET.B  85B.1
.................... 					//////////////////////////////////////////////////// 
.................... 					////////////envoie au Roobreq/////////////////////// 
.................... 					/////////////////////////////////////////////////// 
.................... 	 
.................... 					fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-distToDo_int,distToDo_int);						 
087A6:  MOV     #0,W4
087A8:  MOV     1B76,W3
087AA:  SUB     W4,W3,W5
087AC:  MOV     #0,W4
087AE:  MOV     1B78,W3
087B0:  SUBB    W4,W3,W6
087B2:  MOV     #0,W1
087B4:  MOV     W1,W0
087B6:  CLR.B   1
087B8:  CALL    1FA
087BC:  INC     W1,W1
087BE:  BTSC.B  219.1
087C0:  BRA     87BE
087C2:  MOV     W0,21A
087C4:  MOV     #5,W0
087C6:  CPSGT   W1,W0
087C8:  BRA     87B4
087CA:  MOV     W5,W0
087CC:  MOV     W6,W1
087CE:  MOV     #8007,W4
087D0:  CALL    7352
087D4:  MOV     #A,W1
087D6:  MOV     W1,W0
087D8:  CLR.B   1
087DA:  CALL    1FA
087DE:  INC     W1,W1
087E0:  BTSC.B  219.1
087E2:  BRA     87E0
087E4:  MOV     W0,21A
087E6:  MOV     #10,W0
087E8:  CPSGT   W1,W0
087EA:  BRA     87D6
087EC:  MOV     1B76,W0
087EE:  MOV     1B78,W1
087F0:  MOV     #8007,W4
087F2:  CALL    7352
087F6:  BTSC.B  219.1
087F8:  BRA     87F6
087FA:  MOV     #20,W4
087FC:  MOV     W4,21A
087FE:  BTSC.B  219.1
08800:  BRA     87FE
08802:  MOV     #D,W4
08804:  MOV     W4,21A
.................... 					Depl_send = 1;							//indique que l'on a fini d'envoyer les ordres du dÃ©placment 
08806:  BSET.B  85B.5
.................... 					etat_deplacement = 0; 
08808:  BCLR.B  14B7.1
.................... 					Dist_x = (signed int16)(_X - Pos_x);	//mise a jour pos x 
0880A:  MOV     1B5A,W4
0880C:  MOV     158C,W3
0880E:  SUB     W4,W3,W0
08810:  MOV     W0,1588
.................... 					Dist_y = (signed int16)(_Y - Pos_y); 	//mise a jour pos y 
08812:  MOV     1B5C,W4
08814:  MOV     158E,W3
08816:  SUB     W4,W3,W0
08818:  MOV     W0,158A
.................... 				}	 
.................... 			} 
0881A:  GOTO    8822
.................... 			else 
.................... 			{				 
.................... 				Depl_send = 1; 
0881E:  BSET.B  85B.5
.................... 				etat_deplacement = 0; 
08820:  BCLR.B  14B7.1
.................... 			} 
.................... 		break; 
08822:  GOTO    8826
.................... 	} 
.................... 	// Quitte la fonction 
.................... 	return; 
08826:  MOV     #12,W5
08828:  REPEAT  #3
0882A:  MOV     [--W15],[W5--]
0882C:  MOV     [--W15],W5
0882E:  RETURN  
.................... } 
.................... /* 
.................... 	/** 
.................... * \fn void __Progress(int16 _X, int16 _Y) 
.................... * \brief Fonction utile pour s'etalonner dans un bord  
.................... * \		 s'arrete en detectant une limite de courant  
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 23.2.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Progress(int16 _X, int16 _Y) 
*
08E98:  MOV     W5,[W15++]
08E9A:  MOV     #C,W5
08E9C:  REPEAT  #6
08E9E:  MOV     [W5++],[W15++]
08EA0:  CLR     1B5A
08EA2:  CLR     1B5C
08EA4:  CLR     1B5E
08EA6:  CLR     1B60
08EA8:  CLR     1B62
08EAA:  CLR     1B64
08EAC:  CLR     1B66
08EAE:  CLR     1B68
08EB0:  CLR     1B6A
08EB2:  CLR     1B6C
08EB4:  CLR     1B6E
08EB6:  CLR     1B70
.................... { 
.................... 	static unsigned int8 etat_depl; 
.................... 	float64 amp = 0;				//courant dans le moteur 1 
.................... 	float64 amp2 = 0;				//courant dans le moteur 2  
.................... 	static int1 m1_stop,m2_stop;	//arret moteur 1 et arret moteur 2 
....................  
.................... 	float64 Dist = 0;  
....................  
.................... 	switch(etat_depl) 
08EB8:  MOV.B   15E0,W0L
08EBA:  CLR.B   1
08EBC:  XOR     #0,W0
08EBE:  BRA     Z,8EC6
08EC0:  XOR     #1,W0
08EC2:  BRA     Z,9056
08EC4:  BRA     921A
.................... 	{ 
.................... 		case 0: 
.................... 		 	Dist = sqrt(((_X - Pos_x) * (_X - Pos_x)) + ((_Y - Pos_y) * (_Y - Pos_y))) + DIST_SECU_PROGRESS; // calcul distance de depl  
08EC6:  MOV     1B56,W4
08EC8:  MOV     158C,W3
08ECA:  SUB     W4,W3,W5
08ECC:  MOV     1B56,W4
08ECE:  MOV     158C,W3
08ED0:  SUB     W4,W3,W0
08ED2:  MUL.SS  W5,W0,W0
08ED4:  MOV     W0,W5
08ED6:  MOV     1B58,W4
08ED8:  MOV     158E,W3
08EDA:  SUB     W4,W3,W6
08EDC:  MOV     1B58,W4
08EDE:  MOV     158E,W3
08EE0:  SUB     W4,W3,W0
08EE2:  MUL.SS  W6,W0,W0
08EE4:  ADD     W0,W5,W0
08EE6:  CALL    21A0
08EEA:  MOV     W0,W5
08EEC:  MOV     W1,W6
08EEE:  MOV     W5,1BA2
08EF0:  MOV     W6,1BA4
08EF2:  CALL    2CAC
08EF6:  MOV     W0,W5
08EF8:  MOV     W1,W6
08EFA:  MOV     1586,W0
08EFC:  CALL    2348
08F00:  BCLR.B  43.0
08F02:  MOV     W0,W2
08F04:  MOV     W1,W3
08F06:  MOV     W5,W0
08F08:  MOV     W6,W1
08F0A:  CALL    2446
08F0E:  MOV     W1,W2
08F10:  MOV     W0,W1
08F12:  MOV     #0,W0
08F14:  CALL    8830
08F18:  MOV     W0,1B6A
08F1A:  MOV     W1,1B6C
08F1C:  MOV     W2,1B6E
08F1E:  MOV     W3,1B70
.................... 		 	Dist *= (COEFF_D/10);	//conversion mm en pas 
08F20:  MOV     15BA,W0
08F22:  MOV     15BC,W1
08F24:  MOV     15BE,W2
08F26:  MOV     15C0,W3
08F28:  MOV     #0,W4
08F2A:  MOV     #0,W5
08F2C:  MOV     #0,W6
08F2E:  MOV     #4024,W7
08F30:  CALL    D0A
08F34:  MOV     W0,W4
08F36:  MOV     W1,W5
08F38:  MOV     W2,W6
08F3A:  MOV     W3,W7
08F3C:  MOV     1B6A,W0
08F3E:  MOV     1B6C,W1
08F40:  MOV     1B6E,W2
08F42:  MOV     1B70,W3
08F44:  CALL    BFA
08F48:  MOV     W0,1B6A
08F4A:  MOV     W1,1B6C
08F4C:  MOV     W2,1B6E
08F4E:  MOV     W3,1B70
.................... 			flag_depl_ok = 0; 
08F50:  BCLR.B  85A.6
.................... 			 
.................... 			//balise	 
.................... 			balise_on = 1; // active la balise sur un depl				 
08F52:  BSET.B  85B.1
.................... 			 
.................... 			if(oAvAr)//si on recule 
08F54:  CP0     149E
08F56:  BRA     Z,8F82
.................... 			{	 
.................... 				Balise_set_plage(1);//plage à l'arriere du robot					 
08F58:  MOV.B   #1,W0L
08F5A:  MOV.B   W0L,1BB0
08F5C:  CALL    8040
.................... 				Dist = 0 - Dist; 	// on inverse la distance 
08F60:  BSET.B  43.0
08F62:  MOV     #0,W0
08F64:  MOV     #0,W1
08F66:  MOV     #0,W2
08F68:  MOV     #0,W3
08F6A:  MOV     1B6A,W4
08F6C:  MOV     1B6C,W5
08F6E:  MOV     1B6E,W6
08F70:  MOV     1B70,W7
08F72:  CALL    6F0A
08F76:  MOV     W0,1B6A
08F78:  MOV     W1,1B6C
08F7A:  MOV     W2,1B6E
08F7C:  MOV     W3,1B70
.................... 			} 
08F7E:  GOTO    8F88
.................... 			else  
.................... 			{ 
.................... 				Balise_set_plage(0);//plage à l'avant du robot 
08F82:  CLR.B   1BB0
08F84:  CALL    8040
.................... 			} 
.................... 			//////////////////////////////////////////////////// 
.................... 			////////////envoie au Roobreq/////////////////////// 
.................... 			/////////////////////////////////////////////////// 
.................... 			//__Get_enco_value(1); 
.................... 			 
.................... 			fprintf(ROBOTEQ,"!S 1 %04u_!S 2 %04u \r",oVitMax,oVitMax);	 
08F88:  MOV     #0,W1
08F8A:  MOV     W1,W0
08F8C:  CLR.B   1
08F8E:  CALL    17A
08F92:  INC     W1,W1
08F94:  BTSC.B  219.1
08F96:  BRA     8F94
08F98:  MOV     W0,21A
08F9A:  MOV     #4,W0
08F9C:  CPSGT   W1,W0
08F9E:  BRA     8F8A
08FA0:  MOV     14A2,W0
08FA2:  MOV     #8004,W4
08FA4:  CALL    725C
08FA8:  MOV     #9,W1
08FAA:  MOV     W1,W0
08FAC:  CLR.B   1
08FAE:  CALL    17A
08FB2:  INC     W1,W1
08FB4:  BTSC.B  219.1
08FB6:  BRA     8FB4
08FB8:  MOV     W0,21A
08FBA:  MOV     #E,W0
08FBC:  CPSGT   W1,W0
08FBE:  BRA     8FAA
08FC0:  MOV     14A2,W0
08FC2:  MOV     #8004,W4
08FC4:  CALL    725C
08FC8:  BTSC.B  219.1
08FCA:  BRA     8FC8
08FCC:  MOV     #20,W4
08FCE:  MOV     W4,21A
08FD0:  BTSC.B  219.1
08FD2:  BRA     8FD0
08FD4:  MOV     #D,W4
08FD6:  MOV     W4,21A
.................... 			fprintf(ROBOTEQ,"!PR 1 %d_!PR 2 %d \r",-Dist,-Dist);		 
08FD8:  MOV     1B6A,W5
08FDA:  MOV     1B6C,W6
08FDC:  MOV     1B6E,W7
08FDE:  MOV     1B70,W8
08FE0:  BTG     W8.F
08FE2:  MOV     1B6A,W9
08FE4:  MOV     1B6C,W10
08FE6:  MOV     1B6E,W11
08FE8:  MOV     1B70,W12
08FEA:  BTG     W12.F
08FEC:  MOV     #0,W1
08FEE:  MOV     W1,W0
08FF0:  CLR.B   1
08FF2:  CALL    19C
08FF6:  INC     W1,W1
08FF8:  BTSC.B  219.1
08FFA:  BRA     8FF8
08FFC:  MOV     W0,21A
08FFE:  MOV     #5,W0
09000:  CPSGT   W1,W0
09002:  BRA     8FEE
09004:  MOV     W5,W0
09006:  MOV     W6,W1
09008:  MOV     W7,W2
0900A:  MOV     W8,W3
0900C:  MOV     #0,W4
0900E:  CALL    890A
09012:  MOV     #8,W1
09014:  MOV     W1,W0
09016:  CLR.B   1
09018:  CALL    19C
0901C:  INC     W1,W1
0901E:  BTSC.B  219.1
09020:  BRA     901E
09022:  MOV     W0,21A
09024:  MOV     #E,W0
09026:  CPSGT   W1,W0
09028:  BRA     9014
0902A:  MOV     W9,W0
0902C:  MOV     W10,W1
0902E:  MOV     W11,W2
09030:  MOV     W12,W3
09032:  MOV     #0,W4
09034:  CALL    890A
09038:  BTSC.B  219.1
0903A:  BRA     9038
0903C:  MOV     #20,W4
0903E:  MOV     W4,21A
09040:  BTSC.B  219.1
09042:  BRA     9040
09044:  MOV     #D,W4
09046:  MOV     W4,21A
.................... 			 
.................... 			etat_depl = 1; 
09048:  MOV.B   #1,W0L
0904A:  MOV.B   W0L,15E0
.................... 			delay_ms(20); 
0904C:  MOV     #14,W0
0904E:  CALL    EBE
.................... 			 
.................... 			break; 
09052:  GOTO    921A
.................... 		case 1:  
.................... 			amp = (float64)(__Get_amp(1));	//recup du courant du mot 1 
09056:  MOV     #1,W4
09058:  MOV     W4,1B7C
0905A:  CALL    8A9C
0905E:  MOV     W0,1B5A
09060:  MOV     W1,1B5C
09062:  MOV     W2,1B5E
09064:  MOV     W3,1B60
.................... 			amp2 =(float64)(__Get_amp(2));	//recup du courant du mot 2 
09066:  MOV     #2,W4
09068:  MOV     W4,1B7C
0906A:  CALL    8A9C
0906E:  MOV     W0,1B62
09070:  MOV     W1,1B64
09072:  MOV     W2,1B66
09074:  MOV     W3,1B68
.................... 			amp /= 10;					  	// roboteq envoie 15A pour 1,5A --> /10 
09076:  MOV     1B5A,W0
09078:  MOV     1B5C,W1
0907A:  MOV     1B5E,W2
0907C:  MOV     1B60,W3
0907E:  MOV     #0,W4
09080:  MOV     #0,W5
09082:  MOV     #0,W6
09084:  MOV     #4024,W7
09086:  CALL    D0A
0908A:  MOV     W0,1B5A
0908C:  MOV     W1,1B5C
0908E:  MOV     W2,1B5E
09090:  MOV     W3,1B60
.................... 			amp2 /= 10;					 	// roboteq envoie 15A pour 1,5A --> /10 
09092:  MOV     1B62,W0
09094:  MOV     1B64,W1
09096:  MOV     1B66,W2
09098:  MOV     1B68,W3
0909A:  MOV     #0,W4
0909C:  MOV     #0,W5
0909E:  MOV     #0,W6
090A0:  MOV     #4024,W7
090A2:  CALL    D0A
090A6:  MOV     W0,1B62
090A8:  MOV     W1,1B64
090AA:  MOV     W2,1B66
090AC:  MOV     W3,1B68
.................... 			if(amp >= amp_limit)		 	//Seuil courant ds mot 1 detecte  
090AE:  MOV     157E,W0
090B0:  MOV     1580,W1
090B2:  MOV     1582,W2
090B4:  MOV     1584,W3
090B6:  MOV     1B5A,W4
090B8:  MOV     1B5C,W5
090BA:  MOV     1B5E,W6
090BC:  MOV     1B60,W7
090BE:  CALL    70F8
090C2:  BRA     C,90C6
090C4:  BRA     NZ,90E0
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 1\r");	//Stop le mot 1  
090C6:  MOV     #0,W1
090C8:  MOV     W1,W0
090CA:  CLR.B   1
090CC:  CALL    21E
090D0:  INC     W1,W1
090D2:  BTSC.B  219.1
090D4:  BRA     90D2
090D6:  MOV     W0,21A
090D8:  MOV     #5,W0
090DA:  CPSGT   W1,W0
090DC:  BRA     90C8
.................... 				m1_stop = 1; 
090DE:  BSET.B  14B7.2
.................... 			} 
.................... 			if(amp2 >= amp_limit)			//Seuil courant ds mot 2 detecte 
090E0:  MOV     157E,W0
090E2:  MOV     1580,W1
090E4:  MOV     1582,W2
090E6:  MOV     1584,W3
090E8:  MOV     1B62,W4
090EA:  MOV     1B64,W5
090EC:  MOV     1B66,W6
090EE:  MOV     1B68,W7
090F0:  CALL    70F8
090F4:  BRA     C,90F8
090F6:  BRA     NZ,9112
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!MS 2\r");	//Stop le mot 2 
090F8:  MOV     #0,W1
090FA:  MOV     W1,W0
090FC:  CLR.B   1
090FE:  CALL    232
09102:  INC     W1,W1
09104:  BTSC.B  219.1
09106:  BRA     9104
09108:  MOV     W0,21A
0910A:  MOV     #5,W0
0910C:  CPSGT   W1,W0
0910E:  BRA     90FA
.................... 				m2_stop = 1; 
09110:  BSET.B  14B7.3
.................... 			}	 
.................... 			if(m1_stop==1 && m2_stop==1)	//les 2 moteurs stopes 
09112:  BTSS.B  14B7.2
09114:  BRA     9180
09116:  BTSS.B  14B7.3
09118:  BRA     9180
.................... 			{ 
....................  
.................... 				fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); 	//passage en open loop speed 
0911A:  MOV     #0,W1
0911C:  MOV     W1,W0
0911E:  CLR.B   1
09120:  CALL    136
09124:  INC     W1,W1
09126:  BTSC.B  219.1
09128:  BRA     9126
0912A:  MOV     W0,21A
0912C:  MOV     #13,W0
0912E:  CPSGT   W1,W0
09130:  BRA     911C
.................... 				delay_ms(10); 
09132:  MOV     #A,W0
09134:  CALL    EBE
.................... 				fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); 	//passage en closed loop count postion 
09138:  MOV     #0,W1
0913A:  MOV     W1,W0
0913C:  CLR.B   1
0913E:  CALL    158
09142:  INC     W1,W1
09144:  BTSC.B  219.1
09146:  BRA     9144
09148:  MOV     W0,21A
0914A:  MOV     #13,W0
0914C:  CPSGT   W1,W0
0914E:  BRA     913A
.................... 								 
.................... 				Depl_send = 1; 							  	//fin du déplacment 
09150:  BSET.B  85B.5
.................... 				etat_depl = 0; 
09152:  CLR.B   15E0
....................  
.................... 				fprintf(ROBOTEQ,"!PR 1 1_!PR 2 1\r");	   
09154:  MOV     #0,W1
09156:  MOV     W1,W0
09158:  CLR.B   1
0915A:  CALL    1DC
0915E:  INC     W1,W1
09160:  BTSC.B  219.1
09162:  BRA     9160
09164:  MOV     W0,21A
09166:  MOV     #F,W0
09168:  CPSGT   W1,W0
0916A:  BRA     9156
.................... 				 
.................... 				Dist_x = (signed int16)(_X-Pos_x);			//mise a jour pos x 
0916C:  MOV     1B56,W4
0916E:  MOV     158C,W3
09170:  SUB     W4,W3,W0
09172:  MOV     W0,1588
.................... 				Dist_y = (signed int16)(_Y-Pos_y);			//mise a jour pos y 
09174:  MOV     1B58,W4
09176:  MOV     158E,W3
09178:  SUB     W4,W3,W0
0917A:  MOV     W0,158A
.................... 			} 
0917C:  GOTO    9216
.................... 			else // si pos atteinte 
.................... 			{					 
.................... 				__Check_commande_atteint();  
09180:  CALL    7D7E
.................... 				if(flag_depl_ok == 1) //On attend que le deplacment precedent soit fini(angle) 
09184:  BTSS.B  85A.6
09186:  BRA     9216
.................... 				{ 
.................... 					Dist_x =  cos(Orient) * Dist;			//mise a jour pos x 
09188:  PUSH    159A
0918A:  POP     1B96
0918C:  PUSH    159C
0918E:  POP     1B98
09190:  PUSH    159E
09192:  POP     1B9A
09194:  PUSH    15A0
09196:  POP     1B9C
09198:  CALL    8BA2
0919C:  MOV     W0,W5
0919E:  MOV     W1,W6
091A0:  MOV     W2,W7
091A2:  MOV     W3,W8
091A4:  MOV     W5,[W15++]
091A6:  MOV     W6,[W15++]
091A8:  MOV     W7,[W15++]
091AA:  MOV     W5,W0
091AC:  MOV     W6,W1
091AE:  MOV     W7,W2
091B0:  MOV     W8,W3
091B2:  MOV     1B6A,W4
091B4:  MOV     1B6C,W5
091B6:  MOV     1B6E,W6
091B8:  MOV     1B70,W7
091BA:  CALL    BFA
091BE:  MOV     [--W15],W7
091C0:  MOV     [--W15],W6
091C2:  MOV     [--W15],W5
091C4:  CALL    78C8
091C8:  MOV     W0,1588
.................... 					Dist_y =  sin(Orient) * Dist;			//mise a jour pos y 
091CA:  PUSH    159A
091CC:  POP     1B7C
091CE:  PUSH    159C
091D0:  POP     1B7E
091D2:  PUSH    159E
091D4:  POP     1B80
091D6:  PUSH    15A0
091D8:  POP     1B82
091DA:  CALL    8E5C
091DE:  MOV     W0,W5
091E0:  MOV     W1,W6
091E2:  MOV     W2,W7
091E4:  MOV     W3,W8
091E6:  MOV     W5,[W15++]
091E8:  MOV     W6,[W15++]
091EA:  MOV     W7,[W15++]
091EC:  MOV     W5,W0
091EE:  MOV     W6,W1
091F0:  MOV     W7,W2
091F2:  MOV     W8,W3
091F4:  MOV     1B6A,W4
091F6:  MOV     1B6C,W5
091F8:  MOV     1B6E,W6
091FA:  MOV     1B70,W7
091FC:  CALL    BFA
09200:  MOV     [--W15],W7
09202:  MOV     [--W15],W6
09204:  MOV     [--W15],W5
09206:  CALL    78C8
0920A:  MOV     W0,158A
....................  
.................... 					//remise a zero des varaibles 
.................... 					flag_depl_ok = 0; 
0920C:  BCLR.B  85A.6
.................... 					Depl_send = 1; 
0920E:  BSET.B  85B.5
.................... 					m1_stop = 0; 
09210:  BCLR.B  14B7.2
.................... 					m2_stop = 0;								 
09212:  BCLR.B  14B7.3
.................... 					etat_depl = 0;			 
09214:  CLR.B   15E0
.................... 				} 
.................... 			} 
.................... 			break; 
09216:  GOTO    921A
.................... 	} 
0921A:  MOV     #18,W5
0921C:  REPEAT  #6
0921E:  MOV     [--W15],[W5--]
09220:  MOV     [--W15],W5
09222:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __Nothing(void) 
.................... * \brief Passe l'objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 1.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
....................  
.................... void __Nothing(void) 
.................... { 
.................... 	flag_depl_ok = 1;  
09224:  BSET.B  85A.6
.................... 	Depl_send=1; 
09226:  BSET.B  85B.5
.................... 	balise_on = 0; 
09228:  BCLR.B  85B.1
.................... 	// Quitte la fonction 
.................... 	return; 
0922A:  RETURN  
.................... } 
.................... /** 
.................... * \fn void __LoadObj(unsigned int8 _Obj) 
.................... * \brief Charge le prochain objectif 
.................... * 
.................... * \author Borgeat Remy 
.................... * \version 2.0 
.................... * \date 9.6.2017 
.................... * 
.................... * \param [in] _Obj Numero de l'objectif desire 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __LoadObj(unsigned int16 _Obj,unsigned int16 pts) 
*
018C4:  MOV     W5,[W15++]
.................... {	 
.................... 	// Enregistre Xp, en [mm] 
.................... 	oXp=TabObjectifs[_Obj][pts][0]; 
018C6:  MOV     1B56,W4
018C8:  MOV     #138,W3
018CA:  MUL.UU  W4,W3,W0
018CC:  MOV     W0,W5
018CE:  MOV     1B58,W4
018D0:  MUL.UU  W4,#18,W0
018D2:  ADD     W0,W5,W5
018D4:  MOV     #C10,W4
018D6:  ADD     W5,W4,W0
018D8:  MOV     [W0],[W15++]
018DA:  POP     1498
....................  
.................... 	// Enregistre Yp, en [mm] 
.................... 	oYp=TabObjectifs[_Obj][pts][1]; 
018DC:  MOV     1B56,W4
018DE:  MOV     #138,W3
018E0:  MUL.UU  W4,W3,W0
018E2:  MOV     W0,W5
018E4:  MOV     1B58,W4
018E6:  MUL.UU  W4,#18,W0
018E8:  ADD     W0,W5,W5
018EA:  ADD     W5,#2,W5
018EC:  MOV     W5,W0
018EE:  MOV     #C10,W4
018F0:  ADD     W0,W4,W0
018F2:  MOV     [W0],[W15++]
018F4:  POP     149A
....................  
.................... 	// Enregistre le type de deplacement, en [nbre] 
.................... 	oType=TabObjectifs[_Obj][pts][2]; 
018F6:  MOV     1B56,W4
018F8:  MOV     #138,W3
018FA:  MUL.UU  W4,W3,W0
018FC:  MOV     W0,W5
018FE:  MOV     1B58,W4
01900:  MUL.UU  W4,#18,W0
01902:  ADD     W0,W5,W5
01904:  ADD     W5,#4,W5
01906:  MOV     W5,W0
01908:  MOV     #C10,W4
0190A:  ADD     W0,W4,W0
0190C:  MOV     [W0],[W15++]
0190E:  POP     149C
....................  
.................... 	// Enregistre si avance ou recule 
.................... 	oAvAr=TabObjectifs[_Obj][pts][3]; 
01910:  MOV     1B56,W4
01912:  MOV     #138,W3
01914:  MUL.UU  W4,W3,W0
01916:  MOV     W0,W5
01918:  MOV     1B58,W4
0191A:  MUL.UU  W4,#18,W0
0191C:  ADD     W0,W5,W5
0191E:  ADD     W5,#6,W5
01920:  MOV     W5,W0
01922:  MOV     #C10,W4
01924:  ADD     W0,W4,W0
01926:  MOV     [W0],[W15++]
01928:  POP     149E
....................  
.................... 	// Enregistre le cote duquel tourner 
.................... 	oCoteTourn=TabObjectifs[_Obj][pts][4]; 
0192A:  MOV     1B56,W4
0192C:  MOV     #138,W3
0192E:  MUL.UU  W4,W3,W0
01930:  MOV     W0,W5
01932:  MOV     1B58,W4
01934:  MUL.UU  W4,#18,W0
01936:  ADD     W0,W5,W5
01938:  ADD     W5,#8,W5
0193A:  MOV     W5,W0
0193C:  MOV     #C10,W4
0193E:  ADD     W0,W4,W0
01940:  MOV     [W0],[W15++]
01942:  POP     14A0
....................  
.................... 	// Enregistre la vitesse maximum, en [mm/s] (en [0/000] pour RoboteQ) 
.................... 	oVitMax=TabObjectifs[_Obj][pts][5]; 
01944:  MOV     1B56,W4
01946:  MOV     #138,W3
01948:  MUL.UU  W4,W3,W0
0194A:  MOV     W0,W5
0194C:  MOV     1B58,W4
0194E:  MUL.UU  W4,#18,W0
01950:  ADD     W0,W5,W5
01952:  ADD     W5,#A,W5
01954:  MOV     W5,W0
01956:  MOV     #C10,W4
01958:  ADD     W0,W4,W0
0195A:  MOV     [W0],[W15++]
0195C:  POP     14A2
....................  
.................... 	//Enregistre l'action a faire 
.................... 	Obj_Action = TabObjectifs[_Obj][pts][6]; 
0195E:  MOV     1B56,W4
01960:  MOV     #138,W3
01962:  MUL.UU  W4,W3,W0
01964:  MOV     W0,W5
01966:  MOV     1B58,W4
01968:  MUL.UU  W4,#18,W0
0196A:  ADD     W0,W5,W5
0196C:  ADD     W5,#C,W5
0196E:  MOV     W5,W0
01970:  MOV     #C10,W4
01972:  ADD     W0,W4,W0
01974:  MOV     [W0],[W15++]
01976:  POP     14A4
.................... 	 
.................... 	//Enregistre si le pt est symetrique ou non 
.................... 	Pt_commun = TabObjectifs[_Obj][pts][7]; 
01978:  MOV     1B56,W4
0197A:  MOV     #138,W3
0197C:  MUL.UU  W4,W3,W0
0197E:  MOV     W0,W5
01980:  MOV     1B58,W4
01982:  MUL.UU  W4,#18,W0
01984:  ADD     W0,W5,W5
01986:  ADD     W5,#E,W5
01988:  MOV     W5,W0
0198A:  MOV     #C10,W4
0198C:  ADD     W0,W4,W0
0198E:  MOV     [W0],[W15++]
01990:  POP     14A6
.................... 	 
.................... 	//ponderation objectifs 
.................... 	Ponderation = TabObjectifs[_Obj][pts][8];	 
01992:  MOV     1B56,W4
01994:  MOV     #138,W3
01996:  MUL.UU  W4,W3,W0
01998:  MOV     W0,W5
0199A:  MOV     1B58,W4
0199C:  MUL.UU  W4,#18,W0
0199E:  ADD     W0,W5,W5
019A0:  ADD     W5,#10,W5
019A2:  MOV     W5,W0
019A4:  MOV     #C10,W4
019A6:  ADD     W0,W4,W0
019A8:  MOV     [W0],[W15++]
019AA:  POP     14A8
.................... 	 
.................... 	//Objectifs fini ou non 
.................... 	Obj_end	= TabObjectifs[_Obj][pts][9];  
019AC:  MOV     1B56,W4
019AE:  MOV     #138,W3
019B0:  MUL.UU  W4,W3,W0
019B2:  MOV     W0,W5
019B4:  MOV     1B58,W4
019B6:  MUL.UU  W4,#18,W0
019B8:  ADD     W0,W5,W5
019BA:  ADD     W5,#12,W5
019BC:  MOV     W5,W0
019BE:  MOV     #C10,W4
019C0:  ADD     W0,W4,W0
019C2:  MOV     [W0],[W15++]
019C4:  POP     14AA
.................... 	 
.................... 	//prochain objectifs 
.................... 	Next_obj = TabObjectifs[_Obj][pts][10]; 
019C6:  MOV     1B56,W4
019C8:  MOV     #138,W3
019CA:  MUL.UU  W4,W3,W0
019CC:  MOV     W0,W5
019CE:  MOV     1B58,W4
019D0:  MUL.UU  W4,#18,W0
019D2:  ADD     W0,W5,W5
019D4:  ADD     W5,#14,W5
019D6:  MOV     W5,W0
019D8:  MOV     #C10,W4
019DA:  ADD     W0,W4,W0
019DC:  MOV     [W0],[W15++]
019DE:  POP     14AC
.................... 	 
.................... 	keep_obj = TabObjectifs[_Obj][pts][11]; 
019E0:  MOV     1B56,W4
019E2:  MOV     #138,W3
019E4:  MUL.UU  W4,W3,W0
019E6:  MOV     W0,W5
019E8:  MOV     1B58,W4
019EA:  MUL.UU  W4,#18,W0
019EC:  ADD     W0,W5,W5
019EE:  ADD     W5,#16,W5
019F0:  MOV     W5,W0
019F2:  MOV     #C10,W4
019F4:  ADD     W0,W4,W0
019F6:  MOV     [W0],[W15++]
019F8:  POP     14AE
....................  
.................... 	// Switch les donnees selon la base choisie et le mode 
.................... 	if(TEAM) 
019FA:  BTSS.B  85B.3
019FC:  BRA     1A58
.................... 	{ 
.................... 		switch(oType) 
019FE:  MOV     149C,W0
01A00:  XOR     #0,W0
01A02:  BRA     Z,1A0A
01A04:  XOR     #1,W0
01A06:  BRA     Z,1A2A
01A08:  BRA     1A54
.................... 		{ 
.................... 			case 0 : 
.................... 				if(oXp<=180)oXp=180-oXp; //gestion angle 
01A0A:  MOV     1498,W4
01A0C:  MOV     #B4,W3
01A0E:  CP      W3,W4
01A10:  BRA     LT,1A1E
01A12:  MOV     #B4,W4
01A14:  MOV     1498,W3
01A16:  SUB     W4,W3,W0
01A18:  MOV     W0,1498
01A1A:  GOTO    1A26
.................... 				else oXp = 540 - oXp; 
01A1E:  MOV     #21C,W4
01A20:  MOV     1498,W3
01A22:  SUB     W4,W3,W0
01A24:  MOV     W0,1498
.................... 				break; 
01A26:  GOTO    1A58
.................... 			case 1 : 
.................... 				// PaP ou retient sur place, calcul automatique de l'angle, inversion oX et oCoteTourn 
.................... 				// Enregistre Xp, en [mm] 
.................... 				oXp = TableWidth - oXp; 
01A2A:  MOV     87E,W4
01A2C:  MOV     1498,W3
01A2E:  SUB     W4,W3,W0
01A30:  MOV     W0,1498
.................... 				// Enregistre le cote duquel tourner 
.................... 				if(oCoteTourn==1)oCoteTourn=2; 
01A32:  MOV     14A0,W4
01A34:  CP      W4,#1
01A36:  BRA     NZ,1A40
01A38:  MOV     #2,W4
01A3A:  MOV     W4,14A0
01A3C:  GOTO    1A50
.................... 				else if(oCoteTourn==2)oCoteTourn=1; 
01A40:  MOV     14A0,W4
01A42:  CP      W4,#2
01A44:  BRA     NZ,1A4E
01A46:  MOV     #1,W4
01A48:  MOV     W4,14A0
01A4A:  GOTO    1A50
.................... 				else oCoteTourn=0; 
01A4E:  CLR     14A0
.................... 	 
.................... 				break; 
01A50:  GOTO    1A58
.................... 			default : 
.................... 				break; 
01A54:  GOTO    1A58
.................... 		}		 
.................... 	}						 
01A58:  MOV     [--W15],W5
01A5A:  RETURN  
.................... } 
.................... #endif 
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    RDA_isr 
.................... //	Auteur :	AMANAX 
.................... //	Date:	    27.03.2015 
.................... //  Statut :    OK 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Interruption pour la rÃÂ©ception RS232.  
.................... #INT_RDA2 
.................... void RDA2_isr(void) 
*
005AA:  PUSH    42
005AC:  PUSH    36
005AE:  PUSH    32
005B0:  MOV     W0,[W15++]
005B2:  MOV     #2,W0
005B4:  REPEAT  #C
005B6:  MOV     [W0++],[W15++]
.................... { 
.................... 	// Pour la lecture du caractÃÂ¨re reÃÂ§u 
.................... 	char myChar; 
.................... 	// RÃÂ©ception 
.................... 	myChar = fgetc(ROBOTEQ); 
005B8:  BTSS.B  218.0
005BA:  BRA     5B8
005BC:  MOV     21C,W0
005BE:  MOV.B   W0L,1D8C
.................... 	// Ajout au buffer et incrÃÂ©mentation de la longeur du buffer 
.................... 	RoboteQ_receiveBuffer[RoboteQ_receiveLenght] = myChar; 
005C0:  MOV     15CA,W4
005C2:  LSR     W4,#8,W4
005C4:  MOV     #882,W3
005C6:  ADD     W4,W3,W5
005C8:  MOV     1D8C,W0
005CA:  MOV.B   W0L,[W5+#0]
.................... 	RoboteQ_receiveLenght++; 
005CC:  INC.B   15CB
.................... 	 
.................... 	// Si on trouve la fin de la commande 
.................... 	if(myChar == '\r') 
005CE:  MOV     1D8C,W4
005D0:  CP.B    W4L,#D
005D2:  BRA     NZ,5DA
.................... 	{ 
.................... 		// On dit qu'on peut lire le buffer de rÃÂ©ception 
.................... 		RoboteQ_receiveToProceed = RoboteQ_receiveLenght; 
005D4:  MOV.B   15CB,W0L
005D6:  MOV.B   W0L,15CA
.................... 		RoboteQ_receiveLenght=0; 
005D8:  CLR.B   15CB
.................... 	} 
....................  
.................... } 
....................  
.................... #endif 
....................  
.................... #include "Functions.h" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: TestCartePrinc.mcp														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === ContrÃ´le du robor secondaire.																	== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_h 
005DA:  BCLR.B  87.0
005DC:  MOV     #1A,W0
005DE:  REPEAT  #C
005E0:  MOV     [--W15],[W0--]
005E2:  MOV     [--W15],W0
005E4:  POP     32
005E6:  POP     36
005E8:  POP     42
005EA:  RETFIE  
.................... #define ___Functions_h 
....................  
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0); 
.................... int1 Eject(void); 
....................  
.................... //unsigned int16 soll_vit_rot  = 1450; 
.................... unsigned int16 soll_vit_rot_zero = 2000;  
.................... unsigned int16 soll_vit_mov = 1200; 
....................  
.................... int1 Sens_rot_Couronne = 0; 
....................  
.................... signed int32 Endposition = 0; //position qui doit etre atteinte a la fin du depl 
.................... unsigned int8 Etat_ejection = 0; 
.................... int1 bras_out = 0; 
.................... //int1 bras_in  = 0; 
.................... //int1 flag_module_fond = 0; 
.................... void __ReadObjectifs(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
.................... void __resetEEPROM(void); 
.................... void __reset_roboteq(void); 
.................... void __GetRoboteqPID(unsigned int8 valeur); 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2); 
.................... unsigned int8 __Ask_I2C(unsigned int8 Adr); 
.................... unsigned int8 __Send_I2C(unsigned int8 Adr,unsigned int8* TabToSend); 
.................... void __Gestion_surcharge(unsigned int8 Adresse_driver); 
.................... void __Action_Writting(unsigned int8 ActionToDo); 
.................... void __ReadZones_Interdites(void); 
....................  
.................... unsigned int8 driver_Pompes(unsigned int8 Adresse_driver, unsigned int8 pompe_A, unsigned int8 pompe_B, unsigned int8 pompe_C, unsigned int8 pompe_D, unsigned int8 pompe_E); 
.................... unsigned int8 read_driver_pompes(int8 adresse_driver); 
.................... int1 Panneau_Domotique(void); 
.................... int1 Ramassage(unsigned int8 cote); 
.................... int1 Empilage(void); 
.................... int1 GoToZero_Cremaillere(void); 
.................... int1 reinitialisation(void); 
.................... int1 __GoToZero(void); 
.................... int1 __Check_action_end(unsigned int8 driver_address); 
....................  
.................... #include "Functions.c" 
....................  
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Amand Axel 
.................... 						: Borgeat Rémy     					  										== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Function.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient des fonctions pour le robot																== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Functions_c 
.................... #define ___Functions_c 
....................  
.................... //TEMP//////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_roboteq 300///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_cour 200///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE vitesse_crem 200///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE impulse -10672///////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE distance 52000//////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #DEFINE START 30 
.................... //unsigned int8 points = 0;////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Nom: 	    Afficheur 7 segments 
.................... //	Auteur :	BORR 
.................... //	Date:	    6.1.16 
.................... //  Statut :    Fonctionnel 
.................... //  Futur :     n.a. 
.................... //---------------------------------------------------------------------------------------------------- 
.................... //  Description : Gère 2 afficheur 7 segments 
.................... //	Paramètre(s): int8 nombre -> nombre<=99 
.................... //  Résultat :    /  
.................... //---------------------------------------------------------------------------------------------------- 
.................... void __Afficheur_7segments(int8 nombre,int1 ToBlank=0) 
.................... { 
.................... 	_EN_Uni = _En_Diz = 1; 
*
01338:  BSET.B  2C9.2
0133A:  BSET.B  2C9.3
.................... 	 
.................... 	if(ToBlank) 
0133C:  CP0.B   1B5D
0133E:  BRA     Z,1350
.................... 	{ 
.................... 		PORTB |= 0b1111<<12; 
01340:  MOV     #F000,W0
01342:  IOR     2C8
.................... 		// charge sur les latchs 
.................... 		_EN_Uni = _En_Diz = 0; 
01344:  BCLR.B  2C9.2
01346:  BCLR.B  2C9.3
.................... 		_EN_Uni = _En_Diz = 1; 
01348:  BSET.B  2C9.2
0134A:  BSET.B  2C9.3
.................... 	} 
0134C:  GOTO    138A
.................... 	else 
.................... 	{		 
.................... 		static unsigned int16 dizaine = 0; // variable qui va récupérer le chiffre des dizaine  
.................... 		static unsigned int16 unite = 0; // variable qui va récupérer le chiffre des unité 
.................... 	 
.................... 		dizaine = nombre/10; //récupération du nombre des dizaine 
01350:  MOV.B   1B5C,W0L
01352:  SE      W0,W0
01354:  MOV     W0,W4
01356:  MOV     #A,W3
01358:  REPEAT  #11
0135A:  DIV.S   W4,W3
0135C:  MOV     W0,15EA
.................... 		unite   = nombre%10; //récupération du nombre des unités 
0135E:  MOV.B   1B5C,W0L
01360:  SE      W0,W0
01362:  MOV     W0,W4
01364:  MOV     #A,W3
01366:  REPEAT  #11
01368:  DIV.S   W4,W3
0136A:  MOV     W1,W0
0136C:  MOV     W0,15EC
.................... 	 
.................... 		dizaine = dizaine * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
0136E:  MOV     15EA,W0
01370:  SL      W0,#C,W0
01372:  MOV     W0,15EA
.................... 		unite = unite * 4096; //décalage vers la droite car sortie sur RB12 à RB15 
01374:  MOV     15EC,W0
01376:  SL      W0,#C,W0
01378:  MOV     W0,15EC
.................... 		 
.................... 		_En_Diz = 0; // possibilité d'afficher sur l'afficheur des dizaine	 
0137A:  BCLR.B  2C9.2
.................... 		PORTB = dizaine; //affichage de la valeur sur l'afficheur 
0137C:  PUSH    15EA
0137E:  POP     2C8
.................... 		_En_Diz = 1; // Afficheur dizaine allumé, mais on ne peux plus changer la valeur 
01380:  BSET.B  2C9.2
.................... 	 
.................... 		_EN_Uni = 0; // possibilité d'afficher sur afficheur unité  
01382:  BCLR.B  2C9.3
.................... 		PORTB = unite; // affichage des unité sur l'afficheur des unité  
01384:  PUSH    15EC
01386:  POP     2C8
.................... 		_EN_Uni = 1; // Afficheur unité allumé, mais on ne peux plus changer la valeur 
01388:  BSET.B  2C9.3
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return; 
0138A:  RETURN  
.................... } 
....................  
.................... /* 
.................... 	Fct qui reset une partie de l'eeprom en 
.................... 	remettant les valeurs à 0xffff 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 9.2.2017 
.................... */ 
.................... void __resetEEPROM(void) 
*
0A89C:  MOV     W5,[W15++]
0A89E:  CLR     1B78
.................... { 
.................... 	unsigned int16 adresse = 0; 
.................... 	for(adresse = 0; adresse <= 820; adresse +=  2) 
0A8A0:  CLR     1B78
0A8A2:  MOV     1B78,W4
0A8A4:  MOV     #334,W3
0A8A6:  CP      W3,W4
0A8A8:  BRA     NC,A8C0
.................... 	{ 
.................... 		write_eeprom(adresse, 0xFFFF);//on écrase l'eeprom 
0A8AA:  MOV     #FFFF,W5
0A8AC:  MOV     1B78,W0
0A8AE:  MOV     #A,W1
0A8B0:  MOV     #2,W2
0A8B2:  CALL    A446
0A8B6:  MOV     1B78,W4
0A8B8:  ADD     W4,#2,W4
0A8BA:  MOV     W4,1B78
0A8BC:  GOTO    A8A2
.................... 	} 
0A8C0:  MOV     [--W15],W5
0A8C2:  RETURN  
.................... } 
.................... void __reset_roboteq(void) 
.................... { 
.................... 	fputc('%',ROBOTEQ); 
*
0A878:  MOV.B   #25,W0L
0A87A:  BTSC.B  219.1
0A87C:  BRA     A87A
0A87E:  MOV.B   W0L,21A
0A880:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"RESET 321654987 \r"); 
0A882:  MOV     #0,W1
0A884:  MOV     W1,W0
0A886:  CLR.B   1
0A888:  CALL    246
0A88C:  INC     W1,W1
0A88E:  BTSC.B  219.1
0A890:  BRA     A88E
0A892:  MOV     W0,21A
0A894:  MOV     #10,W0
0A896:  CPSGT   W1,W0
0A898:  BRA     A884
0A89A:  RETURN  
.................... } 
.................... /*======================================================================================= 
.................... 	Fct qui va recuperer les pid du roboteq et les mettre dans un tableau 
.................... =========================================================================================	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date : 16.2.2017 
.................... =========================================================================================	 
.................... 	! on doit faire passer 6x dans la fct. 
.................... 	On doit mettre une boucle exeterieur, car avec dans la fct, 
.................... 	on resete la dedans, et donc on ne peut pas recuperer des caractere 
.................... 	 
.................... 	Trame envoyer : Tab{2,0,:,10,...\r) 
.................... 					Tab{kp1 : ki1 : ...) 
.................... 	Les : separe les donnes, le \r annonce la fin du tableau 
.................... 	 
.................... 	!on peut pas chainer les commande, car il ecrase a chaque fois la reponse de l'ordre precdent 
.................... ==========================================================================================*/ 
.................... void __GetRoboteqPID(unsigned int8 valeur) 
*
0A480:  MOV     W5,[W15++]
0A482:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 i = 3; // car on recoit KP=110 -> on veut que la valeur --> on saute les 3 premiers caractere 
.................... 	static int8 y = 0; 
.................... 	 
.................... 	switch(valeur) // on demande au roboteq es valeur 
0A484:  MOV.B   1B78,W0L
0A486:  CLR.B   1
0A488:  XOR     #0,W0
0A48A:  BRA     Z,A4B2
0A48C:  XOR     #1,W0
0A48E:  BRA     Z,A4D4
0A490:  XOR     #3,W0
0A492:  BRA     Z,A4F6
0A494:  XOR     #1,W0
0A496:  BRA     Z,A518
0A498:  XOR     #7,W0
0A49A:  BRA     Z,A53A
0A49C:  XOR     #1,W0
0A49E:  BRA     Z,A55C
0A4A0:  XOR     #3,W0
0A4A2:  BRA     Z,A57E
0A4A4:  XOR     #1,W0
0A4A6:  BRA     Z,A5A4
0A4A8:  XOR     #F,W0
0A4AA:  BRA     Z,A5CA
0A4AC:  XOR     #1,W0
0A4AE:  BRA     Z,A5F0
0A4B0:  BRA     A616
.................... 	{ 
.................... 		case 0: 
.................... 			fprintf(ROBOTEQ,"~KP 1 \r");			 
0A4B2:  MOV     #0,W1
0A4B4:  MOV     W1,W0
0A4B6:  CLR.B   1
0A4B8:  CALL    264
0A4BC:  INC     W1,W1
0A4BE:  BTSC.B  219.1
0A4C0:  BRA     A4BE
0A4C2:  MOV     W0,21A
0A4C4:  MOV     #6,W0
0A4C6:  CPSGT   W1,W0
0A4C8:  BRA     A4B4
.................... 			delay_ms(10);			 
0A4CA:  MOV     #A,W0
0A4CC:  CALL    EBE
.................... 			break; 
0A4D0:  GOTO    A616
.................... 		case 1: 
.................... 			fprintf(ROBOTEQ,"~KI 1 \r"); 
0A4D4:  MOV     #0,W1
0A4D6:  MOV     W1,W0
0A4D8:  CLR.B   1
0A4DA:  CALL    278
0A4DE:  INC     W1,W1
0A4E0:  BTSC.B  219.1
0A4E2:  BRA     A4E0
0A4E4:  MOV     W0,21A
0A4E6:  MOV     #6,W0
0A4E8:  CPSGT   W1,W0
0A4EA:  BRA     A4D6
.................... 			delay_ms(10); 
0A4EC:  MOV     #A,W0
0A4EE:  CALL    EBE
.................... 			break; 
0A4F2:  GOTO    A616
.................... 		case 2: 
.................... 			fprintf(ROBOTEQ,"~KD 1 \r"); 
0A4F6:  MOV     #0,W1
0A4F8:  MOV     W1,W0
0A4FA:  CLR.B   1
0A4FC:  CALL    28C
0A500:  INC     W1,W1
0A502:  BTSC.B  219.1
0A504:  BRA     A502
0A506:  MOV     W0,21A
0A508:  MOV     #6,W0
0A50A:  CPSGT   W1,W0
0A50C:  BRA     A4F8
.................... 			delay_ms(10); 
0A50E:  MOV     #A,W0
0A510:  CALL    EBE
.................... 			break; 
0A514:  GOTO    A616
.................... 		case 3: 
.................... 			fprintf(ROBOTEQ,"~KP 2 \r"); 
0A518:  MOV     #0,W1
0A51A:  MOV     W1,W0
0A51C:  CLR.B   1
0A51E:  CALL    2A0
0A522:  INC     W1,W1
0A524:  BTSC.B  219.1
0A526:  BRA     A524
0A528:  MOV     W0,21A
0A52A:  MOV     #6,W0
0A52C:  CPSGT   W1,W0
0A52E:  BRA     A51A
.................... 			delay_ms(10); 
0A530:  MOV     #A,W0
0A532:  CALL    EBE
.................... 			break; 
0A536:  GOTO    A616
.................... 		case 4: 
.................... 			fprintf(ROBOTEQ,"~KI 2 \r"); 
0A53A:  MOV     #0,W1
0A53C:  MOV     W1,W0
0A53E:  CLR.B   1
0A540:  CALL    2B4
0A544:  INC     W1,W1
0A546:  BTSC.B  219.1
0A548:  BRA     A546
0A54A:  MOV     W0,21A
0A54C:  MOV     #6,W0
0A54E:  CPSGT   W1,W0
0A550:  BRA     A53C
.................... 			delay_ms(10); 
0A552:  MOV     #A,W0
0A554:  CALL    EBE
.................... 			break; 
0A558:  GOTO    A616
.................... 		case 5: 
.................... 			fprintf(ROBOTEQ,"~KD 2 \r"); 
0A55C:  MOV     #0,W1
0A55E:  MOV     W1,W0
0A560:  CLR.B   1
0A562:  CALL    2C8
0A566:  INC     W1,W1
0A568:  BTSC.B  219.1
0A56A:  BRA     A568
0A56C:  MOV     W0,21A
0A56E:  MOV     #6,W0
0A570:  CPSGT   W1,W0
0A572:  BRA     A55E
.................... 			delay_ms(10); 
0A574:  MOV     #A,W0
0A576:  CALL    EBE
.................... 			break;	 
0A57A:  GOTO    A616
.................... 		case 6: 
.................... 			fprintf(ROBOTEQ,"~MAC 1 \r"); 
0A57E:  MOV     #0,W1
0A580:  MOV     W1,W0
0A582:  CLR.B   1
0A584:  CALL    2DC
0A588:  INC     W1,W1
0A58A:  BTSC.B  219.1
0A58C:  BRA     A58A
0A58E:  MOV     W0,21A
0A590:  MOV     #7,W0
0A592:  CPSGT   W1,W0
0A594:  BRA     A580
.................... 			delay_ms(10); 
0A596:  MOV     #A,W0
0A598:  CALL    EBE
.................... 			i = 4; 
0A59C:  MOV.B   #4,W0L
0A59E:  MOV.B   W0L,15EE
.................... 			break;	 
0A5A0:  GOTO    A616
.................... 		case 7: 
.................... 			fprintf(ROBOTEQ,"~MDEC 1 \r"); 
0A5A4:  MOV     #0,W1
0A5A6:  MOV     W1,W0
0A5A8:  CLR.B   1
0A5AA:  CALL    2F2
0A5AE:  INC     W1,W1
0A5B0:  BTSC.B  219.1
0A5B2:  BRA     A5B0
0A5B4:  MOV     W0,21A
0A5B6:  MOV     #8,W0
0A5B8:  CPSGT   W1,W0
0A5BA:  BRA     A5A6
.................... 			delay_ms(10); 
0A5BC:  MOV     #A,W0
0A5BE:  CALL    EBE
.................... 			i = 5; 
0A5C2:  MOV.B   #5,W0L
0A5C4:  MOV.B   W0L,15EE
.................... 			break;	 
0A5C6:  GOTO    A616
.................... 		case 8: 
.................... 			fprintf(ROBOTEQ,"~MAC 2 \r"); 
0A5CA:  MOV     #0,W1
0A5CC:  MOV     W1,W0
0A5CE:  CLR.B   1
0A5D0:  CALL    308
0A5D4:  INC     W1,W1
0A5D6:  BTSC.B  219.1
0A5D8:  BRA     A5D6
0A5DA:  MOV     W0,21A
0A5DC:  MOV     #7,W0
0A5DE:  CPSGT   W1,W0
0A5E0:  BRA     A5CC
.................... 			delay_ms(10); 
0A5E2:  MOV     #A,W0
0A5E4:  CALL    EBE
.................... 			i = 4; 
0A5E8:  MOV.B   #4,W0L
0A5EA:  MOV.B   W0L,15EE
.................... 			break;	 
0A5EC:  GOTO    A616
.................... 		case 9: 
.................... 			fprintf(ROBOTEQ,"~MDEC 2 \r"); 
0A5F0:  MOV     #0,W1
0A5F2:  MOV     W1,W0
0A5F4:  CLR.B   1
0A5F6:  CALL    31E
0A5FA:  INC     W1,W1
0A5FC:  BTSC.B  219.1
0A5FE:  BRA     A5FC
0A600:  MOV     W0,21A
0A602:  MOV     #8,W0
0A604:  CPSGT   W1,W0
0A606:  BRA     A5F2
.................... 			delay_ms(10); 
0A608:  MOV     #A,W0
0A60A:  CALL    EBE
.................... 			i = 5; 
0A60E:  MOV.B   #5,W0L
0A610:  MOV.B   W0L,15EE
.................... 			break;	 
0A612:  GOTO    A616
.................... 	}	 
....................  
.................... 	if(RoboteQ_receiveBuffer[0] == 'K' || RoboteQ_receiveBuffer[0] == 'M') 
0A616:  MOV     882,W4
0A618:  XOR.B   #4B,W4L
0A61A:  BRA     Z,A622
0A61C:  MOV     882,W4
0A61E:  XOR.B   #4D,W4L
0A620:  BRA     NZ,A676
.................... 	{ 
.................... 		while(RoboteQ_receiveBuffer[i] != 0x0D) // On commence du [2] pour sauter le 'C='. Le +3 est pour le C,= et : (C=xxx:xxx). 
0A622:  MOV.B   15EE,W0L
0A624:  SE      W0,W0
0A626:  MOV     #882,W4
0A628:  ADD     W0,W4,W0
0A62A:  MOV.B   [W0],W5L
0A62C:  SE      W5,W5
0A62E:  CP      W5,#D
0A630:  BRA     Z,A64C
.................... 		{  
.................... 			TabSentRS232[y] = RoboteQ_receiveBuffer[i];				 
0A632:  MOV.B   15EF,W0L
0A634:  SE      W0,W0
0A636:  MOV     #982,W4
0A638:  ADD     W0,W4,W5
0A63A:  MOV.B   15EE,W0L
0A63C:  SE      W0,W0
0A63E:  MOV     #882,W4
0A640:  ADD     W0,W4,W0
0A642:  MOV.B   [W0],[W5]
.................... 			i++; 
0A644:  INC.B   15EE
.................... 			y++; 
0A646:  INC.B   15EF
0A648:  GOTO    A622
.................... 		} 
.................... 		if(valeur<9) 
0A64C:  MOV     1B78,W4
0A64E:  CP.B    W4L,#9
0A650:  BRA     C,A664
.................... 		{	 
.................... 			TabSentRS232[y] = ':';//seperation des valeur	 
0A652:  MOV.B   15EF,W0L
0A654:  SE      W0,W0
0A656:  MOV     #982,W4
0A658:  ADD     W0,W4,W5
0A65A:  MOV.B   #3A,W0L
0A65C:  MOV.B   W0L,[W5]
.................... 			y++; 
0A65E:  INC.B   15EF
.................... 		} 
0A660:  GOTO    A672
.................... 		else 
.................... 		{ 
.................... 			TabSentRS232[y] = '\r'; // fin de transmssion 
0A664:  MOV.B   15EF,W0L
0A666:  SE      W0,W0
0A668:  MOV     #982,W4
0A66A:  ADD     W0,W4,W5
0A66C:  MOV.B   #D,W0L
0A66E:  MOV.B   W0L,[W5]
.................... 			y = 0 ;	 
0A670:  CLR.B   15EF
.................... 		} 
.................... 		i = 3; 
0A672:  MOV.B   #3,W0L
0A674:  MOV.B   W0L,15EE
.................... 	}	 
0A676:  MOV     [--W15],W6
0A678:  MOV     [--W15],W5
0A67A:  RETURN  
....................  
.................... } 
.................... /* 
.................... 	Fct qui va changer les paramètre PID du roboteq. 
.................... 	Les parametre ont ete recu du pc et ont les save en 
.................... 	dans l'eeprom du roboteq 
.................... 	 
.................... 	Auteur : Borgeat Rémy 
.................... 	Date   : 16.2.2017 
.................... */ 
.................... void __SetRoboteqPID(unsigned int8 P1,I1,D1,P2,I2,D2,ac1,dc1,ac2,dc2) 
0A67C:  MOV     W5,[W15++]
.................... { 
.................... 	//envoi des paramètres PID au ROBOTEQ 
.................... 	fprintf(ROBOTEQ,"^KP 1 %u_^KI 1 %u_^KD 1 %u_^KP 2 %u_^KI 2 %u_^KD 2 %u \r",P1,I1,D1,P2,I2,D2); 
0A67E:  MOV     #0,W1
0A680:  MOV     W1,W0
0A682:  CLR.B   1
0A684:  CALL    334
0A688:  INC     W1,W1
0A68A:  BTSC.B  219.1
0A68C:  BRA     A68A
0A68E:  MOV     W0,21A
0A690:  MOV     #5,W0
0A692:  CPSGT   W1,W0
0A694:  BRA     A680
0A696:  MOV.B   1BA0,W0L
0A698:  CLR.B   1
0A69A:  MOV     #0,W4
0A69C:  CALL    725C
0A6A0:  MOV     #8,W1
0A6A2:  MOV     W1,W0
0A6A4:  CLR.B   1
0A6A6:  CALL    334
0A6AA:  INC     W1,W1
0A6AC:  BTSC.B  219.1
0A6AE:  BRA     A6AC
0A6B0:  MOV     W0,21A
0A6B2:  MOV     #E,W0
0A6B4:  CPSGT   W1,W0
0A6B6:  BRA     A6A2
0A6B8:  MOV.B   1BA1,W0L
0A6BA:  CLR.B   1
0A6BC:  MOV     #0,W4
0A6BE:  CALL    725C
0A6C2:  MOV     #11,W1
0A6C4:  MOV     W1,W0
0A6C6:  CLR.B   1
0A6C8:  CALL    334
0A6CC:  INC     W1,W1
0A6CE:  BTSC.B  219.1
0A6D0:  BRA     A6CE
0A6D2:  MOV     W0,21A
0A6D4:  MOV     #17,W0
0A6D6:  CPSGT   W1,W0
0A6D8:  BRA     A6C4
0A6DA:  MOV.B   1BA2,W0L
0A6DC:  CLR.B   1
0A6DE:  MOV     #0,W4
0A6E0:  CALL    725C
0A6E4:  MOV     #1A,W1
0A6E6:  MOV     W1,W0
0A6E8:  CLR.B   1
0A6EA:  CALL    334
0A6EE:  INC     W1,W1
0A6F0:  BTSC.B  219.1
0A6F2:  BRA     A6F0
0A6F4:  MOV     W0,21A
0A6F6:  MOV     #20,W0
0A6F8:  CPSGT   W1,W0
0A6FA:  BRA     A6E6
0A6FC:  MOV.B   1BA3,W0L
0A6FE:  CLR.B   1
0A700:  MOV     #0,W4
0A702:  CALL    725C
0A706:  MOV     #23,W1
0A708:  MOV     W1,W0
0A70A:  CLR.B   1
0A70C:  CALL    334
0A710:  INC     W1,W1
0A712:  BTSC.B  219.1
0A714:  BRA     A712
0A716:  MOV     W0,21A
0A718:  MOV     #29,W0
0A71A:  CPSGT   W1,W0
0A71C:  BRA     A708
0A71E:  MOV.B   1BA4,W0L
0A720:  CLR.B   1
0A722:  MOV     #0,W4
0A724:  CALL    725C
0A728:  MOV     #2C,W1
0A72A:  MOV     W1,W0
0A72C:  CLR.B   1
0A72E:  CALL    334
0A732:  INC     W1,W1
0A734:  BTSC.B  219.1
0A736:  BRA     A734
0A738:  MOV     W0,21A
0A73A:  MOV     #32,W0
0A73C:  CPSGT   W1,W0
0A73E:  BRA     A72A
0A740:  MOV.B   1BA5,W0L
0A742:  CLR.B   1
0A744:  MOV     #0,W4
0A746:  CALL    725C
0A74A:  BTSC.B  219.1
0A74C:  BRA     A74A
0A74E:  MOV     #20,W4
0A750:  MOV     W4,21A
0A752:  BTSC.B  219.1
0A754:  BRA     A752
0A756:  MOV     #D,W4
0A758:  MOV     W4,21A
.................... 	fprintf(ROBOTEQ,"^MAC 1 %u_^MDEC 1 %u_^MAC 2 %u_^MDEC 2 %u \r",ac1,dc1,ac2,dc2);// envoie au Roboteq 
0A75A:  MOV     #0,W1
0A75C:  MOV     W1,W0
0A75E:  CLR.B   1
0A760:  CALL    376
0A764:  INC     W1,W1
0A766:  BTSC.B  219.1
0A768:  BRA     A766
0A76A:  MOV     W0,21A
0A76C:  MOV     #6,W0
0A76E:  CPSGT   W1,W0
0A770:  BRA     A75C
0A772:  MOV.B   1BA6,W0L
0A774:  CLR.B   1
0A776:  MOV     #0,W4
0A778:  CALL    725C
0A77C:  MOV     #9,W1
0A77E:  MOV     W1,W0
0A780:  CLR.B   1
0A782:  CALL    376
0A786:  INC     W1,W1
0A788:  BTSC.B  219.1
0A78A:  BRA     A788
0A78C:  MOV     W0,21A
0A78E:  MOV     #11,W0
0A790:  CPSGT   W1,W0
0A792:  BRA     A77E
0A794:  MOV.B   1BA7,W0L
0A796:  CLR.B   1
0A798:  MOV     #0,W4
0A79A:  CALL    725C
0A79E:  MOV     #14,W1
0A7A0:  MOV     W1,W0
0A7A2:  CLR.B   1
0A7A4:  CALL    376
0A7A8:  INC     W1,W1
0A7AA:  BTSC.B  219.1
0A7AC:  BRA     A7AA
0A7AE:  MOV     W0,21A
0A7B0:  MOV     #1B,W0
0A7B2:  CPSGT   W1,W0
0A7B4:  BRA     A7A0
0A7B6:  MOV.B   1BA8,W0L
0A7B8:  CLR.B   1
0A7BA:  MOV     #0,W4
0A7BC:  CALL    725C
0A7C0:  MOV     #1E,W1
0A7C2:  MOV     W1,W0
0A7C4:  CLR.B   1
0A7C6:  CALL    376
0A7CA:  INC     W1,W1
0A7CC:  BTSC.B  219.1
0A7CE:  BRA     A7CC
0A7D0:  MOV     W0,21A
0A7D2:  MOV     #26,W0
0A7D4:  CPSGT   W1,W0
0A7D6:  BRA     A7C2
0A7D8:  MOV.B   1BA9,W0L
0A7DA:  CLR.B   1
0A7DC:  MOV     #0,W4
0A7DE:  CALL    725C
0A7E2:  BTSC.B  219.1
0A7E4:  BRA     A7E2
0A7E6:  MOV     #20,W4
0A7E8:  MOV     W4,21A
0A7EA:  BTSC.B  219.1
0A7EC:  BRA     A7EA
0A7EE:  MOV     #D,W4
0A7F0:  MOV     W4,21A
....................  
.................... 	write_eeprom(300,P1); 
0A7F2:  MOV.B   1BA0,W0L
0A7F4:  MOV.B   W0L,A
0A7F6:  CLR.B   B
0A7F8:  MOV     #12C,W0
0A7FA:  MOV     #A,W1
0A7FC:  MOV     #2,W2
0A7FE:  CALL    A446
.................... 	write_eeprom(302,I1); 
0A802:  MOV.B   1BA1,W0L
0A804:  MOV.B   W0L,W5L
0A806:  CLR.B   B
0A808:  MOV     #12E,W0
0A80A:  MOV     #A,W1
0A80C:  MOV     #2,W2
0A80E:  CALL    A446
.................... 	write_eeprom(304,D1); 
0A812:  MOV.B   1BA2,W0L
0A814:  MOV.B   W0L,A
0A816:  CLR.B   B
0A818:  MOV     #130,W0
0A81A:  MOV     #A,W1
0A81C:  MOV     #2,W2
0A81E:  CALL    A446
.................... 	write_eeprom(306,P2); 
0A822:  MOV.B   1BA3,W0L
0A824:  MOV.B   W0L,W5L
0A826:  CLR.B   B
0A828:  MOV     #132,W0
0A82A:  MOV     #A,W1
0A82C:  MOV     #2,W2
0A82E:  CALL    A446
.................... 	write_eeprom(308,I2); 
0A832:  MOV.B   1BA4,W0L
0A834:  MOV.B   W0L,A
0A836:  CLR.B   B
0A838:  MOV     #134,W0
0A83A:  MOV     #A,W1
0A83C:  MOV     #2,W2
0A83E:  CALL    A446
.................... 	write_eeprom(310,D2); 
0A842:  MOV.B   1BA5,W0L
0A844:  MOV.B   W0L,W5L
0A846:  CLR.B   B
0A848:  MOV     #136,W0
0A84A:  MOV     #A,W1
0A84C:  MOV     #2,W2
0A84E:  CALL    A446
.................... 	 
.................... 	//Sauvegarde en eeprom 
.................... 	fputc('%',ROBOTEQ);//pas le choix de faire un putc, car le % est un caractère réservé pour le pritnf 
0A852:  MOV.B   #25,W0L
0A854:  BTSC.B  219.1
0A856:  BRA     A854
0A858:  MOV.B   W0L,21A
0A85A:  CLR.B   21B
.................... 	fprintf(ROBOTEQ,"EESAV \r");//envoie du reste de la commande 
0A85C:  MOV     #0,W1
0A85E:  MOV     W1,W0
0A860:  CLR.B   1
0A862:  CALL    3B0
0A866:  INC     W1,W1
0A868:  BTSC.B  219.1
0A86A:  BRA     A868
0A86C:  MOV     W0,21A
0A86E:  MOV     #6,W0
0A870:  CPSGT   W1,W0
0A872:  BRA     A85E
0A874:  MOV     [--W15],W5
0A876:  RETURN  
....................  
.................... } 
....................  
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadObjectifs(void) 
*
01A74:  MOV     W5,[W15++]
01A76:  MOV     W6,[W15++]
01A78:  CLR     1B78
01A7A:  CLR     1B7A
01A7C:  CLR     1B7C
01A7E:  CLR     1B7E
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset; 
.................... 	unsigned int16 NumObj = 0; 
.................... 	unsigned int16 Obj = 0; 
....................  
.................... 	while(y==0) 
01A80:  CP0     1B7A
01A82:  BRA     NZ,1B0C
.................... 	{ 
.................... 		Obj = read_eeprom(offset);//on check si il reste des objectifs 
01A84:  MOV     15F0,W3
01A86:  MOV     #0,W4
01A88:  MOV     #2,W5
01A8A:  CALL    1A5C
01A8E:  MOV     W0,1B7E
.................... 		NumObj = read_eeprom(offset+2); 
01A90:  MOV     15F0,W4
01A92:  ADD     W4,#2,W4
01A94:  MOV     W4,W5
01A96:  MOV     W5,[W15++]
01A98:  MOV     W5,W3
01A9A:  MOV     #0,W4
01A9C:  MOV     #2,W5
01A9E:  CALL    1A5C
01AA2:  MOV     [--W15],W5
01AA4:  MOV     W0,1B7C
.................... 		if(Obj!=0xFFFF)//Si il en reste 
01AA6:  MOV     1B7E,W4
01AA8:  MOV     #FFFF,W3
01AAA:  CP      W3,W4
01AAC:  BRA     Z,1B04
.................... 		{ 
.................... 			for( i = 0 ; i < 24; i += 2) 
01AAE:  CLR     1B78
01AB0:  MOV     1B78,W4
01AB2:  CP      W4,#18
01AB4:  BRA     C,1AF6
.................... 			{			 
.................... 				TabObjectifs[Obj][NumObj][(i/2)] = read_eeprom(i+4+offset);//remplir le tableau avec les objectifs 
01AB6:  MOV     1B7E,W4
01AB8:  MOV     #138,W3
01ABA:  MUL.UU  W4,W3,W0
01ABC:  MOV     W0,W5
01ABE:  MOV     1B7C,W4
01AC0:  MUL.UU  W4,#18,W0
01AC2:  ADD     W0,W5,W5
01AC4:  MOV     1B78,W6
01AC6:  LSR     W6,#1,W6
01AC8:  SL      W6,#1,W0
01ACA:  ADD     W0,W5,W0
01ACC:  MOV     #C10,W4
01ACE:  ADD     W0,W4,W5
01AD0:  MOV     1B78,W4
01AD2:  ADD     W4,#4,W4
01AD4:  MOV     W4,W6
01AD6:  MOV     W6,W0
01AD8:  ADD     15F0,W0
01ADA:  MOV     W0,W6
01ADC:  MOV     W5,[W15++]
01ADE:  MOV     W6,W3
01AE0:  MOV     #0,W4
01AE2:  MOV     #2,W5
01AE4:  CALL    1A5C
01AE8:  MOV     [--W15],W5
01AEA:  MOV     W0,[W5]
01AEC:  MOV     1B78,W4
01AEE:  ADD     W4,#2,W4
01AF0:  MOV     W4,1B78
01AF2:  GOTO    1AB0
.................... 			}	 
.................... 			offset += 28;// offset de +24,afin de lire les objectifs suivant	 
01AF6:  MOV     15F0,W4
01AF8:  ADD     W4,#1C,W4
01AFA:  MOV     W4,15F0
.................... 			NbreObjectifs=Obj;	 
01AFC:  PUSH    1B7E
01AFE:  POP     14BA
.................... 		} 
01B00:  GOTO    1B08
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
01B04:  MOV     #1,W4
01B06:  MOV     W4,1B7A
.................... 		} 
01B08:  GOTO    1A80
.................... 	} 
01B0C:  MOV     [--W15],W6
01B0E:  MOV     [--W15],W5
01B10:  RETURN  
....................  
.................... } 
.................... // Récupère tous les objectifs et les stock en eeprom 
.................... void __ReadZones_Interdites(void) 
01B12:  MOV     W5,[W15++]
01B14:  MOV     W6,[W15++]
01B16:  MOV     W7,[W15++]
01B18:  CLR     1B78
01B1A:  CLR     1B7A
01B1C:  CLR     1B7C
.................... { 
.................... 	// Lit les objectifs stockés en EEPROM 
.................... 	// Les éléments d'objectifs sont stockés chaque deux dans l'EEPROM 
.................... 	unsigned int16 i = 0; 
.................... 	unsigned int16 y = 0; 
.................... 	static int16 offset = 200; 
.................... 	unsigned int16 NumZone = 0; 
....................  
.................... 	while(y==0) 
01B1E:  CP0     1B7A
01B20:  BRA     NZ,1D60
.................... 	{ 
.................... 		NumZone = read_eeprom(offset);//on check si il reste des objectifs 
01B22:  MOV     15F2,W3
01B24:  MOV     #0,W4
01B26:  MOV     #2,W5
01B28:  CALL    1A5C
01B2C:  MOV     W0,1B7C
.................... 		if(NumZone!=0xFFFF)//Si il en reste 
01B2E:  MOV     1B7C,W4
01B30:  MOV     #FFFF,W3
01B32:  CP      W3,W4
01B34:  BRA     Z,1D58
.................... 		{ 
.................... 			for( i = 0 ; i < 16; i += 2) 
01B36:  CLR     1B78
01B38:  MOV     1B78,W4
01B3A:  CP      W4,#10
01B3C:  BRA     C,1B7C
.................... 			{ 
.................... 				TabZonesPC[NumZone][(i/2)] = read_eeprom(i+2+offset);//remplir le tableau avec les objectifs 
01B3E:  MOV     1B7C,W5
01B40:  SL      W5,#5,W5
01B42:  MOV     1B78,W6
01B44:  LSR     W6,#1,W6
01B46:  SL      W6,#2,W0
01B48:  ADD     W0,W5,W0
01B4A:  MOV     #BE6,W4
01B4C:  ADD     W0,W4,W5
01B4E:  MOV     1B78,W4
01B50:  ADD     W4,#2,W4
01B52:  MOV     W4,W6
01B54:  MOV     W6,W0
01B56:  ADD     15F2,W0
01B58:  MOV     W0,W6
01B5A:  MOV     W5,[W15++]
01B5C:  MOV     W6,W3
01B5E:  MOV     #0,W4
01B60:  MOV     #2,W5
01B62:  CALL    1A5C
01B66:  MOV     [--W15],W5
01B68:  MOV     W0,[W5]
01B6A:  MOV.B   #0,W0L
01B6C:  MOV.B   W0L,[W5+#2]
01B6E:  MOV.B   #0,W0L
01B70:  MOV.B   W0L,[W5+#3]
01B72:  MOV     1B78,W4
01B74:  ADD     W4,#2,W4
01B76:  MOV     W4,1B78
01B78:  GOTO    1B38
.................... 			}	 
....................  
.................... 			TabZones[NumZone-1][0] = TabZonesPC[NumZone][0]; 
01B7C:  MOV     1B7C,W4
01B7E:  SUB     W4,#1,W5
01B80:  SL      W5,#4,W5
01B82:  MOV     #B46,W4
01B84:  ADD     W5,W4,W6
01B86:  MOV     1B7C,W7
01B88:  SL      W7,#5,W7
01B8A:  MOV     #BE6,W4
01B8C:  ADD     W7,W4,W0
01B8E:  MOV     [W0++],[W6++]
01B90:  MOV     [W0++],[W6++]
.................... 			TabZones[NumZone-1][1] = TabZonesPC[NumZone][1]; 
01B92:  MOV     1B7C,W4
01B94:  SUB     W4,#1,W5
01B96:  SL      W5,#4,W5
01B98:  ADD     W5,#4,W5
01B9A:  MOV     W5,W0
01B9C:  MOV     #B46,W4
01B9E:  ADD     W0,W4,W5
01BA0:  MOV     1B7C,W6
01BA2:  SL      W6,#5,W6
01BA4:  ADD     W6,#4,W6
01BA6:  MOV     W6,W0
01BA8:  MOV     #BE6,W4
01BAA:  ADD     W0,W4,W0
01BAC:  MOV     [W0++],[W5++]
01BAE:  MOV     [W0++],[W5++]
.................... 			TabZones[NumZone-1][2] = TabZonesPC[NumZone][4]; 
01BB0:  MOV     1B7C,W4
01BB2:  SUB     W4,#1,W5
01BB4:  SL      W5,#4,W5
01BB6:  ADD     W5,#8,W5
01BB8:  MOV     W5,W0
01BBA:  MOV     #B46,W4
01BBC:  ADD     W0,W4,W5
01BBE:  MOV     1B7C,W6
01BC0:  SL      W6,#5,W6
01BC2:  ADD     W6,#10,W6
01BC4:  MOV     W6,W0
01BC6:  MOV     #BE6,W4
01BC8:  ADD     W0,W4,W0
01BCA:  MOV     [W0++],[W5++]
01BCC:  MOV     [W0++],[W5++]
.................... 			TabZones[NumZone-1][3] = TabZonesPC[NumZone][5]; 
01BCE:  MOV     1B7C,W4
01BD0:  SUB     W4,#1,W5
01BD2:  SL      W5,#4,W5
01BD4:  ADD     W5,#C,W5
01BD6:  MOV     W5,W0
01BD8:  MOV     #B46,W4
01BDA:  ADD     W0,W4,W5
01BDC:  MOV     1B7C,W6
01BDE:  SL      W6,#5,W6
01BE0:  ADD     W6,#14,W6
01BE2:  MOV     W6,W0
01BE4:  MOV     #BE6,W4
01BE6:  ADD     W0,W4,W0
01BE8:  MOV     [W0++],[W5++]
01BEA:  MOV     [W0++],[W5++]
.................... 			 
.................... 			if(TabZones[NumZone-1][0] < MARGE)TabZones[NumZone-1][0] = 0; else TabZones[NumZone-1][0] -= (MARGE/2);	 
01BEC:  MOV     1B7C,W4
01BEE:  SUB     W4,#1,W5
01BF0:  SL      W5,#4,W5
01BF2:  MOV     #B46,W4
01BF4:  ADD     W5,W4,W0
01BF6:  MOV     #C,W4
01BF8:  MOV     [W0++],[W4++]
01BFA:  MOV     [W0++],[W4++]
01BFC:  CP      W7,#0
01BFE:  BRA     GT,1C24
01C00:  BRA     LT,1C08
01C02:  MOV     #168,W4
01C04:  CP      W4,W6
01C06:  BRA     LEU,1C24
01C08:  MOV     1B7C,W4
01C0A:  SUB     W4,#1,W5
01C0C:  SL      W5,#4,W5
01C0E:  MOV     #B46,W4
01C10:  ADD     W5,W4,W6
01C12:  CLR.B   [W6]
01C14:  MOV.B   #0,W0L
01C16:  MOV.B   W0L,[W6+#1]
01C18:  MOV.B   #0,W0L
01C1A:  MOV.B   W0L,[W6+#2]
01C1C:  MOV.B   #0,W0L
01C1E:  MOV.B   W0L,[W6+#3]
01C20:  GOTO    1C3A
01C24:  MOV     1B7C,W4
01C26:  SUB     W4,#1,W5
01C28:  SL      W5,#4,W5
01C2A:  MOV     #B46,W4
01C2C:  ADD     W5,W4,W6
01C2E:  MOV     [W6],W4
01C30:  SUB     #B4,W4
01C32:  MOV     W4,[W6]
01C34:  MOV     [++W6],W4
01C36:  SUBB    W4,#0,W0
01C38:  MOV     W0,[W6+#0]
.................... 			if(TabZones[NumZone-1][1] < MARGE)TabZones[NumZone-1][1] = 0; else TabZones[NumZone-1][1] -= (MARGE/2);	 
01C3A:  MOV     1B7C,W4
01C3C:  SUB     W4,#1,W5
01C3E:  SL      W5,#4,W5
01C40:  ADD     W5,#4,W5
01C42:  MOV     W5,W0
01C44:  MOV     #B46,W4
01C46:  ADD     W0,W4,W0
01C48:  MOV     #A,W4
01C4A:  MOV     [W0++],[W4++]
01C4C:  MOV     [W0++],[W4++]
01C4E:  CP      W6,#0
01C50:  BRA     GT,1C7A
01C52:  BRA     LT,1C5A
01C54:  MOV     #168,W4
01C56:  CP      W4,W5
01C58:  BRA     LEU,1C7A
01C5A:  MOV     1B7C,W4
01C5C:  SUB     W4,#1,W5
01C5E:  SL      W5,#4,W5
01C60:  ADD     W5,#4,W5
01C62:  MOV     W5,W0
01C64:  MOV     #B46,W4
01C66:  ADD     W0,W4,W5
01C68:  CLR.B   [W5]
01C6A:  MOV.B   #0,W0L
01C6C:  MOV.B   W0L,[W5+#1]
01C6E:  MOV.B   #0,W0L
01C70:  MOV.B   W0L,[W5+#2]
01C72:  MOV.B   #0,W0L
01C74:  MOV.B   W0L,[W5+#3]
01C76:  GOTO    1C94
01C7A:  MOV     1B7C,W4
01C7C:  SUB     W4,#1,W5
01C7E:  SL      W5,#4,W5
01C80:  ADD     W5,#4,W5
01C82:  MOV     W5,W0
01C84:  MOV     #B46,W4
01C86:  ADD     W0,W4,W5
01C88:  MOV     [W5],W4
01C8A:  SUB     #B4,W4
01C8C:  MOV     W4,[W5]
01C8E:  MOV     [++W5],W4
01C90:  SUBB    W4,#0,W0
01C92:  MOV     W0,[W5+#0]
.................... 			if(TabZones[NumZone-1][2] > (SIZE_TABLE_X-MARGE))TabZones[NumZone-1][2] = 3000; else TabZones[NumZone-1][2] += (MARGE/2);	 
01C94:  MOV     1B7C,W4
01C96:  SUB     W4,#1,W5
01C98:  SL      W5,#4,W5
01C9A:  ADD     W5,#8,W5
01C9C:  MOV     W5,W0
01C9E:  MOV     #B46,W4
01CA0:  ADD     W0,W4,W0
01CA2:  MOV     #A,W4
01CA4:  MOV     [W0++],[W4++]
01CA6:  MOV     [W0++],[W4++]
01CA8:  CP      W6,#0
01CAA:  BRA     LT,1CD6
01CAC:  BRA     GT,1CB4
01CAE:  MOV     #A50,W4
01CB0:  CP      W4,W5
01CB2:  BRA     C,1CD6
01CB4:  MOV     1B7C,W4
01CB6:  SUB     W4,#1,W5
01CB8:  SL      W5,#4,W5
01CBA:  ADD     W5,#8,W5
01CBC:  MOV     W5,W0
01CBE:  MOV     #B46,W4
01CC0:  ADD     W0,W4,W5
01CC2:  MOV.B   #B8,W0L
01CC4:  MOV.B   W0L,[W5]
01CC6:  MOV.B   #B,W0L
01CC8:  MOV.B   W0L,[W5+#1]
01CCA:  MOV.B   #0,W0L
01CCC:  MOV.B   W0L,[W5+#2]
01CCE:  MOV.B   #0,W0L
01CD0:  MOV.B   W0L,[W5+#3]
01CD2:  GOTO    1CF0
01CD6:  MOV     1B7C,W4
01CD8:  SUB     W4,#1,W5
01CDA:  SL      W5,#4,W5
01CDC:  ADD     W5,#8,W5
01CDE:  MOV     W5,W0
01CE0:  MOV     #B46,W4
01CE2:  ADD     W0,W4,W5
01CE4:  MOV     [W5],W4
01CE6:  ADD     #B4,W4
01CE8:  MOV     W4,[W5]
01CEA:  MOV     [++W5],W4
01CEC:  ADDC    W4,#0,W4
01CEE:  MOV     W4,[W5]
.................... 			if(TabZones[NumZone-1][3] > (SIZE_TABLE_Y-MARGE))TabZones[NumZone-1][3] = 2000; else TabZones[NumZone-1][3] += (MARGE/2); 
01CF0:  MOV     1B7C,W4
01CF2:  SUB     W4,#1,W5
01CF4:  SL      W5,#4,W5
01CF6:  ADD     W5,#C,W5
01CF8:  MOV     W5,W0
01CFA:  MOV     #B46,W4
01CFC:  ADD     W0,W4,W0
01CFE:  MOV     #A,W4
01D00:  MOV     [W0++],[W4++]
01D02:  MOV     [W0++],[W4++]
01D04:  CP      W6,#0
01D06:  BRA     LT,1D32
01D08:  BRA     GT,1D10
01D0A:  MOV     #668,W4
01D0C:  CP      W4,W5
01D0E:  BRA     C,1D32
01D10:  MOV     1B7C,W4
01D12:  SUB     W4,#1,W5
01D14:  SL      W5,#4,W5
01D16:  ADD     W5,#C,W5
01D18:  MOV     W5,W0
01D1A:  MOV     #B46,W4
01D1C:  ADD     W0,W4,W5
01D1E:  MOV.B   #D0,W0L
01D20:  MOV.B   W0L,[W5]
01D22:  MOV.B   #7,W0L
01D24:  MOV.B   W0L,[W5+#1]
01D26:  MOV.B   #0,W0L
01D28:  MOV.B   W0L,[W5+#2]
01D2A:  MOV.B   #0,W0L
01D2C:  MOV.B   W0L,[W5+#3]
01D2E:  GOTO    1D4C
01D32:  MOV     1B7C,W4
01D34:  SUB     W4,#1,W5
01D36:  SL      W5,#4,W5
01D38:  ADD     W5,#C,W5
01D3A:  MOV     W5,W0
01D3C:  MOV     #B46,W4
01D3E:  ADD     W0,W4,W5
01D40:  MOV     [W5],W4
01D42:  ADD     #B4,W4
01D44:  MOV     W4,[W5]
01D46:  MOV     [++W5],W4
01D48:  ADDC    W4,#0,W4
01D4A:  MOV     W4,[W5]
.................... 			 
.................... 			offset += 18;// offset de +24,afin de lire les objectifs suivant	 
01D4C:  MOV     15F2,W4
01D4E:  ADD     W4,#12,W4
01D50:  MOV     W4,15F2
.................... 			NbreZone_check++; 
01D52:  INC.B   0880
.................... 		} 
01D54:  GOTO    1D5C
.................... 		else//si il n'y a plus d'objectis 
.................... 		{ 
.................... 			y=1;//on sort de la boucle 
01D58:  MOV     #1,W4
01D5A:  MOV     W4,1B7A
.................... 		} 
01D5C:  GOTO    1B1E
.................... 			 
.................... 	} 
01D60:  MOV     [--W15],W7
01D62:  MOV     [--W15],W6
01D64:  MOV     [--W15],W5
01D66:  RETURN  
.................... //	NbreZone = read_eeprom(512);	 
.................... } 
....................  
.................... // Actions à effectuer 
.................... void __Action_Writting(unsigned int8 ActionToDo) 
.................... { 
.................... //	unsigned int8 StateDriver = 0; 
.................... 	switch(ActionToDo) 
*
09F04:  MOV.B   1B54,W0L
09F06:  CLR.B   1
09F08:  XOR     #0,W0
09F0A:  BRA     Z,9F2E
09F0C:  XOR     #1,W0
09F0E:  BRA     Z,9F34
09F10:  XOR     #3,W0
09F12:  BRA     Z,9F3E
09F14:  XOR     #1,W0
09F16:  BRA     Z,9F4A
09F18:  XOR     #7,W0
09F1A:  BRA     Z,9F56
09F1C:  XOR     #1,W0
09F1E:  BRA     Z,9F62
09F20:  XOR     #2,W0
09F22:  BRA     Z,9F6A
09F24:  XOR     #F,W0
09F26:  BRA     Z,9F72
09F28:  XOR     #1,W0
09F2A:  BRA     Z,9F7A
09F2C:  BRA     9F82
.................... 	{ 
.................... 		// Ne fait rien 
.................... 		case 0 : 
.................... 			Action_send=1; 
09F2E:  BSET.B  85B.7
.................... 			break;		 
09F30:  GOTO    9F8E
.................... 		case 1 : 
.................... 			Ramassage(0); 
09F34:  CLR.B   1B56
09F36:  CALL    92D8
.................... 			break;	 
09F3A:  GOTO    9F8E
.................... 		case 2 :  
.................... 			Ramassage(1); 
09F3E:  MOV.B   #1,W0L
09F40:  MOV.B   W0L,1B56
09F42:  CALL    92D8
.................... 			break; 
09F46:  GOTO    9F8E
.................... 		case 3 :  
.................... 			Ramassage(2); 
09F4A:  MOV.B   #2,W0L
09F4C:  MOV.B   W0L,1B56
09F4E:  CALL    92D8
.................... 			break; 
09F52:  GOTO    9F8E
.................... 		case 4 :  
.................... 			Ramassage(3); 
09F56:  MOV.B   #3,W0L
09F58:  MOV.B   W0L,1B56
09F5A:  CALL    92D8
.................... 			break; 
09F5E:  GOTO    9F8E
.................... 		case 5 :  
.................... 			Empilage(); 
09F62:  CALL    968A
.................... 			break; 
09F66:  GOTO    9F8E
.................... 		case 7 : 
.................... 			Panneau_Domotique(); 
09F6A:  CALL    9EB6
.................... 			break; 
09F6E:  GOTO    9F8E
.................... 		case 8 :  
.................... 			GoToZero_Cremaillere(); 
09F72:  CALL    1824
.................... 			break; 
09F76:  GOTO    9F8E
.................... 		case 9 :  
.................... 			reinitialisation(); 
09F7A:  CALL    9EDA
.................... 			break; 
09F7E:  GOTO    9F8E
.................... 		default : 
.................... 			__Affichage_erreur(5); 
09F82:  MOV.B   #5,W0L
09F84:  MOV.B   W0L,1B5C
09F86:  CALL    102A
.................... 			break; 
09F8A:  GOTO    9F8E
.................... 	} 
09F8E:  RETURN  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour afficher le code de la carte afficheur 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 Affichage_Score(unsigned int8 adresse_driver, unsigned int8 Total) 
.................... { 
.................... 	i2c_start(); 
.................... 	if(i2c_write(adresse_driver) == 0)			//ADRESSE 
.................... 	{ 
.................... 		i2c_write(Total); 
.................... 	} 
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
.................... 		return 0; 
.................... 	} 
.................... 	i2c_stop();	 
.................... 	return 1; 
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour enclencher ou déclencher les pompes 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 driver_Pompes(unsigned int8 adresse_driver, unsigned int8 pompe_A, unsigned int8 pompe_B, unsigned int8 pompe_C, unsigned int8 pompe_D, unsigned int8 pompe_E) 
*
0107C:  MOV     W5,[W15++]
.................... { 
.................... 	delay_ms(2000); 
0107E:  MOV     #7D0,W0
01080:  CALL    EBE
.................... 	unsigned int8 ordre = 0; 
01084:  CLR.B   1B66
.................... 	ordre = pompe_A*16 + pompe_B*8 + pompe_C*4 + pompe_D*2 + pompe_E; 
01086:  MOV.B   1B61,W0L
01088:  CLR.B   1
0108A:  SL      W0,#4,W5
0108C:  MOV.B   1B62,W0L
0108E:  CLR.B   1
01090:  SL      W0,#3,W0
01092:  ADD     W0,W5,W5
01094:  MOV.B   1B63,W0L
01096:  CLR.B   1
01098:  SL      W0,#2,W0
0109A:  ADD     W0,W5,W5
0109C:  MOV.B   1B64,W0L
0109E:  CLR.B   1
010A0:  SL      W0,#1,W0
010A2:  ADD     W0,W5,W5
010A4:  MOV     W5,W0
010A6:  ADD.B   1B65,W0L
010A8:  MOV.B   W0L,1B66
....................  
.................... 	i2c_start(); 
010AA:  BTSS.B  208.3
010AC:  BRA     10B6
010AE:  BSET.B  206.1
010B0:  BTSC.B  206.1
010B2:  BRA     10B0
010B4:  BRA     10BC
010B6:  BSET.B  206.0
010B8:  BTSC.B  206.0
010BA:  BRA     10B8
.................... 	if(i2c_write(adresse_driver) == 0)			//ADRESSE 
010BC:  MOV.B   1B60,W0L
010BE:  MOV.B   W0L,2
010C0:  CALL    E12
010C4:  CP0.B   W0L
010C6:  BRA     NZ,10D4
.................... 	{ 
.................... 		i2c_write(ordre); 
010C8:  MOV.B   1B66,W0L
010CA:  MOV.B   W0L,2
010CC:  CALL    E12
.................... 	} 
010D0:  GOTO    10E4
.................... 	else 
.................... 	{  
.................... 		i2c_stop(); 
010D4:  MOV     #1F,W0
010D6:  AND     206,W0
010D8:  BRA     NZ,10D4
010DA:  BSET.B  206.2
010DC:  BTSC.B  206.2
010DE:  BRA     10DC
.................... 		return 0; 
010E0:  CLR.B   0
010E2:  BRA     10FA
.................... 	} 
.................... 	i2c_stop();	 
010E4:  MOV     #1F,W0
010E6:  AND     206,W0
010E8:  BRA     NZ,10E4
010EA:  BSET.B  206.2
010EC:  BTSC.B  206.2
010EE:  BRA     10EC
.................... 	delay_ms(2000); 
010F0:  MOV     #7D0,W0
010F2:  CALL    EBE
.................... 	return 1; 
010F6:  MOV.B   #1,W0L
010F8:  MOV.B   W0L,0
010FA:  MOV     [--W15],W5
010FC:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour lire l'état des pompes 
.................... //============================================================================================================================ 
....................  
.................... unsigned int8 read_driver_pompes(int8 adresse_driver) 
*
09284:  MOV     W5,[W15++]
09286:  CLR.B   1B5A
.................... { 
.................... 	int8 driver_etat; 
.................... 	int8 ack=0; 
....................  
.................... 	i2c_start(); 
09288:  BTSS.B  208.3
0928A:  BRA     9294
0928C:  BSET.B  206.1
0928E:  BTSC.B  206.1
09290:  BRA     928E
09292:  BRA     929A
09294:  BSET.B  206.0
09296:  BTSC.B  206.0
09298:  BRA     9296
.................... 	ack = i2c_write(adresse_driver+1); 
0929A:  MOV.B   1B58,W0L
0929C:  SE      W0,W0
0929E:  ADD     W0,#1,W0
092A0:  MOV     W0,W5
092A2:  MOV.B   W5L,W1L
092A4:  CALL    E12
092A8:  MOV.B   W0L,1B5A
.................... 	if(ack == 0) 
092AA:  MOV.B   1B5A,W0L
092AC:  SE      W0,W0
092AE:  CP0     W0
092B0:  BRA     NZ,92C2
.................... 	{ 
.................... 		driver_etat=i2c_read(0); 
092B2:  MOV     #0,W1
092B4:  MOV     W1,[W15++]
092B6:  MOV     [--W15],W1
092B8:  CALL    12B8
092BC:  MOV.B   W0L,1B59
.................... 	} 
092BE:  GOTO    92C6
.................... 	else driver_etat = 0b1000000; 
092C2:  MOV.B   #40,W0L
092C4:  MOV.B   W0L,1B59
....................  
.................... 	i2c_stop(); 
092C6:  MOV     #1F,W0
092C8:  AND     206,W0
092CA:  BRA     NZ,92C6
092CC:  BSET.B  206.2
092CE:  BTSC.B  206.2
092D0:  BRA     92CE
.................... 	return driver_etat; 
092D2:  MOV.B   1B59,W0L
092D4:  MOV     [--W15],W5
092D6:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour allumer le panneau domotique 
.................... //============================================================================================================================ 
....................  
.................... int1 Panneau_Domotique(void) 
.................... { 
.................... 	 
.................... 	static int8 etat; 
.................... 	 
.................... 	if(etat == 0) 
*
09EB6:  MOV.B   15F4,W0L
09EB8:  SE      W0,W0
09EBA:  CP0     W0
09EBC:  BRA     NZ,9ECE
.................... 	{ 
.................... 		_Out1 = 1; 
09EBE:  BSET.B  2D6.0
.................... 		_LED3 = 1; 
09EC0:  BSET.B  2D0.3
.................... 		Action_send = 1; 
09EC2:  BSET.B  85B.7
.................... 		Check = 0; 
09EC4:  BCLR.B  85B.4
.................... 		etat = 1; 
09EC6:  MOV.B   #1,W0L
09EC8:  MOV.B   W0L,15F4
.................... 	} 
09ECA:  GOTO    9ED8
.................... 	else 
.................... 	{ 
.................... 		if(_Dig4) 
09ECE:  BTSS.B  2C2.6
09ED0:  BRA     9ED8
.................... 		{ 
.................... 			_LED3 = 0; 
09ED2:  BCLR.B  2D0.3
.................... 			Check = 1; 
09ED4:  BSET.B  85B.4
.................... 			_Out1 = 0; 
09ED6:  BCLR.B  2D6.0
.................... 		} 
.................... 	}		 
09ED8:  RETURN  
.................... 	 
.................... 	/* 
.................... 	static int8 action; 
.................... 	static int8 etat; 
.................... 	static int8 etat_cremaillere; 
....................  
.................... 	switch(action) 
.................... 	{ 
.................... 		case 0 : 
....................  
.................... 				if(Etat!=1)  
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,25500); 
.................... 					return(0); 
.................... 				} 
.................... 				else  
.................... 				{ 
.................... 					driver_Pompes(0xA0,0,0,0,0,0);	 
.................... 					Etat = 0 ; 
.................... 					action = 1; 
.................... 					return(1); 
.................... 				}			 
....................  
.................... 		break; 
....................  
.................... 		case 1 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
....................  
.................... 			if(etat_cremaillere==1) 
.................... 			{ 
.................... 				fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",50,50); 
.................... 				fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-25000,-25000); 
....................  
.................... 				action = 2; 
.................... 			} 
....................  
.................... 		break; 
....................  
.................... 		case 2 : 
.................... 		*/ 
.................... 		/* 
.................... 			delay_ms(5000); 
.................... 			//__Check_commande_atteint();  
....................             if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
....................             {	 
.................... 				fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",50,50); 
.................... 				fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",25000,25000); 
....................  
.................... 				action = 3; 
.................... 				points = points + 25; 
....................             } 
....................           */ 
....................           /* 
....................            
....................           if(_Capdist==0) 
....................           { 
.................... 	          fprintf(ROBOTEQ,"!MS 1_!MS 2\r");                    
.................... 	          fprintf(ROBOTEQ,"^mmod 1 0_^mmod 2 0\r"); 
.................... 	          fprintf(ROBOTEQ,"^mmod 1 3_^mmod 2 3\r");  
.................... 	           
.................... 	          action = 3;    
.................... 	      }   
....................  
....................         break; 
....................  
.................... 		case 3 : 
.................... 			 
.................... 			//delay_ms(5000); 
.................... 			//__Check_commande_atteint(); 
....................             if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
....................             { 
....................             	Action_send = 1; 
....................             	Check=1; 
.................... 			   	action = 0; 
.................... 				etat = 0; 
.................... 				etat_cremaillere = 0;   
.................... 			} 
....................  
.................... 		break;       				 
.................... 	} 
.................... 	*/ 
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction qui permet de ramasser les cubes (doit fournir un paramètre pour savoir de quelle côté de la croix on arrive) 
.................... //============================================================================================================================ 
....................  
.................... int1 Ramassage(unsigned int8 cote) 
*
092D8:  MOV     W5,[W15++]
092DA:  MOV     W6,[W15++]
.................... { 
.................... 	static int8 action; 
.................... 	static int8 Etat; 
.................... 	static int8 etat_cremaillere; 
.................... 	static int8 etat_couronne; 
.................... 	static signed int32 impulse_couronne; 
.................... 	static int1 sens; 
....................  
.................... 	static int8 etat_pompes; 
.................... 	static int8 i; 
....................  
.................... 	switch(action) 
092DC:  MOV.B   15F5,W0L
092DE:  CLR.B   1
092E0:  XOR     #0,W0
092E2:  BRA     Z,9306
092E4:  XOR     #1,W0
092E6:  BRA     Z,935E
092E8:  XOR     #3,W0
092EA:  BRA     Z,939E
092EC:  XOR     #1,W0
092EE:  BRA     Z,93EE
092F0:  XOR     #7,W0
092F2:  BRA     Z,9444
092F4:  XOR     #1,W0
092F6:  BRA     Z,9486
092F8:  XOR     #1B,W0
092FA:  BRA     Z,94DA
092FC:  XOR     #18,W0
092FE:  BRA     Z,9526
09300:  XOR     #1,W0
09302:  BRA     Z,956A
09304:  BRA     958E
.................... 	{ 
.................... 		case 0 : 
....................  
.................... 			switch(cote) 
09306:  MOV.B   1B56,W0L
09308:  CLR.B   1
0930A:  XOR     #0,W0
0930C:  BRA     Z,931C
0930E:  XOR     #1,W0
09310:  BRA     Z,932A
09312:  XOR     #3,W0
09314:  BRA     Z,933A
09316:  XOR     #1,W0
09318:  BRA     Z,934A
0931A:  BRA     935A
.................... 			{ 
.................... 				case 0 : 
....................  
.................... 					impulse_couronne = 0; 
0931C:  CLR     15FA
0931E:  CLR     15FC
.................... 					sens = 1; 
09320:  BSET.B  14B7.6
.................... 					action = 2; 
09322:  MOV.B   #2,W0L
09324:  MOV.B   W0L,15F5
....................  
.................... 				break; 
09326:  GOTO    935A
....................  
.................... 				case 1 : 
....................  
.................... 					impulse_couronne = 16192; 
0932A:  MOV     #3F40,W4
0932C:  MOV     W4,15FA
0932E:  CLR     15FC
.................... 					sens = 0; 
09330:  BCLR.B  14B7.6
.................... 					action = 1; 
09332:  MOV.B   #1,W0L
09334:  MOV.B   W0L,15F5
....................  
.................... 				break; 
09336:  GOTO    935A
....................  
.................... 				case 2 : 
....................  
.................... 					impulse_couronne = -32384; 
0933A:  MOV     #8180,W4
0933C:  MOV     W4,15FA
0933E:  SETM    15FC
.................... 					sens = 1; 
09340:  BSET.B  14B7.6
.................... 					action = 1; 
09342:  MOV.B   #1,W0L
09344:  MOV.B   W0L,15F5
....................  
.................... 				break; 
09346:  GOTO    935A
....................  
.................... 				case 3 : 
....................  
.................... 					impulse_couronne = -16192; 
0934A:  MOV     #C0C0,W4
0934C:  MOV     W4,15FA
0934E:  SETM    15FC
.................... 					sens = 0; 
09350:  BCLR.B  14B7.6
.................... 					action = 1; 
09352:  MOV.B   #1,W0L
09354:  MOV.B   W0L,15F5
....................  
.................... 				break; 
09356:  GOTO    935A
.................... 			} 
....................  
.................... 		break; 
0935A:  GOTO    958E
....................  
.................... 		case 1 : 
....................  
.................... 				if(Etat!=1)  
0935E:  MOV.B   15F6,W0L
09360:  SE      W0,W0
09362:  CP      W0,#1
09364:  BRA     Z,938E
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,impulse_couronne); 
09366:  MOV.B   #C2,W0L
09368:  MOV.B   W0L,1B60
0936A:  CLR.B   1B61
0936C:  MOV.B   #1,W0L
0936E:  MOV.B   W0L,1B62
09370:  MOV.B   #2,W0L
09372:  MOV.B   W0L,1B63
09374:  MOV     #1388,W4
09376:  MOV     W4,1B64
09378:  PUSH    15FA
0937A:  POP     1B66
0937C:  PUSH    15FC
0937E:  POP     1B68
09380:  CALL    10FE
09384:  MOV.B   W0L,15F6
.................... 					return(0); 
09386:  CLR.B   0
09388:  BRA     958E
.................... 				} 
0938A:  GOTO    939A
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
0938E:  CLR.B   15F6
.................... 					action = 2; 
09390:  MOV.B   #2,W0L
09392:  MOV.B   W0L,15F5
.................... 					return(1); 
09394:  MOV.B   #1,W0L
09396:  MOV.B   W0L,0
09398:  BRA     958E
.................... 				}			 
....................  
.................... 		break; 
0939A:  GOTO    958E
....................  
.................... 		case 2 : 
.................... 		 
.................... 			etat_couronne = __Check_action_end(0xC2); 
0939E:  MOV.B   #C2,W0L
093A0:  MOV.B   W0L,1B58
093A2:  CALL    1438
093A6:  MOV.B   W0L,15F8
....................  
.................... 			if(etat_couronne==1) 
093A8:  MOV.B   15F8,W0L
093AA:  SE      W0,W0
093AC:  CP      W0,#1
093AE:  BRA     NZ,93EA
.................... 			{	 
.................... 				//if(impulse_couronne!=0) 
.................... 				//{ 
.................... 				//	etat_couronne = __Check_action_end(0xC2); 
.................... 				//} 
.................... 				//else 
.................... 				//{ 
.................... 				//	etat_couronne=1; 
.................... 				//}		 
.................... 	 
.................... 				//if(etat_couronne==1) 
.................... 				//{		 
.................... 					if(Etat!=1)  
093B0:  MOV.B   15F6,W0L
093B2:  SE      W0,W0
093B4:  CP      W0,#1
093B6:  BRA     Z,93DE
.................... 					{				 
.................... 						Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,-22000);//go_driver_moteur(0xC0,0,DRV_MODE_NON_REGUL,100,DRV_ARRET_COURANT,500); 
093B8:  MOV.B   #C0,W0L
093BA:  MOV.B   W0L,1B60
093BC:  CLR.B   1B61
093BE:  MOV.B   #1,W0L
093C0:  MOV.B   W0L,1B62
093C2:  MOV.B   #2,W0L
093C4:  MOV.B   W0L,1B63
093C6:  MOV     #1388,W4
093C8:  MOV     W4,1B64
093CA:  MOV     #AA10,W4
093CC:  MOV     W4,1B66
093CE:  SETM    1B68
093D0:  CALL    10FE
093D4:  MOV.B   W0L,15F6
.................... 						return(0);			 
093D6:  CLR.B   0
093D8:  BRA     958E
.................... 					} 
093DA:  GOTO    93EA
.................... 					else  
.................... 					{	 
.................... 						Etat = 0 ; 
093DE:  CLR.B   15F6
.................... 						action = 3; 
093E0:  MOV.B   #3,W0L
093E2:  MOV.B   W0L,15F5
.................... 						return(1); 
093E4:  MOV.B   #1,W0L
093E6:  MOV.B   W0L,0
093E8:  BRA     958E
.................... 					} 
.................... 				//} 
.................... 			} 
....................  
.................... 		break; 
093EA:  GOTO    958E
....................  
.................... 		case 3 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
093EE:  MOV.B   #C0,W0L
093F0:  MOV.B   W0L,1B58
093F2:  CALL    1438
093F6:  MOV.B   W0L,15F7
....................  
.................... 			if(etat_cremaillere==1) 
093F8:  MOV.B   15F7,W0L
093FA:  SE      W0,W0
093FC:  CP      W0,#1
093FE:  BRA     NZ,9440
.................... 			{ 
.................... 				if(Etat!=1)  
09400:  MOV.B   15F6,W0L
09402:  SE      W0,W0
09404:  CP      W0,#1
09406:  BRA     Z,942E
.................... 				{				 
.................... 					Etat = driver_Pompes(0xA0, 1, 1, 1, 1, 1); 
09408:  MOV.B   #A0,W0L
0940A:  MOV.B   W0L,1B60
0940C:  MOV.B   #1,W0L
0940E:  MOV.B   W0L,1B61
09410:  MOV.B   #1,W0L
09412:  MOV.B   W0L,1B62
09414:  MOV.B   #1,W0L
09416:  MOV.B   W0L,1B63
09418:  MOV.B   #1,W0L
0941A:  MOV.B   W0L,1B64
0941C:  MOV.B   #1,W0L
0941E:  MOV.B   W0L,1B65
09420:  CALL    107C
09424:  MOV.B   W0L,15F6
.................... 					return(0);			 
09426:  CLR.B   0
09428:  BRA     958E
.................... 				} 
0942A:  GOTO    9440
.................... 				else  
.................... 				{	 
.................... 					delay_ms(1000); 
0942E:  MOV     #3E8,W0
09430:  CALL    EBE
.................... 					Etat = 0; 
09434:  CLR.B   15F6
.................... 					action = 4; 
09436:  MOV.B   #4,W0L
09438:  MOV.B   W0L,15F5
.................... 					return(1); 
0943A:  MOV.B   #1,W0L
0943C:  MOV.B   W0L,0
0943E:  BRA     958E
.................... 				} 
.................... 			} 
....................  
.................... 		break; 
09440:  GOTO    958E
....................  
.................... 		case 4 : 
....................  
.................... 			if(Etat!=1)  
09444:  MOV.B   15F6,W0L
09446:  SE      W0,W0
09448:  CP      W0,#1
0944A:  BRA     Z,9472
.................... 			{				 
.................... 				Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,22000); 
0944C:  MOV.B   #C0,W0L
0944E:  MOV.B   W0L,1B60
09450:  CLR.B   1B61
09452:  MOV.B   #1,W0L
09454:  MOV.B   W0L,1B62
09456:  MOV.B   #2,W0L
09458:  MOV.B   W0L,1B63
0945A:  MOV     #1388,W4
0945C:  MOV     W4,1B64
0945E:  MOV     #55F0,W4
09460:  MOV     W4,1B66
09462:  CLR     1B68
09464:  CALL    10FE
09468:  MOV.B   W0L,15F6
.................... 				return(0);			 
0946A:  CLR.B   0
0946C:  BRA     958E
.................... 			} 
0946E:  GOTO    947E
.................... 			else  
.................... 			{	 
.................... 				Etat = 0 ; 
09472:  CLR.B   15F6
.................... 				action = 5; 
09474:  MOV.B   #5,W0L
09476:  MOV.B   W0L,15F5
.................... 				return(1); 
09478:  MOV.B   #1,W0L
0947A:  MOV.B   W0L,0
0947C:  BRA     958E
.................... 			} 
....................  
.................... 		break; 
0947E:  GOTO    958E
....................  
.................... 		break; 
09482:  GOTO    958E
....................  
.................... 		case 5 : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
09486:  MOV.B   #C0,W0L
09488:  MOV.B   W0L,1B58
0948A:  CALL    1438
0948E:  MOV.B   W0L,15F7
....................  
.................... 			if(etat_cremaillere==1) 
09490:  MOV.B   15F7,W0L
09492:  SE      W0,W0
09494:  CP      W0,#1
09496:  BRA     NZ,94D6
.................... 			{ 
.................... 				etat_pompes = read_driver_pompes(0xA0); 
09498:  MOV.B   #A0,W0L
0949A:  MOV.B   W0L,1B58
0949C:  CALL    9284
094A0:  MOV.B   W0L,15F9
.................... 				if(etat_pompes==0b00011111 || i==1) 
094A2:  MOV.B   15F9,W0L
094A4:  SE      W0,W0
094A6:  CP      W0,#1F
094A8:  BRA     Z,94B2
094AA:  MOV.B   15FE,W0L
094AC:  SE      W0,W0
094AE:  CP      W0,#1
094B0:  BRA     NZ,94BC
.................... 				{ 
.................... 					action = 6; 
094B2:  MOV.B   #6,W0L
094B4:  MOV.B   W0L,15F5
.................... 					i = 0; 
094B6:  CLR.B   15FE
.................... 				} 
094B8:  GOTO    94D6
.................... 				else 
.................... 				{ 
.................... 					if(etat_pompes==0) 
094BC:  MOV.B   15F9,W0L
094BE:  SE      W0,W0
094C0:  CP0     W0
094C2:  BRA     NZ,94D0
.................... 					{ 
.................... 						action = 7; 
094C4:  MOV.B   #7,W0L
094C6:  MOV.B   W0L,15F5
.................... 						Obj_end=1; 
094C8:  MOV     #1,W4
094CA:  MOV     W4,14AA
.................... 					} 
094CC:  GOTO    94D6
.................... 					else 
.................... 					{ 
.................... 						action = 2; 
094D0:  MOV.B   #2,W0L
094D2:  MOV.B   W0L,15F5
.................... 						i++; 
094D4:  INC.B   15FE
.................... 					} 
.................... 				} 
.................... 			}	 
....................  
.................... 		break; 
094D6:  GOTO    958E
....................  
.................... 		case START : 
....................  
.................... 			etat_cremaillere = __Check_action_end(0xC0); 
094DA:  MOV.B   #C0,W0L
094DC:  MOV.B   W0L,1B58
094DE:  CALL    1438
094E2:  MOV.B   W0L,15F7
....................  
.................... 			if(etat_cremaillere==1) 
094E4:  MOV.B   15F7,W0L
094E6:  SE      W0,W0
094E8:  CP      W0,#1
094EA:  BRA     NZ,9526
.................... 			{ 
.................... 				if(Etat!=1)  
094EC:  MOV.B   15F6,W0L
094EE:  SE      W0,W0
094F0:  CP      W0,#1
094F2:  BRA     Z,951A
.................... 				{				 
.................... 					Etat = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,20000); 
094F4:  MOV.B   #C0,W0L
094F6:  MOV.B   W0L,1B60
094F8:  CLR.B   1B61
094FA:  MOV.B   #1,W0L
094FC:  MOV.B   W0L,1B62
094FE:  MOV.B   #2,W0L
09500:  MOV.B   W0L,1B63
09502:  MOV     #1388,W4
09504:  MOV     W4,1B64
09506:  MOV     #4E20,W4
09508:  MOV     W4,1B66
0950A:  CLR     1B68
0950C:  CALL    10FE
09510:  MOV.B   W0L,15F6
.................... 					return(0);			 
09512:  CLR.B   0
09514:  BRA     958E
.................... 				} 
09516:  GOTO    9526
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
0951A:  CLR.B   15F6
.................... 					action = 6; 
0951C:  MOV.B   #6,W0L
0951E:  MOV.B   W0L,15F5
.................... 					return(1); 
09520:  MOV.B   #1,W0L
09522:  MOV.B   W0L,0
09524:  BRA     958E
.................... 				} 
.................... 			} 
.................... 			 
.................... 		case 6 : 
....................  
.................... 				if(Etat!=1)  
09526:  MOV.B   15F6,W0L
09528:  SE      W0,W0
0952A:  CP      W0,#1
0952C:  BRA     Z,955E
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,-impulse_couronne); 
0952E:  MOV     #0,W4
09530:  MOV     15FA,W3
09532:  SUB     W4,W3,W5
09534:  MOV     #0,W4
09536:  MOV     15FC,W3
09538:  SUBB    W4,W3,W6
0953A:  MOV.B   #C2,W0L
0953C:  MOV.B   W0L,1B60
0953E:  CLR.B   1B61
09540:  MOV.B   #1,W0L
09542:  MOV.B   W0L,1B62
09544:  MOV.B   #2,W0L
09546:  MOV.B   W0L,1B63
09548:  MOV     #1388,W4
0954A:  MOV     W4,1B64
0954C:  MOV     W5,1B66
0954E:  MOV     W6,1B68
09550:  CALL    10FE
09554:  MOV.B   W0L,15F6
.................... 					return(0); 
09556:  CLR.B   0
09558:  BRA     958E
.................... 				} 
0955A:  GOTO    956A
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
0955E:  CLR.B   15F6
.................... 					action = 7; 
09560:  MOV.B   #7,W0L
09562:  MOV.B   W0L,15F5
.................... 					return(1); 
09564:  MOV.B   #1,W0L
09566:  MOV.B   W0L,0
09568:  BRA     958E
.................... 				}		 
....................  
.................... 		case 7 : 
....................  
.................... 			etat_couronne = __Check_action_end(0xC2); 
0956A:  MOV.B   #C2,W0L
0956C:  MOV.B   W0L,1B58
0956E:  CALL    1438
09572:  MOV.B   W0L,15F8
....................  
.................... 			if(etat_couronne==1) 
09574:  MOV.B   15F8,W0L
09576:  SE      W0,W0
09578:  CP      W0,#1
0957A:  BRA     NZ,958A
.................... 			{ 
.................... 				Action_send = 1; 
0957C:  BSET.B  85B.7
.................... 				action = 0; 
0957E:  CLR.B   15F5
.................... 				Etat = 0; 
09580:  CLR.B   15F6
.................... 				etat_cremaillere = 0; 
09582:  CLR.B   15F7
.................... 				etat_pompes = 0; 
09584:  CLR.B   15F9
.................... 				i = 0;	 
09586:  CLR.B   15FE
.................... 				Check=1; 
09588:  BSET.B  85B.4
.................... 			}		 
....................  
.................... 		break; 
0958A:  GOTO    958E
....................  
.................... 	} 
0958E:  MOV     [--W15],W6
09590:  MOV     [--W15],W5
09592:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction pour empiler la tour de 5 étages. La solution (sensé être transmis par le raspberry à la carte principale) 
.................... //	est enregistré dans une variable.La fonction permet de monter les tours pour les différentes solution et pour les 2 côtés. 
.................... //	Avant de poser les cubes, on vérifie grâce à une autre fonction si on a un cube. Le comptage des points est aussi intégré 
.................... //	pour toutes les possibilités. 
.................... //============================================================================================================================ 
....................  
.................... int1 Empilage(void) 
*
0968A:  MOV     W5,[W15++]
0968C:  MOV     #C,W5
0968E:  REPEAT  #3
09690:  MOV     [W5++],[W15++]
.................... { 
.................... 	static int8 action; 
.................... 	static int8 Etat; 
.................... 	static int8 etat_cremaillere; 
.................... 	static int8 etat_couronne; 
.................... 	static int8 etat_pompes; 
.................... 	static int1 etat_pompe_A; 
.................... 	static int1 etat_pompe_B; 
.................... 	static int1 etat_pompe_C; 
.................... 	static int1 etat_pompe_D; 
.................... 	static int1 etat_pompe_E; 
.................... 	//int8 solution = 0; 
....................  
.................... 	static int1 combinaison; 
.................... 	static int8 etage;	 
.................... 	static int8 i;	 
.................... 	//static int8 points;// Surement à mettre en global 
.................... 	 
.................... 	//solution = 1;//(PORTA&0b11110000)/16; 
....................  
.................... 	if(Team==1) 
09692:  BTSS.B  85B.3
09694:  BRA     9EAC
.................... 	{ 
.................... 		switch(solution) 
09696:  MOV.B   87A,W0L
09698:  CLR.B   1
0969A:  XOR     #1,W0
0969C:  BRA     Z,96A0
0969E:  BRA     9EAC
.................... 		{ 
.................... 			case 0b0001 : 
.................... 	 
.................... 				switch(action) 
096A0:  MOV.B   15FF,W0L
096A2:  CLR.B   1
096A4:  XOR     #0,W0
096A6:  BRA     Z,96FA
096A8:  XOR     #1E,W0
096AA:  BRA     Z,9808
096AC:  XOR     #1F,W0
096AE:  BRA     Z,984E
096B0:  XOR     #3,W0
096B2:  BRA     Z,98EA
096B4:  XOR     #1,W0
096B6:  BRA     Z,9900
096B8:  XOR     #7,W0
096BA:  BRA     Z,9940
096BC:  XOR     #1,W0
096BE:  BRA     Z,99FA
096C0:  XOR     #3,W0
096C2:  BRA     Z,9A8C
096C4:  XOR     #1,W0
096C6:  BRA     Z,9AA2
096C8:  XOR     #F,W0
096CA:  BRA     Z,9AE2
096CC:  XOR     #1,W0
096CE:  BRA     Z,9B34
096D0:  XOR     #3,W0
096D2:  BRA     Z,9BD2
096D4:  XOR     #1,W0
096D6:  BRA     Z,9BE8
096D8:  XOR     #7,W0
096DA:  BRA     Z,9C28
096DC:  XOR     #1,W0
096DE:  BRA     Z,9C7A
096E0:  XOR     #3,W0
096E2:  BRA     Z,9D26
096E4:  XOR     #1,W0
096E6:  BRA     Z,9D3C
096E8:  XOR     #1F,W0
096EA:  BRA     Z,9D7C
096EC:  XOR     #1,W0
096EE:  BRA     Z,9DCE
096F0:  XOR     #3,W0
096F2:  BRA     Z,9E6A
096F4:  XOR     #1,W0
096F6:  BRA     Z,9E80
096F8:  BRA     9EA8
.................... 				{ 
.................... 					case 0 : 
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
096FA:  MOV.B   #A0,W0L
096FC:  MOV.B   W0L,1B58
096FE:  CALL    9284
09702:  MOV.B   W0L,1603
.................... 						etat_pompe_A = (etat_pompes&0b00010000)/16; 
09704:  MOV.B   1603,W0L
09706:  SE      W0,W0
09708:  AND     W0,#10,W5
0970A:  MOV     W5,W4
0970C:  MOV     #10,W3
0970E:  REPEAT  #11
09710:  DIV.S   W4,W3
09712:  BCLR.B  14B7.7
09714:  BTSC.B  0.0
09716:  BSET.B  14B7.7
.................... 						etat_pompe_B = (etat_pompes&0b00001000)/8; 
09718:  MOV.B   1603,W0L
0971A:  SE      W0,W0
0971C:  AND     W0,#8,W5
0971E:  MOV     W5,W4
09720:  MOV     #8,W3
09722:  REPEAT  #11
09724:  DIV.S   W4,W3
09726:  BCLR.B  1604.0
09728:  BTSC.B  0.0
0972A:  BSET.B  1604.0
.................... 						etat_pompe_C = (etat_pompes&0b00000100)/4; 
0972C:  MOV.B   1603,W0L
0972E:  SE      W0,W0
09730:  AND     W0,#4,W5
09732:  MOV     W5,W4
09734:  MOV     #4,W3
09736:  REPEAT  #11
09738:  DIV.S   W4,W3
0973A:  BCLR.B  1604.1
0973C:  BTSC.B  0.0
0973E:  BSET.B  1604.1
.................... 						etat_pompe_D = (etat_pompes&0b00000010)/2; 
09740:  MOV.B   1603,W0L
09742:  SE      W0,W0
09744:  AND     W0,#2,W5
09746:  MOV     W5,W4
09748:  MOV     #2,W3
0974A:  REPEAT  #11
0974C:  DIV.S   W4,W3
0974E:  BCLR.B  1604.2
09750:  BTSC.B  0.0
09752:  BSET.B  1604.2
.................... 						etat_pompe_E = (etat_pompes&0b00000001); 
09754:  MOV.B   1603,W0L
09756:  SE      W0,W0
09758:  AND     W0,#1,W0
0975A:  BCLR.B  1604.3
0975C:  BTSC.B  0.0
0975E:  BSET.B  1604.3
.................... 	 
.................... 	 
.................... 						fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",vitesse_roboteq,vitesse_roboteq); 
09760:  MOV     #0,W1
09762:  MOV     W1,W0
09764:  CLR.B   1
09766:  CALL    3C4
0976A:  INC     W1,W1
0976C:  BTSC.B  219.1
0976E:  BRA     976C
09770:  MOV     W0,21A
09772:  MOV     #4,W0
09774:  CPSGT   W1,W0
09776:  BRA     9762
09778:  MOV     #12C,W0
0977A:  MOV     #8007,W4
0977C:  CALL    9594
09780:  MOV     #9,W1
09782:  MOV     W1,W0
09784:  CLR.B   1
09786:  CALL    3C4
0978A:  INC     W1,W1
0978C:  BTSC.B  219.1
0978E:  BRA     978C
09790:  MOV     W0,21A
09792:  MOV     #E,W0
09794:  CPSGT   W1,W0
09796:  BRA     9782
09798:  MOV     #12C,W0
0979A:  MOV     #8007,W4
0979C:  CALL    9594
097A0:  BTSC.B  219.1
097A2:  BRA     97A0
097A4:  MOV     #20,W4
097A6:  MOV     W4,21A
097A8:  BTSC.B  219.1
097AA:  BRA     97A8
097AC:  MOV     #D,W4
097AE:  MOV     W4,21A
.................... 						fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",impulse,impulse); 
097B0:  MOV     #0,W1
097B2:  MOV     W1,W0
097B4:  CLR.B   1
097B6:  CALL    1FA
097BA:  INC     W1,W1
097BC:  BTSC.B  219.1
097BE:  BRA     97BC
097C0:  MOV     W0,21A
097C2:  MOV     #5,W0
097C4:  CPSGT   W1,W0
097C6:  BRA     97B2
097C8:  MOV     #D650,W0
097CA:  MOV     #8007,W4
097CC:  CALL    9594
097D0:  MOV     #A,W1
097D2:  MOV     W1,W0
097D4:  CLR.B   1
097D6:  CALL    1FA
097DA:  INC     W1,W1
097DC:  BTSC.B  219.1
097DE:  BRA     97DC
097E0:  MOV     W0,21A
097E2:  MOV     #10,W0
097E4:  CPSGT   W1,W0
097E6:  BRA     97D2
097E8:  MOV     #D650,W0
097EA:  MOV     #8007,W4
097EC:  CALL    9594
097F0:  BTSC.B  219.1
097F2:  BRA     97F0
097F4:  MOV     #20,W4
097F6:  MOV     W4,21A
097F8:  BTSC.B  219.1
097FA:  BRA     97F8
097FC:  MOV     #D,W4
097FE:  MOV     W4,21A
.................... 	 
.................... 						action = START; 
09800:  MOV.B   #1E,W0L
09802:  MOV.B   W0L,15FF
.................... 	 
.................... 					break; 
09804:  GOTO    9EA8
.................... 	 
.................... 					case START : 
.................... 	 
.................... 						delay_ms(1000); 
09808:  MOV     #3E8,W0
0980A:  CALL    EBE
.................... 						//__Check_commande_atteint(); 
.................... 	                  	if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
.................... 	                  	{   
.................... 							if(Etat!=1)  
0980E:  MOV.B   1600,W0L
09810:  SE      W0,W0
09812:  CP      W0,#1
09814:  BRA     Z,983E
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,-20000); 
09816:  MOV.B   #C0,W0L
09818:  MOV.B   W0L,1B60
0981A:  MOV.B   #1,W0L
0981C:  MOV.B   W0L,1B61
0981E:  MOV.B   #1,W0L
09820:  MOV.B   W0L,1B62
09822:  MOV.B   #2,W0L
09824:  MOV.B   W0L,1B63
09826:  MOV     #C8,W4
09828:  MOV     W4,1B64
0982A:  MOV     #B1E0,W4
0982C:  MOV     W4,1B66
0982E:  SETM    1B68
09830:  CALL    10FE
09834:  MOV.B   W0L,1600
.................... 								return(0); 
09836:  CLR.B   0
09838:  BRA     9EAC
.................... 							} 
0983A:  GOTO    984A
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
0983E:  CLR.B   1600
.................... 								action = 1; 
09840:  MOV.B   #1,W0L
09842:  MOV.B   W0L,15FF
.................... 								return(1); 
09844:  MOV.B   #1,W0L
09846:  MOV.B   W0L,0
09848:  BRA     9EAC
.................... 							} 
.................... 	                  	}    
.................... 	 
.................... 					break; 
0984A:  GOTO    9EA8
.................... 	 
.................... 					case 1 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
0984E:  MOV.B   #C0,W0L
09850:  MOV.B   W0L,1B58
09852:  CALL    1438
09856:  MOV.B   W0L,1601
.................... 	 
.................... 						if(etat_cremaillere==1) 
09858:  MOV.B   1601,W0L
0985A:  SE      W0,W0
0985C:  CP      W0,#1
0985E:  BRA     NZ,98E6
.................... 						{   
.................... 	                  		if(bit_test(etat_pompes, 2) == 1) 
09860:  BTSS.B  1603.2
09862:  BRA     98E2
.................... 	                  		{  
.................... 								if(Etat!=1)  
09864:  MOV.B   1600,W0L
09866:  SE      W0,W0
09868:  CP      W0,#1
0986A:  BRA     Z,98CA
.................... 								{	 
.................... 									etat_pompe_C = 0;			 
0986C:  BCLR.B  1604.1
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
0986E:  CLR     W0
09870:  BTSC.B  14B7.7
09872:  INC     W0,W0
09874:  MOV.B   W0L,W5L
09876:  CLR     W0
09878:  BTSC.B  1604.0
0987A:  INC     W0,W0
0987C:  MOV.B   W0L,W6L
0987E:  CLR     W0
09880:  BTSC.B  1604.1
09882:  INC     W0,W0
09884:  MOV.B   W0L,W7L
09886:  CLR     W0
09888:  BTSC.B  1604.2
0988A:  INC     W0,W0
0988C:  MOV.B   W0L,W8L
0988E:  CLR     W0
09890:  BTSC.B  1604.3
09892:  INC     W0,W0
09894:  MOV.B   W0L,W9L
09896:  MOV     W0,[W15++]
09898:  MOV.B   #A0,W0L
0989A:  MOV.B   W0L,1B60
0989C:  MOV     [--W15],W0
0989E:  PUSH    1B60
098A0:  MOV.B   W5L,[W15-#1]
098A2:  POP     1B60
098A4:  PUSH    1B62
098A6:  MOV.B   W6L,[W15-#2]
098A8:  POP     1B62
098AA:  PUSH    1B62
098AC:  MOV.B   W7L,[W15-#1]
098AE:  POP     1B62
098B0:  PUSH    1B64
098B2:  MOV.B   W8L,[W15-#2]
098B4:  POP     1B64
098B6:  PUSH    1B64
098B8:  MOV.B   W9L,[W15-#1]
098BA:  POP     1B64
098BC:  CALL    107C
098C0:  MOV.B   W0L,1600
.................... 									return(0);			 
098C2:  CLR.B   0
098C4:  BRA     9EAC
.................... 								} 
098C6:  GOTO    98DE
.................... 								else  
.................... 								{	 
.................... 									etage++; 
098CA:  INC.B   1605
.................... 									points = points + etage; 
098CC:  MOV.B   875,W0L
098CE:  ADD.B   1605,W0L
098D0:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
098D2:  CLR.B   1600
.................... 									action = 3; 
098D4:  MOV.B   #3,W0L
098D6:  MOV.B   W0L,15FF
.................... 									return(1); 
098D8:  MOV.B   #1,W0L
098DA:  MOV.B   W0L,0
098DC:  BRA     9EAC
.................... 								} 
.................... 							} 
098DE:  GOTO    98E6
.................... 							else 
.................... 							{ 
.................... 								action = 4; 
098E2:  MOV.B   #4,W0L
098E4:  MOV.B   W0L,15FF
.................... 							} 
.................... 	                  	}    
.................... 	 
.................... 					break; 
098E6:  GOTO    9EA8
.................... 	 
.................... 					case 2 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
098EA:  MOV.B   #A0,W0L
098EC:  MOV.B   W0L,1B58
098EE:  CALL    9284
098F2:  MOV.B   W0L,1603
.................... 						if(bit_test(etat_pompes, 2) == 0) 
098F4:  BTSC.B  1603.2
098F6:  BRA     98FC
.................... 						{ 
.................... 							action = 3; 
098F8:  MOV.B   #3,W0L
098FA:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
098FC:  GOTO    9EA8
.................... 	 
.................... 					case 3 : 
.................... 	   
.................... 						if(Etat!=1)  
09900:  MOV.B   1600,W0L
09902:  SE      W0,W0
09904:  CP      W0,#1
09906:  BRA     Z,9930
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,(distance)); 
09908:  MOV.B   #C0,W0L
0990A:  MOV.B   W0L,1B60
0990C:  MOV.B   #1,W0L
0990E:  MOV.B   W0L,1B61
09910:  MOV.B   #1,W0L
09912:  MOV.B   W0L,1B62
09914:  MOV.B   #2,W0L
09916:  MOV.B   W0L,1B63
09918:  MOV     #C8,W4
0991A:  MOV     W4,1B64
0991C:  MOV     #CB20,W4
0991E:  MOV     W4,1B66
09920:  CLR     1B68
09922:  CALL    10FE
09926:  MOV.B   W0L,1600
.................... 							return(0); 
09928:  CLR.B   0
0992A:  BRA     9EAC
.................... 						} 
0992C:  GOTO    993C
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
09930:  CLR.B   1600
.................... 							action = 4; 
09932:  MOV.B   #4,W0L
09934:  MOV.B   W0L,15FF
.................... 							return(1); 
09936:  MOV.B   #1,W0L
09938:  MOV.B   W0L,0
0993A:  BRA     9EAC
.................... 						}	 
.................... 	 
.................... 					break; 
0993C:  GOTO    9EA8
.................... 	 
.................... 					case 4 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09940:  MOV.B   #C0,W0L
09942:  MOV.B   W0L,1B58
09944:  CALL    1438
09948:  MOV.B   W0L,1601
.................... 	 
.................... 						if(etat_cremaillere==1) 
0994A:  MOV.B   1601,W0L
0994C:  SE      W0,W0
0994E:  CP      W0,#1
09950:  BRA     NZ,99F6
.................... 						{ 
.................... 							fprintf(ROBOTEQ,"!S 1 %07d_!S 2 %07d \r",vitesse_roboteq,vitesse_roboteq); 
09952:  MOV     #0,W1
09954:  MOV     W1,W0
09956:  CLR.B   1
09958:  CALL    3C4
0995C:  INC     W1,W1
0995E:  BTSC.B  219.1
09960:  BRA     995E
09962:  MOV     W0,21A
09964:  MOV     #4,W0
09966:  CPSGT   W1,W0
09968:  BRA     9954
0996A:  MOV     #12C,W0
0996C:  MOV     #8007,W4
0996E:  CALL    9594
09972:  MOV     #9,W1
09974:  MOV     W1,W0
09976:  CLR.B   1
09978:  CALL    3C4
0997C:  INC     W1,W1
0997E:  BTSC.B  219.1
09980:  BRA     997E
09982:  MOV     W0,21A
09984:  MOV     #E,W0
09986:  CPSGT   W1,W0
09988:  BRA     9974
0998A:  MOV     #12C,W0
0998C:  MOV     #8007,W4
0998E:  CALL    9594
09992:  BTSC.B  219.1
09994:  BRA     9992
09996:  MOV     #20,W4
09998:  MOV     W4,21A
0999A:  BTSC.B  219.1
0999C:  BRA     999A
0999E:  MOV     #D,W4
099A0:  MOV     W4,21A
.................... 							fprintf(ROBOTEQ,"!PR 1 %07d_!PR 2 %07d \r",-impulse,-impulse); 
099A2:  MOV     #0,W1
099A4:  MOV     W1,W0
099A6:  CLR.B   1
099A8:  CALL    1FA
099AC:  INC     W1,W1
099AE:  BTSC.B  219.1
099B0:  BRA     99AE
099B2:  MOV     W0,21A
099B4:  MOV     #5,W0
099B6:  CPSGT   W1,W0
099B8:  BRA     99A4
099BA:  MOV     #29B0,W0
099BC:  MOV     #8007,W4
099BE:  CALL    9594
099C2:  MOV     #A,W1
099C4:  MOV     W1,W0
099C6:  CLR.B   1
099C8:  CALL    1FA
099CC:  INC     W1,W1
099CE:  BTSC.B  219.1
099D0:  BRA     99CE
099D2:  MOV     W0,21A
099D4:  MOV     #10,W0
099D6:  CPSGT   W1,W0
099D8:  BRA     99C4
099DA:  MOV     #29B0,W0
099DC:  MOV     #8007,W4
099DE:  CALL    9594
099E2:  BTSC.B  219.1
099E4:  BRA     99E2
099E6:  MOV     #20,W4
099E8:  MOV     W4,21A
099EA:  BTSC.B  219.1
099EC:  BRA     99EA
099EE:  MOV     #D,W4
099F0:  MOV     W4,21A
.................... 	 
.................... 							action = 5;	 
099F2:  MOV.B   #5,W0L
099F4:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
099F6:  GOTO    9EA8
.................... 	 
.................... 					case 5 : 
.................... 	 
.................... 						delay_ms(1000); 
099FA:  MOV     #3E8,W0
099FC:  CALL    EBE
.................... 						//__Check_commande_atteint(); 
.................... 	                  	if(1)//flag_depl_ok == 1)                     //si le dÃ©placement est fini 
.................... 	                  	{    
.................... 	                  		if(bit_test(etat_pompes, 4) == 1) 
09A00:  BTSS.B  1603.4
09A02:  BRA     9A82
.................... 	                  		{  
.................... 								if(Etat!=1)  
09A04:  MOV.B   1600,W0L
09A06:  SE      W0,W0
09A08:  CP      W0,#1
09A0A:  BRA     Z,9A6A
.................... 								{	 
.................... 									etat_pompe_A = 0;			 
09A0C:  BCLR.B  14B7.7
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
09A0E:  CLR     W0
09A10:  BTSC.B  14B7.7
09A12:  INC     W0,W0
09A14:  MOV.B   W0L,W5L
09A16:  CLR     W0
09A18:  BTSC.B  1604.0
09A1A:  INC     W0,W0
09A1C:  MOV.B   W0L,W6L
09A1E:  CLR     W0
09A20:  BTSC.B  1604.1
09A22:  INC     W0,W0
09A24:  MOV.B   W0L,W7L
09A26:  CLR     W0
09A28:  BTSC.B  1604.2
09A2A:  INC     W0,W0
09A2C:  MOV.B   W0L,W8L
09A2E:  CLR     W0
09A30:  BTSC.B  1604.3
09A32:  INC     W0,W0
09A34:  MOV.B   W0L,W9L
09A36:  MOV     W0,[W15++]
09A38:  MOV.B   #A0,W0L
09A3A:  MOV.B   W0L,1B60
09A3C:  MOV     [--W15],W0
09A3E:  PUSH    1B60
09A40:  MOV.B   W5L,[W15-#1]
09A42:  POP     1B60
09A44:  PUSH    1B62
09A46:  MOV.B   W6L,[W15-#2]
09A48:  POP     1B62
09A4A:  PUSH    1B62
09A4C:  MOV.B   W7L,[W15-#1]
09A4E:  POP     1B62
09A50:  PUSH    1B64
09A52:  MOV.B   W8L,[W15-#2]
09A54:  POP     1B64
09A56:  PUSH    1B64
09A58:  MOV.B   W9L,[W15-#1]
09A5A:  POP     1B64
09A5C:  CALL    107C
09A60:  MOV.B   W0L,1600
.................... 									return(0);			 
09A62:  CLR.B   0
09A64:  BRA     9EAC
.................... 								} 
09A66:  GOTO    9A7E
.................... 								else  
.................... 								{ 
.................... 									etage++; 
09A6A:  INC.B   1605
.................... 									points = points + etage;	 
09A6C:  MOV.B   875,W0L
09A6E:  ADD.B   1605,W0L
09A70:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09A72:  CLR.B   1600
.................... 									action = 7; 
09A74:  MOV.B   #7,W0L
09A76:  MOV.B   W0L,15FF
.................... 									return(1); 
09A78:  MOV.B   #1,W0L
09A7A:  MOV.B   W0L,0
09A7C:  BRA     9EAC
.................... 								} 
.................... 							} 
09A7E:  GOTO    9A88
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
09A82:  BSET.B  1604.4
.................... 								action = 8; 
09A84:  MOV.B   #8,W0L
09A86:  MOV.B   W0L,15FF
.................... 							} 
.................... 	                  	} 
.................... 	 
.................... 					break; 
09A88:  GOTO    9EA8
.................... 	 
.................... 					case 6 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09A8C:  MOV.B   #A0,W0L
09A8E:  MOV.B   W0L,1B58
09A90:  CALL    9284
09A94:  MOV.B   W0L,1603
.................... 						if(bit_test(etat_pompes,4) == 0) 
09A96:  BTSC.B  1603.4
09A98:  BRA     9A9E
.................... 						{ 
.................... 							action = 7; 
09A9A:  MOV.B   #7,W0L
09A9C:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
09A9E:  GOTO    9EA8
.................... 	 
.................... 					case 7 : 
.................... 	 
.................... 						if(Etat!=1)  
09AA2:  MOV.B   1600,W0L
09AA4:  SE      W0,W0
09AA6:  CP      W0,#1
09AA8:  BRA     Z,9AD2
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
09AAA:  MOV.B   #C0,W0L
09AAC:  MOV.B   W0L,1B60
09AAE:  MOV.B   #1,W0L
09AB0:  MOV.B   W0L,1B61
09AB2:  MOV.B   #1,W0L
09AB4:  MOV.B   W0L,1B62
09AB6:  MOV.B   #2,W0L
09AB8:  MOV.B   W0L,1B63
09ABA:  MOV     #C8,W4
09ABC:  MOV     W4,1B64
09ABE:  MOV     #CB20,W4
09AC0:  MOV     W4,1B66
09AC2:  CLR     1B68
09AC4:  CALL    10FE
09AC8:  MOV.B   W0L,1600
.................... 							return(0); 
09ACA:  CLR.B   0
09ACC:  BRA     9EAC
.................... 						} 
09ACE:  GOTO    9ADE
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
09AD2:  CLR.B   1600
.................... 							action = 8; 
09AD4:  MOV.B   #8,W0L
09AD6:  MOV.B   W0L,15FF
.................... 							return(1); 
09AD8:  MOV.B   #1,W0L
09ADA:  MOV.B   W0L,0
09ADC:  BRA     9EAC
.................... 						} 
.................... 	 
.................... 					break; 
09ADE:  GOTO    9EA8
.................... 	 
.................... 					case 8 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09AE2:  MOV.B   #C0,W0L
09AE4:  MOV.B   W0L,1B58
09AE6:  CALL    1438
09AEA:  MOV.B   W0L,1601
.................... 	 
.................... 						if(etat_cremaillere==1) 
09AEC:  MOV.B   1601,W0L
09AEE:  SE      W0,W0
09AF0:  CP      W0,#1
09AF2:  BRA     NZ,9B30
.................... 						{ 
.................... 							if(Etat!=1)  
09AF4:  MOV.B   1600,W0L
09AF6:  SE      W0,W0
09AF8:  CP      W0,#1
09AFA:  BRA     Z,9B24
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,16192); 
09AFC:  MOV.B   #C2,W0L
09AFE:  MOV.B   W0L,1B60
09B00:  MOV.B   #1,W0L
09B02:  MOV.B   W0L,1B61
09B04:  MOV.B   #1,W0L
09B06:  MOV.B   W0L,1B62
09B08:  MOV.B   #2,W0L
09B0A:  MOV.B   W0L,1B63
09B0C:  MOV     #C8,W4
09B0E:  MOV     W4,1B64
09B10:  MOV     #3F40,W4
09B12:  MOV     W4,1B66
09B14:  CLR     1B68
09B16:  CALL    10FE
09B1A:  MOV.B   W0L,1600
.................... 								return(0); 
09B1C:  CLR.B   0
09B1E:  BRA     9EAC
.................... 							} 
09B20:  GOTO    9B30
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
09B24:  CLR.B   1600
.................... 								action = 9; 
09B26:  MOV.B   #9,W0L
09B28:  MOV.B   W0L,15FF
.................... 								return(1); 
09B2A:  MOV.B   #1,W0L
09B2C:  MOV.B   W0L,0
09B2E:  BRA     9EAC
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09B30:  GOTO    9EA8
.................... 	 
.................... 					case 9 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
09B34:  MOV.B   #C2,W0L
09B36:  MOV.B   W0L,1B58
09B38:  CALL    1438
09B3C:  MOV.B   W0L,1602
.................... 	 
.................... 						if(etat_couronne==1) 
09B3E:  MOV.B   1602,W0L
09B40:  SE      W0,W0
09B42:  CP      W0,#1
09B44:  BRA     NZ,9BCE
.................... 	                  	{    
.................... 	                  		if(bit_test(etat_pompes, 3) == 1) 
09B46:  BTSS.B  1603.3
09B48:  BRA     9BC8
.................... 	                  		{ 
.................... 								if(Etat!=1)  
09B4A:  MOV.B   1600,W0L
09B4C:  SE      W0,W0
09B4E:  CP      W0,#1
09B50:  BRA     Z,9BB0
.................... 								{	 
.................... 									etat_pompe_B = 0;			 
09B52:  BCLR.B  1604.0
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
09B54:  CLR     W0
09B56:  BTSC.B  14B7.7
09B58:  INC     W0,W0
09B5A:  MOV.B   W0L,W5L
09B5C:  CLR     W0
09B5E:  BTSC.B  1604.0
09B60:  INC     W0,W0
09B62:  MOV.B   W0L,W6L
09B64:  CLR     W0
09B66:  BTSC.B  1604.1
09B68:  INC     W0,W0
09B6A:  MOV.B   W0L,W7L
09B6C:  CLR     W0
09B6E:  BTSC.B  1604.2
09B70:  INC     W0,W0
09B72:  MOV.B   W0L,W8L
09B74:  CLR     W0
09B76:  BTSC.B  1604.3
09B78:  INC     W0,W0
09B7A:  MOV.B   W0L,W9L
09B7C:  MOV     W0,[W15++]
09B7E:  MOV.B   #A0,W0L
09B80:  MOV.B   W0L,1B60
09B82:  MOV     [--W15],W0
09B84:  PUSH    1B60
09B86:  MOV.B   W5L,[W15-#1]
09B88:  POP     1B60
09B8A:  PUSH    1B62
09B8C:  MOV.B   W6L,[W15-#2]
09B8E:  POP     1B62
09B90:  PUSH    1B62
09B92:  MOV.B   W7L,[W15-#1]
09B94:  POP     1B62
09B96:  PUSH    1B64
09B98:  MOV.B   W8L,[W15-#2]
09B9A:  POP     1B64
09B9C:  PUSH    1B64
09B9E:  MOV.B   W9L,[W15-#1]
09BA0:  POP     1B64
09BA2:  CALL    107C
09BA6:  MOV.B   W0L,1600
.................... 									return(0);			 
09BA8:  CLR.B   0
09BAA:  BRA     9EAC
.................... 								} 
09BAC:  GOTO    9BC4
.................... 								else  
.................... 								{	 
.................... 									etage++; 
09BB0:  INC.B   1605
.................... 									points = points + etage; 
09BB2:  MOV.B   875,W0L
09BB4:  ADD.B   1605,W0L
09BB6:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09BB8:  CLR.B   1600
.................... 									action = 11; 
09BBA:  MOV.B   #B,W0L
09BBC:  MOV.B   W0L,15FF
.................... 									return(1); 
09BBE:  MOV.B   #1,W0L
09BC0:  MOV.B   W0L,0
09BC2:  BRA     9EAC
.................... 								} 
.................... 							} 
09BC4:  GOTO    9BCE
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
09BC8:  BSET.B  1604.4
.................... 								action = 12; 
09BCA:  MOV.B   #C,W0L
09BCC:  MOV.B   W0L,15FF
.................... 							} 
.................... 	                  	} 
.................... 	 
.................... 					break; 
09BCE:  GOTO    9EA8
.................... 	 
.................... 					case 10 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09BD2:  MOV.B   #A0,W0L
09BD4:  MOV.B   W0L,1B58
09BD6:  CALL    9284
09BDA:  MOV.B   W0L,1603
.................... 						if(bit_test(etat_pompes,3) == 0) 
09BDC:  BTSC.B  1603.3
09BDE:  BRA     9BE4
.................... 						{ 
.................... 							action = 11; 
09BE0:  MOV.B   #B,W0L
09BE2:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
09BE4:  GOTO    9EA8
.................... 	 
.................... 					case 11 : 
.................... 	 
.................... 						if(Etat!=1)  
09BE8:  MOV.B   1600,W0L
09BEA:  SE      W0,W0
09BEC:  CP      W0,#1
09BEE:  BRA     Z,9C18
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
09BF0:  MOV.B   #C0,W0L
09BF2:  MOV.B   W0L,1B60
09BF4:  MOV.B   #1,W0L
09BF6:  MOV.B   W0L,1B61
09BF8:  MOV.B   #1,W0L
09BFA:  MOV.B   W0L,1B62
09BFC:  MOV.B   #2,W0L
09BFE:  MOV.B   W0L,1B63
09C00:  MOV     #C8,W4
09C02:  MOV     W4,1B64
09C04:  MOV     #CB20,W4
09C06:  MOV     W4,1B66
09C08:  CLR     1B68
09C0A:  CALL    10FE
09C0E:  MOV.B   W0L,1600
.................... 							return(0); 
09C10:  CLR.B   0
09C12:  BRA     9EAC
.................... 						} 
09C14:  GOTO    9C24
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
09C18:  CLR.B   1600
.................... 							action = 12; 
09C1A:  MOV.B   #C,W0L
09C1C:  MOV.B   W0L,15FF
.................... 							return(1); 
09C1E:  MOV.B   #1,W0L
09C20:  MOV.B   W0L,0
09C22:  BRA     9EAC
.................... 						} 
.................... 	 
.................... 					break; 
09C24:  GOTO    9EA8
.................... 	 
.................... 					case 12 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09C28:  MOV.B   #C0,W0L
09C2A:  MOV.B   W0L,1B58
09C2C:  CALL    1438
09C30:  MOV.B   W0L,1601
.................... 	 
.................... 						if(etat_cremaillere==1) 
09C32:  MOV.B   1601,W0L
09C34:  SE      W0,W0
09C36:  CP      W0,#1
09C38:  BRA     NZ,9C76
.................... 	                  	{  
.................... 							if(Etat!=1)  
09C3A:  MOV.B   1600,W0L
09C3C:  SE      W0,W0
09C3E:  CP      W0,#1
09C40:  BRA     Z,9C6A
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,16192); 
09C42:  MOV.B   #C2,W0L
09C44:  MOV.B   W0L,1B60
09C46:  MOV.B   #1,W0L
09C48:  MOV.B   W0L,1B61
09C4A:  MOV.B   #1,W0L
09C4C:  MOV.B   W0L,1B62
09C4E:  MOV.B   #2,W0L
09C50:  MOV.B   W0L,1B63
09C52:  MOV     #C8,W4
09C54:  MOV     W4,1B64
09C56:  MOV     #3F40,W4
09C58:  MOV     W4,1B66
09C5A:  CLR     1B68
09C5C:  CALL    10FE
09C60:  MOV.B   W0L,1600
.................... 								return(0); 
09C62:  CLR.B   0
09C64:  BRA     9EAC
.................... 							} 
09C66:  GOTO    9C76
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
09C6A:  CLR.B   1600
.................... 								action = 13; 
09C6C:  MOV.B   #D,W0L
09C6E:  MOV.B   W0L,15FF
.................... 								return(1); 
09C70:  MOV.B   #1,W0L
09C72:  MOV.B   W0L,0
09C74:  BRA     9EAC
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09C76:  GOTO    9EA8
.................... 	 
.................... 					case 13 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
09C7A:  MOV.B   #C2,W0L
09C7C:  MOV.B   W0L,1B58
09C7E:  CALL    1438
09C82:  MOV.B   W0L,1602
.................... 	 
.................... 						if(etat_couronne==1) 
09C84:  MOV.B   1602,W0L
09C86:  SE      W0,W0
09C88:  CP      W0,#1
09C8A:  BRA     NZ,9D22
.................... 	                  	{  
.................... 	                  		if(bit_test(etat_pompes, 0) == 1) 
09C8C:  BTSS.B  1603.0
09C8E:  BRA     9D1C
.................... 	                  		{ 
.................... 								if(Etat!=1)  
09C90:  MOV.B   1600,W0L
09C92:  SE      W0,W0
09C94:  CP      W0,#1
09C96:  BRA     Z,9CF6
.................... 								{	 
.................... 									etat_pompe_E = 0;			 
09C98:  BCLR.B  1604.3
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
09C9A:  CLR     W0
09C9C:  BTSC.B  14B7.7
09C9E:  INC     W0,W0
09CA0:  MOV.B   W0L,W5L
09CA2:  CLR     W0
09CA4:  BTSC.B  1604.0
09CA6:  INC     W0,W0
09CA8:  MOV.B   W0L,W6L
09CAA:  CLR     W0
09CAC:  BTSC.B  1604.1
09CAE:  INC     W0,W0
09CB0:  MOV.B   W0L,W7L
09CB2:  CLR     W0
09CB4:  BTSC.B  1604.2
09CB6:  INC     W0,W0
09CB8:  MOV.B   W0L,W8L
09CBA:  CLR     W0
09CBC:  BTSC.B  1604.3
09CBE:  INC     W0,W0
09CC0:  MOV.B   W0L,W9L
09CC2:  MOV     W0,[W15++]
09CC4:  MOV.B   #A0,W0L
09CC6:  MOV.B   W0L,1B60
09CC8:  MOV     [--W15],W0
09CCA:  PUSH    1B60
09CCC:  MOV.B   W5L,[W15-#1]
09CCE:  POP     1B60
09CD0:  PUSH    1B62
09CD2:  MOV.B   W6L,[W15-#2]
09CD4:  POP     1B62
09CD6:  PUSH    1B62
09CD8:  MOV.B   W7L,[W15-#1]
09CDA:  POP     1B62
09CDC:  PUSH    1B64
09CDE:  MOV.B   W8L,[W15-#2]
09CE0:  POP     1B64
09CE2:  PUSH    1B64
09CE4:  MOV.B   W9L,[W15-#1]
09CE6:  POP     1B64
09CE8:  CALL    107C
09CEC:  MOV.B   W0L,1600
.................... 									return(0);			 
09CEE:  CLR.B   0
09CF0:  BRA     9EAC
.................... 								} 
09CF2:  GOTO    9D18
.................... 								else  
.................... 								{ 
.................... 									etage++; 
09CF6:  INC.B   1605
.................... 									points = points + etage;	 
09CF8:  MOV.B   875,W0L
09CFA:  ADD.B   1605,W0L
09CFC:  MOV.B   W0L,875
.................... 									if(combinaison == 0) 
09CFE:  BTSC.B  1604.4
09D00:  BRA     9D0C
.................... 									{ 
.................... 										points = points + 30; 
09D02:  MOV     874,W4
09D04:  LSR     W4,#8,W4
09D06:  ADD.B   W4L,#1E,W4L
09D08:  MOV.B   W4L,W0L
09D0A:  MOV.B   W0L,875
.................... 									} 
.................... 									Etat = 0 ; 
09D0C:  CLR.B   1600
.................... 									action = 15; 
09D0E:  MOV.B   #F,W0L
09D10:  MOV.B   W0L,15FF
.................... 									return(1); 
09D12:  MOV.B   #1,W0L
09D14:  MOV.B   W0L,0
09D16:  BRA     9EAC
.................... 								} 
.................... 							} 
09D18:  GOTO    9D22
.................... 							else 
.................... 							{ 
.................... 								combinaison = 1; 
09D1C:  BSET.B  1604.4
.................... 								action = 16; 
09D1E:  MOV.B   #10,W0L
09D20:  MOV.B   W0L,15FF
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09D22:  GOTO    9EA8
.................... 	 
.................... 					case 14 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09D26:  MOV.B   #A0,W0L
09D28:  MOV.B   W0L,1B58
09D2A:  CALL    9284
09D2E:  MOV.B   W0L,1603
.................... 						if(bit_test(etat_pompes,0) == 0) 
09D30:  BTSC.B  1603.0
09D32:  BRA     9D38
.................... 						{ 
.................... 							action = 15; 
09D34:  MOV.B   #F,W0L
09D36:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
09D38:  GOTO    9EA8
.................... 	 
.................... 					case 15 : 
.................... 	 
.................... 						if(Etat!=1)  
09D3C:  MOV.B   1600,W0L
09D3E:  SE      W0,W0
09D40:  CP      W0,#1
09D42:  BRA     Z,9D6C
.................... 						{ 
.................... 							Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,vitesse_crem,DRV_ARRET_POSITION_RELATIVE,distance); 
09D44:  MOV.B   #C0,W0L
09D46:  MOV.B   W0L,1B60
09D48:  MOV.B   #1,W0L
09D4A:  MOV.B   W0L,1B61
09D4C:  MOV.B   #1,W0L
09D4E:  MOV.B   W0L,1B62
09D50:  MOV.B   #2,W0L
09D52:  MOV.B   W0L,1B63
09D54:  MOV     #C8,W4
09D56:  MOV     W4,1B64
09D58:  MOV     #CB20,W4
09D5A:  MOV     W4,1B66
09D5C:  CLR     1B68
09D5E:  CALL    10FE
09D62:  MOV.B   W0L,1600
.................... 							return(0); 
09D64:  CLR.B   0
09D66:  BRA     9EAC
.................... 						} 
09D68:  GOTO    9D78
.................... 						else  
.................... 						{	 
.................... 							Etat = 0 ; 
09D6C:  CLR.B   1600
.................... 							action = 16; 
09D6E:  MOV.B   #10,W0L
09D70:  MOV.B   W0L,15FF
.................... 							return(1); 
09D72:  MOV.B   #1,W0L
09D74:  MOV.B   W0L,0
09D76:  BRA     9EAC
.................... 						} 
.................... 	 
.................... 					break; 
09D78:  GOTO    9EA8
.................... 	 
.................... 					case 16 : 
.................... 	 
.................... 						etat_cremaillere = __Check_action_end(0xC0); 
09D7C:  MOV.B   #C0,W0L
09D7E:  MOV.B   W0L,1B58
09D80:  CALL    1438
09D84:  MOV.B   W0L,1601
.................... 	 
.................... 						if(etat_cremaillere==1) 
09D86:  MOV.B   1601,W0L
09D88:  SE      W0,W0
09D8A:  CP      W0,#1
09D8C:  BRA     NZ,9DCA
.................... 						{ 
.................... 							if(Etat!=1)  
09D8E:  MOV.B   1600,W0L
09D90:  SE      W0,W0
09D92:  CP      W0,#1
09D94:  BRA     Z,9DBE
.................... 							{ 
.................... 								Etat = go_driver_moteur(0xC2,1,DRV_MODE_VITESSE ,vitesse_cour,DRV_ARRET_POSITION_RELATIVE,-48576); 
09D96:  MOV.B   #C2,W0L
09D98:  MOV.B   W0L,1B60
09D9A:  MOV.B   #1,W0L
09D9C:  MOV.B   W0L,1B61
09D9E:  MOV.B   #1,W0L
09DA0:  MOV.B   W0L,1B62
09DA2:  MOV.B   #2,W0L
09DA4:  MOV.B   W0L,1B63
09DA6:  MOV     #C8,W4
09DA8:  MOV     W4,1B64
09DAA:  MOV     #4240,W4
09DAC:  MOV     W4,1B66
09DAE:  SETM    1B68
09DB0:  CALL    10FE
09DB4:  MOV.B   W0L,1600
.................... 								return(0); 
09DB6:  CLR.B   0
09DB8:  BRA     9EAC
.................... 							} 
09DBA:  GOTO    9DCA
.................... 							else  
.................... 							{	 
.................... 								Etat = 0 ; 
09DBE:  CLR.B   1600
.................... 								action = 17; 
09DC0:  MOV.B   #11,W0L
09DC2:  MOV.B   W0L,15FF
.................... 								return(1); 
09DC4:  MOV.B   #1,W0L
09DC6:  MOV.B   W0L,0
09DC8:  BRA     9EAC
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09DCA:  GOTO    9EA8
.................... 	 
.................... 					case 17 : 
.................... 	 
.................... 						etat_couronne = __Check_action_end(0xC2); 
09DCE:  MOV.B   #C2,W0L
09DD0:  MOV.B   W0L,1B58
09DD2:  CALL    1438
09DD6:  MOV.B   W0L,1602
.................... 	 
.................... 						if(etat_couronne==1) 
09DD8:  MOV.B   1602,W0L
09DDA:  SE      W0,W0
09DDC:  CP      W0,#1
09DDE:  BRA     NZ,9E66
.................... 	                  	{ 
.................... 	                  		if(bit_test(etat_pompes, 1) == 1) 
09DE0:  BTSS.B  1603.1
09DE2:  BRA     9E62
.................... 	                  		{ 
.................... 								if(Etat!=1)  
09DE4:  MOV.B   1600,W0L
09DE6:  SE      W0,W0
09DE8:  CP      W0,#1
09DEA:  BRA     Z,9E4A
.................... 								{	 
.................... 									etat_pompe_D = 0;			 
09DEC:  BCLR.B  1604.2
.................... 									Etat = driver_Pompes(0xA0, etat_pompe_A, etat_pompe_B, etat_pompe_C, etat_pompe_D, etat_pompe_E); 
09DEE:  CLR     W0
09DF0:  BTSC.B  14B7.7
09DF2:  INC     W0,W0
09DF4:  MOV.B   W0L,W5L
09DF6:  CLR     W0
09DF8:  BTSC.B  1604.0
09DFA:  INC     W0,W0
09DFC:  MOV.B   W0L,W6L
09DFE:  CLR     W0
09E00:  BTSC.B  1604.1
09E02:  INC     W0,W0
09E04:  MOV.B   W0L,W7L
09E06:  CLR     W0
09E08:  BTSC.B  1604.2
09E0A:  INC     W0,W0
09E0C:  MOV.B   W0L,W8L
09E0E:  CLR     W0
09E10:  BTSC.B  1604.3
09E12:  INC     W0,W0
09E14:  MOV.B   W0L,W9L
09E16:  MOV     W0,[W15++]
09E18:  MOV.B   #A0,W0L
09E1A:  MOV.B   W0L,1B60
09E1C:  MOV     [--W15],W0
09E1E:  PUSH    1B60
09E20:  MOV.B   W5L,[W15-#1]
09E22:  POP     1B60
09E24:  PUSH    1B62
09E26:  MOV.B   W6L,[W15-#2]
09E28:  POP     1B62
09E2A:  PUSH    1B62
09E2C:  MOV.B   W7L,[W15-#1]
09E2E:  POP     1B62
09E30:  PUSH    1B64
09E32:  MOV.B   W8L,[W15-#2]
09E34:  POP     1B64
09E36:  PUSH    1B64
09E38:  MOV.B   W9L,[W15-#1]
09E3A:  POP     1B64
09E3C:  CALL    107C
09E40:  MOV.B   W0L,1600
.................... 									return(0);			 
09E42:  CLR.B   0
09E44:  BRA     9EAC
.................... 								} 
09E46:  GOTO    9E5E
.................... 								else  
.................... 								{	 
.................... 									etage++; 
09E4A:  INC.B   1605
.................... 									points = points + etage; 
09E4C:  MOV.B   875,W0L
09E4E:  ADD.B   1605,W0L
09E50:  MOV.B   W0L,875
.................... 									Etat = 0 ; 
09E52:  CLR.B   1600
.................... 									action = 19; 
09E54:  MOV.B   #13,W0L
09E56:  MOV.B   W0L,15FF
.................... 									return(1); 
09E58:  MOV.B   #1,W0L
09E5A:  MOV.B   W0L,0
09E5C:  BRA     9EAC
.................... 								} 
.................... 							} 
09E5E:  GOTO    9E66
.................... 							else 
.................... 							{ 
.................... 								action = 19; 
09E62:  MOV.B   #13,W0L
09E64:  MOV.B   W0L,15FF
.................... 							} 
.................... 						} 
.................... 	 
.................... 					break; 
09E66:  GOTO    9EA8
.................... 	 
.................... 					case 18 :  
.................... 	 
.................... 						etat_pompes = read_driver_pompes(0xA0); 
09E6A:  MOV.B   #A0,W0L
09E6C:  MOV.B   W0L,1B58
09E6E:  CALL    9284
09E72:  MOV.B   W0L,1603
.................... 						if(bit_test(etat_pompes,1) == 0) 
09E74:  BTSC.B  1603.1
09E76:  BRA     9E7C
.................... 						{ 
.................... 							action = 19; 
09E78:  MOV.B   #13,W0L
09E7A:  MOV.B   W0L,15FF
.................... 						} 
.................... 	 
.................... 					break; 
09E7C:  GOTO    9EA8
.................... 	 
.................... 					case 19 : 
.................... 	 
.................... 						Etat = driver_Pompes(0xA0,0,0,0,0,0); 
09E80:  MOV.B   #A0,W0L
09E82:  MOV.B   W0L,1B60
09E84:  CLR.B   1B61
09E86:  CLR.B   1B62
09E88:  CLR.B   1B63
09E8A:  CLR.B   1B64
09E8C:  CLR.B   1B65
09E8E:  CALL    107C
09E92:  MOV.B   W0L,1600
.................... 						Check=1; 
09E94:  BSET.B  85B.4
.................... 						Action_send = 1; 
09E96:  BSET.B  85B.7
.................... 						action = 0; 
09E98:  CLR.B   15FF
.................... 						etat = 0; 
09E9A:  CLR.B   1600
.................... 						Sens_rot_Couronne = 0; 
09E9C:  BCLR.B  14B7.4
.................... 						combinaison = 0; 
09E9E:  BCLR.B  1604.4
.................... 						etage = 0;	 
09EA0:  CLR.B   1605
.................... 						i = 0; 
09EA2:  CLR.B   1606
.................... 	 
.................... 					break; 
09EA4:  GOTO    9EA8
.................... 	 
.................... 				} 
.................... 	 
.................... 			break; 
09EA8:  GOTO    9EAC
.................... 	 
.................... 			 
.................... 	 
.................... 		}		 
.................... 	}	 
09EAC:  MOV     #12,W5
09EAE:  REPEAT  #3
09EB0:  MOV     [--W15],[W5--]
09EB2:  MOV     [--W15],W5
09EB4:  RETURN  
.................... } 
....................  
.................... //============================================================================================================================ 
.................... //	Fonction qui va réinitialiser la crémaillère en position 0, puis la remonter à 30000 impulse 
.................... //============================================================================================================================ 
.................... 	 
.................... 	int1 GoToZero_Cremaillere(void) 
.................... 	{ 
.................... 		static int8 action; 
.................... 		static int8 Etat; 
.................... 		static int8 etat_cremaillere; 
.................... 	 
.................... 		switch(action) 
*
01824:  MOV.B   1607,W0L
01826:  CLR.B   1
01828:  XOR     #0,W0
0182A:  BRA     Z,1832
0182C:  XOR     #1,W0
0182E:  BRA     Z,1872
01830:  BRA     18C2
.................... 		{ 
.................... 			case 0 : 
.................... 	 
.................... 				if(Etat!=1)  
01832:  MOV.B   1608,W0L
01834:  SE      W0,W0
01836:  CP      W0,#1
01838:  BRA     Z,185E
.................... 				{ 
.................... 					Etat = go_driver_moteur(0xC0,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,750); 
0183A:  MOV.B   #C0,W0L
0183C:  MOV.B   W0L,1B60
0183E:  CLR.B   1B61
01840:  MOV.B   #2,W0L
01842:  MOV.B   W0L,1B62
01844:  CLR.B   1B63
01846:  MOV     #64,W4
01848:  MOV     W4,1B64
0184A:  MOV     #2EE,W4
0184C:  MOV     W4,1B66
0184E:  CLR     1B68
01850:  CALL    10FE
01854:  MOV.B   W0L,1608
.................... 					return(0); 
01856:  CLR.B   0
01858:  BRA     18C2
.................... 				} 
0185A:  GOTO    186E
.................... 				else  
.................... 				{	 
.................... 					Etat = 0 ; 
0185E:  CLR.B   1608
.................... 					action = 1; 
01860:  MOV.B   #1,W0L
01862:  MOV.B   W0L,1607
.................... 					delay_ms(100); 
01864:  MOV     #64,W0
01866:  CALL    EBE
.................... 					return(0); 
0186A:  CLR.B   0
0186C:  BRA     18C2
.................... 				} 
.................... 	 
.................... 			break; 
0186E:  GOTO    18C2
.................... 	 
.................... 			case 1 : 
.................... 	 
.................... 				etat_cremaillere = __Check_action_end(0xC0); 
01872:  MOV.B   #C0,W0L
01874:  MOV.B   W0L,1B58
01876:  CALL    1438
0187A:  MOV.B   W0L,1609
.................... 		 
.................... 				if(etat_cremaillere==1) 
0187C:  MOV.B   1609,W0L
0187E:  SE      W0,W0
01880:  CP      W0,#1
01882:  BRA     NZ,18BE
.................... 				{ 
.................... 					if(Etat!=1)  
01884:  MOV.B   1608,W0L
01886:  SE      W0,W0
01888:  CP      W0,#1
0188A:  BRA     Z,18B4
.................... 					{				 
.................... 						Etat = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,30000); 
0188C:  MOV.B   #C0,W0L
0188E:  MOV.B   W0L,1B60
01890:  MOV.B   #1,W0L
01892:  MOV.B   W0L,1B61
01894:  MOV.B   #1,W0L
01896:  MOV.B   W0L,1B62
01898:  MOV.B   #2,W0L
0189A:  MOV.B   W0L,1B63
0189C:  MOV     #1388,W4
0189E:  MOV     W4,1B64
018A0:  MOV     #7530,W4
018A2:  MOV     W4,1B66
018A4:  CLR     1B68
018A6:  CALL    10FE
018AA:  MOV.B   W0L,1608
.................... 						return(0);			 
018AC:  CLR.B   0
018AE:  BRA     18C2
.................... 					} 
018B0:  GOTO    18BE
.................... 					else  
.................... 					{	 
.................... 						Etat = 0 ; 
018B4:  CLR.B   1608
.................... 						action = 0; 
018B6:  CLR.B   1607
.................... 						return(1); 
018B8:  MOV.B   #1,W0L
018BA:  MOV.B   W0L,0
018BC:  BRA     18C2
.................... 					} 
.................... 				}	 
.................... 			break; 
018BE:  GOTO    18C2
.................... 		} 
018C2:  RETURN  
.................... 	}	 
.................... 	 
.................... //============================================================================================================================ 
.................... //	Fonction qui va réinitialiser la couronne et la crémaillère 
.................... //============================================================================================================================ 
....................  
.................... int1 reinitialisation(void) 
*
09EDA:  MOV     W5,[W15++]
09EDC:  MOV     W6,[W15++]
.................... { 
.................... 	static int1 Zero_Couronne; 
.................... 	static int1 Zero_Cremaillere; 
....................  
.................... 	if(Zero_Cremaillere != 1) 
09EDE:  BTSC.B  1604.6
09EE0:  BRA     9EEC
.................... 	{ 
.................... 		Zero_Cremaillere = GoToZero_Cremaillere(); 
09EE2:  CALL    1824
09EE6:  BCLR.B  1604.6
09EE8:  BTSC.B  0.0
09EEA:  BSET.B  1604.6
.................... 	} 
.................... 	 
.................... 	//if(Zero_Couronne != 1)			// Ne fonctionner pas toujours (surement pas à cause du code) donc enlever 
.................... 	//{ 
.................... 	//	Zero_Couronne = __GoToZero();	 
.................... 	//} 
.................... 	Zero_Couronne = 1; 
09EEC:  BSET.B  1604.5
.................... 	if(Zero_Cremaillere == 1 && Zero_Couronne == 1) 
09EEE:  BTSS.B  1604.6
09EF0:  BRA     9EFE
09EF2:  BTSS.B  1604.5
09EF4:  BRA     9EFE
.................... 	{ 
.................... 		Action_send = 1; 
09EF6:  BSET.B  85B.7
.................... 		Check=1; 
09EF8:  BSET.B  85B.4
.................... 		Zero_Couronne = 0; 
09EFA:  BCLR.B  1604.5
.................... 		Zero_Cremaillere = 0; 
09EFC:  BCLR.B  1604.6
.................... 	} 
09EFE:  MOV     [--W15],W6
09F00:  MOV     [--W15],W5
09F02:  RETURN  
.................... } 
....................  
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: GoToZero																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Favre Lenny 
.................... //						: Borgeat Rémy     												 
.................... //  Date				: 24.02.2017															 
.................... //  Date de modif.		: 17.3.2017															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui place le barillet à son point zéro 
.................... // paramètres 	:	Aucun paramètre 
.................... // retourne 	:	retourne le status du driver											 
.................... //					0-> non utilisé																 
.................... //					1-> OK : ordre transmis et terminé													 
.................... //					2-> not ready  (le slave ne répond pas)															 
.................... //					3-> Le barillet n'a pas trouvé le point zéro															 
.................... //=================================================================================================================================================================================================== 
.................... int1 __GoToZero(void) 
*
01218:  MOV     W5,[W15++]
.................... { 
.................... 	static signed int32 ActualPosition = 0; 
.................... 	static signed int32 Position; 
.................... 	static int8 Etat = 0; 
.................... 	static int1 read = 0; 
.................... 	 
.................... 	if(Sens_rot_Couronne==0) 
0121A:  BTSC.B  14B7.4
0121C:  BRA     1228
.................... 	{ 
.................... 		Position = 48576; 
0121E:  MOV     #BDC0,W4
01220:  MOV     W4,160E
01222:  CLR     1610
.................... 	} 
01224:  GOTO    122E
.................... 	else 
.................... 	{ 
.................... 		Position = -48576; 
01228:  MOV     #4240,W4
0122A:  MOV     W4,160E
0122C:  SETM    1610
.................... 	}		 
....................  
.................... 	if(_ZeroPoint == 0 && Etat == 0) return(1); 
0122E:  BTSC.B  2C2.7
01230:  BRA     1244
01232:  MOV.B   1612,W0L
01234:  SE      W0,W0
01236:  CP0     W0
01238:  BRA     NZ,1244
0123A:  MOV.B   #1,W0L
0123C:  MOV.B   W0L,0
0123E:  BRA     12B4
01240:  GOTO    12B4
.................... 	else 
.................... 	{	 
.................... 		if(Etat!=1) 
01244:  MOV.B   1612,W0L
01246:  SE      W0,W0
01248:  CP      W0,#1
0124A:  BRA     Z,1286
.................... 		{ 
.................... 			if(!read) 
0124C:  BTSC.B  1604.7
0124E:  BRA     1258
.................... 			{ 
.................... 				//ActualPosition = read_pos_moteur(0xC2); // on prend la pos du moteur 
.................... 				delay_ms(20); 
01250:  MOV     #14,W0
01252:  CALL    EBE
.................... 				read = 1; 
01256:  BSET.B  1604.7
.................... 			}		 
.................... 			Etat = go_driver_moteur(0xC2,0,DRV_MODE_VITESSE,100,DRV_ARRET_POSITION_RELATIVE,Position);//ABSOLUE,(64768 + ActualPosition));	 
01258:  MOV.B   #C2,W0L
0125A:  MOV.B   W0L,1B60
0125C:  CLR.B   1B61
0125E:  MOV.B   #1,W0L
01260:  MOV.B   W0L,1B62
01262:  MOV.B   #2,W0L
01264:  MOV.B   W0L,1B63
01266:  MOV     #64,W4
01268:  MOV     W4,1B64
0126A:  PUSH    160E
0126C:  POP     1B66
0126E:  PUSH    1610
01270:  POP     1B68
01272:  CALL    10FE
01276:  MOV.B   W0L,1612
.................... 			delay_ms(20); 
01278:  MOV     #14,W0
0127A:  CALL    EBE
.................... 			return(0); 
0127E:  CLR.B   0
01280:  BRA     12B4
.................... 		} 
01282:  GOTO    12B4
.................... 		else 
.................... 		{ 
.................... 			if(!_ZeroPoint) 
01286:  BTSC.B  2C2.7
01288:  BRA     12B0
.................... 			{ 
.................... 				Etat = 0; 
0128A:  CLR.B   1612
.................... 				read = 0; 
0128C:  BCLR.B  1604.7
.................... 				driver_moteur(0xC2,0); //arrêt du driver 
0128E:  MOV.B   #C2,W0L
01290:  MOV.B   W0L,1B5C
01292:  CLR.B   1B5D
01294:  CALL    11BE
.................... 				if(obj_Action==8)Action_send = 0; 
01298:  MOV     14A4,W4
0129A:  CP      W4,#8
0129C:  BRA     NZ,12A4
0129E:  BCLR.B  85B.7
012A0:  GOTO    12A6
.................... 				else Action_send=1; 
012A4:  BSET.B  85B.7
.................... 				return(1); 
012A6:  MOV.B   #1,W0L
012A8:  MOV.B   W0L,0
012AA:  BRA     12B4
.................... 			} 
012AC:  GOTO    12B4
.................... 			else return(0); 
012B0:  CLR.B   0
012B2:  BRA     12B4
.................... 		} 
.................... 	} 
012B4:  MOV     [--W15],W5
012B6:  RETURN  
.................... } 
.................... //================================================================================================================================================================================================= 
.................... // Fonction 	: __Check_action_end																														 
.................... //================================================================================================================================================================================================= 
.................... //	Développé par:		: Borgeat Remy   
.................... //						:   												 
.................... //  Date				: 28.02.2017															 
.................... //  Date de modif.		: 															 
.................... //-------------------------------------------------------------------------------------------------------------------------------------------------------------																 
.................... // Description 	:	Fonction qui check l'etat du driver moteur 
.................... // 				: 	En cas de surcharge ou driver pas connecte --> on affiche l'erreur 
.................... //				: 	En cas de surchauffe --> on attend 1s pour renvoyer l'ordre 
.................... // paramètres 	:	Addresse du driver 
.................... // retourne 	:	1 -> ordre fini, 0 -> ordre en cours ou erreur	 
.................... //=================================================================================================================================================================================================== 
.................... int1 __Check_action_end(unsigned int8 driver_address) 
*
01438:  MOV     W5,[W15++]
0143A:  MOV     W6,[W15++]
0143C:  CLR     1B5A
.................... { 
.................... 	static unsigned int32 Time_ms = 0; 
.................... 	static signed int16 impulses_toDo = 0; 
.................... 	signed int16 ActualPosition = 0; 
.................... 	static unsigned int8 passage_erreur = 0; 
.................... 	static unsigned int8 Etat_d = 1; 
.................... 	static unsigned int1 ok = 0; 
.................... 	static unsigned int8 Etat = 0; 
.................... 	static unsigned int1 read = 0; 
.................... 	static unsigned int8 Etat_driver = 0; 
.................... 	Etat_d = read_driver_moteur(driver_address); 
0143E:  MOV.B   1B58,W0L
01440:  MOV.B   W0L,1B6A
01442:  CALL    12E2
01446:  MOV.B   W0L,161A
.................... 	delay_ms(20); 
01448:  MOV     #14,W0
0144A:  CALL    EBE
....................  
.................... 	switch(Etat_d) 
0144E:  MOV.B   161A,W0L
01450:  CLR.B   1
01452:  XOR     #0,W0
01454:  BRA     Z,146C
01456:  XOR     #1,W0
01458:  BRA     Z,147C
0145A:  XOR     #3,W0
0145C:  BRA     Z,14BC
0145E:  XOR     #1,W0
01460:  BRA     Z,15C6
01462:  XOR     #7,W0
01464:  BRA     Z,17A0
01466:  XOR     #1,W0
01468:  BRA     Z,17E0
0146A:  BRA     181E
.................... 	{ 
.................... 		case 0:  
.................... 			Erreur_max_surchauffe = 0; 
0146C:  CLR.B   881
.................... 			Time_ms = 0; 
0146E:  CLR     1614
01470:  CLR     1616
.................... 			return(1); //driver arreter --> ordre fini  
01472:  MOV.B   #1,W0L
01474:  MOV.B   W0L,0
01476:  BRA     181E
.................... 			break;	 
01478:  GOTO    181E
.................... 			 
.................... 		case 1:	//en cours 
.................... 			 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(10); 
0147C:  MOV     1B58,W4
0147E:  XOR.B   #C0,W4L
01480:  BRA     NZ,1490
01482:  MOV.B   #A,W0L
01484:  MOV.B   W0L,1B5C
01486:  CLR.B   1B5D
01488:  CALL    1338
0148C:  GOTO    14B4
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(11); 
01490:  MOV     1B58,W4
01492:  XOR.B   #C2,W4L
01494:  BRA     NZ,14A4
01496:  MOV.B   #B,W0L
01498:  MOV.B   W0L,1B5C
0149A:  CLR.B   1B5D
0149C:  CALL    1338
014A0:  GOTO    14B4
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(12); 
014A4:  MOV     1B58,W4
014A6:  XOR.B   #C4,W4L
014A8:  BRA     NZ,14B4
014AA:  MOV.B   #C,W0L
014AC:  MOV.B   W0L,1B5C
014AE:  CLR.B   1B5D
014B0:  CALL    1338
....................  
.................... 			return(0);//driver en mouvement, ou en erreur --> on renvoie 0	 
014B4:  CLR.B   0
014B6:  BRA     181E
.................... 			break; 
014B8:  GOTO    181E
.................... 					 
.................... 		case 2: // surcharge on tire plus de courant que le maximum configure 
.................... 	 
.................... 			if(driver_address==0xC0) 
014BC:  MOV     1B58,W4
014BE:  XOR.B   #C0,W4L
014C0:  BRA     NZ,159C
.................... 			{ 
.................... 				while(!ok) 
014C2:  BTSC.B  161B.0
014C4:  BRA     1598
.................... 				{ 
.................... 					switch(Etat) 
014C6:  MOV.B   161C,W0L
014C8:  CLR.B   1
014CA:  XOR     #0,W0
014CC:  BRA     Z,14D4
014CE:  XOR     #1,W0
014D0:  BRA     Z,152E
014D2:  BRA     1594
.................... 					{ 
.................... 						case 0: 
.................... 							if(!read) 
014D4:  BTSC.B  161B.1
014D6:  BRA     14EE
.................... 							{ 
.................... 								driver_moteur(0xC0,0); 
014D8:  MOV.B   #C0,W0L
014DA:  MOV.B   W0L,1B5C
014DC:  CLR.B   1B5D
014DE:  CALL    11BE
.................... 								ActualPosition = read_pos_moteur(0xC0); // on prend la pos du moteur 
014E2:  MOV.B   #C0,W0L
014E4:  MOV.B   W0L,1B5C
014E6:  CALL    138C
014EA:  MOV     W0,1B5A
.................... 								read = 1; 
014EC:  BSET.B  161B.1
.................... 							} 
.................... 							if(Etat_driver!=1) // on fait deplacer le moteur ds un sens(si quelquechose le coince) 
014EE:  MOV     161C,W4
014F0:  LSR     W4,#8,W4
014F2:  CP.B    W4L,#1
014F4:  BRA     Z,1524
.................... 							{ 
.................... 								Etat_driver = go_driver_moteur(0xC0,1,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition-250)); 
014F6:  MOV     1B5A,W4
014F8:  SUB     #FA,W4
014FA:  MOV     W4,W5
014FC:  MOV.B   #C0,W0L
014FE:  MOV.B   W0L,1B60
01500:  MOV.B   #1,W0L
01502:  MOV.B   W0L,1B61
01504:  MOV.B   #1,W0L
01506:  MOV.B   W0L,1B62
01508:  MOV.B   #1,W0L
0150A:  MOV.B   W0L,1B63
0150C:  PUSH    15E4
0150E:  POP     1B64
01510:  MOV     W5,1B66
01512:  CLR     W4
01514:  BTSC.B  1B67.7
01516:  SETM    W4
01518:  MOV     W4,1B68
0151A:  CALL    10FE
0151E:  MOV.B   W0L,161D
.................... 							} 
01520:  GOTO    152A
.................... 							else 
.................... 							{ 
.................... 								Etat_driver = 0; 
01524:  CLR.B   161D
.................... 								Etat++; // passe au depl suivant 
01526:  INC.B   161C
.................... 								read = 0; 
01528:  BCLR.B  161B.1
.................... 							} 
.................... 							break; 
0152A:  GOTO    1594
.................... 						case 1://retourne a la postion  
.................... 							Etat_d = read_driver_moteur(0xC0); 
0152E:  MOV.B   #C0,W0L
01530:  MOV.B   W0L,1B6A
01532:  CALL    12E2
01536:  MOV.B   W0L,161A
.................... 							if(Etat_d == 0) 
01538:  CP0.B   161A
0153A:  BRA     NZ,1590
.................... 							{ 
.................... 								if(!read) 
0153C:  BTSC.B  161B.1
0153E:  BRA     155A
.................... 								{ 
.................... 									ActualPosition = ActualPosition - 250; 
01540:  MOV     1B5A,W4
01542:  SUB     #FA,W4
01544:  MOV     W4,1B5A
.................... 									impulses_toDo = EndPosition - ActualPosition ; 
01546:  MOV     1B5A,W0
01548:  CLR     W1
0154A:  BTSC    W0.F
0154C:  SETM    W1
0154E:  MOV     15E6,W4
01550:  SUB     W4,W0,W0
01552:  MOV     15E8,W4
01554:  SUBB    W4,W1,W1
01556:  MOV     W0,1618
.................... 									read = 1;   
01558:  BSET.B  161B.1
.................... 								} 
.................... 								if(Etat_driver!=1) 
0155A:  MOV     161C,W4
0155C:  LSR     W4,#8,W4
0155E:  CP.B    W4L,#1
01560:  BRA     Z,158E
.................... 								{ 
.................... 									Etat_driver = go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,(ActualPosition + impulses_toDo)); 
01562:  MOV     1B5A,W0
01564:  ADD     1618,W0
01566:  MOV     W0,W5
01568:  MOV.B   #C0,W0L
0156A:  MOV.B   W0L,1B60
0156C:  CLR.B   1B61
0156E:  MOV.B   #1,W0L
01570:  MOV.B   W0L,1B62
01572:  MOV.B   #1,W0L
01574:  MOV.B   W0L,1B63
01576:  PUSH    15E4
01578:  POP     1B64
0157A:  MOV     W5,1B66
0157C:  CLR     W4
0157E:  BTSC.B  1B67.7
01580:  SETM    W4
01582:  MOV     W4,1B68
01584:  CALL    10FE
01588:  MOV.B   W0L,161D
.................... 									 
.................... 								} 
0158A:  GOTO    1590
.................... 								else 
.................... 								{ 
.................... 									ok = 1;  
0158E:  BSET.B  161B.0
.................... 								} 
.................... 							}								 
.................... 							break; 
01590:  GOTO    1594
.................... 					} 
01594:  GOTO    14C2
.................... 					} 
.................... 			} 
01598:  GOTO    15BC
.................... 			else if(driver_address==0xC2) __Affichage_erreur(11); // surcharge ejection 
0159C:  MOV     1B58,W4
0159E:  XOR.B   #C2,W4L
015A0:  BRA     NZ,15AE
015A2:  MOV.B   #B,W0L
015A4:  MOV.B   W0L,1B5C
015A6:  CALL    102A
015AA:  GOTO    15BC
.................... 			else if(driver_address==0xC4) __Affichage_erreur(12); // surcharge cremaillere		 
015AE:  MOV     1B58,W4
015B0:  XOR.B   #C4,W4L
015B2:  BRA     NZ,15BC
015B4:  MOV.B   #C,W0L
015B6:  MOV.B   W0L,1B5C
015B8:  CALL    102A
.................... 			ok = 0; 
015BC:  BCLR.B  161B.0
.................... 			return(0); 
015BE:  CLR.B   0
015C0:  BRA     181E
.................... 			break; 
015C2:  GOTO    181E
.................... 			 
.................... 		case 3: // surchauffe pont-h 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(16); 
015C6:  MOV     1B58,W4
015C8:  XOR.B   #C0,W4L
015CA:  BRA     NZ,15DA
015CC:  MOV.B   #10,W0L
015CE:  MOV.B   W0L,1B5C
015D0:  CLR.B   1B5D
015D2:  CALL    1338
015D6:  GOTO    15FE
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(17); 
015DA:  MOV     1B58,W4
015DC:  XOR.B   #C2,W4L
015DE:  BRA     NZ,15EE
015E0:  MOV.B   #11,W0L
015E2:  MOV.B   W0L,1B5C
015E4:  CLR.B   1B5D
015E6:  CALL    1338
015EA:  GOTO    15FE
.................... 			else if(driver_address==0xC4) __Afficheur_7segments(18); 
015EE:  MOV     1B58,W4
015F0:  XOR.B   #C4,W4L
015F2:  BRA     NZ,15FE
015F4:  MOV.B   #12,W0L
015F6:  MOV.B   W0L,1B5C
015F8:  CLR.B   1B5D
015FA:  CALL    1338
.................... 			 
.................... 			if(Time_ms==0)Time_ms = GameTimeMS; 
015FE:  CP0     1614
01600:  BRA     NZ,1612
01602:  CP0     1616
01604:  BRA     NZ,1612
01606:  PUSH    86A
01608:  POP     1614
0160A:  PUSH    86C
0160C:  POP     1616
0160E:  GOTO    1798
.................... 			else if(GameTimeMS - Time_ms >= TIME_SURCHAUFFE_MS)//on attend 1s 
01612:  MOV     86A,W4
01614:  MOV     1614,W3
01616:  SUB     W4,W3,W5
01618:  MOV     86C,W4
0161A:  MOV     1616,W3
0161C:  SUBB    W4,W3,W6
0161E:  CP      W6,#0
01620:  BRA     NC,1798
01622:  BRA     GTU,162A
01624:  MOV     C06,W4
01626:  CP      W4,W5
01628:  BRA     GTU,1798
.................... 			{ 
.................... 				Time_ms = 0; 
0162A:  CLR     1614
0162C:  CLR     1616
.................... 				 
.................... 				if(driver_address == 0xC0)//moteur barillet 
0162E:  MOV     1B58,W4
01630:  XOR.B   #C0,W4L
01632:  BRA     NZ,168E
.................... 				{ 
.................... 					ActualPosition = read_pos_moteur(0xC0); //on reprend l'ordre 
01634:  MOV.B   #C0,W0L
01636:  MOV.B   W0L,1B5C
01638:  CALL    138C
0163C:  MOV     W0,1B5A
.................... 					if((ActualPosition-EndPosition)!= 0) 
0163E:  MOV     1B5A,W0
01640:  CLR     W1
01642:  BTSC    W0.F
01644:  SETM    W1
01646:  MOV     15E6,W4
01648:  SUB     W0,W4,W5
0164A:  MOV     15E8,W4
0164C:  SUBB    W1,W4,W6
0164E:  CP0     W5
01650:  BRA     NZ,1656
01652:  CP0     W6
01654:  BRA     Z,168A
.................... 					{ 
.................... 						impulses_toDo = EndPosition - ActualPosition ;  
01656:  MOV     1B5A,W0
01658:  CLR     W1
0165A:  BTSC    W0.F
0165C:  SETM    W1
0165E:  MOV     15E6,W4
01660:  SUB     W4,W0,W0
01662:  MOV     15E8,W4
01664:  SUBB    W4,W1,W1
01666:  MOV     W0,1618
.................... 						go_driver_moteur(0xC0,0,DRV_MODE_VITESSE,soll_vit_mov,DRV_ARRET_POSITION_ABSOLUE,impulses_toDo); 
01668:  MOV.B   #C0,W0L
0166A:  MOV.B   W0L,1B60
0166C:  CLR.B   1B61
0166E:  MOV.B   #1,W0L
01670:  MOV.B   W0L,1B62
01672:  MOV.B   #1,W0L
01674:  MOV.B   W0L,1B63
01676:  PUSH    15E4
01678:  POP     1B64
0167A:  PUSH    1618
0167C:  POP     1B66
0167E:  CLR     W4
01680:  BTSC.B  1B67.7
01682:  SETM    W4
01684:  MOV     W4,1B68
01686:  CALL    10FE
.................... 					} 
.................... 				} 
0168A:  GOTO    175A
.................... 				else if(driver_address == 0xC2)//moteur qui couche les modules 
0168E:  MOV     1B58,W4
01690:  XOR.B   #C2,W4L
01692:  BRA     NZ,1716
.................... 				{ 
.................... 					if((GameTimeMS-Time_ejection)<Time_ejection_toDo) 
01694:  MOV     86A,W4
01696:  MOV     C08,W3
01698:  SUB     W4,W3,W5
0169A:  MOV     86C,W4
0169C:  MOV     C0A,W3
0169E:  SUBB    W4,W3,W6
016A0:  MOV     C0E,W4
016A2:  CP      W4,W6
016A4:  BRA     NC,1712
016A6:  BRA     GTU,16AE
016A8:  MOV     C0C,W4
016AA:  CP      W4,W5
016AC:  BRA     LEU,1712
.................... 					{ 
.................... 						Time_ejection_toDo = Time_ejection_toDo - (GameTimeMS-Time_ejection); //calcul du temps qu'il reste a faire 
016AE:  MOV     86A,W4
016B0:  MOV     C08,W3
016B2:  SUB     W4,W3,W0
016B4:  MOV     86C,W4
016B6:  MOV     C0A,W3
016B8:  SUBB    W4,W3,W1
016BA:  MOV     C0C,W4
016BC:  SUB     W4,W0,W0
016BE:  MOV     W0,C0C
016C0:  MOV     C0E,W4
016C2:  SUBB    W4,W1,W0
016C4:  MOV     W0,C0E
.................... 						//renvoi de la suite de l'ordre 
.................... 						if(Etat_ejection == 1) go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,100,DRV_ARRET_TEMPS, Time_ejection_toDo);						 
016C6:  MOV     15E0,W4
016C8:  LSR     W4,#8,W4
016CA:  CP.B    W4L,#1
016CC:  BRA     NZ,16F2
016CE:  MOV.B   #C2,W0L
016D0:  MOV.B   W0L,1B60
016D2:  MOV.B   #1,W0L
016D4:  MOV.B   W0L,1B61
016D6:  MOV.B   #2,W0L
016D8:  MOV.B   W0L,1B62
016DA:  MOV.B   #3,W0L
016DC:  MOV.B   W0L,1B63
016DE:  MOV     #64,W4
016E0:  MOV     W4,1B64
016E2:  PUSH    C0C
016E4:  POP     1B66
016E6:  PUSH    C0E
016E8:  POP     1B68
016EA:  CALL    10FE
016EE:  GOTO    1712
.................... 						else go_driver_moteur(0xC2,1,DRV_MODE_NON_REGUL,25,DRV_ARRET_TEMPS,Time_ejection_toDo); 
016F2:  MOV.B   #C2,W0L
016F4:  MOV.B   W0L,1B60
016F6:  MOV.B   #1,W0L
016F8:  MOV.B   W0L,1B61
016FA:  MOV.B   #2,W0L
016FC:  MOV.B   W0L,1B62
016FE:  MOV.B   #3,W0L
01700:  MOV.B   W0L,1B63
01702:  MOV     #19,W4
01704:  MOV     W4,1B64
01706:  PUSH    C0C
01708:  POP     1B66
0170A:  PUSH    C0E
0170C:  POP     1B68
0170E:  CALL    10FE
.................... 					}	 
.................... 				} 
01712:  GOTO    175A
.................... 				else if(driver_address == 0xC4) 
01716:  MOV     1B58,W4
01718:  XOR.B   #C4,W4L
0171A:  BRA     NZ,175A
.................... 				{ 
.................... 					if(bras_out)go_driver_moteur(0xC4,0,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200); // rentre le bras 
0171C:  BTSS.B  14B7.5
0171E:  BRA     173E
01720:  MOV.B   #C4,W0L
01722:  MOV.B   W0L,1B60
01724:  CLR.B   1B61
01726:  MOV.B   #2,W0L
01728:  MOV.B   W0L,1B62
0172A:  CLR.B   1B63
0172C:  MOV     #64,W4
0172E:  MOV     W4,1B64
01730:  MOV     #C8,W4
01732:  MOV     W4,1B66
01734:  CLR     1B68
01736:  CALL    10FE
0173A:  GOTO    175A
.................... 					else go_driver_moteur(0xC4,1,DRV_MODE_NON_REGUL ,100,DRV_ARRET_COURANT,200);	   // sort le bras		 
0173E:  MOV.B   #C4,W0L
01740:  MOV.B   W0L,1B60
01742:  MOV.B   #1,W0L
01744:  MOV.B   W0L,1B61
01746:  MOV.B   #2,W0L
01748:  MOV.B   W0L,1B62
0174A:  CLR.B   1B63
0174C:  MOV     #64,W4
0174E:  MOV     W4,1B64
01750:  MOV     #C8,W4
01752:  MOV     W4,1B66
01754:  CLR     1B68
01756:  CALL    10FE
.................... 				} 
.................... 				passage_erreur++; 
0175A:  INC.B   1613
.................... 				if(passage_erreur > Erreur_max_surchauffe)// si on a 10 erreurs a la suite de surchauffe 
0175C:  MOV.B   881,W0L
0175E:  MOV     1612,W4
01760:  LSR     W4,#8,W4
01762:  CP.B    W4L,W0L
01764:  BRA     LEU,1798
.................... 				{ 
.................... 					if(driver_address == 0xC0)    __Affichage_erreur(13); //surcahuffe driver barrilet 
01766:  MOV     1B58,W4
01768:  XOR.B   #C0,W4L
0176A:  BRA     NZ,1778
0176C:  MOV.B   #D,W0L
0176E:  MOV.B   W0L,1B5C
01770:  CALL    102A
01774:  GOTO    1798
.................... 					else if(driver_address==0xC2) __Affichage_erreur(14); //surchauffe driver ejection 
01778:  MOV     1B58,W4
0177A:  XOR.B   #C2,W4L
0177C:  BRA     NZ,178A
0177E:  MOV.B   #E,W0L
01780:  MOV.B   W0L,1B5C
01782:  CALL    102A
01786:  GOTO    1798
.................... 					else if(driver_address==0xC4) __Affichage_erreur(15); //surchauffe driver cremaillere	 
0178A:  MOV     1B58,W4
0178C:  XOR.B   #C4,W4L
0178E:  BRA     NZ,1798
01790:  MOV.B   #F,W0L
01792:  MOV.B   W0L,1B5C
01794:  CALL    102A
.................... 				} 
.................... 				 
.................... 			} 	 
.................... 			return(0);						 
01798:  CLR.B   0
0179A:  BRA     181E
.................... 			break; 
0179C:  GOTO    181E
.................... 		case 4://processing 
.................... 			if(driver_address==0xC0)__Afficheur_7segments(13); 
017A0:  MOV     1B58,W4
017A2:  XOR.B   #C0,W4L
017A4:  BRA     NZ,17B4
017A6:  MOV.B   #D,W0L
017A8:  MOV.B   W0L,1B5C
017AA:  CLR.B   1B5D
017AC:  CALL    1338
017B0:  GOTO    17D8
.................... 			else if(driver_address==0xC2) __Afficheur_7segments(14); 
017B4:  MOV     1B58,W4
017B6:  XOR.B   #C2,W4L
017B8:  BRA     NZ,17C8
017BA:  MOV.B   #E,W0L
017BC:  MOV.B   W0L,1B5C
017BE:  CLR.B   1B5D
017C0:  CALL    1338
017C4:  GOTO    17D8
.................... 			else if(driver_address==0xC4)__Afficheur_7segments(15); 
017C8:  MOV     1B58,W4
017CA:  XOR.B   #C4,W4L
017CC:  BRA     NZ,17D8
017CE:  MOV.B   #F,W0L
017D0:  MOV.B   W0L,1B5C
017D2:  CLR.B   1B5D
017D4:  CALL    1338
.................... 			return(0);  
017D8:  CLR.B   0
017DA:  BRA     181E
.................... 			break;  
017DC:  GOTO    181E
.................... 		case 5://slave ne repond pas 
.................... 			if(driver_address == 0xC0)    __Affichage_erreur(16); //driver barillet ne repond pas 
017E0:  MOV     1B58,W4
017E2:  XOR.B   #C0,W4L
017E4:  BRA     NZ,17F2
017E6:  MOV.B   #10,W0L
017E8:  MOV.B   W0L,1B5C
017EA:  CALL    102A
017EE:  GOTO    1816
.................... 			else if(driver_address==0xC2) __Affichage_erreur(17); //driver ejection ne repond pas 
017F2:  MOV     1B58,W4
017F4:  XOR.B   #C2,W4L
017F6:  BRA     NZ,1804
017F8:  MOV.B   #11,W0L
017FA:  MOV.B   W0L,1B5C
017FC:  CALL    102A
01800:  GOTO    1816
.................... 			else if(driver_address==0xC4) __Affichage_erreur(18); //driver cremaillere ne repond pas			 
01804:  MOV     1B58,W4
01806:  XOR.B   #C4,W4L
01808:  BRA     NZ,1816
0180A:  MOV.B   #12,W0L
0180C:  MOV.B   W0L,1B5C
0180E:  CALL    102A
01812:  GOTO    1816
.................... 			else ;//__Affichage_erreur();	 
.................... 			return(0);			 
01816:  CLR.B   0
01818:  BRA     181E
.................... 			break; 
0181A:  GOTO    181E
.................... 	} 
0181E:  MOV     [--W15],W6
01820:  MOV     [--W15],W5
01822:  RETURN  
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "PC/___PC.h" 
.................... /* 
.................... * \file ___PC.h 
.................... * \brief Gère la communication PC (defs.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_H 
.................... #define ___PC_H 
....................  
....................  
....................  
.................... // Config RS232 
.................... #use rs232(baud=115200,parity=N,xmit=PIN_F3,rcv=PIN_F2,bits=8,stream=RS232) 
.................... // Config UART 
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_F5,rcv=PIN_F4,bits=8,stream=UARTi) 
....................  
.................... // Définit quand un tableau est à décoder 
.................... int1 PCh_flagUARTReadyToDecode = 0; 
.................... // Watchdog pour éviter un blocage UART 
.................... int1 PCh_flagUARTWatchdog = 0; 
....................  
....................  
.................... void __Init_UART(void);	// Initialise 
.................... void __UART_Decode(unsigned int32* _Tab);	// Décode une trame 
.................... void __SendBackUART(void); // Renvoi la dernière commande envoyée 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec); // Décode un tableau 
.................... #include "PC/___PC.c" 
.................... /* 
.................... * \file ___PC.c 
.................... * \brief Gère la communication PC (fcts.) 
.................... * \ EMVs Eurobot - Driver Moteur 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * \copyright GNU Public License 
.................... */ 
....................  
.................... #ifndef ___PC_C 
.................... #define ___PC_C 
....................  
.................... // Bits & define 
.................... 	// Contient la trame à décoder 
.................... unsigned int8 TabToDecode[256]={0}; 
.................... unsigned int8 PosTabToDecode = 0; 
.................... unsigned int8 ToDoUART = 0; 
.................... 	// Contient les valeurs décodées 
.................... unsigned int32 TabDecoded[256]={0}; 
.................... 	// Attend une réponse 
.................... int1 UARTWaitResp=0; 
.................... 	// Nombre de fois à renvoyer 
.................... unsigned int8 UARTToSendBack=0; 
.................... 	 
....................  
.................... /** 
.................... * \fn void __Init_UART(void) 
.................... * \brief Initie l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __Init_UART(void) 
.................... { 
.................... 	// Réception 
.................... 	enable_interrupts(INT_RDA); 
*
01026:  BSET.B  8D.1
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
01028:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void RDA_isr(void) 
.................... * \brief Interruption RDA, récupère les caractères du RS232. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... */ 
.................... #INT_RDA 
.................... void RDA_isr(void) 
*
00908:  PUSH    42
0090A:  PUSH    36
0090C:  PUSH    32
0090E:  MOV     W0,[W15++]
00910:  MOV     #2,W0
00912:  REPEAT  #C
00914:  MOV     [W0++],[W15++]
.................... {	 
.................... 	// Checksum UART 
.................... 	static unsigned int8 HashR1, HashR2, HashC1, HashC2; 
.................... 	if(PCh_flagUARTReadyToDecode==0) 
00916:  BTSC.B  161B.2
00918:  BRA     A7C
.................... 	{ 
.................... 		// Active le watchdog UART 
.................... 		PCh_flagUARTWatchdog = 1; 
0091A:  BSET.B  161B.3
.................... 		// Traite la réception 
.................... 		while(kbhit(RS232)) 
0091C:  BTSS.B  20E.0
0091E:  BRA     A7C
.................... 		{ 
.................... 			// Récupération donnée 
.................... 			unsigned int8 Dataa = fgetc(RS232); 
00920:  BTSS.B  20E.0
00922:  BRA     920
00924:  MOV     212,W0
00926:  MOV.B   W0L,1D8C
.................... 			 
.................... 			// Si c'est une réponse à un envoi, on remet à 0 l'attente de réponse et la fausse erreur 
.................... 			if(UARTWaitResp && Dataa==ACK)  
00928:  BTSS.B  161B.4
0092A:  BRA     93A
0092C:  MOV     1D8C,W4
0092E:  CP.B    W4L,#6
00930:  BRA     NZ,93A
.................... 			{ 
.................... 				UARTWaitResp=0; 
00932:  BCLR.B  161B.4
.................... 				UARTToSendBack=0; 
00934:  CLR.B   1B20
.................... 				 
.................... 			}	 
00936:  GOTO    A78
.................... 			// Si ce n'est pas OK, renvoie un certain nombre de fois 
.................... 			else if(UARTWaitResp && Dataa==NAK) 
0093A:  BTSS.B  161B.4
0093C:  BRA     960
0093E:  MOV     1D8C,W4
00940:  CP.B    W4L,#15
00942:  BRA     NZ,960
.................... 			{ 
.................... 				if(UARTToSendBack<UART_NBR_REP_NAK) {__SendBackUART();UARTToSendBack++;} 
00944:  MOV.B   1B20,W0L
00946:  MOV     14B0,W4
00948:  LSR     W4,#8,W4
0094A:  CP.B    W4L,W0L
0094C:  BRA     LEU,958
0094E:  CALL    5EC
00952:  INC.B   1B20
00954:  GOTO    95C
.................... 				else {UARTWaitResp=0;UARTToSendBack=0;} 
00958:  BCLR.B  161B.4
0095A:  CLR.B   1B20
.................... 			} 
0095C:  GOTO    A78
.................... 			// Réception 
.................... 			else 
.................... 			{	 
.................... 				// Début de transmission 
.................... 				if(Dataa == STX&&ToDoUART==0) 
00960:  MOV     1D8C,W4
00962:  CP.B    W4L,#2
00964:  BRA     NZ,97A
00966:  CP0.B   171F
00968:  BRA     NZ,97A
.................... 				{ 
.................... 					HashC1 = HashC2 = 0; 
0096A:  CLR.B   1B24
0096C:  MOV.B   1B24,W0L
0096E:  MOV.B   W0L,1B23
.................... 					ToDoUART=1;  
00970:  MOV.B   #1,W0L
00972:  MOV.B   W0L,171F
.................... 					PosTabToDecode=0; 
00974:  CLR.B   171E
.................... 				} 
00976:  GOTO    A78
.................... 				// Fin de transmission 
.................... 				else if(Dataa == ETX&&ToDoUART==5)		 
0097A:  MOV     1D8C,W4
0097C:  CP.B    W4L,#3
0097E:  BRA     NZ,A00
00980:  MOV     171E,W4
00982:  LSR     W4,#8,W4
00984:  CP.B    W4L,#5
00986:  BRA     NZ,A00
.................... 				{		 
.................... 					if(HashC1==ETX||HashC1==CR)HashC1++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
00988:  MOV     1B22,W4
0098A:  LSR     W4,#8,W4
0098C:  CP.B    W4L,#3
0098E:  BRA     Z,998
00990:  MOV     1B22,W4
00992:  LSR     W4,#8,W4
00994:  CP.B    W4L,#D
00996:  BRA     NZ,99A
00998:  INC.B   1B23
.................... 					if(HashC2==ETX||HashC2==CR)HashC2++; // Pour éviter de détecter une fausse fin de tableau, le caractère ETC doit être réservé. 
0099A:  MOV     1B24,W4
0099C:  CP.B    W4L,#3
0099E:  BRA     Z,9A6
009A0:  MOV     1B24,W4
009A2:  CP.B    W4L,#D
009A4:  BRA     NZ,9A8
009A6:  INC.B   1B24
.................... 					// Si trame OK 
.................... 					if(HashC1==HashR1 && HashC2==HashR2) 
009A8:  MOV.B   1B23,W0L
009AA:  CP.B    1B21
009AC:  BRA     NZ,9EA
009AE:  MOV.B   1B24,W0L
009B0:  CP.B    1B22
009B2:  BRA     NZ,9EA
.................... 					{ 
.................... 						TabToDecode[PosTabToDecode] = ETX; 
009B4:  MOV     171E,W4
009B6:  CLR.B   9
009B8:  MOV     #161E,W3
009BA:  ADD     W4,W3,W5
009BC:  MOV.B   #3,W0L
009BE:  MOV.B   W0L,[W5]
.................... 						// Décode le tableau 
.................... 						__CommDecode(TabToDecode,TabDecoded); 
009C0:  MOV     #161E,W4
009C2:  MOV     W4,1D8E
009C4:  MOV     #1720,W4
009C6:  MOV     W4,1D90
009C8:  CALL    88C
.................... 						if(TabDecoded[0]==UART_ADDR) 
009CC:  MOV     1720,W0
009CE:  CP      14B2
009D0:  BRA     NZ,9E6
009D2:  MOV     1722,W0
009D4:  CP      14B4
009D6:  BRA     NZ,9E6
.................... 						{	 
.................... 							// Dit qu'on est prêts à recevoir 
.................... 							PCh_flagUARTReadyToDecode=1; 
009D8:  BSET.B  161B.2
.................... 							// Renvoie un simple OK 
.................... 							fputc(ACK,RS232); 
009DA:  MOV.B   #6,W0L
009DC:  BTSC.B  20F.1
009DE:  BRA     9DC
009E0:  MOV.B   W0L,210
009E2:  CLR.B   211
.................... 							// Dit qu'on attend une réponse 
.................... 							UARTWaitResp=1; 
009E4:  BSET.B  161B.4
.................... 						}	 
.................... 					} 
009E6:  GOTO    9F4
.................... 					else fputc(NAK,RS232); // Erreur de réception, envoi un pas ok 
009EA:  MOV.B   #15,W0L
009EC:  BTSC.B  20F.1
009EE:  BRA     9EC
009F0:  MOV.B   W0L,210
009F2:  CLR.B   211
.................... 					ToDoUART = 0; 
009F4:  CLR.B   171F
.................... 					PosTabToDecode=0; 
009F6:  CLR.B   171E
.................... 					UARTToSendBack=0; 
009F8:  CLR.B   1B20
.................... 					// Désactive le watchdog UART 
.................... 					PCh_flagUARTWatchdog = 0; 
009FA:  BCLR.B  161B.3
.................... 				} 
009FC:  GOTO    A78
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==1)ToDoUART=2; 
00A00:  MOV     171E,W4
00A02:  LSR     W4,#8,W4
00A04:  CP.B    W4L,#1
00A06:  BRA     NZ,A10
00A08:  MOV.B   #2,W0L
00A0A:  MOV.B   W0L,171F
00A0C:  GOTO    A78
.................... 				// Enregistre le premier Hash 
.................... 				else if(ToDoUART==2) 
00A10:  MOV     171E,W4
00A12:  LSR     W4,#8,W4
00A14:  CP.B    W4L,#2
00A16:  BRA     NZ,A24
.................... 				{ 
.................... 					HashR1 = Dataa; 
00A18:  MOV.B   1D8C,W0L
00A1A:  MOV.B   W0L,1B21
.................... 					ToDoUART=3;	 
00A1C:  MOV.B   #3,W0L
00A1E:  MOV.B   W0L,171F
.................... 				}	 
00A20:  GOTO    A78
.................... 				// Saute l'espace 
.................... 				else if(ToDoUART==3)ToDoUART=4; 
00A24:  MOV     171E,W4
00A26:  LSR     W4,#8,W4
00A28:  CP.B    W4L,#3
00A2A:  BRA     NZ,A34
00A2C:  MOV.B   #4,W0L
00A2E:  MOV.B   W0L,171F
00A30:  GOTO    A78
.................... 				// Enregistre le second Hash 
.................... 				else if(ToDoUART==4) 
00A34:  MOV     171E,W4
00A36:  LSR     W4,#8,W4
00A38:  CP.B    W4L,#4
00A3A:  BRA     NZ,A48
.................... 				{ 
.................... 					HashR2 = Dataa; 
00A3C:  MOV.B   1D8C,W0L
00A3E:  MOV.B   W0L,1B22
.................... 					ToDoUART=5; 
00A40:  MOV.B   #5,W0L
00A42:  MOV.B   W0L,171F
.................... 				} 
00A44:  GOTO    A78
.................... 				// Capture la trame 
.................... 				else if(ToDoUART == 5)  
00A48:  MOV     171E,W4
00A4A:  LSR     W4,#8,W4
00A4C:  CP.B    W4L,#5
00A4E:  BRA     NZ,A78
.................... 				{ 
.................... 					// Hash les valeurs reçues 
.................... 					HashC1 += Dataa; 
00A50:  MOV.B   1B23,W0L
00A52:  ADD.B   1D8C,W0L
00A54:  MOV.B   W0L,1B23
.................... 					HashC2 = (HashC2+Dataa)*(PosTabToDecode+1);	 
00A56:  MOV.B   1B24,W0L
00A58:  ADD.B   1D8C,W0L
00A5A:  MOV.B   W0L,A
00A5C:  MOV     171E,W4
00A5E:  CLR.B   9
00A60:  ADD     W4,#1,W4
00A62:  MOV     W4,W0
00A64:  CLR.B   B
00A66:  MUL.UU  W5,W0,W0
00A68:  MOV.B   W0L,1B24
.................... 					// Retire l'incrément ASCII et enregistre 
.................... 					TabToDecode[PosTabToDecode] = Dataa; 
00A6A:  MOV     171E,W4
00A6C:  CLR.B   9
00A6E:  MOV     #161E,W3
00A70:  ADD     W4,W3,W5
00A72:  MOV     1D8C,W0
00A74:  MOV.B   W0L,[W5+#0]
.................... 					 
.................... 					PosTabToDecode++; 
00A76:  INC.B   171E
.................... 				} 
.................... 			}			 
00A78:  GOTO    91C
.................... 		}	 
.................... 	}		 
.................... 	// Quitte l'interruption 
.................... 	return; 
00A7C:  BCLR.B  85.1
00A7E:  MOV     #1A,W0
00A80:  REPEAT  #C
00A82:  MOV     [--W15],[W0--]
00A84:  MOV     [--W15],W0
00A86:  POP     32
00A88:  POP     36
00A8A:  POP     42
00A8C:  RETFIE  
.................... } 
....................  
.................... /** 
.................... * \fn void __UART_Decode(char* Tab) 
.................... * \brief Décode la trame de l'UART. 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 20.11.2015 
.................... * 
.................... * \param[in] (*)_Tab Tableau avec lequel travailler 
.................... * \return Ne retourne rien 
.................... */ 
.................... void __UART_Decode(unsigned int32* _Tab) 
*
0A8C4:  MOV     W5,[W15++]
0A8C6:  MOV     #C,W5
0A8C8:  REPEAT  #7
0A8CA:  MOV     [W5++],[W15++]
0A8CC:  CLR     1B56
0A8CE:  CLR     1B5A
0A8D0:  CLR     1B5C
0A8D2:  CLR     1B5E
.................... { 
.................... 	unsigned int16 index = 0; 
.................... 	unsigned int16 Xo,Yo = 0; 
.................... 	signed int16 phi = 0;	 
.................... 	static int16 memo; 
.................... 	static int16 Memorise; 
.................... 	unsigned int16 Adresse = 0; 
.................... 	// Regarde quoi faire 
.................... 	switch(*(_Tab+1)) // On saute la première adresse mémoire qui contient l'adresse du driver 
0A8D4:  MOV     1B54,W4
0A8D6:  ADD     W4,#4,W4
0A8D8:  MOV     W4,W0
0A8DA:  MOV     W0,W5
0A8DC:  MOV     #0,W3
0A8DE:  MOV     [W5++],[W3++]
0A8E0:  MOV     [W5++],[W3++]
0A8E2:  CP0     W0
0A8E4:  BRA     NZ,A8EA
0A8E6:  CP0     W1
0A8E8:  BRA     Z,A976
0A8EA:  CP      W0,#1
0A8EC:  BRA     NZ,A8F2
0A8EE:  CP0     W1
0A8F0:  BRA     Z,A982
0A8F2:  CP      W0,#2
0A8F4:  BRA     NZ,A8FA
0A8F6:  CP0     W1
0A8F8:  BRA     Z,A990
0A8FA:  CP      W0,#3
0A8FC:  BRA     NZ,A902
0A8FE:  CP0     W1
0A900:  BRA     Z,A996
0A902:  CP      W0,#4
0A904:  BRA     NZ,A90A
0A906:  CP0     W1
0A908:  BRA     Z,A99A
0A90A:  CP      W0,#A
0A90C:  BRA     NZ,A912
0A90E:  CP0     W1
0A910:  BRA     Z,A99E
0A912:  CP      W0,#B
0A914:  BRA     NZ,A91A
0A916:  CP0     W1
0A918:  BRA     Z,A9B8
0A91A:  CP      W0,#C
0A91C:  BRA     NZ,A922
0A91E:  CP0     W1
0A920:  BRA     Z,A9BC
0A922:  CP      W0,#14
0A924:  BRA     NZ,A92A
0A926:  CP0     W1
0A928:  BRA     Z,AA06
0A92A:  CP      W0,#15
0A92C:  BRA     NZ,A932
0A92E:  CP0     W1
0A930:  BRA     Z,AA0A
0A932:  CP      W0,#16
0A934:  BRA     NZ,A93A
0A936:  CP0     W1
0A938:  BRA     Z,AA5C
0A93A:  CP      W0,#17
0A93C:  BRA     NZ,A942
0A93E:  CP0     W1
0A940:  BRA     Z,AA70
0A942:  CP      W0,#18
0A944:  BRA     NZ,A94A
0A946:  CP0     W1
0A948:  BRA     Z,AAB8
0A94A:  CP      W0,#19
0A94C:  BRA     NZ,A952
0A94E:  CP0     W1
0A950:  BRA     Z,AB82
0A952:  CP      W0,#1E
0A954:  BRA     NZ,A95A
0A956:  CP0     W1
0A958:  BRA     Z,AB90
0A95A:  CP      W0,#1F
0A95C:  BRA     NZ,A962
0A95E:  CP0     W1
0A960:  BRA     Z,AB94
0A962:  CP      W0,#13
0A964:  BRA     NZ,A96A
0A966:  CP0     W1
0A968:  BRA     Z,AB98
0A96A:  MOV     #32,W4
0A96C:  CP      W0,W4
0A96E:  BRA     NZ,A974
0A970:  CP0     W1
0A972:  BRA     Z,ABF4
0A974:  BRA     ABF8
.................... 	{ 
.................... 		// Test Comm - LED Blink 
.................... 		case 0 : 
.................... 			_LED1=_LED2=_LED3=_LED4=1; 
0A976:  BSET.B  2D0.4
0A978:  BSET.B  2D0.3
0A97A:  BSET.B  2D0.2
0A97C:  BSET.B  2D0.1
.................... 			break; 
0A97E:  GOTO    AC14
.................... 		// Demande si est connecté	 
.................... 		case 1 : 
.................... 			fputc(0x31,RS232); 
0A982:  MOV.B   #31,W0L
0A984:  BTSC.B  20F.1
0A986:  BRA     A984
0A988:  MOV.B   W0L,210
0A98A:  CLR.B   211
.................... 			break; 
0A98C:  GOTO    AC14
.................... 		// Reset la plaque 
.................... 		case 2 : 
.................... 			reset_cpu(); 
0A990:  RESET   
.................... 			break; 
0A992:  GOTO    AC14
.................... 		// Demande si RoboteQ connecté 
.................... 		case 3 : 
.................... 			// ? 
.................... 			break; 
0A996:  GOTO    AC14
.................... 		// Configuration du robot 
.................... 		case 4 :			 
.................... 			break; 
0A99A:  GOTO    AC14
.................... 		// Change d'objectif 
.................... 		case 10 : 
.................... 			flagMarche = (int1)(*(_Tab+2)); 
0A99E:  BCLR.B  14B7.0
0A9A0:  MOV     1B54,W4
0A9A2:  ADD     W4,#8,W4
0A9A4:  MOV     W4,W0
0A9A6:  MOV.B   [W0],W4L
0A9A8:  BCLR.B  0.0
0A9AA:  BTSC.B  8.0
0A9AC:  BSET.B  0.0
0A9AE:  BTSS    W0.0
0A9B0:  BRA     A9B4
0A9B2:  BSET.B  14B7.0
.................... 			break; 
0A9B4:  GOTO    AC14
.................... 		//	Arrêt d'urgence 
.................... 		case 11 : 
.................... 			 
.................... 			break; 
0A9B8:  GOTO    AC14
.................... 		// Set la position de départ 
.................... 		case 12 : 
.................... 			Xo = *(_Tab+2); 
0A9BC:  MOV     1B54,W4
0A9BE:  ADD     W4,#8,W4
0A9C0:  MOV     W4,W0
0A9C2:  MOV     [W0],[W15++]
0A9C4:  POP     1B58
.................... 			Yo = *(_Tab+3); 
0A9C6:  MOV     1B54,W4
0A9C8:  ADD     W4,#C,W4
0A9CA:  MOV     W4,W0
0A9CC:  MOV     [W0],[W15++]
0A9CE:  POP     1B5A
.................... 			phi = *(_Tab+4); 
0A9D0:  MOV     1B54,W4
0A9D2:  ADD     W4,#10,W4
0A9D4:  MOV     W4,W0
0A9D6:  MOV     W0,W4
0A9D8:  MOV     #0,W3
0A9DA:  MOV     [W4++],[W3++]
0A9DC:  MOV     [W4++],[W3++]
0A9DE:  MOV     W0,1B5C
.................... 			 
.................... 			write_eeprom(800,Xo); 
0A9E0:  MOV     #320,W0
0A9E2:  MOV     #1B58,W1
0A9E4:  MOV     #2,W2
0A9E6:  CALL    A446
.................... 			write_eeprom(802,Yo); 
0A9EA:  MOV     #322,W0
0A9EC:  MOV     #1B5A,W1
0A9EE:  MOV     #2,W2
0A9F0:  CALL    A446
.................... 			write_eeprom(804,phi); 
0A9F4:  MOV     #324,W0
0A9F6:  MOV     #1B5C,W1
0A9F8:  MOV     #2,W2
0A9FA:  CALL    A446
.................... 			 
.................... 			__Init_pos();	 
0A9FE:  CALL    1DCC
.................... 			break; 
0AA02:  GOTO    AC14
.................... 		 
.................... 		// Enregistre le nombre d'objectifs 
.................... 		case 20 : 
.................... 			break; 
0AA06:  GOTO    AC14
.................... 		// Sauvegarde un objectif en EEPROM 
.................... 		case 21 : 
.................... 			for(index = memo; index <  (memo + 28); index += 2) 
0AA0A:  PUSH    1B26
0AA0C:  POP     1B56
0AA0E:  MOV     1B26,W4
0AA10:  ADD     W4,#1C,W4
0AA12:  MOV     W4,W0
0AA14:  MOV     1B56,W4
0AA16:  CP      W4,W0
0AA18:  BRA     GE,AA50
.................... 			{ 
.................... 				write_eeprom(index, *( _Tab +((index - memo)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0AA1A:  MOV     1B56,W4
0AA1C:  MOV     1B26,W3
0AA1E:  SUB     W4,W3,W5
0AA20:  MOV     W5,W4
0AA22:  MOV     #2,W3
0AA24:  REPEAT  #11
0AA26:  DIV.S   W4,W3
0AA28:  MOV     W0,W5
0AA2A:  MOV     W5,W4
0AA2C:  MUL.UU  W4,#4,W0
0AA2E:  MOV     1B54,W4
0AA30:  ADD     W0,W4,W5
0AA32:  ADD     W5,#C,W5
0AA34:  MOV     W5,W0
0AA36:  MOV     #A,W4
0AA38:  MOV     [W0++],[W4++]
0AA3A:  MOV     [W0++],[W4++]
0AA3C:  MOV     1B56,W0
0AA3E:  MOV     #A,W1
0AA40:  MOV     #2,W2
0AA42:  CALL    A446
0AA46:  MOV     1B56,W4
0AA48:  ADD     W4,#2,W4
0AA4A:  MOV     W4,1B56
0AA4C:  GOTO    AA0E
.................... 			} 
.................... 			memo = index; //offset afin d'aler écrie plus loin dans l'eeprom 
0AA50:  PUSH    1B56
0AA52:  POP     1B26
.................... 			__ReadObjectifs(); 
0AA54:  CALL    1A74
.................... 		break; 
0AA58:  GOTO    AC14
.................... 		// Définit le prochain objectif à charger 
.................... 		case 22 : 
.................... 			NextObj=(unsigned int16)*(_Tab+2); 
0AA5C:  MOV     1B54,W4
0AA5E:  ADD     W4,#8,W4
0AA60:  MOV     W4,W0
0AA62:  MOV     W0,W4
0AA64:  MOV     #0,W3
0AA66:  MOV     [W4++],[W3++]
0AA68:  MOV     [W4++],[W3++]
0AA6A:  MOV     W0,14BC
.................... 			break; 
0AA6C:  GOTO    AC14
.................... 		// Set les PIDs de roboteQ 
.................... 		case 23 : 
.................... 			while(index<250)//reset le tableau 
0AA70:  MOV     1B56,W4
0AA72:  MOV     #FA,W3
0AA74:  CP      W3,W4
0AA76:  BRA     LEU,AA88
.................... 			{ 
.................... 				 TabSentRS232[index] = '\r'; 
0AA78:  MOV     #982,W4
0AA7A:  MOV     1B56,W3
0AA7C:  ADD     W3,W4,W5
0AA7E:  MOV.B   #D,W0L
0AA80:  MOV.B   W0L,[W5]
.................... 				 index++; 
0AA82:  INC     1B56
0AA84:  GOTO    AA70
.................... 			} 
.................... 			index = 0; 
0AA88:  CLR     1B56
.................... 			index = 0; 
0AA8A:  CLR     1B56
.................... 			while(index<10) // on recupere les donnees 
0AA8C:  MOV     1B56,W4
0AA8E:  CP      W4,#A
0AA90:  BRA     C,AAA0
.................... 			{ 
.................... 				 __GetRoboteqPID(index); 
0AA92:  MOV.B   1B56,W0L
0AA94:  MOV.B   W0L,1B78
0AA96:  CALL    A480
.................... 				 index++; 
0AA9A:  INC     1B56
0AA9C:  GOTO    AA8C
0AAA0:  PUSH    42
0AAA2:  BCLR.B  81.7
0AAA4:  SETM.B  42
0AAA6:  BSET.B  81.7
.................... 			} 
.................... 			__SendBackUART(); // on envoie a la plaque 
0AAA8:  CALL    5EC
0AAAC:  BCLR.B  81.7
0AAAE:  POP     42
0AAB0:  BSET.B  81.7
.................... 			index = 0; 
0AAB2:  CLR     1B56
.................... 			break; 
0AAB4:  GOTO    AC14
.................... 		case 24 : 
.................... 			__SetRoboteqPID(*(_Tab+2),*(_Tab+3),*(_Tab+4),*(_Tab+5),*(_Tab+6),*(_Tab+7),*(_Tab+8),*(_Tab+9),*(_Tab+10),*(_Tab+11)); 
0AAB8:  MOV     1B54,W4
0AABA:  ADD     W4,#8,W4
0AABC:  MOV     W4,W0
0AABE:  MOV     #A,W4
0AAC0:  MOV     [W0++],[W4++]
0AAC2:  MOV     [W0++],[W4++]
0AAC4:  MOV     1B54,W4
0AAC6:  ADD     W4,#C,W4
0AAC8:  MOV     W4,W0
0AACA:  MOV     #E,W4
0AACC:  MOV     [W0++],[W4++]
0AACE:  MOV     [W0++],[W4++]
0AAD0:  MOV     1B54,W4
0AAD2:  ADD     W4,#10,W4
0AAD4:  MOV     W4,W0
0AAD6:  MOV     #12,W4
0AAD8:  MOV     [W0++],[W4++]
0AADA:  MOV     [W0++],[W4++]
0AADC:  MOV     1B54,W4
0AADE:  ADD     W4,#14,W4
0AAE0:  MOV     W4,W0
0AAE2:  MOV     #16,W4
0AAE4:  MOV     [W0++],[W4++]
0AAE6:  MOV     [W0++],[W4++]
0AAE8:  MOV     1B54,W4
0AAEA:  ADD     W4,#18,W4
0AAEC:  MOV     W4,W0
0AAEE:  MOV     #1A,W4
0AAF0:  MOV     [W0++],[W4++]
0AAF2:  MOV     [W0++],[W4++]
0AAF4:  MOV     1B54,W4
0AAF6:  ADD     W4,#1C,W4
0AAF8:  MOV     W4,W0
0AAFA:  MOV     #1B62,W4
0AAFC:  MOV     [W0++],[W4++]
0AAFE:  MOV     [W0++],[W4++]
0AB00:  MOV     #20,W4
0AB02:  MOV     1B54,W3
0AB04:  ADD     W3,W4,W0
0AB06:  MOV     #1B66,W4
0AB08:  MOV     [W0++],[W4++]
0AB0A:  MOV     [W0++],[W4++]
0AB0C:  MOV     #24,W4
0AB0E:  MOV     1B54,W3
0AB10:  ADD     W3,W4,W0
0AB12:  MOV     #1B6A,W4
0AB14:  MOV     [W0++],[W4++]
0AB16:  MOV     [W0++],[W4++]
0AB18:  MOV     #28,W4
0AB1A:  MOV     1B54,W3
0AB1C:  ADD     W3,W4,W0
0AB1E:  MOV     #1B6E,W4
0AB20:  MOV     [W0++],[W4++]
0AB22:  MOV     [W0++],[W4++]
0AB24:  MOV     #2C,W4
0AB26:  MOV     1B54,W3
0AB28:  ADD     W3,W4,W0
0AB2A:  MOV     #1B72,W4
0AB2C:  MOV     [W0++],[W4++]
0AB2E:  MOV     [W0++],[W4++]
0AB30:  PUSH    1BA0
0AB32:  MOV.B   W5L,[W15-#2]
0AB34:  POP     1BA0
0AB36:  PUSH    1BA0
0AB38:  MOV.B   W7L,[W15-#1]
0AB3A:  POP     1BA0
0AB3C:  PUSH    1BA2
0AB3E:  MOV.B   W9L,[W15-#2]
0AB40:  POP     1BA2
0AB42:  PUSH    1BA2
0AB44:  MOV.B   W11L,[W15-#1]
0AB46:  POP     1BA2
0AB48:  PUSH    1BA4
0AB4A:  MOV.B   W13L,[W15-#2]
0AB4C:  POP     1BA4
0AB4E:  MOV     W0,[W15++]
0AB50:  MOV.B   1B62,W0L
0AB52:  MOV.B   W0L,1BA5
0AB54:  MOV     [--W15],W0
0AB56:  MOV     W0,[W15++]
0AB58:  MOV.B   1B66,W0L
0AB5A:  MOV.B   W0L,1BA6
0AB5C:  MOV     [--W15],W0
0AB5E:  MOV     W0,[W15++]
0AB60:  MOV.B   1B6A,W0L
0AB62:  MOV.B   W0L,1BA7
0AB64:  MOV     [--W15],W0
0AB66:  MOV     W0,[W15++]
0AB68:  MOV.B   1B6E,W0L
0AB6A:  MOV.B   W0L,1BA8
0AB6C:  MOV     [--W15],W0
0AB6E:  MOV     W0,[W15++]
0AB70:  MOV.B   1B72,W0L
0AB72:  MOV.B   W0L,1BA9
0AB74:  MOV     [--W15],W0
0AB76:  CALL    A67C
.................... 			__reset_Roboteq(); 
0AB7A:  CALL    A878
.................... 			break; 
0AB7E:  GOTO    AC14
.................... 		 
.................... 		//erase eeprom 
.................... 		case 25 : 
.................... 			__resetEEPROM(); 
0AB82:  CALL    A89C
.................... 			reset_cpu();     
0AB86:  RESET   
.................... 			break;		 
0AB88:  GOTO    AC14
.................... 		 
.................... 			break; 
0AB8C:  GOTO    AC14
.................... 		// Ouvre ou ferme l'étau 
.................... 		case 30 : 
.................... 			break; 
0AB90:  GOTO    AC14
.................... 		// Position hold ou release du servo 
.................... 		case 31 : 
.................... 			break;			 
0AB94:  GOTO    AC14
.................... 		case 19 : 
.................... 			for(Adresse = Memorise ; Adresse <= 16 + Memorise ; Adresse += 2) 
0AB98:  PUSH    1B28
0AB9A:  POP     1B5E
0AB9C:  MOV     #10,W0
0AB9E:  ADD     1B28,W0
0ABA0:  MOV     1B5E,W4
0ABA2:  CP      W4,W0
0ABA4:  BRA     GT,ABE8
.................... 			{ 
.................... 				write_eeprom(Adresse + 200 , *( _Tab +((Adresse - Memorise)/2) + 3));//on sauvegarde les objectifs dans l'EEPROM 
0ABA6:  MOV     #C8,W4
0ABA8:  MOV     1B5E,W3
0ABAA:  ADD     W3,W4,W5
0ABAC:  MOV     1B5E,W4
0ABAE:  MOV     1B28,W3
0ABB0:  SUB     W4,W3,W6
0ABB2:  MOV     W6,W4
0ABB4:  MOV     #2,W3
0ABB6:  REPEAT  #11
0ABB8:  DIV.S   W4,W3
0ABBA:  MOV     W0,W6
0ABBC:  MOV     W6,W4
0ABBE:  MUL.UU  W4,#4,W0
0ABC0:  MOV     1B54,W4
0ABC2:  ADD     W0,W4,W6
0ABC4:  ADD     W6,#C,W6
0ABC6:  MOV     W6,W0
0ABC8:  MOV     #C,W4
0ABCA:  MOV     [W0++],[W4++]
0ABCC:  MOV     [W0++],[W4++]
0ABCE:  MOV     W5,W0
0ABD0:  MOV     #C,W1
0ABD2:  MOV     #2,W2
0ABD4:  CALL    A446
.................... 				delay_ms(5); 
0ABD8:  MOV     #5,W0
0ABDA:  CALL    EBE
0ABDE:  MOV     1B5E,W4
0ABE0:  ADD     W4,#2,W4
0ABE2:  MOV     W4,1B5E
0ABE4:  GOTO    AB9C
.................... 			} 
.................... 			Memorise = Adresse; //offset afin d'aler écrie plus loin dans l'eeprom 
0ABE8:  PUSH    1B5E
0ABEA:  POP     1B28
.................... 			__ReadZones_Interdites();		 
0ABEC:  CALL    1B12
.................... 			break; 
0ABF0:  GOTO    AC14
.................... 		// Ne lit plus les objectifs en ROM avant une nouvelle écriture	 
.................... 		case 50 :			 
.................... 			break;	 
0ABF4:  GOTO    AC14
.................... 			 
.................... 			// Avertit le PC d'une action inconnue 
.................... 		default : 
.................... 			fprintf(RS232,"Carte Principale : Commande Inconnue\r"); 
0ABF8:  MOV     #0,W1
0ABFA:  MOV     W1,W0
0ABFC:  CLR.B   1
0ABFE:  CALL    3E6
0AC02:  INC     W1,W1
0AC04:  BTSC.B  20F.1
0AC06:  BRA     AC04
0AC08:  MOV     W0,210
0AC0A:  MOV     #24,W0
0AC0C:  CPSGT   W1,W0
0AC0E:  BRA     ABFA
.................... 			break; 
0AC10:  GOTO    AC14
.................... 	} 
.................... 	 
.................... 	// Permet de recevoir à nouveau 
.................... 	PCh_flagUARTReadyToDecode = 0; 
0AC14:  BCLR.B  161B.2
....................  
.................... 	// Quitte la fonction 
.................... 	return; 
0AC16:  MOV     #1A,W5
0AC18:  REPEAT  #7
0AC1A:  MOV     [--W15],[W5--]
0AC1C:  MOV     [--W15],W5
0AC1E:  RETURN  
.................... } 
....................  
.................... /** 
.................... * \fn void __SendBackUART(void) 
.................... * \brief Envoi des commandes en UART 
.................... * 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 11.01.2016 
.................... * 
.................... * \return Ne retourne rien 
....................  
.................... */ 
.................... void __SendBackUART(void) 
*
005EC:  MOV     W5,[W15++]
005EE:  MOV     #982,W4
005F0:  MOV     W4,1D92
005F2:  CLR.B   1D94
.................... { 
.................... 	char* ptrBuffy = TabSentRS232; 
.................... 	// Envoi commande 
.................... 	unsigned int8 ToEndSend=0; 
.................... 	while(*(ptrBuffy+ToEndSend)!='\r' && *(ptrBuffy+ToEndSend)!=ETX) // Attend de voir la fin de tableau 
005F4:  MOV     1D94,W4
005F6:  CLR.B   9
005F8:  MOV     1D92,W3
005FA:  ADD     W3,W4,W0
005FC:  MOV.B   [W0],W4L
005FE:  CP.B    W4L,#D
00600:  BRA     Z,62A
00602:  MOV     1D94,W4
00604:  CLR.B   9
00606:  MOV     1D92,W3
00608:  ADD     W3,W4,W0
0060A:  MOV.B   [W0],W4L
0060C:  CP.B    W4L,#3
0060E:  BRA     Z,62A
.................... 	{ 
.................... 		fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi la commande 
00610:  MOV     1D94,W4
00612:  CLR.B   9
00614:  MOV     1D92,W3
00616:  ADD     W3,W4,W0
00618:  MOV.B   [W0],W5L
0061A:  MOV.B   W5L,W0L
0061C:  BTSC.B  20F.1
0061E:  BRA     61C
00620:  MOV.B   W0L,210
00622:  CLR.B   211
.................... 		ToEndSend++; 
00624:  INC.B   1D94
00626:  GOTO    5F4
.................... 	}	 
.................... 	fputc(*(ptrBuffy+ToEndSend),RS232); // Envoi le caractère de fin de commande 
0062A:  MOV     1D94,W4
0062C:  CLR.B   9
0062E:  MOV     1D92,W3
00630:  ADD     W3,W4,W0
00632:  MOV.B   [W0],W5L
00634:  MOV.B   W5L,W0L
00636:  BTSC.B  20F.1
00638:  BRA     636
0063A:  MOV.B   W0L,210
0063C:  CLR.B   211
.................... 	TabSentRS232[ToEndSend]=*(ptrBuffy+ToEndSend); 
0063E:  MOV     1D94,W4
00640:  CLR.B   9
00642:  MOV     #982,W3
00644:  ADD     W4,W3,W5
00646:  MOV     1D94,W4
00648:  CLR.B   9
0064A:  MOV     1D92,W3
0064C:  ADD     W3,W4,W0
0064E:  MOV.B   [W0],[W5]
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
00650:  MOV     [--W15],W5
00652:  RETURN  
.................... }	 
....................  
.................... // Décode un tableau 
.................... void __CommDecode(unsigned int8* _TabToDec,unsigned int32* _TabDec) 
*
0088C:  MOV     W5,[W15++]
0088E:  MOV.B   #1,W0L
00890:  MOV.B   W0L,1D92
00892:  CLR.B   1D93
00894:  CLR.B   1D94
.................... { 
.................... 	// Permet de se balader dans le tableau 
.................... 	unsigned int8 i=1,j=0,ki=0; 
.................... 	char TempTab[11]={0}; // Taille max d'un int32 + NULL 
00896:  CLR     1D96
00898:  CLR     1D98
0089A:  CLR     1D9A
0089C:  CLR     1D9C
0089E:  CLR     1D9E
008A0:  CLR.B   1DA0
.................... 	// On décode tout 
.................... 	while(_TabToDec[i]!=ETX) 
008A2:  MOV     1D92,W4
008A4:  CLR.B   9
008A6:  MOV     W4,W0
008A8:  ADD     1D8E,W0
008AA:  MOV.B   [W0],W4L
008AC:  CP.B    W4L,#3
008AE:  BRA     Z,904
.................... 	{ 
.................... 		// On cherche la fin d'un nombre 
.................... 		while(_TabToDec[i]!=SPACE) 
008B0:  MOV     1D92,W4
008B2:  CLR.B   9
008B4:  MOV     W4,W0
008B6:  ADD     1D8E,W0
008B8:  MOV.B   [W0],W4L
008BA:  XOR.B   #20,W4L
008BC:  BRA     Z,8D8
.................... 		{ 
.................... 			TempTab[j]=(char)(_TabToDec[i]); 
008BE:  MOV     1D92,W4
008C0:  LSR     W4,#8,W4
008C2:  MOV     #1D96,W3
008C4:  ADD     W4,W3,W5
008C6:  MOV     1D92,W4
008C8:  CLR.B   9
008CA:  MOV     W4,W0
008CC:  ADD     1D8E,W0
008CE:  MOV.B   [W0],[W5]
.................... 			i++;j++; 
008D0:  INC.B   1D92
008D2:  INC.B   1D93
008D4:  GOTO    8B0
.................... 		}	 
.................... 		TempTab[j]=NUL; 
008D8:  MOV     1D92,W4
008DA:  LSR     W4,#8,W4
008DC:  MOV     #1D96,W3
008DE:  ADD     W4,W3,W5
008E0:  CLR.B   [W5]
.................... 		i++;j=0; 
008E2:  INC.B   1D92
008E4:  CLR.B   1D93
.................... 		// On enregistre le nombres 
.................... 		_TabDec[ki]=(unsigned int32)atoi32(TempTab); 
008E6:  MOV.B   1D94,W0L
008E8:  CLR.B   1
008EA:  SL      W0,#2,W0
008EC:  MOV     1D90,W4
008EE:  ADD     W0,W4,W5
008F0:  MOV     #1D96,W4
008F2:  MOV     W4,1DAC
008F4:  CALL    696
008F8:  MOV     #0,W4
008FA:  MOV     [W4++],[W5++]
008FC:  MOV     [W4++],[W5++]
.................... 		ki++; 
008FE:  INC.B   1D94
00900:  GOTO    8A2
.................... 	} 
.................... 	 
.................... 	// Quitte la fonction 
.................... 	return;	 
00904:  MOV     [--W15],W5
00906:  RETURN  
.................... }	 
....................  
.................... #endif 
....................  
....................  
.................... #endif 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.h" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_h 
.................... #define ___Zones_interdites_h 
....................  
....................  
....................  
.................... enum{x1, y1, x4, y4}; 
.................... enum{X, Y}; 
....................  
.................... int x3 = 0; 
.................... int y3 = 3; 
.................... int x2 = 2; 
.................... int y2 = 1; 
....................  
.................... int32 start_point_X, start_point_Y, end_point_X, end_point_Y; 
.................... signed int32 spot_X, spot_Y;  
....................  
.................... //********************************************************************************************************************* 
.................... // checkPath 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si le trajet du point A Ã  B passe sur une zone interdite 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... int checkPath(); 
....................  
.................... void checkPtsRelai(); 
....................  
.................... //********************************************************************************************************************* 
.................... // findPath 
.................... // 
.................... // Cette fonction permet de trouver le trajet pour arriver Ã  la destination en Ã©vitant les zones interdites 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findPath(); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... int16 getDist(int16 x1, int16 y1, int16 x2, int16 y2); 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(int16 pt1X, int16 pt1Y, int16 pt2X, int16 pt2Y); 
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int16 px, int16 py, int16 rx1, int16 ry1, int16 rx4, int16 ry4); 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int16 xStart, int16 yStart, int16 xEnd, int16 yEnd, int i_zone); 
....................  
.................... #include "zonesinterdites/__ZonesInterdites.c" 
.................... /*==================================================================================================== 
.................... ===																									== 
.................... ===											EMVs - EUROBOT	  										== 
.................... ===											--------------											== 
.................... ====================================================================================================== 
.................... ===	 Auteur				: Rithner AurÃ©lien   					  									== 
.................... ===  Date				: 30.04.2015    															== 
.................... ===  Nom du programme 	: Zones_interdites.c														== 
.................... ===  Version 			: V1.0																		== 
.................... ====================================================================================================== 
.................... === Description :																					== 
.................... === Contient les fonctions qui permettent de gÃ©rer et d'Ã©viter les zones interdites					== 
.................... ====================================================================================================*/ 
....................  
.................... #ifndef ___Zones_interdites_c 
.................... #define ___Zones_interdites_c 
....................  
.................... //********************************************************************************************************************* 
.................... // checkPath 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si le trajet du point A Ã  B passe sur une zone interdite 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... int checkPath() 
*
020AC:  MOV     W5,[W15++]
020AE:  MOV     W6,[W15++]
020B0:  MOV     W7,[W15++]
020B2:  MOV     W8,[W15++]
.................... { 
.................... 	path_found = 0; 
020B4:  CLR     A84
.................... 		 
....................     start_point_X = Pos_x; 
020B6:  MOV     158C,W0
020B8:  CLR     W1
020BA:  BTSC    W0.F
020BC:  SETM    W1
020BE:  MOV     W0,1B32
020C0:  MOV     W1,1B34
....................     start_point_Y = Pos_y; 
020C2:  MOV     158E,W0
020C4:  CLR     W1
020C6:  BTSC    W0.F
020C8:  SETM    W1
020CA:  MOV     W0,1B36
020CC:  MOV     W1,1B38
....................  
....................     end_point_X = oXp; 
020CE:  MOV     1498,W0
020D0:  CLR     W1
020D2:  BTSC    W0.F
020D4:  SETM    W1
020D6:  MOV     W0,1B3A
020D8:  MOV     W1,1B3C
....................     end_point_Y = oYp; 
020DA:  MOV     149A,W0
020DC:  CLR     W1
020DE:  BTSC    W0.F
020E0:  SETM    W1
020E2:  MOV     W0,1B3E
020E4:  MOV     W1,1B40
....................  
....................     checkIntersection(start_point_X, start_point_Y, end_point_X, end_point_Y); 
020E6:  MOV     1B32,W5
020E8:  MOV     1B36,W6
020EA:  MOV     1B3A,W7
020EC:  MOV     1B3E,W8
020EE:  MOV     W5,1B64
020F0:  MOV     W6,1B66
020F2:  MOV     W7,1B68
020F4:  MOV     W8,1B6A
020F6:  CALL    1EF4
.................... 		 
.................... 	if (intersection_found > 0) 
020FA:  MOV     A82,W4
020FC:  CP      W4,#0
020FE:  BRA     LE,2106
.................... 	{ 
.................... 			path_found = 0; 
02100:  CLR     A84
.................... 	} 
02102:  GOTO    210A
.................... 	else 
.................... 	{ 
.................... 			path_found = 1; 
02106:  MOV     #1,W4
02108:  MOV     W4,A84
.................... 	} 
....................  
.................... 	return path_found; 
0210A:  PUSH    A84
0210C:  POP     0
0210E:  MOV     [--W15],W8
02110:  MOV     [--W15],W7
02112:  MOV     [--W15],W6
02114:  MOV     [--W15],W5
02116:  RETURN  
....................    
.................... } 
....................  
.................... void checkPtsRelai() 
*
06D44:  MOV     W5,[W15++]
06D46:  MOV     #C,W5
06D48:  REPEAT  #3
06D4A:  MOV     [W5++],[W15++]
.................... { 
.................... 	//On vÃ©rifie si un des points relais se trouve trop prÃ¨s du bord 
.................... 	path_tooclose = 0; 
06D4C:  CLR     A8A
....................     int i = 1; 
06D4E:  MOV     #1,W4
06D50:  MOV     W4,1B5A
....................     do 
....................     { 
....................     	if(PtsRelai[i_rel - i][X] < (MARGE/2) || PtsRelai[i_rel - i][Y] < (MARGE/2) || PtsRelai[i_rel - i][X] > (SIZE_TABLE_X-(MARGE/2)) || PtsRelai[i_rel - i][Y] > (SIZE_TABLE_Y-(MARGE/2))) 
06D52:  MOV     A8E,W4
06D54:  MOV     1B5A,W3
06D56:  SUB     W4,W3,W5
06D58:  MOV     W5,W4
06D5A:  MUL.UU  W4,#8,W0
06D5C:  MOV     W0,W5
06D5E:  MOV     #AA6,W4
06D60:  ADD     W5,W4,W0
06D62:  MOV     #C,W4
06D64:  MOV     [W0++],[W4++]
06D66:  MOV     [W0++],[W4++]
06D68:  CP      W7,#0
06D6A:  BRA     LT,6DDE
06D6C:  BRA     GT,6D74
06D6E:  MOV     #B4,W4
06D70:  CP      W4,W6
06D72:  BRA     GTU,6DDE
06D74:  MOV     A8E,W4
06D76:  MOV     1B5A,W3
06D78:  SUB     W4,W3,W6
06D7A:  MOV     W6,W4
06D7C:  MUL.UU  W4,#8,W6
06D7E:  ADD     W6,#4,W6
06D80:  MOV     W6,W0
06D82:  MOV     #AA6,W4
06D84:  ADD     W0,W4,W0
06D86:  MOV     #C,W4
06D88:  MOV     [W0++],[W4++]
06D8A:  MOV     [W0++],[W4++]
06D8C:  CP      W7,#0
06D8E:  BRA     LT,6DDE
06D90:  BRA     GT,6D98
06D92:  MOV     #B4,W4
06D94:  CP      W4,W6
06D96:  BRA     GTU,6DDE
06D98:  MOV     A8E,W4
06D9A:  MOV     1B5A,W3
06D9C:  SUB     W4,W3,W6
06D9E:  MOV     W6,W4
06DA0:  MUL.UU  W4,#8,W6
06DA2:  MOV     #AA6,W4
06DA4:  ADD     W6,W4,W0
06DA6:  MOV     #E,W4
06DA8:  MOV     [W0++],[W4++]
06DAA:  MOV     [W0++],[W4++]
06DAC:  CP      W8,#0
06DAE:  BRA     GT,6DDE
06DB0:  BRA     LT,6DB8
06DB2:  MOV     #B04,W4
06DB4:  CP      W4,W7
06DB6:  BRA     NC,6DDE
06DB8:  MOV     A8E,W4
06DBA:  MOV     1B5A,W3
06DBC:  SUB     W4,W3,W7
06DBE:  MOV     W7,W4
06DC0:  MUL.UU  W4,#8,W0
06DC2:  MOV     W0,W7
06DC4:  ADD     W7,#4,W7
06DC6:  MOV     W7,W0
06DC8:  MOV     #AA6,W4
06DCA:  ADD     W0,W4,W0
06DCC:  MOV     #E,W4
06DCE:  MOV     [W0++],[W4++]
06DD0:  MOV     [W0++],[W4++]
06DD2:  CP      W8,#0
06DD4:  BRA     LT,6DE2
06DD6:  BRA     GT,6DDE
06DD8:  MOV     #71C,W4
06DDA:  CP      W4,W7
06DDC:  BRA     C,6DE2
....................     	{ 
....................     		path_tooclose = 1; 
06DDE:  MOV     #1,W4
06DE0:  MOV     W4,A8A
....................     	} 
....................     	i++; 
06DE2:  INC     1B5A
....................  
....................     }while(!path_tooclose && i <= relay_point_number); 
06DE4:  CP0     A8A
06DE6:  BRA     NZ,6DF2
06DE8:  MOV     1B5A,W0
06DEA:  MOV     A8C,W4
06DEC:  CP      W4,W0
06DEE:  BRA     LT,6DF2
06DF0:  BRA     6D52
....................  
.................... 	if(path_impossible == 0) 
06DF2:  CP0     A86
06DF4:  BRA     NZ,6E40
.................... 	{ 
.................... 	    //Alors on recalcul le trajet en passant par l'autre cÃ´tÃ© de la zone interdite 
.................... 	    if(path_tooclose) 
06DF6:  CP0     A8A
06DF8:  BRA     Z,6E3C
.................... 	    { 
.................... 	    	path_opposite = 1; 
06DFA:  MOV     #1,W4
06DFC:  MOV     W4,A88
.................... 	    	i_rel = i_rel-relay_point_number; 
06DFE:  MOV     A8E,W4
06E00:  MOV     A8C,W3
06E02:  SUB     W4,W3,W0
06E04:  MOV     W0,A8E
.................... 	    	findRel(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y, 0); 
06E06:  MOV     A8E,W4
06E08:  SUB     W4,#1,W5
06E0A:  MOV     W5,W4
06E0C:  MUL.UU  W4,#8,W0
06E0E:  MOV     W0,W5
06E10:  MOV     #AA6,W4
06E12:  ADD     W5,W4,W0
06E14:  MOV     [W0],W6
06E16:  MOV     A8E,W4
06E18:  SUB     W4,#1,W7
06E1A:  MOV     W7,W4
06E1C:  MUL.UU  W4,#8,W0
06E1E:  MOV     W0,W7
06E20:  ADD     W7,#4,W7
06E22:  MOV     W7,W0
06E24:  MOV     #AA6,W4
06E26:  ADD     W0,W4,W0
06E28:  MOV     [W0],W7
06E2A:  MOV     1B3A,W8
06E2C:  MOV     1B3E,W9
06E2E:  MOV     W6,1B68
06E30:  MOV     W7,1B6A
06E32:  MOV     W8,1B6C
06E34:  MOV     W9,1B6E
06E36:  CLR     1B70
06E38:  CALL    2E38
.................... 	    } 
.................... 	} 
06E3C:  GOTO    6E4E
.................... 	else 
.................... 	{ 
.................... 		//Alors on recalcul le trajet en passant par l'autre cÃ´tÃ© de la zone interdite 
.................... 	    if(path_tooclose) 
06E40:  CP0     A8A
06E42:  BRA     Z,6E4C
.................... 	    { 
.................... 	    	__Stop(); 
06E44:  CALL    6D08
.................... 	    } 
06E48:  GOTO    6E4E
.................... 	    else 
.................... 	    { 
.................... 		    path_impossible = 0; 
06E4C:  CLR     A86
.................... 		}  
.................... 		 
.................... 	}	     
06E4E:  MOV     #12,W5
06E50:  REPEAT  #3
06E52:  MOV     [--W15],[W5--]
06E54:  MOV     [--W15],W5
06E56:  RETURN  
....................  
....................  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // findPath 
.................... // 
.................... // Cette fonction permet de trouver le trajet pour arriver Ã  la destination en Ã©vitant les zones interdites 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : - 
.................... // return      : - 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findPath() 
06E58:  MOV     W5,[W15++]
06E5A:  MOV     #C,W5
06E5C:  REPEAT  #3
06E5E:  MOV     [W5++],[W15++]
06E60:  CLR     1B54
06E62:  CLR     1B56
.................... { 
....................    	int i = 0; 
....................    	int exit = 0; 
....................     //Si on intercepte encore une zone alors intersection_found sera > 0 
....................     while(intersection_found > 0 && !exit && !flag_end) 
06E64:  MOV     A82,W4
06E66:  CP      W4,#0
06E68:  BRA     LE,6F00
06E6A:  CP0     1B56
06E6C:  BRA     NZ,6F00
06E6E:  BTSC.B  85A.7
06E70:  BRA     6F00
....................     { 
....................         //Tant qu'on intercepte une zone depuis le point relai on continue Ã  en chercher un autre 
....................         i++; 
06E72:  INC     1B54
....................          
....................         if(path_impossible == 1) 
06E74:  MOV     A86,W4
06E76:  CP      W4,#1
06E78:  BRA     NZ,6E82
....................         { 
....................        	 	path_opposite = 1; 
06E7A:  MOV     #1,W4
06E7C:  MOV     W4,A88
....................        	} 
06E7E:  GOTO    6E84
....................        	else 
....................        	{ 
.................... 	      	path_opposite = 0; 
06E82:  CLR     A88
.................... 	    } 
.................... 	      								  
....................          
....................         //On trouve le premier point relai 
....................         findRel(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y, 0); 
06E84:  MOV     A8E,W4
06E86:  SUB     W4,#1,W5
06E88:  MOV     W5,W4
06E8A:  MUL.UU  W4,#8,W0
06E8C:  MOV     W0,W5
06E8E:  MOV     #AA6,W4
06E90:  ADD     W5,W4,W0
06E92:  MOV     [W0],W6
06E94:  MOV     A8E,W4
06E96:  SUB     W4,#1,W7
06E98:  MOV     W7,W4
06E9A:  MUL.UU  W4,#8,W0
06E9C:  MOV     W0,W7
06E9E:  ADD     W7,#4,W7
06EA0:  MOV     W7,W0
06EA2:  MOV     #AA6,W4
06EA4:  ADD     W0,W4,W0
06EA6:  MOV     [W0],W7
06EA8:  MOV     1B3A,W8
06EAA:  MOV     1B3E,W9
06EAC:  MOV     W6,1B68
06EAE:  MOV     W7,1B6A
06EB0:  MOV     W8,1B6C
06EB2:  MOV     W9,1B6E
06EB4:  CLR     1B70
06EB6:  CALL    2E38
....................          
....................         //On vÃ©rifie si un des points relais se trouve trop prÃ¨s du bord 
....................    		//Si c'est le cas alors on a recalculÃ© le trajet en passant de l'autre cÃ´tÃ© de la zone 
....................         checkPtsRelai(); 
06EBA:  CALL    6D44
....................         if(path_impossible == 1) 
06EBE:  MOV     A86,W4
06EC0:  CP      W4,#1
06EC2:  BRA     NZ,6EC8
....................         { 
.................... 	        exit = 1; 
06EC4:  MOV     #1,W4
06EC6:  MOV     W4,1B56
.................... 	    }  
....................         //On vÃ©rifie si depuis le premier point relai on intercepte encore une zone 
....................         checkIntersection(PtsRelai[i_rel - 1][X], PtsRelai[i_rel - 1][Y], end_point_X, end_point_Y); 
06EC8:  MOV     A8E,W4
06ECA:  SUB     W4,#1,W5
06ECC:  MOV     W5,W4
06ECE:  MUL.UU  W4,#8,W0
06ED0:  MOV     W0,W5
06ED2:  MOV     #AA6,W4
06ED4:  ADD     W5,W4,W0
06ED6:  MOV     [W0],W6
06ED8:  MOV     A8E,W4
06EDA:  SUB     W4,#1,W7
06EDC:  MOV     W7,W4
06EDE:  MUL.UU  W4,#8,W0
06EE0:  MOV     W0,W7
06EE2:  ADD     W7,#4,W7
06EE4:  MOV     W7,W0
06EE6:  MOV     #AA6,W4
06EE8:  ADD     W0,W4,W0
06EEA:  MOV     [W0],W7
06EEC:  MOV     1B3A,W8
06EEE:  MOV     1B3E,W9
06EF0:  MOV     W6,1B64
06EF2:  MOV     W7,1B66
06EF4:  MOV     W8,1B68
06EF6:  MOV     W9,1B6A
06EF8:  CALL    1EF4
06EFC:  GOTO    6E64
....................     } 
06F00:  MOV     #12,W5
06F02:  REPEAT  #3
06F04:  MOV     [--W15],[W5--]
06F06:  MOV     [--W15],W5
06F08:  RETURN  
....................      
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getDist 
.................... // 
.................... // Cette fonction permet de calculer la distance entre 2 points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : la distance entre les deux points 
.................... // 
.................... //********************************************************************************************************************* 
.................... int16 getDist(int16 x1, int16 y1, int16 x2, int16 y2) 
*
02DB6:  MOV     W5,[W15++]
02DB8:  MOV     W6,[W15++]
02DBA:  MOV     W7,[W15++]
02DBC:  MOV     W8,[W15++]
.................... { 
....................     return (sqrt(pow(fabs(x2-x1),2)) + (pow(fabs(y2-y1),2))); 
02DBE:  MOV     1B90,W4
02DC0:  MOV     1B8C,W3
02DC2:  SUB     W4,W3,W5
02DC4:  MOV     W5,W0
02DC6:  BTSS    W0.F
02DC8:  BRA     2DCE
02DCA:  MOV     #0,W4
02DCC:  SUB     W4,W5,W0
02DCE:  CALL    21A0
02DD2:  MOV     W0,W5
02DD4:  MOV     W1,W6
02DD6:  MOV     W5,1BA6
02DD8:  MOV     W6,1BA8
02DDA:  CLR     1BAA
02DDC:  MOV     #4000,W4
02DDE:  MOV     W4,1BAC
02DE0:  CALL    2B56
02DE4:  MOV     W0,W5
02DE6:  MOV     W1,W6
02DE8:  MOV     W5,1BA2
02DEA:  MOV     W6,1BA4
02DEC:  CALL    2CAC
02DF0:  MOV     W0,W5
02DF2:  MOV     W1,W6
02DF4:  MOV     1B92,W4
02DF6:  MOV     1B8E,W3
02DF8:  SUB     W4,W3,W7
02DFA:  MOV     W7,W0
02DFC:  BTSS    W0.F
02DFE:  BRA     2E04
02E00:  MOV     #0,W4
02E02:  SUB     W4,W7,W0
02E04:  CALL    21A0
02E08:  MOV     W0,W7
02E0A:  MOV     W1,W8
02E0C:  MOV     W7,1BA6
02E0E:  MOV     W8,1BA8
02E10:  CLR     1BAA
02E12:  MOV     #4000,W4
02E14:  MOV     W4,1BAC
02E16:  CALL    2B56
02E1A:  BCLR.B  43.0
02E1C:  MOV     W0,W2
02E1E:  MOV     W1,W3
02E20:  MOV     W5,W0
02E22:  MOV     W6,W1
02E24:  CALL    2446
02E28:  CALL    231C
02E2C:  MOV     W0,0
02E2E:  MOV     [--W15],W8
02E30:  MOV     [--W15],W7
02E32:  MOV     [--W15],W6
02E34:  MOV     [--W15],W5
02E36:  RETURN  
.................... } 
....................  
.................... //********************************************************************************************************************* 
.................... // checkIntersection 
.................... // 
.................... // Cette fonction permet de vÃ©rifier si une ou plusieurs zone interdites se trouvent entre les deux points 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : coord x,y du point de dÃ©part et d'arrivÃ©e 
.................... // return      : modification en global de intersection_found et de TabIntersection 
.................... // 
.................... //********************************************************************************************************************* 
.................... void checkIntersection(int16 pt1X, int16 pt1Y, int16 pt2X, int16 pt2Y) 
*
01EF4:  MOV     W5,[W15++]
01EF6:  MOV     W6,[W15++]
01EF8:  MOV     W7,[W15++]
01EFA:  MOV     W8,[W15++]
01EFC:  CLR     1B6C
.................... { 
.................... 	 
....................  
....................     int zoneToCheck = 0; 
....................  
....................     intersection_found = 0; 
01EFE:  CLR     A82
....................  
....................     int j; 
....................     for ( j= 0; j < 10; j++) 
01F00:  CLR     1B6E
01F02:  MOV     1B6E,W4
01F04:  CP      W4,#A
01F06:  BRA     GE,1F1C
....................     { 
....................         TabIntersection[j] = 0; 
01F08:  MOV     1B6E,W4
01F0A:  MUL.UU  W4,#2,W0
01F0C:  MOV     #A92,W4
01F0E:  ADD     W0,W4,W5
01F10:  CLR.B   [W5]
01F12:  MOV.B   #0,W0L
01F14:  MOV.B   W0L,[W5+#1]
01F16:  INC     1B6E
01F18:  GOTO    1F02
....................     } 
....................      
....................  
....................     signed int32 dX = pt2X-pt1X; 
....................     signed int32 dY = pt2Y-pt1Y; 
....................  
....................     int i = 0; 
01F1C:  MOV     1B68,W4
01F1E:  MOV     1B64,W3
01F20:  SUB     W4,W3,W0
01F22:  CLR     W1
01F24:  BTSC    W0.F
01F26:  SETM    W1
01F28:  MOV     W0,1B70
01F2A:  MOV     W1,1B72
01F2C:  MOV     1B6A,W4
01F2E:  MOV     1B66,W3
01F30:  SUB     W4,W3,W0
01F32:  CLR     W1
01F34:  BTSC    W0.F
01F36:  SETM    W1
01F38:  MOV     W0,1B74
01F3A:  MOV     W1,1B76
01F3C:  CLR     1B78
....................  
....................     do 
....................     { 
....................         i++; 
01F3E:  INC     1B78
....................  
....................         //On calcule des points le long du trajet 
....................         spot_X = (dX*i)/100; 
01F40:  MOV     1B78,W0
01F42:  CLR     W1
01F44:  BTSC    W0.F
01F46:  SETM    W1
01F48:  PUSH    42
01F4A:  BCLR.B  81.7
01F4C:  SETM.B  42
01F4E:  BSET.B  81.7
01F50:  MOV     W0,W2
01F52:  MOV     W1,W3
01F54:  MOV     1B70,W0
01F56:  MOV     1B72,W1
01F58:  CALL    654
01F5C:  BCLR.B  81.7
01F5E:  POP     42
01F60:  BSET.B  81.7
01F62:  MOV     W0,W5
01F64:  MOV     W1,W6
01F66:  BCLR.B  43.0
01F68:  MOV     W5,W0
01F6A:  MOV     W6,W1
01F6C:  MOV     #64,W2
01F6E:  MOV     #0,W3
01F70:  CALL    1E76
01F74:  MOV     W0,1B42
01F76:  MOV     W1,1B44
....................         spot_Y = (dY*i)/100; 
01F78:  MOV     1B78,W0
01F7A:  CLR     W1
01F7C:  BTSC    W0.F
01F7E:  SETM    W1
01F80:  PUSH    42
01F82:  BCLR.B  81.7
01F84:  SETM.B  42
01F86:  BSET.B  81.7
01F88:  MOV     W0,W2
01F8A:  MOV     W1,W3
01F8C:  MOV     1B74,W0
01F8E:  MOV     1B76,W1
01F90:  CALL    654
01F94:  BCLR.B  81.7
01F96:  POP     42
01F98:  BSET.B  81.7
01F9A:  MOV     W0,W5
01F9C:  MOV     W1,W6
01F9E:  BCLR.B  43.0
01FA0:  MOV     W5,W0
01FA2:  MOV     W6,W1
01FA4:  MOV     #64,W2
01FA6:  MOV     #0,W3
01FA8:  CALL    1E76
01FAC:  MOV     W0,1B46
01FAE:  MOV     W1,1B48
....................  
....................  
....................         //Pour chaque point du trajet on vÃ©rifie s'il est dans une zone 
....................         for(zoneToCheck = 0; zoneToCheck < 10; zoneToCheck++) 
01FB0:  CLR     1B6C
01FB2:  MOV     1B6C,W4
01FB4:  CP      W4,#A
01FB6:  BRA     GE,2086
....................         { 
....................             //On vÃ©rifie si le point se trouve dans la zone interdite 
.................... 	        if ((spot_X+pt1X) > TabZones[zoneToCheck][0] && (spot_X+pt1X) < TabZones[zoneToCheck][2]) 
01FB8:  MOV     1B64,W0
01FBA:  CLR     W1
01FBC:  BTSC    W0.F
01FBE:  SETM    W1
01FC0:  MOV     1B42,W4
01FC2:  ADD     W0,W4,W5
01FC4:  MOV     1B44,W4
01FC6:  ADDC    W1,W4,W6
01FC8:  MOV     1B6C,W4
01FCA:  MUL.UU  W4,#10,W0
01FCC:  MOV     W0,W7
01FCE:  MOV     #B46,W4
01FD0:  ADD     W7,W4,W0
01FD2:  MOV     W0,W4
01FD4:  MOV     #0,W3
01FD6:  MOV     [W4++],[W3++]
01FD8:  MOV     [W4++],[W3++]
01FDA:  CP      W1,W6
01FDC:  BRA     GT,2080
01FDE:  BRA     LT,1FE4
01FE0:  CP      W0,W5
01FE2:  BRA     C,2080
01FE4:  MOV     1B64,W0
01FE6:  CLR     W1
01FE8:  BTSC    W0.F
01FEA:  SETM    W1
01FEC:  MOV     1B42,W4
01FEE:  ADD     W0,W4,W5
01FF0:  MOV     1B44,W4
01FF2:  ADDC    W1,W4,W6
01FF4:  MOV     1B6C,W4
01FF6:  MUL.UU  W4,#10,W8
01FF8:  ADD     W8,#8,W8
01FFA:  MOV     W8,W0
01FFC:  MOV     #B46,W4
01FFE:  ADD     W0,W4,W0
02000:  MOV     W0,W4
02002:  MOV     #0,W3
02004:  MOV     [W4++],[W3++]
02006:  MOV     [W4++],[W3++]
02008:  CP      W6,W1
0200A:  BRA     GT,2080
0200C:  BRA     LT,2012
0200E:  CP      W5,W0
02010:  BRA     C,2080
.................... 	        { 
.................... 		        if ((spot_Y+pt1Y) > TabZones[zoneToCheck][1] && (spot_Y+pt1Y) < TabZones[zoneToCheck][3]) 
02012:  MOV     1B66,W0
02014:  CLR     W1
02016:  BTSC    W0.F
02018:  SETM    W1
0201A:  MOV     1B46,W4
0201C:  ADD     W0,W4,W5
0201E:  MOV     1B48,W4
02020:  ADDC    W1,W4,W6
02022:  MOV     1B6C,W4
02024:  MUL.UU  W4,#10,W0
02026:  MOV     W0,W7
02028:  ADD     W7,#4,W7
0202A:  MOV     W7,W0
0202C:  MOV     #B46,W4
0202E:  ADD     W0,W4,W0
02030:  MOV     W0,W4
02032:  MOV     #0,W3
02034:  MOV     [W4++],[W3++]
02036:  MOV     [W4++],[W3++]
02038:  CP      W1,W6
0203A:  BRA     GT,2080
0203C:  BRA     LT,2042
0203E:  CP      W0,W5
02040:  BRA     C,2080
02042:  MOV     1B66,W0
02044:  CLR     W1
02046:  BTSC    W0.F
02048:  SETM    W1
0204A:  MOV     1B46,W4
0204C:  ADD     W0,W4,W5
0204E:  MOV     1B48,W4
02050:  ADDC    W1,W4,W6
02052:  MOV     1B6C,W4
02054:  MUL.UU  W4,#10,W0
02056:  MOV     W0,W7
02058:  ADD     W7,#C,W7
0205A:  MOV     W7,W0
0205C:  MOV     #B46,W4
0205E:  ADD     W0,W4,W0
02060:  MOV     W0,W4
02062:  MOV     #0,W3
02064:  MOV     [W4++],[W3++]
02066:  MOV     [W4++],[W3++]
02068:  CP      W6,W1
0206A:  BRA     GT,2080
0206C:  BRA     LT,2072
0206E:  CP      W5,W0
02070:  BRA     C,2080
.................... 		        { 
.................... 			        
....................                     TabIntersection[intersection_found] = zoneToCheck; 
02072:  MOV     A82,W4
02074:  MUL.UU  W4,#2,W0
02076:  MOV     #A92,W4
02078:  ADD     W0,W4,W5
0207A:  MOV     1B6C,W4
0207C:  MOV     W4,[W5+#0]
....................                     intersection_found++; 
0207E:  INC     0A82
.................... 			 
.................... 		        } 
.................... 			 
.................... 			 
.................... 	        } 
02080:  INC     1B6C
02082:  GOTO    1FB2
....................         } 
.................... 	 
....................     }while (i < 100 && intersection_found == 0); 
02086:  MOV     1B78,W4
02088:  MOV     #64,W3
0208A:  CP      W3,W4
0208C:  BRA     LE,2092
0208E:  CP0     A82
02090:  BRA     Z,1F3E
....................  
....................     if(intersection_found > 0) 
02092:  MOV     A82,W4
02094:  CP      W4,#0
02096:  BRA     LE,209E
....................     { 
....................     	path_found = 0; 
02098:  CLR     A84
....................     } 
0209A:  GOTO    20A2
....................     else 
....................     { 
....................     	path_found = 1; 
0209E:  MOV     #1,W4
020A0:  MOV     W4,A84
....................     } 
020A2:  MOV     [--W15],W8
020A4:  MOV     [--W15],W7
020A6:  MOV     [--W15],W6
020A8:  MOV     [--W15],W5
020AA:  RETURN  
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // getPos 
.................... // 
.................... // Cette fonction permet de dÃ©finir la position relative d'un point par rapport Ã  une zone rectangulaire 
.................... // Il y a 9 zones possibles qui sont dÃ©terminÃ©es en prolongeant les cÃ´tÃ©s du rectangle, les zones sont numÃ©rotÃ©es 
.................... // dans le sens des aiguilles d'une montre, en partant de en haut Ã  gauche avec la zone 0. La zone 8 correspond au rectangle.  
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : px et py coordonnÃ©es du point, rx1 et ry1 sommet en haut Ã  gauche, rx4 et ry4 sommet en bas Ã  droite  
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... int getPos(int16 px, int16 py, int16 rx1, int16 ry1, int16 rx4, int16 ry4) 
.................... { 
....................     int pos; 
....................  
....................     if (px > rx4) 
*
02118:  MOV     1B94,W0
0211A:  MOV     1B8C,W4
0211C:  CP      W4,W0
0211E:  BRA     LE,2148
....................     { 
....................         if (py > ry4) 
02120:  MOV     1B96,W0
02122:  MOV     1B8E,W4
02124:  CP      W4,W0
02126:  BRA     LE,2130
....................         { 
....................             pos = 4; //Le point se trouve en bas Ã  droite de la zone 
02128:  MOV     #4,W4
0212A:  MOV     W4,1B98
....................         } 
0212C:  GOTO    2144
....................         else if (py > ry1) 
02130:  MOV     1B92,W0
02132:  MOV     1B8E,W4
02134:  CP      W4,W0
02136:  BRA     LE,2140
....................         { 
....................             pos = 3; //Le point se trouve Ã  droite de la zone 
02138:  MOV     #3,W4
0213A:  MOV     W4,1B98
....................         } 
0213C:  GOTO    2144
....................         else 
....................         { 
....................             pos = 2; //Le point se trouve en haut Ã  droite de la zone 
02140:  MOV     #2,W4
02142:  MOV     W4,1B98
....................         } 
....................     } 
02144:  GOTO    219A
....................     else if (px > rx1) 
02148:  MOV     1B90,W0
0214A:  MOV     1B8C,W4
0214C:  CP      W4,W0
0214E:  BRA     LE,2178
....................     { 
....................         if (py > ry4) 
02150:  MOV     1B96,W0
02152:  MOV     1B8E,W4
02154:  CP      W4,W0
02156:  BRA     LE,2160
....................         { 
....................             pos = 5; //Le point se trouve en bas de la zone 
02158:  MOV     #5,W4
0215A:  MOV     W4,1B98
....................         } 
0215C:  GOTO    2174
....................         else if (py > ry1) 
02160:  MOV     1B92,W0
02162:  MOV     1B8E,W4
02164:  CP      W4,W0
02166:  BRA     LE,2170
....................         { 
....................             pos = 8; //Le point se trouve dans la zone 
02168:  MOV     #8,W4
0216A:  MOV     W4,1B98
....................         } 
0216C:  GOTO    2174
....................         else 
....................         { 
....................             pos = 1; //Le point se trouve en haut de la zone 
02170:  MOV     #1,W4
02172:  MOV     W4,1B98
....................         } 
....................     } 
02174:  GOTO    219A
....................     else 
....................     { 
....................         if (py > ry4) 
02178:  MOV     1B96,W0
0217A:  MOV     1B8E,W4
0217C:  CP      W4,W0
0217E:  BRA     LE,2188
....................         { 
....................             pos = 6; //Le point se trouve en bas Ã  gauche de la zone 
02180:  MOV     #6,W4
02182:  MOV     W4,1B98
....................         } 
02184:  GOTO    219A
....................         else if (py > ry1) 
02188:  MOV     1B92,W0
0218A:  MOV     1B8E,W4
0218C:  CP      W4,W0
0218E:  BRA     LE,2198
....................         { 
....................             pos = 7; //Le point se trouve Ã  gauche de la zone 
02190:  MOV     #7,W4
02192:  MOV     W4,1B98
....................         } 
02194:  GOTO    219A
....................         else 
....................         { 
....................             pos = 0; //Le point se trouve en haut Ã  gauche de la zone 
02198:  CLR     1B98
....................         } 
....................     } 
....................  
....................     return pos; 
0219A:  PUSH    1B98
0219C:  POP     0
0219E:  RETURN  
....................          
.................... } 
....................  
....................  
.................... //********************************************************************************************************************* 
.................... // finRel 
.................... // 
.................... // Cette fonction permet de de trouver le chemin le plus court pour Ã©viter la zone interdite en dÃ©finissant les points 
.................... // relais 
.................... // 
.................... // Developpe par : AurÃ©lien Rithner 
.................... // Date :          16.10.2018 
.................... // Revision :		V1.0 
.................... // 
.................... // parametres  : xStart et yStart coordonnÃ©es du point de dÃ©part, xEnd et yEnd coordonnÃ©es du point de dÃ©part, 
.................... // return      : entier de 0 Ã  8 
.................... // 
.................... //********************************************************************************************************************* 
.................... void findRel(int16 xStart, int16 yStart, int16 xEnd, int16 yEnd, int i_zone) 
*
02E38:  MOV     W5,[W15++]
02E3A:  MOV     #C,W5
02E3C:  REPEAT  #4
02E3E:  MOV     [W5++],[W15++]
02E40:  MOV     1B70,W4
02E42:  MUL.UU  W4,#2,W0
02E44:  MOV     #A92,W4
02E46:  ADD     W0,W4,W0
02E48:  MOV     [W0],W5
02E4A:  MOV     W5,W4
02E4C:  MUL.UU  W4,#10,W0
02E4E:  MOV     W0,W5
02E50:  MOV     #B46,W4
02E52:  ADD     W5,W4,W0
02E54:  MOV     [W0],W6
02E56:  MOV     1B70,W4
02E58:  MUL.UU  W4,#2,W0
02E5A:  MOV     #A92,W4
02E5C:  ADD     W0,W4,W0
02E5E:  MOV     [W0],W7
02E60:  MOV     W7,W4
02E62:  MUL.UU  W4,#10,W0
02E64:  MOV     W0,W7
02E66:  ADD     W7,#4,W7
02E68:  MOV     W7,W0
02E6A:  MOV     #B46,W4
02E6C:  ADD     W0,W4,W0
02E6E:  MOV     [W0],W7
02E70:  MOV     1B70,W4
02E72:  MUL.UU  W4,#2,W0
02E74:  MOV     #A92,W4
02E76:  ADD     W0,W4,W0
02E78:  MOV     [W0],W8
02E7A:  MOV     W8,W4
02E7C:  MUL.UU  W4,#10,W8
02E7E:  ADD     W8,#8,W8
02E80:  MOV     W8,W0
02E82:  MOV     #B46,W4
02E84:  ADD     W0,W4,W0
02E86:  MOV     [W0],W8
02E88:  MOV     1B70,W4
02E8A:  MUL.UU  W4,#2,W0
02E8C:  MOV     #A92,W4
02E8E:  ADD     W0,W4,W0
02E90:  MOV     [W0],W9
02E92:  MOV     W9,W4
02E94:  MUL.UU  W4,#10,W0
02E96:  MOV     W0,W9
02E98:  ADD     W9,#C,W9
02E9A:  MOV     W9,W0
02E9C:  MOV     #B46,W4
02E9E:  ADD     W0,W4,W0
02EA0:  MOV     [W0],W9
02EA2:  PUSH    1B68
02EA4:  POP     1B8C
02EA6:  PUSH    1B6A
02EA8:  POP     1B8E
02EAA:  MOV     W6,1B90
02EAC:  MOV     W7,1B92
02EAE:  MOV     W8,1B94
02EB0:  MOV     W9,1B96
02EB2:  CALL    2118
02EB6:  MOV     W0,1B72
02EB8:  MOV     1B70,W4
02EBA:  MUL.UU  W4,#2,W0
02EBC:  MOV     #A92,W4
02EBE:  ADD     W0,W4,W0
02EC0:  MOV     [W0],W6
02EC2:  MOV     W6,W4
02EC4:  MUL.UU  W4,#10,W6
02EC6:  MOV     #B46,W4
02EC8:  ADD     W6,W4,W0
02ECA:  MOV     [W0],W7
02ECC:  MOV     1B70,W4
02ECE:  MUL.UU  W4,#2,W0
02ED0:  MOV     #A92,W4
02ED2:  ADD     W0,W4,W0
02ED4:  MOV     [W0],W8
02ED6:  MOV     W8,W4
02ED8:  MUL.UU  W4,#10,W8
02EDA:  ADD     W8,#4,W8
02EDC:  MOV     W8,W0
02EDE:  MOV     #B46,W4
02EE0:  ADD     W0,W4,W0
02EE2:  MOV     [W0],W8
02EE4:  MOV     1B70,W4
02EE6:  MUL.UU  W4,#2,W0
02EE8:  MOV     #A92,W4
02EEA:  ADD     W0,W4,W0
02EEC:  MOV     [W0],W9
02EEE:  MOV     W9,W4
02EF0:  MUL.UU  W4,#10,W0
02EF2:  MOV     W0,W9
02EF4:  ADD     W9,#8,W9
02EF6:  MOV     W9,W0
02EF8:  MOV     #B46,W4
02EFA:  ADD     W0,W4,W0
02EFC:  MOV     [W0],W9
02EFE:  MOV     1B70,W4
02F00:  MUL.UU  W4,#2,W0
02F02:  MOV     #A92,W4
02F04:  ADD     W0,W4,W0
02F06:  MOV     [W0],W10
02F08:  MOV     W10,W4
02F0A:  MUL.UU  W4,#10,W10
02F0C:  ADD     W10,#C,W10
02F0E:  MOV     W10,W0
02F10:  MOV     #B46,W4
02F12:  ADD     W0,W4,W0
02F14:  MOV     [W0],W10
02F16:  PUSH    1B6C
02F18:  POP     1B8C
02F1A:  PUSH    1B6E
02F1C:  POP     1B8E
02F1E:  MOV     W7,1B90
02F20:  MOV     W8,1B92
02F22:  MOV     W9,1B94
02F24:  MOV     W10,1B96
02F26:  CALL    2118
02F2A:  MOV     W0,1B74
.................... { 
.................... 	//On rÃ©cupÃ¨re la position des deux points par rapport Ã  la zone 
....................     int posStart = getPos(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................     int posEnd = getPos(xEnd, yEnd, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][1], TabZones[TabIntersection[i_zone]][2], TabZones[TabIntersection[i_zone]][y4]); 
....................  
....................     relay_point_number = 0; 
02F2C:  CLR     A8C
....................  
....................  
....................  
....................     if(posStart == 8 || posEnd == 8) 
02F2E:  MOV     1B72,W4
02F30:  CP      W4,#8
02F32:  BRA     Z,2F3A
02F34:  MOV     1B74,W4
02F36:  CP      W4,#8
02F38:  BRA     NZ,2F40
....................     { 
....................     	path_found = 0; 
02F3A:  CLR     A84
....................     	//path_impossible = 1; 
....................     }	 
02F3C:  GOTO    6CFE
....................     else 
....................     { 
.................... 	    switch (posStart) 
02F40:  MOV     1B72,W0
02F42:  XOR     #0,W0
02F44:  BRA     Z,2F68
02F46:  XOR     #1,W0
02F48:  BRA     Z,35CE
02F4A:  XOR     #3,W0
02F4C:  BRA     Z,3F52
02F4E:  XOR     #1,W0
02F50:  BRA     Z,44B4
02F52:  XOR     #7,W0
02F54:  BRA     Z,4E30
02F56:  XOR     #1,W0
02F58:  BRA     Z,5430
02F5A:  XOR     #3,W0
02F5C:  BRA     Z,5DAC
02F5E:  XOR     #1,W0
02F60:  BRA     Z,6368
02F62:  XOR     #F,W0
02F64:  BRA     Z,6CEC
02F66:  BRA     6CF2
.................... 	    { 
.................... 	        case 0: 
....................  
.................... 	        	if(path_opposite) 
02F68:  CP0     A88
02F6A:  BRA     Z,32CA
.................... 			    { 
.................... 			    	if (posEnd == 3) 
02F6C:  MOV     1B74,W4
02F6E:  CP      W4,#3
02F70:  BRA     NZ,302A
.................... 		            { 
....................  
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
02F72:  MOV     A8E,W4
02F74:  MUL.UU  W4,#8,W0
02F76:  MOV     W0,W5
02F78:  MOV     #AA6,W4
02F7A:  ADD     W5,W4,W6
02F7C:  MOV     1B70,W4
02F7E:  MUL.UU  W4,#2,W0
02F80:  MOV     #A92,W4
02F82:  ADD     W0,W4,W0
02F84:  MOV     [W0],W7
02F86:  MOV     W7,W4
02F88:  MUL.UU  W4,#10,W0
02F8A:  MOV     W0,W7
02F8C:  MOV     1B2A,W4
02F8E:  MUL.UU  W4,#4,W0
02F90:  ADD     W0,W7,W0
02F92:  MOV     #B46,W4
02F94:  ADD     W0,W4,W0
02F96:  MOV     [W0++],[W6++]
02F98:  MOV     [W0++],[W6++]
02F9A:  MOV     A8E,W4
02F9C:  MUL.UU  W4,#8,W0
02F9E:  MOV     W0,W5
02FA0:  ADD     W5,#4,W5
02FA2:  MOV     W5,W0
02FA4:  MOV     #AA6,W4
02FA6:  ADD     W0,W4,W5
02FA8:  MOV     1B70,W4
02FAA:  MUL.UU  W4,#2,W0
02FAC:  MOV     #A92,W4
02FAE:  ADD     W0,W4,W0
02FB0:  MOV     [W0],W6
02FB2:  MOV     W6,W4
02FB4:  MUL.UU  W4,#10,W6
02FB6:  MOV     1B2C,W4
02FB8:  MUL.UU  W4,#4,W0
02FBA:  ADD     W0,W6,W0
02FBC:  MOV     #B46,W4
02FBE:  ADD     W0,W4,W0
02FC0:  MOV     [W0++],[W5++]
02FC2:  MOV     [W0++],[W5++]
.................... 	                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
02FC4:  MOV     A8E,W4
02FC6:  ADD     W4,#1,W4
02FC8:  MOV     W4,W5
02FCA:  MOV     W5,W4
02FCC:  MUL.UU  W4,#8,W0
02FCE:  MOV     W0,W5
02FD0:  MOV     #AA6,W4
02FD2:  ADD     W5,W4,W6
02FD4:  MOV     1B70,W4
02FD6:  MUL.UU  W4,#2,W0
02FD8:  MOV     #A92,W4
02FDA:  ADD     W0,W4,W0
02FDC:  MOV     [W0],W7
02FDE:  MOV     W7,W4
02FE0:  MUL.UU  W4,#10,W0
02FE2:  MOV     W0,W7
02FE4:  ADD     W7,#8,W7
02FE6:  MOV     W7,W0
02FE8:  MOV     #B46,W4
02FEA:  ADD     W0,W4,W0
02FEC:  MOV     [W0++],[W6++]
02FEE:  MOV     [W0++],[W6++]
02FF0:  MOV     A8E,W4
02FF2:  ADD     W4,#1,W4
02FF4:  MOV     W4,W5
02FF6:  MOV     W5,W4
02FF8:  MUL.UU  W4,#8,W0
02FFA:  MOV     W0,W5
02FFC:  ADD     W5,#4,W5
02FFE:  MOV     W5,W0
03000:  MOV     #AA6,W4
03002:  ADD     W0,W4,W5
03004:  MOV     1B70,W4
03006:  MUL.UU  W4,#2,W0
03008:  MOV     #A92,W4
0300A:  ADD     W0,W4,W0
0300C:  MOV     [W0],W6
0300E:  MOV     W6,W4
03010:  MUL.UU  W4,#10,W6
03012:  ADD     W6,#C,W6
03014:  MOV     W6,W0
03016:  MOV     #B46,W4
03018:  ADD     W0,W4,W0
0301A:  MOV     [W0++],[W5++]
0301C:  MOV     [W0++],[W5++]
.................... 	                    relay_point_number = 2; 
0301E:  MOV     #2,W4
03020:  MOV     W4,A8C
.................... 		                path_found = true; 
03022:  MOV     #1,W4
03024:  MOV     W4,A84
.................... 		            } 
03026:  GOTO    32C6
.................... 		            else if (posEnd == 4) 
0302A:  MOV     1B74,W4
0302C:  CP      W4,#4
0302E:  BRA     NZ,320C
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
03030:  MOV     1B70,W4
03032:  MUL.UU  W4,#2,W0
03034:  MOV     #A92,W4
03036:  ADD     W0,W4,W0
03038:  MOV     [W0],W5
0303A:  MOV     W5,W4
0303C:  MUL.UU  W4,#10,W0
0303E:  MOV     W0,W5
03040:  MOV     1B2A,W4
03042:  MUL.UU  W4,#4,W0
03044:  ADD     W0,W5,W0
03046:  MOV     #B46,W4
03048:  ADD     W0,W4,W0
0304A:  MOV     [W0],W5
0304C:  MOV     1B70,W4
0304E:  MUL.UU  W4,#2,W0
03050:  MOV     #A92,W4
03052:  ADD     W0,W4,W0
03054:  MOV     [W0],W6
03056:  MOV     W6,W4
03058:  MUL.UU  W4,#10,W6
0305A:  MOV     1B2C,W4
0305C:  MUL.UU  W4,#4,W0
0305E:  ADD     W0,W6,W0
03060:  MOV     #B46,W4
03062:  ADD     W0,W4,W0
03064:  MOV     [W0],W6
03066:  PUSH    1B68
03068:  POP     1B8C
0306A:  PUSH    1B6A
0306C:  POP     1B8E
0306E:  MOV     W5,1B90
03070:  MOV     W6,1B92
03072:  CALL    2DB6
03076:  MOV     W0,W5
03078:  MOV     1B70,W4
0307A:  MUL.UU  W4,#2,W0
0307C:  MOV     #A92,W4
0307E:  ADD     W0,W4,W0
03080:  MOV     [W0],W6
03082:  MOV     W6,W4
03084:  MUL.UU  W4,#10,W6
03086:  MOV     1B2A,W4
03088:  MUL.UU  W4,#4,W0
0308A:  ADD     W0,W6,W0
0308C:  MOV     #B46,W4
0308E:  ADD     W0,W4,W0
03090:  MOV     [W0],W6
03092:  MOV     1B70,W4
03094:  MUL.UU  W4,#2,W0
03096:  MOV     #A92,W4
03098:  ADD     W0,W4,W0
0309A:  MOV     [W0],W7
0309C:  MOV     W7,W4
0309E:  MUL.UU  W4,#10,W0
030A0:  MOV     W0,W7
030A2:  MOV     1B2C,W4
030A4:  MUL.UU  W4,#4,W0
030A6:  ADD     W0,W7,W0
030A8:  MOV     #B46,W4
030AA:  ADD     W0,W4,W0
030AC:  MOV     [W0],W7
030AE:  MOV     W6,1B8C
030B0:  MOV     W7,1B8E
030B2:  PUSH    1B6C
030B4:  POP     1B90
030B6:  PUSH    1B6E
030B8:  POP     1B92
030BA:  CALL    2DB6
030BE:  ADD     W0,W5,W5
030C0:  MOV     1B70,W4
030C2:  MUL.UU  W4,#2,W0
030C4:  MOV     #A92,W4
030C6:  ADD     W0,W4,W0
030C8:  MOV     [W0],W6
030CA:  MOV     W6,W4
030CC:  MUL.UU  W4,#10,W6
030CE:  MOV     1B2E,W4
030D0:  MUL.UU  W4,#4,W0
030D2:  ADD     W0,W6,W0
030D4:  MOV     #B46,W4
030D6:  ADD     W0,W4,W0
030D8:  MOV     [W0],W6
030DA:  MOV     1B70,W4
030DC:  MUL.UU  W4,#2,W0
030DE:  MOV     #A92,W4
030E0:  ADD     W0,W4,W0
030E2:  MOV     [W0],W7
030E4:  MOV     W7,W4
030E6:  MUL.UU  W4,#10,W0
030E8:  MOV     W0,W7
030EA:  MOV     1B30,W4
030EC:  MUL.UU  W4,#4,W0
030EE:  ADD     W0,W7,W0
030F0:  MOV     #B46,W4
030F2:  ADD     W0,W4,W0
030F4:  MOV     [W0],W7
030F6:  PUSH    1B68
030F8:  POP     1B8C
030FA:  PUSH    1B6A
030FC:  POP     1B8E
030FE:  MOV     W6,1B90
03100:  MOV     W7,1B92
03102:  CALL    2DB6
03106:  MOV     W0,W6
03108:  MOV     1B70,W4
0310A:  MUL.UU  W4,#2,W0
0310C:  MOV     #A92,W4
0310E:  ADD     W0,W4,W0
03110:  MOV     [W0],W7
03112:  MOV     W7,W4
03114:  MUL.UU  W4,#10,W0
03116:  MOV     W0,W7
03118:  MOV     1B2E,W4
0311A:  MUL.UU  W4,#4,W0
0311C:  ADD     W0,W7,W0
0311E:  MOV     #B46,W4
03120:  ADD     W0,W4,W0
03122:  MOV     [W0],W7
03124:  MOV     1B70,W4
03126:  MUL.UU  W4,#2,W0
03128:  MOV     #A92,W4
0312A:  ADD     W0,W4,W0
0312C:  MOV     [W0],W8
0312E:  MOV     W8,W4
03130:  MUL.UU  W4,#10,W8
03132:  MOV     1B30,W4
03134:  MUL.UU  W4,#4,W0
03136:  ADD     W0,W8,W0
03138:  MOV     #B46,W4
0313A:  ADD     W0,W4,W0
0313C:  MOV     [W0],W8
0313E:  MOV     W7,1B8C
03140:  MOV     W8,1B8E
03142:  PUSH    1B6C
03144:  POP     1B90
03146:  PUSH    1B6E
03148:  POP     1B92
0314A:  CALL    2DB6
0314E:  ADD     W0,W6,W0
03150:  CP      W0,W5
03152:  BRA     GE,31AE
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03154:  MOV     A8E,W4
03156:  MUL.UU  W4,#8,W0
03158:  MOV     W0,W5
0315A:  MOV     #AA6,W4
0315C:  ADD     W5,W4,W6
0315E:  MOV     1B70,W4
03160:  MUL.UU  W4,#2,W0
03162:  MOV     #A92,W4
03164:  ADD     W0,W4,W0
03166:  MOV     [W0],W7
03168:  MOV     W7,W4
0316A:  MUL.UU  W4,#10,W0
0316C:  MOV     W0,W7
0316E:  MOV     1B2A,W4
03170:  MUL.UU  W4,#4,W0
03172:  ADD     W0,W7,W0
03174:  MOV     #B46,W4
03176:  ADD     W0,W4,W0
03178:  MOV     [W0++],[W6++]
0317A:  MOV     [W0++],[W6++]
0317C:  MOV     A8E,W4
0317E:  MUL.UU  W4,#8,W0
03180:  MOV     W0,W5
03182:  ADD     W5,#4,W5
03184:  MOV     W5,W0
03186:  MOV     #AA6,W4
03188:  ADD     W0,W4,W5
0318A:  MOV     1B70,W4
0318C:  MUL.UU  W4,#2,W0
0318E:  MOV     #A92,W4
03190:  ADD     W0,W4,W0
03192:  MOV     [W0],W6
03194:  MOV     W6,W4
03196:  MUL.UU  W4,#10,W6
03198:  MOV     1B2C,W4
0319A:  MUL.UU  W4,#4,W0
0319C:  ADD     W0,W6,W0
0319E:  MOV     #B46,W4
031A0:  ADD     W0,W4,W0
031A2:  MOV     [W0++],[W5++]
031A4:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
031A6:  MOV     #1,W4
031A8:  MOV     W4,A8C
.................... 		                } 
031AA:  GOTO    3204
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
031AE:  MOV     A8E,W4
031B0:  MUL.UU  W4,#8,W0
031B2:  MOV     W0,W5
031B4:  MOV     #AA6,W4
031B6:  ADD     W5,W4,W6
031B8:  MOV     1B70,W4
031BA:  MUL.UU  W4,#2,W0
031BC:  MOV     #A92,W4
031BE:  ADD     W0,W4,W0
031C0:  MOV     [W0],W7
031C2:  MOV     W7,W4
031C4:  MUL.UU  W4,#10,W0
031C6:  MOV     W0,W7
031C8:  MOV     1B2E,W4
031CA:  MUL.UU  W4,#4,W0
031CC:  ADD     W0,W7,W0
031CE:  MOV     #B46,W4
031D0:  ADD     W0,W4,W0
031D2:  MOV     [W0++],[W6++]
031D4:  MOV     [W0++],[W6++]
031D6:  MOV     A8E,W4
031D8:  MUL.UU  W4,#8,W0
031DA:  MOV     W0,W5
031DC:  ADD     W5,#4,W5
031DE:  MOV     W5,W0
031E0:  MOV     #AA6,W4
031E2:  ADD     W0,W4,W5
031E4:  MOV     1B70,W4
031E6:  MUL.UU  W4,#2,W0
031E8:  MOV     #A92,W4
031EA:  ADD     W0,W4,W0
031EC:  MOV     [W0],W6
031EE:  MOV     W6,W4
031F0:  MUL.UU  W4,#10,W6
031F2:  MOV     1B30,W4
031F4:  MUL.UU  W4,#4,W0
031F6:  ADD     W0,W6,W0
031F8:  MOV     #B46,W4
031FA:  ADD     W0,W4,W0
031FC:  MOV     [W0++],[W5++]
031FE:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03200:  MOV     #1,W4
03202:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
03204:  MOV     #1,W4
03206:  MOV     W4,A84
.................... 		            } 
03208:  GOTO    32C6
.................... 		            else if (posEnd == 5) 
0320C:  MOV     1B74,W4
0320E:  CP      W4,#5
03210:  BRA     NZ,32C6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03212:  MOV     A8E,W4
03214:  MUL.UU  W4,#8,W0
03216:  MOV     W0,W5
03218:  MOV     #AA6,W4
0321A:  ADD     W5,W4,W6
0321C:  MOV     1B70,W4
0321E:  MUL.UU  W4,#2,W0
03220:  MOV     #A92,W4
03222:  ADD     W0,W4,W0
03224:  MOV     [W0],W7
03226:  MOV     W7,W4
03228:  MUL.UU  W4,#10,W0
0322A:  MOV     W0,W7
0322C:  MOV     1B2E,W4
0322E:  MUL.UU  W4,#4,W0
03230:  ADD     W0,W7,W0
03232:  MOV     #B46,W4
03234:  ADD     W0,W4,W0
03236:  MOV     [W0++],[W6++]
03238:  MOV     [W0++],[W6++]
0323A:  MOV     A8E,W4
0323C:  MUL.UU  W4,#8,W0
0323E:  MOV     W0,W5
03240:  ADD     W5,#4,W5
03242:  MOV     W5,W0
03244:  MOV     #AA6,W4
03246:  ADD     W0,W4,W5
03248:  MOV     1B70,W4
0324A:  MUL.UU  W4,#2,W0
0324C:  MOV     #A92,W4
0324E:  ADD     W0,W4,W0
03250:  MOV     [W0],W6
03252:  MOV     W6,W4
03254:  MUL.UU  W4,#10,W6
03256:  MOV     1B30,W4
03258:  MUL.UU  W4,#4,W0
0325A:  ADD     W0,W6,W0
0325C:  MOV     #B46,W4
0325E:  ADD     W0,W4,W0
03260:  MOV     [W0++],[W5++]
03262:  MOV     [W0++],[W5++]
.................... 	                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03264:  MOV     A8E,W4
03266:  ADD     W4,#1,W4
03268:  MOV     W4,W5
0326A:  MOV     W5,W4
0326C:  MUL.UU  W4,#8,W0
0326E:  MOV     W0,W5
03270:  MOV     #AA6,W4
03272:  ADD     W5,W4,W6
03274:  MOV     1B70,W4
03276:  MUL.UU  W4,#2,W0
03278:  MOV     #A92,W4
0327A:  ADD     W0,W4,W0
0327C:  MOV     [W0],W7
0327E:  MOV     W7,W4
03280:  MUL.UU  W4,#10,W0
03282:  MOV     W0,W7
03284:  ADD     W7,#8,W7
03286:  MOV     W7,W0
03288:  MOV     #B46,W4
0328A:  ADD     W0,W4,W0
0328C:  MOV     [W0++],[W6++]
0328E:  MOV     [W0++],[W6++]
03290:  MOV     A8E,W4
03292:  ADD     W4,#1,W4
03294:  MOV     W4,W5
03296:  MOV     W5,W4
03298:  MUL.UU  W4,#8,W0
0329A:  MOV     W0,W5
0329C:  ADD     W5,#4,W5
0329E:  MOV     W5,W0
032A0:  MOV     #AA6,W4
032A2:  ADD     W0,W4,W5
032A4:  MOV     1B70,W4
032A6:  MUL.UU  W4,#2,W0
032A8:  MOV     #A92,W4
032AA:  ADD     W0,W4,W0
032AC:  MOV     [W0],W6
032AE:  MOV     W6,W4
032B0:  MUL.UU  W4,#10,W6
032B2:  ADD     W6,#C,W6
032B4:  MOV     W6,W0
032B6:  MOV     #B46,W4
032B8:  ADD     W0,W4,W0
032BA:  MOV     [W0++],[W5++]
032BC:  MOV     [W0++],[W5++]
.................... 	                    relay_point_number = 2; 
032BE:  MOV     #2,W4
032C0:  MOV     W4,A8C
.................... 		                path_found = true; 
032C2:  MOV     #1,W4
032C4:  MOV     W4,A84
.................... 		            } 
.................... 			    } 
032C6:  GOTO    35CA
.................... 			    else 
.................... 			    { 
.................... 	            	if (posEnd == 3) 
032CA:  MOV     1B74,W4
032CC:  CP      W4,#3
032CE:  BRA     NZ,332E
.................... 		            { 
....................  
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
032D0:  MOV     A8E,W4
032D2:  MUL.UU  W4,#8,W0
032D4:  MOV     W0,W5
032D6:  MOV     #AA6,W4
032D8:  ADD     W5,W4,W6
032DA:  MOV     1B70,W4
032DC:  MUL.UU  W4,#2,W0
032DE:  MOV     #A92,W4
032E0:  ADD     W0,W4,W0
032E2:  MOV     [W0],W7
032E4:  MOV     W7,W4
032E6:  MUL.UU  W4,#10,W0
032E8:  MOV     W0,W7
032EA:  MOV     1B2E,W4
032EC:  MUL.UU  W4,#4,W0
032EE:  ADD     W0,W7,W0
032F0:  MOV     #B46,W4
032F2:  ADD     W0,W4,W0
032F4:  MOV     [W0++],[W6++]
032F6:  MOV     [W0++],[W6++]
032F8:  MOV     A8E,W4
032FA:  MUL.UU  W4,#8,W0
032FC:  MOV     W0,W5
032FE:  ADD     W5,#4,W5
03300:  MOV     W5,W0
03302:  MOV     #AA6,W4
03304:  ADD     W0,W4,W5
03306:  MOV     1B70,W4
03308:  MUL.UU  W4,#2,W0
0330A:  MOV     #A92,W4
0330C:  ADD     W0,W4,W0
0330E:  MOV     [W0],W6
03310:  MOV     W6,W4
03312:  MUL.UU  W4,#10,W6
03314:  MOV     1B30,W4
03316:  MUL.UU  W4,#4,W0
03318:  ADD     W0,W6,W0
0331A:  MOV     #B46,W4
0331C:  ADD     W0,W4,W0
0331E:  MOV     [W0++],[W5++]
03320:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03322:  MOV     #1,W4
03324:  MOV     W4,A8C
.................... 		                path_found = true; 
03326:  MOV     #1,W4
03328:  MOV     W4,A84
.................... 		            } 
0332A:  GOTO    35CA
.................... 		            else if (posEnd == 4) 
0332E:  MOV     1B74,W4
03330:  CP      W4,#4
03332:  BRA     NZ,3510
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) > (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd))) 
03334:  MOV     1B70,W4
03336:  MUL.UU  W4,#2,W0
03338:  MOV     #A92,W4
0333A:  ADD     W0,W4,W0
0333C:  MOV     [W0],W5
0333E:  MOV     W5,W4
03340:  MUL.UU  W4,#10,W0
03342:  MOV     W0,W5
03344:  MOV     1B2A,W4
03346:  MUL.UU  W4,#4,W0
03348:  ADD     W0,W5,W0
0334A:  MOV     #B46,W4
0334C:  ADD     W0,W4,W0
0334E:  MOV     [W0],W5
03350:  MOV     1B70,W4
03352:  MUL.UU  W4,#2,W0
03354:  MOV     #A92,W4
03356:  ADD     W0,W4,W0
03358:  MOV     [W0],W6
0335A:  MOV     W6,W4
0335C:  MUL.UU  W4,#10,W6
0335E:  MOV     1B2C,W4
03360:  MUL.UU  W4,#4,W0
03362:  ADD     W0,W6,W0
03364:  MOV     #B46,W4
03366:  ADD     W0,W4,W0
03368:  MOV     [W0],W6
0336A:  PUSH    1B68
0336C:  POP     1B8C
0336E:  PUSH    1B6A
03370:  POP     1B8E
03372:  MOV     W5,1B90
03374:  MOV     W6,1B92
03376:  CALL    2DB6
0337A:  MOV     W0,W5
0337C:  MOV     1B70,W4
0337E:  MUL.UU  W4,#2,W0
03380:  MOV     #A92,W4
03382:  ADD     W0,W4,W0
03384:  MOV     [W0],W6
03386:  MOV     W6,W4
03388:  MUL.UU  W4,#10,W6
0338A:  MOV     1B2A,W4
0338C:  MUL.UU  W4,#4,W0
0338E:  ADD     W0,W6,W0
03390:  MOV     #B46,W4
03392:  ADD     W0,W4,W0
03394:  MOV     [W0],W6
03396:  MOV     1B70,W4
03398:  MUL.UU  W4,#2,W0
0339A:  MOV     #A92,W4
0339C:  ADD     W0,W4,W0
0339E:  MOV     [W0],W7
033A0:  MOV     W7,W4
033A2:  MUL.UU  W4,#10,W0
033A4:  MOV     W0,W7
033A6:  MOV     1B2C,W4
033A8:  MUL.UU  W4,#4,W0
033AA:  ADD     W0,W7,W0
033AC:  MOV     #B46,W4
033AE:  ADD     W0,W4,W0
033B0:  MOV     [W0],W7
033B2:  MOV     W6,1B8C
033B4:  MOV     W7,1B8E
033B6:  PUSH    1B6C
033B8:  POP     1B90
033BA:  PUSH    1B6E
033BC:  POP     1B92
033BE:  CALL    2DB6
033C2:  ADD     W0,W5,W5
033C4:  MOV     1B70,W4
033C6:  MUL.UU  W4,#2,W0
033C8:  MOV     #A92,W4
033CA:  ADD     W0,W4,W0
033CC:  MOV     [W0],W6
033CE:  MOV     W6,W4
033D0:  MUL.UU  W4,#10,W6
033D2:  MOV     1B2E,W4
033D4:  MUL.UU  W4,#4,W0
033D6:  ADD     W0,W6,W0
033D8:  MOV     #B46,W4
033DA:  ADD     W0,W4,W0
033DC:  MOV     [W0],W6
033DE:  MOV     1B70,W4
033E0:  MUL.UU  W4,#2,W0
033E2:  MOV     #A92,W4
033E4:  ADD     W0,W4,W0
033E6:  MOV     [W0],W7
033E8:  MOV     W7,W4
033EA:  MUL.UU  W4,#10,W0
033EC:  MOV     W0,W7
033EE:  MOV     1B30,W4
033F0:  MUL.UU  W4,#4,W0
033F2:  ADD     W0,W7,W0
033F4:  MOV     #B46,W4
033F6:  ADD     W0,W4,W0
033F8:  MOV     [W0],W7
033FA:  PUSH    1B68
033FC:  POP     1B8C
033FE:  PUSH    1B6A
03400:  POP     1B8E
03402:  MOV     W6,1B90
03404:  MOV     W7,1B92
03406:  CALL    2DB6
0340A:  MOV     W0,W6
0340C:  MOV     1B70,W4
0340E:  MUL.UU  W4,#2,W0
03410:  MOV     #A92,W4
03412:  ADD     W0,W4,W0
03414:  MOV     [W0],W7
03416:  MOV     W7,W4
03418:  MUL.UU  W4,#10,W0
0341A:  MOV     W0,W7
0341C:  MOV     1B2E,W4
0341E:  MUL.UU  W4,#4,W0
03420:  ADD     W0,W7,W0
03422:  MOV     #B46,W4
03424:  ADD     W0,W4,W0
03426:  MOV     [W0],W7
03428:  MOV     1B70,W4
0342A:  MUL.UU  W4,#2,W0
0342C:  MOV     #A92,W4
0342E:  ADD     W0,W4,W0
03430:  MOV     [W0],W8
03432:  MOV     W8,W4
03434:  MUL.UU  W4,#10,W8
03436:  MOV     1B30,W4
03438:  MUL.UU  W4,#4,W0
0343A:  ADD     W0,W8,W0
0343C:  MOV     #B46,W4
0343E:  ADD     W0,W4,W0
03440:  MOV     [W0],W8
03442:  MOV     W7,1B8C
03444:  MOV     W8,1B8E
03446:  PUSH    1B6C
03448:  POP     1B90
0344A:  PUSH    1B6E
0344C:  POP     1B92
0344E:  CALL    2DB6
03452:  ADD     W0,W6,W0
03454:  CP      W0,W5
03456:  BRA     GE,34B2
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03458:  MOV     A8E,W4
0345A:  MUL.UU  W4,#8,W0
0345C:  MOV     W0,W5
0345E:  MOV     #AA6,W4
03460:  ADD     W5,W4,W6
03462:  MOV     1B70,W4
03464:  MUL.UU  W4,#2,W0
03466:  MOV     #A92,W4
03468:  ADD     W0,W4,W0
0346A:  MOV     [W0],W7
0346C:  MOV     W7,W4
0346E:  MUL.UU  W4,#10,W0
03470:  MOV     W0,W7
03472:  MOV     1B2E,W4
03474:  MUL.UU  W4,#4,W0
03476:  ADD     W0,W7,W0
03478:  MOV     #B46,W4
0347A:  ADD     W0,W4,W0
0347C:  MOV     [W0++],[W6++]
0347E:  MOV     [W0++],[W6++]
03480:  MOV     A8E,W4
03482:  MUL.UU  W4,#8,W0
03484:  MOV     W0,W5
03486:  ADD     W5,#4,W5
03488:  MOV     W5,W0
0348A:  MOV     #AA6,W4
0348C:  ADD     W0,W4,W5
0348E:  MOV     1B70,W4
03490:  MUL.UU  W4,#2,W0
03492:  MOV     #A92,W4
03494:  ADD     W0,W4,W0
03496:  MOV     [W0],W6
03498:  MOV     W6,W4
0349A:  MUL.UU  W4,#10,W6
0349C:  MOV     1B30,W4
0349E:  MUL.UU  W4,#4,W0
034A0:  ADD     W0,W6,W0
034A2:  MOV     #B46,W4
034A4:  ADD     W0,W4,W0
034A6:  MOV     [W0++],[W5++]
034A8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
034AA:  MOV     #1,W4
034AC:  MOV     W4,A8C
.................... 		                } 
034AE:  GOTO    3508
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
034B2:  MOV     A8E,W4
034B4:  MUL.UU  W4,#8,W0
034B6:  MOV     W0,W5
034B8:  MOV     #AA6,W4
034BA:  ADD     W5,W4,W6
034BC:  MOV     1B70,W4
034BE:  MUL.UU  W4,#2,W0
034C0:  MOV     #A92,W4
034C2:  ADD     W0,W4,W0
034C4:  MOV     [W0],W7
034C6:  MOV     W7,W4
034C8:  MUL.UU  W4,#10,W0
034CA:  MOV     W0,W7
034CC:  MOV     1B2A,W4
034CE:  MUL.UU  W4,#4,W0
034D0:  ADD     W0,W7,W0
034D2:  MOV     #B46,W4
034D4:  ADD     W0,W4,W0
034D6:  MOV     [W0++],[W6++]
034D8:  MOV     [W0++],[W6++]
034DA:  MOV     A8E,W4
034DC:  MUL.UU  W4,#8,W0
034DE:  MOV     W0,W5
034E0:  ADD     W5,#4,W5
034E2:  MOV     W5,W0
034E4:  MOV     #AA6,W4
034E6:  ADD     W0,W4,W5
034E8:  MOV     1B70,W4
034EA:  MUL.UU  W4,#2,W0
034EC:  MOV     #A92,W4
034EE:  ADD     W0,W4,W0
034F0:  MOV     [W0],W6
034F2:  MOV     W6,W4
034F4:  MUL.UU  W4,#10,W6
034F6:  MOV     1B2C,W4
034F8:  MUL.UU  W4,#4,W0
034FA:  ADD     W0,W6,W0
034FC:  MOV     #B46,W4
034FE:  ADD     W0,W4,W0
03500:  MOV     [W0++],[W5++]
03502:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
03504:  MOV     #1,W4
03506:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
03508:  MOV     #1,W4
0350A:  MOV     W4,A84
.................... 		            } 
0350C:  GOTO    35CA
.................... 		            else if (posEnd == 5) 
03510:  MOV     1B74,W4
03512:  CP      W4,#5
03514:  BRA     NZ,35CA
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03516:  MOV     A8E,W4
03518:  MUL.UU  W4,#8,W0
0351A:  MOV     W0,W5
0351C:  MOV     #AA6,W4
0351E:  ADD     W5,W4,W6
03520:  MOV     1B70,W4
03522:  MUL.UU  W4,#2,W0
03524:  MOV     #A92,W4
03526:  ADD     W0,W4,W0
03528:  MOV     [W0],W7
0352A:  MOV     W7,W4
0352C:  MUL.UU  W4,#10,W0
0352E:  MOV     W0,W7
03530:  MOV     1B2E,W4
03532:  MUL.UU  W4,#4,W0
03534:  ADD     W0,W7,W0
03536:  MOV     #B46,W4
03538:  ADD     W0,W4,W0
0353A:  MOV     [W0++],[W6++]
0353C:  MOV     [W0++],[W6++]
0353E:  MOV     A8E,W4
03540:  MUL.UU  W4,#8,W0
03542:  MOV     W0,W5
03544:  ADD     W5,#4,W5
03546:  MOV     W5,W0
03548:  MOV     #AA6,W4
0354A:  ADD     W0,W4,W5
0354C:  MOV     1B70,W4
0354E:  MUL.UU  W4,#2,W0
03550:  MOV     #A92,W4
03552:  ADD     W0,W4,W0
03554:  MOV     [W0],W6
03556:  MOV     W6,W4
03558:  MUL.UU  W4,#10,W6
0355A:  MOV     1B30,W4
0355C:  MUL.UU  W4,#4,W0
0355E:  ADD     W0,W6,W0
03560:  MOV     #B46,W4
03562:  ADD     W0,W4,W0
03564:  MOV     [W0++],[W5++]
03566:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03568:  MOV     A8E,W4
0356A:  ADD     W4,#1,W4
0356C:  MOV     W4,W5
0356E:  MOV     W5,W4
03570:  MUL.UU  W4,#8,W0
03572:  MOV     W0,W5
03574:  MOV     #AA6,W4
03576:  ADD     W5,W4,W6
03578:  MOV     1B70,W4
0357A:  MUL.UU  W4,#2,W0
0357C:  MOV     #A92,W4
0357E:  ADD     W0,W4,W0
03580:  MOV     [W0],W7
03582:  MOV     W7,W4
03584:  MUL.UU  W4,#10,W0
03586:  MOV     W0,W7
03588:  ADD     W7,#8,W7
0358A:  MOV     W7,W0
0358C:  MOV     #B46,W4
0358E:  ADD     W0,W4,W0
03590:  MOV     [W0++],[W6++]
03592:  MOV     [W0++],[W6++]
03594:  MOV     A8E,W4
03596:  ADD     W4,#1,W4
03598:  MOV     W4,W5
0359A:  MOV     W5,W4
0359C:  MUL.UU  W4,#8,W0
0359E:  MOV     W0,W5
035A0:  ADD     W5,#4,W5
035A2:  MOV     W5,W0
035A4:  MOV     #AA6,W4
035A6:  ADD     W0,W4,W5
035A8:  MOV     1B70,W4
035AA:  MUL.UU  W4,#2,W0
035AC:  MOV     #A92,W4
035AE:  ADD     W0,W4,W0
035B0:  MOV     [W0],W6
035B2:  MOV     W6,W4
035B4:  MUL.UU  W4,#10,W6
035B6:  ADD     W6,#C,W6
035B8:  MOV     W6,W0
035BA:  MOV     #B46,W4
035BC:  ADD     W0,W4,W0
035BE:  MOV     [W0++],[W5++]
035C0:  MOV     [W0++],[W5++]
....................  
.................... 		                relay_point_number = 2; 
035C2:  MOV     #2,W4
035C4:  MOV     W4,A8C
.................... 		                path_found = true; 
035C6:  MOV     #1,W4
035C8:  MOV     W4,A84
.................... 		            } 
.................... 			    } 
....................  
....................  
.................... 	            break; 
035CA:  GOTO    6CF8
....................  
.................... 	        case 1: 
.................... 	        	if(path_opposite) 
035CE:  CP0     A88
035D0:  BRA     Z,3BFE
.................... 	        	{ 
.................... 	    			if (posEnd == 3) 
035D2:  MOV     1B74,W4
035D4:  CP      W4,#3
035D6:  BRA     NZ,36E6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
035D8:  MOV     A8E,W4
035DA:  MUL.UU  W4,#8,W0
035DC:  MOV     W0,W5
035DE:  MOV     #AA6,W4
035E0:  ADD     W5,W4,W6
035E2:  MOV     1B70,W4
035E4:  MUL.UU  W4,#2,W0
035E6:  MOV     #A92,W4
035E8:  ADD     W0,W4,W0
035EA:  MOV     [W0],W7
035EC:  MOV     W7,W4
035EE:  MUL.UU  W4,#10,W0
035F0:  MOV     W0,W7
035F2:  MOV     #B46,W4
035F4:  ADD     W7,W4,W0
035F6:  MOV     [W0++],[W6++]
035F8:  MOV     [W0++],[W6++]
035FA:  MOV     A8E,W4
035FC:  MUL.UU  W4,#8,W0
035FE:  MOV     W0,W5
03600:  ADD     W5,#4,W5
03602:  MOV     W5,W0
03604:  MOV     #AA6,W4
03606:  ADD     W0,W4,W5
03608:  MOV     1B70,W4
0360A:  MUL.UU  W4,#2,W0
0360C:  MOV     #A92,W4
0360E:  ADD     W0,W4,W0
03610:  MOV     [W0],W6
03612:  MOV     W6,W4
03614:  MUL.UU  W4,#10,W6
03616:  ADD     W6,#4,W6
03618:  MOV     W6,W0
0361A:  MOV     #B46,W4
0361C:  ADD     W0,W4,W0
0361E:  MOV     [W0++],[W5++]
03620:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03622:  MOV     A8E,W4
03624:  ADD     W4,#1,W4
03626:  MOV     W4,W5
03628:  MOV     W5,W4
0362A:  MUL.UU  W4,#8,W0
0362C:  MOV     W0,W5
0362E:  MOV     #AA6,W4
03630:  ADD     W5,W4,W6
03632:  MOV     1B70,W4
03634:  MUL.UU  W4,#2,W0
03636:  MOV     #A92,W4
03638:  ADD     W0,W4,W0
0363A:  MOV     [W0],W7
0363C:  MOV     W7,W4
0363E:  MUL.UU  W4,#10,W0
03640:  MOV     W0,W7
03642:  MOV     1B2A,W4
03644:  MUL.UU  W4,#4,W0
03646:  ADD     W0,W7,W0
03648:  MOV     #B46,W4
0364A:  ADD     W0,W4,W0
0364C:  MOV     [W0++],[W6++]
0364E:  MOV     [W0++],[W6++]
03650:  MOV     A8E,W4
03652:  ADD     W4,#1,W4
03654:  MOV     W4,W5
03656:  MOV     W5,W4
03658:  MUL.UU  W4,#8,W0
0365A:  MOV     W0,W5
0365C:  ADD     W5,#4,W5
0365E:  MOV     W5,W0
03660:  MOV     #AA6,W4
03662:  ADD     W0,W4,W5
03664:  MOV     1B70,W4
03666:  MUL.UU  W4,#2,W0
03668:  MOV     #A92,W4
0366A:  ADD     W0,W4,W0
0366C:  MOV     [W0],W6
0366E:  MOV     W6,W4
03670:  MUL.UU  W4,#10,W6
03672:  MOV     1B2C,W4
03674:  MUL.UU  W4,#4,W0
03676:  ADD     W0,W6,W0
03678:  MOV     #B46,W4
0367A:  ADD     W0,W4,W0
0367C:  MOV     [W0++],[W5++]
0367E:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03680:  MOV     A8E,W4
03682:  ADD     W4,#2,W4
03684:  MOV     W4,W5
03686:  MOV     W5,W4
03688:  MUL.UU  W4,#8,W0
0368A:  MOV     W0,W5
0368C:  MOV     #AA6,W4
0368E:  ADD     W5,W4,W6
03690:  MOV     1B70,W4
03692:  MUL.UU  W4,#2,W0
03694:  MOV     #A92,W4
03696:  ADD     W0,W4,W0
03698:  MOV     [W0],W7
0369A:  MOV     W7,W4
0369C:  MUL.UU  W4,#10,W0
0369E:  MOV     W0,W7
036A0:  ADD     W7,#8,W7
036A2:  MOV     W7,W0
036A4:  MOV     #B46,W4
036A6:  ADD     W0,W4,W0
036A8:  MOV     [W0++],[W6++]
036AA:  MOV     [W0++],[W6++]
036AC:  MOV     A8E,W4
036AE:  ADD     W4,#2,W4
036B0:  MOV     W4,W5
036B2:  MOV     W5,W4
036B4:  MUL.UU  W4,#8,W0
036B6:  MOV     W0,W5
036B8:  ADD     W5,#4,W5
036BA:  MOV     W5,W0
036BC:  MOV     #AA6,W4
036BE:  ADD     W0,W4,W5
036C0:  MOV     1B70,W4
036C2:  MUL.UU  W4,#2,W0
036C4:  MOV     #A92,W4
036C6:  ADD     W0,W4,W0
036C8:  MOV     [W0],W6
036CA:  MOV     W6,W4
036CC:  MUL.UU  W4,#10,W6
036CE:  ADD     W6,#C,W6
036D0:  MOV     W6,W0
036D2:  MOV     #B46,W4
036D4:  ADD     W0,W4,W0
036D6:  MOV     [W0++],[W5++]
036D8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
036DA:  MOV     #3,W4
036DC:  MOV     W4,A8C
.................... 		                path_found = true; 
036DE:  MOV     #1,W4
036E0:  MOV     W4,A84
.................... 		            } 
036E2:  GOTO    3BFA
.................... 		            else if (posEnd == 4) 
036E6:  MOV     1B74,W4
036E8:  CP      W4,#4
036EA:  BRA     NZ,37A0
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
036EC:  MOV     A8E,W4
036EE:  MUL.UU  W4,#8,W0
036F0:  MOV     W0,W5
036F2:  MOV     #AA6,W4
036F4:  ADD     W5,W4,W6
036F6:  MOV     1B70,W4
036F8:  MUL.UU  W4,#2,W0
036FA:  MOV     #A92,W4
036FC:  ADD     W0,W4,W0
036FE:  MOV     [W0],W7
03700:  MOV     W7,W4
03702:  MUL.UU  W4,#10,W0
03704:  MOV     W0,W7
03706:  MOV     #B46,W4
03708:  ADD     W7,W4,W0
0370A:  MOV     [W0++],[W6++]
0370C:  MOV     [W0++],[W6++]
0370E:  MOV     A8E,W4
03710:  MUL.UU  W4,#8,W0
03712:  MOV     W0,W5
03714:  ADD     W5,#4,W5
03716:  MOV     W5,W0
03718:  MOV     #AA6,W4
0371A:  ADD     W0,W4,W5
0371C:  MOV     1B70,W4
0371E:  MUL.UU  W4,#2,W0
03720:  MOV     #A92,W4
03722:  ADD     W0,W4,W0
03724:  MOV     [W0],W6
03726:  MOV     W6,W4
03728:  MUL.UU  W4,#10,W6
0372A:  ADD     W6,#4,W6
0372C:  MOV     W6,W0
0372E:  MOV     #B46,W4
03730:  ADD     W0,W4,W0
03732:  MOV     [W0++],[W5++]
03734:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03736:  MOV     A8E,W4
03738:  ADD     W4,#1,W4
0373A:  MOV     W4,W5
0373C:  MOV     W5,W4
0373E:  MUL.UU  W4,#8,W0
03740:  MOV     W0,W5
03742:  MOV     #AA6,W4
03744:  ADD     W5,W4,W6
03746:  MOV     1B70,W4
03748:  MUL.UU  W4,#2,W0
0374A:  MOV     #A92,W4
0374C:  ADD     W0,W4,W0
0374E:  MOV     [W0],W7
03750:  MOV     W7,W4
03752:  MUL.UU  W4,#10,W0
03754:  MOV     W0,W7
03756:  MOV     1B2A,W4
03758:  MUL.UU  W4,#4,W0
0375A:  ADD     W0,W7,W0
0375C:  MOV     #B46,W4
0375E:  ADD     W0,W4,W0
03760:  MOV     [W0++],[W6++]
03762:  MOV     [W0++],[W6++]
03764:  MOV     A8E,W4
03766:  ADD     W4,#1,W4
03768:  MOV     W4,W5
0376A:  MOV     W5,W4
0376C:  MUL.UU  W4,#8,W0
0376E:  MOV     W0,W5
03770:  ADD     W5,#4,W5
03772:  MOV     W5,W0
03774:  MOV     #AA6,W4
03776:  ADD     W0,W4,W5
03778:  MOV     1B70,W4
0377A:  MUL.UU  W4,#2,W0
0377C:  MOV     #A92,W4
0377E:  ADD     W0,W4,W0
03780:  MOV     [W0],W6
03782:  MOV     W6,W4
03784:  MUL.UU  W4,#10,W6
03786:  MOV     1B2C,W4
03788:  MUL.UU  W4,#4,W0
0378A:  ADD     W0,W6,W0
0378C:  MOV     #B46,W4
0378E:  ADD     W0,W4,W0
03790:  MOV     [W0++],[W5++]
03792:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03794:  MOV     #2,W4
03796:  MOV     W4,A8C
.................... 		                path_found = true; 
03798:  MOV     #1,W4
0379A:  MOV     W4,A84
.................... 		            } 
0379C:  GOTO    3BFA
.................... 		            else if (posEnd == 5) 
037A0:  MOV     1B74,W4
037A2:  CP      W4,#5
037A4:  BRA     NZ,3A28
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
037A6:  MOV     1B70,W4
037A8:  MUL.UU  W4,#2,W0
037AA:  MOV     #A92,W4
037AC:  ADD     W0,W4,W0
037AE:  MOV     [W0],W5
037B0:  MOV     W5,W4
037B2:  MUL.UU  W4,#10,W0
037B4:  MOV     W0,W5
037B6:  MOV     #B46,W4
037B8:  ADD     W5,W4,W0
037BA:  MOV     [W0],W6
037BC:  MOV     1B70,W4
037BE:  MUL.UU  W4,#2,W0
037C0:  MOV     #A92,W4
037C2:  ADD     W0,W4,W0
037C4:  MOV     [W0],W7
037C6:  MOV     W7,W4
037C8:  MUL.UU  W4,#10,W0
037CA:  MOV     W0,W7
037CC:  ADD     W7,#4,W7
037CE:  MOV     W7,W0
037D0:  MOV     #B46,W4
037D2:  ADD     W0,W4,W0
037D4:  MOV     [W0],W7
037D6:  PUSH    1B68
037D8:  POP     1B8C
037DA:  PUSH    1B6A
037DC:  POP     1B8E
037DE:  MOV     W6,1B90
037E0:  MOV     W7,1B92
037E2:  CALL    2DB6
037E6:  MOV     W0,W6
037E8:  MOV     1B70,W4
037EA:  MUL.UU  W4,#2,W0
037EC:  MOV     #A92,W4
037EE:  ADD     W0,W4,W0
037F0:  MOV     [W0],W7
037F2:  MOV     W7,W4
037F4:  MUL.UU  W4,#10,W0
037F6:  MOV     W0,W7
037F8:  MOV     1B2A,W4
037FA:  MUL.UU  W4,#4,W0
037FC:  ADD     W0,W7,W0
037FE:  MOV     #B46,W4
03800:  ADD     W0,W4,W0
03802:  MOV     [W0],W7
03804:  MOV     1B70,W4
03806:  MUL.UU  W4,#2,W0
03808:  MOV     #A92,W4
0380A:  ADD     W0,W4,W0
0380C:  MOV     [W0],W8
0380E:  MOV     W8,W4
03810:  MUL.UU  W4,#10,W8
03812:  MOV     1B2C,W4
03814:  MUL.UU  W4,#4,W0
03816:  ADD     W0,W8,W0
03818:  MOV     #B46,W4
0381A:  ADD     W0,W4,W0
0381C:  MOV     [W0],W8
0381E:  MOV     W7,1B8C
03820:  MOV     W8,1B8E
03822:  PUSH    1B6C
03824:  POP     1B90
03826:  PUSH    1B6E
03828:  POP     1B92
0382A:  CALL    2DB6
0382E:  ADD     W0,W6,W6
03830:  MOV     1B70,W4
03832:  MUL.UU  W4,#2,W0
03834:  MOV     #A92,W4
03836:  ADD     W0,W4,W0
03838:  MOV     [W0],W7
0383A:  MOV     W7,W4
0383C:  MUL.UU  W4,#10,W0
0383E:  MOV     W0,W7
03840:  MOV     1B2E,W4
03842:  MUL.UU  W4,#4,W0
03844:  ADD     W0,W7,W0
03846:  MOV     #B46,W4
03848:  ADD     W0,W4,W0
0384A:  MOV     [W0],W7
0384C:  MOV     1B70,W4
0384E:  MUL.UU  W4,#2,W0
03850:  MOV     #A92,W4
03852:  ADD     W0,W4,W0
03854:  MOV     [W0],W8
03856:  MOV     W8,W4
03858:  MUL.UU  W4,#10,W8
0385A:  MOV     1B30,W4
0385C:  MUL.UU  W4,#4,W0
0385E:  ADD     W0,W8,W0
03860:  MOV     #B46,W4
03862:  ADD     W0,W4,W0
03864:  MOV     [W0],W8
03866:  PUSH    1B68
03868:  POP     1B8C
0386A:  PUSH    1B6A
0386C:  POP     1B8E
0386E:  MOV     W7,1B90
03870:  MOV     W8,1B92
03872:  CALL    2DB6
03876:  MOV     W0,W7
03878:  MOV     1B70,W4
0387A:  MUL.UU  W4,#2,W0
0387C:  MOV     #A92,W4
0387E:  ADD     W0,W4,W0
03880:  MOV     [W0],W8
03882:  MOV     W8,W4
03884:  MUL.UU  W4,#10,W8
03886:  ADD     W8,#8,W8
03888:  MOV     W8,W0
0388A:  MOV     #B46,W4
0388C:  ADD     W0,W4,W0
0388E:  MOV     [W0],W8
03890:  MOV     1B70,W4
03892:  MUL.UU  W4,#2,W0
03894:  MOV     #A92,W4
03896:  ADD     W0,W4,W0
03898:  MOV     [W0],W9
0389A:  MOV     W9,W4
0389C:  MUL.UU  W4,#10,W0
0389E:  MOV     W0,W9
038A0:  ADD     W9,#C,W9
038A2:  MOV     W9,W0
038A4:  MOV     #B46,W4
038A6:  ADD     W0,W4,W0
038A8:  MOV     [W0],W9
038AA:  MOV     W8,1B8C
038AC:  MOV     W9,1B8E
038AE:  PUSH    1B6C
038B0:  POP     1B90
038B2:  PUSH    1B6E
038B4:  POP     1B92
038B6:  CALL    2DB6
038BA:  ADD     W0,W7,W0
038BC:  CP      W6,W0
038BE:  BRA     GE,3974
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
038C0:  MOV     A8E,W4
038C2:  MUL.UU  W4,#8,W0
038C4:  MOV     W0,W5
038C6:  MOV     #AA6,W4
038C8:  ADD     W5,W4,W6
038CA:  MOV     1B70,W4
038CC:  MUL.UU  W4,#2,W0
038CE:  MOV     #A92,W4
038D0:  ADD     W0,W4,W0
038D2:  MOV     [W0],W7
038D4:  MOV     W7,W4
038D6:  MUL.UU  W4,#10,W0
038D8:  MOV     W0,W7
038DA:  MOV     1B2E,W4
038DC:  MUL.UU  W4,#4,W0
038DE:  ADD     W0,W7,W0
038E0:  MOV     #B46,W4
038E2:  ADD     W0,W4,W0
038E4:  MOV     [W0++],[W6++]
038E6:  MOV     [W0++],[W6++]
038E8:  MOV     A8E,W4
038EA:  MUL.UU  W4,#8,W0
038EC:  MOV     W0,W5
038EE:  ADD     W5,#4,W5
038F0:  MOV     W5,W0
038F2:  MOV     #AA6,W4
038F4:  ADD     W0,W4,W5
038F6:  MOV     1B70,W4
038F8:  MUL.UU  W4,#2,W0
038FA:  MOV     #A92,W4
038FC:  ADD     W0,W4,W0
038FE:  MOV     [W0],W6
03900:  MOV     W6,W4
03902:  MUL.UU  W4,#10,W6
03904:  MOV     1B30,W4
03906:  MUL.UU  W4,#4,W0
03908:  ADD     W0,W6,W0
0390A:  MOV     #B46,W4
0390C:  ADD     W0,W4,W0
0390E:  MOV     [W0++],[W5++]
03910:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03912:  MOV     A8E,W4
03914:  ADD     W4,#1,W4
03916:  MOV     W4,W5
03918:  MOV     W5,W4
0391A:  MUL.UU  W4,#8,W0
0391C:  MOV     W0,W5
0391E:  MOV     #AA6,W4
03920:  ADD     W5,W4,W6
03922:  MOV     1B70,W4
03924:  MUL.UU  W4,#2,W0
03926:  MOV     #A92,W4
03928:  ADD     W0,W4,W0
0392A:  MOV     [W0],W7
0392C:  MOV     W7,W4
0392E:  MUL.UU  W4,#10,W0
03930:  MOV     W0,W7
03932:  ADD     W7,#8,W7
03934:  MOV     W7,W0
03936:  MOV     #B46,W4
03938:  ADD     W0,W4,W0
0393A:  MOV     [W0++],[W6++]
0393C:  MOV     [W0++],[W6++]
0393E:  MOV     A8E,W4
03940:  ADD     W4,#1,W4
03942:  MOV     W4,W5
03944:  MOV     W5,W4
03946:  MUL.UU  W4,#8,W0
03948:  MOV     W0,W5
0394A:  ADD     W5,#4,W5
0394C:  MOV     W5,W0
0394E:  MOV     #AA6,W4
03950:  ADD     W0,W4,W5
03952:  MOV     1B70,W4
03954:  MUL.UU  W4,#2,W0
03956:  MOV     #A92,W4
03958:  ADD     W0,W4,W0
0395A:  MOV     [W0],W6
0395C:  MOV     W6,W4
0395E:  MUL.UU  W4,#10,W6
03960:  ADD     W6,#C,W6
03962:  MOV     W6,W0
03964:  MOV     #B46,W4
03966:  ADD     W0,W4,W0
03968:  MOV     [W0++],[W5++]
0396A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
0396C:  MOV     #2,W4
0396E:  MOV     W4,A8C
.................... 		                } 
03970:  GOTO    3A20
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03974:  MOV     A8E,W4
03976:  MUL.UU  W4,#8,W0
03978:  MOV     W0,W5
0397A:  MOV     #AA6,W4
0397C:  ADD     W5,W4,W6
0397E:  MOV     1B70,W4
03980:  MUL.UU  W4,#2,W0
03982:  MOV     #A92,W4
03984:  ADD     W0,W4,W0
03986:  MOV     [W0],W7
03988:  MOV     W7,W4
0398A:  MUL.UU  W4,#10,W0
0398C:  MOV     W0,W7
0398E:  MOV     #B46,W4
03990:  ADD     W7,W4,W0
03992:  MOV     [W0++],[W6++]
03994:  MOV     [W0++],[W6++]
03996:  MOV     A8E,W4
03998:  MUL.UU  W4,#8,W0
0399A:  MOV     W0,W5
0399C:  ADD     W5,#4,W5
0399E:  MOV     W5,W0
039A0:  MOV     #AA6,W4
039A2:  ADD     W0,W4,W5
039A4:  MOV     1B70,W4
039A6:  MUL.UU  W4,#2,W0
039A8:  MOV     #A92,W4
039AA:  ADD     W0,W4,W0
039AC:  MOV     [W0],W6
039AE:  MOV     W6,W4
039B0:  MUL.UU  W4,#10,W6
039B2:  ADD     W6,#4,W6
039B4:  MOV     W6,W0
039B6:  MOV     #B46,W4
039B8:  ADD     W0,W4,W0
039BA:  MOV     [W0++],[W5++]
039BC:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3];		                     
039BE:  MOV     A8E,W4
039C0:  ADD     W4,#1,W4
039C2:  MOV     W4,W5
039C4:  MOV     W5,W4
039C6:  MUL.UU  W4,#8,W0
039C8:  MOV     W0,W5
039CA:  MOV     #AA6,W4
039CC:  ADD     W5,W4,W6
039CE:  MOV     1B70,W4
039D0:  MUL.UU  W4,#2,W0
039D2:  MOV     #A92,W4
039D4:  ADD     W0,W4,W0
039D6:  MOV     [W0],W7
039D8:  MOV     W7,W4
039DA:  MUL.UU  W4,#10,W0
039DC:  MOV     W0,W7
039DE:  MOV     1B2A,W4
039E0:  MUL.UU  W4,#4,W0
039E2:  ADD     W0,W7,W0
039E4:  MOV     #B46,W4
039E6:  ADD     W0,W4,W0
039E8:  MOV     [W0++],[W6++]
039EA:  MOV     [W0++],[W6++]
039EC:  MOV     A8E,W4
039EE:  ADD     W4,#1,W4
039F0:  MOV     W4,W5
039F2:  MOV     W5,W4
039F4:  MUL.UU  W4,#8,W0
039F6:  MOV     W0,W5
039F8:  ADD     W5,#4,W5
039FA:  MOV     W5,W0
039FC:  MOV     #AA6,W4
039FE:  ADD     W0,W4,W5
03A00:  MOV     1B70,W4
03A02:  MUL.UU  W4,#2,W0
03A04:  MOV     #A92,W4
03A06:  ADD     W0,W4,W0
03A08:  MOV     [W0],W6
03A0A:  MOV     W6,W4
03A0C:  MUL.UU  W4,#10,W6
03A0E:  MOV     1B2C,W4
03A10:  MUL.UU  W4,#4,W0
03A12:  ADD     W0,W6,W0
03A14:  MOV     #B46,W4
03A16:  ADD     W0,W4,W0
03A18:  MOV     [W0++],[W5++]
03A1A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03A1C:  MOV     #2,W4
03A1E:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
03A20:  MOV     #1,W4
03A22:  MOV     W4,A84
.................... 		            } 
03A24:  GOTO    3BFA
.................... 		            else if (posEnd == 6) 
03A28:  MOV     1B74,W4
03A2A:  CP      W4,#6
03A2C:  BRA     NZ,3AE6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03A2E:  MOV     A8E,W4
03A30:  MUL.UU  W4,#8,W0
03A32:  MOV     W0,W5
03A34:  MOV     #AA6,W4
03A36:  ADD     W5,W4,W6
03A38:  MOV     1B70,W4
03A3A:  MUL.UU  W4,#2,W0
03A3C:  MOV     #A92,W4
03A3E:  ADD     W0,W4,W0
03A40:  MOV     [W0],W7
03A42:  MOV     W7,W4
03A44:  MUL.UU  W4,#10,W0
03A46:  MOV     W0,W7
03A48:  MOV     1B2E,W4
03A4A:  MUL.UU  W4,#4,W0
03A4C:  ADD     W0,W7,W0
03A4E:  MOV     #B46,W4
03A50:  ADD     W0,W4,W0
03A52:  MOV     [W0++],[W6++]
03A54:  MOV     [W0++],[W6++]
03A56:  MOV     A8E,W4
03A58:  MUL.UU  W4,#8,W0
03A5A:  MOV     W0,W5
03A5C:  ADD     W5,#4,W5
03A5E:  MOV     W5,W0
03A60:  MOV     #AA6,W4
03A62:  ADD     W0,W4,W5
03A64:  MOV     1B70,W4
03A66:  MUL.UU  W4,#2,W0
03A68:  MOV     #A92,W4
03A6A:  ADD     W0,W4,W0
03A6C:  MOV     [W0],W6
03A6E:  MOV     W6,W4
03A70:  MUL.UU  W4,#10,W6
03A72:  MOV     1B30,W4
03A74:  MUL.UU  W4,#4,W0
03A76:  ADD     W0,W6,W0
03A78:  MOV     #B46,W4
03A7A:  ADD     W0,W4,W0
03A7C:  MOV     [W0++],[W5++]
03A7E:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03A80:  MOV     A8E,W4
03A82:  ADD     W4,#1,W4
03A84:  MOV     W4,W5
03A86:  MOV     W5,W4
03A88:  MUL.UU  W4,#8,W0
03A8A:  MOV     W0,W5
03A8C:  MOV     #AA6,W4
03A8E:  ADD     W5,W4,W6
03A90:  MOV     1B70,W4
03A92:  MUL.UU  W4,#2,W0
03A94:  MOV     #A92,W4
03A96:  ADD     W0,W4,W0
03A98:  MOV     [W0],W7
03A9A:  MOV     W7,W4
03A9C:  MUL.UU  W4,#10,W0
03A9E:  MOV     W0,W7
03AA0:  ADD     W7,#8,W7
03AA2:  MOV     W7,W0
03AA4:  MOV     #B46,W4
03AA6:  ADD     W0,W4,W0
03AA8:  MOV     [W0++],[W6++]
03AAA:  MOV     [W0++],[W6++]
03AAC:  MOV     A8E,W4
03AAE:  ADD     W4,#1,W4
03AB0:  MOV     W4,W5
03AB2:  MOV     W5,W4
03AB4:  MUL.UU  W4,#8,W0
03AB6:  MOV     W0,W5
03AB8:  ADD     W5,#4,W5
03ABA:  MOV     W5,W0
03ABC:  MOV     #AA6,W4
03ABE:  ADD     W0,W4,W5
03AC0:  MOV     1B70,W4
03AC2:  MUL.UU  W4,#2,W0
03AC4:  MOV     #A92,W4
03AC6:  ADD     W0,W4,W0
03AC8:  MOV     [W0],W6
03ACA:  MOV     W6,W4
03ACC:  MUL.UU  W4,#10,W6
03ACE:  ADD     W6,#C,W6
03AD0:  MOV     W6,W0
03AD2:  MOV     #B46,W4
03AD4:  ADD     W0,W4,W0
03AD6:  MOV     [W0++],[W5++]
03AD8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
03ADA:  MOV     #2,W4
03ADC:  MOV     W4,A8C
.................... 		                path_found = true; 
03ADE:  MOV     #1,W4
03AE0:  MOV     W4,A84
.................... 		            } 
03AE2:  GOTO    3BFA
.................... 		            else if(posEnd == 7) 
03AE6:  MOV     1B74,W4
03AE8:  CP      W4,#7
03AEA:  BRA     NZ,3BFA
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03AEC:  MOV     A8E,W4
03AEE:  MUL.UU  W4,#8,W0
03AF0:  MOV     W0,W5
03AF2:  MOV     #AA6,W4
03AF4:  ADD     W5,W4,W6
03AF6:  MOV     1B70,W4
03AF8:  MUL.UU  W4,#2,W0
03AFA:  MOV     #A92,W4
03AFC:  ADD     W0,W4,W0
03AFE:  MOV     [W0],W7
03B00:  MOV     W7,W4
03B02:  MUL.UU  W4,#10,W0
03B04:  MOV     W0,W7
03B06:  MOV     1B2E,W4
03B08:  MUL.UU  W4,#4,W0
03B0A:  ADD     W0,W7,W0
03B0C:  MOV     #B46,W4
03B0E:  ADD     W0,W4,W0
03B10:  MOV     [W0++],[W6++]
03B12:  MOV     [W0++],[W6++]
03B14:  MOV     A8E,W4
03B16:  MUL.UU  W4,#8,W0
03B18:  MOV     W0,W5
03B1A:  ADD     W5,#4,W5
03B1C:  MOV     W5,W0
03B1E:  MOV     #AA6,W4
03B20:  ADD     W0,W4,W5
03B22:  MOV     1B70,W4
03B24:  MUL.UU  W4,#2,W0
03B26:  MOV     #A92,W4
03B28:  ADD     W0,W4,W0
03B2A:  MOV     [W0],W6
03B2C:  MOV     W6,W4
03B2E:  MUL.UU  W4,#10,W6
03B30:  MOV     1B30,W4
03B32:  MUL.UU  W4,#4,W0
03B34:  ADD     W0,W6,W0
03B36:  MOV     #B46,W4
03B38:  ADD     W0,W4,W0
03B3A:  MOV     [W0++],[W5++]
03B3C:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03B3E:  MOV     A8E,W4
03B40:  ADD     W4,#1,W4
03B42:  MOV     W4,W5
03B44:  MOV     W5,W4
03B46:  MUL.UU  W4,#8,W0
03B48:  MOV     W0,W5
03B4A:  MOV     #AA6,W4
03B4C:  ADD     W5,W4,W6
03B4E:  MOV     1B70,W4
03B50:  MUL.UU  W4,#2,W0
03B52:  MOV     #A92,W4
03B54:  ADD     W0,W4,W0
03B56:  MOV     [W0],W7
03B58:  MOV     W7,W4
03B5A:  MUL.UU  W4,#10,W0
03B5C:  MOV     W0,W7
03B5E:  ADD     W7,#8,W7
03B60:  MOV     W7,W0
03B62:  MOV     #B46,W4
03B64:  ADD     W0,W4,W0
03B66:  MOV     [W0++],[W6++]
03B68:  MOV     [W0++],[W6++]
03B6A:  MOV     A8E,W4
03B6C:  ADD     W4,#1,W4
03B6E:  MOV     W4,W5
03B70:  MOV     W5,W4
03B72:  MUL.UU  W4,#8,W0
03B74:  MOV     W0,W5
03B76:  ADD     W5,#4,W5
03B78:  MOV     W5,W0
03B7A:  MOV     #AA6,W4
03B7C:  ADD     W0,W4,W5
03B7E:  MOV     1B70,W4
03B80:  MUL.UU  W4,#2,W0
03B82:  MOV     #A92,W4
03B84:  ADD     W0,W4,W0
03B86:  MOV     [W0],W6
03B88:  MOV     W6,W4
03B8A:  MUL.UU  W4,#10,W6
03B8C:  ADD     W6,#C,W6
03B8E:  MOV     W6,W0
03B90:  MOV     #B46,W4
03B92:  ADD     W0,W4,W0
03B94:  MOV     [W0++],[W5++]
03B96:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03B98:  MOV     A8E,W4
03B9A:  ADD     W4,#2,W4
03B9C:  MOV     W4,W5
03B9E:  MOV     W5,W4
03BA0:  MUL.UU  W4,#8,W0
03BA2:  MOV     W0,W5
03BA4:  MOV     #AA6,W4
03BA6:  ADD     W5,W4,W6
03BA8:  MOV     1B70,W4
03BAA:  MUL.UU  W4,#2,W0
03BAC:  MOV     #A92,W4
03BAE:  ADD     W0,W4,W0
03BB0:  MOV     [W0],W7
03BB2:  MOV     W7,W4
03BB4:  MUL.UU  W4,#10,W0
03BB6:  MOV     W0,W7
03BB8:  MOV     1B2A,W4
03BBA:  MUL.UU  W4,#4,W0
03BBC:  ADD     W0,W7,W0
03BBE:  MOV     #B46,W4
03BC0:  ADD     W0,W4,W0
03BC2:  MOV     [W0++],[W6++]
03BC4:  MOV     [W0++],[W6++]
03BC6:  MOV     A8E,W4
03BC8:  ADD     W4,#2,W4
03BCA:  MOV     W4,W5
03BCC:  MOV     W5,W4
03BCE:  MUL.UU  W4,#8,W0
03BD0:  MOV     W0,W5
03BD2:  ADD     W5,#4,W5
03BD4:  MOV     W5,W0
03BD6:  MOV     #AA6,W4
03BD8:  ADD     W0,W4,W5
03BDA:  MOV     1B70,W4
03BDC:  MUL.UU  W4,#2,W0
03BDE:  MOV     #A92,W4
03BE0:  ADD     W0,W4,W0
03BE2:  MOV     [W0],W6
03BE4:  MOV     W6,W4
03BE6:  MUL.UU  W4,#10,W6
03BE8:  MOV     1B2C,W4
03BEA:  MUL.UU  W4,#4,W0
03BEC:  ADD     W0,W6,W0
03BEE:  MOV     #B46,W4
03BF0:  ADD     W0,W4,W0
03BF2:  MOV     [W0++],[W5++]
03BF4:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
03BF6:  MOV     #3,W4
03BF8:  MOV     W4,A8C
.................... 		            } 
.................... 	        	} 
03BFA:  GOTO    3F4E
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 3 || posEnd == 4) 
03BFE:  MOV     1B74,W4
03C00:  CP      W4,#3
03C02:  BRA     Z,3C0A
03C04:  MOV     1B74,W4
03C06:  CP      W4,#4
03C08:  BRA     NZ,3C68
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03C0A:  MOV     A8E,W4
03C0C:  MUL.UU  W4,#8,W0
03C0E:  MOV     W0,W5
03C10:  MOV     #AA6,W4
03C12:  ADD     W5,W4,W6
03C14:  MOV     1B70,W4
03C16:  MUL.UU  W4,#2,W0
03C18:  MOV     #A92,W4
03C1A:  ADD     W0,W4,W0
03C1C:  MOV     [W0],W7
03C1E:  MOV     W7,W4
03C20:  MUL.UU  W4,#10,W0
03C22:  MOV     W0,W7
03C24:  MOV     1B2E,W4
03C26:  MUL.UU  W4,#4,W0
03C28:  ADD     W0,W7,W0
03C2A:  MOV     #B46,W4
03C2C:  ADD     W0,W4,W0
03C2E:  MOV     [W0++],[W6++]
03C30:  MOV     [W0++],[W6++]
03C32:  MOV     A8E,W4
03C34:  MUL.UU  W4,#8,W0
03C36:  MOV     W0,W5
03C38:  ADD     W5,#4,W5
03C3A:  MOV     W5,W0
03C3C:  MOV     #AA6,W4
03C3E:  ADD     W0,W4,W5
03C40:  MOV     1B70,W4
03C42:  MUL.UU  W4,#2,W0
03C44:  MOV     #A92,W4
03C46:  ADD     W0,W4,W0
03C48:  MOV     [W0],W6
03C4A:  MOV     W6,W4
03C4C:  MUL.UU  W4,#10,W6
03C4E:  MOV     1B30,W4
03C50:  MUL.UU  W4,#4,W0
03C52:  ADD     W0,W6,W0
03C54:  MOV     #B46,W4
03C56:  ADD     W0,W4,W0
03C58:  MOV     [W0++],[W5++]
03C5A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03C5C:  MOV     #1,W4
03C5E:  MOV     W4,A8C
.................... 		                path_found = true; 
03C60:  MOV     #1,W4
03C62:  MOV     W4,A84
.................... 		            } 
03C64:  GOTO    3F4E
.................... 		            else if (posEnd == 5) 
03C68:  MOV     1B74,W4
03C6A:  CP      W4,#5
03C6C:  BRA     NZ,3EF0
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
03C6E:  MOV     1B70,W4
03C70:  MUL.UU  W4,#2,W0
03C72:  MOV     #A92,W4
03C74:  ADD     W0,W4,W0
03C76:  MOV     [W0],W5
03C78:  MOV     W5,W4
03C7A:  MUL.UU  W4,#10,W0
03C7C:  MOV     W0,W5
03C7E:  MOV     #B46,W4
03C80:  ADD     W5,W4,W0
03C82:  MOV     [W0],W6
03C84:  MOV     1B70,W4
03C86:  MUL.UU  W4,#2,W0
03C88:  MOV     #A92,W4
03C8A:  ADD     W0,W4,W0
03C8C:  MOV     [W0],W7
03C8E:  MOV     W7,W4
03C90:  MUL.UU  W4,#10,W0
03C92:  MOV     W0,W7
03C94:  ADD     W7,#4,W7
03C96:  MOV     W7,W0
03C98:  MOV     #B46,W4
03C9A:  ADD     W0,W4,W0
03C9C:  MOV     [W0],W7
03C9E:  PUSH    1B68
03CA0:  POP     1B8C
03CA2:  PUSH    1B6A
03CA4:  POP     1B8E
03CA6:  MOV     W6,1B90
03CA8:  MOV     W7,1B92
03CAA:  CALL    2DB6
03CAE:  MOV     W0,W6
03CB0:  MOV     1B70,W4
03CB2:  MUL.UU  W4,#2,W0
03CB4:  MOV     #A92,W4
03CB6:  ADD     W0,W4,W0
03CB8:  MOV     [W0],W7
03CBA:  MOV     W7,W4
03CBC:  MUL.UU  W4,#10,W0
03CBE:  MOV     W0,W7
03CC0:  MOV     1B2A,W4
03CC2:  MUL.UU  W4,#4,W0
03CC4:  ADD     W0,W7,W0
03CC6:  MOV     #B46,W4
03CC8:  ADD     W0,W4,W0
03CCA:  MOV     [W0],W7
03CCC:  MOV     1B70,W4
03CCE:  MUL.UU  W4,#2,W0
03CD0:  MOV     #A92,W4
03CD2:  ADD     W0,W4,W0
03CD4:  MOV     [W0],W8
03CD6:  MOV     W8,W4
03CD8:  MUL.UU  W4,#10,W8
03CDA:  MOV     1B2C,W4
03CDC:  MUL.UU  W4,#4,W0
03CDE:  ADD     W0,W8,W0
03CE0:  MOV     #B46,W4
03CE2:  ADD     W0,W4,W0
03CE4:  MOV     [W0],W8
03CE6:  MOV     W7,1B8C
03CE8:  MOV     W8,1B8E
03CEA:  PUSH    1B6C
03CEC:  POP     1B90
03CEE:  PUSH    1B6E
03CF0:  POP     1B92
03CF2:  CALL    2DB6
03CF6:  ADD     W0,W6,W6
03CF8:  MOV     1B70,W4
03CFA:  MUL.UU  W4,#2,W0
03CFC:  MOV     #A92,W4
03CFE:  ADD     W0,W4,W0
03D00:  MOV     [W0],W7
03D02:  MOV     W7,W4
03D04:  MUL.UU  W4,#10,W0
03D06:  MOV     W0,W7
03D08:  MOV     1B2E,W4
03D0A:  MUL.UU  W4,#4,W0
03D0C:  ADD     W0,W7,W0
03D0E:  MOV     #B46,W4
03D10:  ADD     W0,W4,W0
03D12:  MOV     [W0],W7
03D14:  MOV     1B70,W4
03D16:  MUL.UU  W4,#2,W0
03D18:  MOV     #A92,W4
03D1A:  ADD     W0,W4,W0
03D1C:  MOV     [W0],W8
03D1E:  MOV     W8,W4
03D20:  MUL.UU  W4,#10,W8
03D22:  MOV     1B30,W4
03D24:  MUL.UU  W4,#4,W0
03D26:  ADD     W0,W8,W0
03D28:  MOV     #B46,W4
03D2A:  ADD     W0,W4,W0
03D2C:  MOV     [W0],W8
03D2E:  PUSH    1B68
03D30:  POP     1B8C
03D32:  PUSH    1B6A
03D34:  POP     1B8E
03D36:  MOV     W7,1B90
03D38:  MOV     W8,1B92
03D3A:  CALL    2DB6
03D3E:  MOV     W0,W7
03D40:  MOV     1B70,W4
03D42:  MUL.UU  W4,#2,W0
03D44:  MOV     #A92,W4
03D46:  ADD     W0,W4,W0
03D48:  MOV     [W0],W8
03D4A:  MOV     W8,W4
03D4C:  MUL.UU  W4,#10,W8
03D4E:  ADD     W8,#8,W8
03D50:  MOV     W8,W0
03D52:  MOV     #B46,W4
03D54:  ADD     W0,W4,W0
03D56:  MOV     [W0],W8
03D58:  MOV     1B70,W4
03D5A:  MUL.UU  W4,#2,W0
03D5C:  MOV     #A92,W4
03D5E:  ADD     W0,W4,W0
03D60:  MOV     [W0],W9
03D62:  MOV     W9,W4
03D64:  MUL.UU  W4,#10,W0
03D66:  MOV     W0,W9
03D68:  ADD     W9,#C,W9
03D6A:  MOV     W9,W0
03D6C:  MOV     #B46,W4
03D6E:  ADD     W0,W4,W0
03D70:  MOV     [W0],W9
03D72:  MOV     W8,1B8C
03D74:  MOV     W9,1B8E
03D76:  PUSH    1B6C
03D78:  POP     1B90
03D7A:  PUSH    1B6E
03D7C:  POP     1B92
03D7E:  CALL    2DB6
03D82:  ADD     W0,W7,W0
03D84:  CP      W6,W0
03D86:  BRA     GE,3E38
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03D88:  MOV     A8E,W4
03D8A:  MUL.UU  W4,#8,W0
03D8C:  MOV     W0,W5
03D8E:  MOV     #AA6,W4
03D90:  ADD     W5,W4,W6
03D92:  MOV     1B70,W4
03D94:  MUL.UU  W4,#2,W0
03D96:  MOV     #A92,W4
03D98:  ADD     W0,W4,W0
03D9A:  MOV     [W0],W7
03D9C:  MOV     W7,W4
03D9E:  MUL.UU  W4,#10,W0
03DA0:  MOV     W0,W7
03DA2:  MOV     #B46,W4
03DA4:  ADD     W7,W4,W0
03DA6:  MOV     [W0++],[W6++]
03DA8:  MOV     [W0++],[W6++]
03DAA:  MOV     A8E,W4
03DAC:  MUL.UU  W4,#8,W0
03DAE:  MOV     W0,W5
03DB0:  ADD     W5,#4,W5
03DB2:  MOV     W5,W0
03DB4:  MOV     #AA6,W4
03DB6:  ADD     W0,W4,W5
03DB8:  MOV     1B70,W4
03DBA:  MUL.UU  W4,#2,W0
03DBC:  MOV     #A92,W4
03DBE:  ADD     W0,W4,W0
03DC0:  MOV     [W0],W6
03DC2:  MOV     W6,W4
03DC4:  MUL.UU  W4,#10,W6
03DC6:  ADD     W6,#4,W6
03DC8:  MOV     W6,W0
03DCA:  MOV     #B46,W4
03DCC:  ADD     W0,W4,W0
03DCE:  MOV     [W0++],[W5++]
03DD0:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
03DD2:  MOV     A8E,W4
03DD4:  ADD     W4,#1,W4
03DD6:  MOV     W4,W5
03DD8:  MOV     W5,W4
03DDA:  MUL.UU  W4,#8,W0
03DDC:  MOV     W0,W5
03DDE:  MOV     #AA6,W4
03DE0:  ADD     W5,W4,W6
03DE2:  MOV     1B70,W4
03DE4:  MUL.UU  W4,#2,W0
03DE6:  MOV     #A92,W4
03DE8:  ADD     W0,W4,W0
03DEA:  MOV     [W0],W7
03DEC:  MOV     W7,W4
03DEE:  MUL.UU  W4,#10,W0
03DF0:  MOV     W0,W7
03DF2:  MOV     1B2A,W4
03DF4:  MUL.UU  W4,#4,W0
03DF6:  ADD     W0,W7,W0
03DF8:  MOV     #B46,W4
03DFA:  ADD     W0,W4,W0
03DFC:  MOV     [W0++],[W6++]
03DFE:  MOV     [W0++],[W6++]
03E00:  MOV     A8E,W4
03E02:  ADD     W4,#1,W4
03E04:  MOV     W4,W5
03E06:  MOV     W5,W4
03E08:  MUL.UU  W4,#8,W0
03E0A:  MOV     W0,W5
03E0C:  ADD     W5,#4,W5
03E0E:  MOV     W5,W0
03E10:  MOV     #AA6,W4
03E12:  ADD     W0,W4,W5
03E14:  MOV     1B70,W4
03E16:  MUL.UU  W4,#2,W0
03E18:  MOV     #A92,W4
03E1A:  ADD     W0,W4,W0
03E1C:  MOV     [W0],W6
03E1E:  MOV     W6,W4
03E20:  MUL.UU  W4,#10,W6
03E22:  MOV     1B2C,W4
03E24:  MUL.UU  W4,#4,W0
03E26:  ADD     W0,W6,W0
03E28:  MOV     #B46,W4
03E2A:  ADD     W0,W4,W0
03E2C:  MOV     [W0++],[W5++]
03E2E:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03E30:  MOV     #2,W4
03E32:  MOV     W4,A8C
.................... 		                } 
03E34:  GOTO    3EE8
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
03E38:  MOV     A8E,W4
03E3A:  MUL.UU  W4,#8,W0
03E3C:  MOV     W0,W5
03E3E:  MOV     #AA6,W4
03E40:  ADD     W5,W4,W6
03E42:  MOV     1B70,W4
03E44:  MUL.UU  W4,#2,W0
03E46:  MOV     #A92,W4
03E48:  ADD     W0,W4,W0
03E4A:  MOV     [W0],W7
03E4C:  MOV     W7,W4
03E4E:  MUL.UU  W4,#10,W0
03E50:  MOV     W0,W7
03E52:  MOV     1B2E,W4
03E54:  MUL.UU  W4,#4,W0
03E56:  ADD     W0,W7,W0
03E58:  MOV     #B46,W4
03E5A:  ADD     W0,W4,W0
03E5C:  MOV     [W0++],[W6++]
03E5E:  MOV     [W0++],[W6++]
03E60:  MOV     A8E,W4
03E62:  MUL.UU  W4,#8,W0
03E64:  MOV     W0,W5
03E66:  ADD     W5,#4,W5
03E68:  MOV     W5,W0
03E6A:  MOV     #AA6,W4
03E6C:  ADD     W0,W4,W5
03E6E:  MOV     1B70,W4
03E70:  MUL.UU  W4,#2,W0
03E72:  MOV     #A92,W4
03E74:  ADD     W0,W4,W0
03E76:  MOV     [W0],W6
03E78:  MOV     W6,W4
03E7A:  MUL.UU  W4,#10,W6
03E7C:  MOV     1B30,W4
03E7E:  MUL.UU  W4,#4,W0
03E80:  ADD     W0,W6,W0
03E82:  MOV     #B46,W4
03E84:  ADD     W0,W4,W0
03E86:  MOV     [W0++],[W5++]
03E88:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03E8A:  MOV     A8E,W4
03E8C:  ADD     W4,#1,W4
03E8E:  MOV     W4,W5
03E90:  MOV     W5,W4
03E92:  MUL.UU  W4,#8,W0
03E94:  MOV     W0,W5
03E96:  MOV     #AA6,W4
03E98:  ADD     W5,W4,W6
03E9A:  MOV     1B70,W4
03E9C:  MUL.UU  W4,#2,W0
03E9E:  MOV     #A92,W4
03EA0:  ADD     W0,W4,W0
03EA2:  MOV     [W0],W7
03EA4:  MOV     W7,W4
03EA6:  MUL.UU  W4,#10,W0
03EA8:  MOV     W0,W7
03EAA:  ADD     W7,#8,W7
03EAC:  MOV     W7,W0
03EAE:  MOV     #B46,W4
03EB0:  ADD     W0,W4,W0
03EB2:  MOV     [W0++],[W6++]
03EB4:  MOV     [W0++],[W6++]
03EB6:  MOV     A8E,W4
03EB8:  ADD     W4,#1,W4
03EBA:  MOV     W4,W5
03EBC:  MOV     W5,W4
03EBE:  MUL.UU  W4,#8,W0
03EC0:  MOV     W0,W5
03EC2:  ADD     W5,#4,W5
03EC4:  MOV     W5,W0
03EC6:  MOV     #AA6,W4
03EC8:  ADD     W0,W4,W5
03ECA:  MOV     1B70,W4
03ECC:  MUL.UU  W4,#2,W0
03ECE:  MOV     #A92,W4
03ED0:  ADD     W0,W4,W0
03ED2:  MOV     [W0],W6
03ED4:  MOV     W6,W4
03ED6:  MUL.UU  W4,#10,W6
03ED8:  ADD     W6,#C,W6
03EDA:  MOV     W6,W0
03EDC:  MOV     #B46,W4
03EDE:  ADD     W0,W4,W0
03EE0:  MOV     [W0++],[W5++]
03EE2:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
03EE4:  MOV     #2,W4
03EE6:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
03EE8:  MOV     #1,W4
03EEA:  MOV     W4,A84
.................... 		            } 
03EEC:  GOTO    3F4E
.................... 		            else if (posEnd == 6 || posEnd == 7) 
03EF0:  MOV     1B74,W4
03EF2:  CP      W4,#6
03EF4:  BRA     Z,3EFC
03EF6:  MOV     1B74,W4
03EF8:  CP      W4,#7
03EFA:  BRA     NZ,3F4E
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
03EFC:  MOV     A8E,W4
03EFE:  MUL.UU  W4,#8,W0
03F00:  MOV     W0,W5
03F02:  MOV     #AA6,W4
03F04:  ADD     W5,W4,W6
03F06:  MOV     1B70,W4
03F08:  MUL.UU  W4,#2,W0
03F0A:  MOV     #A92,W4
03F0C:  ADD     W0,W4,W0
03F0E:  MOV     [W0],W7
03F10:  MOV     W7,W4
03F12:  MUL.UU  W4,#10,W0
03F14:  MOV     W0,W7
03F16:  MOV     #B46,W4
03F18:  ADD     W7,W4,W0
03F1A:  MOV     [W0++],[W6++]
03F1C:  MOV     [W0++],[W6++]
03F1E:  MOV     A8E,W4
03F20:  MUL.UU  W4,#8,W0
03F22:  MOV     W0,W5
03F24:  ADD     W5,#4,W5
03F26:  MOV     W5,W0
03F28:  MOV     #AA6,W4
03F2A:  ADD     W0,W4,W5
03F2C:  MOV     1B70,W4
03F2E:  MUL.UU  W4,#2,W0
03F30:  MOV     #A92,W4
03F32:  ADD     W0,W4,W0
03F34:  MOV     [W0],W6
03F36:  MOV     W6,W4
03F38:  MUL.UU  W4,#10,W6
03F3A:  ADD     W6,#4,W6
03F3C:  MOV     W6,W0
03F3E:  MOV     #B46,W4
03F40:  ADD     W0,W4,W0
03F42:  MOV     [W0++],[W5++]
03F44:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03F46:  MOV     #1,W4
03F48:  MOV     W4,A8C
.................... 		                path_found = true; 
03F4A:  MOV     #1,W4
03F4C:  MOV     W4,A84
.................... 		            } 
.................... 	            }	 
.................... 	            break; 
03F4E:  GOTO    6CF8
....................  
.................... 	        case 2: 
....................  
.................... 	        	if(path_opposite) 
03F52:  CP0     A88
03F54:  BRA     Z,4236
.................... 	        	{ 
.................... 	        		if (posEnd == 5) 
03F56:  MOV     1B74,W4
03F58:  CP      W4,#5
03F5A:  BRA     NZ,3FB6
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
03F5C:  MOV     A8E,W4
03F5E:  MUL.UU  W4,#8,W0
03F60:  MOV     W0,W5
03F62:  MOV     #AA6,W4
03F64:  ADD     W5,W4,W6
03F66:  MOV     1B70,W4
03F68:  MUL.UU  W4,#2,W0
03F6A:  MOV     #A92,W4
03F6C:  ADD     W0,W4,W0
03F6E:  MOV     [W0],W7
03F70:  MOV     W7,W4
03F72:  MUL.UU  W4,#10,W0
03F74:  MOV     W0,W7
03F76:  ADD     W7,#8,W7
03F78:  MOV     W7,W0
03F7A:  MOV     #B46,W4
03F7C:  ADD     W0,W4,W0
03F7E:  MOV     [W0++],[W6++]
03F80:  MOV     [W0++],[W6++]
03F82:  MOV     A8E,W4
03F84:  MUL.UU  W4,#8,W0
03F86:  MOV     W0,W5
03F88:  ADD     W5,#4,W5
03F8A:  MOV     W5,W0
03F8C:  MOV     #AA6,W4
03F8E:  ADD     W0,W4,W5
03F90:  MOV     1B70,W4
03F92:  MUL.UU  W4,#2,W0
03F94:  MOV     #A92,W4
03F96:  ADD     W0,W4,W0
03F98:  MOV     [W0],W6
03F9A:  MOV     W6,W4
03F9C:  MUL.UU  W4,#10,W6
03F9E:  ADD     W6,#C,W6
03FA0:  MOV     W6,W0
03FA2:  MOV     #B46,W4
03FA4:  ADD     W0,W4,W0
03FA6:  MOV     [W0++],[W5++]
03FA8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
03FAA:  MOV     #1,W4
03FAC:  MOV     W4,A8C
.................... 		                path_found = true; 
03FAE:  MOV     #1,W4
03FB0:  MOV     W4,A84
.................... 		            } 
03FB2:  GOTO    4232
.................... 		            else if (posEnd == 6) 
03FB6:  MOV     1B74,W4
03FB8:  CP      W4,#6
03FBA:  BRA     NZ,4178
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
03FBC:  MOV     1B70,W4
03FBE:  MUL.UU  W4,#2,W0
03FC0:  MOV     #A92,W4
03FC2:  ADD     W0,W4,W0
03FC4:  MOV     [W0],W5
03FC6:  MOV     W5,W4
03FC8:  MUL.UU  W4,#10,W0
03FCA:  MOV     W0,W5
03FCC:  MOV     #B46,W4
03FCE:  ADD     W5,W4,W0
03FD0:  MOV     [W0],W6
03FD2:  MOV     1B70,W4
03FD4:  MUL.UU  W4,#2,W0
03FD6:  MOV     #A92,W4
03FD8:  ADD     W0,W4,W0
03FDA:  MOV     [W0],W7
03FDC:  MOV     W7,W4
03FDE:  MUL.UU  W4,#10,W0
03FE0:  MOV     W0,W7
03FE2:  ADD     W7,#4,W7
03FE4:  MOV     W7,W0
03FE6:  MOV     #B46,W4
03FE8:  ADD     W0,W4,W0
03FEA:  MOV     [W0],W7
03FEC:  PUSH    1B68
03FEE:  POP     1B8C
03FF0:  PUSH    1B6A
03FF2:  POP     1B8E
03FF4:  MOV     W6,1B90
03FF6:  MOV     W7,1B92
03FF8:  CALL    2DB6
03FFC:  MOV     W0,W6
03FFE:  MOV     1B70,W4
04000:  MUL.UU  W4,#2,W0
04002:  MOV     #A92,W4
04004:  ADD     W0,W4,W0
04006:  MOV     [W0],W7
04008:  MOV     W7,W4
0400A:  MUL.UU  W4,#10,W0
0400C:  MOV     W0,W7
0400E:  MOV     #B46,W4
04010:  ADD     W7,W4,W0
04012:  MOV     [W0],W8
04014:  MOV     1B70,W4
04016:  MUL.UU  W4,#2,W0
04018:  MOV     #A92,W4
0401A:  ADD     W0,W4,W0
0401C:  MOV     [W0],W9
0401E:  MOV     W9,W4
04020:  MUL.UU  W4,#10,W0
04022:  MOV     W0,W9
04024:  ADD     W9,#4,W9
04026:  MOV     W9,W0
04028:  MOV     #B46,W4
0402A:  ADD     W0,W4,W0
0402C:  MOV     [W0],W9
0402E:  MOV     W8,1B8C
04030:  MOV     W9,1B8E
04032:  PUSH    1B6C
04034:  POP     1B90
04036:  PUSH    1B6E
04038:  POP     1B92
0403A:  CALL    2DB6
0403E:  ADD     W0,W6,W6
04040:  MOV     1B70,W4
04042:  MUL.UU  W4,#2,W0
04044:  MOV     #A92,W4
04046:  ADD     W0,W4,W0
04048:  MOV     [W0],W8
0404A:  MOV     W8,W4
0404C:  MUL.UU  W4,#10,W8
0404E:  ADD     W8,#8,W8
04050:  MOV     W8,W0
04052:  MOV     #B46,W4
04054:  ADD     W0,W4,W0
04056:  MOV     [W0],W8
04058:  MOV     1B70,W4
0405A:  MUL.UU  W4,#2,W0
0405C:  MOV     #A92,W4
0405E:  ADD     W0,W4,W0
04060:  MOV     [W0],W9
04062:  MOV     W9,W4
04064:  MUL.UU  W4,#10,W0
04066:  MOV     W0,W9
04068:  ADD     W9,#C,W9
0406A:  MOV     W9,W0
0406C:  MOV     #B46,W4
0406E:  ADD     W0,W4,W0
04070:  MOV     [W0],W9
04072:  PUSH    1B68
04074:  POP     1B8C
04076:  PUSH    1B6A
04078:  POP     1B8E
0407A:  MOV     W8,1B90
0407C:  MOV     W9,1B92
0407E:  CALL    2DB6
04082:  MOV     W0,W8
04084:  MOV     1B70,W4
04086:  MUL.UU  W4,#2,W0
04088:  MOV     #A92,W4
0408A:  ADD     W0,W4,W0
0408C:  MOV     [W0],W9
0408E:  MOV     W9,W4
04090:  MUL.UU  W4,#10,W0
04092:  MOV     W0,W9
04094:  ADD     W9,#8,W9
04096:  MOV     W9,W0
04098:  MOV     #B46,W4
0409A:  ADD     W0,W4,W0
0409C:  MOV     [W0],W9
0409E:  MOV     1B70,W4
040A0:  MUL.UU  W4,#2,W0
040A2:  MOV     #A92,W4
040A4:  ADD     W0,W4,W0
040A6:  MOV     [W0],W10
040A8:  MOV     W10,W4
040AA:  MUL.UU  W4,#10,W10
040AC:  ADD     W10,#C,W10
040AE:  MOV     W10,W0
040B0:  MOV     #B46,W4
040B2:  ADD     W0,W4,W0
040B4:  MOV     [W0],W10
040B6:  MOV     W9,1B8C
040B8:  MOV     W10,1B8E
040BA:  PUSH    1B6C
040BC:  POP     1B90
040BE:  PUSH    1B6E
040C0:  POP     1B92
040C2:  CALL    2DB6
040C6:  ADD     W0,W8,W0
040C8:  CP      W6,W0
040CA:  BRA     GE,4122
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
040CC:  MOV     A8E,W4
040CE:  MUL.UU  W4,#8,W0
040D0:  MOV     W0,W5
040D2:  MOV     #AA6,W4
040D4:  ADD     W5,W4,W6
040D6:  MOV     1B70,W4
040D8:  MUL.UU  W4,#2,W0
040DA:  MOV     #A92,W4
040DC:  ADD     W0,W4,W0
040DE:  MOV     [W0],W7
040E0:  MOV     W7,W4
040E2:  MUL.UU  W4,#10,W0
040E4:  MOV     W0,W7
040E6:  ADD     W7,#8,W7
040E8:  MOV     W7,W0
040EA:  MOV     #B46,W4
040EC:  ADD     W0,W4,W0
040EE:  MOV     [W0++],[W6++]
040F0:  MOV     [W0++],[W6++]
040F2:  MOV     A8E,W4
040F4:  MUL.UU  W4,#8,W0
040F6:  MOV     W0,W5
040F8:  ADD     W5,#4,W5
040FA:  MOV     W5,W0
040FC:  MOV     #AA6,W4
040FE:  ADD     W0,W4,W5
04100:  MOV     1B70,W4
04102:  MUL.UU  W4,#2,W0
04104:  MOV     #A92,W4
04106:  ADD     W0,W4,W0
04108:  MOV     [W0],W6
0410A:  MOV     W6,W4
0410C:  MUL.UU  W4,#10,W6
0410E:  ADD     W6,#C,W6
04110:  MOV     W6,W0
04112:  MOV     #B46,W4
04114:  ADD     W0,W4,W0
04116:  MOV     [W0++],[W5++]
04118:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0411A:  MOV     #1,W4
0411C:  MOV     W4,A8C
.................... 		                } 
0411E:  GOTO    4170
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04122:  MOV     A8E,W4
04124:  MUL.UU  W4,#8,W0
04126:  MOV     W0,W5
04128:  MOV     #AA6,W4
0412A:  ADD     W5,W4,W6
0412C:  MOV     1B70,W4
0412E:  MUL.UU  W4,#2,W0
04130:  MOV     #A92,W4
04132:  ADD     W0,W4,W0
04134:  MOV     [W0],W7
04136:  MOV     W7,W4
04138:  MUL.UU  W4,#10,W0
0413A:  MOV     W0,W7
0413C:  MOV     #B46,W4
0413E:  ADD     W7,W4,W0
04140:  MOV     [W0++],[W6++]
04142:  MOV     [W0++],[W6++]
04144:  MOV     A8E,W4
04146:  MUL.UU  W4,#8,W0
04148:  MOV     W0,W5
0414A:  ADD     W5,#4,W5
0414C:  MOV     W5,W0
0414E:  MOV     #AA6,W4
04150:  ADD     W0,W4,W5
04152:  MOV     1B70,W4
04154:  MUL.UU  W4,#2,W0
04156:  MOV     #A92,W4
04158:  ADD     W0,W4,W0
0415A:  MOV     [W0],W6
0415C:  MOV     W6,W4
0415E:  MUL.UU  W4,#10,W6
04160:  ADD     W6,#4,W6
04162:  MOV     W6,W0
04164:  MOV     #B46,W4
04166:  ADD     W0,W4,W0
04168:  MOV     [W0++],[W5++]
0416A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0416C:  MOV     #1,W4
0416E:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
04170:  MOV     #1,W4
04172:  MOV     W4,A84
.................... 		            } 
04174:  GOTO    4232
.................... 		            else if (posEnd == 7) 
04178:  MOV     1B74,W4
0417A:  CP      W4,#7
0417C:  BRA     NZ,4232
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0417E:  MOV     A8E,W4
04180:  MUL.UU  W4,#8,W0
04182:  MOV     W0,W5
04184:  MOV     #AA6,W4
04186:  ADD     W5,W4,W6
04188:  MOV     1B70,W4
0418A:  MUL.UU  W4,#2,W0
0418C:  MOV     #A92,W4
0418E:  ADD     W0,W4,W0
04190:  MOV     [W0],W7
04192:  MOV     W7,W4
04194:  MUL.UU  W4,#10,W0
04196:  MOV     W0,W7
04198:  ADD     W7,#8,W7
0419A:  MOV     W7,W0
0419C:  MOV     #B46,W4
0419E:  ADD     W0,W4,W0
041A0:  MOV     [W0++],[W6++]
041A2:  MOV     [W0++],[W6++]
041A4:  MOV     A8E,W4
041A6:  MUL.UU  W4,#8,W0
041A8:  MOV     W0,W5
041AA:  ADD     W5,#4,W5
041AC:  MOV     W5,W0
041AE:  MOV     #AA6,W4
041B0:  ADD     W0,W4,W5
041B2:  MOV     1B70,W4
041B4:  MUL.UU  W4,#2,W0
041B6:  MOV     #A92,W4
041B8:  ADD     W0,W4,W0
041BA:  MOV     [W0],W6
041BC:  MOV     W6,W4
041BE:  MUL.UU  W4,#10,W6
041C0:  ADD     W6,#C,W6
041C2:  MOV     W6,W0
041C4:  MOV     #B46,W4
041C6:  ADD     W0,W4,W0
041C8:  MOV     [W0++],[W5++]
041CA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
041CC:  MOV     A8E,W4
041CE:  ADD     W4,#1,W4
041D0:  MOV     W4,W5
041D2:  MOV     W5,W4
041D4:  MUL.UU  W4,#8,W0
041D6:  MOV     W0,W5
041D8:  MOV     #AA6,W4
041DA:  ADD     W5,W4,W6
041DC:  MOV     1B70,W4
041DE:  MUL.UU  W4,#2,W0
041E0:  MOV     #A92,W4
041E2:  ADD     W0,W4,W0
041E4:  MOV     [W0],W7
041E6:  MOV     W7,W4
041E8:  MUL.UU  W4,#10,W0
041EA:  MOV     W0,W7
041EC:  MOV     1B2A,W4
041EE:  MUL.UU  W4,#4,W0
041F0:  ADD     W0,W7,W0
041F2:  MOV     #B46,W4
041F4:  ADD     W0,W4,W0
041F6:  MOV     [W0++],[W6++]
041F8:  MOV     [W0++],[W6++]
041FA:  MOV     A8E,W4
041FC:  ADD     W4,#1,W4
041FE:  MOV     W4,W5
04200:  MOV     W5,W4
04202:  MUL.UU  W4,#8,W0
04204:  MOV     W0,W5
04206:  ADD     W5,#4,W5
04208:  MOV     W5,W0
0420A:  MOV     #AA6,W4
0420C:  ADD     W0,W4,W5
0420E:  MOV     1B70,W4
04210:  MUL.UU  W4,#2,W0
04212:  MOV     #A92,W4
04214:  ADD     W0,W4,W0
04216:  MOV     [W0],W6
04218:  MOV     W6,W4
0421A:  MUL.UU  W4,#10,W6
0421C:  MOV     1B2C,W4
0421E:  MUL.UU  W4,#4,W0
04220:  ADD     W0,W6,W0
04222:  MOV     #B46,W4
04224:  ADD     W0,W4,W0
04226:  MOV     [W0++],[W5++]
04228:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0422A:  MOV     #2,W4
0422C:  MOV     W4,A8C
.................... 		                path_found = true; 
0422E:  MOV     #1,W4
04230:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
04232:  GOTO    44B0
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 5) 
04236:  MOV     1B74,W4
04238:  CP      W4,#5
0423A:  BRA     NZ,4296
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0423C:  MOV     A8E,W4
0423E:  MUL.UU  W4,#8,W0
04240:  MOV     W0,W5
04242:  MOV     #AA6,W4
04244:  ADD     W5,W4,W6
04246:  MOV     1B70,W4
04248:  MUL.UU  W4,#2,W0
0424A:  MOV     #A92,W4
0424C:  ADD     W0,W4,W0
0424E:  MOV     [W0],W7
04250:  MOV     W7,W4
04252:  MUL.UU  W4,#10,W0
04254:  MOV     W0,W7
04256:  ADD     W7,#8,W7
04258:  MOV     W7,W0
0425A:  MOV     #B46,W4
0425C:  ADD     W0,W4,W0
0425E:  MOV     [W0++],[W6++]
04260:  MOV     [W0++],[W6++]
04262:  MOV     A8E,W4
04264:  MUL.UU  W4,#8,W0
04266:  MOV     W0,W5
04268:  ADD     W5,#4,W5
0426A:  MOV     W5,W0
0426C:  MOV     #AA6,W4
0426E:  ADD     W0,W4,W5
04270:  MOV     1B70,W4
04272:  MUL.UU  W4,#2,W0
04274:  MOV     #A92,W4
04276:  ADD     W0,W4,W0
04278:  MOV     [W0],W6
0427A:  MOV     W6,W4
0427C:  MUL.UU  W4,#10,W6
0427E:  ADD     W6,#C,W6
04280:  MOV     W6,W0
04282:  MOV     #B46,W4
04284:  ADD     W0,W4,W0
04286:  MOV     [W0++],[W5++]
04288:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0428A:  MOV     #1,W4
0428C:  MOV     W4,A8C
.................... 		                path_found = true; 
0428E:  MOV     #1,W4
04290:  MOV     W4,A84
.................... 		            } 
04292:  GOTO    44B0
.................... 		            else if (posEnd == 6) 
04296:  MOV     1B74,W4
04298:  CP      W4,#6
0429A:  BRA     NZ,4458
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
0429C:  MOV     1B70,W4
0429E:  MUL.UU  W4,#2,W0
042A0:  MOV     #A92,W4
042A2:  ADD     W0,W4,W0
042A4:  MOV     [W0],W5
042A6:  MOV     W5,W4
042A8:  MUL.UU  W4,#10,W0
042AA:  MOV     W0,W5
042AC:  MOV     #B46,W4
042AE:  ADD     W5,W4,W0
042B0:  MOV     [W0],W6
042B2:  MOV     1B70,W4
042B4:  MUL.UU  W4,#2,W0
042B6:  MOV     #A92,W4
042B8:  ADD     W0,W4,W0
042BA:  MOV     [W0],W7
042BC:  MOV     W7,W4
042BE:  MUL.UU  W4,#10,W0
042C0:  MOV     W0,W7
042C2:  ADD     W7,#4,W7
042C4:  MOV     W7,W0
042C6:  MOV     #B46,W4
042C8:  ADD     W0,W4,W0
042CA:  MOV     [W0],W7
042CC:  PUSH    1B68
042CE:  POP     1B8C
042D0:  PUSH    1B6A
042D2:  POP     1B8E
042D4:  MOV     W6,1B90
042D6:  MOV     W7,1B92
042D8:  CALL    2DB6
042DC:  MOV     W0,W6
042DE:  MOV     1B70,W4
042E0:  MUL.UU  W4,#2,W0
042E2:  MOV     #A92,W4
042E4:  ADD     W0,W4,W0
042E6:  MOV     [W0],W7
042E8:  MOV     W7,W4
042EA:  MUL.UU  W4,#10,W0
042EC:  MOV     W0,W7
042EE:  MOV     #B46,W4
042F0:  ADD     W7,W4,W0
042F2:  MOV     [W0],W8
042F4:  MOV     1B70,W4
042F6:  MUL.UU  W4,#2,W0
042F8:  MOV     #A92,W4
042FA:  ADD     W0,W4,W0
042FC:  MOV     [W0],W9
042FE:  MOV     W9,W4
04300:  MUL.UU  W4,#10,W0
04302:  MOV     W0,W9
04304:  ADD     W9,#4,W9
04306:  MOV     W9,W0
04308:  MOV     #B46,W4
0430A:  ADD     W0,W4,W0
0430C:  MOV     [W0],W9
0430E:  MOV     W8,1B8C
04310:  MOV     W9,1B8E
04312:  PUSH    1B6C
04314:  POP     1B90
04316:  PUSH    1B6E
04318:  POP     1B92
0431A:  CALL    2DB6
0431E:  ADD     W0,W6,W6
04320:  MOV     1B70,W4
04322:  MUL.UU  W4,#2,W0
04324:  MOV     #A92,W4
04326:  ADD     W0,W4,W0
04328:  MOV     [W0],W8
0432A:  MOV     W8,W4
0432C:  MUL.UU  W4,#10,W8
0432E:  ADD     W8,#8,W8
04330:  MOV     W8,W0
04332:  MOV     #B46,W4
04334:  ADD     W0,W4,W0
04336:  MOV     [W0],W8
04338:  MOV     1B70,W4
0433A:  MUL.UU  W4,#2,W0
0433C:  MOV     #A92,W4
0433E:  ADD     W0,W4,W0
04340:  MOV     [W0],W9
04342:  MOV     W9,W4
04344:  MUL.UU  W4,#10,W0
04346:  MOV     W0,W9
04348:  ADD     W9,#C,W9
0434A:  MOV     W9,W0
0434C:  MOV     #B46,W4
0434E:  ADD     W0,W4,W0
04350:  MOV     [W0],W9
04352:  PUSH    1B68
04354:  POP     1B8C
04356:  PUSH    1B6A
04358:  POP     1B8E
0435A:  MOV     W8,1B90
0435C:  MOV     W9,1B92
0435E:  CALL    2DB6
04362:  MOV     W0,W8
04364:  MOV     1B70,W4
04366:  MUL.UU  W4,#2,W0
04368:  MOV     #A92,W4
0436A:  ADD     W0,W4,W0
0436C:  MOV     [W0],W9
0436E:  MOV     W9,W4
04370:  MUL.UU  W4,#10,W0
04372:  MOV     W0,W9
04374:  ADD     W9,#8,W9
04376:  MOV     W9,W0
04378:  MOV     #B46,W4
0437A:  ADD     W0,W4,W0
0437C:  MOV     [W0],W9
0437E:  MOV     1B70,W4
04380:  MUL.UU  W4,#2,W0
04382:  MOV     #A92,W4
04384:  ADD     W0,W4,W0
04386:  MOV     [W0],W10
04388:  MOV     W10,W4
0438A:  MUL.UU  W4,#10,W10
0438C:  ADD     W10,#C,W10
0438E:  MOV     W10,W0
04390:  MOV     #B46,W4
04392:  ADD     W0,W4,W0
04394:  MOV     [W0],W10
04396:  MOV     W9,1B8C
04398:  MOV     W10,1B8E
0439A:  PUSH    1B6C
0439C:  POP     1B90
0439E:  PUSH    1B6E
043A0:  POP     1B92
043A2:  CALL    2DB6
043A6:  ADD     W0,W8,W0
043A8:  CP      W6,W0
043AA:  BRA     GE,43FE
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
043AC:  MOV     A8E,W4
043AE:  MUL.UU  W4,#8,W0
043B0:  MOV     W0,W5
043B2:  MOV     #AA6,W4
043B4:  ADD     W5,W4,W6
043B6:  MOV     1B70,W4
043B8:  MUL.UU  W4,#2,W0
043BA:  MOV     #A92,W4
043BC:  ADD     W0,W4,W0
043BE:  MOV     [W0],W7
043C0:  MOV     W7,W4
043C2:  MUL.UU  W4,#10,W0
043C4:  MOV     W0,W7
043C6:  MOV     #B46,W4
043C8:  ADD     W7,W4,W0
043CA:  MOV     [W0++],[W6++]
043CC:  MOV     [W0++],[W6++]
043CE:  MOV     A8E,W4
043D0:  MUL.UU  W4,#8,W0
043D2:  MOV     W0,W5
043D4:  ADD     W5,#4,W5
043D6:  MOV     W5,W0
043D8:  MOV     #AA6,W4
043DA:  ADD     W0,W4,W5
043DC:  MOV     1B70,W4
043DE:  MUL.UU  W4,#2,W0
043E0:  MOV     #A92,W4
043E2:  ADD     W0,W4,W0
043E4:  MOV     [W0],W6
043E6:  MOV     W6,W4
043E8:  MUL.UU  W4,#10,W6
043EA:  ADD     W6,#4,W6
043EC:  MOV     W6,W0
043EE:  MOV     #B46,W4
043F0:  ADD     W0,W4,W0
043F2:  MOV     [W0++],[W5++]
043F4:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
043F6:  MOV     #1,W4
043F8:  MOV     W4,A8C
.................... 		                } 
043FA:  GOTO    4450
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
043FE:  MOV     A8E,W4
04400:  MUL.UU  W4,#8,W0
04402:  MOV     W0,W5
04404:  MOV     #AA6,W4
04406:  ADD     W5,W4,W6
04408:  MOV     1B70,W4
0440A:  MUL.UU  W4,#2,W0
0440C:  MOV     #A92,W4
0440E:  ADD     W0,W4,W0
04410:  MOV     [W0],W7
04412:  MOV     W7,W4
04414:  MUL.UU  W4,#10,W0
04416:  MOV     W0,W7
04418:  ADD     W7,#8,W7
0441A:  MOV     W7,W0
0441C:  MOV     #B46,W4
0441E:  ADD     W0,W4,W0
04420:  MOV     [W0++],[W6++]
04422:  MOV     [W0++],[W6++]
04424:  MOV     A8E,W4
04426:  MUL.UU  W4,#8,W0
04428:  MOV     W0,W5
0442A:  ADD     W5,#4,W5
0442C:  MOV     W5,W0
0442E:  MOV     #AA6,W4
04430:  ADD     W0,W4,W5
04432:  MOV     1B70,W4
04434:  MUL.UU  W4,#2,W0
04436:  MOV     #A92,W4
04438:  ADD     W0,W4,W0
0443A:  MOV     [W0],W6
0443C:  MOV     W6,W4
0443E:  MUL.UU  W4,#10,W6
04440:  ADD     W6,#C,W6
04442:  MOV     W6,W0
04444:  MOV     #B46,W4
04446:  ADD     W0,W4,W0
04448:  MOV     [W0++],[W5++]
0444A:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
0444C:  MOV     #1,W4
0444E:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
04450:  MOV     #1,W4
04452:  MOV     W4,A84
.................... 		            } 
04454:  GOTO    44B0
.................... 		            else if (posEnd == 7) 
04458:  MOV     1B74,W4
0445A:  CP      W4,#7
0445C:  BRA     NZ,44B0
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0445E:  MOV     A8E,W4
04460:  MUL.UU  W4,#8,W0
04462:  MOV     W0,W5
04464:  MOV     #AA6,W4
04466:  ADD     W5,W4,W6
04468:  MOV     1B70,W4
0446A:  MUL.UU  W4,#2,W0
0446C:  MOV     #A92,W4
0446E:  ADD     W0,W4,W0
04470:  MOV     [W0],W7
04472:  MOV     W7,W4
04474:  MUL.UU  W4,#10,W0
04476:  MOV     W0,W7
04478:  MOV     #B46,W4
0447A:  ADD     W7,W4,W0
0447C:  MOV     [W0++],[W6++]
0447E:  MOV     [W0++],[W6++]
04480:  MOV     A8E,W4
04482:  MUL.UU  W4,#8,W0
04484:  MOV     W0,W5
04486:  ADD     W5,#4,W5
04488:  MOV     W5,W0
0448A:  MOV     #AA6,W4
0448C:  ADD     W0,W4,W5
0448E:  MOV     1B70,W4
04490:  MUL.UU  W4,#2,W0
04492:  MOV     #A92,W4
04494:  ADD     W0,W4,W0
04496:  MOV     [W0],W6
04498:  MOV     W6,W4
0449A:  MUL.UU  W4,#10,W6
0449C:  ADD     W6,#4,W6
0449E:  MOV     W6,W0
044A0:  MOV     #B46,W4
044A2:  ADD     W0,W4,W0
044A4:  MOV     [W0++],[W5++]
044A6:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
044A8:  MOV     #1,W4
044AA:  MOV     W4,A8C
.................... 		                path_found = true; 
044AC:  MOV     #1,W4
044AE:  MOV     W4,A84
.................... 		            } 
.................... 		        } 
....................  
.................... 	            break; 
044B0:  GOTO    6CF8
....................  
.................... 	        case 3: 
....................  
.................... 	        	if(path_opposite) 
044B4:  CP0     A88
044B6:  BRA     Z,4ADE
.................... 	        	{ 
.................... 	        		if(posEnd == 5) 
044B8:  MOV     1B74,W4
044BA:  CP      W4,#5
044BC:  BRA     NZ,45D0
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
044BE:  MOV     A8E,W4
044C0:  MUL.UU  W4,#8,W0
044C2:  MOV     W0,W5
044C4:  MOV     #AA6,W4
044C6:  ADD     W5,W4,W6
044C8:  MOV     1B70,W4
044CA:  MUL.UU  W4,#2,W0
044CC:  MOV     #A92,W4
044CE:  ADD     W0,W4,W0
044D0:  MOV     [W0],W7
044D2:  MOV     W7,W4
044D4:  MUL.UU  W4,#10,W0
044D6:  MOV     W0,W7
044D8:  MOV     1B2E,W4
044DA:  MUL.UU  W4,#4,W0
044DC:  ADD     W0,W7,W0
044DE:  MOV     #B46,W4
044E0:  ADD     W0,W4,W0
044E2:  MOV     [W0++],[W6++]
044E4:  MOV     [W0++],[W6++]
044E6:  MOV     A8E,W4
044E8:  MUL.UU  W4,#8,W0
044EA:  MOV     W0,W5
044EC:  ADD     W5,#4,W5
044EE:  MOV     W5,W0
044F0:  MOV     #AA6,W4
044F2:  ADD     W0,W4,W5
044F4:  MOV     1B70,W4
044F6:  MUL.UU  W4,#2,W0
044F8:  MOV     #A92,W4
044FA:  ADD     W0,W4,W0
044FC:  MOV     [W0],W6
044FE:  MOV     W6,W4
04500:  MUL.UU  W4,#10,W6
04502:  MOV     1B30,W4
04504:  MUL.UU  W4,#4,W0
04506:  ADD     W0,W6,W0
04508:  MOV     #B46,W4
0450A:  ADD     W0,W4,W0
0450C:  MOV     [W0++],[W5++]
0450E:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04510:  MOV     A8E,W4
04512:  ADD     W4,#1,W4
04514:  MOV     W4,W5
04516:  MOV     W5,W4
04518:  MUL.UU  W4,#8,W0
0451A:  MOV     W0,W5
0451C:  MOV     #AA6,W4
0451E:  ADD     W5,W4,W6
04520:  MOV     1B70,W4
04522:  MUL.UU  W4,#2,W0
04524:  MOV     #A92,W4
04526:  ADD     W0,W4,W0
04528:  MOV     [W0],W7
0452A:  MOV     W7,W4
0452C:  MUL.UU  W4,#10,W0
0452E:  MOV     W0,W7
04530:  MOV     #B46,W4
04532:  ADD     W7,W4,W0
04534:  MOV     [W0++],[W6++]
04536:  MOV     [W0++],[W6++]
04538:  MOV     A8E,W4
0453A:  ADD     W4,#1,W4
0453C:  MOV     W4,W5
0453E:  MOV     W5,W4
04540:  MUL.UU  W4,#8,W0
04542:  MOV     W0,W5
04544:  ADD     W5,#4,W5
04546:  MOV     W5,W0
04548:  MOV     #AA6,W4
0454A:  ADD     W0,W4,W5
0454C:  MOV     1B70,W4
0454E:  MUL.UU  W4,#2,W0
04550:  MOV     #A92,W4
04552:  ADD     W0,W4,W0
04554:  MOV     [W0],W6
04556:  MOV     W6,W4
04558:  MUL.UU  W4,#10,W6
0455A:  ADD     W6,#4,W6
0455C:  MOV     W6,W0
0455E:  MOV     #B46,W4
04560:  ADD     W0,W4,W0
04562:  MOV     [W0++],[W5++]
04564:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04566:  MOV     A8E,W4
04568:  ADD     W4,#2,W4
0456A:  MOV     W4,W5
0456C:  MOV     W5,W4
0456E:  MUL.UU  W4,#8,W0
04570:  MOV     W0,W5
04572:  MOV     #AA6,W4
04574:  ADD     W5,W4,W6
04576:  MOV     1B70,W4
04578:  MUL.UU  W4,#2,W0
0457A:  MOV     #A92,W4
0457C:  ADD     W0,W4,W0
0457E:  MOV     [W0],W7
04580:  MOV     W7,W4
04582:  MUL.UU  W4,#10,W0
04584:  MOV     W0,W7
04586:  MOV     1B2A,W4
04588:  MUL.UU  W4,#4,W0
0458A:  ADD     W0,W7,W0
0458C:  MOV     #B46,W4
0458E:  ADD     W0,W4,W0
04590:  MOV     [W0++],[W6++]
04592:  MOV     [W0++],[W6++]
04594:  MOV     A8E,W4
04596:  ADD     W4,#2,W4
04598:  MOV     W4,W5
0459A:  MOV     W5,W4
0459C:  MUL.UU  W4,#8,W0
0459E:  MOV     W0,W5
045A0:  ADD     W5,#4,W5
045A2:  MOV     W5,W0
045A4:  MOV     #AA6,W4
045A6:  ADD     W0,W4,W5
045A8:  MOV     1B70,W4
045AA:  MUL.UU  W4,#2,W0
045AC:  MOV     #A92,W4
045AE:  ADD     W0,W4,W0
045B0:  MOV     [W0],W6
045B2:  MOV     W6,W4
045B4:  MUL.UU  W4,#10,W6
045B6:  MOV     1B2C,W4
045B8:  MUL.UU  W4,#4,W0
045BA:  ADD     W0,W6,W0
045BC:  MOV     #B46,W4
045BE:  ADD     W0,W4,W0
045C0:  MOV     [W0++],[W5++]
045C2:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
045C4:  MOV     #3,W4
045C6:  MOV     W4,A8C
.................... 		                path_found = true; 
045C8:  MOV     #1,W4
045CA:  MOV     W4,A84
.................... 		            } 
045CC:  GOTO    4ADA
.................... 		            else if (posEnd == 6) 
045D0:  MOV     1B74,W4
045D2:  CP      W4,#6
045D4:  BRA     NZ,468A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
045D6:  MOV     A8E,W4
045D8:  MUL.UU  W4,#8,W0
045DA:  MOV     W0,W5
045DC:  MOV     #AA6,W4
045DE:  ADD     W5,W4,W6
045E0:  MOV     1B70,W4
045E2:  MUL.UU  W4,#2,W0
045E4:  MOV     #A92,W4
045E6:  ADD     W0,W4,W0
045E8:  MOV     [W0],W7
045EA:  MOV     W7,W4
045EC:  MUL.UU  W4,#10,W0
045EE:  MOV     W0,W7
045F0:  MOV     1B2E,W4
045F2:  MUL.UU  W4,#4,W0
045F4:  ADD     W0,W7,W0
045F6:  MOV     #B46,W4
045F8:  ADD     W0,W4,W0
045FA:  MOV     [W0++],[W6++]
045FC:  MOV     [W0++],[W6++]
045FE:  MOV     A8E,W4
04600:  MUL.UU  W4,#8,W0
04602:  MOV     W0,W5
04604:  ADD     W5,#4,W5
04606:  MOV     W5,W0
04608:  MOV     #AA6,W4
0460A:  ADD     W0,W4,W5
0460C:  MOV     1B70,W4
0460E:  MUL.UU  W4,#2,W0
04610:  MOV     #A92,W4
04612:  ADD     W0,W4,W0
04614:  MOV     [W0],W6
04616:  MOV     W6,W4
04618:  MUL.UU  W4,#10,W6
0461A:  MOV     1B30,W4
0461C:  MUL.UU  W4,#4,W0
0461E:  ADD     W0,W6,W0
04620:  MOV     #B46,W4
04622:  ADD     W0,W4,W0
04624:  MOV     [W0++],[W5++]
04626:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04628:  MOV     A8E,W4
0462A:  ADD     W4,#1,W4
0462C:  MOV     W4,W5
0462E:  MOV     W5,W4
04630:  MUL.UU  W4,#8,W0
04632:  MOV     W0,W5
04634:  MOV     #AA6,W4
04636:  ADD     W5,W4,W6
04638:  MOV     1B70,W4
0463A:  MUL.UU  W4,#2,W0
0463C:  MOV     #A92,W4
0463E:  ADD     W0,W4,W0
04640:  MOV     [W0],W7
04642:  MOV     W7,W4
04644:  MUL.UU  W4,#10,W0
04646:  MOV     W0,W7
04648:  MOV     #B46,W4
0464A:  ADD     W7,W4,W0
0464C:  MOV     [W0++],[W6++]
0464E:  MOV     [W0++],[W6++]
04650:  MOV     A8E,W4
04652:  ADD     W4,#1,W4
04654:  MOV     W4,W5
04656:  MOV     W5,W4
04658:  MUL.UU  W4,#8,W0
0465A:  MOV     W0,W5
0465C:  ADD     W5,#4,W5
0465E:  MOV     W5,W0
04660:  MOV     #AA6,W4
04662:  ADD     W0,W4,W5
04664:  MOV     1B70,W4
04666:  MUL.UU  W4,#2,W0
04668:  MOV     #A92,W4
0466A:  ADD     W0,W4,W0
0466C:  MOV     [W0],W6
0466E:  MOV     W6,W4
04670:  MUL.UU  W4,#10,W6
04672:  ADD     W6,#4,W6
04674:  MOV     W6,W0
04676:  MOV     #B46,W4
04678:  ADD     W0,W4,W0
0467A:  MOV     [W0++],[W5++]
0467C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0467E:  MOV     #2,W4
04680:  MOV     W4,A8C
.................... 		                path_found = true; 
04682:  MOV     #1,W4
04684:  MOV     W4,A84
.................... 		            } 
04686:  GOTO    4ADA
.................... 		            else if (posEnd == 7) 
0468A:  MOV     1B74,W4
0468C:  CP      W4,#7
0468E:  BRA     NZ,490E
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
04690:  MOV     1B70,W4
04692:  MUL.UU  W4,#2,W0
04694:  MOV     #A92,W4
04696:  ADD     W0,W4,W0
04698:  MOV     [W0],W5
0469A:  MOV     W5,W4
0469C:  MUL.UU  W4,#10,W0
0469E:  MOV     W0,W5
046A0:  MOV     1B2E,W4
046A2:  MUL.UU  W4,#4,W0
046A4:  ADD     W0,W5,W0
046A6:  MOV     #B46,W4
046A8:  ADD     W0,W4,W0
046AA:  MOV     [W0],W5
046AC:  MOV     1B70,W4
046AE:  MUL.UU  W4,#2,W0
046B0:  MOV     #A92,W4
046B2:  ADD     W0,W4,W0
046B4:  MOV     [W0],W6
046B6:  MOV     W6,W4
046B8:  MUL.UU  W4,#10,W6
046BA:  MOV     1B30,W4
046BC:  MUL.UU  W4,#4,W0
046BE:  ADD     W0,W6,W0
046C0:  MOV     #B46,W4
046C2:  ADD     W0,W4,W0
046C4:  MOV     [W0],W6
046C6:  PUSH    1B68
046C8:  POP     1B8C
046CA:  PUSH    1B6A
046CC:  POP     1B8E
046CE:  MOV     W5,1B90
046D0:  MOV     W6,1B92
046D2:  CALL    2DB6
046D6:  MOV     W0,W5
046D8:  MOV     1B70,W4
046DA:  MUL.UU  W4,#2,W0
046DC:  MOV     #A92,W4
046DE:  ADD     W0,W4,W0
046E0:  MOV     [W0],W6
046E2:  MOV     W6,W4
046E4:  MUL.UU  W4,#10,W6
046E6:  MOV     #B46,W4
046E8:  ADD     W6,W4,W0
046EA:  MOV     [W0],W7
046EC:  MOV     1B70,W4
046EE:  MUL.UU  W4,#2,W0
046F0:  MOV     #A92,W4
046F2:  ADD     W0,W4,W0
046F4:  MOV     [W0],W8
046F6:  MOV     W8,W4
046F8:  MUL.UU  W4,#10,W8
046FA:  ADD     W8,#4,W8
046FC:  MOV     W8,W0
046FE:  MOV     #B46,W4
04700:  ADD     W0,W4,W0
04702:  MOV     [W0],W8
04704:  MOV     W7,1B8C
04706:  MOV     W8,1B8E
04708:  PUSH    1B6C
0470A:  POP     1B90
0470C:  PUSH    1B6E
0470E:  POP     1B92
04710:  CALL    2DB6
04714:  ADD     W0,W5,W5
04716:  MOV     1B70,W4
04718:  MUL.UU  W4,#2,W0
0471A:  MOV     #A92,W4
0471C:  ADD     W0,W4,W0
0471E:  MOV     [W0],W7
04720:  MOV     W7,W4
04722:  MUL.UU  W4,#10,W0
04724:  MOV     W0,W7
04726:  ADD     W7,#8,W7
04728:  MOV     W7,W0
0472A:  MOV     #B46,W4
0472C:  ADD     W0,W4,W0
0472E:  MOV     [W0],W7
04730:  MOV     1B70,W4
04732:  MUL.UU  W4,#2,W0
04734:  MOV     #A92,W4
04736:  ADD     W0,W4,W0
04738:  MOV     [W0],W8
0473A:  MOV     W8,W4
0473C:  MUL.UU  W4,#10,W8
0473E:  ADD     W8,#C,W8
04740:  MOV     W8,W0
04742:  MOV     #B46,W4
04744:  ADD     W0,W4,W0
04746:  MOV     [W0],W8
04748:  PUSH    1B68
0474A:  POP     1B8C
0474C:  PUSH    1B6A
0474E:  POP     1B8E
04750:  MOV     W7,1B90
04752:  MOV     W8,1B92
04754:  CALL    2DB6
04758:  MOV     W0,W7
0475A:  MOV     1B70,W4
0475C:  MUL.UU  W4,#2,W0
0475E:  MOV     #A92,W4
04760:  ADD     W0,W4,W0
04762:  MOV     [W0],W8
04764:  MOV     W8,W4
04766:  MUL.UU  W4,#10,W8
04768:  MOV     1B2A,W4
0476A:  MUL.UU  W4,#4,W0
0476C:  ADD     W0,W8,W0
0476E:  MOV     #B46,W4
04770:  ADD     W0,W4,W0
04772:  MOV     [W0],W8
04774:  MOV     1B70,W4
04776:  MUL.UU  W4,#2,W0
04778:  MOV     #A92,W4
0477A:  ADD     W0,W4,W0
0477C:  MOV     [W0],W9
0477E:  MOV     W9,W4
04780:  MUL.UU  W4,#10,W0
04782:  MOV     W0,W9
04784:  MOV     1B2C,W4
04786:  MUL.UU  W4,#4,W0
04788:  ADD     W0,W9,W0
0478A:  MOV     #B46,W4
0478C:  ADD     W0,W4,W0
0478E:  MOV     [W0],W9
04790:  MOV     W8,1B8C
04792:  MOV     W9,1B8E
04794:  PUSH    1B6C
04796:  POP     1B90
04798:  PUSH    1B6E
0479A:  POP     1B92
0479C:  CALL    2DB6
047A0:  ADD     W0,W7,W0
047A2:  CP      W5,W0
047A4:  BRA     GE,485A
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
047A6:  MOV     A8E,W4
047A8:  MUL.UU  W4,#8,W0
047AA:  MOV     W0,W5
047AC:  MOV     #AA6,W4
047AE:  ADD     W5,W4,W6
047B0:  MOV     1B70,W4
047B2:  MUL.UU  W4,#2,W0
047B4:  MOV     #A92,W4
047B6:  ADD     W0,W4,W0
047B8:  MOV     [W0],W7
047BA:  MOV     W7,W4
047BC:  MUL.UU  W4,#10,W0
047BE:  MOV     W0,W7
047C0:  ADD     W7,#8,W7
047C2:  MOV     W7,W0
047C4:  MOV     #B46,W4
047C6:  ADD     W0,W4,W0
047C8:  MOV     [W0++],[W6++]
047CA:  MOV     [W0++],[W6++]
047CC:  MOV     A8E,W4
047CE:  MUL.UU  W4,#8,W0
047D0:  MOV     W0,W5
047D2:  ADD     W5,#4,W5
047D4:  MOV     W5,W0
047D6:  MOV     #AA6,W4
047D8:  ADD     W0,W4,W5
047DA:  MOV     1B70,W4
047DC:  MUL.UU  W4,#2,W0
047DE:  MOV     #A92,W4
047E0:  ADD     W0,W4,W0
047E2:  MOV     [W0],W6
047E4:  MOV     W6,W4
047E6:  MUL.UU  W4,#10,W6
047E8:  ADD     W6,#C,W6
047EA:  MOV     W6,W0
047EC:  MOV     #B46,W4
047EE:  ADD     W0,W4,W0
047F0:  MOV     [W0++],[W5++]
047F2:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
047F4:  MOV     A8E,W4
047F6:  ADD     W4,#1,W4
047F8:  MOV     W4,W5
047FA:  MOV     W5,W4
047FC:  MUL.UU  W4,#8,W0
047FE:  MOV     W0,W5
04800:  MOV     #AA6,W4
04802:  ADD     W5,W4,W6
04804:  MOV     1B70,W4
04806:  MUL.UU  W4,#2,W0
04808:  MOV     #A92,W4
0480A:  ADD     W0,W4,W0
0480C:  MOV     [W0],W7
0480E:  MOV     W7,W4
04810:  MUL.UU  W4,#10,W0
04812:  MOV     W0,W7
04814:  MOV     1B2A,W4
04816:  MUL.UU  W4,#4,W0
04818:  ADD     W0,W7,W0
0481A:  MOV     #B46,W4
0481C:  ADD     W0,W4,W0
0481E:  MOV     [W0++],[W6++]
04820:  MOV     [W0++],[W6++]
04822:  MOV     A8E,W4
04824:  ADD     W4,#1,W4
04826:  MOV     W4,W5
04828:  MOV     W5,W4
0482A:  MUL.UU  W4,#8,W0
0482C:  MOV     W0,W5
0482E:  ADD     W5,#4,W5
04830:  MOV     W5,W0
04832:  MOV     #AA6,W4
04834:  ADD     W0,W4,W5
04836:  MOV     1B70,W4
04838:  MUL.UU  W4,#2,W0
0483A:  MOV     #A92,W4
0483C:  ADD     W0,W4,W0
0483E:  MOV     [W0],W6
04840:  MOV     W6,W4
04842:  MUL.UU  W4,#10,W6
04844:  MOV     1B2C,W4
04846:  MUL.UU  W4,#4,W0
04848:  ADD     W0,W6,W0
0484A:  MOV     #B46,W4
0484C:  ADD     W0,W4,W0
0484E:  MOV     [W0++],[W5++]
04850:  MOV     [W0++],[W5++]
.................... 		                     
.................... 		                    relay_point_number = 2; 
04852:  MOV     #2,W4
04854:  MOV     W4,A8C
.................... 		                } 
04856:  GOTO    4906
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0485A:  MOV     A8E,W4
0485C:  MUL.UU  W4,#8,W0
0485E:  MOV     W0,W5
04860:  MOV     #AA6,W4
04862:  ADD     W5,W4,W6
04864:  MOV     1B70,W4
04866:  MUL.UU  W4,#2,W0
04868:  MOV     #A92,W4
0486A:  ADD     W0,W4,W0
0486C:  MOV     [W0],W7
0486E:  MOV     W7,W4
04870:  MUL.UU  W4,#10,W0
04872:  MOV     W0,W7
04874:  MOV     1B2E,W4
04876:  MUL.UU  W4,#4,W0
04878:  ADD     W0,W7,W0
0487A:  MOV     #B46,W4
0487C:  ADD     W0,W4,W0
0487E:  MOV     [W0++],[W6++]
04880:  MOV     [W0++],[W6++]
04882:  MOV     A8E,W4
04884:  MUL.UU  W4,#8,W0
04886:  MOV     W0,W5
04888:  ADD     W5,#4,W5
0488A:  MOV     W5,W0
0488C:  MOV     #AA6,W4
0488E:  ADD     W0,W4,W5
04890:  MOV     1B70,W4
04892:  MUL.UU  W4,#2,W0
04894:  MOV     #A92,W4
04896:  ADD     W0,W4,W0
04898:  MOV     [W0],W6
0489A:  MOV     W6,W4
0489C:  MUL.UU  W4,#10,W6
0489E:  MOV     1B30,W4
048A0:  MUL.UU  W4,#4,W0
048A2:  ADD     W0,W6,W0
048A4:  MOV     #B46,W4
048A6:  ADD     W0,W4,W0
048A8:  MOV     [W0++],[W5++]
048AA:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
048AC:  MOV     A8E,W4
048AE:  ADD     W4,#1,W4
048B0:  MOV     W4,W5
048B2:  MOV     W5,W4
048B4:  MUL.UU  W4,#8,W0
048B6:  MOV     W0,W5
048B8:  MOV     #AA6,W4
048BA:  ADD     W5,W4,W6
048BC:  MOV     1B70,W4
048BE:  MUL.UU  W4,#2,W0
048C0:  MOV     #A92,W4
048C2:  ADD     W0,W4,W0
048C4:  MOV     [W0],W7
048C6:  MOV     W7,W4
048C8:  MUL.UU  W4,#10,W0
048CA:  MOV     W0,W7
048CC:  MOV     #B46,W4
048CE:  ADD     W7,W4,W0
048D0:  MOV     [W0++],[W6++]
048D2:  MOV     [W0++],[W6++]
048D4:  MOV     A8E,W4
048D6:  ADD     W4,#1,W4
048D8:  MOV     W4,W5
048DA:  MOV     W5,W4
048DC:  MUL.UU  W4,#8,W0
048DE:  MOV     W0,W5
048E0:  ADD     W5,#4,W5
048E2:  MOV     W5,W0
048E4:  MOV     #AA6,W4
048E6:  ADD     W0,W4,W5
048E8:  MOV     1B70,W4
048EA:  MUL.UU  W4,#2,W0
048EC:  MOV     #A92,W4
048EE:  ADD     W0,W4,W0
048F0:  MOV     [W0],W6
048F2:  MOV     W6,W4
048F4:  MUL.UU  W4,#10,W6
048F6:  ADD     W6,#4,W6
048F8:  MOV     W6,W0
048FA:  MOV     #B46,W4
048FC:  ADD     W0,W4,W0
048FE:  MOV     [W0++],[W5++]
04900:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
04902:  MOV     #2,W4
04904:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
04906:  MOV     #1,W4
04908:  MOV     W4,A84
.................... 		            } 
0490A:  GOTO    4ADA
.................... 		            else if (posEnd == 0) 
0490E:  CP0     1B74
04910:  BRA     NZ,49CA
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04912:  MOV     A8E,W4
04914:  MUL.UU  W4,#8,W0
04916:  MOV     W0,W5
04918:  MOV     #AA6,W4
0491A:  ADD     W5,W4,W6
0491C:  MOV     1B70,W4
0491E:  MUL.UU  W4,#2,W0
04920:  MOV     #A92,W4
04922:  ADD     W0,W4,W0
04924:  MOV     [W0],W7
04926:  MOV     W7,W4
04928:  MUL.UU  W4,#10,W0
0492A:  MOV     W0,W7
0492C:  ADD     W7,#8,W7
0492E:  MOV     W7,W0
04930:  MOV     #B46,W4
04932:  ADD     W0,W4,W0
04934:  MOV     [W0++],[W6++]
04936:  MOV     [W0++],[W6++]
04938:  MOV     A8E,W4
0493A:  MUL.UU  W4,#8,W0
0493C:  MOV     W0,W5
0493E:  ADD     W5,#4,W5
04940:  MOV     W5,W0
04942:  MOV     #AA6,W4
04944:  ADD     W0,W4,W5
04946:  MOV     1B70,W4
04948:  MUL.UU  W4,#2,W0
0494A:  MOV     #A92,W4
0494C:  ADD     W0,W4,W0
0494E:  MOV     [W0],W6
04950:  MOV     W6,W4
04952:  MUL.UU  W4,#10,W6
04954:  ADD     W6,#C,W6
04956:  MOV     W6,W0
04958:  MOV     #B46,W4
0495A:  ADD     W0,W4,W0
0495C:  MOV     [W0++],[W5++]
0495E:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04960:  MOV     A8E,W4
04962:  ADD     W4,#1,W4
04964:  MOV     W4,W5
04966:  MOV     W5,W4
04968:  MUL.UU  W4,#8,W0
0496A:  MOV     W0,W5
0496C:  MOV     #AA6,W4
0496E:  ADD     W5,W4,W6
04970:  MOV     1B70,W4
04972:  MUL.UU  W4,#2,W0
04974:  MOV     #A92,W4
04976:  ADD     W0,W4,W0
04978:  MOV     [W0],W7
0497A:  MOV     W7,W4
0497C:  MUL.UU  W4,#10,W0
0497E:  MOV     W0,W7
04980:  MOV     1B2A,W4
04982:  MUL.UU  W4,#4,W0
04984:  ADD     W0,W7,W0
04986:  MOV     #B46,W4
04988:  ADD     W0,W4,W0
0498A:  MOV     [W0++],[W6++]
0498C:  MOV     [W0++],[W6++]
0498E:  MOV     A8E,W4
04990:  ADD     W4,#1,W4
04992:  MOV     W4,W5
04994:  MOV     W5,W4
04996:  MUL.UU  W4,#8,W0
04998:  MOV     W0,W5
0499A:  ADD     W5,#4,W5
0499C:  MOV     W5,W0
0499E:  MOV     #AA6,W4
049A0:  ADD     W0,W4,W5
049A2:  MOV     1B70,W4
049A4:  MUL.UU  W4,#2,W0
049A6:  MOV     #A92,W4
049A8:  ADD     W0,W4,W0
049AA:  MOV     [W0],W6
049AC:  MOV     W6,W4
049AE:  MUL.UU  W4,#10,W6
049B0:  MOV     1B2C,W4
049B2:  MUL.UU  W4,#4,W0
049B4:  ADD     W0,W6,W0
049B6:  MOV     #B46,W4
049B8:  ADD     W0,W4,W0
049BA:  MOV     [W0++],[W5++]
049BC:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
049BE:  MOV     #2,W4
049C0:  MOV     W4,A8C
.................... 		                path_found = true; 
049C2:  MOV     #1,W4
049C4:  MOV     W4,A84
.................... 		            } 
049C6:  GOTO    4ADA
.................... 		            else if (posEnd == 1) 
049CA:  MOV     1B74,W4
049CC:  CP      W4,#1
049CE:  BRA     NZ,4ADA
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
049D0:  MOV     A8E,W4
049D2:  MUL.UU  W4,#8,W0
049D4:  MOV     W0,W5
049D6:  MOV     #AA6,W4
049D8:  ADD     W5,W4,W6
049DA:  MOV     1B70,W4
049DC:  MUL.UU  W4,#2,W0
049DE:  MOV     #A92,W4
049E0:  ADD     W0,W4,W0
049E2:  MOV     [W0],W7
049E4:  MOV     W7,W4
049E6:  MUL.UU  W4,#10,W0
049E8:  MOV     W0,W7
049EA:  ADD     W7,#8,W7
049EC:  MOV     W7,W0
049EE:  MOV     #B46,W4
049F0:  ADD     W0,W4,W0
049F2:  MOV     [W0++],[W6++]
049F4:  MOV     [W0++],[W6++]
049F6:  MOV     A8E,W4
049F8:  MUL.UU  W4,#8,W0
049FA:  MOV     W0,W5
049FC:  ADD     W5,#4,W5
049FE:  MOV     W5,W0
04A00:  MOV     #AA6,W4
04A02:  ADD     W0,W4,W5
04A04:  MOV     1B70,W4
04A06:  MUL.UU  W4,#2,W0
04A08:  MOV     #A92,W4
04A0A:  ADD     W0,W4,W0
04A0C:  MOV     [W0],W6
04A0E:  MOV     W6,W4
04A10:  MUL.UU  W4,#10,W6
04A12:  ADD     W6,#C,W6
04A14:  MOV     W6,W0
04A16:  MOV     #B46,W4
04A18:  ADD     W0,W4,W0
04A1A:  MOV     [W0++],[W5++]
04A1C:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04A1E:  MOV     A8E,W4
04A20:  ADD     W4,#1,W4
04A22:  MOV     W4,W5
04A24:  MOV     W5,W4
04A26:  MUL.UU  W4,#8,W0
04A28:  MOV     W0,W5
04A2A:  MOV     #AA6,W4
04A2C:  ADD     W5,W4,W6
04A2E:  MOV     1B70,W4
04A30:  MUL.UU  W4,#2,W0
04A32:  MOV     #A92,W4
04A34:  ADD     W0,W4,W0
04A36:  MOV     [W0],W7
04A38:  MOV     W7,W4
04A3A:  MUL.UU  W4,#10,W0
04A3C:  MOV     W0,W7
04A3E:  MOV     1B2A,W4
04A40:  MUL.UU  W4,#4,W0
04A42:  ADD     W0,W7,W0
04A44:  MOV     #B46,W4
04A46:  ADD     W0,W4,W0
04A48:  MOV     [W0++],[W6++]
04A4A:  MOV     [W0++],[W6++]
04A4C:  MOV     A8E,W4
04A4E:  ADD     W4,#1,W4
04A50:  MOV     W4,W5
04A52:  MOV     W5,W4
04A54:  MUL.UU  W4,#8,W0
04A56:  MOV     W0,W5
04A58:  ADD     W5,#4,W5
04A5A:  MOV     W5,W0
04A5C:  MOV     #AA6,W4
04A5E:  ADD     W0,W4,W5
04A60:  MOV     1B70,W4
04A62:  MUL.UU  W4,#2,W0
04A64:  MOV     #A92,W4
04A66:  ADD     W0,W4,W0
04A68:  MOV     [W0],W6
04A6A:  MOV     W6,W4
04A6C:  MUL.UU  W4,#10,W6
04A6E:  MOV     1B2C,W4
04A70:  MUL.UU  W4,#4,W0
04A72:  ADD     W0,W6,W0
04A74:  MOV     #B46,W4
04A76:  ADD     W0,W4,W0
04A78:  MOV     [W0++],[W5++]
04A7A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04A7C:  MOV     A8E,W4
04A7E:  ADD     W4,#2,W4
04A80:  MOV     W4,W5
04A82:  MOV     W5,W4
04A84:  MUL.UU  W4,#8,W0
04A86:  MOV     W0,W5
04A88:  MOV     #AA6,W4
04A8A:  ADD     W5,W4,W6
04A8C:  MOV     1B70,W4
04A8E:  MUL.UU  W4,#2,W0
04A90:  MOV     #A92,W4
04A92:  ADD     W0,W4,W0
04A94:  MOV     [W0],W7
04A96:  MOV     W7,W4
04A98:  MUL.UU  W4,#10,W0
04A9A:  MOV     W0,W7
04A9C:  MOV     #B46,W4
04A9E:  ADD     W7,W4,W0
04AA0:  MOV     [W0++],[W6++]
04AA2:  MOV     [W0++],[W6++]
04AA4:  MOV     A8E,W4
04AA6:  ADD     W4,#2,W4
04AA8:  MOV     W4,W5
04AAA:  MOV     W5,W4
04AAC:  MUL.UU  W4,#8,W0
04AAE:  MOV     W0,W5
04AB0:  ADD     W5,#4,W5
04AB2:  MOV     W5,W0
04AB4:  MOV     #AA6,W4
04AB6:  ADD     W0,W4,W5
04AB8:  MOV     1B70,W4
04ABA:  MUL.UU  W4,#2,W0
04ABC:  MOV     #A92,W4
04ABE:  ADD     W0,W4,W0
04AC0:  MOV     [W0],W6
04AC2:  MOV     W6,W4
04AC4:  MUL.UU  W4,#10,W6
04AC6:  ADD     W6,#4,W6
04AC8:  MOV     W6,W0
04ACA:  MOV     #B46,W4
04ACC:  ADD     W0,W4,W0
04ACE:  MOV     [W0++],[W5++]
04AD0:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
04AD2:  MOV     #3,W4
04AD4:  MOV     W4,A8C
.................... 		                path_found = true; 
04AD6:  MOV     #1,W4
04AD8:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
04ADA:  GOTO    4E2C
.................... 	        	else 
.................... 	        	{ 
.................... 	        		if(posEnd == 5 || posEnd == 6) 
04ADE:  MOV     1B74,W4
04AE0:  CP      W4,#5
04AE2:  BRA     Z,4AEA
04AE4:  MOV     1B74,W4
04AE6:  CP      W4,#6
04AE8:  BRA     NZ,4B44
.................... 		            { 
.................... 		            	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04AEA:  MOV     A8E,W4
04AEC:  MUL.UU  W4,#8,W0
04AEE:  MOV     W0,W5
04AF0:  MOV     #AA6,W4
04AF2:  ADD     W5,W4,W6
04AF4:  MOV     1B70,W4
04AF6:  MUL.UU  W4,#2,W0
04AF8:  MOV     #A92,W4
04AFA:  ADD     W0,W4,W0
04AFC:  MOV     [W0],W7
04AFE:  MOV     W7,W4
04B00:  MUL.UU  W4,#10,W0
04B02:  MOV     W0,W7
04B04:  ADD     W7,#8,W7
04B06:  MOV     W7,W0
04B08:  MOV     #B46,W4
04B0A:  ADD     W0,W4,W0
04B0C:  MOV     [W0++],[W6++]
04B0E:  MOV     [W0++],[W6++]
04B10:  MOV     A8E,W4
04B12:  MUL.UU  W4,#8,W0
04B14:  MOV     W0,W5
04B16:  ADD     W5,#4,W5
04B18:  MOV     W5,W0
04B1A:  MOV     #AA6,W4
04B1C:  ADD     W0,W4,W5
04B1E:  MOV     1B70,W4
04B20:  MUL.UU  W4,#2,W0
04B22:  MOV     #A92,W4
04B24:  ADD     W0,W4,W0
04B26:  MOV     [W0],W6
04B28:  MOV     W6,W4
04B2A:  MUL.UU  W4,#10,W6
04B2C:  ADD     W6,#C,W6
04B2E:  MOV     W6,W0
04B30:  MOV     #B46,W4
04B32:  ADD     W0,W4,W0
04B34:  MOV     [W0++],[W5++]
04B36:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
04B38:  MOV     #1,W4
04B3A:  MOV     W4,A8C
.................... 		                path_found = true; 
04B3C:  MOV     #1,W4
04B3E:  MOV     W4,A84
.................... 		            } 
04B40:  GOTO    4E2C
.................... 		            else if (posEnd == 7) 
04B44:  MOV     1B74,W4
04B46:  CP      W4,#7
04B48:  BRA     NZ,4DC8
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd)) 
04B4A:  MOV     1B70,W4
04B4C:  MUL.UU  W4,#2,W0
04B4E:  MOV     #A92,W4
04B50:  ADD     W0,W4,W0
04B52:  MOV     [W0],W5
04B54:  MOV     W5,W4
04B56:  MUL.UU  W4,#10,W0
04B58:  MOV     W0,W5
04B5A:  MOV     1B2E,W4
04B5C:  MUL.UU  W4,#4,W0
04B5E:  ADD     W0,W5,W0
04B60:  MOV     #B46,W4
04B62:  ADD     W0,W4,W0
04B64:  MOV     [W0],W5
04B66:  MOV     1B70,W4
04B68:  MUL.UU  W4,#2,W0
04B6A:  MOV     #A92,W4
04B6C:  ADD     W0,W4,W0
04B6E:  MOV     [W0],W6
04B70:  MOV     W6,W4
04B72:  MUL.UU  W4,#10,W6
04B74:  MOV     1B30,W4
04B76:  MUL.UU  W4,#4,W0
04B78:  ADD     W0,W6,W0
04B7A:  MOV     #B46,W4
04B7C:  ADD     W0,W4,W0
04B7E:  MOV     [W0],W6
04B80:  PUSH    1B68
04B82:  POP     1B8C
04B84:  PUSH    1B6A
04B86:  POP     1B8E
04B88:  MOV     W5,1B90
04B8A:  MOV     W6,1B92
04B8C:  CALL    2DB6
04B90:  MOV     W0,W5
04B92:  MOV     1B70,W4
04B94:  MUL.UU  W4,#2,W0
04B96:  MOV     #A92,W4
04B98:  ADD     W0,W4,W0
04B9A:  MOV     [W0],W6
04B9C:  MOV     W6,W4
04B9E:  MUL.UU  W4,#10,W6
04BA0:  MOV     #B46,W4
04BA2:  ADD     W6,W4,W0
04BA4:  MOV     [W0],W7
04BA6:  MOV     1B70,W4
04BA8:  MUL.UU  W4,#2,W0
04BAA:  MOV     #A92,W4
04BAC:  ADD     W0,W4,W0
04BAE:  MOV     [W0],W8
04BB0:  MOV     W8,W4
04BB2:  MUL.UU  W4,#10,W8
04BB4:  ADD     W8,#4,W8
04BB6:  MOV     W8,W0
04BB8:  MOV     #B46,W4
04BBA:  ADD     W0,W4,W0
04BBC:  MOV     [W0],W8
04BBE:  MOV     W7,1B8C
04BC0:  MOV     W8,1B8E
04BC2:  PUSH    1B6C
04BC4:  POP     1B90
04BC6:  PUSH    1B6E
04BC8:  POP     1B92
04BCA:  CALL    2DB6
04BCE:  ADD     W0,W5,W5
04BD0:  MOV     1B70,W4
04BD2:  MUL.UU  W4,#2,W0
04BD4:  MOV     #A92,W4
04BD6:  ADD     W0,W4,W0
04BD8:  MOV     [W0],W7
04BDA:  MOV     W7,W4
04BDC:  MUL.UU  W4,#10,W0
04BDE:  MOV     W0,W7
04BE0:  ADD     W7,#8,W7
04BE2:  MOV     W7,W0
04BE4:  MOV     #B46,W4
04BE6:  ADD     W0,W4,W0
04BE8:  MOV     [W0],W7
04BEA:  MOV     1B70,W4
04BEC:  MUL.UU  W4,#2,W0
04BEE:  MOV     #A92,W4
04BF0:  ADD     W0,W4,W0
04BF2:  MOV     [W0],W8
04BF4:  MOV     W8,W4
04BF6:  MUL.UU  W4,#10,W8
04BF8:  ADD     W8,#C,W8
04BFA:  MOV     W8,W0
04BFC:  MOV     #B46,W4
04BFE:  ADD     W0,W4,W0
04C00:  MOV     [W0],W8
04C02:  PUSH    1B68
04C04:  POP     1B8C
04C06:  PUSH    1B6A
04C08:  POP     1B8E
04C0A:  MOV     W7,1B90
04C0C:  MOV     W8,1B92
04C0E:  CALL    2DB6
04C12:  MOV     W0,W7
04C14:  MOV     1B70,W4
04C16:  MUL.UU  W4,#2,W0
04C18:  MOV     #A92,W4
04C1A:  ADD     W0,W4,W0
04C1C:  MOV     [W0],W8
04C1E:  MOV     W8,W4
04C20:  MUL.UU  W4,#10,W8
04C22:  MOV     1B2A,W4
04C24:  MUL.UU  W4,#4,W0
04C26:  ADD     W0,W8,W0
04C28:  MOV     #B46,W4
04C2A:  ADD     W0,W4,W0
04C2C:  MOV     [W0],W8
04C2E:  MOV     1B70,W4
04C30:  MUL.UU  W4,#2,W0
04C32:  MOV     #A92,W4
04C34:  ADD     W0,W4,W0
04C36:  MOV     [W0],W9
04C38:  MOV     W9,W4
04C3A:  MUL.UU  W4,#10,W0
04C3C:  MOV     W0,W9
04C3E:  MOV     1B2C,W4
04C40:  MUL.UU  W4,#4,W0
04C42:  ADD     W0,W9,W0
04C44:  MOV     #B46,W4
04C46:  ADD     W0,W4,W0
04C48:  MOV     [W0],W9
04C4A:  MOV     W8,1B8C
04C4C:  MOV     W9,1B8E
04C4E:  PUSH    1B6C
04C50:  POP     1B90
04C52:  PUSH    1B6E
04C54:  POP     1B92
04C56:  CALL    2DB6
04C5A:  ADD     W0,W7,W0
04C5C:  CP      W5,W0
04C5E:  BRA     GE,4D10
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04C60:  MOV     A8E,W4
04C62:  MUL.UU  W4,#8,W0
04C64:  MOV     W0,W5
04C66:  MOV     #AA6,W4
04C68:  ADD     W5,W4,W6
04C6A:  MOV     1B70,W4
04C6C:  MUL.UU  W4,#2,W0
04C6E:  MOV     #A92,W4
04C70:  ADD     W0,W4,W0
04C72:  MOV     [W0],W7
04C74:  MOV     W7,W4
04C76:  MUL.UU  W4,#10,W0
04C78:  MOV     W0,W7
04C7A:  MOV     1B2E,W4
04C7C:  MUL.UU  W4,#4,W0
04C7E:  ADD     W0,W7,W0
04C80:  MOV     #B46,W4
04C82:  ADD     W0,W4,W0
04C84:  MOV     [W0++],[W6++]
04C86:  MOV     [W0++],[W6++]
04C88:  MOV     A8E,W4
04C8A:  MUL.UU  W4,#8,W0
04C8C:  MOV     W0,W5
04C8E:  ADD     W5,#4,W5
04C90:  MOV     W5,W0
04C92:  MOV     #AA6,W4
04C94:  ADD     W0,W4,W5
04C96:  MOV     1B70,W4
04C98:  MUL.UU  W4,#2,W0
04C9A:  MOV     #A92,W4
04C9C:  ADD     W0,W4,W0
04C9E:  MOV     [W0],W6
04CA0:  MOV     W6,W4
04CA2:  MUL.UU  W4,#10,W6
04CA4:  MOV     1B30,W4
04CA6:  MUL.UU  W4,#4,W0
04CA8:  ADD     W0,W6,W0
04CAA:  MOV     #B46,W4
04CAC:  ADD     W0,W4,W0
04CAE:  MOV     [W0++],[W5++]
04CB0:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04CB2:  MOV     A8E,W4
04CB4:  ADD     W4,#1,W4
04CB6:  MOV     W4,W5
04CB8:  MOV     W5,W4
04CBA:  MUL.UU  W4,#8,W0
04CBC:  MOV     W0,W5
04CBE:  MOV     #AA6,W4
04CC0:  ADD     W5,W4,W6
04CC2:  MOV     1B70,W4
04CC4:  MUL.UU  W4,#2,W0
04CC6:  MOV     #A92,W4
04CC8:  ADD     W0,W4,W0
04CCA:  MOV     [W0],W7
04CCC:  MOV     W7,W4
04CCE:  MUL.UU  W4,#10,W0
04CD0:  MOV     W0,W7
04CD2:  MOV     #B46,W4
04CD4:  ADD     W7,W4,W0
04CD6:  MOV     [W0++],[W6++]
04CD8:  MOV     [W0++],[W6++]
04CDA:  MOV     A8E,W4
04CDC:  ADD     W4,#1,W4
04CDE:  MOV     W4,W5
04CE0:  MOV     W5,W4
04CE2:  MUL.UU  W4,#8,W0
04CE4:  MOV     W0,W5
04CE6:  ADD     W5,#4,W5
04CE8:  MOV     W5,W0
04CEA:  MOV     #AA6,W4
04CEC:  ADD     W0,W4,W5
04CEE:  MOV     1B70,W4
04CF0:  MUL.UU  W4,#2,W0
04CF2:  MOV     #A92,W4
04CF4:  ADD     W0,W4,W0
04CF6:  MOV     [W0],W6
04CF8:  MOV     W6,W4
04CFA:  MUL.UU  W4,#10,W6
04CFC:  ADD     W6,#4,W6
04CFE:  MOV     W6,W0
04D00:  MOV     #B46,W4
04D02:  ADD     W0,W4,W0
04D04:  MOV     [W0++],[W5++]
04D06:  MOV     [W0++],[W5++]
.................... 		                     
.................... 		                    relay_point_number = 2; 
04D08:  MOV     #2,W4
04D0A:  MOV     W4,A8C
.................... 		                } 
04D0C:  GOTO    4DC0
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
04D10:  MOV     A8E,W4
04D12:  MUL.UU  W4,#8,W0
04D14:  MOV     W0,W5
04D16:  MOV     #AA6,W4
04D18:  ADD     W5,W4,W6
04D1A:  MOV     1B70,W4
04D1C:  MUL.UU  W4,#2,W0
04D1E:  MOV     #A92,W4
04D20:  ADD     W0,W4,W0
04D22:  MOV     [W0],W7
04D24:  MOV     W7,W4
04D26:  MUL.UU  W4,#10,W0
04D28:  MOV     W0,W7
04D2A:  ADD     W7,#8,W7
04D2C:  MOV     W7,W0
04D2E:  MOV     #B46,W4
04D30:  ADD     W0,W4,W0
04D32:  MOV     [W0++],[W6++]
04D34:  MOV     [W0++],[W6++]
04D36:  MOV     A8E,W4
04D38:  MUL.UU  W4,#8,W0
04D3A:  MOV     W0,W5
04D3C:  ADD     W5,#4,W5
04D3E:  MOV     W5,W0
04D40:  MOV     #AA6,W4
04D42:  ADD     W0,W4,W5
04D44:  MOV     1B70,W4
04D46:  MUL.UU  W4,#2,W0
04D48:  MOV     #A92,W4
04D4A:  ADD     W0,W4,W0
04D4C:  MOV     [W0],W6
04D4E:  MOV     W6,W4
04D50:  MUL.UU  W4,#10,W6
04D52:  ADD     W6,#C,W6
04D54:  MOV     W6,W0
04D56:  MOV     #B46,W4
04D58:  ADD     W0,W4,W0
04D5A:  MOV     [W0++],[W5++]
04D5C:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y3]; 
04D5E:  MOV     A8E,W4
04D60:  ADD     W4,#1,W4
04D62:  MOV     W4,W5
04D64:  MOV     W5,W4
04D66:  MUL.UU  W4,#8,W0
04D68:  MOV     W0,W5
04D6A:  MOV     #AA6,W4
04D6C:  ADD     W5,W4,W6
04D6E:  MOV     1B70,W4
04D70:  MUL.UU  W4,#2,W0
04D72:  MOV     #A92,W4
04D74:  ADD     W0,W4,W0
04D76:  MOV     [W0],W7
04D78:  MOV     W7,W4
04D7A:  MUL.UU  W4,#10,W0
04D7C:  MOV     W0,W7
04D7E:  MOV     1B2A,W4
04D80:  MUL.UU  W4,#4,W0
04D82:  ADD     W0,W7,W0
04D84:  MOV     #B46,W4
04D86:  ADD     W0,W4,W0
04D88:  MOV     [W0++],[W6++]
04D8A:  MOV     [W0++],[W6++]
04D8C:  MOV     A8E,W4
04D8E:  ADD     W4,#1,W4
04D90:  MOV     W4,W5
04D92:  MOV     W5,W4
04D94:  MUL.UU  W4,#8,W0
04D96:  MOV     W0,W5
04D98:  ADD     W5,#4,W5
04D9A:  MOV     W5,W0
04D9C:  MOV     #AA6,W4
04D9E:  ADD     W0,W4,W5
04DA0:  MOV     1B70,W4
04DA2:  MUL.UU  W4,#2,W0
04DA4:  MOV     #A92,W4
04DA6:  ADD     W0,W4,W0
04DA8:  MOV     [W0],W6
04DAA:  MOV     W6,W4
04DAC:  MUL.UU  W4,#10,W6
04DAE:  MOV     1B2C,W4
04DB0:  MUL.UU  W4,#4,W0
04DB2:  ADD     W0,W6,W0
04DB4:  MOV     #B46,W4
04DB6:  ADD     W0,W4,W0
04DB8:  MOV     [W0++],[W5++]
04DBA:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
04DBC:  MOV     #2,W4
04DBE:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
04DC0:  MOV     #1,W4
04DC2:  MOV     W4,A84
.................... 		            } 
04DC4:  GOTO    4E2C
.................... 		            else if (posEnd == 0 || posEnd == 1) 
04DC8:  CP0     1B74
04DCA:  BRA     Z,4DD2
04DCC:  MOV     1B74,W4
04DCE:  CP      W4,#1
04DD0:  BRA     NZ,4E2C
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04DD2:  MOV     A8E,W4
04DD4:  MUL.UU  W4,#8,W0
04DD6:  MOV     W0,W5
04DD8:  MOV     #AA6,W4
04DDA:  ADD     W5,W4,W6
04DDC:  MOV     1B70,W4
04DDE:  MUL.UU  W4,#2,W0
04DE0:  MOV     #A92,W4
04DE2:  ADD     W0,W4,W0
04DE4:  MOV     [W0],W7
04DE6:  MOV     W7,W4
04DE8:  MUL.UU  W4,#10,W0
04DEA:  MOV     W0,W7
04DEC:  MOV     1B2E,W4
04DEE:  MUL.UU  W4,#4,W0
04DF0:  ADD     W0,W7,W0
04DF2:  MOV     #B46,W4
04DF4:  ADD     W0,W4,W0
04DF6:  MOV     [W0++],[W6++]
04DF8:  MOV     [W0++],[W6++]
04DFA:  MOV     A8E,W4
04DFC:  MUL.UU  W4,#8,W0
04DFE:  MOV     W0,W5
04E00:  ADD     W5,#4,W5
04E02:  MOV     W5,W0
04E04:  MOV     #AA6,W4
04E06:  ADD     W0,W4,W5
04E08:  MOV     1B70,W4
04E0A:  MUL.UU  W4,#2,W0
04E0C:  MOV     #A92,W4
04E0E:  ADD     W0,W4,W0
04E10:  MOV     [W0],W6
04E12:  MOV     W6,W4
04E14:  MUL.UU  W4,#10,W6
04E16:  MOV     1B30,W4
04E18:  MUL.UU  W4,#4,W0
04E1A:  ADD     W0,W6,W0
04E1C:  MOV     #B46,W4
04E1E:  ADD     W0,W4,W0
04E20:  MOV     [W0++],[W5++]
04E22:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
04E24:  MOV     #1,W4
04E26:  MOV     W4,A8C
.................... 		                path_found = true; 
04E28:  MOV     #1,W4
04E2A:  MOV     W4,A84
.................... 		            } 
.................... 		             
.................... 	        	} 
.................... 	             
.................... 	             
....................  
.................... 	            break; 
04E2C:  GOTO    6CF8
....................  
.................... 	        case 4: 
....................  
.................... 	        	if(path_opposite) 
04E30:  CP0     A88
04E32:  BRA     Z,5188
.................... 	        	{ 
.................... 	        		if (posEnd == 7) 
04E34:  MOV     1B74,W4
04E36:  CP      W4,#7
04E38:  BRA     NZ,4EEE
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
04E3A:  MOV     A8E,W4
04E3C:  MUL.UU  W4,#8,W0
04E3E:  MOV     W0,W5
04E40:  MOV     #AA6,W4
04E42:  ADD     W5,W4,W6
04E44:  MOV     1B70,W4
04E46:  MUL.UU  W4,#2,W0
04E48:  MOV     #A92,W4
04E4A:  ADD     W0,W4,W0
04E4C:  MOV     [W0],W7
04E4E:  MOV     W7,W4
04E50:  MUL.UU  W4,#10,W0
04E52:  MOV     W0,W7
04E54:  MOV     1B2E,W4
04E56:  MUL.UU  W4,#4,W0
04E58:  ADD     W0,W7,W0
04E5A:  MOV     #B46,W4
04E5C:  ADD     W0,W4,W0
04E5E:  MOV     [W0++],[W6++]
04E60:  MOV     [W0++],[W6++]
04E62:  MOV     A8E,W4
04E64:  MUL.UU  W4,#8,W0
04E66:  MOV     W0,W5
04E68:  ADD     W5,#4,W5
04E6A:  MOV     W5,W0
04E6C:  MOV     #AA6,W4
04E6E:  ADD     W0,W4,W5
04E70:  MOV     1B70,W4
04E72:  MUL.UU  W4,#2,W0
04E74:  MOV     #A92,W4
04E76:  ADD     W0,W4,W0
04E78:  MOV     [W0],W6
04E7A:  MOV     W6,W4
04E7C:  MUL.UU  W4,#10,W6
04E7E:  MOV     1B30,W4
04E80:  MUL.UU  W4,#4,W0
04E82:  ADD     W0,W6,W0
04E84:  MOV     #B46,W4
04E86:  ADD     W0,W4,W0
04E88:  MOV     [W0++],[W5++]
04E8A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
04E8C:  MOV     A8E,W4
04E8E:  ADD     W4,#1,W4
04E90:  MOV     W4,W5
04E92:  MOV     W5,W4
04E94:  MUL.UU  W4,#8,W0
04E96:  MOV     W0,W5
04E98:  MOV     #AA6,W4
04E9A:  ADD     W5,W4,W6
04E9C:  MOV     1B70,W4
04E9E:  MUL.UU  W4,#2,W0
04EA0:  MOV     #A92,W4
04EA2:  ADD     W0,W4,W0
04EA4:  MOV     [W0],W7
04EA6:  MOV     W7,W4
04EA8:  MUL.UU  W4,#10,W0
04EAA:  MOV     W0,W7
04EAC:  MOV     #B46,W4
04EAE:  ADD     W7,W4,W0
04EB0:  MOV     [W0++],[W6++]
04EB2:  MOV     [W0++],[W6++]
04EB4:  MOV     A8E,W4
04EB6:  ADD     W4,#1,W4
04EB8:  MOV     W4,W5
04EBA:  MOV     W5,W4
04EBC:  MUL.UU  W4,#8,W0
04EBE:  MOV     W0,W5
04EC0:  ADD     W5,#4,W5
04EC2:  MOV     W5,W0
04EC4:  MOV     #AA6,W4
04EC6:  ADD     W0,W4,W5
04EC8:  MOV     1B70,W4
04ECA:  MUL.UU  W4,#2,W0
04ECC:  MOV     #A92,W4
04ECE:  ADD     W0,W4,W0
04ED0:  MOV     [W0],W6
04ED2:  MOV     W6,W4
04ED4:  MUL.UU  W4,#10,W6
04ED6:  ADD     W6,#4,W6
04ED8:  MOV     W6,W0
04EDA:  MOV     #B46,W4
04EDC:  ADD     W0,W4,W0
04EDE:  MOV     [W0++],[W5++]
04EE0:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
04EE2:  MOV     #2,W4
04EE4:  MOV     W4,A8C
.................... 		                path_found = true; 
04EE6:  MOV     #1,W4
04EE8:  MOV     W4,A84
.................... 		            } 
04EEA:  GOTO    5184
.................... 		            else if (posEnd == 0) 
04EEE:  CP0     1B74
04EF0:  BRA     NZ,50CE
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
04EF2:  MOV     1B70,W4
04EF4:  MUL.UU  W4,#2,W0
04EF6:  MOV     #A92,W4
04EF8:  ADD     W0,W4,W0
04EFA:  MOV     [W0],W5
04EFC:  MOV     W5,W4
04EFE:  MUL.UU  W4,#10,W0
04F00:  MOV     W0,W5
04F02:  MOV     1B2E,W4
04F04:  MUL.UU  W4,#4,W0
04F06:  ADD     W0,W5,W0
04F08:  MOV     #B46,W4
04F0A:  ADD     W0,W4,W0
04F0C:  MOV     [W0],W5
04F0E:  MOV     1B70,W4
04F10:  MUL.UU  W4,#2,W0
04F12:  MOV     #A92,W4
04F14:  ADD     W0,W4,W0
04F16:  MOV     [W0],W6
04F18:  MOV     W6,W4
04F1A:  MUL.UU  W4,#10,W6
04F1C:  MOV     1B30,W4
04F1E:  MUL.UU  W4,#4,W0
04F20:  ADD     W0,W6,W0
04F22:  MOV     #B46,W4
04F24:  ADD     W0,W4,W0
04F26:  MOV     [W0],W6
04F28:  PUSH    1B68
04F2A:  POP     1B8C
04F2C:  PUSH    1B6A
04F2E:  POP     1B8E
04F30:  MOV     W5,1B90
04F32:  MOV     W6,1B92
04F34:  CALL    2DB6
04F38:  MOV     W0,W5
04F3A:  MOV     1B70,W4
04F3C:  MUL.UU  W4,#2,W0
04F3E:  MOV     #A92,W4
04F40:  ADD     W0,W4,W0
04F42:  MOV     [W0],W6
04F44:  MOV     W6,W4
04F46:  MUL.UU  W4,#10,W6
04F48:  MOV     1B2E,W4
04F4A:  MUL.UU  W4,#4,W0
04F4C:  ADD     W0,W6,W0
04F4E:  MOV     #B46,W4
04F50:  ADD     W0,W4,W0
04F52:  MOV     [W0],W6
04F54:  MOV     1B70,W4
04F56:  MUL.UU  W4,#2,W0
04F58:  MOV     #A92,W4
04F5A:  ADD     W0,W4,W0
04F5C:  MOV     [W0],W7
04F5E:  MOV     W7,W4
04F60:  MUL.UU  W4,#10,W0
04F62:  MOV     W0,W7
04F64:  MOV     1B30,W4
04F66:  MUL.UU  W4,#4,W0
04F68:  ADD     W0,W7,W0
04F6A:  MOV     #B46,W4
04F6C:  ADD     W0,W4,W0
04F6E:  MOV     [W0],W7
04F70:  MOV     W6,1B8C
04F72:  MOV     W7,1B8E
04F74:  PUSH    1B6C
04F76:  POP     1B90
04F78:  PUSH    1B6E
04F7A:  POP     1B92
04F7C:  CALL    2DB6
04F80:  ADD     W0,W5,W5
04F82:  MOV     1B70,W4
04F84:  MUL.UU  W4,#2,W0
04F86:  MOV     #A92,W4
04F88:  ADD     W0,W4,W0
04F8A:  MOV     [W0],W6
04F8C:  MOV     W6,W4
04F8E:  MUL.UU  W4,#10,W6
04F90:  MOV     1B2A,W4
04F92:  MUL.UU  W4,#4,W0
04F94:  ADD     W0,W6,W0
04F96:  MOV     #B46,W4
04F98:  ADD     W0,W4,W0
04F9A:  MOV     [W0],W6
04F9C:  MOV     1B70,W4
04F9E:  MUL.UU  W4,#2,W0
04FA0:  MOV     #A92,W4
04FA2:  ADD     W0,W4,W0
04FA4:  MOV     [W0],W7
04FA6:  MOV     W7,W4
04FA8:  MUL.UU  W4,#10,W0
04FAA:  MOV     W0,W7
04FAC:  MOV     1B2C,W4
04FAE:  MUL.UU  W4,#4,W0
04FB0:  ADD     W0,W7,W0
04FB2:  MOV     #B46,W4
04FB4:  ADD     W0,W4,W0
04FB6:  MOV     [W0],W7
04FB8:  PUSH    1B68
04FBA:  POP     1B8C
04FBC:  PUSH    1B6A
04FBE:  POP     1B8E
04FC0:  MOV     W6,1B90
04FC2:  MOV     W7,1B92
04FC4:  CALL    2DB6
04FC8:  MOV     W0,W6
04FCA:  MOV     1B70,W4
04FCC:  MUL.UU  W4,#2,W0
04FCE:  MOV     #A92,W4
04FD0:  ADD     W0,W4,W0
04FD2:  MOV     [W0],W7
04FD4:  MOV     W7,W4
04FD6:  MUL.UU  W4,#10,W0
04FD8:  MOV     W0,W7
04FDA:  MOV     1B2A,W4
04FDC:  MUL.UU  W4,#4,W0
04FDE:  ADD     W0,W7,W0
04FE0:  MOV     #B46,W4
04FE2:  ADD     W0,W4,W0
04FE4:  MOV     [W0],W7
04FE6:  MOV     1B70,W4
04FE8:  MUL.UU  W4,#2,W0
04FEA:  MOV     #A92,W4
04FEC:  ADD     W0,W4,W0
04FEE:  MOV     [W0],W8
04FF0:  MOV     W8,W4
04FF2:  MUL.UU  W4,#10,W8
04FF4:  MOV     1B2C,W4
04FF6:  MUL.UU  W4,#4,W0
04FF8:  ADD     W0,W8,W0
04FFA:  MOV     #B46,W4
04FFC:  ADD     W0,W4,W0
04FFE:  MOV     [W0],W8
05000:  MOV     W7,1B8C
05002:  MOV     W8,1B8E
05004:  PUSH    1B6C
05006:  POP     1B90
05008:  PUSH    1B6E
0500A:  POP     1B92
0500C:  CALL    2DB6
05010:  ADD     W0,W6,W0
05012:  CP      W5,W0
05014:  BRA     GE,5070
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05016:  MOV     A8E,W4
05018:  MUL.UU  W4,#8,W0
0501A:  MOV     W0,W5
0501C:  MOV     #AA6,W4
0501E:  ADD     W5,W4,W6
05020:  MOV     1B70,W4
05022:  MUL.UU  W4,#2,W0
05024:  MOV     #A92,W4
05026:  ADD     W0,W4,W0
05028:  MOV     [W0],W7
0502A:  MOV     W7,W4
0502C:  MUL.UU  W4,#10,W0
0502E:  MOV     W0,W7
05030:  MOV     1B2A,W4
05032:  MUL.UU  W4,#4,W0
05034:  ADD     W0,W7,W0
05036:  MOV     #B46,W4
05038:  ADD     W0,W4,W0
0503A:  MOV     [W0++],[W6++]
0503C:  MOV     [W0++],[W6++]
0503E:  MOV     A8E,W4
05040:  MUL.UU  W4,#8,W0
05042:  MOV     W0,W5
05044:  ADD     W5,#4,W5
05046:  MOV     W5,W0
05048:  MOV     #AA6,W4
0504A:  ADD     W0,W4,W5
0504C:  MOV     1B70,W4
0504E:  MUL.UU  W4,#2,W0
05050:  MOV     #A92,W4
05052:  ADD     W0,W4,W0
05054:  MOV     [W0],W6
05056:  MOV     W6,W4
05058:  MUL.UU  W4,#10,W6
0505A:  MOV     1B2C,W4
0505C:  MUL.UU  W4,#4,W0
0505E:  ADD     W0,W6,W0
05060:  MOV     #B46,W4
05062:  ADD     W0,W4,W0
05064:  MOV     [W0++],[W5++]
05066:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
05068:  MOV     #1,W4
0506A:  MOV     W4,A8C
.................... 		                } 
0506C:  GOTO    50C6
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05070:  MOV     A8E,W4
05072:  MUL.UU  W4,#8,W0
05074:  MOV     W0,W5
05076:  MOV     #AA6,W4
05078:  ADD     W5,W4,W6
0507A:  MOV     1B70,W4
0507C:  MUL.UU  W4,#2,W0
0507E:  MOV     #A92,W4
05080:  ADD     W0,W4,W0
05082:  MOV     [W0],W7
05084:  MOV     W7,W4
05086:  MUL.UU  W4,#10,W0
05088:  MOV     W0,W7
0508A:  MOV     1B2E,W4
0508C:  MUL.UU  W4,#4,W0
0508E:  ADD     W0,W7,W0
05090:  MOV     #B46,W4
05092:  ADD     W0,W4,W0
05094:  MOV     [W0++],[W6++]
05096:  MOV     [W0++],[W6++]
05098:  MOV     A8E,W4
0509A:  MUL.UU  W4,#8,W0
0509C:  MOV     W0,W5
0509E:  ADD     W5,#4,W5
050A0:  MOV     W5,W0
050A2:  MOV     #AA6,W4
050A4:  ADD     W0,W4,W5
050A6:  MOV     1B70,W4
050A8:  MUL.UU  W4,#2,W0
050AA:  MOV     #A92,W4
050AC:  ADD     W0,W4,W0
050AE:  MOV     [W0],W6
050B0:  MOV     W6,W4
050B2:  MUL.UU  W4,#10,W6
050B4:  MOV     1B30,W4
050B6:  MUL.UU  W4,#4,W0
050B8:  ADD     W0,W6,W0
050BA:  MOV     #B46,W4
050BC:  ADD     W0,W4,W0
050BE:  MOV     [W0++],[W5++]
050C0:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
050C2:  MOV     #1,W4
050C4:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
050C6:  MOV     #1,W4
050C8:  MOV     W4,A84
.................... 		            } 
050CA:  GOTO    5184
.................... 		            else if (posEnd == 1) 
050CE:  MOV     1B74,W4
050D0:  CP      W4,#1
050D2:  BRA     NZ,5184
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
050D4:  MOV     A8E,W4
050D6:  MUL.UU  W4,#8,W0
050D8:  MOV     W0,W5
050DA:  MOV     #AA6,W4
050DC:  ADD     W5,W4,W6
050DE:  MOV     1B70,W4
050E0:  MUL.UU  W4,#2,W0
050E2:  MOV     #A92,W4
050E4:  ADD     W0,W4,W0
050E6:  MOV     [W0],W7
050E8:  MOV     W7,W4
050EA:  MUL.UU  W4,#10,W0
050EC:  MOV     W0,W7
050EE:  MOV     1B2A,W4
050F0:  MUL.UU  W4,#4,W0
050F2:  ADD     W0,W7,W0
050F4:  MOV     #B46,W4
050F6:  ADD     W0,W4,W0
050F8:  MOV     [W0++],[W6++]
050FA:  MOV     [W0++],[W6++]
050FC:  MOV     A8E,W4
050FE:  MUL.UU  W4,#8,W0
05100:  MOV     W0,W5
05102:  ADD     W5,#4,W5
05104:  MOV     W5,W0
05106:  MOV     #AA6,W4
05108:  ADD     W0,W4,W5
0510A:  MOV     1B70,W4
0510C:  MUL.UU  W4,#2,W0
0510E:  MOV     #A92,W4
05110:  ADD     W0,W4,W0
05112:  MOV     [W0],W6
05114:  MOV     W6,W4
05116:  MUL.UU  W4,#10,W6
05118:  MOV     1B2C,W4
0511A:  MUL.UU  W4,#4,W0
0511C:  ADD     W0,W6,W0
0511E:  MOV     #B46,W4
05120:  ADD     W0,W4,W0
05122:  MOV     [W0++],[W5++]
05124:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05126:  MOV     A8E,W4
05128:  ADD     W4,#1,W4
0512A:  MOV     W4,W5
0512C:  MOV     W5,W4
0512E:  MUL.UU  W4,#8,W0
05130:  MOV     W0,W5
05132:  MOV     #AA6,W4
05134:  ADD     W5,W4,W6
05136:  MOV     1B70,W4
05138:  MUL.UU  W4,#2,W0
0513A:  MOV     #A92,W4
0513C:  ADD     W0,W4,W0
0513E:  MOV     [W0],W7
05140:  MOV     W7,W4
05142:  MUL.UU  W4,#10,W0
05144:  MOV     W0,W7
05146:  MOV     #B46,W4
05148:  ADD     W7,W4,W0
0514A:  MOV     [W0++],[W6++]
0514C:  MOV     [W0++],[W6++]
0514E:  MOV     A8E,W4
05150:  ADD     W4,#1,W4
05152:  MOV     W4,W5
05154:  MOV     W5,W4
05156:  MUL.UU  W4,#8,W0
05158:  MOV     W0,W5
0515A:  ADD     W5,#4,W5
0515C:  MOV     W5,W0
0515E:  MOV     #AA6,W4
05160:  ADD     W0,W4,W5
05162:  MOV     1B70,W4
05164:  MUL.UU  W4,#2,W0
05166:  MOV     #A92,W4
05168:  ADD     W0,W4,W0
0516A:  MOV     [W0],W6
0516C:  MOV     W6,W4
0516E:  MUL.UU  W4,#10,W6
05170:  ADD     W6,#4,W6
05172:  MOV     W6,W0
05174:  MOV     #B46,W4
05176:  ADD     W0,W4,W0
05178:  MOV     [W0++],[W5++]
0517A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0517C:  MOV     #2,W4
0517E:  MOV     W4,A8C
.................... 		                path_found = true; 
05180:  MOV     #1,W4
05182:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
05184:  GOTO    542C
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 7) 
05188:  MOV     1B74,W4
0518A:  CP      W4,#7
0518C:  BRA     NZ,51EC
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0518E:  MOV     A8E,W4
05190:  MUL.UU  W4,#8,W0
05192:  MOV     W0,W5
05194:  MOV     #AA6,W4
05196:  ADD     W5,W4,W6
05198:  MOV     1B70,W4
0519A:  MUL.UU  W4,#2,W0
0519C:  MOV     #A92,W4
0519E:  ADD     W0,W4,W0
051A0:  MOV     [W0],W7
051A2:  MOV     W7,W4
051A4:  MUL.UU  W4,#10,W0
051A6:  MOV     W0,W7
051A8:  MOV     1B2A,W4
051AA:  MUL.UU  W4,#4,W0
051AC:  ADD     W0,W7,W0
051AE:  MOV     #B46,W4
051B0:  ADD     W0,W4,W0
051B2:  MOV     [W0++],[W6++]
051B4:  MOV     [W0++],[W6++]
051B6:  MOV     A8E,W4
051B8:  MUL.UU  W4,#8,W0
051BA:  MOV     W0,W5
051BC:  ADD     W5,#4,W5
051BE:  MOV     W5,W0
051C0:  MOV     #AA6,W4
051C2:  ADD     W0,W4,W5
051C4:  MOV     1B70,W4
051C6:  MUL.UU  W4,#2,W0
051C8:  MOV     #A92,W4
051CA:  ADD     W0,W4,W0
051CC:  MOV     [W0],W6
051CE:  MOV     W6,W4
051D0:  MUL.UU  W4,#10,W6
051D2:  MOV     1B2C,W4
051D4:  MUL.UU  W4,#4,W0
051D6:  ADD     W0,W6,W0
051D8:  MOV     #B46,W4
051DA:  ADD     W0,W4,W0
051DC:  MOV     [W0++],[W5++]
051DE:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
051E0:  MOV     #1,W4
051E2:  MOV     W4,A8C
.................... 		                path_found = true; 
051E4:  MOV     #1,W4
051E6:  MOV     W4,A84
.................... 		            } 
051E8:  GOTO    542C
.................... 		            else if (posEnd == 0) 
051EC:  CP0     1B74
051EE:  BRA     NZ,53CC
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3], xEnd, yEnd))) 
051F0:  MOV     1B70,W4
051F2:  MUL.UU  W4,#2,W0
051F4:  MOV     #A92,W4
051F6:  ADD     W0,W4,W0
051F8:  MOV     [W0],W5
051FA:  MOV     W5,W4
051FC:  MUL.UU  W4,#10,W0
051FE:  MOV     W0,W5
05200:  MOV     1B2E,W4
05202:  MUL.UU  W4,#4,W0
05204:  ADD     W0,W5,W0
05206:  MOV     #B46,W4
05208:  ADD     W0,W4,W0
0520A:  MOV     [W0],W5
0520C:  MOV     1B70,W4
0520E:  MUL.UU  W4,#2,W0
05210:  MOV     #A92,W4
05212:  ADD     W0,W4,W0
05214:  MOV     [W0],W6
05216:  MOV     W6,W4
05218:  MUL.UU  W4,#10,W6
0521A:  MOV     1B30,W4
0521C:  MUL.UU  W4,#4,W0
0521E:  ADD     W0,W6,W0
05220:  MOV     #B46,W4
05222:  ADD     W0,W4,W0
05224:  MOV     [W0],W6
05226:  PUSH    1B68
05228:  POP     1B8C
0522A:  PUSH    1B6A
0522C:  POP     1B8E
0522E:  MOV     W5,1B90
05230:  MOV     W6,1B92
05232:  CALL    2DB6
05236:  MOV     W0,W5
05238:  MOV     1B70,W4
0523A:  MUL.UU  W4,#2,W0
0523C:  MOV     #A92,W4
0523E:  ADD     W0,W4,W0
05240:  MOV     [W0],W6
05242:  MOV     W6,W4
05244:  MUL.UU  W4,#10,W6
05246:  MOV     1B2E,W4
05248:  MUL.UU  W4,#4,W0
0524A:  ADD     W0,W6,W0
0524C:  MOV     #B46,W4
0524E:  ADD     W0,W4,W0
05250:  MOV     [W0],W6
05252:  MOV     1B70,W4
05254:  MUL.UU  W4,#2,W0
05256:  MOV     #A92,W4
05258:  ADD     W0,W4,W0
0525A:  MOV     [W0],W7
0525C:  MOV     W7,W4
0525E:  MUL.UU  W4,#10,W0
05260:  MOV     W0,W7
05262:  MOV     1B30,W4
05264:  MUL.UU  W4,#4,W0
05266:  ADD     W0,W7,W0
05268:  MOV     #B46,W4
0526A:  ADD     W0,W4,W0
0526C:  MOV     [W0],W7
0526E:  MOV     W6,1B8C
05270:  MOV     W7,1B8E
05272:  PUSH    1B6C
05274:  POP     1B90
05276:  PUSH    1B6E
05278:  POP     1B92
0527A:  CALL    2DB6
0527E:  ADD     W0,W5,W5
05280:  MOV     1B70,W4
05282:  MUL.UU  W4,#2,W0
05284:  MOV     #A92,W4
05286:  ADD     W0,W4,W0
05288:  MOV     [W0],W6
0528A:  MOV     W6,W4
0528C:  MUL.UU  W4,#10,W6
0528E:  MOV     1B2A,W4
05290:  MUL.UU  W4,#4,W0
05292:  ADD     W0,W6,W0
05294:  MOV     #B46,W4
05296:  ADD     W0,W4,W0
05298:  MOV     [W0],W6
0529A:  MOV     1B70,W4
0529C:  MUL.UU  W4,#2,W0
0529E:  MOV     #A92,W4
052A0:  ADD     W0,W4,W0
052A2:  MOV     [W0],W7
052A4:  MOV     W7,W4
052A6:  MUL.UU  W4,#10,W0
052A8:  MOV     W0,W7
052AA:  MOV     1B2C,W4
052AC:  MUL.UU  W4,#4,W0
052AE:  ADD     W0,W7,W0
052B0:  MOV     #B46,W4
052B2:  ADD     W0,W4,W0
052B4:  MOV     [W0],W7
052B6:  PUSH    1B68
052B8:  POP     1B8C
052BA:  PUSH    1B6A
052BC:  POP     1B8E
052BE:  MOV     W6,1B90
052C0:  MOV     W7,1B92
052C2:  CALL    2DB6
052C6:  MOV     W0,W6
052C8:  MOV     1B70,W4
052CA:  MUL.UU  W4,#2,W0
052CC:  MOV     #A92,W4
052CE:  ADD     W0,W4,W0
052D0:  MOV     [W0],W7
052D2:  MOV     W7,W4
052D4:  MUL.UU  W4,#10,W0
052D6:  MOV     W0,W7
052D8:  MOV     1B2A,W4
052DA:  MUL.UU  W4,#4,W0
052DC:  ADD     W0,W7,W0
052DE:  MOV     #B46,W4
052E0:  ADD     W0,W4,W0
052E2:  MOV     [W0],W7
052E4:  MOV     1B70,W4
052E6:  MUL.UU  W4,#2,W0
052E8:  MOV     #A92,W4
052EA:  ADD     W0,W4,W0
052EC:  MOV     [W0],W8
052EE:  MOV     W8,W4
052F0:  MUL.UU  W4,#10,W8
052F2:  MOV     1B2C,W4
052F4:  MUL.UU  W4,#4,W0
052F6:  ADD     W0,W8,W0
052F8:  MOV     #B46,W4
052FA:  ADD     W0,W4,W0
052FC:  MOV     [W0],W8
052FE:  MOV     W7,1B8C
05300:  MOV     W8,1B8E
05302:  PUSH    1B6C
05304:  POP     1B90
05306:  PUSH    1B6E
05308:  POP     1B92
0530A:  CALL    2DB6
0530E:  ADD     W0,W6,W0
05310:  CP      W5,W0
05312:  BRA     GE,536E
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05314:  MOV     A8E,W4
05316:  MUL.UU  W4,#8,W0
05318:  MOV     W0,W5
0531A:  MOV     #AA6,W4
0531C:  ADD     W5,W4,W6
0531E:  MOV     1B70,W4
05320:  MUL.UU  W4,#2,W0
05322:  MOV     #A92,W4
05324:  ADD     W0,W4,W0
05326:  MOV     [W0],W7
05328:  MOV     W7,W4
0532A:  MUL.UU  W4,#10,W0
0532C:  MOV     W0,W7
0532E:  MOV     1B2E,W4
05330:  MUL.UU  W4,#4,W0
05332:  ADD     W0,W7,W0
05334:  MOV     #B46,W4
05336:  ADD     W0,W4,W0
05338:  MOV     [W0++],[W6++]
0533A:  MOV     [W0++],[W6++]
0533C:  MOV     A8E,W4
0533E:  MUL.UU  W4,#8,W0
05340:  MOV     W0,W5
05342:  ADD     W5,#4,W5
05344:  MOV     W5,W0
05346:  MOV     #AA6,W4
05348:  ADD     W0,W4,W5
0534A:  MOV     1B70,W4
0534C:  MUL.UU  W4,#2,W0
0534E:  MOV     #A92,W4
05350:  ADD     W0,W4,W0
05352:  MOV     [W0],W6
05354:  MOV     W6,W4
05356:  MUL.UU  W4,#10,W6
05358:  MOV     1B30,W4
0535A:  MUL.UU  W4,#4,W0
0535C:  ADD     W0,W6,W0
0535E:  MOV     #B46,W4
05360:  ADD     W0,W4,W0
05362:  MOV     [W0++],[W5++]
05364:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
05366:  MOV     #1,W4
05368:  MOV     W4,A8C
.................... 		                } 
0536A:  GOTO    53C4
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0536E:  MOV     A8E,W4
05370:  MUL.UU  W4,#8,W0
05372:  MOV     W0,W5
05374:  MOV     #AA6,W4
05376:  ADD     W5,W4,W6
05378:  MOV     1B70,W4
0537A:  MUL.UU  W4,#2,W0
0537C:  MOV     #A92,W4
0537E:  ADD     W0,W4,W0
05380:  MOV     [W0],W7
05382:  MOV     W7,W4
05384:  MUL.UU  W4,#10,W0
05386:  MOV     W0,W7
05388:  MOV     1B2A,W4
0538A:  MUL.UU  W4,#4,W0
0538C:  ADD     W0,W7,W0
0538E:  MOV     #B46,W4
05390:  ADD     W0,W4,W0
05392:  MOV     [W0++],[W6++]
05394:  MOV     [W0++],[W6++]
05396:  MOV     A8E,W4
05398:  MUL.UU  W4,#8,W0
0539A:  MOV     W0,W5
0539C:  ADD     W5,#4,W5
0539E:  MOV     W5,W0
053A0:  MOV     #AA6,W4
053A2:  ADD     W0,W4,W5
053A4:  MOV     1B70,W4
053A6:  MUL.UU  W4,#2,W0
053A8:  MOV     #A92,W4
053AA:  ADD     W0,W4,W0
053AC:  MOV     [W0],W6
053AE:  MOV     W6,W4
053B0:  MUL.UU  W4,#10,W6
053B2:  MOV     1B2C,W4
053B4:  MUL.UU  W4,#4,W0
053B6:  ADD     W0,W6,W0
053B8:  MOV     #B46,W4
053BA:  ADD     W0,W4,W0
053BC:  MOV     [W0++],[W5++]
053BE:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
053C0:  MOV     #1,W4
053C2:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
053C4:  MOV     #1,W4
053C6:  MOV     W4,A84
.................... 		            } 
053C8:  GOTO    542C
.................... 		            else if (posEnd == 1) 
053CC:  MOV     1B74,W4
053CE:  CP      W4,#1
053D0:  BRA     NZ,542C
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y2]; 
053D2:  MOV     A8E,W4
053D4:  MUL.UU  W4,#8,W0
053D6:  MOV     W0,W5
053D8:  MOV     #AA6,W4
053DA:  ADD     W5,W4,W6
053DC:  MOV     1B70,W4
053DE:  MUL.UU  W4,#2,W0
053E0:  MOV     #A92,W4
053E2:  ADD     W0,W4,W0
053E4:  MOV     [W0],W7
053E6:  MOV     W7,W4
053E8:  MUL.UU  W4,#10,W0
053EA:  MOV     W0,W7
053EC:  MOV     1B2E,W4
053EE:  MUL.UU  W4,#4,W0
053F0:  ADD     W0,W7,W0
053F2:  MOV     #B46,W4
053F4:  ADD     W0,W4,W0
053F6:  MOV     [W0++],[W6++]
053F8:  MOV     [W0++],[W6++]
053FA:  MOV     A8E,W4
053FC:  MUL.UU  W4,#8,W0
053FE:  MOV     W0,W5
05400:  ADD     W5,#4,W5
05402:  MOV     W5,W0
05404:  MOV     #AA6,W4
05406:  ADD     W0,W4,W5
05408:  MOV     1B70,W4
0540A:  MUL.UU  W4,#2,W0
0540C:  MOV     #A92,W4
0540E:  ADD     W0,W4,W0
05410:  MOV     [W0],W6
05412:  MOV     W6,W4
05414:  MUL.UU  W4,#10,W6
05416:  MOV     1B30,W4
05418:  MUL.UU  W4,#4,W0
0541A:  ADD     W0,W6,W0
0541C:  MOV     #B46,W4
0541E:  ADD     W0,W4,W0
05420:  MOV     [W0++],[W5++]
05422:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
05424:  MOV     #1,W4
05426:  MOV     W4,A8C
.................... 		                path_found = true; 
05428:  MOV     #1,W4
0542A:  MOV     W4,A84
.................... 		            } 
.................... 		        } 
.................... 	            break; 
0542C:  GOTO    6CF8
....................  
.................... 	        case 5: 
....................  
.................... 	        	if(path_opposite) 
05430:  CP0     A88
05432:  BRA     Z,5A5A
.................... 	        	{ 
.................... 	        		if (posEnd == 2) 
05434:  MOV     1B74,W4
05436:  CP      W4,#2
05438:  BRA     NZ,54EE
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
0543A:  MOV     A8E,W4
0543C:  MUL.UU  W4,#8,W0
0543E:  MOV     W0,W5
05440:  MOV     #AA6,W4
05442:  ADD     W5,W4,W6
05444:  MOV     1B70,W4
05446:  MUL.UU  W4,#2,W0
05448:  MOV     #A92,W4
0544A:  ADD     W0,W4,W0
0544C:  MOV     [W0],W7
0544E:  MOV     W7,W4
05450:  MUL.UU  W4,#10,W0
05452:  MOV     W0,W7
05454:  MOV     1B2A,W4
05456:  MUL.UU  W4,#4,W0
05458:  ADD     W0,W7,W0
0545A:  MOV     #B46,W4
0545C:  ADD     W0,W4,W0
0545E:  MOV     [W0++],[W6++]
05460:  MOV     [W0++],[W6++]
05462:  MOV     A8E,W4
05464:  MUL.UU  W4,#8,W0
05466:  MOV     W0,W5
05468:  ADD     W5,#4,W5
0546A:  MOV     W5,W0
0546C:  MOV     #AA6,W4
0546E:  ADD     W0,W4,W5
05470:  MOV     1B70,W4
05472:  MUL.UU  W4,#2,W0
05474:  MOV     #A92,W4
05476:  ADD     W0,W4,W0
05478:  MOV     [W0],W6
0547A:  MOV     W6,W4
0547C:  MUL.UU  W4,#10,W6
0547E:  MOV     1B2C,W4
05480:  MUL.UU  W4,#4,W0
05482:  ADD     W0,W6,W0
05484:  MOV     #B46,W4
05486:  ADD     W0,W4,W0
05488:  MOV     [W0++],[W5++]
0548A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0548C:  MOV     A8E,W4
0548E:  ADD     W4,#1,W4
05490:  MOV     W4,W5
05492:  MOV     W5,W4
05494:  MUL.UU  W4,#8,W0
05496:  MOV     W0,W5
05498:  MOV     #AA6,W4
0549A:  ADD     W5,W4,W6
0549C:  MOV     1B70,W4
0549E:  MUL.UU  W4,#2,W0
054A0:  MOV     #A92,W4
054A2:  ADD     W0,W4,W0
054A4:  MOV     [W0],W7
054A6:  MOV     W7,W4
054A8:  MUL.UU  W4,#10,W0
054AA:  MOV     W0,W7
054AC:  MOV     #B46,W4
054AE:  ADD     W7,W4,W0
054B0:  MOV     [W0++],[W6++]
054B2:  MOV     [W0++],[W6++]
054B4:  MOV     A8E,W4
054B6:  ADD     W4,#1,W4
054B8:  MOV     W4,W5
054BA:  MOV     W5,W4
054BC:  MUL.UU  W4,#8,W0
054BE:  MOV     W0,W5
054C0:  ADD     W5,#4,W5
054C2:  MOV     W5,W0
054C4:  MOV     #AA6,W4
054C6:  ADD     W0,W4,W5
054C8:  MOV     1B70,W4
054CA:  MUL.UU  W4,#2,W0
054CC:  MOV     #A92,W4
054CE:  ADD     W0,W4,W0
054D0:  MOV     [W0],W6
054D2:  MOV     W6,W4
054D4:  MUL.UU  W4,#10,W6
054D6:  ADD     W6,#4,W6
054D8:  MOV     W6,W0
054DA:  MOV     #B46,W4
054DC:  ADD     W0,W4,W0
054DE:  MOV     [W0++],[W5++]
054E0:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
054E2:  MOV     #2,W4
054E4:  MOV     W4,A8C
.................... 		                path_found = true; 
054E6:  MOV     #1,W4
054E8:  MOV     W4,A84
.................... 		            } 
054EA:  GOTO    5A56
.................... 		            else if (posEnd == 3) 
054EE:  MOV     1B74,W4
054F0:  CP      W4,#3
054F2:  BRA     NZ,5606
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
054F4:  MOV     A8E,W4
054F6:  MUL.UU  W4,#8,W0
054F8:  MOV     W0,W5
054FA:  MOV     #AA6,W4
054FC:  ADD     W5,W4,W6
054FE:  MOV     1B70,W4
05500:  MUL.UU  W4,#2,W0
05502:  MOV     #A92,W4
05504:  ADD     W0,W4,W0
05506:  MOV     [W0],W7
05508:  MOV     W7,W4
0550A:  MUL.UU  W4,#10,W0
0550C:  MOV     W0,W7
0550E:  MOV     1B2A,W4
05510:  MUL.UU  W4,#4,W0
05512:  ADD     W0,W7,W0
05514:  MOV     #B46,W4
05516:  ADD     W0,W4,W0
05518:  MOV     [W0++],[W6++]
0551A:  MOV     [W0++],[W6++]
0551C:  MOV     A8E,W4
0551E:  MUL.UU  W4,#8,W0
05520:  MOV     W0,W5
05522:  ADD     W5,#4,W5
05524:  MOV     W5,W0
05526:  MOV     #AA6,W4
05528:  ADD     W0,W4,W5
0552A:  MOV     1B70,W4
0552C:  MUL.UU  W4,#2,W0
0552E:  MOV     #A92,W4
05530:  ADD     W0,W4,W0
05532:  MOV     [W0],W6
05534:  MOV     W6,W4
05536:  MUL.UU  W4,#10,W6
05538:  MOV     1B2C,W4
0553A:  MUL.UU  W4,#4,W0
0553C:  ADD     W0,W6,W0
0553E:  MOV     #B46,W4
05540:  ADD     W0,W4,W0
05542:  MOV     [W0++],[W5++]
05544:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05546:  MOV     A8E,W4
05548:  ADD     W4,#1,W4
0554A:  MOV     W4,W5
0554C:  MOV     W5,W4
0554E:  MUL.UU  W4,#8,W0
05550:  MOV     W0,W5
05552:  MOV     #AA6,W4
05554:  ADD     W5,W4,W6
05556:  MOV     1B70,W4
05558:  MUL.UU  W4,#2,W0
0555A:  MOV     #A92,W4
0555C:  ADD     W0,W4,W0
0555E:  MOV     [W0],W7
05560:  MOV     W7,W4
05562:  MUL.UU  W4,#10,W0
05564:  MOV     W0,W7
05566:  MOV     #B46,W4
05568:  ADD     W7,W4,W0
0556A:  MOV     [W0++],[W6++]
0556C:  MOV     [W0++],[W6++]
0556E:  MOV     A8E,W4
05570:  ADD     W4,#1,W4
05572:  MOV     W4,W5
05574:  MOV     W5,W4
05576:  MUL.UU  W4,#8,W0
05578:  MOV     W0,W5
0557A:  ADD     W5,#4,W5
0557C:  MOV     W5,W0
0557E:  MOV     #AA6,W4
05580:  ADD     W0,W4,W5
05582:  MOV     1B70,W4
05584:  MUL.UU  W4,#2,W0
05586:  MOV     #A92,W4
05588:  ADD     W0,W4,W0
0558A:  MOV     [W0],W6
0558C:  MOV     W6,W4
0558E:  MUL.UU  W4,#10,W6
05590:  ADD     W6,#4,W6
05592:  MOV     W6,W0
05594:  MOV     #B46,W4
05596:  ADD     W0,W4,W0
05598:  MOV     [W0++],[W5++]
0559A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0559C:  MOV     A8E,W4
0559E:  ADD     W4,#2,W4
055A0:  MOV     W4,W5
055A2:  MOV     W5,W4
055A4:  MUL.UU  W4,#8,W0
055A6:  MOV     W0,W5
055A8:  MOV     #AA6,W4
055AA:  ADD     W5,W4,W6
055AC:  MOV     1B70,W4
055AE:  MUL.UU  W4,#2,W0
055B0:  MOV     #A92,W4
055B2:  ADD     W0,W4,W0
055B4:  MOV     [W0],W7
055B6:  MOV     W7,W4
055B8:  MUL.UU  W4,#10,W0
055BA:  MOV     W0,W7
055BC:  MOV     1B2E,W4
055BE:  MUL.UU  W4,#4,W0
055C0:  ADD     W0,W7,W0
055C2:  MOV     #B46,W4
055C4:  ADD     W0,W4,W0
055C6:  MOV     [W0++],[W6++]
055C8:  MOV     [W0++],[W6++]
055CA:  MOV     A8E,W4
055CC:  ADD     W4,#2,W4
055CE:  MOV     W4,W5
055D0:  MOV     W5,W4
055D2:  MUL.UU  W4,#8,W0
055D4:  MOV     W0,W5
055D6:  ADD     W5,#4,W5
055D8:  MOV     W5,W0
055DA:  MOV     #AA6,W4
055DC:  ADD     W0,W4,W5
055DE:  MOV     1B70,W4
055E0:  MUL.UU  W4,#2,W0
055E2:  MOV     #A92,W4
055E4:  ADD     W0,W4,W0
055E6:  MOV     [W0],W6
055E8:  MOV     W6,W4
055EA:  MUL.UU  W4,#10,W6
055EC:  MOV     1B30,W4
055EE:  MUL.UU  W4,#4,W0
055F0:  ADD     W0,W6,W0
055F2:  MOV     #B46,W4
055F4:  ADD     W0,W4,W0
055F6:  MOV     [W0++],[W5++]
055F8:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
055FA:  MOV     #3,W4
055FC:  MOV     W4,A8C
.................... 		                path_found = true; 
055FE:  MOV     #1,W4
05600:  MOV     W4,A84
.................... 		            } 
05602:  GOTO    5A56
.................... 		            else if (posEnd == 1) 
05606:  MOV     1B74,W4
05608:  CP      W4,#1
0560A:  BRA     NZ,588A
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
0560C:  MOV     1B70,W4
0560E:  MUL.UU  W4,#2,W0
05610:  MOV     #A92,W4
05612:  ADD     W0,W4,W0
05614:  MOV     [W0],W5
05616:  MOV     W5,W4
05618:  MUL.UU  W4,#10,W0
0561A:  MOV     W0,W5
0561C:  MOV     1B2A,W4
0561E:  MUL.UU  W4,#4,W0
05620:  ADD     W0,W5,W0
05622:  MOV     #B46,W4
05624:  ADD     W0,W4,W0
05626:  MOV     [W0],W5
05628:  MOV     1B70,W4
0562A:  MUL.UU  W4,#2,W0
0562C:  MOV     #A92,W4
0562E:  ADD     W0,W4,W0
05630:  MOV     [W0],W6
05632:  MOV     W6,W4
05634:  MUL.UU  W4,#10,W6
05636:  MOV     1B2C,W4
05638:  MUL.UU  W4,#4,W0
0563A:  ADD     W0,W6,W0
0563C:  MOV     #B46,W4
0563E:  ADD     W0,W4,W0
05640:  MOV     [W0],W6
05642:  PUSH    1B68
05644:  POP     1B8C
05646:  PUSH    1B6A
05648:  POP     1B8E
0564A:  MOV     W5,1B90
0564C:  MOV     W6,1B92
0564E:  CALL    2DB6
05652:  MOV     W0,W5
05654:  MOV     1B70,W4
05656:  MUL.UU  W4,#2,W0
05658:  MOV     #A92,W4
0565A:  ADD     W0,W4,W0
0565C:  MOV     [W0],W6
0565E:  MOV     W6,W4
05660:  MUL.UU  W4,#10,W6
05662:  MOV     #B46,W4
05664:  ADD     W6,W4,W0
05666:  MOV     [W0],W7
05668:  MOV     1B70,W4
0566A:  MUL.UU  W4,#2,W0
0566C:  MOV     #A92,W4
0566E:  ADD     W0,W4,W0
05670:  MOV     [W0],W8
05672:  MOV     W8,W4
05674:  MUL.UU  W4,#10,W8
05676:  ADD     W8,#4,W8
05678:  MOV     W8,W0
0567A:  MOV     #B46,W4
0567C:  ADD     W0,W4,W0
0567E:  MOV     [W0],W8
05680:  MOV     W7,1B8C
05682:  MOV     W8,1B8E
05684:  PUSH    1B6C
05686:  POP     1B90
05688:  PUSH    1B6E
0568A:  POP     1B92
0568C:  CALL    2DB6
05690:  ADD     W0,W5,W5
05692:  MOV     1B70,W4
05694:  MUL.UU  W4,#2,W0
05696:  MOV     #A92,W4
05698:  ADD     W0,W4,W0
0569A:  MOV     [W0],W7
0569C:  MOV     W7,W4
0569E:  MUL.UU  W4,#10,W0
056A0:  MOV     W0,W7
056A2:  ADD     W7,#8,W7
056A4:  MOV     W7,W0
056A6:  MOV     #B46,W4
056A8:  ADD     W0,W4,W0
056AA:  MOV     [W0],W7
056AC:  MOV     1B70,W4
056AE:  MUL.UU  W4,#2,W0
056B0:  MOV     #A92,W4
056B2:  ADD     W0,W4,W0
056B4:  MOV     [W0],W8
056B6:  MOV     W8,W4
056B8:  MUL.UU  W4,#10,W8
056BA:  ADD     W8,#C,W8
056BC:  MOV     W8,W0
056BE:  MOV     #B46,W4
056C0:  ADD     W0,W4,W0
056C2:  MOV     [W0],W8
056C4:  PUSH    1B68
056C6:  POP     1B8C
056C8:  PUSH    1B6A
056CA:  POP     1B8E
056CC:  MOV     W7,1B90
056CE:  MOV     W8,1B92
056D0:  CALL    2DB6
056D4:  MOV     W0,W7
056D6:  MOV     1B70,W4
056D8:  MUL.UU  W4,#2,W0
056DA:  MOV     #A92,W4
056DC:  ADD     W0,W4,W0
056DE:  MOV     [W0],W8
056E0:  MOV     W8,W4
056E2:  MUL.UU  W4,#10,W8
056E4:  MOV     1B2E,W4
056E6:  MUL.UU  W4,#4,W0
056E8:  ADD     W0,W8,W0
056EA:  MOV     #B46,W4
056EC:  ADD     W0,W4,W0
056EE:  MOV     [W0],W8
056F0:  MOV     1B70,W4
056F2:  MUL.UU  W4,#2,W0
056F4:  MOV     #A92,W4
056F6:  ADD     W0,W4,W0
056F8:  MOV     [W0],W9
056FA:  MOV     W9,W4
056FC:  MUL.UU  W4,#10,W0
056FE:  MOV     W0,W9
05700:  MOV     1B30,W4
05702:  MUL.UU  W4,#4,W0
05704:  ADD     W0,W9,W0
05706:  MOV     #B46,W4
05708:  ADD     W0,W4,W0
0570A:  MOV     [W0],W9
0570C:  MOV     W8,1B8C
0570E:  MOV     W9,1B8E
05710:  PUSH    1B6C
05712:  POP     1B90
05714:  PUSH    1B6E
05716:  POP     1B92
05718:  CALL    2DB6
0571C:  ADD     W0,W7,W0
0571E:  CP      W5,W0
05720:  BRA     GE,57D6
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05722:  MOV     A8E,W4
05724:  MUL.UU  W4,#8,W0
05726:  MOV     W0,W5
05728:  MOV     #AA6,W4
0572A:  ADD     W5,W4,W6
0572C:  MOV     1B70,W4
0572E:  MUL.UU  W4,#2,W0
05730:  MOV     #A92,W4
05732:  ADD     W0,W4,W0
05734:  MOV     [W0],W7
05736:  MOV     W7,W4
05738:  MUL.UU  W4,#10,W0
0573A:  MOV     W0,W7
0573C:  ADD     W7,#8,W7
0573E:  MOV     W7,W0
05740:  MOV     #B46,W4
05742:  ADD     W0,W4,W0
05744:  MOV     [W0++],[W6++]
05746:  MOV     [W0++],[W6++]
05748:  MOV     A8E,W4
0574A:  MUL.UU  W4,#8,W0
0574C:  MOV     W0,W5
0574E:  ADD     W5,#4,W5
05750:  MOV     W5,W0
05752:  MOV     #AA6,W4
05754:  ADD     W0,W4,W5
05756:  MOV     1B70,W4
05758:  MUL.UU  W4,#2,W0
0575A:  MOV     #A92,W4
0575C:  ADD     W0,W4,W0
0575E:  MOV     [W0],W6
05760:  MOV     W6,W4
05762:  MUL.UU  W4,#10,W6
05764:  ADD     W6,#C,W6
05766:  MOV     W6,W0
05768:  MOV     #B46,W4
0576A:  ADD     W0,W4,W0
0576C:  MOV     [W0++],[W5++]
0576E:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05770:  MOV     A8E,W4
05772:  ADD     W4,#1,W4
05774:  MOV     W4,W5
05776:  MOV     W5,W4
05778:  MUL.UU  W4,#8,W0
0577A:  MOV     W0,W5
0577C:  MOV     #AA6,W4
0577E:  ADD     W5,W4,W6
05780:  MOV     1B70,W4
05782:  MUL.UU  W4,#2,W0
05784:  MOV     #A92,W4
05786:  ADD     W0,W4,W0
05788:  MOV     [W0],W7
0578A:  MOV     W7,W4
0578C:  MUL.UU  W4,#10,W0
0578E:  MOV     W0,W7
05790:  MOV     1B2E,W4
05792:  MUL.UU  W4,#4,W0
05794:  ADD     W0,W7,W0
05796:  MOV     #B46,W4
05798:  ADD     W0,W4,W0
0579A:  MOV     [W0++],[W6++]
0579C:  MOV     [W0++],[W6++]
0579E:  MOV     A8E,W4
057A0:  ADD     W4,#1,W4
057A2:  MOV     W4,W5
057A4:  MOV     W5,W4
057A6:  MUL.UU  W4,#8,W0
057A8:  MOV     W0,W5
057AA:  ADD     W5,#4,W5
057AC:  MOV     W5,W0
057AE:  MOV     #AA6,W4
057B0:  ADD     W0,W4,W5
057B2:  MOV     1B70,W4
057B4:  MUL.UU  W4,#2,W0
057B6:  MOV     #A92,W4
057B8:  ADD     W0,W4,W0
057BA:  MOV     [W0],W6
057BC:  MOV     W6,W4
057BE:  MUL.UU  W4,#10,W6
057C0:  MOV     1B30,W4
057C2:  MUL.UU  W4,#4,W0
057C4:  ADD     W0,W6,W0
057C6:  MOV     #B46,W4
057C8:  ADD     W0,W4,W0
057CA:  MOV     [W0++],[W5++]
057CC:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
057CE:  MOV     #2,W4
057D0:  MOV     W4,A8C
.................... 		                } 
057D2:  GOTO    5882
.................... 		                else 
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3];  
057D6:  MOV     A8E,W4
057D8:  MUL.UU  W4,#8,W0
057DA:  MOV     W0,W5
057DC:  MOV     #AA6,W4
057DE:  ADD     W5,W4,W6
057E0:  MOV     1B70,W4
057E2:  MUL.UU  W4,#2,W0
057E4:  MOV     #A92,W4
057E6:  ADD     W0,W4,W0
057E8:  MOV     [W0],W7
057EA:  MOV     W7,W4
057EC:  MUL.UU  W4,#10,W0
057EE:  MOV     W0,W7
057F0:  MOV     1B2A,W4
057F2:  MUL.UU  W4,#4,W0
057F4:  ADD     W0,W7,W0
057F6:  MOV     #B46,W4
057F8:  ADD     W0,W4,W0
057FA:  MOV     [W0++],[W6++]
057FC:  MOV     [W0++],[W6++]
057FE:  MOV     A8E,W4
05800:  MUL.UU  W4,#8,W0
05802:  MOV     W0,W5
05804:  ADD     W5,#4,W5
05806:  MOV     W5,W0
05808:  MOV     #AA6,W4
0580A:  ADD     W0,W4,W5
0580C:  MOV     1B70,W4
0580E:  MUL.UU  W4,#2,W0
05810:  MOV     #A92,W4
05812:  ADD     W0,W4,W0
05814:  MOV     [W0],W6
05816:  MOV     W6,W4
05818:  MUL.UU  W4,#10,W6
0581A:  MOV     1B2C,W4
0581C:  MUL.UU  W4,#4,W0
0581E:  ADD     W0,W6,W0
05820:  MOV     #B46,W4
05822:  ADD     W0,W4,W0
05824:  MOV     [W0++],[W5++]
05826:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05828:  MOV     A8E,W4
0582A:  ADD     W4,#1,W4
0582C:  MOV     W4,W5
0582E:  MOV     W5,W4
05830:  MUL.UU  W4,#8,W0
05832:  MOV     W0,W5
05834:  MOV     #AA6,W4
05836:  ADD     W5,W4,W6
05838:  MOV     1B70,W4
0583A:  MUL.UU  W4,#2,W0
0583C:  MOV     #A92,W4
0583E:  ADD     W0,W4,W0
05840:  MOV     [W0],W7
05842:  MOV     W7,W4
05844:  MUL.UU  W4,#10,W0
05846:  MOV     W0,W7
05848:  MOV     #B46,W4
0584A:  ADD     W7,W4,W0
0584C:  MOV     [W0++],[W6++]
0584E:  MOV     [W0++],[W6++]
05850:  MOV     A8E,W4
05852:  ADD     W4,#1,W4
05854:  MOV     W4,W5
05856:  MOV     W5,W4
05858:  MUL.UU  W4,#8,W0
0585A:  MOV     W0,W5
0585C:  ADD     W5,#4,W5
0585E:  MOV     W5,W0
05860:  MOV     #AA6,W4
05862:  ADD     W0,W4,W5
05864:  MOV     1B70,W4
05866:  MUL.UU  W4,#2,W0
05868:  MOV     #A92,W4
0586A:  ADD     W0,W4,W0
0586C:  MOV     [W0],W6
0586E:  MOV     W6,W4
05870:  MUL.UU  W4,#10,W6
05872:  ADD     W6,#4,W6
05874:  MOV     W6,W0
05876:  MOV     #B46,W4
05878:  ADD     W0,W4,W0
0587A:  MOV     [W0++],[W5++]
0587C:  MOV     [W0++],[W5++]
.................... 		                      
.................... 		                    relay_point_number = 2; 
0587E:  MOV     #2,W4
05880:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
05882:  MOV     #1,W4
05884:  MOV     W4,A84
.................... 		            } 
05886:  GOTO    5A56
.................... 		            else if (posEnd == 7) 
0588A:  MOV     1B74,W4
0588C:  CP      W4,#7
0588E:  BRA     NZ,599E
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05890:  MOV     A8E,W4
05892:  MUL.UU  W4,#8,W0
05894:  MOV     W0,W5
05896:  MOV     #AA6,W4
05898:  ADD     W5,W4,W6
0589A:  MOV     1B70,W4
0589C:  MUL.UU  W4,#2,W0
0589E:  MOV     #A92,W4
058A0:  ADD     W0,W4,W0
058A2:  MOV     [W0],W7
058A4:  MOV     W7,W4
058A6:  MUL.UU  W4,#10,W0
058A8:  MOV     W0,W7
058AA:  ADD     W7,#8,W7
058AC:  MOV     W7,W0
058AE:  MOV     #B46,W4
058B0:  ADD     W0,W4,W0
058B2:  MOV     [W0++],[W6++]
058B4:  MOV     [W0++],[W6++]
058B6:  MOV     A8E,W4
058B8:  MUL.UU  W4,#8,W0
058BA:  MOV     W0,W5
058BC:  ADD     W5,#4,W5
058BE:  MOV     W5,W0
058C0:  MOV     #AA6,W4
058C2:  ADD     W0,W4,W5
058C4:  MOV     1B70,W4
058C6:  MUL.UU  W4,#2,W0
058C8:  MOV     #A92,W4
058CA:  ADD     W0,W4,W0
058CC:  MOV     [W0],W6
058CE:  MOV     W6,W4
058D0:  MUL.UU  W4,#10,W6
058D2:  ADD     W6,#C,W6
058D4:  MOV     W6,W0
058D6:  MOV     #B46,W4
058D8:  ADD     W0,W4,W0
058DA:  MOV     [W0++],[W5++]
058DC:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
058DE:  MOV     A8E,W4
058E0:  ADD     W4,#1,W4
058E2:  MOV     W4,W5
058E4:  MOV     W5,W4
058E6:  MUL.UU  W4,#8,W0
058E8:  MOV     W0,W5
058EA:  MOV     #AA6,W4
058EC:  ADD     W5,W4,W6
058EE:  MOV     1B70,W4
058F0:  MUL.UU  W4,#2,W0
058F2:  MOV     #A92,W4
058F4:  ADD     W0,W4,W0
058F6:  MOV     [W0],W7
058F8:  MOV     W7,W4
058FA:  MUL.UU  W4,#10,W0
058FC:  MOV     W0,W7
058FE:  MOV     1B2E,W4
05900:  MUL.UU  W4,#4,W0
05902:  ADD     W0,W7,W0
05904:  MOV     #B46,W4
05906:  ADD     W0,W4,W0
05908:  MOV     [W0++],[W6++]
0590A:  MOV     [W0++],[W6++]
0590C:  MOV     A8E,W4
0590E:  ADD     W4,#1,W4
05910:  MOV     W4,W5
05912:  MOV     W5,W4
05914:  MUL.UU  W4,#8,W0
05916:  MOV     W0,W5
05918:  ADD     W5,#4,W5
0591A:  MOV     W5,W0
0591C:  MOV     #AA6,W4
0591E:  ADD     W0,W4,W5
05920:  MOV     1B70,W4
05922:  MUL.UU  W4,#2,W0
05924:  MOV     #A92,W4
05926:  ADD     W0,W4,W0
05928:  MOV     [W0],W6
0592A:  MOV     W6,W4
0592C:  MUL.UU  W4,#10,W6
0592E:  MOV     1B30,W4
05930:  MUL.UU  W4,#4,W0
05932:  ADD     W0,W6,W0
05934:  MOV     #B46,W4
05936:  ADD     W0,W4,W0
05938:  MOV     [W0++],[W5++]
0593A:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0593C:  MOV     A8E,W4
0593E:  ADD     W4,#2,W4
05940:  MOV     W4,W5
05942:  MOV     W5,W4
05944:  MUL.UU  W4,#8,W0
05946:  MOV     W0,W5
05948:  MOV     #AA6,W4
0594A:  ADD     W5,W4,W6
0594C:  MOV     1B70,W4
0594E:  MUL.UU  W4,#2,W0
05950:  MOV     #A92,W4
05952:  ADD     W0,W4,W0
05954:  MOV     [W0],W7
05956:  MOV     W7,W4
05958:  MUL.UU  W4,#10,W0
0595A:  MOV     W0,W7
0595C:  MOV     #B46,W4
0595E:  ADD     W7,W4,W0
05960:  MOV     [W0++],[W6++]
05962:  MOV     [W0++],[W6++]
05964:  MOV     A8E,W4
05966:  ADD     W4,#2,W4
05968:  MOV     W4,W5
0596A:  MOV     W5,W4
0596C:  MUL.UU  W4,#8,W0
0596E:  MOV     W0,W5
05970:  ADD     W5,#4,W5
05972:  MOV     W5,W0
05974:  MOV     #AA6,W4
05976:  ADD     W0,W4,W5
05978:  MOV     1B70,W4
0597A:  MUL.UU  W4,#2,W0
0597C:  MOV     #A92,W4
0597E:  ADD     W0,W4,W0
05980:  MOV     [W0],W6
05982:  MOV     W6,W4
05984:  MUL.UU  W4,#10,W6
05986:  ADD     W6,#4,W6
05988:  MOV     W6,W0
0598A:  MOV     #B46,W4
0598C:  ADD     W0,W4,W0
0598E:  MOV     [W0++],[W5++]
05990:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
05992:  MOV     #3,W4
05994:  MOV     W4,A8C
.................... 		                path_found = true; 
05996:  MOV     #1,W4
05998:  MOV     W4,A84
.................... 		            } 
0599A:  GOTO    5A56
.................... 		            else if(posEnd == 0) 
0599E:  CP0     1B74
059A0:  BRA     NZ,5A56
.................... 		            { 
.................... 						PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
059A2:  MOV     A8E,W4
059A4:  MUL.UU  W4,#8,W0
059A6:  MOV     W0,W5
059A8:  MOV     #AA6,W4
059AA:  ADD     W5,W4,W6
059AC:  MOV     1B70,W4
059AE:  MUL.UU  W4,#2,W0
059B0:  MOV     #A92,W4
059B2:  ADD     W0,W4,W0
059B4:  MOV     [W0],W7
059B6:  MOV     W7,W4
059B8:  MUL.UU  W4,#10,W0
059BA:  MOV     W0,W7
059BC:  ADD     W7,#8,W7
059BE:  MOV     W7,W0
059C0:  MOV     #B46,W4
059C2:  ADD     W0,W4,W0
059C4:  MOV     [W0++],[W6++]
059C6:  MOV     [W0++],[W6++]
059C8:  MOV     A8E,W4
059CA:  MUL.UU  W4,#8,W0
059CC:  MOV     W0,W5
059CE:  ADD     W5,#4,W5
059D0:  MOV     W5,W0
059D2:  MOV     #AA6,W4
059D4:  ADD     W0,W4,W5
059D6:  MOV     1B70,W4
059D8:  MUL.UU  W4,#2,W0
059DA:  MOV     #A92,W4
059DC:  ADD     W0,W4,W0
059DE:  MOV     [W0],W6
059E0:  MOV     W6,W4
059E2:  MUL.UU  W4,#10,W6
059E4:  ADD     W6,#C,W6
059E6:  MOV     W6,W0
059E8:  MOV     #B46,W4
059EA:  ADD     W0,W4,W0
059EC:  MOV     [W0++],[W5++]
059EE:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
059F0:  MOV     A8E,W4
059F2:  ADD     W4,#1,W4
059F4:  MOV     W4,W5
059F6:  MOV     W5,W4
059F8:  MUL.UU  W4,#8,W0
059FA:  MOV     W0,W5
059FC:  MOV     #AA6,W4
059FE:  ADD     W5,W4,W6
05A00:  MOV     1B70,W4
05A02:  MUL.UU  W4,#2,W0
05A04:  MOV     #A92,W4
05A06:  ADD     W0,W4,W0
05A08:  MOV     [W0],W7
05A0A:  MOV     W7,W4
05A0C:  MUL.UU  W4,#10,W0
05A0E:  MOV     W0,W7
05A10:  MOV     1B2E,W4
05A12:  MUL.UU  W4,#4,W0
05A14:  ADD     W0,W7,W0
05A16:  MOV     #B46,W4
05A18:  ADD     W0,W4,W0
05A1A:  MOV     [W0++],[W6++]
05A1C:  MOV     [W0++],[W6++]
05A1E:  MOV     A8E,W4
05A20:  ADD     W4,#1,W4
05A22:  MOV     W4,W5
05A24:  MOV     W5,W4
05A26:  MUL.UU  W4,#8,W0
05A28:  MOV     W0,W5
05A2A:  ADD     W5,#4,W5
05A2C:  MOV     W5,W0
05A2E:  MOV     #AA6,W4
05A30:  ADD     W0,W4,W5
05A32:  MOV     1B70,W4
05A34:  MUL.UU  W4,#2,W0
05A36:  MOV     #A92,W4
05A38:  ADD     W0,W4,W0
05A3A:  MOV     [W0],W6
05A3C:  MOV     W6,W4
05A3E:  MUL.UU  W4,#10,W6
05A40:  MOV     1B30,W4
05A42:  MUL.UU  W4,#4,W0
05A44:  ADD     W0,W6,W0
05A46:  MOV     #B46,W4
05A48:  ADD     W0,W4,W0
05A4A:  MOV     [W0++],[W5++]
05A4C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
05A4E:  MOV     #2,W4
05A50:  MOV     W4,A8C
.................... 		                path_found = true; 
05A52:  MOV     #1,W4
05A54:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
05A56:  GOTO    5DA8
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 2 || posEnd == 3) 
05A5A:  MOV     1B74,W4
05A5C:  CP      W4,#2
05A5E:  BRA     Z,5A66
05A60:  MOV     1B74,W4
05A62:  CP      W4,#3
05A64:  BRA     NZ,5AC0
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05A66:  MOV     A8E,W4
05A68:  MUL.UU  W4,#8,W0
05A6A:  MOV     W0,W5
05A6C:  MOV     #AA6,W4
05A6E:  ADD     W5,W4,W6
05A70:  MOV     1B70,W4
05A72:  MUL.UU  W4,#2,W0
05A74:  MOV     #A92,W4
05A76:  ADD     W0,W4,W0
05A78:  MOV     [W0],W7
05A7A:  MOV     W7,W4
05A7C:  MUL.UU  W4,#10,W0
05A7E:  MOV     W0,W7
05A80:  ADD     W7,#8,W7
05A82:  MOV     W7,W0
05A84:  MOV     #B46,W4
05A86:  ADD     W0,W4,W0
05A88:  MOV     [W0++],[W6++]
05A8A:  MOV     [W0++],[W6++]
05A8C:  MOV     A8E,W4
05A8E:  MUL.UU  W4,#8,W0
05A90:  MOV     W0,W5
05A92:  ADD     W5,#4,W5
05A94:  MOV     W5,W0
05A96:  MOV     #AA6,W4
05A98:  ADD     W0,W4,W5
05A9A:  MOV     1B70,W4
05A9C:  MUL.UU  W4,#2,W0
05A9E:  MOV     #A92,W4
05AA0:  ADD     W0,W4,W0
05AA2:  MOV     [W0],W6
05AA4:  MOV     W6,W4
05AA6:  MUL.UU  W4,#10,W6
05AA8:  ADD     W6,#C,W6
05AAA:  MOV     W6,W0
05AAC:  MOV     #B46,W4
05AAE:  ADD     W0,W4,W0
05AB0:  MOV     [W0++],[W5++]
05AB2:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
05AB4:  MOV     #1,W4
05AB6:  MOV     W4,A8C
.................... 		                path_found = true; 
05AB8:  MOV     #1,W4
05ABA:  MOV     W4,A84
.................... 		            } 
05ABC:  GOTO    5DA8
.................... 		            else if (posEnd == 1) 
05AC0:  MOV     1B74,W4
05AC2:  CP      W4,#1
05AC4:  BRA     NZ,5D44
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd)) 
05AC6:  MOV     1B70,W4
05AC8:  MUL.UU  W4,#2,W0
05ACA:  MOV     #A92,W4
05ACC:  ADD     W0,W4,W0
05ACE:  MOV     [W0],W5
05AD0:  MOV     W5,W4
05AD2:  MUL.UU  W4,#10,W0
05AD4:  MOV     W0,W5
05AD6:  MOV     1B2A,W4
05AD8:  MUL.UU  W4,#4,W0
05ADA:  ADD     W0,W5,W0
05ADC:  MOV     #B46,W4
05ADE:  ADD     W0,W4,W0
05AE0:  MOV     [W0],W5
05AE2:  MOV     1B70,W4
05AE4:  MUL.UU  W4,#2,W0
05AE6:  MOV     #A92,W4
05AE8:  ADD     W0,W4,W0
05AEA:  MOV     [W0],W6
05AEC:  MOV     W6,W4
05AEE:  MUL.UU  W4,#10,W6
05AF0:  MOV     1B2C,W4
05AF2:  MUL.UU  W4,#4,W0
05AF4:  ADD     W0,W6,W0
05AF6:  MOV     #B46,W4
05AF8:  ADD     W0,W4,W0
05AFA:  MOV     [W0],W6
05AFC:  PUSH    1B68
05AFE:  POP     1B8C
05B00:  PUSH    1B6A
05B02:  POP     1B8E
05B04:  MOV     W5,1B90
05B06:  MOV     W6,1B92
05B08:  CALL    2DB6
05B0C:  MOV     W0,W5
05B0E:  MOV     1B70,W4
05B10:  MUL.UU  W4,#2,W0
05B12:  MOV     #A92,W4
05B14:  ADD     W0,W4,W0
05B16:  MOV     [W0],W6
05B18:  MOV     W6,W4
05B1A:  MUL.UU  W4,#10,W6
05B1C:  MOV     #B46,W4
05B1E:  ADD     W6,W4,W0
05B20:  MOV     [W0],W7
05B22:  MOV     1B70,W4
05B24:  MUL.UU  W4,#2,W0
05B26:  MOV     #A92,W4
05B28:  ADD     W0,W4,W0
05B2A:  MOV     [W0],W8
05B2C:  MOV     W8,W4
05B2E:  MUL.UU  W4,#10,W8
05B30:  ADD     W8,#4,W8
05B32:  MOV     W8,W0
05B34:  MOV     #B46,W4
05B36:  ADD     W0,W4,W0
05B38:  MOV     [W0],W8
05B3A:  MOV     W7,1B8C
05B3C:  MOV     W8,1B8E
05B3E:  PUSH    1B6C
05B40:  POP     1B90
05B42:  PUSH    1B6E
05B44:  POP     1B92
05B46:  CALL    2DB6
05B4A:  ADD     W0,W5,W5
05B4C:  MOV     1B70,W4
05B4E:  MUL.UU  W4,#2,W0
05B50:  MOV     #A92,W4
05B52:  ADD     W0,W4,W0
05B54:  MOV     [W0],W7
05B56:  MOV     W7,W4
05B58:  MUL.UU  W4,#10,W0
05B5A:  MOV     W0,W7
05B5C:  ADD     W7,#8,W7
05B5E:  MOV     W7,W0
05B60:  MOV     #B46,W4
05B62:  ADD     W0,W4,W0
05B64:  MOV     [W0],W7
05B66:  MOV     1B70,W4
05B68:  MUL.UU  W4,#2,W0
05B6A:  MOV     #A92,W4
05B6C:  ADD     W0,W4,W0
05B6E:  MOV     [W0],W8
05B70:  MOV     W8,W4
05B72:  MUL.UU  W4,#10,W8
05B74:  ADD     W8,#C,W8
05B76:  MOV     W8,W0
05B78:  MOV     #B46,W4
05B7A:  ADD     W0,W4,W0
05B7C:  MOV     [W0],W8
05B7E:  PUSH    1B68
05B80:  POP     1B8C
05B82:  PUSH    1B6A
05B84:  POP     1B8E
05B86:  MOV     W7,1B90
05B88:  MOV     W8,1B92
05B8A:  CALL    2DB6
05B8E:  MOV     W0,W7
05B90:  MOV     1B70,W4
05B92:  MUL.UU  W4,#2,W0
05B94:  MOV     #A92,W4
05B96:  ADD     W0,W4,W0
05B98:  MOV     [W0],W8
05B9A:  MOV     W8,W4
05B9C:  MUL.UU  W4,#10,W8
05B9E:  MOV     1B2E,W4
05BA0:  MUL.UU  W4,#4,W0
05BA2:  ADD     W0,W8,W0
05BA4:  MOV     #B46,W4
05BA6:  ADD     W0,W4,W0
05BA8:  MOV     [W0],W8
05BAA:  MOV     1B70,W4
05BAC:  MUL.UU  W4,#2,W0
05BAE:  MOV     #A92,W4
05BB0:  ADD     W0,W4,W0
05BB2:  MOV     [W0],W9
05BB4:  MOV     W9,W4
05BB6:  MUL.UU  W4,#10,W0
05BB8:  MOV     W0,W9
05BBA:  MOV     1B30,W4
05BBC:  MUL.UU  W4,#4,W0
05BBE:  ADD     W0,W9,W0
05BC0:  MOV     #B46,W4
05BC2:  ADD     W0,W4,W0
05BC4:  MOV     [W0],W9
05BC6:  MOV     W8,1B8C
05BC8:  MOV     W9,1B8E
05BCA:  PUSH    1B6C
05BCC:  POP     1B90
05BCE:  PUSH    1B6E
05BD0:  POP     1B92
05BD2:  CALL    2DB6
05BD6:  ADD     W0,W7,W0
05BD8:  CP      W5,W0
05BDA:  BRA     GE,5C8C
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3];  
05BDC:  MOV     A8E,W4
05BDE:  MUL.UU  W4,#8,W0
05BE0:  MOV     W0,W5
05BE2:  MOV     #AA6,W4
05BE4:  ADD     W5,W4,W6
05BE6:  MOV     1B70,W4
05BE8:  MUL.UU  W4,#2,W0
05BEA:  MOV     #A92,W4
05BEC:  ADD     W0,W4,W0
05BEE:  MOV     [W0],W7
05BF0:  MOV     W7,W4
05BF2:  MUL.UU  W4,#10,W0
05BF4:  MOV     W0,W7
05BF6:  MOV     1B2A,W4
05BF8:  MUL.UU  W4,#4,W0
05BFA:  ADD     W0,W7,W0
05BFC:  MOV     #B46,W4
05BFE:  ADD     W0,W4,W0
05C00:  MOV     [W0++],[W6++]
05C02:  MOV     [W0++],[W6++]
05C04:  MOV     A8E,W4
05C06:  MUL.UU  W4,#8,W0
05C08:  MOV     W0,W5
05C0A:  ADD     W5,#4,W5
05C0C:  MOV     W5,W0
05C0E:  MOV     #AA6,W4
05C10:  ADD     W0,W4,W5
05C12:  MOV     1B70,W4
05C14:  MUL.UU  W4,#2,W0
05C16:  MOV     #A92,W4
05C18:  ADD     W0,W4,W0
05C1A:  MOV     [W0],W6
05C1C:  MOV     W6,W4
05C1E:  MUL.UU  W4,#10,W6
05C20:  MOV     1B2C,W4
05C22:  MUL.UU  W4,#4,W0
05C24:  ADD     W0,W6,W0
05C26:  MOV     #B46,W4
05C28:  ADD     W0,W4,W0
05C2A:  MOV     [W0++],[W5++]
05C2C:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05C2E:  MOV     A8E,W4
05C30:  ADD     W4,#1,W4
05C32:  MOV     W4,W5
05C34:  MOV     W5,W4
05C36:  MUL.UU  W4,#8,W0
05C38:  MOV     W0,W5
05C3A:  MOV     #AA6,W4
05C3C:  ADD     W5,W4,W6
05C3E:  MOV     1B70,W4
05C40:  MUL.UU  W4,#2,W0
05C42:  MOV     #A92,W4
05C44:  ADD     W0,W4,W0
05C46:  MOV     [W0],W7
05C48:  MOV     W7,W4
05C4A:  MUL.UU  W4,#10,W0
05C4C:  MOV     W0,W7
05C4E:  MOV     #B46,W4
05C50:  ADD     W7,W4,W0
05C52:  MOV     [W0++],[W6++]
05C54:  MOV     [W0++],[W6++]
05C56:  MOV     A8E,W4
05C58:  ADD     W4,#1,W4
05C5A:  MOV     W4,W5
05C5C:  MOV     W5,W4
05C5E:  MUL.UU  W4,#8,W0
05C60:  MOV     W0,W5
05C62:  ADD     W5,#4,W5
05C64:  MOV     W5,W0
05C66:  MOV     #AA6,W4
05C68:  ADD     W0,W4,W5
05C6A:  MOV     1B70,W4
05C6C:  MUL.UU  W4,#2,W0
05C6E:  MOV     #A92,W4
05C70:  ADD     W0,W4,W0
05C72:  MOV     [W0],W6
05C74:  MOV     W6,W4
05C76:  MUL.UU  W4,#10,W6
05C78:  ADD     W6,#4,W6
05C7A:  MOV     W6,W0
05C7C:  MOV     #B46,W4
05C7E:  ADD     W0,W4,W0
05C80:  MOV     [W0++],[W5++]
05C82:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
05C84:  MOV     #2,W4
05C86:  MOV     W4,A8C
.................... 		                } 
05C88:  GOTO    5D3C
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05C8C:  MOV     A8E,W4
05C8E:  MUL.UU  W4,#8,W0
05C90:  MOV     W0,W5
05C92:  MOV     #AA6,W4
05C94:  ADD     W5,W4,W6
05C96:  MOV     1B70,W4
05C98:  MUL.UU  W4,#2,W0
05C9A:  MOV     #A92,W4
05C9C:  ADD     W0,W4,W0
05C9E:  MOV     [W0],W7
05CA0:  MOV     W7,W4
05CA2:  MUL.UU  W4,#10,W0
05CA4:  MOV     W0,W7
05CA6:  ADD     W7,#8,W7
05CA8:  MOV     W7,W0
05CAA:  MOV     #B46,W4
05CAC:  ADD     W0,W4,W0
05CAE:  MOV     [W0++],[W6++]
05CB0:  MOV     [W0++],[W6++]
05CB2:  MOV     A8E,W4
05CB4:  MUL.UU  W4,#8,W0
05CB6:  MOV     W0,W5
05CB8:  ADD     W5,#4,W5
05CBA:  MOV     W5,W0
05CBC:  MOV     #AA6,W4
05CBE:  ADD     W0,W4,W5
05CC0:  MOV     1B70,W4
05CC2:  MUL.UU  W4,#2,W0
05CC4:  MOV     #A92,W4
05CC6:  ADD     W0,W4,W0
05CC8:  MOV     [W0],W6
05CCA:  MOV     W6,W4
05CCC:  MUL.UU  W4,#10,W6
05CCE:  ADD     W6,#C,W6
05CD0:  MOV     W6,W0
05CD2:  MOV     #B46,W4
05CD4:  ADD     W0,W4,W0
05CD6:  MOV     [W0++],[W5++]
05CD8:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2];  
05CDA:  MOV     A8E,W4
05CDC:  ADD     W4,#1,W4
05CDE:  MOV     W4,W5
05CE0:  MOV     W5,W4
05CE2:  MUL.UU  W4,#8,W0
05CE4:  MOV     W0,W5
05CE6:  MOV     #AA6,W4
05CE8:  ADD     W5,W4,W6
05CEA:  MOV     1B70,W4
05CEC:  MUL.UU  W4,#2,W0
05CEE:  MOV     #A92,W4
05CF0:  ADD     W0,W4,W0
05CF2:  MOV     [W0],W7
05CF4:  MOV     W7,W4
05CF6:  MUL.UU  W4,#10,W0
05CF8:  MOV     W0,W7
05CFA:  MOV     1B2E,W4
05CFC:  MUL.UU  W4,#4,W0
05CFE:  ADD     W0,W7,W0
05D00:  MOV     #B46,W4
05D02:  ADD     W0,W4,W0
05D04:  MOV     [W0++],[W6++]
05D06:  MOV     [W0++],[W6++]
05D08:  MOV     A8E,W4
05D0A:  ADD     W4,#1,W4
05D0C:  MOV     W4,W5
05D0E:  MOV     W5,W4
05D10:  MUL.UU  W4,#8,W0
05D12:  MOV     W0,W5
05D14:  ADD     W5,#4,W5
05D16:  MOV     W5,W0
05D18:  MOV     #AA6,W4
05D1A:  ADD     W0,W4,W5
05D1C:  MOV     1B70,W4
05D1E:  MUL.UU  W4,#2,W0
05D20:  MOV     #A92,W4
05D22:  ADD     W0,W4,W0
05D24:  MOV     [W0],W6
05D26:  MOV     W6,W4
05D28:  MUL.UU  W4,#10,W6
05D2A:  MOV     1B30,W4
05D2C:  MUL.UU  W4,#4,W0
05D2E:  ADD     W0,W6,W0
05D30:  MOV     #B46,W4
05D32:  ADD     W0,W4,W0
05D34:  MOV     [W0++],[W5++]
05D36:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
05D38:  MOV     #2,W4
05D3A:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
05D3C:  MOV     #1,W4
05D3E:  MOV     W4,A84
.................... 		            } 
05D40:  GOTO    5DA8
.................... 		            else if (posEnd == 7 || posEnd == 0) 
05D44:  MOV     1B74,W4
05D46:  CP      W4,#7
05D48:  BRA     Z,5D4E
05D4A:  CP0     1B74
05D4C:  BRA     NZ,5DA8
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
05D4E:  MOV     A8E,W4
05D50:  MUL.UU  W4,#8,W0
05D52:  MOV     W0,W5
05D54:  MOV     #AA6,W4
05D56:  ADD     W5,W4,W6
05D58:  MOV     1B70,W4
05D5A:  MUL.UU  W4,#2,W0
05D5C:  MOV     #A92,W4
05D5E:  ADD     W0,W4,W0
05D60:  MOV     [W0],W7
05D62:  MOV     W7,W4
05D64:  MUL.UU  W4,#10,W0
05D66:  MOV     W0,W7
05D68:  MOV     1B2A,W4
05D6A:  MUL.UU  W4,#4,W0
05D6C:  ADD     W0,W7,W0
05D6E:  MOV     #B46,W4
05D70:  ADD     W0,W4,W0
05D72:  MOV     [W0++],[W6++]
05D74:  MOV     [W0++],[W6++]
05D76:  MOV     A8E,W4
05D78:  MUL.UU  W4,#8,W0
05D7A:  MOV     W0,W5
05D7C:  ADD     W5,#4,W5
05D7E:  MOV     W5,W0
05D80:  MOV     #AA6,W4
05D82:  ADD     W0,W4,W5
05D84:  MOV     1B70,W4
05D86:  MUL.UU  W4,#2,W0
05D88:  MOV     #A92,W4
05D8A:  ADD     W0,W4,W0
05D8C:  MOV     [W0],W6
05D8E:  MOV     W6,W4
05D90:  MUL.UU  W4,#10,W6
05D92:  MOV     1B2C,W4
05D94:  MUL.UU  W4,#4,W0
05D96:  ADD     W0,W6,W0
05D98:  MOV     #B46,W4
05D9A:  ADD     W0,W4,W0
05D9C:  MOV     [W0++],[W5++]
05D9E:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
05DA0:  MOV     #1,W4
05DA2:  MOV     W4,A8C
.................... 		                path_found = true; 
05DA4:  MOV     #1,W4
05DA6:  MOV     W4,A84
.................... 		            } 
.................... 				} 
.................... 	            break; 
05DA8:  GOTO    6CF8
....................  
.................... 	        case 6: 
....................  
.................... 	        	if(path_opposite) 
05DAC:  CP0     A88
05DAE:  BRA     Z,60EA
.................... 	        	{ 
....................         			 
.................... 	                if (posEnd == 3) 
05DB0:  MOV     1B74,W4
05DB2:  CP      W4,#3
05DB4:  BRA     NZ,5E6A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05DB6:  MOV     A8E,W4
05DB8:  MUL.UU  W4,#8,W0
05DBA:  MOV     W0,W5
05DBC:  MOV     #AA6,W4
05DBE:  ADD     W5,W4,W6
05DC0:  MOV     1B70,W4
05DC2:  MUL.UU  W4,#2,W0
05DC4:  MOV     #A92,W4
05DC6:  ADD     W0,W4,W0
05DC8:  MOV     [W0],W7
05DCA:  MOV     W7,W4
05DCC:  MUL.UU  W4,#10,W0
05DCE:  MOV     W0,W7
05DD0:  MOV     #B46,W4
05DD2:  ADD     W7,W4,W0
05DD4:  MOV     [W0++],[W6++]
05DD6:  MOV     [W0++],[W6++]
05DD8:  MOV     A8E,W4
05DDA:  MUL.UU  W4,#8,W0
05DDC:  MOV     W0,W5
05DDE:  ADD     W5,#4,W5
05DE0:  MOV     W5,W0
05DE2:  MOV     #AA6,W4
05DE4:  ADD     W0,W4,W5
05DE6:  MOV     1B70,W4
05DE8:  MUL.UU  W4,#2,W0
05DEA:  MOV     #A92,W4
05DEC:  ADD     W0,W4,W0
05DEE:  MOV     [W0],W6
05DF0:  MOV     W6,W4
05DF2:  MUL.UU  W4,#10,W6
05DF4:  ADD     W6,#4,W6
05DF6:  MOV     W6,W0
05DF8:  MOV     #B46,W4
05DFA:  ADD     W0,W4,W0
05DFC:  MOV     [W0++],[W5++]
05DFE:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
05E00:  MOV     A8E,W4
05E02:  ADD     W4,#1,W4
05E04:  MOV     W4,W5
05E06:  MOV     W5,W4
05E08:  MUL.UU  W4,#8,W0
05E0A:  MOV     W0,W5
05E0C:  MOV     #AA6,W4
05E0E:  ADD     W5,W4,W6
05E10:  MOV     1B70,W4
05E12:  MUL.UU  W4,#2,W0
05E14:  MOV     #A92,W4
05E16:  ADD     W0,W4,W0
05E18:  MOV     [W0],W7
05E1A:  MOV     W7,W4
05E1C:  MUL.UU  W4,#10,W0
05E1E:  MOV     W0,W7
05E20:  MOV     1B2E,W4
05E22:  MUL.UU  W4,#4,W0
05E24:  ADD     W0,W7,W0
05E26:  MOV     #B46,W4
05E28:  ADD     W0,W4,W0
05E2A:  MOV     [W0++],[W6++]
05E2C:  MOV     [W0++],[W6++]
05E2E:  MOV     A8E,W4
05E30:  ADD     W4,#1,W4
05E32:  MOV     W4,W5
05E34:  MOV     W5,W4
05E36:  MUL.UU  W4,#8,W0
05E38:  MOV     W0,W5
05E3A:  ADD     W5,#4,W5
05E3C:  MOV     W5,W0
05E3E:  MOV     #AA6,W4
05E40:  ADD     W0,W4,W5
05E42:  MOV     1B70,W4
05E44:  MUL.UU  W4,#2,W0
05E46:  MOV     #A92,W4
05E48:  ADD     W0,W4,W0
05E4A:  MOV     [W0],W6
05E4C:  MOV     W6,W4
05E4E:  MUL.UU  W4,#10,W6
05E50:  MOV     1B30,W4
05E52:  MUL.UU  W4,#4,W0
05E54:  ADD     W0,W6,W0
05E56:  MOV     #B46,W4
05E58:  ADD     W0,W4,W0
05E5A:  MOV     [W0++],[W5++]
05E5C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
05E5E:  MOV     #2,W4
05E60:  MOV     W4,A8C
.................... 		                path_found = true; 
05E62:  MOV     #1,W4
05E64:  MOV     W4,A84
.................... 		            } 
05E66:  GOTO    60E6
.................... 		            else if (posEnd == 2) 
05E6A:  MOV     1B74,W4
05E6C:  CP      W4,#2
05E6E:  BRA     NZ,602C
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
05E70:  MOV     1B70,W4
05E72:  MUL.UU  W4,#2,W0
05E74:  MOV     #A92,W4
05E76:  ADD     W0,W4,W0
05E78:  MOV     [W0],W5
05E7A:  MOV     W5,W4
05E7C:  MUL.UU  W4,#10,W0
05E7E:  MOV     W0,W5
05E80:  MOV     #B46,W4
05E82:  ADD     W5,W4,W0
05E84:  MOV     [W0],W6
05E86:  MOV     1B70,W4
05E88:  MUL.UU  W4,#2,W0
05E8A:  MOV     #A92,W4
05E8C:  ADD     W0,W4,W0
05E8E:  MOV     [W0],W7
05E90:  MOV     W7,W4
05E92:  MUL.UU  W4,#10,W0
05E94:  MOV     W0,W7
05E96:  ADD     W7,#4,W7
05E98:  MOV     W7,W0
05E9A:  MOV     #B46,W4
05E9C:  ADD     W0,W4,W0
05E9E:  MOV     [W0],W7
05EA0:  PUSH    1B68
05EA2:  POP     1B8C
05EA4:  PUSH    1B6A
05EA6:  POP     1B8E
05EA8:  MOV     W6,1B90
05EAA:  MOV     W7,1B92
05EAC:  CALL    2DB6
05EB0:  MOV     W0,W6
05EB2:  MOV     1B70,W4
05EB4:  MUL.UU  W4,#2,W0
05EB6:  MOV     #A92,W4
05EB8:  ADD     W0,W4,W0
05EBA:  MOV     [W0],W7
05EBC:  MOV     W7,W4
05EBE:  MUL.UU  W4,#10,W0
05EC0:  MOV     W0,W7
05EC2:  MOV     #B46,W4
05EC4:  ADD     W7,W4,W0
05EC6:  MOV     [W0],W8
05EC8:  MOV     1B70,W4
05ECA:  MUL.UU  W4,#2,W0
05ECC:  MOV     #A92,W4
05ECE:  ADD     W0,W4,W0
05ED0:  MOV     [W0],W9
05ED2:  MOV     W9,W4
05ED4:  MUL.UU  W4,#10,W0
05ED6:  MOV     W0,W9
05ED8:  ADD     W9,#4,W9
05EDA:  MOV     W9,W0
05EDC:  MOV     #B46,W4
05EDE:  ADD     W0,W4,W0
05EE0:  MOV     [W0],W9
05EE2:  MOV     W8,1B8C
05EE4:  MOV     W9,1B8E
05EE6:  PUSH    1B6C
05EE8:  POP     1B90
05EEA:  PUSH    1B6E
05EEC:  POP     1B92
05EEE:  CALL    2DB6
05EF2:  ADD     W0,W6,W6
05EF4:  MOV     1B70,W4
05EF6:  MUL.UU  W4,#2,W0
05EF8:  MOV     #A92,W4
05EFA:  ADD     W0,W4,W0
05EFC:  MOV     [W0],W8
05EFE:  MOV     W8,W4
05F00:  MUL.UU  W4,#10,W8
05F02:  ADD     W8,#8,W8
05F04:  MOV     W8,W0
05F06:  MOV     #B46,W4
05F08:  ADD     W0,W4,W0
05F0A:  MOV     [W0],W8
05F0C:  MOV     1B70,W4
05F0E:  MUL.UU  W4,#2,W0
05F10:  MOV     #A92,W4
05F12:  ADD     W0,W4,W0
05F14:  MOV     [W0],W9
05F16:  MOV     W9,W4
05F18:  MUL.UU  W4,#10,W0
05F1A:  MOV     W0,W9
05F1C:  ADD     W9,#C,W9
05F1E:  MOV     W9,W0
05F20:  MOV     #B46,W4
05F22:  ADD     W0,W4,W0
05F24:  MOV     [W0],W9
05F26:  PUSH    1B68
05F28:  POP     1B8C
05F2A:  PUSH    1B6A
05F2C:  POP     1B8E
05F2E:  MOV     W8,1B90
05F30:  MOV     W9,1B92
05F32:  CALL    2DB6
05F36:  MOV     W0,W8
05F38:  MOV     1B70,W4
05F3A:  MUL.UU  W4,#2,W0
05F3C:  MOV     #A92,W4
05F3E:  ADD     W0,W4,W0
05F40:  MOV     [W0],W9
05F42:  MOV     W9,W4
05F44:  MUL.UU  W4,#10,W0
05F46:  MOV     W0,W9
05F48:  ADD     W9,#8,W9
05F4A:  MOV     W9,W0
05F4C:  MOV     #B46,W4
05F4E:  ADD     W0,W4,W0
05F50:  MOV     [W0],W9
05F52:  MOV     1B70,W4
05F54:  MUL.UU  W4,#2,W0
05F56:  MOV     #A92,W4
05F58:  ADD     W0,W4,W0
05F5A:  MOV     [W0],W10
05F5C:  MOV     W10,W4
05F5E:  MUL.UU  W4,#10,W10
05F60:  ADD     W10,#C,W10
05F62:  MOV     W10,W0
05F64:  MOV     #B46,W4
05F66:  ADD     W0,W4,W0
05F68:  MOV     [W0],W10
05F6A:  MOV     W9,1B8C
05F6C:  MOV     W10,1B8E
05F6E:  PUSH    1B6C
05F70:  POP     1B90
05F72:  PUSH    1B6E
05F74:  POP     1B92
05F76:  CALL    2DB6
05F7A:  ADD     W0,W8,W0
05F7C:  CP      W6,W0
05F7E:  BRA     GE,5FD6
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
05F80:  MOV     A8E,W4
05F82:  MUL.UU  W4,#8,W0
05F84:  MOV     W0,W5
05F86:  MOV     #AA6,W4
05F88:  ADD     W5,W4,W6
05F8A:  MOV     1B70,W4
05F8C:  MUL.UU  W4,#2,W0
05F8E:  MOV     #A92,W4
05F90:  ADD     W0,W4,W0
05F92:  MOV     [W0],W7
05F94:  MOV     W7,W4
05F96:  MUL.UU  W4,#10,W0
05F98:  MOV     W0,W7
05F9A:  ADD     W7,#8,W7
05F9C:  MOV     W7,W0
05F9E:  MOV     #B46,W4
05FA0:  ADD     W0,W4,W0
05FA2:  MOV     [W0++],[W6++]
05FA4:  MOV     [W0++],[W6++]
05FA6:  MOV     A8E,W4
05FA8:  MUL.UU  W4,#8,W0
05FAA:  MOV     W0,W5
05FAC:  ADD     W5,#4,W5
05FAE:  MOV     W5,W0
05FB0:  MOV     #AA6,W4
05FB2:  ADD     W0,W4,W5
05FB4:  MOV     1B70,W4
05FB6:  MUL.UU  W4,#2,W0
05FB8:  MOV     #A92,W4
05FBA:  ADD     W0,W4,W0
05FBC:  MOV     [W0],W6
05FBE:  MOV     W6,W4
05FC0:  MUL.UU  W4,#10,W6
05FC2:  ADD     W6,#C,W6
05FC4:  MOV     W6,W0
05FC6:  MOV     #B46,W4
05FC8:  ADD     W0,W4,W0
05FCA:  MOV     [W0++],[W5++]
05FCC:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
05FCE:  MOV     #1,W4
05FD0:  MOV     W4,A8C
.................... 		                } 
05FD2:  GOTO    6024
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
05FD6:  MOV     A8E,W4
05FD8:  MUL.UU  W4,#8,W0
05FDA:  MOV     W0,W5
05FDC:  MOV     #AA6,W4
05FDE:  ADD     W5,W4,W6
05FE0:  MOV     1B70,W4
05FE2:  MUL.UU  W4,#2,W0
05FE4:  MOV     #A92,W4
05FE6:  ADD     W0,W4,W0
05FE8:  MOV     [W0],W7
05FEA:  MOV     W7,W4
05FEC:  MUL.UU  W4,#10,W0
05FEE:  MOV     W0,W7
05FF0:  MOV     #B46,W4
05FF2:  ADD     W7,W4,W0
05FF4:  MOV     [W0++],[W6++]
05FF6:  MOV     [W0++],[W6++]
05FF8:  MOV     A8E,W4
05FFA:  MUL.UU  W4,#8,W0
05FFC:  MOV     W0,W5
05FFE:  ADD     W5,#4,W5
06000:  MOV     W5,W0
06002:  MOV     #AA6,W4
06004:  ADD     W0,W4,W5
06006:  MOV     1B70,W4
06008:  MUL.UU  W4,#2,W0
0600A:  MOV     #A92,W4
0600C:  ADD     W0,W4,W0
0600E:  MOV     [W0],W6
06010:  MOV     W6,W4
06012:  MUL.UU  W4,#10,W6
06014:  ADD     W6,#4,W6
06016:  MOV     W6,W0
06018:  MOV     #B46,W4
0601A:  ADD     W0,W4,W0
0601C:  MOV     [W0++],[W5++]
0601E:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
06020:  MOV     #1,W4
06022:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
06024:  MOV     #1,W4
06026:  MOV     W4,A84
.................... 		            } 
06028:  GOTO    60E6
.................... 		            else if (posEnd == 1) 
0602C:  MOV     1B74,W4
0602E:  CP      W4,#1
06030:  BRA     NZ,60E6
.................... 		            { 
.................... 						PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
06032:  MOV     A8E,W4
06034:  MUL.UU  W4,#8,W0
06036:  MOV     W0,W5
06038:  MOV     #AA6,W4
0603A:  ADD     W5,W4,W6
0603C:  MOV     1B70,W4
0603E:  MUL.UU  W4,#2,W0
06040:  MOV     #A92,W4
06042:  ADD     W0,W4,W0
06044:  MOV     [W0],W7
06046:  MOV     W7,W4
06048:  MUL.UU  W4,#10,W0
0604A:  MOV     W0,W7
0604C:  ADD     W7,#8,W7
0604E:  MOV     W7,W0
06050:  MOV     #B46,W4
06052:  ADD     W0,W4,W0
06054:  MOV     [W0++],[W6++]
06056:  MOV     [W0++],[W6++]
06058:  MOV     A8E,W4
0605A:  MUL.UU  W4,#8,W0
0605C:  MOV     W0,W5
0605E:  ADD     W5,#4,W5
06060:  MOV     W5,W0
06062:  MOV     #AA6,W4
06064:  ADD     W0,W4,W5
06066:  MOV     1B70,W4
06068:  MUL.UU  W4,#2,W0
0606A:  MOV     #A92,W4
0606C:  ADD     W0,W4,W0
0606E:  MOV     [W0],W6
06070:  MOV     W6,W4
06072:  MUL.UU  W4,#10,W6
06074:  ADD     W6,#C,W6
06076:  MOV     W6,W0
06078:  MOV     #B46,W4
0607A:  ADD     W0,W4,W0
0607C:  MOV     [W0++],[W5++]
0607E:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
06080:  MOV     A8E,W4
06082:  ADD     W4,#1,W4
06084:  MOV     W4,W5
06086:  MOV     W5,W4
06088:  MUL.UU  W4,#8,W0
0608A:  MOV     W0,W5
0608C:  MOV     #AA6,W4
0608E:  ADD     W5,W4,W6
06090:  MOV     1B70,W4
06092:  MUL.UU  W4,#2,W0
06094:  MOV     #A92,W4
06096:  ADD     W0,W4,W0
06098:  MOV     [W0],W7
0609A:  MOV     W7,W4
0609C:  MUL.UU  W4,#10,W0
0609E:  MOV     W0,W7
060A0:  MOV     1B2E,W4
060A2:  MUL.UU  W4,#4,W0
060A4:  ADD     W0,W7,W0
060A6:  MOV     #B46,W4
060A8:  ADD     W0,W4,W0
060AA:  MOV     [W0++],[W6++]
060AC:  MOV     [W0++],[W6++]
060AE:  MOV     A8E,W4
060B0:  ADD     W4,#1,W4
060B2:  MOV     W4,W5
060B4:  MOV     W5,W4
060B6:  MUL.UU  W4,#8,W0
060B8:  MOV     W0,W5
060BA:  ADD     W5,#4,W5
060BC:  MOV     W5,W0
060BE:  MOV     #AA6,W4
060C0:  ADD     W0,W4,W5
060C2:  MOV     1B70,W4
060C4:  MUL.UU  W4,#2,W0
060C6:  MOV     #A92,W4
060C8:  ADD     W0,W4,W0
060CA:  MOV     [W0],W6
060CC:  MOV     W6,W4
060CE:  MUL.UU  W4,#10,W6
060D0:  MOV     1B30,W4
060D2:  MUL.UU  W4,#4,W0
060D4:  ADD     W0,W6,W0
060D6:  MOV     #B46,W4
060D8:  ADD     W0,W4,W0
060DA:  MOV     [W0++],[W5++]
060DC:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
060DE:  MOV     #2,W4
060E0:  MOV     W4,A8C
.................... 		                path_found = true; 
060E2:  MOV     #1,W4
060E4:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
060E6:  GOTO    6364
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 3) 
060EA:  MOV     1B74,W4
060EC:  CP      W4,#3
060EE:  BRA     NZ,614A
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
060F0:  MOV     A8E,W4
060F2:  MUL.UU  W4,#8,W0
060F4:  MOV     W0,W5
060F6:  MOV     #AA6,W4
060F8:  ADD     W5,W4,W6
060FA:  MOV     1B70,W4
060FC:  MUL.UU  W4,#2,W0
060FE:  MOV     #A92,W4
06100:  ADD     W0,W4,W0
06102:  MOV     [W0],W7
06104:  MOV     W7,W4
06106:  MUL.UU  W4,#10,W0
06108:  MOV     W0,W7
0610A:  ADD     W7,#8,W7
0610C:  MOV     W7,W0
0610E:  MOV     #B46,W4
06110:  ADD     W0,W4,W0
06112:  MOV     [W0++],[W6++]
06114:  MOV     [W0++],[W6++]
06116:  MOV     A8E,W4
06118:  MUL.UU  W4,#8,W0
0611A:  MOV     W0,W5
0611C:  ADD     W5,#4,W5
0611E:  MOV     W5,W0
06120:  MOV     #AA6,W4
06122:  ADD     W0,W4,W5
06124:  MOV     1B70,W4
06126:  MUL.UU  W4,#2,W0
06128:  MOV     #A92,W4
0612A:  ADD     W0,W4,W0
0612C:  MOV     [W0],W6
0612E:  MOV     W6,W4
06130:  MUL.UU  W4,#10,W6
06132:  ADD     W6,#C,W6
06134:  MOV     W6,W0
06136:  MOV     #B46,W4
06138:  ADD     W0,W4,W0
0613A:  MOV     [W0++],[W5++]
0613C:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0613E:  MOV     #1,W4
06140:  MOV     W4,A8C
.................... 		                path_found = true; 
06142:  MOV     #1,W4
06144:  MOV     W4,A84
.................... 		            } 
06146:  GOTO    6364
.................... 		            else if (posEnd == 2) 
0614A:  MOV     1B74,W4
0614C:  CP      W4,#2
0614E:  BRA     NZ,630C
.................... 		            { 
.................... 		                if ((getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1], xEnd, yEnd)) < (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd))) 
06150:  MOV     1B70,W4
06152:  MUL.UU  W4,#2,W0
06154:  MOV     #A92,W4
06156:  ADD     W0,W4,W0
06158:  MOV     [W0],W5
0615A:  MOV     W5,W4
0615C:  MUL.UU  W4,#10,W0
0615E:  MOV     W0,W5
06160:  MOV     #B46,W4
06162:  ADD     W5,W4,W0
06164:  MOV     [W0],W6
06166:  MOV     1B70,W4
06168:  MUL.UU  W4,#2,W0
0616A:  MOV     #A92,W4
0616C:  ADD     W0,W4,W0
0616E:  MOV     [W0],W7
06170:  MOV     W7,W4
06172:  MUL.UU  W4,#10,W0
06174:  MOV     W0,W7
06176:  ADD     W7,#4,W7
06178:  MOV     W7,W0
0617A:  MOV     #B46,W4
0617C:  ADD     W0,W4,W0
0617E:  MOV     [W0],W7
06180:  PUSH    1B68
06182:  POP     1B8C
06184:  PUSH    1B6A
06186:  POP     1B8E
06188:  MOV     W6,1B90
0618A:  MOV     W7,1B92
0618C:  CALL    2DB6
06190:  MOV     W0,W6
06192:  MOV     1B70,W4
06194:  MUL.UU  W4,#2,W0
06196:  MOV     #A92,W4
06198:  ADD     W0,W4,W0
0619A:  MOV     [W0],W7
0619C:  MOV     W7,W4
0619E:  MUL.UU  W4,#10,W0
061A0:  MOV     W0,W7
061A2:  MOV     #B46,W4
061A4:  ADD     W7,W4,W0
061A6:  MOV     [W0],W8
061A8:  MOV     1B70,W4
061AA:  MUL.UU  W4,#2,W0
061AC:  MOV     #A92,W4
061AE:  ADD     W0,W4,W0
061B0:  MOV     [W0],W9
061B2:  MOV     W9,W4
061B4:  MUL.UU  W4,#10,W0
061B6:  MOV     W0,W9
061B8:  ADD     W9,#4,W9
061BA:  MOV     W9,W0
061BC:  MOV     #B46,W4
061BE:  ADD     W0,W4,W0
061C0:  MOV     [W0],W9
061C2:  MOV     W8,1B8C
061C4:  MOV     W9,1B8E
061C6:  PUSH    1B6C
061C8:  POP     1B90
061CA:  PUSH    1B6E
061CC:  POP     1B92
061CE:  CALL    2DB6
061D2:  ADD     W0,W6,W6
061D4:  MOV     1B70,W4
061D6:  MUL.UU  W4,#2,W0
061D8:  MOV     #A92,W4
061DA:  ADD     W0,W4,W0
061DC:  MOV     [W0],W8
061DE:  MOV     W8,W4
061E0:  MUL.UU  W4,#10,W8
061E2:  ADD     W8,#8,W8
061E4:  MOV     W8,W0
061E6:  MOV     #B46,W4
061E8:  ADD     W0,W4,W0
061EA:  MOV     [W0],W8
061EC:  MOV     1B70,W4
061EE:  MUL.UU  W4,#2,W0
061F0:  MOV     #A92,W4
061F2:  ADD     W0,W4,W0
061F4:  MOV     [W0],W9
061F6:  MOV     W9,W4
061F8:  MUL.UU  W4,#10,W0
061FA:  MOV     W0,W9
061FC:  ADD     W9,#C,W9
061FE:  MOV     W9,W0
06200:  MOV     #B46,W4
06202:  ADD     W0,W4,W0
06204:  MOV     [W0],W9
06206:  PUSH    1B68
06208:  POP     1B8C
0620A:  PUSH    1B6A
0620C:  POP     1B8E
0620E:  MOV     W8,1B90
06210:  MOV     W9,1B92
06212:  CALL    2DB6
06216:  MOV     W0,W8
06218:  MOV     1B70,W4
0621A:  MUL.UU  W4,#2,W0
0621C:  MOV     #A92,W4
0621E:  ADD     W0,W4,W0
06220:  MOV     [W0],W9
06222:  MOV     W9,W4
06224:  MUL.UU  W4,#10,W0
06226:  MOV     W0,W9
06228:  ADD     W9,#8,W9
0622A:  MOV     W9,W0
0622C:  MOV     #B46,W4
0622E:  ADD     W0,W4,W0
06230:  MOV     [W0],W9
06232:  MOV     1B70,W4
06234:  MUL.UU  W4,#2,W0
06236:  MOV     #A92,W4
06238:  ADD     W0,W4,W0
0623A:  MOV     [W0],W10
0623C:  MOV     W10,W4
0623E:  MUL.UU  W4,#10,W10
06240:  ADD     W10,#C,W10
06242:  MOV     W10,W0
06244:  MOV     #B46,W4
06246:  ADD     W0,W4,W0
06248:  MOV     [W0],W10
0624A:  MOV     W9,1B8C
0624C:  MOV     W10,1B8E
0624E:  PUSH    1B6C
06250:  POP     1B90
06252:  PUSH    1B6E
06254:  POP     1B92
06256:  CALL    2DB6
0625A:  ADD     W0,W8,W0
0625C:  CP      W6,W0
0625E:  BRA     GE,62B2
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06260:  MOV     A8E,W4
06262:  MUL.UU  W4,#8,W0
06264:  MOV     W0,W5
06266:  MOV     #AA6,W4
06268:  ADD     W5,W4,W6
0626A:  MOV     1B70,W4
0626C:  MUL.UU  W4,#2,W0
0626E:  MOV     #A92,W4
06270:  ADD     W0,W4,W0
06272:  MOV     [W0],W7
06274:  MOV     W7,W4
06276:  MUL.UU  W4,#10,W0
06278:  MOV     W0,W7
0627A:  MOV     #B46,W4
0627C:  ADD     W7,W4,W0
0627E:  MOV     [W0++],[W6++]
06280:  MOV     [W0++],[W6++]
06282:  MOV     A8E,W4
06284:  MUL.UU  W4,#8,W0
06286:  MOV     W0,W5
06288:  ADD     W5,#4,W5
0628A:  MOV     W5,W0
0628C:  MOV     #AA6,W4
0628E:  ADD     W0,W4,W5
06290:  MOV     1B70,W4
06292:  MUL.UU  W4,#2,W0
06294:  MOV     #A92,W4
06296:  ADD     W0,W4,W0
06298:  MOV     [W0],W6
0629A:  MOV     W6,W4
0629C:  MUL.UU  W4,#10,W6
0629E:  ADD     W6,#4,W6
062A0:  MOV     W6,W0
062A2:  MOV     #B46,W4
062A4:  ADD     W0,W4,W0
062A6:  MOV     [W0++],[W5++]
062A8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
062AA:  MOV     #1,W4
062AC:  MOV     W4,A8C
.................... 		                } 
062AE:  GOTO    6304
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y4]; 
062B2:  MOV     A8E,W4
062B4:  MUL.UU  W4,#8,W0
062B6:  MOV     W0,W5
062B8:  MOV     #AA6,W4
062BA:  ADD     W5,W4,W6
062BC:  MOV     1B70,W4
062BE:  MUL.UU  W4,#2,W0
062C0:  MOV     #A92,W4
062C2:  ADD     W0,W4,W0
062C4:  MOV     [W0],W7
062C6:  MOV     W7,W4
062C8:  MUL.UU  W4,#10,W0
062CA:  MOV     W0,W7
062CC:  ADD     W7,#8,W7
062CE:  MOV     W7,W0
062D0:  MOV     #B46,W4
062D2:  ADD     W0,W4,W0
062D4:  MOV     [W0++],[W6++]
062D6:  MOV     [W0++],[W6++]
062D8:  MOV     A8E,W4
062DA:  MUL.UU  W4,#8,W0
062DC:  MOV     W0,W5
062DE:  ADD     W5,#4,W5
062E0:  MOV     W5,W0
062E2:  MOV     #AA6,W4
062E4:  ADD     W0,W4,W5
062E6:  MOV     1B70,W4
062E8:  MUL.UU  W4,#2,W0
062EA:  MOV     #A92,W4
062EC:  ADD     W0,W4,W0
062EE:  MOV     [W0],W6
062F0:  MOV     W6,W4
062F2:  MUL.UU  W4,#10,W6
062F4:  ADD     W6,#C,W6
062F6:  MOV     W6,W0
062F8:  MOV     #B46,W4
062FA:  ADD     W0,W4,W0
062FC:  MOV     [W0++],[W5++]
062FE:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 1; 
06300:  MOV     #1,W4
06302:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
06304:  MOV     #1,W4
06306:  MOV     W4,A84
.................... 		            } 
06308:  GOTO    6364
.................... 		            else if (posEnd == 1) 
0630C:  MOV     1B74,W4
0630E:  CP      W4,#1
06310:  BRA     NZ,6364
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06312:  MOV     A8E,W4
06314:  MUL.UU  W4,#8,W0
06316:  MOV     W0,W5
06318:  MOV     #AA6,W4
0631A:  ADD     W5,W4,W6
0631C:  MOV     1B70,W4
0631E:  MUL.UU  W4,#2,W0
06320:  MOV     #A92,W4
06322:  ADD     W0,W4,W0
06324:  MOV     [W0],W7
06326:  MOV     W7,W4
06328:  MUL.UU  W4,#10,W0
0632A:  MOV     W0,W7
0632C:  MOV     #B46,W4
0632E:  ADD     W7,W4,W0
06330:  MOV     [W0++],[W6++]
06332:  MOV     [W0++],[W6++]
06334:  MOV     A8E,W4
06336:  MUL.UU  W4,#8,W0
06338:  MOV     W0,W5
0633A:  ADD     W5,#4,W5
0633C:  MOV     W5,W0
0633E:  MOV     #AA6,W4
06340:  ADD     W0,W4,W5
06342:  MOV     1B70,W4
06344:  MUL.UU  W4,#2,W0
06346:  MOV     #A92,W4
06348:  ADD     W0,W4,W0
0634A:  MOV     [W0],W6
0634C:  MOV     W6,W4
0634E:  MUL.UU  W4,#10,W6
06350:  ADD     W6,#4,W6
06352:  MOV     W6,W0
06354:  MOV     #B46,W4
06356:  ADD     W0,W4,W0
06358:  MOV     [W0++],[W5++]
0635A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
0635C:  MOV     #1,W4
0635E:  MOV     W4,A8C
.................... 		                path_found = true; 
06360:  MOV     #1,W4
06362:  MOV     W4,A84
.................... 		            } 
.................... 	            } 
.................... 	            break; 
06364:  GOTO    6CF8
....................  
.................... 	        case 7: 
....................  
.................... 	        	if(path_opposite) 
06368:  CP0     A88
0636A:  BRA     Z,6998
.................... 	        	{ 
.................... 	        		if (posEnd == 5) 
0636C:  MOV     1B74,W4
0636E:  CP      W4,#5
06370:  BRA     NZ,647C
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06372:  MOV     A8E,W4
06374:  MUL.UU  W4,#8,W0
06376:  MOV     W0,W5
06378:  MOV     #AA6,W4
0637A:  ADD     W5,W4,W6
0637C:  MOV     1B70,W4
0637E:  MUL.UU  W4,#2,W0
06380:  MOV     #A92,W4
06382:  ADD     W0,W4,W0
06384:  MOV     [W0],W7
06386:  MOV     W7,W4
06388:  MUL.UU  W4,#10,W0
0638A:  MOV     W0,W7
0638C:  MOV     #B46,W4
0638E:  ADD     W7,W4,W0
06390:  MOV     [W0++],[W6++]
06392:  MOV     [W0++],[W6++]
06394:  MOV     A8E,W4
06396:  MUL.UU  W4,#8,W0
06398:  MOV     W0,W5
0639A:  ADD     W5,#4,W5
0639C:  MOV     W5,W0
0639E:  MOV     #AA6,W4
063A0:  ADD     W0,W4,W5
063A2:  MOV     1B70,W4
063A4:  MUL.UU  W4,#2,W0
063A6:  MOV     #A92,W4
063A8:  ADD     W0,W4,W0
063AA:  MOV     [W0],W6
063AC:  MOV     W6,W4
063AE:  MUL.UU  W4,#10,W6
063B0:  ADD     W6,#4,W6
063B2:  MOV     W6,W0
063B4:  MOV     #B46,W4
063B6:  ADD     W0,W4,W0
063B8:  MOV     [W0++],[W5++]
063BA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
063BC:  MOV     A8E,W4
063BE:  ADD     W4,#1,W4
063C0:  MOV     W4,W5
063C2:  MOV     W5,W4
063C4:  MUL.UU  W4,#8,W0
063C6:  MOV     W0,W5
063C8:  MOV     #AA6,W4
063CA:  ADD     W5,W4,W6
063CC:  MOV     1B70,W4
063CE:  MUL.UU  W4,#2,W0
063D0:  MOV     #A92,W4
063D2:  ADD     W0,W4,W0
063D4:  MOV     [W0],W7
063D6:  MOV     W7,W4
063D8:  MUL.UU  W4,#10,W0
063DA:  MOV     W0,W7
063DC:  MOV     1B2E,W4
063DE:  MUL.UU  W4,#4,W0
063E0:  ADD     W0,W7,W0
063E2:  MOV     #B46,W4
063E4:  ADD     W0,W4,W0
063E6:  MOV     [W0++],[W6++]
063E8:  MOV     [W0++],[W6++]
063EA:  MOV     A8E,W4
063EC:  ADD     W4,#1,W4
063EE:  MOV     W4,W5
063F0:  MOV     W5,W4
063F2:  MUL.UU  W4,#8,W0
063F4:  MOV     W0,W5
063F6:  ADD     W5,#4,W5
063F8:  MOV     W5,W0
063FA:  MOV     #AA6,W4
063FC:  ADD     W0,W4,W5
063FE:  MOV     1B70,W4
06400:  MUL.UU  W4,#2,W0
06402:  MOV     #A92,W4
06404:  ADD     W0,W4,W0
06406:  MOV     [W0],W6
06408:  MOV     W6,W4
0640A:  MUL.UU  W4,#10,W6
0640C:  MOV     1B30,W4
0640E:  MUL.UU  W4,#4,W0
06410:  ADD     W0,W6,W0
06412:  MOV     #B46,W4
06414:  ADD     W0,W4,W0
06416:  MOV     [W0++],[W5++]
06418:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y4]; 
0641A:  MOV     A8E,W4
0641C:  ADD     W4,#2,W4
0641E:  MOV     W4,W5
06420:  MOV     W5,W4
06422:  MUL.UU  W4,#8,W0
06424:  MOV     W0,W5
06426:  MOV     #AA6,W4
06428:  ADD     W5,W4,W6
0642A:  MOV     1B70,W4
0642C:  MUL.UU  W4,#2,W0
0642E:  MOV     #A92,W4
06430:  ADD     W0,W4,W0
06432:  MOV     [W0],W7
06434:  MOV     W7,W4
06436:  MUL.UU  W4,#10,W0
06438:  MOV     W0,W7
0643A:  ADD     W7,#8,W7
0643C:  MOV     W7,W0
0643E:  MOV     #B46,W4
06440:  ADD     W0,W4,W0
06442:  MOV     [W0++],[W6++]
06444:  MOV     [W0++],[W6++]
06446:  MOV     A8E,W4
06448:  ADD     W4,#2,W4
0644A:  MOV     W4,W5
0644C:  MOV     W5,W4
0644E:  MUL.UU  W4,#8,W0
06450:  MOV     W0,W5
06452:  ADD     W5,#4,W5
06454:  MOV     W5,W0
06456:  MOV     #AA6,W4
06458:  ADD     W0,W4,W5
0645A:  MOV     1B70,W4
0645C:  MUL.UU  W4,#2,W0
0645E:  MOV     #A92,W4
06460:  ADD     W0,W4,W0
06462:  MOV     [W0],W6
06464:  MOV     W6,W4
06466:  MUL.UU  W4,#10,W6
06468:  ADD     W6,#C,W6
0646A:  MOV     W6,W0
0646C:  MOV     #B46,W4
0646E:  ADD     W0,W4,W0
06470:  MOV     [W0++],[W5++]
06472:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
06474:  MOV     #3,W4
06476:  MOV     W4,A8C
.................... 		                path_found = true; 
06478:  MOV     #1,W4
0647A:  MOV     W4,A84
.................... 		            } 
.................... 		            if (posEnd == 4) 
0647C:  MOV     1B74,W4
0647E:  CP      W4,#4
06480:  BRA     NZ,6536
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06482:  MOV     A8E,W4
06484:  MUL.UU  W4,#8,W0
06486:  MOV     W0,W5
06488:  MOV     #AA6,W4
0648A:  ADD     W5,W4,W6
0648C:  MOV     1B70,W4
0648E:  MUL.UU  W4,#2,W0
06490:  MOV     #A92,W4
06492:  ADD     W0,W4,W0
06494:  MOV     [W0],W7
06496:  MOV     W7,W4
06498:  MUL.UU  W4,#10,W0
0649A:  MOV     W0,W7
0649C:  MOV     #B46,W4
0649E:  ADD     W7,W4,W0
064A0:  MOV     [W0++],[W6++]
064A2:  MOV     [W0++],[W6++]
064A4:  MOV     A8E,W4
064A6:  MUL.UU  W4,#8,W0
064A8:  MOV     W0,W5
064AA:  ADD     W5,#4,W5
064AC:  MOV     W5,W0
064AE:  MOV     #AA6,W4
064B0:  ADD     W0,W4,W5
064B2:  MOV     1B70,W4
064B4:  MUL.UU  W4,#2,W0
064B6:  MOV     #A92,W4
064B8:  ADD     W0,W4,W0
064BA:  MOV     [W0],W6
064BC:  MOV     W6,W4
064BE:  MUL.UU  W4,#10,W6
064C0:  ADD     W6,#4,W6
064C2:  MOV     W6,W0
064C4:  MOV     #B46,W4
064C6:  ADD     W0,W4,W0
064C8:  MOV     [W0++],[W5++]
064CA:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
064CC:  MOV     A8E,W4
064CE:  ADD     W4,#1,W4
064D0:  MOV     W4,W5
064D2:  MOV     W5,W4
064D4:  MUL.UU  W4,#8,W0
064D6:  MOV     W0,W5
064D8:  MOV     #AA6,W4
064DA:  ADD     W5,W4,W6
064DC:  MOV     1B70,W4
064DE:  MUL.UU  W4,#2,W0
064E0:  MOV     #A92,W4
064E2:  ADD     W0,W4,W0
064E4:  MOV     [W0],W7
064E6:  MOV     W7,W4
064E8:  MUL.UU  W4,#10,W0
064EA:  MOV     W0,W7
064EC:  MOV     1B2E,W4
064EE:  MUL.UU  W4,#4,W0
064F0:  ADD     W0,W7,W0
064F2:  MOV     #B46,W4
064F4:  ADD     W0,W4,W0
064F6:  MOV     [W0++],[W6++]
064F8:  MOV     [W0++],[W6++]
064FA:  MOV     A8E,W4
064FC:  ADD     W4,#1,W4
064FE:  MOV     W4,W5
06500:  MOV     W5,W4
06502:  MUL.UU  W4,#8,W0
06504:  MOV     W0,W5
06506:  ADD     W5,#4,W5
06508:  MOV     W5,W0
0650A:  MOV     #AA6,W4
0650C:  ADD     W0,W4,W5
0650E:  MOV     1B70,W4
06510:  MUL.UU  W4,#2,W0
06512:  MOV     #A92,W4
06514:  ADD     W0,W4,W0
06516:  MOV     [W0],W6
06518:  MOV     W6,W4
0651A:  MUL.UU  W4,#10,W6
0651C:  MOV     1B30,W4
0651E:  MUL.UU  W4,#4,W0
06520:  ADD     W0,W6,W0
06522:  MOV     #B46,W4
06524:  ADD     W0,W4,W0
06526:  MOV     [W0++],[W5++]
06528:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
0652A:  MOV     #2,W4
0652C:  MOV     W4,A8C
.................... 		                path_found = true; 
0652E:  MOV     #1,W4
06530:  MOV     W4,A84
.................... 		            } 
06532:  GOTO    6994
.................... 		            else if (posEnd == 3) 
06536:  MOV     1B74,W4
06538:  CP      W4,#3
0653A:  BRA     NZ,67BE
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
0653C:  MOV     1B70,W4
0653E:  MUL.UU  W4,#2,W0
06540:  MOV     #A92,W4
06542:  ADD     W0,W4,W0
06544:  MOV     [W0],W5
06546:  MOV     W5,W4
06548:  MUL.UU  W4,#10,W0
0654A:  MOV     W0,W5
0654C:  MOV     #B46,W4
0654E:  ADD     W5,W4,W0
06550:  MOV     [W0],W6
06552:  MOV     1B70,W4
06554:  MUL.UU  W4,#2,W0
06556:  MOV     #A92,W4
06558:  ADD     W0,W4,W0
0655A:  MOV     [W0],W7
0655C:  MOV     W7,W4
0655E:  MUL.UU  W4,#10,W0
06560:  MOV     W0,W7
06562:  ADD     W7,#4,W7
06564:  MOV     W7,W0
06566:  MOV     #B46,W4
06568:  ADD     W0,W4,W0
0656A:  MOV     [W0],W7
0656C:  PUSH    1B68
0656E:  POP     1B8C
06570:  PUSH    1B6A
06572:  POP     1B8E
06574:  MOV     W6,1B90
06576:  MOV     W7,1B92
06578:  CALL    2DB6
0657C:  MOV     W0,W6
0657E:  MOV     1B70,W4
06580:  MUL.UU  W4,#2,W0
06582:  MOV     #A92,W4
06584:  ADD     W0,W4,W0
06586:  MOV     [W0],W7
06588:  MOV     W7,W4
0658A:  MUL.UU  W4,#10,W0
0658C:  MOV     W0,W7
0658E:  MOV     1B2E,W4
06590:  MUL.UU  W4,#4,W0
06592:  ADD     W0,W7,W0
06594:  MOV     #B46,W4
06596:  ADD     W0,W4,W0
06598:  MOV     [W0],W7
0659A:  MOV     1B70,W4
0659C:  MUL.UU  W4,#2,W0
0659E:  MOV     #A92,W4
065A0:  ADD     W0,W4,W0
065A2:  MOV     [W0],W8
065A4:  MOV     W8,W4
065A6:  MUL.UU  W4,#10,W8
065A8:  MOV     1B30,W4
065AA:  MUL.UU  W4,#4,W0
065AC:  ADD     W0,W8,W0
065AE:  MOV     #B46,W4
065B0:  ADD     W0,W4,W0
065B2:  MOV     [W0],W8
065B4:  MOV     W7,1B8C
065B6:  MOV     W8,1B8E
065B8:  PUSH    1B6C
065BA:  POP     1B90
065BC:  PUSH    1B6E
065BE:  POP     1B92
065C0:  CALL    2DB6
065C4:  ADD     W0,W6,W6
065C6:  MOV     1B70,W4
065C8:  MUL.UU  W4,#2,W0
065CA:  MOV     #A92,W4
065CC:  ADD     W0,W4,W0
065CE:  MOV     [W0],W7
065D0:  MOV     W7,W4
065D2:  MUL.UU  W4,#10,W0
065D4:  MOV     W0,W7
065D6:  MOV     1B2A,W4
065D8:  MUL.UU  W4,#4,W0
065DA:  ADD     W0,W7,W0
065DC:  MOV     #B46,W4
065DE:  ADD     W0,W4,W0
065E0:  MOV     [W0],W7
065E2:  MOV     1B70,W4
065E4:  MUL.UU  W4,#2,W0
065E6:  MOV     #A92,W4
065E8:  ADD     W0,W4,W0
065EA:  MOV     [W0],W8
065EC:  MOV     W8,W4
065EE:  MUL.UU  W4,#10,W8
065F0:  MOV     1B2C,W4
065F2:  MUL.UU  W4,#4,W0
065F4:  ADD     W0,W8,W0
065F6:  MOV     #B46,W4
065F8:  ADD     W0,W4,W0
065FA:  MOV     [W0],W8
065FC:  PUSH    1B68
065FE:  POP     1B8C
06600:  PUSH    1B6A
06602:  POP     1B8E
06604:  MOV     W7,1B90
06606:  MOV     W8,1B92
06608:  CALL    2DB6
0660C:  MOV     W0,W7
0660E:  MOV     1B70,W4
06610:  MUL.UU  W4,#2,W0
06612:  MOV     #A92,W4
06614:  ADD     W0,W4,W0
06616:  MOV     [W0],W8
06618:  MOV     W8,W4
0661A:  MUL.UU  W4,#10,W8
0661C:  ADD     W8,#8,W8
0661E:  MOV     W8,W0
06620:  MOV     #B46,W4
06622:  ADD     W0,W4,W0
06624:  MOV     [W0],W8
06626:  MOV     1B70,W4
06628:  MUL.UU  W4,#2,W0
0662A:  MOV     #A92,W4
0662C:  ADD     W0,W4,W0
0662E:  MOV     [W0],W9
06630:  MOV     W9,W4
06632:  MUL.UU  W4,#10,W0
06634:  MOV     W0,W9
06636:  ADD     W9,#C,W9
06638:  MOV     W9,W0
0663A:  MOV     #B46,W4
0663C:  ADD     W0,W4,W0
0663E:  MOV     [W0],W9
06640:  MOV     W8,1B8C
06642:  MOV     W9,1B8E
06644:  PUSH    1B6C
06646:  POP     1B90
06648:  PUSH    1B6E
0664A:  POP     1B92
0664C:  CALL    2DB6
06650:  ADD     W0,W7,W0
06652:  CP      W6,W0
06654:  BRA     GE,670A
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
06656:  MOV     A8E,W4
06658:  MUL.UU  W4,#8,W0
0665A:  MOV     W0,W5
0665C:  MOV     #AA6,W4
0665E:  ADD     W5,W4,W6
06660:  MOV     1B70,W4
06662:  MUL.UU  W4,#2,W0
06664:  MOV     #A92,W4
06666:  ADD     W0,W4,W0
06668:  MOV     [W0],W7
0666A:  MOV     W7,W4
0666C:  MUL.UU  W4,#10,W0
0666E:  MOV     W0,W7
06670:  MOV     1B2A,W4
06672:  MUL.UU  W4,#4,W0
06674:  ADD     W0,W7,W0
06676:  MOV     #B46,W4
06678:  ADD     W0,W4,W0
0667A:  MOV     [W0++],[W6++]
0667C:  MOV     [W0++],[W6++]
0667E:  MOV     A8E,W4
06680:  MUL.UU  W4,#8,W0
06682:  MOV     W0,W5
06684:  ADD     W5,#4,W5
06686:  MOV     W5,W0
06688:  MOV     #AA6,W4
0668A:  ADD     W0,W4,W5
0668C:  MOV     1B70,W4
0668E:  MUL.UU  W4,#2,W0
06690:  MOV     #A92,W4
06692:  ADD     W0,W4,W0
06694:  MOV     [W0],W6
06696:  MOV     W6,W4
06698:  MUL.UU  W4,#10,W6
0669A:  MOV     1B2C,W4
0669C:  MUL.UU  W4,#4,W0
0669E:  ADD     W0,W6,W0
066A0:  MOV     #B46,W4
066A2:  ADD     W0,W4,W0
066A4:  MOV     [W0++],[W5++]
066A6:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
066A8:  MOV     A8E,W4
066AA:  ADD     W4,#1,W4
066AC:  MOV     W4,W5
066AE:  MOV     W5,W4
066B0:  MUL.UU  W4,#8,W0
066B2:  MOV     W0,W5
066B4:  MOV     #AA6,W4
066B6:  ADD     W5,W4,W6
066B8:  MOV     1B70,W4
066BA:  MUL.UU  W4,#2,W0
066BC:  MOV     #A92,W4
066BE:  ADD     W0,W4,W0
066C0:  MOV     [W0],W7
066C2:  MOV     W7,W4
066C4:  MUL.UU  W4,#10,W0
066C6:  MOV     W0,W7
066C8:  ADD     W7,#8,W7
066CA:  MOV     W7,W0
066CC:  MOV     #B46,W4
066CE:  ADD     W0,W4,W0
066D0:  MOV     [W0++],[W6++]
066D2:  MOV     [W0++],[W6++]
066D4:  MOV     A8E,W4
066D6:  ADD     W4,#1,W4
066D8:  MOV     W4,W5
066DA:  MOV     W5,W4
066DC:  MUL.UU  W4,#8,W0
066DE:  MOV     W0,W5
066E0:  ADD     W5,#4,W5
066E2:  MOV     W5,W0
066E4:  MOV     #AA6,W4
066E6:  ADD     W0,W4,W5
066E8:  MOV     1B70,W4
066EA:  MUL.UU  W4,#2,W0
066EC:  MOV     #A92,W4
066EE:  ADD     W0,W4,W0
066F0:  MOV     [W0],W6
066F2:  MOV     W6,W4
066F4:  MUL.UU  W4,#10,W6
066F6:  ADD     W6,#C,W6
066F8:  MOV     W6,W0
066FA:  MOV     #B46,W4
066FC:  ADD     W0,W4,W0
066FE:  MOV     [W0++],[W5++]
06700:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
06702:  MOV     #2,W4
06704:  MOV     W4,A8C
.................... 		                } 
06706:  GOTO    67B6
.................... 		                else 
.................... 		                { 
.................... 		                	PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
0670A:  MOV     A8E,W4
0670C:  MUL.UU  W4,#8,W0
0670E:  MOV     W0,W5
06710:  MOV     #AA6,W4
06712:  ADD     W5,W4,W6
06714:  MOV     1B70,W4
06716:  MUL.UU  W4,#2,W0
06718:  MOV     #A92,W4
0671A:  ADD     W0,W4,W0
0671C:  MOV     [W0],W7
0671E:  MOV     W7,W4
06720:  MUL.UU  W4,#10,W0
06722:  MOV     W0,W7
06724:  MOV     #B46,W4
06726:  ADD     W7,W4,W0
06728:  MOV     [W0++],[W6++]
0672A:  MOV     [W0++],[W6++]
0672C:  MOV     A8E,W4
0672E:  MUL.UU  W4,#8,W0
06730:  MOV     W0,W5
06732:  ADD     W5,#4,W5
06734:  MOV     W5,W0
06736:  MOV     #AA6,W4
06738:  ADD     W0,W4,W5
0673A:  MOV     1B70,W4
0673C:  MUL.UU  W4,#2,W0
0673E:  MOV     #A92,W4
06740:  ADD     W0,W4,W0
06742:  MOV     [W0],W6
06744:  MOV     W6,W4
06746:  MUL.UU  W4,#10,W6
06748:  ADD     W6,#4,W6
0674A:  MOV     W6,W0
0674C:  MOV     #B46,W4
0674E:  ADD     W0,W4,W0
06750:  MOV     [W0++],[W5++]
06752:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
06754:  MOV     A8E,W4
06756:  ADD     W4,#1,W4
06758:  MOV     W4,W5
0675A:  MOV     W5,W4
0675C:  MUL.UU  W4,#8,W0
0675E:  MOV     W0,W5
06760:  MOV     #AA6,W4
06762:  ADD     W5,W4,W6
06764:  MOV     1B70,W4
06766:  MUL.UU  W4,#2,W0
06768:  MOV     #A92,W4
0676A:  ADD     W0,W4,W0
0676C:  MOV     [W0],W7
0676E:  MOV     W7,W4
06770:  MUL.UU  W4,#10,W0
06772:  MOV     W0,W7
06774:  MOV     1B2E,W4
06776:  MUL.UU  W4,#4,W0
06778:  ADD     W0,W7,W0
0677A:  MOV     #B46,W4
0677C:  ADD     W0,W4,W0
0677E:  MOV     [W0++],[W6++]
06780:  MOV     [W0++],[W6++]
06782:  MOV     A8E,W4
06784:  ADD     W4,#1,W4
06786:  MOV     W4,W5
06788:  MOV     W5,W4
0678A:  MUL.UU  W4,#8,W0
0678C:  MOV     W0,W5
0678E:  ADD     W5,#4,W5
06790:  MOV     W5,W0
06792:  MOV     #AA6,W4
06794:  ADD     W0,W4,W5
06796:  MOV     1B70,W4
06798:  MUL.UU  W4,#2,W0
0679A:  MOV     #A92,W4
0679C:  ADD     W0,W4,W0
0679E:  MOV     [W0],W6
067A0:  MOV     W6,W4
067A2:  MUL.UU  W4,#10,W6
067A4:  MOV     1B30,W4
067A6:  MUL.UU  W4,#4,W0
067A8:  ADD     W0,W6,W0
067AA:  MOV     #B46,W4
067AC:  ADD     W0,W4,W0
067AE:  MOV     [W0++],[W5++]
067B0:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
067B2:  MOV     #2,W4
067B4:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
067B6:  MOV     #1,W4
067B8:  MOV     W4,A84
.................... 		            } 
067BA:  GOTO    6994
.................... 		            else if (posEnd == 2) 
067BE:  MOV     1B74,W4
067C0:  CP      W4,#2
067C2:  BRA     NZ,687C
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
067C4:  MOV     A8E,W4
067C6:  MUL.UU  W4,#8,W0
067C8:  MOV     W0,W5
067CA:  MOV     #AA6,W4
067CC:  ADD     W5,W4,W6
067CE:  MOV     1B70,W4
067D0:  MUL.UU  W4,#2,W0
067D2:  MOV     #A92,W4
067D4:  ADD     W0,W4,W0
067D6:  MOV     [W0],W7
067D8:  MOV     W7,W4
067DA:  MUL.UU  W4,#10,W0
067DC:  MOV     W0,W7
067DE:  MOV     1B2A,W4
067E0:  MUL.UU  W4,#4,W0
067E2:  ADD     W0,W7,W0
067E4:  MOV     #B46,W4
067E6:  ADD     W0,W4,W0
067E8:  MOV     [W0++],[W6++]
067EA:  MOV     [W0++],[W6++]
067EC:  MOV     A8E,W4
067EE:  MUL.UU  W4,#8,W0
067F0:  MOV     W0,W5
067F2:  ADD     W5,#4,W5
067F4:  MOV     W5,W0
067F6:  MOV     #AA6,W4
067F8:  ADD     W0,W4,W5
067FA:  MOV     1B70,W4
067FC:  MUL.UU  W4,#2,W0
067FE:  MOV     #A92,W4
06800:  ADD     W0,W4,W0
06802:  MOV     [W0],W6
06804:  MOV     W6,W4
06806:  MUL.UU  W4,#10,W6
06808:  MOV     1B2C,W4
0680A:  MUL.UU  W4,#4,W0
0680C:  ADD     W0,W6,W0
0680E:  MOV     #B46,W4
06810:  ADD     W0,W4,W0
06812:  MOV     [W0++],[W5++]
06814:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
06816:  MOV     A8E,W4
06818:  ADD     W4,#1,W4
0681A:  MOV     W4,W5
0681C:  MOV     W5,W4
0681E:  MUL.UU  W4,#8,W0
06820:  MOV     W0,W5
06822:  MOV     #AA6,W4
06824:  ADD     W5,W4,W6
06826:  MOV     1B70,W4
06828:  MUL.UU  W4,#2,W0
0682A:  MOV     #A92,W4
0682C:  ADD     W0,W4,W0
0682E:  MOV     [W0],W7
06830:  MOV     W7,W4
06832:  MUL.UU  W4,#10,W0
06834:  MOV     W0,W7
06836:  ADD     W7,#8,W7
06838:  MOV     W7,W0
0683A:  MOV     #B46,W4
0683C:  ADD     W0,W4,W0
0683E:  MOV     [W0++],[W6++]
06840:  MOV     [W0++],[W6++]
06842:  MOV     A8E,W4
06844:  ADD     W4,#1,W4
06846:  MOV     W4,W5
06848:  MOV     W5,W4
0684A:  MUL.UU  W4,#8,W0
0684C:  MOV     W0,W5
0684E:  ADD     W5,#4,W5
06850:  MOV     W5,W0
06852:  MOV     #AA6,W4
06854:  ADD     W0,W4,W5
06856:  MOV     1B70,W4
06858:  MUL.UU  W4,#2,W0
0685A:  MOV     #A92,W4
0685C:  ADD     W0,W4,W0
0685E:  MOV     [W0],W6
06860:  MOV     W6,W4
06862:  MUL.UU  W4,#10,W6
06864:  ADD     W6,#C,W6
06866:  MOV     W6,W0
06868:  MOV     #B46,W4
0686A:  ADD     W0,W4,W0
0686C:  MOV     [W0++],[W5++]
0686E:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 2; 
06870:  MOV     #2,W4
06872:  MOV     W4,A8C
.................... 		                path_found = true; 
06874:  MOV     #1,W4
06876:  MOV     W4,A84
.................... 		            } 
06878:  GOTO    6994
.................... 		            else if (posEnd == 1) 
0687C:  MOV     1B74,W4
0687E:  CP      W4,#1
06880:  BRA     NZ,6994
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
06882:  MOV     A8E,W4
06884:  MUL.UU  W4,#8,W0
06886:  MOV     W0,W5
06888:  MOV     #AA6,W4
0688A:  ADD     W5,W4,W6
0688C:  MOV     1B70,W4
0688E:  MUL.UU  W4,#2,W0
06890:  MOV     #A92,W4
06892:  ADD     W0,W4,W0
06894:  MOV     [W0],W7
06896:  MOV     W7,W4
06898:  MUL.UU  W4,#10,W0
0689A:  MOV     W0,W7
0689C:  MOV     1B2A,W4
0689E:  MUL.UU  W4,#4,W0
068A0:  ADD     W0,W7,W0
068A2:  MOV     #B46,W4
068A4:  ADD     W0,W4,W0
068A6:  MOV     [W0++],[W6++]
068A8:  MOV     [W0++],[W6++]
068AA:  MOV     A8E,W4
068AC:  MUL.UU  W4,#8,W0
068AE:  MOV     W0,W5
068B0:  ADD     W5,#4,W5
068B2:  MOV     W5,W0
068B4:  MOV     #AA6,W4
068B6:  ADD     W0,W4,W5
068B8:  MOV     1B70,W4
068BA:  MUL.UU  W4,#2,W0
068BC:  MOV     #A92,W4
068BE:  ADD     W0,W4,W0
068C0:  MOV     [W0],W6
068C2:  MOV     W6,W4
068C4:  MUL.UU  W4,#10,W6
068C6:  MOV     1B2C,W4
068C8:  MUL.UU  W4,#4,W0
068CA:  ADD     W0,W6,W0
068CC:  MOV     #B46,W4
068CE:  ADD     W0,W4,W0
068D0:  MOV     [W0++],[W5++]
068D2:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
068D4:  MOV     A8E,W4
068D6:  ADD     W4,#1,W4
068D8:  MOV     W4,W5
068DA:  MOV     W5,W4
068DC:  MUL.UU  W4,#8,W0
068DE:  MOV     W0,W5
068E0:  MOV     #AA6,W4
068E2:  ADD     W5,W4,W6
068E4:  MOV     1B70,W4
068E6:  MUL.UU  W4,#2,W0
068E8:  MOV     #A92,W4
068EA:  ADD     W0,W4,W0
068EC:  MOV     [W0],W7
068EE:  MOV     W7,W4
068F0:  MUL.UU  W4,#10,W0
068F2:  MOV     W0,W7
068F4:  ADD     W7,#8,W7
068F6:  MOV     W7,W0
068F8:  MOV     #B46,W4
068FA:  ADD     W0,W4,W0
068FC:  MOV     [W0++],[W6++]
068FE:  MOV     [W0++],[W6++]
06900:  MOV     A8E,W4
06902:  ADD     W4,#1,W4
06904:  MOV     W4,W5
06906:  MOV     W5,W4
06908:  MUL.UU  W4,#8,W0
0690A:  MOV     W0,W5
0690C:  ADD     W5,#4,W5
0690E:  MOV     W5,W0
06910:  MOV     #AA6,W4
06912:  ADD     W0,W4,W5
06914:  MOV     1B70,W4
06916:  MUL.UU  W4,#2,W0
06918:  MOV     #A92,W4
0691A:  ADD     W0,W4,W0
0691C:  MOV     [W0],W6
0691E:  MOV     W6,W4
06920:  MUL.UU  W4,#10,W6
06922:  ADD     W6,#C,W6
06924:  MOV     W6,W0
06926:  MOV     #B46,W4
06928:  ADD     W0,W4,W0
0692A:  MOV     [W0++],[W5++]
0692C:  MOV     [W0++],[W5++]
.................... 		                PtsRelai[i_rel+2][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+2][Y] = TabZones[TabIntersection[i_zone]][y2]; 
0692E:  MOV     A8E,W4
06930:  ADD     W4,#2,W4
06932:  MOV     W4,W5
06934:  MOV     W5,W4
06936:  MUL.UU  W4,#8,W0
06938:  MOV     W0,W5
0693A:  MOV     #AA6,W4
0693C:  ADD     W5,W4,W6
0693E:  MOV     1B70,W4
06940:  MUL.UU  W4,#2,W0
06942:  MOV     #A92,W4
06944:  ADD     W0,W4,W0
06946:  MOV     [W0],W7
06948:  MOV     W7,W4
0694A:  MUL.UU  W4,#10,W0
0694C:  MOV     W0,W7
0694E:  MOV     1B2E,W4
06950:  MUL.UU  W4,#4,W0
06952:  ADD     W0,W7,W0
06954:  MOV     #B46,W4
06956:  ADD     W0,W4,W0
06958:  MOV     [W0++],[W6++]
0695A:  MOV     [W0++],[W6++]
0695C:  MOV     A8E,W4
0695E:  ADD     W4,#2,W4
06960:  MOV     W4,W5
06962:  MOV     W5,W4
06964:  MUL.UU  W4,#8,W0
06966:  MOV     W0,W5
06968:  ADD     W5,#4,W5
0696A:  MOV     W5,W0
0696C:  MOV     #AA6,W4
0696E:  ADD     W0,W4,W5
06970:  MOV     1B70,W4
06972:  MUL.UU  W4,#2,W0
06974:  MOV     #A92,W4
06976:  ADD     W0,W4,W0
06978:  MOV     [W0],W6
0697A:  MOV     W6,W4
0697C:  MUL.UU  W4,#10,W6
0697E:  MOV     1B30,W4
06980:  MUL.UU  W4,#4,W0
06982:  ADD     W0,W6,W0
06984:  MOV     #B46,W4
06986:  ADD     W0,W4,W0
06988:  MOV     [W0++],[W5++]
0698A:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 3; 
0698C:  MOV     #3,W4
0698E:  MOV     W4,A8C
.................... 		                path_found = true; 
06990:  MOV     #1,W4
06992:  MOV     W4,A84
.................... 		            } 
.................... 	        	} 
06994:  GOTO    6CE8
.................... 	        	else 
.................... 	        	{ 
.................... 		            if (posEnd == 5 || posEnd == 4) 
06998:  MOV     1B74,W4
0699A:  CP      W4,#5
0699C:  BRA     Z,69A4
0699E:  MOV     1B74,W4
069A0:  CP      W4,#4
069A2:  BRA     NZ,6A02
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
069A4:  MOV     A8E,W4
069A6:  MUL.UU  W4,#8,W0
069A8:  MOV     W0,W5
069AA:  MOV     #AA6,W4
069AC:  ADD     W5,W4,W6
069AE:  MOV     1B70,W4
069B0:  MUL.UU  W4,#2,W0
069B2:  MOV     #A92,W4
069B4:  ADD     W0,W4,W0
069B6:  MOV     [W0],W7
069B8:  MOV     W7,W4
069BA:  MUL.UU  W4,#10,W0
069BC:  MOV     W0,W7
069BE:  MOV     1B2A,W4
069C0:  MUL.UU  W4,#4,W0
069C2:  ADD     W0,W7,W0
069C4:  MOV     #B46,W4
069C6:  ADD     W0,W4,W0
069C8:  MOV     [W0++],[W6++]
069CA:  MOV     [W0++],[W6++]
069CC:  MOV     A8E,W4
069CE:  MUL.UU  W4,#8,W0
069D0:  MOV     W0,W5
069D2:  ADD     W5,#4,W5
069D4:  MOV     W5,W0
069D6:  MOV     #AA6,W4
069D8:  ADD     W0,W4,W5
069DA:  MOV     1B70,W4
069DC:  MUL.UU  W4,#2,W0
069DE:  MOV     #A92,W4
069E0:  ADD     W0,W4,W0
069E2:  MOV     [W0],W6
069E4:  MOV     W6,W4
069E6:  MUL.UU  W4,#10,W6
069E8:  MOV     1B2C,W4
069EA:  MUL.UU  W4,#4,W0
069EC:  ADD     W0,W6,W0
069EE:  MOV     #B46,W4
069F0:  ADD     W0,W4,W0
069F2:  MOV     [W0++],[W5++]
069F4:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
069F6:  MOV     #1,W4
069F8:  MOV     W4,A8C
.................... 		                path_found = true; 
069FA:  MOV     #1,W4
069FC:  MOV     W4,A84
.................... 		            } 
069FE:  GOTO    6CE8
.................... 		            else if (posEnd == 3) 
06A02:  MOV     1B74,W4
06A04:  CP      W4,#3
06A06:  BRA     NZ,6C8A
.................... 		            { 
.................... 		                if (getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x1], TabZones[TabIntersection[i_zone]][y1]) + getDist(TabZones[TabIntersection[i_zone]][x2], TabZones[TabIntersection[i_zone]][y2], xEnd, yEnd) < getDist(xStart, yStart, TabZones[TabIntersection[i_zone]][x3], TabZones[TabIntersection[i_zone]][y3]) + getDist(TabZones[TabIntersection[i_zone]][x4], TabZones[TabIntersection[i_zone]][y4], xEnd, yEnd)) 
06A08:  MOV     1B70,W4
06A0A:  MUL.UU  W4,#2,W0
06A0C:  MOV     #A92,W4
06A0E:  ADD     W0,W4,W0
06A10:  MOV     [W0],W5
06A12:  MOV     W5,W4
06A14:  MUL.UU  W4,#10,W0
06A16:  MOV     W0,W5
06A18:  MOV     #B46,W4
06A1A:  ADD     W5,W4,W0
06A1C:  MOV     [W0],W6
06A1E:  MOV     1B70,W4
06A20:  MUL.UU  W4,#2,W0
06A22:  MOV     #A92,W4
06A24:  ADD     W0,W4,W0
06A26:  MOV     [W0],W7
06A28:  MOV     W7,W4
06A2A:  MUL.UU  W4,#10,W0
06A2C:  MOV     W0,W7
06A2E:  ADD     W7,#4,W7
06A30:  MOV     W7,W0
06A32:  MOV     #B46,W4
06A34:  ADD     W0,W4,W0
06A36:  MOV     [W0],W7
06A38:  PUSH    1B68
06A3A:  POP     1B8C
06A3C:  PUSH    1B6A
06A3E:  POP     1B8E
06A40:  MOV     W6,1B90
06A42:  MOV     W7,1B92
06A44:  CALL    2DB6
06A48:  MOV     W0,W6
06A4A:  MOV     1B70,W4
06A4C:  MUL.UU  W4,#2,W0
06A4E:  MOV     #A92,W4
06A50:  ADD     W0,W4,W0
06A52:  MOV     [W0],W7
06A54:  MOV     W7,W4
06A56:  MUL.UU  W4,#10,W0
06A58:  MOV     W0,W7
06A5A:  MOV     1B2E,W4
06A5C:  MUL.UU  W4,#4,W0
06A5E:  ADD     W0,W7,W0
06A60:  MOV     #B46,W4
06A62:  ADD     W0,W4,W0
06A64:  MOV     [W0],W7
06A66:  MOV     1B70,W4
06A68:  MUL.UU  W4,#2,W0
06A6A:  MOV     #A92,W4
06A6C:  ADD     W0,W4,W0
06A6E:  MOV     [W0],W8
06A70:  MOV     W8,W4
06A72:  MUL.UU  W4,#10,W8
06A74:  MOV     1B30,W4
06A76:  MUL.UU  W4,#4,W0
06A78:  ADD     W0,W8,W0
06A7A:  MOV     #B46,W4
06A7C:  ADD     W0,W4,W0
06A7E:  MOV     [W0],W8
06A80:  MOV     W7,1B8C
06A82:  MOV     W8,1B8E
06A84:  PUSH    1B6C
06A86:  POP     1B90
06A88:  PUSH    1B6E
06A8A:  POP     1B92
06A8C:  CALL    2DB6
06A90:  ADD     W0,W6,W6
06A92:  MOV     1B70,W4
06A94:  MUL.UU  W4,#2,W0
06A96:  MOV     #A92,W4
06A98:  ADD     W0,W4,W0
06A9A:  MOV     [W0],W7
06A9C:  MOV     W7,W4
06A9E:  MUL.UU  W4,#10,W0
06AA0:  MOV     W0,W7
06AA2:  MOV     1B2A,W4
06AA4:  MUL.UU  W4,#4,W0
06AA6:  ADD     W0,W7,W0
06AA8:  MOV     #B46,W4
06AAA:  ADD     W0,W4,W0
06AAC:  MOV     [W0],W7
06AAE:  MOV     1B70,W4
06AB0:  MUL.UU  W4,#2,W0
06AB2:  MOV     #A92,W4
06AB4:  ADD     W0,W4,W0
06AB6:  MOV     [W0],W8
06AB8:  MOV     W8,W4
06ABA:  MUL.UU  W4,#10,W8
06ABC:  MOV     1B2C,W4
06ABE:  MUL.UU  W4,#4,W0
06AC0:  ADD     W0,W8,W0
06AC2:  MOV     #B46,W4
06AC4:  ADD     W0,W4,W0
06AC6:  MOV     [W0],W8
06AC8:  PUSH    1B68
06ACA:  POP     1B8C
06ACC:  PUSH    1B6A
06ACE:  POP     1B8E
06AD0:  MOV     W7,1B90
06AD2:  MOV     W8,1B92
06AD4:  CALL    2DB6
06AD8:  MOV     W0,W7
06ADA:  MOV     1B70,W4
06ADC:  MUL.UU  W4,#2,W0
06ADE:  MOV     #A92,W4
06AE0:  ADD     W0,W4,W0
06AE2:  MOV     [W0],W8
06AE4:  MOV     W8,W4
06AE6:  MUL.UU  W4,#10,W8
06AE8:  ADD     W8,#8,W8
06AEA:  MOV     W8,W0
06AEC:  MOV     #B46,W4
06AEE:  ADD     W0,W4,W0
06AF0:  MOV     [W0],W8
06AF2:  MOV     1B70,W4
06AF4:  MUL.UU  W4,#2,W0
06AF6:  MOV     #A92,W4
06AF8:  ADD     W0,W4,W0
06AFA:  MOV     [W0],W9
06AFC:  MOV     W9,W4
06AFE:  MUL.UU  W4,#10,W0
06B00:  MOV     W0,W9
06B02:  ADD     W9,#C,W9
06B04:  MOV     W9,W0
06B06:  MOV     #B46,W4
06B08:  ADD     W0,W4,W0
06B0A:  MOV     [W0],W9
06B0C:  MOV     W8,1B8C
06B0E:  MOV     W9,1B8E
06B10:  PUSH    1B6C
06B12:  POP     1B90
06B14:  PUSH    1B6E
06B16:  POP     1B92
06B18:  CALL    2DB6
06B1C:  ADD     W0,W7,W0
06B1E:  CP      W6,W0
06B20:  BRA     GE,6BD2
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06B22:  MOV     A8E,W4
06B24:  MUL.UU  W4,#8,W0
06B26:  MOV     W0,W5
06B28:  MOV     #AA6,W4
06B2A:  ADD     W5,W4,W6
06B2C:  MOV     1B70,W4
06B2E:  MUL.UU  W4,#2,W0
06B30:  MOV     #A92,W4
06B32:  ADD     W0,W4,W0
06B34:  MOV     [W0],W7
06B36:  MOV     W7,W4
06B38:  MUL.UU  W4,#10,W0
06B3A:  MOV     W0,W7
06B3C:  MOV     #B46,W4
06B3E:  ADD     W7,W4,W0
06B40:  MOV     [W0++],[W6++]
06B42:  MOV     [W0++],[W6++]
06B44:  MOV     A8E,W4
06B46:  MUL.UU  W4,#8,W0
06B48:  MOV     W0,W5
06B4A:  ADD     W5,#4,W5
06B4C:  MOV     W5,W0
06B4E:  MOV     #AA6,W4
06B50:  ADD     W0,W4,W5
06B52:  MOV     1B70,W4
06B54:  MUL.UU  W4,#2,W0
06B56:  MOV     #A92,W4
06B58:  ADD     W0,W4,W0
06B5A:  MOV     [W0],W6
06B5C:  MOV     W6,W4
06B5E:  MUL.UU  W4,#10,W6
06B60:  ADD     W6,#4,W6
06B62:  MOV     W6,W0
06B64:  MOV     #B46,W4
06B66:  ADD     W0,W4,W0
06B68:  MOV     [W0++],[W5++]
06B6A:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x2]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y2]; 
06B6C:  MOV     A8E,W4
06B6E:  ADD     W4,#1,W4
06B70:  MOV     W4,W5
06B72:  MOV     W5,W4
06B74:  MUL.UU  W4,#8,W0
06B76:  MOV     W0,W5
06B78:  MOV     #AA6,W4
06B7A:  ADD     W5,W4,W6
06B7C:  MOV     1B70,W4
06B7E:  MUL.UU  W4,#2,W0
06B80:  MOV     #A92,W4
06B82:  ADD     W0,W4,W0
06B84:  MOV     [W0],W7
06B86:  MOV     W7,W4
06B88:  MUL.UU  W4,#10,W0
06B8A:  MOV     W0,W7
06B8C:  MOV     1B2E,W4
06B8E:  MUL.UU  W4,#4,W0
06B90:  ADD     W0,W7,W0
06B92:  MOV     #B46,W4
06B94:  ADD     W0,W4,W0
06B96:  MOV     [W0++],[W6++]
06B98:  MOV     [W0++],[W6++]
06B9A:  MOV     A8E,W4
06B9C:  ADD     W4,#1,W4
06B9E:  MOV     W4,W5
06BA0:  MOV     W5,W4
06BA2:  MUL.UU  W4,#8,W0
06BA4:  MOV     W0,W5
06BA6:  ADD     W5,#4,W5
06BA8:  MOV     W5,W0
06BAA:  MOV     #AA6,W4
06BAC:  ADD     W0,W4,W5
06BAE:  MOV     1B70,W4
06BB0:  MUL.UU  W4,#2,W0
06BB2:  MOV     #A92,W4
06BB4:  ADD     W0,W4,W0
06BB6:  MOV     [W0],W6
06BB8:  MOV     W6,W4
06BBA:  MUL.UU  W4,#10,W6
06BBC:  MOV     1B30,W4
06BBE:  MUL.UU  W4,#4,W0
06BC0:  ADD     W0,W6,W0
06BC2:  MOV     #B46,W4
06BC4:  ADD     W0,W4,W0
06BC6:  MOV     [W0++],[W5++]
06BC8:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
06BCA:  MOV     #2,W4
06BCC:  MOV     W4,A8C
.................... 		                } 
06BCE:  GOTO    6C82
.................... 		                else 
.................... 		                { 
.................... 		                    PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x3]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y3]; 
06BD2:  MOV     A8E,W4
06BD4:  MUL.UU  W4,#8,W0
06BD6:  MOV     W0,W5
06BD8:  MOV     #AA6,W4
06BDA:  ADD     W5,W4,W6
06BDC:  MOV     1B70,W4
06BDE:  MUL.UU  W4,#2,W0
06BE0:  MOV     #A92,W4
06BE2:  ADD     W0,W4,W0
06BE4:  MOV     [W0],W7
06BE6:  MOV     W7,W4
06BE8:  MUL.UU  W4,#10,W0
06BEA:  MOV     W0,W7
06BEC:  MOV     1B2A,W4
06BEE:  MUL.UU  W4,#4,W0
06BF0:  ADD     W0,W7,W0
06BF2:  MOV     #B46,W4
06BF4:  ADD     W0,W4,W0
06BF6:  MOV     [W0++],[W6++]
06BF8:  MOV     [W0++],[W6++]
06BFA:  MOV     A8E,W4
06BFC:  MUL.UU  W4,#8,W0
06BFE:  MOV     W0,W5
06C00:  ADD     W5,#4,W5
06C02:  MOV     W5,W0
06C04:  MOV     #AA6,W4
06C06:  ADD     W0,W4,W5
06C08:  MOV     1B70,W4
06C0A:  MUL.UU  W4,#2,W0
06C0C:  MOV     #A92,W4
06C0E:  ADD     W0,W4,W0
06C10:  MOV     [W0],W6
06C12:  MOV     W6,W4
06C14:  MUL.UU  W4,#10,W6
06C16:  MOV     1B2C,W4
06C18:  MUL.UU  W4,#4,W0
06C1A:  ADD     W0,W6,W0
06C1C:  MOV     #B46,W4
06C1E:  ADD     W0,W4,W0
06C20:  MOV     [W0++],[W5++]
06C22:  MOV     [W0++],[W5++]
.................... 		                    PtsRelai[i_rel+1][X] = TabZones[TabIntersection[i_zone]][x4]; PtsRelai[i_rel+1][Y] = TabZones[TabIntersection[i_zone]][y4]; 
06C24:  MOV     A8E,W4
06C26:  ADD     W4,#1,W4
06C28:  MOV     W4,W5
06C2A:  MOV     W5,W4
06C2C:  MUL.UU  W4,#8,W0
06C2E:  MOV     W0,W5
06C30:  MOV     #AA6,W4
06C32:  ADD     W5,W4,W6
06C34:  MOV     1B70,W4
06C36:  MUL.UU  W4,#2,W0
06C38:  MOV     #A92,W4
06C3A:  ADD     W0,W4,W0
06C3C:  MOV     [W0],W7
06C3E:  MOV     W7,W4
06C40:  MUL.UU  W4,#10,W0
06C42:  MOV     W0,W7
06C44:  ADD     W7,#8,W7
06C46:  MOV     W7,W0
06C48:  MOV     #B46,W4
06C4A:  ADD     W0,W4,W0
06C4C:  MOV     [W0++],[W6++]
06C4E:  MOV     [W0++],[W6++]
06C50:  MOV     A8E,W4
06C52:  ADD     W4,#1,W4
06C54:  MOV     W4,W5
06C56:  MOV     W5,W4
06C58:  MUL.UU  W4,#8,W0
06C5A:  MOV     W0,W5
06C5C:  ADD     W5,#4,W5
06C5E:  MOV     W5,W0
06C60:  MOV     #AA6,W4
06C62:  ADD     W0,W4,W5
06C64:  MOV     1B70,W4
06C66:  MUL.UU  W4,#2,W0
06C68:  MOV     #A92,W4
06C6A:  ADD     W0,W4,W0
06C6C:  MOV     [W0],W6
06C6E:  MOV     W6,W4
06C70:  MUL.UU  W4,#10,W6
06C72:  ADD     W6,#C,W6
06C74:  MOV     W6,W0
06C76:  MOV     #B46,W4
06C78:  ADD     W0,W4,W0
06C7A:  MOV     [W0++],[W5++]
06C7C:  MOV     [W0++],[W5++]
.................... 		                    relay_point_number = 2; 
06C7E:  MOV     #2,W4
06C80:  MOV     W4,A8C
.................... 		                } 
.................... 		                path_found = true; 
06C82:  MOV     #1,W4
06C84:  MOV     W4,A84
.................... 		            } 
06C86:  GOTO    6CE8
.................... 		            else if (posEnd == 2 || posEnd == 1) 
06C8A:  MOV     1B74,W4
06C8C:  CP      W4,#2
06C8E:  BRA     Z,6C96
06C90:  MOV     1B74,W4
06C92:  CP      W4,#1
06C94:  BRA     NZ,6CE8
.................... 		            { 
.................... 		                PtsRelai[i_rel][X] = TabZones[TabIntersection[i_zone]][x1]; PtsRelai[i_rel][Y] = TabZones[TabIntersection[i_zone]][y1]; 
06C96:  MOV     A8E,W4
06C98:  MUL.UU  W4,#8,W0
06C9A:  MOV     W0,W5
06C9C:  MOV     #AA6,W4
06C9E:  ADD     W5,W4,W6
06CA0:  MOV     1B70,W4
06CA2:  MUL.UU  W4,#2,W0
06CA4:  MOV     #A92,W4
06CA6:  ADD     W0,W4,W0
06CA8:  MOV     [W0],W7
06CAA:  MOV     W7,W4
06CAC:  MUL.UU  W4,#10,W0
06CAE:  MOV     W0,W7
06CB0:  MOV     #B46,W4
06CB2:  ADD     W7,W4,W0
06CB4:  MOV     [W0++],[W6++]
06CB6:  MOV     [W0++],[W6++]
06CB8:  MOV     A8E,W4
06CBA:  MUL.UU  W4,#8,W0
06CBC:  MOV     W0,W5
06CBE:  ADD     W5,#4,W5
06CC0:  MOV     W5,W0
06CC2:  MOV     #AA6,W4
06CC4:  ADD     W0,W4,W5
06CC6:  MOV     1B70,W4
06CC8:  MUL.UU  W4,#2,W0
06CCA:  MOV     #A92,W4
06CCC:  ADD     W0,W4,W0
06CCE:  MOV     [W0],W6
06CD0:  MOV     W6,W4
06CD2:  MUL.UU  W4,#10,W6
06CD4:  ADD     W6,#4,W6
06CD6:  MOV     W6,W0
06CD8:  MOV     #B46,W4
06CDA:  ADD     W0,W4,W0
06CDC:  MOV     [W0++],[W5++]
06CDE:  MOV     [W0++],[W5++]
.................... 		                relay_point_number = 1; 
06CE0:  MOV     #1,W4
06CE2:  MOV     W4,A8C
.................... 		                path_found = true; 
06CE4:  MOV     #1,W4
06CE6:  MOV     W4,A84
.................... 		            } 
.................... 		        } 
....................  
.................... 	            break; 
06CE8:  GOTO    6CF8
....................  
.................... 	        case 8: 
....................  
.................... 	            path_found = false; 
06CEC:  CLR     A84
....................  
.................... 	            break; 
06CEE:  GOTO    6CF8
....................  
.................... 	        default: 
.................... 	            path_found = false; 
06CF2:  CLR     A84
.................... 	            break; 
06CF4:  GOTO    6CF8
.................... 	    } 
....................  
.................... 	    i_rel = i_rel + relay_point_number;     
06CF8:  MOV     A8E,W0
06CFA:  ADD     A8C,W0
06CFC:  MOV     W0,A8E
....................     } 
06CFE:  MOV     #14,W5
06D00:  REPEAT  #4
06D02:  MOV     [--W15],[W5--]
06D04:  MOV     [--W15],W5
06D06:  RETURN  
....................   
.................... } 
....................  
....................  
.................... #endif  
....................  
....................  
.................... #endif  
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////// 
.................... // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! // 
.................... // La plage ROM 0 ÃÂ  511 est rÃÂ©servÃÂ©e aux objectifs. // 
.................... // 512/513 : Nombre d'objectifs 
.................... // 514/515 : Si des objectifs sont chargÃÂ©s 
.................... ////////////////////////////////////////////////////// 
....................  
.................... //******************************************************************************** 
.................... //*  Mains 
.................... //**************************************************************************************************** 
.................... void main(void) 
*
0AC20:  MOV     #2000,W15
0AC22:  MOV     #27FF,W0
0AC24:  MOV     W0,20
0AC26:  NOP     
0AC28:  MOV     #7444,W0
0AC2A:  MOV     W0,94
0AC2C:  MOV     #4744,W0
0AC2E:  MOV     W0,96
0AC30:  BSET.B  81.7
0AC32:  BCLR.B  2E4.3
0AC34:  BCLR.B  2E4.2
0AC36:  BCLR.B  2E8.2
0AC38:  BCLR.B  2E8.3
0AC3A:  BSET.B  207.7
0AC3C:  BSET.B  207.5
0AC3E:  BSET.B  206.6
0AC40:  BCLR.B  207.3
0AC42:  BSET.B  206.7
0AC44:  BCLR.B  207.0
0AC46:  BSET.B  207.1
0AC48:  BCLR.B  207.2
0AC4A:  CLR     20A
0AC4C:  MOV     #C2,W4
0AC4E:  MOV     W4,204
0AC50:  MOV     #8000,W4
0AC52:  MOV     W4,216
0AC54:  MOV     #400,W4
0AC56:  MOV     W4,218
0AC58:  MOV     #A,W4
0AC5A:  MOV     W4,21E
0AC5C:  BCLR.B  85A.0
0AC5E:  BCLR.B  85A.1
0AC60:  BCLR.B  85A.2
0AC62:  BCLR.B  85A.3
0AC64:  BCLR.B  85A.4
0AC66:  BCLR.B  85A.5
0AC68:  BCLR.B  85A.6
0AC6A:  BCLR.B  85A.7
0AC6C:  BCLR.B  85B.0
0AC6E:  BCLR.B  85B.1
0AC70:  BCLR.B  85B.2
0AC72:  BCLR.B  85B.3
0AC74:  CLR     85C
0AC76:  CLR     85E
0AC78:  CLR.B   860
0AC7A:  CLR     862
0AC7C:  CLR     864
0AC7E:  CLR     866
0AC80:  CLR     868
0AC82:  CLR     86A
0AC84:  CLR     86C
0AC86:  CLR.B   861
0AC88:  CLR.B   86E
0AC8A:  MOV.B   #4,W0L
0AC8C:  MOV.B   W0L,86F
0AC8E:  CLR.B   870
0AC90:  CLR.B   871
0AC92:  CLR.B   872
0AC94:  MOV.B   #1,W0L
0AC96:  MOV.B   W0L,873
0AC98:  MOV.B   #1,W0L
0AC9A:  MOV.B   W0L,874
0AC9C:  CLR     876
0AC9E:  CLR     878
0ACA0:  BSET.B  85B.4
0ACA2:  CLR.B   875
0ACA4:  CLR.B   87A
0ACA6:  CLR.B   87B
0ACA8:  CLR.B   87C
0ACAA:  CLR.B   87D
0ACAC:  BCLR.B  85B.5
0ACAE:  BCLR.B  85B.6
0ACB0:  MOV     #BB8,W4
0ACB2:  MOV     W4,87E
0ACB4:  CLR.B   880
0ACB6:  CLR     A82
0ACB8:  CLR     A84
0ACBA:  CLR     A86
0ACBC:  CLR     A88
0ACBE:  CLR     A8A
0ACC0:  CLR     A8C
0ACC2:  CLR     A8E
0ACC4:  CLR     A90
0ACC6:  MOV     #3E8,W4
0ACC8:  MOV     W4,C06
0ACCA:  MOV.B   #A,W0L
0ACCC:  MOV.B   W0L,881
0ACCE:  CLR     C08
0ACD0:  CLR     C0A
0ACD2:  CLR     C0C
0ACD4:  CLR     C0E
0ACD6:  BCLR.B  85B.7
0ACD8:  CLR     1498
0ACDA:  CLR     149A
0ACDC:  CLR     149C
0ACDE:  CLR     149E
0ACE0:  CLR     14A0
0ACE2:  CLR     14A2
0ACE4:  CLR     14A4
0ACE6:  CLR     14A6
0ACE8:  CLR     14A8
0ACEA:  CLR     14AA
0ACEC:  CLR     14AC
0ACEE:  CLR     14AE
0ACF0:  MOV.B   #14,W0L
0ACF2:  MOV.B   W0L,14B0
0ACF4:  MOV.B   #5,W0L
0ACF6:  MOV.B   W0L,14B1
0ACF8:  MOV     #2,W4
0ACFA:  MOV     W4,14B2
0ACFC:  CLR     14B4
0ACFE:  MOV.B   #3,W0L
0AD00:  MOV.B   W0L,14B6
0AD02:  MOV     #C8,W4
0AD04:  MOV     W4,14B8
0AD06:  BCLR.B  14B7.0
0AD08:  CLR     14BA
0AD0A:  CLR     14BC
0AD0C:  MOV     #999A,W4
0AD0E:  MOV     W4,157E
0AD10:  MOV     #9999,W4
0AD12:  MOV     W4,1580
0AD14:  MOV     #9999,W4
0AD16:  MOV     W4,1582
0AD18:  MOV     #3FF9,W4
0AD1A:  MOV     W4,1584
0AD1C:  MOV     #64,W4
0AD1E:  MOV     W4,1586
0AD20:  CLR     158A
0AD22:  CLR     158C
0AD24:  CLR     158E
0AD26:  CLR     1590
0AD28:  CLR     1592
0AD2A:  CLR     1594
0AD2C:  CLR     1596
0AD2E:  CLR     1598
0AD30:  CLR     159A
0AD32:  CLR     159C
0AD34:  CLR     159E
0AD36:  CLR     15A0
0AD38:  MOV     #F8B6,W4
0AD3A:  MOV     W4,15A2
0AD3C:  MOV     #14,W4
0AD3E:  MOV     W4,15A4
0AD40:  MOV     #D9E3,W4
0AD42:  MOV     W4,15A6
0AD44:  MOV     #400B,W4
0AD46:  MOV     W4,15A8
0AD48:  CLR     15AA
0AD4A:  CLR     15AC
0AD4C:  MOV     #8800,W4
0AD4E:  MOV     W4,15AE
0AD50:  MOV     #40B3,W4
0AD52:  MOV     W4,15B0
0AD54:  MOV     #6DDB,W4
0AD56:  MOV     W4,15B2
0AD58:  MOV     #9A17,W4
0AD5A:  MOV     W4,15B4
0AD5C:  MOV     #84EB,W4
0AD5E:  MOV     W4,15B6
0AD60:  MOV     #403D,W4
0AD62:  MOV     W4,15B8
0AD64:  MOV     15AA,W0
0AD66:  MOV     15AC,W1
0AD68:  MOV     15AE,W2
0AD6A:  MOV     15B0,W3
0AD6C:  MOV     #0,W4
0AD6E:  MOV     #0,W5
0AD70:  MOV     #0,W6
0AD72:  MOV     #4010,W7
0AD74:  CALL    BFA
0AD78:  MOV     W0,W5
0AD7A:  MOV     W1,W6
0AD7C:  MOV     W2,W7
0AD7E:  MOV     W3,W8
0AD80:  MOV     W5,[W15++]
0AD82:  MOV     W6,[W15++]
0AD84:  MOV     W7,[W15++]
0AD86:  MOV     15A2,W0
0AD88:  MOV     15A4,W1
0AD8A:  MOV     15A6,W2
0AD8C:  MOV     15A8,W3
0AD8E:  MOV     #2D18,W4
0AD90:  MOV     #5444,W5
0AD92:  MOV     #21FB,W6
0AD94:  MOV     #4009,W7
0AD96:  CALL    BFA
0AD9A:  MOV     [--W15],W7
0AD9C:  MOV     [--W15],W6
0AD9E:  MOV     [--W15],W5
0ADA0:  MOV     W5,[W15++]
0ADA2:  MOV     W6,[W15++]
0ADA4:  MOV     W7,[W15++]
0ADA6:  MOV     W0,W4
0ADA8:  MOV     W5,W0
0ADAA:  MOV     W1,W5
0ADAC:  MOV     W6,W1
0ADAE:  MOV     W2,W6
0ADB0:  MOV     W7,W2
0ADB2:  MOV     W3,W7
0ADB4:  MOV     W8,W3
0ADB6:  CALL    D0A
0ADBA:  MOV     [--W15],W7
0ADBC:  MOV     [--W15],W6
0ADBE:  MOV     [--W15],W5
0ADC0:  MOV     W0,15BA
0ADC2:  MOV     W1,15BC
0ADC4:  MOV     W2,15BE
0ADC6:  MOV     W3,15C0
0ADC8:  MOV     #9D39,W4
0ADCA:  MOV     W4,15C2
0ADCC:  MOV     #A252,W4
0ADCE:  MOV     W4,15C4
0ADD0:  MOV     #DF46,W4
0ADD2:  MOV     W4,15C6
0ADD4:  MOV     #3F91,W4
0ADD6:  MOV     W4,15C8
0ADD8:  CLR.B   15CA
0ADDA:  CLR.B   15CB
0ADDC:  CLR     15CC
0ADDE:  CLR     15CE
0ADE0:  CLR     15D0
0ADE2:  CLR     15D2
0ADE4:  CLR     15D4
0ADE6:  CLR     15D6
0ADE8:  CLR     15D8
0ADEA:  CLR     15DA
0ADEC:  CLR     15DC
0ADEE:  CLR     15DE
0ADF0:  BCLR.B  14B7.1
0ADF2:  MOV     #7D0,W4
0ADF4:  MOV     W4,15E2
0ADF6:  MOV     #4B0,W4
0ADF8:  MOV     W4,15E4
0ADFA:  BCLR.B  14B7.4
0ADFC:  CLR     15E6
0ADFE:  CLR     15E8
0AE00:  CLR.B   15E1
0AE02:  BCLR.B  14B7.5
0AE04:  CLR     15EA
0AE06:  CLR     15EC
0AE08:  MOV.B   #3,W0L
0AE0A:  MOV.B   W0L,15EE
0AE0C:  CLR.B   15EF
0AE0E:  MOV     #C8,W4
0AE10:  MOV     W4,15F2
0AE12:  CLR     160A
0AE14:  CLR     160C
0AE16:  CLR.B   1612
0AE18:  BCLR.B  1604.7
0AE1A:  CLR     1614
0AE1C:  CLR     1616
0AE1E:  CLR     1618
0AE20:  CLR.B   1613
0AE22:  MOV.B   #1,W0L
0AE24:  MOV.B   W0L,161A
0AE26:  BCLR.B  161B.0
0AE28:  CLR.B   161C
0AE2A:  BCLR.B  161B.1
0AE2C:  CLR.B   161D
0AE2E:  MOV     #8000,W4
0AE30:  MOV     W4,20C
0AE32:  MOV     #400,W4
0AE34:  MOV     W4,20E
0AE36:  MOV     #A,W4
0AE38:  MOV     W4,214
0AE3A:  BCLR.B  161B.2
0AE3C:  BCLR.B  161B.3
0AE3E:  CLR.B   171E
0AE40:  CLR.B   171F
0AE42:  BCLR.B  161B.4
0AE44:  CLR.B   1B20
0AE46:  CLR     1B2A
0AE48:  MOV     #3,W4
0AE4A:  MOV     W4,1B2C
0AE4C:  MOV     #2,W4
0AE4E:  MOV     W4,1B2E
0AE50:  MOV     #1,W4
0AE52:  MOV     W4,1B30
0AE54:  CLR     1B4A
0AE56:  BCLR.B  161B.5
0AE58:  SETM    2A8
0AE5A:  BRA     AF2A
0AE5C:  DATA    C2,00,08
0AE5E:  DATA    82,00,C1
0AE60:  DATA    60,0A,A6
0AE62:  DATA    00,C8,88
0AE64:  DATA    0C,10,00
0AE66:  DATA    80,01,14
0AE68:  DATA    B7,00,80
0AE6A:  DATA    01,14,B7
0AE6C:  DATA    00,80,01
0AE6E:  DATA    14,B7,00
0AE70:  DATA    C0,06,14
0AE72:  DATA    BE,00,00
0AE74:  DATA    4B,F0,3F
0AE76:  DATA    5C,0A,58
0AE78:  DATA    F6,3B,8F
0AE7A:  DATA    00,C0,3C
0AE7C:  DATA    8B,28,AC
0AE7E:  DATA    3C,BE,F6
0AE80:  DATA    3F,D2,D5
0AE82:  DATA    44,16,8C
0AE84:  DATA    15,D7,BF
0AE86:  DATA    69,00,5A
0AE88:  DATA    2E,1B,87
0AE8A:  DATA    99,3F,9A
0AE8C:  DATA    5F,AD,4B
0AE8E:  DATA    91,E4,01
0AE90:  DATA    C0,5D,11
0AE92:  DATA    2F,92,E4
0AE94:  DATA    81,FB,3F
0AE96:  DATA    38,DA,91
0AE98:  DATA    80,9D,C5
0AE9A:  DATA    E0,BF,6F
0AE9C:  DATA    12,C0,B4
0AE9E:  DATA    C3,09,AB
0AEA0:  DATA    3F,6B,C1
0AEA2:  DATA    03,4E,C1
0AEA4:  DATA    B5,45,BF
0AEA6:  DATA    F7,40,05
0AEA8:  DATA    FF,00,5C
0AEAA:  DATA    EF,3F,F3
0AEAC:  DATA    A3,E2,F7
0AEAE:  DATA    D7,FF,01
0AEB0:  DATA    40,C0,B4
0AEB2:  DATA    FF,05,3C
0AEB4:  DATA    58,FC,3F
0AEB6:  DATA    3B,D3,C0
0AEB8:  DATA    B5,BA,8C
0AEBA:  DATA    E2,3F,39
0AEBC:  DATA    D3,C7,3D
0AEBE:  DATA    41,79,B2
0AEC0:  DATA    3F,87,0D
0AEC2:  DATA    3C,50,D0
0AEC4:  DATA    AF,62,3F
0AEC6:  DATA    30,4B,8D
0AEC8:  DATA    A2,82,AA
0AECA:  DATA    04,40,09
0AECC:  DATA    A0,40,4A
0AECE:  DATA    05,76,03
0AED0:  DATA    40,EC,9E
0AED2:  DATA    37,88,A6
0AED4:  DATA    44,F0,3F
0AED6:  DATA    8F,12,8D
0AED8:  DATA    29,9A,5B
0AEDA:  DATA    C7,3F,0E
0AEDC:  DATA    E0,80,7C
0AEDE:  DATA    A1,D8,86
0AEE0:  DATA    3F,29,4B
0AEE2:  DATA    FB,95,C2
0AEE4:  DATA    37,1A,3F
0AEE6:  DATA    00,00,80
0AEE8:  DATA    01,15,E0
0AEEA:  DATA    00,80,02
0AEEC:  DATA    15,F0,00
0AEEE:  DATA    00,C0,16
0AEF0:  DATA    15,F4,00
0AEF2:  DATA    80,01,16
0AEF4:  DATA    04,00,80
0AEF6:  DATA    04,16,0E
0AEF8:  DATA    00,00,00
0AEFA:  DATA    00,C1,00
0AEFC:  DATA    16,1E,00
0AEFE:  DATA    C4,00,17
0AF00:  DATA    20,00,80
0AF02:  DATA    04,1B,21
0AF04:  DATA    00,00,00
0AF06:  DATA    00,80,04
0AF08:  DATA    1B,26,00
0AF0A:  DATA    00,00,00
0AF0C:  DATA    00,00,00
0AF0E:  INC     W2,W2
0AF10:  CP      W2,#1
0AF12:  BRA     NZ,AF1C
0AF14:  TBLRDL  [W1],W3
0AF16:  TBLRDH  [W1++],W4
0AF18:  MOV.B   6,W0L
0AF1A:  RETURN  
0AF1C:  CP      W2,#2
0AF1E:  BRA     NZ,AF24
0AF20:  MOV.B   7,W0L
0AF22:  RETURN  
0AF24:  MOV.B   8,W0L
0AF26:  CLR     W2
0AF28:  RETURN  
0AF2A:  MOV     #0,W6
0AF2C:  MOV     #0,W0
0AF2E:  MOV     W0,32
0AF30:  MOV     #AE5C,W0
0AF32:  MOV     W0,W1
0AF34:  CLR     W2
0AF36:  CALL    AF0E
0AF3A:  MOV.B   W0L,B
0AF3C:  CALL    AF0E
0AF40:  MOV.B   W0L,A
0AF42:  CP0     W5
0AF44:  BRA     Z,AF78
0AF46:  BTSS    W5.F
0AF48:  BRA     AF58
0AF4A:  CALL    AF0E
0AF4E:  MOV.B   W0L,D
0AF50:  CALL    AF0E
0AF54:  MOV.B   W0L,C
0AF56:  BCLR    W5.F
0AF58:  BTSS    W5.E
0AF5A:  BRA     AF6C
0AF5C:  BCLR    W5.E
0AF5E:  DEC     W5,W5
0AF60:  CALL    AF0E
0AF64:  MOV.B   W0L,W7L
0AF66:  REPEAT  W5
0AF68:  MOV.B   W7L,[W6++]
0AF6A:  BRA     AF36
0AF6C:  CALL    AF0E
0AF70:  MOV.B   W0L,[W6++]
0AF72:  DEC     W5,W5
0AF74:  BRA     NZ,AF6C
0AF76:  BRA     AF36
.................... { 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////	INITIALISATION DE TOUS LES MODULES	//////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 		// Initialisation du dsPIC 
.................... 	__Init_dsPIC();	 
0AF78:  CALL    F7E
.................... //	delay_ms(1300);  
.................... 	__Init_UART(); 
0AF7C:  CALL    1026
.................... 	//__Init_pos(); 
.................... 	//delay_ms(1000); 
.................... 	 
.................... 		// Check si dÃÂ©marreur en place 
.................... 	if(!_DEMA)__Affichage_Erreur(1); 
0AF80:  BTSC.B  2C3.2
0AF82:  BRA     AF8C
0AF84:  MOV.B   #1,W0L
0AF86:  MOV.B   W0L,1B5C
0AF88:  CALL    102A
....................  
.................... 				 
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 			// Configuration de la balise 
.................... 	Balise_config_plage(0, 12, 14);	// En avanÃÂ§ant 
0AF8C:  CLR.B   1B54
0AF8E:  MOV.B   #C,W0L
0AF90:  MOV.B   W0L,1B55
0AF92:  MOV.B   #E,W0L
0AF94:  MOV.B   W0L,1B56
0AF96:  CALL    1032
.................... 	delay_ms(100); 
0AF9A:  MOV     #64,W0
0AF9C:  CALL    EBE
.................... 	Balise_config_plage(1, 4, 6); // En reculant 
0AFA0:  MOV.B   #1,W0L
0AFA2:  MOV.B   W0L,1B54
0AFA4:  MOV.B   #4,W0L
0AFA6:  MOV.B   W0L,1B55
0AFA8:  MOV.B   #6,W0L
0AFAA:  MOV.B   W0L,1B56
0AFAC:  CALL    1032
.................... 	delay_ms(100); 
0AFB0:  MOV     #64,W0
0AFB2:  CALL    EBE
....................  
.................... 		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
.................... 		// Set la base 
.................... 		// On n'affiche pas l'erreur ici car si on dÃÂ©branche le driver de dÃÂ©placement 
.................... 		// pour envoyer les objectifs, cela bloquerait le systÃÂ¨me 
.................... //	unsigned int8 ToSetBase=0; 
.................... 	if(_TEAM==0) 
0AFB6:  BTSC.B  2C3.4
0AFB8:  BRA     AFC4
.................... 	{ 
.................... 		_LDT1=0; 
0AFBA:  BCLR.B  2D6.5
.................... 		_LDT2=1; 
0AFBC:  BSET.B  2D6.6
.................... 		Team=0; 
0AFBE:  BCLR.B  85B.3
.................... 	} 
0AFC0:  GOTO    AFCE
.................... 	else if(_TEAM==1) 
0AFC4:  BTSS.B  2C3.4
0AFC6:  BRA     AFCE
.................... 	{ 
.................... 		_LDT2=0; 
0AFC8:  BCLR.B  2D6.6
.................... 		_LDT1=1; 
0AFCA:  BSET.B  2D6.5
.................... 		Team=1; 
0AFCC:  BSET.B  85B.3
.................... 	}	 
.................... 	//Team=1; 
.................... 	fprintf(ROBOTEQ,"!MG\r"); 
0AFCE:  MOV     #0,W1
0AFD0:  MOV     W1,W0
0AFD2:  CLR.B   1
0AFD4:  CALL    418
0AFD8:  INC     W1,W1
0AFDA:  BTSC.B  219.1
0AFDC:  BRA     AFDA
0AFDE:  MOV     W0,21A
0AFE0:  MOV     #3,W0
0AFE2:  CPSGT   W1,W0
0AFE4:  BRA     AFD0
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 			 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	/////////////////////////////////	PROGRAMME PRINCIPAL	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////////// 
.................... 	int1 action_ok1 = 0; 
.................... 	int1 action_ok2 = 0; 
.................... 	int1 action_ok3 = 0; 
.................... 	int1 Module_inplace = 0; 
0AFE6:  BCLR.B  1B4C.0
0AFE8:  BCLR.B  1B4C.1
0AFEA:  BCLR.B  1B4C.2
0AFEC:  BCLR.B  1B4C.3
....................  	 
....................   	driver_Pompes(0xA0, 0, 0, 0, 0, 0);		//Désactive toute les pompes 
0AFEE:  MOV.B   #A0,W0L
0AFF0:  MOV.B   W0L,1B60
0AFF2:  CLR.B   1B61
0AFF4:  CLR.B   1B62
0AFF6:  CLR.B   1B63
0AFF8:  CLR.B   1B64
0AFFA:  CLR.B   1B65
0AFFC:  CALL    107C
.................... 	 
.................... 	 
.................... 	while(!Module_inplace) Module_inplace=__GoToZero();		//Réinitialise la couronne 
0B000:  BTSC.B  1B4C.3
0B002:  BRA     B012
0B004:  CALL    1218
0B008:  BCLR.B  1B4C.3
0B00A:  BTSC.B  0.0
0B00C:  BSET.B  1B4C.3
0B00E:  GOTO    B000
.................... 	go_driver_moteur(0xC2,0,DRV_MODE_VITESSE ,5000,DRV_ARRET_POSITION_RELATIVE,1);	//Pour que la couronne maintient la position 
0B012:  MOV.B   #C2,W0L
0B014:  MOV.B   W0L,1B60
0B016:  CLR.B   1B61
0B018:  MOV.B   #1,W0L
0B01A:  MOV.B   W0L,1B62
0B01C:  MOV.B   #2,W0L
0B01E:  MOV.B   W0L,1B63
0B020:  MOV     #1388,W4
0B022:  MOV     W4,1B64
0B024:  MOV     #1,W4
0B026:  MOV     W4,1B66
0B028:  CLR     1B68
0B02A:  CALL    10FE
.................... 	delay_ms(100); 
0B02E:  MOV     #64,W0
0B030:  CALL    EBE
.................... 	Module_inplace = 0; 
0B034:  BCLR.B  1B4C.3
.................... 	while(!Module_inplace) Module_inplace=GoToZero_Cremaillere();		//Réinitialise la crémaillère 
0B036:  BTSC.B  1B4C.3
0B038:  BRA     B048
0B03A:  CALL    1824
0B03E:  BCLR.B  1B4C.3
0B040:  BTSC.B  0.0
0B042:  BSET.B  1B4C.3
0B044:  GOTO    B036
.................... 	delay_ms(100); 
0B048:  MOV     #64,W0
0B04A:  CALL    EBE
.................... 	 
.................... 	 
.................... 	 
.................... 		 
.................... 	while(1) 
.................... 	{		 
.................... 		switch(Etat_rob) 
0B04E:  MOV.B   87B,W0L
0B050:  CLR.B   1
0B052:  XOR     #0,W0
0B054:  BRA     Z,B078
0B056:  XOR     #1,W0
0B058:  BRA     Z,B0EE
0B05A:  XOR     #3,W0
0B05C:  BRA     Z,B0F2
0B05E:  XOR     #1,W0
0B060:  BRA     Z,B1B4
0B062:  XOR     #7,W0
0B064:  BRA     Z,B1F6
0B066:  XOR     #1,W0
0B068:  BRA     Z,B24C
0B06A:  XOR     #3,W0
0B06C:  BRA     Z,B2A8
0B06E:  XOR     #1,W0
0B070:  BRA     Z,B35E
0B072:  XOR     #F,W0
0B074:  BRA     Z,B42A
0B076:  BRA     B476
.................... 		{ 
.................... 			case Init: 
.................... 				//solution=(PORTA&0b11110000)/16; 
.................... 				solution = 0b0001; 
0B078:  MOV.B   #1,W0L
0B07A:  MOV.B   W0L,87A
.................... 								 
.................... 				if(NbreObjectifs > 0 && !_DEMA  && !flag_end)//si on a des objectifs et qu'il sont charger 
0B07C:  CP0     14BA
0B07E:  BRA     Z,B0BA
0B080:  BTSC.B  2C3.2
0B082:  BRA     B0BA
0B084:  BTSC.B  85A.7
0B086:  BRA     B0BA
.................... 				{ 
.................... 					if(BeginTimeMS==0)  
0B088:  CP0     866
0B08A:  BRA     NZ,B098
0B08C:  CP0     868
0B08E:  BRA     NZ,B098
.................... 					{ 
.................... 						BeginTimeMS = RealTimeMS; 
0B090:  PUSH    862
0B092:  POP     866
0B094:  PUSH    864
0B096:  POP     868
.................... 						//delay_ms(1000);  
.................... 					} 
.................... 					__Afficheur_7segments(0); 
0B098:  CLR.B   1B5C
0B09A:  CLR.B   1B5D
0B09C:  CALL    1338
.................... 					__LoadObj(NoObj,NoPts);//on mets l'objectifs dans des variables 
0B0A0:  MOV.B   873,W0L
0B0A2:  MOV.B   W0L,1B56
0B0A4:  CLR.B   1B57
0B0A6:  MOV.B   874,W0L
0B0A8:  MOV.B   W0L,1B58
0B0AA:  CLR.B   1B59
0B0AC:  CALL    18C4
.................... 					Etat_rob = Check_ZI;//on change d'etat 
0B0B0:  MOV.B   #2,W0L
0B0B2:  MOV.B   W0L,87B
.................... 					Depl_send = 0;			 
0B0B4:  BCLR.B  85B.5
.................... 				} 
0B0B6:  GOTO    B0EA
.................... 				else if(NbreObjectifs == 0) 
0B0BA:  CP0     14BA
0B0BC:  BRA     NZ,B0D4
.................... 				{ 
.................... 					__Afficheur_7segments(1); 
0B0BE:  MOV.B   #1,W0L
0B0C0:  MOV.B   W0L,1B5C
0B0C2:  CLR.B   1B5D
0B0C4:  CALL    1338
.................... 					__ReadObjectifs();	 
0B0C8:  CALL    1A74
.................... 					__ReadZones_Interdites(); 
0B0CC:  CALL    1B12
.................... 				} 
0B0D0:  GOTO    B0EA
.................... 				else if(_DEMA == 1 && NbreObjectifs != 0) 
0B0D4:  BTSS.B  2C3.2
0B0D6:  BRA     B0EA
0B0D8:  CP0     14BA
0B0DA:  BRA     Z,B0EA
.................... 				{				 
.................... 					__Afficheur_7segments(2); 
0B0DC:  MOV.B   #2,W0L
0B0DE:  MOV.B   W0L,1B5C
0B0E0:  CLR.B   1B5D
0B0E2:  CALL    1338
.................... 					__Init_pos();					 
0B0E6:  CALL    1DCC
.................... 				} 
.................... 				break; 
0B0EA:  GOTO    B482
....................  
....................  
.................... 			 
.................... 			case Choose_objectif: 
....................  
.................... 				/* 
.................... 				static int obj_todo = 0; //L'objectif qu'on regarde si on peut le faire 
....................  
.................... 				obj_todo++; //On passe à l'objectif suivant 
.................... 				__LoadObj(obj_todo, 1); //On récupère les données de l'objectif dans les variables 
....................  
.................... 				if(oTime < (TimeLimit - GameTimeS) && !obj_done && !obj_notcontinuable) 
.................... 				{ 
.................... 					Etat_rob = Send_depl_action; 
.................... 				} 
....................  
.................... 				if (obj_todo >= (NbreObjectifs))  
.................... 				{ 
.................... 					obj_todo = 0; 
.................... 				} 
.................... 				*/ 
.................... 				break; 
0B0EE:  GOTO    B482
.................... 				 
....................  
.................... 			case Check_ZI: 
....................  
.................... 				__Afficheur_7segments(3); 
0B0F2:  MOV.B   #3,W0L
0B0F4:  MOV.B   W0L,1B5C
0B0F6:  CLR.B   1B5D
0B0F8:  CALL    1338
.................... 				if(checkPath()) 
0B0FC:  CALL    20AC
0B100:  CP0     W0
0B102:  BRA     Z,B116
.................... 				{ 
.................... 					__Afficheur_7segments(4); 
0B104:  MOV.B   #4,W0L
0B106:  MOV.B   W0L,1B5C
0B108:  CLR.B   1B5D
0B10A:  CALL    1338
.................... 					Etat_rob = Send_depl_action; 
0B10E:  MOV.B   #3,W0L
0B110:  MOV.B   W0L,87B
.................... 				} 
0B112:  GOTO    B1B0
.................... 				else 
.................... 				{ 
.................... 					__Afficheur_7segments(7); 
0B116:  MOV.B   #7,W0L
0B118:  MOV.B   W0L,1B5C
0B11A:  CLR.B   1B5D
0B11C:  CALL    1338
.................... 					//On met le point de départ dans la première case du tableau 
.................... 					i_rel = 0; 
0B120:  CLR     A8E
.................... 					PtsRelai[i_rel][X] = Pos_x;  
0B122:  MOV     A8E,W4
0B124:  MUL.UU  W4,#8,W0
0B126:  MOV     W0,W5
0B128:  MOV     #AA6,W4
0B12A:  ADD     W5,W4,W6
0B12C:  MOV     158C,W0
0B12E:  CLR     W1
0B130:  BTSC    W0.F
0B132:  SETM    W1
0B134:  MOV     #0,W4
0B136:  MOV     [W4++],[W6++]
0B138:  MOV     [W4++],[W6++]
.................... 					PtsRelai[i_rel][Y] = Pos_y;  
0B13A:  MOV     A8E,W4
0B13C:  MUL.UU  W4,#8,W0
0B13E:  MOV     W0,W5
0B140:  ADD     W5,#4,W5
0B142:  MOV     W5,W0
0B144:  MOV     #AA6,W4
0B146:  ADD     W0,W4,W5
0B148:  MOV     158E,W0
0B14A:  CLR     W1
0B14C:  BTSC    W0.F
0B14E:  SETM    W1
0B150:  MOV     #0,W4
0B152:  MOV     [W4++],[W5++]
0B154:  MOV     [W4++],[W5++]
.................... 					i_rel++; 
0B156:  INC     0A8E
.................... 					 
.................... 					findPath(); 
0B158:  CALL    6E58
.................... 					 
.................... 					 
.................... 					i_rel++; 
0B15C:  INC     0A8E
.................... 					PtsRelai[i_rel-1][X] = oXp;  
0B15E:  MOV     A8E,W4
0B160:  SUB     W4,#1,W5
0B162:  MOV     W5,W4
0B164:  MUL.UU  W4,#8,W0
0B166:  MOV     W0,W5
0B168:  MOV     #AA6,W4
0B16A:  ADD     W5,W4,W6
0B16C:  MOV     1498,W0
0B16E:  CLR     W1
0B170:  BTSC    W0.F
0B172:  SETM    W1
0B174:  MOV     #0,W4
0B176:  MOV     [W4++],[W6++]
0B178:  MOV     [W4++],[W6++]
.................... 					PtsRelai[i_rel-1][Y] = oYp;  
0B17A:  MOV     A8E,W4
0B17C:  SUB     W4,#1,W5
0B17E:  MOV     W5,W4
0B180:  MUL.UU  W4,#8,W0
0B182:  MOV     W0,W5
0B184:  ADD     W5,#4,W5
0B186:  MOV     W5,W0
0B188:  MOV     #AA6,W4
0B18A:  ADD     W0,W4,W5
0B18C:  MOV     149A,W0
0B18E:  CLR     W1
0B190:  BTSC    W0.F
0B192:  SETM    W1
0B194:  MOV     #0,W4
0B196:  MOV     [W4++],[W5++]
0B198:  MOV     [W4++],[W5++]
.................... 					i_depl = 1; 
0B19A:  MOV     #1,W4
0B19C:  MOV     W4,A90
.................... 					 
.................... 					if(path_impossible == 1) 
0B19E:  MOV     A86,W4
0B1A0:  CP      W4,#1
0B1A2:  BRA     NZ,B1AC
.................... 			        { 
.................... 				        __Stop(); 
0B1A4:  CALL    6D08
.................... 				    }  
0B1A8:  GOTO    B1B0
.................... 				    else 
.................... 				    { 
.................... 					    Etat_rob = Send_depl_action_ZI; 
0B1AC:  MOV.B   #4,W0L
0B1AE:  MOV.B   W0L,87B
.................... 					}  
.................... 					 
.................... 				} 
....................  
.................... 				break; 
0B1B0:  GOTO    B482
....................  
.................... 			case Send_depl_action: 
....................  
....................  
.................... 				__Afficheur_7segments(5); 
0B1B4:  MOV.B   #5,W0L
0B1B6:  MOV.B   W0L,1B5C
0B1B8:  CLR.B   1B5D
0B1BA:  CALL    1338
.................... 				if(!Depl_send && !flag_end)//si le deplacement n'as pas ete envoye 
0B1BE:  BTSC.B  85B.5
0B1C0:  BRA     B1CE
0B1C2:  BTSC.B  85A.7
0B1C4:  BRA     B1CE
.................... 				{ 
.................... 					__DeplToDo(oType);//envoie le déplacment 
0B1C6:  MOV.B   149C,W0L
0B1C8:  MOV.B   W0L,1B54
0B1CA:  CALL    922C
.................... 				} 
.................... 				if(!Action_send && !flag_end)//si l'action n'a pas ete envoyee 
0B1CE:  BTSC.B  85B.7
0B1D0:  BRA     B1DE
0B1D2:  BTSC.B  85A.7
0B1D4:  BRA     B1DE
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
0B1D6:  MOV.B   14A4,W0L
0B1D8:  MOV.B   W0L,1B54
0B1DA:  CALL    9F04
.................... 				} 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
0B1DE:  BTSS.B  85B.5
0B1E0:  BRA     B1F2
0B1E2:  BTSS.B  85B.7
0B1E4:  BRA     B1F2
0B1E6:  BTSC.B  85A.7
0B1E8:  BRA     B1F2
.................... 				{ 
.................... 					Depl_send = 0; 
0B1EA:  BCLR.B  85B.5
.................... 					Action_send = 0; 
0B1EC:  BCLR.B  85B.7
.................... 					Etat_rob = Depl_action_process; 
0B1EE:  MOV.B   #5,W0L
0B1F0:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
0B1F2:  GOTO    B482
....................  
....................  
.................... 			case Send_depl_action_ZI: 
....................  
.................... 				__Afficheur_7segments(8); 
0B1F6:  MOV.B   #8,W0L
0B1F8:  MOV.B   W0L,1B5C
0B1FA:  CLR.B   1B5D
0B1FC:  CALL    1338
.................... 				 
.................... 				//__Check_commande_atteint(); 
.................... 				 
.................... 				if(!Action_send)//si l'action n'a pas ete envoyee 
0B200:  BTSC.B  85B.7
0B202:  BRA     B20C
.................... 				{ 
.................... 					__Action_Writting(obj_Action);//envoie l'action 
0B204:  MOV.B   14A4,W0L
0B206:  MOV.B   W0L,1B54
0B208:  CALL    9F04
.................... 				} 
....................  
.................... 				if(!Depl_send) 
0B20C:  BTSC.B  85B.5
0B20E:  BRA     B234
.................... 				{ 
.................... 					__PaP(PtsRelai[i_depl][X], PtsRelai[i_depl][Y]); 
0B210:  MOV     A90,W4
0B212:  MUL.UU  W4,#8,W0
0B214:  MOV     W0,W5
0B216:  MOV     #AA6,W4
0B218:  ADD     W5,W4,W0
0B21A:  MOV     [W0],W6
0B21C:  MOV     A90,W4
0B21E:  MUL.UU  W4,#8,W0
0B220:  MOV     W0,W7
0B222:  ADD     W7,#4,W7
0B224:  MOV     W7,W0
0B226:  MOV     #AA6,W4
0B228:  ADD     W0,W4,W0
0B22A:  MOV     [W0],W7
0B22C:  MOV     W6,1B5A
0B22E:  MOV     W7,1B5C
0B230:  CALL    807A
.................... 				} 
.................... /* 
.................... 				if (flag_depl_ok) 
.................... 				{ 
.................... 					i_depl++; 
.................... 					Depl_send = 0; 
.................... 					flag_depl_ok = 0; 
.................... 				} 
....................  
.................... 				if(i_depl >= i_rel && Action_send)//si tout a ete envoye 
.................... 				{ 
.................... 					Depl_send = 0; 
.................... 					Action_send = 0; 
.................... 					Etat_rob = Depl_action_process_ZI; 
.................... 				} 
.................... */ 
.................... 				if(Depl_send && Action_send && !flag_end)//si tout a ete envoye 
0B234:  BTSS.B  85B.5
0B236:  BRA     B248
0B238:  BTSS.B  85B.7
0B23A:  BRA     B248
0B23C:  BTSC.B  85A.7
0B23E:  BRA     B248
.................... 				{ 
.................... 					Depl_send = 0; 
0B240:  BCLR.B  85B.5
.................... 					Action_send = 0; 
0B242:  BCLR.B  85B.7
.................... 					Etat_rob = Depl_action_process_ZI; 
0B244:  MOV.B   #6,W0L
0B246:  MOV.B   W0L,87B
.................... 				} 
....................  
.................... 				break; 
0B248:  GOTO    B482
....................  
.................... 			case Depl_action_process : 
....................  
.................... 				__Afficheur_7segments(6); 
0B24C:  MOV.B   #6,W0L
0B24E:  MOV.B   W0L,1B5C
0B250:  CLR.B   1B5D
0B252:  CALL    1338
.................... 				__Check_commande_atteint(); 
0B256:  CALL    7D7E
.................... 				//action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
.................... 				//action_ok2 = __Check_action_end(0xC2); 
.................... 				//action_ok3 = __Check_action_end(0xC4); 
.................... 				if(flag_depl_ok && /*action_ok1 && action_ok2 && action_ok3*/Check && !flag_end && !_Detected)//on attend que tout soit fini 
0B25A:  BTSS.B  85A.6
0B25C:  BRA     B2A4
0B25E:  BTSS.B  85B.4
0B260:  BRA     B2A4
0B262:  BTSC.B  85A.7
0B264:  BRA     B2A4
0B266:  BTSC.B  85B.0
0B268:  BRA     B2A4
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
0B26A:  MOV     872,W4
0B26C:  LSR     W4,#8,W4
0B26E:  CP.B    W4L,#1
0B270:  BRA     NZ,B27E
0B272:  MOV     874,W4
0B274:  CP.B    W4L,#1
0B276:  BRA     NZ,B27E
0B278:  MOV     #3E8,W0
0B27A:  CALL    EBE
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
0B27E:  MOV     158C,W0
0B280:  ADD     1588,W0
0B282:  MOV     W0,158C
.................... 					Pos_y += Dist_y; 
0B284:  MOV     158E,W0
0B286:  ADD     158A,W0
0B288:  MOV     W0,158E
.................... 					 
.................... 					//__Afficheur_7segments(3); 
.................... 	 
.................... 					Dist_x=0; 
0B28A:  CLR     1588
.................... 					Dist_y=0; 
0B28C:  CLR     158A
.................... 					Dorient = 0; 
0B28E:  CLR     1592
0B290:  CLR     1594
0B292:  CLR     1596
0B294:  CLR     1598
.................... 					balise_on = 0; 
0B296:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
0B298:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
0B29A:  BCLR.B  1B4C.0
.................... 					action_ok2 = 0; 
0B29C:  BCLR.B  1B4C.1
.................... 					action_ok3 = 0; 
0B29E:  BCLR.B  1B4C.2
.................... 					Etat_rob = Switch_end_obj; 
0B2A0:  MOV.B   #7,W0L
0B2A2:  MOV.B   W0L,87B
.................... 				} 
.................... 				break; 
0B2A4:  GOTO    B482
....................  
.................... 			case Depl_action_process_ZI: 
....................  
.................... 				__Afficheur_7segments(9); 
0B2A8:  MOV.B   #9,W0L
0B2AA:  MOV.B   W0L,1B5C
0B2AC:  CLR.B   1B5D
0B2AE:  CALL    1338
.................... 				__Check_commande_atteint(); 
0B2B2:  CALL    7D7E
.................... 				//action_ok1 = __Check_action_end(0xC0); // 1 si ordre fini 
.................... 				//action_ok2 = __Check_action_end(0xC2); 
.................... 				//action_ok3 = __Check_action_end(0xC4); 
.................... 				if(flag_depl_ok && /*action_ok1 && action_ok2 && action_ok3*/ Check && !flag_end && !_Detected)//on attend que tout soit fini 
0B2B6:  BTSS.B  85A.6
0B2B8:  BRA     B35A
0B2BA:  BTSS.B  85B.4
0B2BC:  BRA     B35A
0B2BE:  BTSC.B  85A.7
0B2C0:  BRA     B35A
0B2C2:  BTSC.B  85B.0
0B2C4:  BRA     B35A
.................... 				{ 
.................... 					if(NoObj==1&&NoPts==1) delay_ms(1000); 
0B2C6:  MOV     872,W4
0B2C8:  LSR     W4,#8,W4
0B2CA:  CP.B    W4L,#1
0B2CC:  BRA     NZ,B2DA
0B2CE:  MOV     874,W4
0B2D0:  CP.B    W4L,#1
0B2D2:  BRA     NZ,B2DA
0B2D4:  MOV     #3E8,W0
0B2D6:  CALL    EBE
.................... 					//actualisation position xy  
.................... 					Pos_x += Dist_x;  
0B2DA:  MOV     158C,W0
0B2DC:  ADD     1588,W0
0B2DE:  MOV     W0,158C
.................... 					Pos_y += Dist_y; 
0B2E0:  MOV     158E,W0
0B2E2:  ADD     158A,W0
0B2E4:  MOV     W0,158E
.................... 					 
.................... 					//__Afficheur_7segments(3); 
.................... 	 
.................... 					Dist_x=0; 
0B2E6:  CLR     1588
.................... 					Dist_y=0; 
0B2E8:  CLR     158A
.................... 					Dorient = 0; 
0B2EA:  CLR     1592
0B2EC:  CLR     1594
0B2EE:  CLR     1596
0B2F0:  CLR     1598
.................... 					balise_on = 0; 
0B2F2:  BCLR.B  85B.1
.................... 					flag_depl_ok = 0; 
0B2F4:  BCLR.B  85A.6
.................... 					action_ok1 = 0; 
0B2F6:  BCLR.B  1B4C.0
.................... 					action_ok2 = 0; 
0B2F8:  BCLR.B  1B4C.1
.................... 					action_ok3 = 0; 
0B2FA:  BCLR.B  1B4C.2
.................... 					 
.................... 					i_depl++; 
0B2FC:  INC     0A90
.................... 					 
.................... 					if(i_depl >= i_rel)//si tout a ete envoye 
0B2FE:  MOV     A8E,W0
0B300:  MOV     A90,W4
0B302:  CP      W4,W0
0B304:  BRA     LT,B356
.................... 					{ 
.................... 						Depl_send = 0; 
0B306:  BCLR.B  85B.5
.................... 						Action_send = 0; 
0B308:  BCLR.B  85B.7
.................... 						int i; 
.................... 						for(i = 0; i < 10; i++) 
0B30A:  CLR     1B4E
0B30C:  MOV     1B4E,W4
0B30E:  CP      W4,#A
0B310:  BRA     GE,B34C
.................... 						{ 
.................... 							PtsRelai[i][0] = 0; 
0B312:  MOV     1B4E,W4
0B314:  MUL.UU  W4,#8,W0
0B316:  MOV     W0,W5
0B318:  MOV     #AA6,W4
0B31A:  ADD     W5,W4,W6
0B31C:  CLR.B   [W6]
0B31E:  MOV.B   #0,W0L
0B320:  MOV.B   W0L,[W6+#1]
0B322:  MOV.B   #0,W0L
0B324:  MOV.B   W0L,[W6+#2]
0B326:  MOV.B   #0,W0L
0B328:  MOV.B   W0L,[W6+#3]
.................... 							PtsRelai[i][1] = 0; 
0B32A:  MOV     1B4E,W4
0B32C:  MUL.UU  W4,#8,W0
0B32E:  MOV     W0,W5
0B330:  ADD     W5,#4,W5
0B332:  MOV     W5,W0
0B334:  MOV     #AA6,W4
0B336:  ADD     W0,W4,W5
0B338:  CLR.B   [W5]
0B33A:  MOV.B   #0,W0L
0B33C:  MOV.B   W0L,[W5+#1]
0B33E:  MOV.B   #0,W0L
0B340:  MOV.B   W0L,[W5+#2]
0B342:  MOV.B   #0,W0L
0B344:  MOV.B   W0L,[W5+#3]
0B346:  INC     1B4E
0B348:  GOTO    B30C
.................... 						}	 
.................... 						path_opposite = 0; 
0B34C:  CLR     A88
.................... 						Etat_rob = Switch_end_obj; 
0B34E:  MOV.B   #7,W0L
0B350:  MOV.B   W0L,87B
.................... 					} 
0B352:  GOTO    B35A
.................... 					else 
.................... 					{ 
.................... 					 Etat_rob = Send_depl_action_ZI; 
0B356:  MOV.B   #4,W0L
0B358:  MOV.B   W0L,87B
.................... 					}	 
.................... 					 
.................... 				} 
.................... 				break;	 
0B35A:  GOTO    B482
....................  
.................... 			 
.................... 			case Switch_end_obj: 
.................... 				if(keep_obj==0)  
0B35E:  CP0     14AE
0B360:  BRA     NZ,B37C
.................... 				{ 
.................... 					TabObjectifs[NoObj][1][8] = 0; // mise de la ponderation a 0 --> on le remploie plus 
0B362:  MOV.B   873,W0L
0B364:  CLR.B   1
0B366:  MOV     #138,W4
0B368:  MUL.UU  W0,W4,W0
0B36A:  MOV     W0,W5
0B36C:  ADD     W5,#18,W5
0B36E:  ADD     W5,#10,W5
0B370:  MOV     W5,W0
0B372:  MOV     #C10,W4
0B374:  ADD     W0,W4,W5
0B376:  CLR.B   [W5]
0B378:  MOV.B   #0,W0L
0B37A:  MOV.B   W0L,[W5+#1]
.................... 				} 
.................... 			 	if(Obj_end)//si fini l'objectifs,passe a l'obj suivant 
0B37C:  CP0     14AA
0B37E:  BRA     Z,B3EC
.................... 				{ 
.................... 					if(Next_obj!=0) // 0--> passe a l'obj suivant, sinon va a l'obj marquer 
0B380:  CP0     14AC
0B382:  BRA     Z,B3A8
.................... 					{ 
.................... 						last_obj = NoObj; 
0B384:  MOV.B   873,W0L
0B386:  MOV.B   W0L,876
0B388:  CLR.B   877
0B38A:  CLR     878
.................... 						NoObj = Next_Obj; 
0B38C:  MOV.B   14AC,W0L
0B38E:  MOV.B   W0L,873
.................... 						NoPts = 1; 
0B390:  MOV.B   #1,W0L
0B392:  MOV.B   W0L,874
.................... 						__LoadObj(NoObj,NoPts);//charge le nouveau pts						 
0B394:  MOV.B   873,W0L
0B396:  MOV.B   W0L,1B56
0B398:  CLR.B   1B57
0B39A:  MOV.B   874,W0L
0B39C:  MOV.B   W0L,1B58
0B39E:  CLR.B   1B59
0B3A0:  CALL    18C4
.................... 					} 
0B3A4:  GOTO    B3E8
.................... 					else 
.................... 					{ 
.................... 						last_obj = NoObj; 
0B3A8:  MOV.B   873,W0L
0B3AA:  MOV.B   W0L,876
0B3AC:  CLR.B   877
0B3AE:  CLR     878
.................... 						do //prochain objectifs avec pondÃÂ©ration de 10 
.................... 						{ 
.................... 							__Afficheur_7segments(4); 
0B3B0:  MOV.B   #4,W0L
0B3B2:  MOV.B   W0L,1B5C
0B3B4:  CLR.B   1B5D
0B3B6:  CALL    1338
.................... 							NoObj++; // on passe a l'objectifs suivant 
0B3BA:  INC.B   0873
.................... 							NoPts=1; // on reprend au premier pts 
0B3BC:  MOV.B   #1,W0L
0B3BE:  MOV.B   W0L,874
.................... 							if(NoObj == 10) 
0B3C0:  MOV     872,W4
0B3C2:  LSR     W4,#8,W4
0B3C4:  CP.B    W4L,#A
0B3C6:  BRA     NZ,B3D2
.................... 							{ 
.................... 								Flag_end = 1; 
0B3C8:  BSET.B  85A.7
.................... 								Ponderation = 10; 
0B3CA:  MOV     #A,W4
0B3CC:  MOV     W4,14A8
.................... 							} 
0B3CE:  GOTO    B3E2
.................... 							else __LoadObj(NoObj,NoPts);//charge le nouveau pts 
0B3D2:  MOV.B   873,W0L
0B3D4:  MOV.B   W0L,1B56
0B3D6:  CLR.B   1B57
0B3D8:  MOV.B   874,W0L
0B3DA:  MOV.B   W0L,1B58
0B3DC:  CLR.B   1B59
0B3DE:  CALL    18C4
.................... 	 
.................... 						}while(Ponderation!=10); 
0B3E2:  MOV     14A8,W4
0B3E4:  CP      W4,#A
0B3E6:  BRA     NZ,B3B0
....................  
.................... 					} 
.................... 				} 
0B3E8:  GOTO    B410
.................... 				else 
.................... 				{ 
.................... 					if(Pt_commun==1) NoPts+=2; // skip le pts droite 
0B3EC:  MOV     14A6,W4
0B3EE:  CP      W4,#1
0B3F0:  BRA     NZ,B3FE
0B3F2:  MOV     874,W4
0B3F4:  ADD.B   W4L,#2,W4L
0B3F6:  MOV.B   W4L,W0L
0B3F8:  MOV.B   W0L,874
0B3FA:  GOTO    B400
.................... 					else NoPts++; // passe au pt suivant suivant																 
0B3FE:  INC.B   0874
.................... 					__LoadObj(NoObj,NoPts);//charge le nouveau pts 
0B400:  MOV.B   873,W0L
0B402:  MOV.B   W0L,1B56
0B404:  CLR.B   1B57
0B406:  MOV.B   874,W0L
0B408:  MOV.B   W0L,1B58
0B40A:  CLR.B   1B59
0B40C:  CALL    18C4
.................... 				}	 
.................... 				if(Pt_commun!=0)//si point pas symetrique 
0B410:  CP0     14A6
0B412:  BRA     Z,B420
.................... 				{ 
.................... 					if(Team)//pt droite 
0B414:  BTSS.B  85B.3
0B416:  BRA     B420
.................... 					{ 
.................... 						if(Pt_commun==1) NoPts++; // passe ÃÂ  l'obj suivant (pt droite) 
0B418:  MOV     14A6,W4
0B41A:  CP      W4,#1
0B41C:  BRA     NZ,B420
0B41E:  INC.B   0874
.................... 					} 
.................... 				} 
.................... 				 
.................... 				if(!Flag_end) Etat_rob = Init; 
0B420:  BTSC.B  85A.7
0B422:  BRA     B426
0B424:  CLR.B   87B
.................... 				break; 
0B426:  GOTO    B482
.................... 			case Wait_end: //case wait 
.................... 				if(flag_error) //erreur --> clignotement 7 segments 
0B42A:  BTSS.B  85B.2
0B42C:  BRA     B450
.................... 				{ 
.................... 					__Afficheur_7segments(No_erreur,1); 
0B42E:  MOV.B   870,W0L
0B430:  MOV.B   W0L,1B5C
0B432:  MOV.B   #1,W0L
0B434:  MOV.B   W0L,1B5D
0B436:  CALL    1338
.................... 					delay_ms(1000); 
0B43A:  MOV     #3E8,W0
0B43C:  CALL    EBE
.................... 					__Afficheur_7segments(No_erreur,0); 
0B440:  MOV.B   870,W0L
0B442:  MOV.B   W0L,1B5C
0B444:  CLR.B   1B5D
0B446:  CALL    1338
.................... 					delay_ms(1000); 
0B44A:  MOV     #3E8,W0
0B44C:  CALL    EBE
.................... 				} 
.................... 				if(flagGameEnd) 
0B450:  BTSS.B  85A.0
0B452:  BRA     B472
.................... 				{ 
.................... 					__Afficheur_7segments(99); 
0B454:  MOV.B   #63,W0L
0B456:  MOV.B   W0L,1B5C
0B458:  CLR.B   1B5D
0B45A:  CALL    1338
.................... 					// Desactive tout le reste 
.................... 					MoveServo(0,20); 
0B45E:  CLR     1B54
0B460:  MOV     #14,W4
0B462:  MOV     W4,1B56
0B464:  CALL    9F90
.................... 					disable_interrupts(INTR_GLOBAL); 
0B468:  BCLR.B  81.7
0B46A:  MOV     #E0,W4
0B46C:  MOV     W4,42
0B46E:  BSET.B  81.7
.................... 					flagGameEnd=0;			 
0B470:  BCLR.B  85A.0
.................... 				}				 
.................... 				break;			 
0B472:  GOTO    B482
.................... 			default: 
.................... 				__Affichage_erreur(3);  
0B476:  MOV.B   #3,W0L
0B478:  MOV.B   W0L,1B5C
0B47A:  CALL    102A
.................... 				break; 
0B47E:  GOTO    B482
.................... 		} 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
....................  
....................         //////////////////////////////////////////////////////////////////////////////////// 
.................... 		////////////////////////	ACTION PARALLELES	//////////////////////////////////// 
.................... 		//////////////////////////////////////////////////////////////////////////////////// 
.................... 		 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        BALISE          ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(flagBaliseCheck && !flag_end && balise_on && !flag_error) 
0B482:  BTSS.B  85A.2
0B484:  BRA     B630
0B486:  BTSC.B  85A.7
0B488:  BRA     B630
0B48A:  BTSS.B  85B.1
0B48C:  BRA     B630
0B48E:  BTSC.B  85B.2
0B490:  BRA     B630
....................       	{ 
....................         	Value_bal = Check_balise(); 			//Recuperation de la valeur de la bailse 
0B492:  CALL    9FC6
0B496:  MOV.B   W0L,871
....................         	tempo_bal++; 							//temporisation de la balise, d'une fois detecte, il faut passer 4  tempo bal = 4 pour continuer 
0B498:  INC.B   0872
.................... 	        if(Value_bal>=MAX_VALUE_DETECT_BALISE) 	//si adversaire trop proche 
0B49A:  MOV.B   14B6,W0L
0B49C:  MOV     870,W4
0B49E:  LSR     W4,#8,W4
0B4A0:  CP.B    W4L,W0L
0B4A2:  BRA     NC,B5BC
.................... 	        {    
.................... 	       		tempo_bal = 0;						//remise a 0 de la tempo 
0B4A4:  CLR.B   872
....................            		__Afficheur_7segments(44); 
0B4A6:  MOV.B   #2C,W0L
0B4A8:  MOV.B   W0L,1B5C
0B4AA:  CLR.B   1B5D
0B4AC:  CALL    1338
.................... 	           	_LED2,_LED3,_LED4 = 1; 
0B4B0:  BSET.B  2D0.4
.................... 	           	_Detected = 1;						//indique que l'on a detecte l'adversaire 
0B4B2:  BSET.B  85B.0
.................... 	         
.................... 	            /////////////////// Arret du robot /////////////////////////////////////// 
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 9000_^MDEC 2 9000\r");	//rampe de dec. plus raide  
0B4B4:  MOV     #0,W1
0B4B6:  MOV     W1,W0
0B4B8:  CLR.B   1
0B4BA:  CALL    42A
0B4BE:  INC     W1,W1
0B4C0:  BTSC.B  219.1
0B4C2:  BRA     B4C0
0B4C4:  MOV     W0,21A
0B4C6:  MOV     #19,W0
0B4C8:  CPSGT   W1,W0
0B4CA:  BRA     B4B6
.................... 	            delay_ms(20); 
0B4CC:  MOV     #14,W0
0B4CE:  CALL    EBE
.................... 	            fprintf(ROBOTEQ,"!S 1 0_!S 2 0\r");				//vitesse du robot a 0 --> il va freiner 
0B4D2:  MOV     #0,W1
0B4D4:  MOV     W1,W0
0B4D6:  CLR.B   1
0B4D8:  CALL    452
0B4DC:  INC     W1,W1
0B4DE:  BTSC.B  219.1
0B4E0:  BRA     B4DE
0B4E2:  MOV     W0,21A
0B4E4:  MOV     #D,W0
0B4E6:  CPSGT   W1,W0
0B4E8:  BRA     B4D4
....................  
.................... 	            if(Time_detected==0) // recuperation du temps de la detection 
0B4EA:  CP0.B   86E
0B4EC:  BRA     NZ,B4F6
.................... 	            { 
.................... 	               Time_detected = GameTimeS; 
0B4EE:  MOV.B   861,W0L
0B4F0:  MOV.B   W0L,86E
.................... 	            } 
0B4F2:  GOTO    B5B8
.................... 	            else if(((GameTimeS - Time_detected) >= TIME_tempo_dectected))//on attend 6s 
0B4F6:  MOV     860,W4
0B4F8:  LSR     W4,#8,W4
0B4FA:  MOV     86E,W3
0B4FC:  SUB.B   W4L,W3L,W0L
0B4FE:  MOV     86E,W4
0B500:  LSR     W4,#8,W4
0B502:  CP.B    W4L,W0L
0B504:  BRA     GTU,B5B8
.................... 	            {  
.................... 	            	 
.................... 	            	__actual_pos();// actualisation de la Pos xy  
0B506:  CALL    A006
....................     				 
....................     				/////////////////// effacer l'ordre en cours  ///////////////////  
....................                   	fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
0B50A:  MOV     #0,W1
0B50C:  MOV     W1,W0
0B50E:  CLR.B   1
0B510:  CALL    136
0B514:  INC     W1,W1
0B516:  BTSC.B  219.1
0B518:  BRA     B516
0B51A:  MOV     W0,21A
0B51C:  MOV     #13,W0
0B51E:  CPSGT   W1,W0
0B520:  BRA     B50C
....................                   	delay_ms(10); 
0B522:  MOV     #A,W0
0B524:  CALL    EBE
....................                   	fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
0B528:  MOV     #0,W1
0B52A:  MOV     W1,W0
0B52C:  CLR.B   1
0B52E:  CALL    158
0B532:  INC     W1,W1
0B534:  BTSC.B  219.1
0B536:  BRA     B534
0B538:  MOV     W0,21A
0B53A:  MOV     #13,W0
0B53C:  CPSGT   W1,W0
0B53E:  BRA     B52A
.................... 	                  	 
.................... 					if(checkPath()) 
0B540:  CALL    20AC
0B544:  CP0     W0
0B546:  BRA     Z,B558
.................... 					{ 
.................... 						__Afficheur_7segments(0); 
0B548:  CLR.B   1B5C
0B54A:  CLR.B   1B5D
0B54C:  CALL    1338
.................... 						__Stop(); 
0B550:  CALL    6D08
.................... 					} 
0B554:  GOTO    B5B8
.................... 					else 
.................... 					{ 
.................... 						 
.................... 	                  	 
.................... 	                  	_Detected = 0; 
0B558:  BCLR.B  85B.0
.................... 		                balise_on = 0; 
0B55A:  BCLR.B  85B.1
.................... 		                Dist_x = 0; 
0B55C:  CLR     1588
.................... 		                Dist_y = 0; 
0B55E:  CLR     158A
.................... 		                Dorient = 0;  
0B560:  CLR     1592
0B562:  CLR     1594
0B564:  CLR     1596
0B566:  CLR     1598
.................... 		                Time_detected=0; 
0B568:  CLR.B   86E
.................... 		                 
.................... 		                Depl_send = 0; 
0B56A:  BCLR.B  85B.5
.................... 						Action_send = 0; 
0B56C:  BCLR.B  85B.7
.................... 						int i; 
.................... 						for(i = 0; i < 10; i++) 
0B56E:  CLR     1B50
0B570:  MOV     1B50,W4
0B572:  CP      W4,#A
0B574:  BRA     GE,B5B0
.................... 						{ 
.................... 							PtsRelai[i][0] = 0; 
0B576:  MOV     1B50,W4
0B578:  MUL.UU  W4,#8,W0
0B57A:  MOV     W0,W5
0B57C:  MOV     #AA6,W4
0B57E:  ADD     W5,W4,W6
0B580:  CLR.B   [W6]
0B582:  MOV.B   #0,W0L
0B584:  MOV.B   W0L,[W6+#1]
0B586:  MOV.B   #0,W0L
0B588:  MOV.B   W0L,[W6+#2]
0B58A:  MOV.B   #0,W0L
0B58C:  MOV.B   W0L,[W6+#3]
.................... 							PtsRelai[i][1] = 0; 
0B58E:  MOV     1B50,W4
0B590:  MUL.UU  W4,#8,W0
0B592:  MOV     W0,W5
0B594:  ADD     W5,#4,W5
0B596:  MOV     W5,W0
0B598:  MOV     #AA6,W4
0B59A:  ADD     W0,W4,W5
0B59C:  CLR.B   [W5]
0B59E:  MOV.B   #0,W0L
0B5A0:  MOV.B   W0L,[W5+#1]
0B5A2:  MOV.B   #0,W0L
0B5A4:  MOV.B   W0L,[W5+#2]
0B5A6:  MOV.B   #0,W0L
0B5A8:  MOV.B   W0L,[W5+#3]
0B5AA:  INC     1B50
0B5AC:  GOTO    B570
.................... 						} 
.................... 	                  	 
.................... 	                  	path_impossible = 1; 
0B5B0:  MOV     #1,W4
0B5B2:  MOV     W4,A86
.................... 	                  	 
.................... 	                  	Etat_rob = Check_ZI; 
0B5B4:  MOV.B   #2,W0L
0B5B6:  MOV.B   W0L,87B
.................... 	                  	 
.................... 	                  	 
.................... 					} 
....................       
.................... 	            	/* 
.................... 	                if(TabObjectifs[(NoObj+1)][1][8]!=10 && TabObjectifs[(NoObj+1)][1][8]!=0)//si obj suivant pond entre 1 et 9 --> on switch l'obj 
.................... 	                { 
.................... 	                   /////////////////// actualisation position x,y /////////////////// 
.................... 	                  __actual_pos();// actualisation de la Pos xy  
....................  
.................... 	                   /////////////////// effacer l'ordre en cours  ///////////////////  
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 0_^MMOD 2 0\r"); //passage en open loop speed 
.................... 	                  delay_ms(10); 
.................... 	                  fprintf(ROBOTEQ,"^MMOD 1 3_^MMOD 2 3\r"); //passage en closed loop count postion 
....................  
.................... 	                   /////////////////// Passage a l'obj suivant  /////////////////// 
.................... 	                  NoObj++; // passage a l'objectif suivant 
.................... 	                  NoPts = 1; // on demarre par le premier pts 
.................... 	                  __LoadObj(NoObj,NoPts);//charge le nouveau pts 
.................... 	                
.................... 	                  if(Pt_commun!=0)//si point pas symetrique 
.................... 	                  { 
.................... 	                  if(Team)//pt droite 
.................... 	                  { 
.................... 	                     if(Pt_commun==1) NoPts++; // passe ÃÂ  l'obj suivant (pt droite) 
.................... 	                  } 
.................... 	                  } 
.................... 	                  Etat_rob = Init; // on recommence le programme 
.................... 	                  _Detected = 0; 
.................... 	                  balise_on = 0; 
.................... 	                  Dist_x = 0; 
.................... 	                  Dist_y = 0; 
.................... 	                  Dorient = 0;  
.................... 	                  _LED2,_LED3,_LED4 = 0; 
.................... 	                  Time_detected=0; 
.................... 	                } 
.................... 	                */ 
....................  
.................... 	            } 
.................... 	        } 
0B5B8:  GOTO    B62C
.................... 	        else if(_Detected && tempo_bal == 4) // si detecte et que l'adv n'est plus la  
0B5BC:  BTSS.B  85B.0
0B5BE:  BRA     B62C
0B5C0:  MOV     872,W4
0B5C2:  CP.B    W4L,#4
0B5C4:  BRA     NZ,B62C
.................... 	        { 
.................... 	             /////////////////// Reprise de l'ordre  ///////////////////          
.................... 	            fprintf(ROBOTEQ,"^MDEC 1 6000_^MDEC 2 6000\r");//on reprend le dernier ordre    
0B5C6:  MOV     #0,W1
0B5C8:  MOV     W1,W0
0B5CA:  CLR.B   1
0B5CC:  CALL    46E
0B5D0:  INC     W1,W1
0B5D2:  BTSC.B  219.1
0B5D4:  BRA     B5D2
0B5D6:  MOV     W0,21A
0B5D8:  MOV     #19,W0
0B5DA:  CPSGT   W1,W0
0B5DC:  BRA     B5C8
.................... 	            fprintf(ROBOTEQ,"!S 1 %u_!S 2 %u\r",oVitMax,oVitMax); 
0B5DE:  MOV     #0,W1
0B5E0:  MOV     W1,W0
0B5E2:  CLR.B   1
0B5E4:  CALL    496
0B5E8:  INC     W1,W1
0B5EA:  BTSC.B  219.1
0B5EC:  BRA     B5EA
0B5EE:  MOV     W0,21A
0B5F0:  MOV     #4,W0
0B5F2:  CPSGT   W1,W0
0B5F4:  BRA     B5E0
0B5F6:  MOV     14A2,W0
0B5F8:  MOV     #0,W4
0B5FA:  CALL    725C
0B5FE:  MOV     #7,W1
0B600:  MOV     W1,W0
0B602:  CLR.B   1
0B604:  CALL    496
0B608:  INC     W1,W1
0B60A:  BTSC.B  219.1
0B60C:  BRA     B60A
0B60E:  MOV     W0,21A
0B610:  MOV     #C,W0
0B612:  CPSGT   W1,W0
0B614:  BRA     B600
0B616:  MOV     14A2,W0
0B618:  MOV     #0,W4
0B61A:  CALL    725C
0B61E:  BTSC.B  219.1
0B620:  BRA     B61E
0B622:  MOV     #D,W4
0B624:  MOV     W4,21A
....................  
.................... 	            Time_detected = 0;  
0B626:  CLR.B   86E
.................... 	            _LED1=0; 
0B628:  BCLR.B  2D0.1
.................... 	            _Detected = 0; 
0B62A:  BCLR.B  85B.0
....................              
.................... 	        } 
.................... 	        _LED1=!_LED1;  
0B62C:  BTG.B   2D0.1
.................... 	        flagBaliseCheck = 0; 
0B62E:  BCLR.B  85A.2
.................... 	    }    
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        UART            ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if(PCh_flagUARTReadyToDecode) __UART_Decode(TabDecoded); 
0B630:  BTSS.B  161B.2
0B632:  BRA     B63C
0B634:  MOV     #1720,W4
0B636:  MOV     W4,1B54
0B638:  CALL    A8C4
....................  
....................  
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		///////////////////////        Fin du prog.    ////////////////////////////////////// 
.................... 		///////////////////////////////////////////////////////////////////////////////////// 
.................... 		if((Flag_end || flagTimeOut || flag_error) && !IsPassedTimeOut) 
0B63C:  BTSC.B  85A.7
0B63E:  BRA     B648
0B640:  BTSC.B  85A.1
0B642:  BRA     B648
0B644:  BTSS.B  85B.2
0B646:  BRA     B6A4
0B648:  BTSC.B  85A.5
0B64A:  BRA     B6A4
.................... 		{ 
.................... 			__Afficheur_7segments(points); 
0B64C:  MOV.B   875,W0L
0B64E:  MOV.B   W0L,1B5C
0B650:  CLR.B   1B5D
0B652:  CALL    1338
....................  
.................... 			IsPassedTimeOut=1; 
0B656:  BSET.B  85A.5
.................... 			// arret moteurs 
.................... 			fprintf(ROBOTEQ, "!EX \r");  
0B658:  MOV     #0,W1
0B65A:  MOV     W1,W0
0B65C:  CLR.B   1
0B65E:  CALL    4B4
0B662:  INC     W1,W1
0B664:  BTSC.B  219.1
0B666:  BRA     B664
0B668:  MOV     W0,21A
0B66A:  MOV     #4,W0
0B66C:  CPSGT   W1,W0
0B66E:  BRA     B65A
.................... 			driver_Pompes(0xA0,0,0,0,0,0); 
0B670:  MOV.B   #A0,W0L
0B672:  MOV.B   W0L,1B60
0B674:  CLR.B   1B61
0B676:  CLR.B   1B62
0B678:  CLR.B   1B63
0B67A:  CLR.B   1B64
0B67C:  CLR.B   1B65
0B67E:  CALL    107C
.................... 			driver_moteur(0xC0,0); 
0B682:  MOV.B   #C0,W0L
0B684:  MOV.B   W0L,1B5C
0B686:  CLR.B   1B5D
0B688:  CALL    11BE
.................... 			driver_moteur(0xC2,0); 
0B68C:  MOV.B   #C2,W0L
0B68E:  MOV.B   W0L,1B5C
0B690:  CLR.B   1B5D
0B692:  CALL    11BE
.................... 			driver_moteur(0xC4,0); 
0B696:  MOV.B   #C4,W0L
0B698:  MOV.B   W0L,1B5C
0B69A:  CLR.B   1B5D
0B69C:  CALL    11BE
.................... 			Etat_rob = Wait_end; 
0B6A0:  MOV.B   #8,W0L
0B6A2:  MOV.B   W0L,87B
.................... 		} 
0B6A4:  GOTO    B04E
.................... 		 
.................... 	} 
.................... } 
....................  
....................  
.................... /** 
.................... * \fn void TIMER1_isr(void) 
.................... * \author Amand Axel 
.................... * \version 2.0 
.................... * \date 19.10.2015 
.................... * 
.................... * \brief Met ÃÂ  jour la pose, gÃÂ¨re le profil trapÃÂ©zoÃÂ¯dal et le PID 
.................... *		 S'active chaque 1 [ms] 
.................... * 
.................... */ 
.................... #INT_TIMER1 HIGH 
.................... void TIMER1_isr(void) 
*
00AE2:  PUSH    42
00AE4:  PUSH    36
00AE6:  PUSH    32
00AE8:  MOV     W0,[W15++]
00AEA:  MOV     #2,W0
00AEC:  REPEAT  #C
00AEE:  MOV     [W0++],[W15++]
*
0B6A8:  BRA     B6A8
.................... { 
.................... 	// Compte le temps rÃÂ©el 
.................... 	RealTimeMS ++; 
*
00AF0:  INC     0862
00AF2:  BTSC.B  42.1
00AF4:  INC     0864
.................... 	// Temps de jeu 
.................... 	if(BeginTimeMS!=0) 
00AF6:  CP0     866
00AF8:  BRA     NZ,AFE
00AFA:  CP0     868
00AFC:  BRA     Z,B2A
.................... 	{ 
.................... 		GameTimeMS=RealTimeMS-BeginTimeMS; 
00AFE:  MOV     862,W4
00B00:  MOV     866,W3
00B02:  SUB     W4,W3,W0
00B04:  MOV     W0,86A
00B06:  MOV     864,W4
00B08:  MOV     868,W3
00B0A:  SUBB    W4,W3,W0
00B0C:  MOV     W0,86C
.................... 		if(GameTimeMS%1000==0)GameTimeS++; 
00B0E:  BSET.B  43.0
00B10:  MOV     86A,W0
00B12:  MOV     86C,W1
00B14:  MOV     #3E8,W2
00B16:  MOV     #0,W3
00B18:  CALL    A8E
00B1C:  MOV     W0,W5
00B1E:  MOV     W1,W6
00B20:  CP0     W5
00B22:  BRA     NZ,B2A
00B24:  CP0     W6
00B26:  BRA     NZ,B2A
00B28:  INC.B   0861
.................... 	}	 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	//////////////////////////////////	TASK GIVER	//////////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// Balise ÃÂ  checker 
.................... 	if(GameTimeS == 92) FlagGameEnd = 1;  
00B2A:  MOV     860,W4
00B2C:  LSR     W4,#8,W4
00B2E:  XOR.B   #5C,W4L
00B30:  BRA     NZ,B34
00B32:  BSET.B  85A.0
.................... 	if(BeginTimeMS!=0 && GameTimeMS%TIME_TO_CHECK_BAL==0) 
00B34:  CP0     866
00B36:  BRA     NZ,B3C
00B38:  CP0     868
00B3A:  BRA     Z,B58
00B3C:  BSET.B  43.0
00B3E:  MOV     86A,W0
00B40:  MOV     86C,W1
00B42:  MOV     14B8,W2
00B44:  MOV     #0,W3
00B46:  CALL    A8E
00B4A:  MOV     W0,W5
00B4C:  MOV     W1,W6
00B4E:  CP0     W5
00B50:  BRA     NZ,B58
00B52:  CP0     W6
00B54:  BRA     NZ,B58
.................... 	{ 
.................... 		// Check Balise 
.................... 		flagBaliseCheck=1; 
00B56:  BSET.B  85A.2
.................... 	} 
.................... 	if(BeginTimeMS!=0 && GameTimeMS%500==0)ToDisplay=!ToDisplay; 
00B58:  CP0     866
00B5A:  BRA     NZ,B60
00B5C:  CP0     868
00B5E:  BRA     Z,B7C
00B60:  BSET.B  43.0
00B62:  MOV     86A,W0
00B64:  MOV     86C,W1
00B66:  MOV     #1F4,W2
00B68:  MOV     #0,W3
00B6A:  CALL    A8E
00B6E:  MOV     W0,W5
00B70:  MOV     W1,W6
00B72:  CP0     W5
00B74:  BRA     NZ,B7C
00B76:  CP0     W6
00B78:  BRA     NZ,B7C
00B7A:  BTG.B   85A.4
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////	WATCHDOG INTERRUPTS	//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// WD Times 
.................... 	static unsigned int16 UART_WD_TIME=0; 
.................... 	 
.................... 	// Watchdog UART, rÃÂ©initialise la capture 
.................... 	if(PCh_flagUARTWatchdog==1) 
00B7C:  BTSS.B  161B.3
00B7E:  BRA     B9A
.................... 	{ 
.................... 		UART_WD_TIME++; 
00B80:  INC     1B4A
.................... 		if(UART_WD_TIME>=UART_WD_DELAY) 
00B82:  MOV.B   14B0,W0L
00B84:  CLR.B   1
00B86:  MOV     1B4A,W4
00B88:  CP      W4,W0
00B8A:  BRA     NC,B96
.................... 		{ 
.................... 			// Reset UART 
.................... 			ToDoUART = 0; 
00B8C:  CLR.B   171F
.................... 			PosTabToDecode=0; 
00B8E:  CLR.B   171E
.................... 			UARTToSendBack=0; 
00B90:  CLR.B   1B20
.................... 			UARTWaitResp=0; 
00B92:  BCLR.B  161B.4
.................... 			// Desactive le watchdog UART 
.................... 			PCh_flagUARTWatchdog = 0; 
00B94:  BCLR.B  161B.3
.................... 		} 
.................... 	} 
00B96:  GOTO    B9C
.................... 	else UART_WD_TIME=0; 
00B9A:  CLR     1B4A
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	////////////////////////////		PROGRAM END		//////////////////////////////// 
.................... 	//////////////////////////////////////////////////////////////////////////////////// 
.................... 	// AprÃÂ¨s 1min30, on arrÃÂªte les ÃÂ©lÃÂ©ments essentiels 
.................... 	if(BeginTimeMS!=0 && GameTimeS>=98) 
00B9C:  CP0     866
00B9E:  BRA     NZ,BA4
00BA0:  CP0     868
00BA2:  BRA     Z,BB0
00BA4:  MOV     860,W4
00BA6:  LSR     W4,#8,W4
00BA8:  MOV     #62,W3
00BAA:  CP.B    W3L,W4L
00BAC:  BRA     GTU,BB0
.................... 	{ 
.................... 		flagTimeOut=1; 
00BAE:  BSET.B  85A.1
.................... 	} 
.................... 	// AprÃÂ¨s la fin de jeu, on ouvre le parasol  
.................... 	if(BeginTimeMS!=0 && GameTimeS>=92) 
00BB0:  CP0     866
00BB2:  BRA     NZ,BB8
00BB4:  CP0     868
00BB6:  BRA     Z,BC2
00BB8:  MOV     860,W4
00BBA:  LSR     W4,#8,W4
00BBC:  MOV     #5C,W3
00BBE:  CP.B    W3L,W4L
00BC0:  BRA     GTU,BC2
.................... 	{ 
.................... 		//flagGameEnd=1; 
.................... 	}	 
.................... } 
....................  
.................... //////////////////////////////////////// 
.................... //// Timer de clignotement d'erreur. //// 
.................... //////////////////////////////////////// 
00BC2:  BCLR.B  84.3
00BC4:  MOV     #1A,W0
00BC6:  REPEAT  #C
00BC8:  MOV     [--W15],[W0--]
00BCA:  MOV     [--W15],W0
00BCC:  POP     32
00BCE:  POP     36
00BD0:  POP     42
00BD2:  RETFIE  
.................... #INT_TIMER3 
.................... void TIMER3_isr(void) 
00BD4:  PUSH    42
00BD6:  PUSH    36
00BD8:  PUSH    32
00BDA:  MOV     W0,[W15++]
00BDC:  MOV     #2,W0
00BDE:  REPEAT  #C
00BE0:  MOV     [W0++],[W15++]
.................... { 
.................... 	static int1 On_Off_Error = 0; 
.................... 	 
.................... 	// Si doit afficher une erreur 
.................... 	if(flagError) 
00BE2:  BTSS.B  85A.3
00BE4:  BRA     BE8
.................... 	{ 
.................... 	//	__Afficheur_7segments(NO_ERROR,On_Off_Error); 
.................... 		On_Off_Error =! On_Off_Error; 
00BE6:  BTG.B   161B.5
.................... 	}	 
00BE8:  BCLR.B  84.7
00BEA:  MOV     #1A,W0
00BEC:  REPEAT  #C
00BEE:  MOV     [--W15],[W0--]
00BF0:  MOV     [--W15],W0
00BF2:  POP     32
00BF4:  POP     36
00BF6:  POP     42
00BF8:  RETFIE  
.................... }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

Configuration Fuses:
   Word  1L: C712   HS2_PLL8
          H: FF00  
   Word  2L: 003F   WPSB16 WPSA512 NOWDT
          H: FF00  
   Word  3L: 8030   NOPUT BORRES NOBROWNOUT MCLR
          H: FF00  
   Word  4L: 310F   NOWRTB NOBSS NOEBS NORBS
          H: FF00  
   Word  5L: 330F   NOWRTSS NOSSS NOESS NORSS
          H: FF00  
   Word  6L: 0007   NOWRT NOPROTECT
          H: FF00  
   Word  7L: 4003   ICSP1 DEBUG
          H: FF00  

   Some fuses have been forced to be compatible with the ICD debugger.
